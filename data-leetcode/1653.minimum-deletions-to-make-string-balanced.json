[
    {
        "title": "Defuse the Bomb",
        "question_content": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code&nbsp;of length of n&nbsp;and a key k.\nTo decrypt the code, you must replace every number. All the numbers are replaced simultaneously.\n\n\tIf k > 0, replace the ith number with the sum of the next k numbers.\n\tIf k < 0, replace the ith number with the sum of the previous k numbers.\n\tIf k == 0, replace the ith number with 0.\n\nAs code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].\nGiven the circular array code and an integer key k, return the decrypted code to defuse the bomb!\n&nbsp;\nExample 1:\n\nInput: code = [5,7,1,4], k = 3\nOutput: [12,10,16,13]\nExplanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.\n\nExample 2:\n\nInput: code = [1,2,3,4], k = 0\nOutput: [0,0,0,0]\nExplanation: When k is zero, the numbers are replaced by 0. \n\nExample 3:\n\nInput: code = [2,4,9,3], k = -2\nOutput: [12,5,6,13]\nExplanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.\n\n&nbsp;\nConstraints:\n\n\tn == code.length\n\t1 <= n&nbsp;<= 100\n\t1 <= code[i] <= 100\n\t-(n - 1) <= k <= n - 1",
        "solutions": [
            {
                "id": 935398,
                "title": "java-o-n-100-time-and-space-short-concise-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] res = new int[code.length];\\n        if (k == 0) return res;\\n        //Define the initial window and initial sum\\n        int start = 1, end = k, sum = 0;\\n        if (k < 0) {//If k < 0, the starting point will be end of the array.\\n            k = -k;\\n            start = code.length - k;\\n            end = code.length - 1;\\n        }\\n        for (int i = start; i <= end; i++) sum += code[i];\\n        //Scan through the code array as i moving to the right, update the window sum.\\n        for (int i = 0; i < code.length; i++) {\\n            res[i] = sum;\\n            sum -= code[(start++) % code.length];\\n            sum += code[(++end) % code.length];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948726,
                "title": "c-sliding-window-linear-time-and-constant-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t// Taking a window of k elements\\n\\t\\t\\n\\t\\t// First window will be from index 1 to index k\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n\\t\\t   // if k is negative then the first window will be the last k elements\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        // maintaining first window\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            // sliding the window \\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935444,
                "title": "clean-python-3-prefix-sum-o-n",
                "content": "Use the prefix sum trick to get range sum in O(1)\\nTime: `O(N)`\\nSpace: `O(N)`\\nThanks @WangQiuc\\'s suggestion.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\\n\\nOne pass\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(1, 2 * n):\\n            prefix[i] += prefix[i - 1]\\n        for i in range(n):\\n            code[i] = prefix[i + k] - prefix[i]\\n        return code\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        n = len(code)\\n        prefix = code * 2\\n        for i in range(2 * n):\\n            prefix[i] += i > 0 and prefix[i - 1]\\n            if k <= i < n + k:\\n                code[i - k] = prefix[i] - prefix[i - k]\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936749,
                "title": "pyhton3-beats-100-double-the-code-array",
                "content": "Double the ```code``` array so that it\\'s easy to iterate.\\n```class Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k==0: return [0 for i in code]\\n        temp = code\\n        code = code*2\\n        for i in range(len(temp)):\\n            if k>0:\\n                temp[i] = sum(code[i+1:i+k+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        return temp",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```code```",
                "codeTag": "Unknown"
            },
            {
                "id": 935478,
                "title": "python-3-clean-sliding-window",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```\\n\\n- for negative k: reverse params and result\\n- calculate sum of k element, then iteratively add new element and remove oldest one.\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0: return self.decrypt(code[::-1], -k)[::-1]\\n        \\n        n = len(code)\\n        ret = [0] * n\\n        s = sum(code[:k])\\n        for i, c in enumerate(code):\\n            s += code[(i + k) % n] - c\\n            ret[i] = s\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935457,
                "title": "my-short-easy-to-understand-solution",
                "content": "To deal with this kind of problem, we need to play with the index wisely and carefully, just like defusing a bomb (lol). There are 3 points we need to notice:\\n\\n0. We need to return the result directly if k == 0 based on the problem statement. (I will handle this case specifically, to make it more readable and slightly faster :) )\\n1. We need to do ***%*** to make sure the index is always in-bound when k > 0;\\n2. We need to do ***+code.length*** to make sure it is alway > 0, and ***%*** to make sure the index is always in-bound when k < 0.\\n\\nHere is my code: \\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```\\n\\nPlease upvote if you find this is helpful! :)",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint[] result = new int[code.length];\\n\\tif (k == 0) {\\n\\t\\treturn result;\\n\\t}\\n\\tfor (int i = 0; i < result.length; i++) {\\n\\t\\tif (k > 0) {\\n\\t\\t\\tfor (int j = i + 1; j < i + k + 1; j++) {\\n\\t\\t\\t\\tresult[i] += code[j % code.length];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = i - 1; j > i + k - 1; j--) {\\n\\t\\t\\t\\tresult[i] += code[(j + code.length) % code.length];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942580,
                "title": "c-easy-solution-brute-force",
                "content": "if you don\\'t know how this code works,you could comment below.\\nI will try my best to answer your question! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int>Ans(code.size(),0);\\n        \\n        for(int i = 0;i<code.size();i++){\\n            if (k > 0){\\n                int total = 0;\\n                for(int count = 1;count<=k;count++){\\n                    int num = i + count;\\n                    num = num % code.size(); \\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else if (k < 0){\\n                int total = 0;\\n                for(int count = -1;count>=k;count--){\\n                    int num = i + count;\\n                    if (num < 0){\\n                        num = code.size() + num;\\n                    }\\n                    total += code[num];\\n                }\\n                Ans[i] = total;\\n            }\\n            else{\\n                Ans[i] = 0;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218554,
                "title": "very-easy-solution-explained-with-sample-implementation-break-the-cycle-prefix-suffix-sum",
                "content": "*------Please **upvote** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION:**\\n\\n**Prerequisites -** *Prefix Sum* and *Suffix Sum* of an Array.\\n\\nFirst, we **simplify** the problem by **breaking the cycle.** \\n\\n*****How?*****  Just append the array to itself and the cycle will be broken into a linear array.\\n\\nTake the sample input array **code** as: **[5, 7, 1, 4]**\\nAppending it to itself, we get our new array **arr** as: **[5, 7, 1, 4, 5, 7, 1, 4]**.  We will now use this array for calculation.\\n\\n1. If **k = 0**: Just change all array elements of **code** to **0** and return **code**.\\n\\n2. If **k > 0**:  We calculate the **prefix** sum array **pre** of **arr** and our result for every index **i** would be **pre [i + k] - pre [i]**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**pre:** `[5, 12, 13, 17, 22, 29, 30, 34]`\\n\\n**k = 2**\\n\\nNow, for every index **i**: **code [i]** will become **pre [i + 2] - pre [i]**.\\n\\n**i = 0**: `code [0]` = `pre [0 + 2] - pre [0]` = `pre [2] - pre [0]` = **8**\\n**i = 1**: `code [1]` = `pre [1 + 2] - pre [1]` = `pre [3] - pre [1]` = **5**\\n**i = 2**: `code [2]` = `pre [2 + 2] - pre [2]` = `pre [4] - pre [2]` = **9**\\n**i = 3**: `code [3]` = `pre [3 + 2] - pre [3]` = `pre [5] - pre [3]` = **12**\\n\\nReturn **code** as **`[8, 5, 9, 12]`**\\n\\n3. If **k < 0**:  We calculate the **suffix** sum array **suf** of **arr** and our result for every index **i** would be **suf [i + n - k] - suf [i + n]** where **`n = length (code)`**.  Sample implementation:\\n\\n**arr:** `[5, 7, 1, 4, 5, 7, 1, 4]`\\n**suf:** `[34, 29, 22, 21, 17, 12, 5, 4]`\\n\\n**k = -2**\\n\\nHere, we will proceed in the reverse order (right - to - left) because the suffix sum is calculated from the right - to - left direction.\\n\\nNow, for every index **i**: **code [i]** will become **suf [i + 4 - 2] - suf [i + 4]**.\\n\\n**i = 3**: `code [3]` = `suf [3 + 4 - 2] - suf [3 + 4]` = `suf [5] - suf [7]` = **8**\\n**i = 2**: `code [2]` = `suf [2 + 4 - 2] - suf [2 + 4]` = `suf [4] - suf [6]` = **12**\\n**i = 1**: `code [1]` = `suf [1 + 4 - 2] - suf [1 + 4]` = `suf [3] - suf [5]` = **9**\\n**i = 0**: `code [0]` = `suf [0 + 4 - 2] - suf [0 + 4]` = `suf [2] - suf [4]` = **5**\\n\\nReturn **code** as **`[5, 9, 12, 8]`**\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = 0;\\n        }\\n        \\n        else if (k > 0) {\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int prefix [] = new int [arr.length];\\n            prefix [0] = arr [0];\\n            for (int i = 1; i < prefix.length; i++)\\n                prefix [i] = prefix [i-1] + arr [i];\\n            for (int i = 0; i < code.length; i++)\\n                code [i] = prefix [i + k] - prefix [i];\\n        }\\n        \\n        else {\\n            k = Math.abs (k);\\n            int arr [] = new int [code.length * 2];\\n            for (int i = 0; i < code.length; i++) {\\n                arr [i] = code [i];\\n                arr [i + code.length] = code [i];\\n            }\\n            int suffix [] = new int [arr.length];\\n            suffix [arr.length - 1] = arr [arr.length - 1];\\n            for (int i = suffix.length - 2; i >= 0; i--)\\n                suffix [i] = suffix [i+1] + arr [i];\\n            for (int i = code.length - 1; i >= 0; i--)\\n                code [i] = suffix [i + code.length - k] - suffix [i + code.length];\\n        }\\n        \\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947553,
                "title": "java-o-n-using-prefix-sum-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] presum = new int[code.length];\\n        int[] postsum = new int[code.length];\\n\\t\\t\\n\\t\\t//Create prefix sum array\\n        int sum = 0;\\n        for(int i=0; i<code.length; ++i){\\n            sum += code[i];\\n            presum[i] = sum;\\n        }\\n        \\n\\t\\t//Create prefix sum array in reverse\\n        sum=0;\\n        for(int i=code.length-1; i>=0; --i){\\n            sum += code[i];\\n            postsum[i] = sum;\\n        }\\n        \\n        for(int i=0; i<code.length; ++i){\\n            if(k > 0){\\n                if((i+k) < code.length){\\n                    code[i] = presum[i+k]-presum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//presum[code.length-1] - presum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//presum[k-(code.length -i)]; --> Elements left of i\\n                    code[i] = presum[code.length-1] - presum[i] + presum[k-(code.length -i)];\\n                }   \\n            }else if(k == 0){\\n                code[i] = 0;\\n            }else{\\n                if(i+k >= 0){\\n                    code[i] = postsum[i+k] - postsum[i];\\n                }else{\\n\\t\\t\\t\\t\\t//postsum[0] - postsum[i]  --> Elements right of i\\n\\t\\t\\t\\t\\t//postsum[code.length+(i+k)] --> Elements left of i\\n                    code[i] = postsum[0] - postsum[i] + postsum[code.length+(i+k)];\\n                }\\n            }\\n        }\\n\\t\\t\\n        return code;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285276,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int[] decrypt(int[] code, int k) {\\n        int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153936,
                "title": "simple-and-easy",
                "content": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\noutput = []\\nfor i in range(len(code)):\\n\\tif k > 0:\\n\\t\\tsum = 0\\n\\t\\tj = i+1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm-=1\\n\\t\\t\\tj+=1\\n\\t\\toutput.append(sum)\\n\\n\\telif k == 0:\\n\\t\\toutput.append(0)\\n\\n\\telse:\\n\\t\\tsum = 0\\n\\t\\tj = i-1\\n\\t\\tm = k\\n\\t\\twhile(m):\\n\\t\\t\\tsum+=code[j%len(code)]\\n\\t\\t\\tm+=1\\n\\t\\t\\tj-=1\\n\\t\\toutput.append(sum)\\n\\nreturn output\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008102,
                "title": "go-o-n-0ms-2-3mb-sliding-window-with-wrapping-indexes",
                "content": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    n := len(code)\\n    result := make([]int, n)\\n    if k == 0 {\\n        return result\\n    }\\n    start, end := 1, k + 1\\n    if k < 0 {\\n        start, end  =  n + k, n\\n    }\\n    s := 0\\n    for i := start; i < end; i++ {\\n        s += code[i]\\n    }\\n    for i := 0; i < n; i++ {\\n        result[i] = s\\n        s = s - code[(start + i) % n] + code[(end + i) % n]\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942554,
                "title": "java-o-n-clear-explanation-beats-100",
                "content": "The idea is that for each index i, we will need to be able to query the sum of the next or prev k numbers - an easy way to achieve this is to cache the prefix sums.\\n\\nHowever, there is the added complexity of circular array so we can simply create a prefix sum array that is twice the normal length. Essentially caching the prefix sums of the array repeated.\\n\\ni.e. For something like A = [1,2,3,4], we can concatentate it with itself to create B = [1,2,3,4,1,2,3,4] so that it is easier to work with when applying circular things. \\n\\nWhen working with A, if k = 3 and i = 1, then normally we would have an add indexes 2, 3 and 4. However, index 4 would in fact be index 0 since we are working with a circular array. With our concatenated array B, we would be able to directly access index 4.\\n\\nTaking this concept 1 step further, we can then prefix sum cache this concatenated version which gives us a prefix sum cache that can find circular ranges. So if k < 0, we can find the range sum of [i-k, i-1] and if k > 0, we can find the range sum of [i+1, i+k].\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if(k == 0) return new int[code.length];\\n        \\n        int[] prefix = new int[code.length * 2 + 1];\\n        for(int i = 0; i < code.length * 2; i++) {\\n            prefix[i+1] = prefix[i] + code[i % code.length];\\n        }\\n        \\n        int[] ret = new int[code.length];\\n        for(int i = 0; i < code.length; i++) {\\n            int end = i + k;\\n            if(k < 0) {\\n                ret[i] = prefix[i + code.length] - prefix[end + code.length];\\n            }\\n            else {\\n                ret[i] = prefix[end + 1] - prefix[i+1];\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352139,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        l = code + code\\n        if k == 0:\\n            return [0]*n\\n        elif k > 0:\\n            ans = []\\n            for i in range(n):\\n                ans.append(sum(l[i+1:i+k+1]))\\n            return ans\\n        else:\\n            ans = []\\n            j = n\\n            for i in range(n):\\n                ans.append(sum(l[j+k:j]))\\n                j += 1\\n            return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971143,
                "title": "javascript-simple",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    var res = new Array(code.length).fill(0)\\n    if (k > 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i + 1\\n            while(count < k){\\n                if (j === code.length) j = 0\\n                res[i] += code[j]\\n                count = count + 1\\n                j++\\n            }\\n        }\\n    }\\n    if (k < 0){\\n            for(var i = 0; i < code.length; i++){\\n            var count = 0\\n            var j = i - 1\\n            while(count > k){\\n                if (j === -1) j = code.length - 1\\n                res[i] += code[j]\\n                count = count - 1\\n                j--\\n            }\\n        }\\n    }\\n    return res \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367476,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int i, j, m, num;\\n        vector<int> ans;\\n        for(i=0 ; i<code.size() ; i++)\\n        {\\n            num=0;\\n            j = i;\\n            m = abs(k);\\n            while(m--)\\n            {\\n                if(k<0)\\n                {\\n                    j = j-1;\\n                    if(j<0)\\n                        j += code.size();\\n                    num += code[j];\\n                }\\n                else if(k>0)\\n                {\\n                    j = j+1;\\n                    if(j>=code.size())\\n                        j -= code.size();\\n                    num += code[j];\\n                }\\n            }\\n            ans.push_back(num);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482725,
                "title": "defuse-the-bomb",
                "content": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n\\t\\t\\tlength = len(code) \\n\\t\\t\\tans=[0 for i in range(length)] \\n\\n\\t\\t\\tif k==0:  return ans \\n\\n\\t\\t\\tif k < 0:  code.reverse() \\n\\n\\t\\t\\tsumm = sum(code[:abs(k)])\\n\\n\\t\\t\\tfor i in range(length):\\n\\t\\t\\t\\t\\tsumm = summ-code[i]+code[(i+abs(k))%length]   \\n\\t\\t\\t\\t\\tans[i] = summ \\n\\n\\t\\t\\treturn reversed(ans) if k<0 else ans  \\n\\t\\t\\t\\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1903674,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0] * len(code)\\n        data = code + code\\n        result = [sum(data[i + 1: i + 1 + abs(k)]) for i in range(len(code))]\\n\\t\\t# result = []\\n        # for i in range(len(code)):\\n        #     result.append(sum(data[i + 1: i + 1 + abs(k)]))\\n        if 0 > k:\\n            return result[k - 1:] + result[:k - 1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384496,
                "title": "c-solution-simple-approach",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n    vector<int> ans;\\n    int n=code.size();\\n    if (k > 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + 1, temp = 0;\\n            while (temp++ != k)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else if (k < 0)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            int sum = 0, j = i + k + n, temp = k;\\n            while (temp++ != 0)\\n                sum += code[j++ % n];\\n            ans.push_back(sum);\\n        }\\n    }\\n    else\\n        for (int i = 0; i < n; i++)\\n            ans.push_back(0);\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152661,
                "title": "python-3-o-n-sliding-window-with-array-rotation",
                "content": "# Intuition\\nOn close inspection we find that K<0 case solution is just a rotated form of K>0 solution\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReturn 0 array for k==0 case and for other case find the next k sum array by sliding window technique and in case the k value is negative then rotate the ans list by k-1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ans=[]\\n        s=0\\n        if k==0:\\n            ans = [0]*len(code)\\n        else:\\n            absK=abs(k)\\n            s=sum(code[0:absK])\\n            for i in range(len(code)):\\n                s=s-code[i]+code[(i+absK)%len(code)]\\n                ans.append(s)\\n            if k<0:\\n                ans=ans[k-1:]+ans[:k-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933571,
                "title": "java-sliding-window-explained",
                "content": "**Idea:** Use a sliding window to maintain sum\\n>**T/S:** O(n)/O(1), where n = size(code), (ignoring space for output)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tvar n = code.length;\\n\\treturn k > 0 \\n\\t\\t ? decrypt(code, new int[n], k, 1, k + 1) \\n\\t\\t : decrypt(code, new int[n], k, n + k, n);\\n}\\n\\n// [left, right)\\nprivate int[] decrypt(int[] code, int[] decode, int k, int left, int right) {\\n\\tif (k == 0)\\n\\t\\treturn decode;\\n\\t\\t\\n\\tvar sum = decode[0] = Arrays.stream(code, left, right).sum();\\n\\t\\n\\tfor (int i = 1, n = decode.length; i < n; i++, left++, right++)\\n\\t\\tdecode[i] = sum += code[right % n] - code[left % n];\\n\\t\\n\\treturn decode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819345,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int n=code.size();\\n        vector<int>res(n,0);\\n        \\n        if(k==0)\\n            return res;\\n        \\n\\t\\t\\n        int start=1,end=k;\\n        if(k<0)\\n        {\\n            k*=-1;\\n            start=n-k;\\n            end=n-1;\\n        }\\n        int sum=0;\\n        for(int i=start;i<=end;i++)\\n            sum+=code[i];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=sum;\\n            sum-=code[(start++)%n];\\n            sum+=code[(++end)%n];\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599513,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }\\n            j--;\\n        }else{\\n            while(++k<=0){\\n                sum+=code[j--]; \\n            }\\n            j++;\\n            int temp=j;\\n            j=i;\\n            i=temp;\\n        }\\n        \\n        for(int p=0;p<code.length;p++){\\n            res[p]=sum;\\n          //  System.out.println(i+\" \"+j);\\n            j=(j+1)%code.length;\\n            sum=sum+(code[j]-code[i]);\\n            i=(i+1)%code.length;\\n        }\\n        return res;\\n    }\\n}\\nPlease upvote if you like the solution \\uD83D\\uDE4F",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int res[]=new int[code.length];\\n        if(k==0) return res;\\n        int i= (k>0) ? 1 : code.length-1;\\n        int j=i;\\n        int sum=0;\\n        if(k>0){\\n            while(--k>=0)\\n            {\\n               sum+=code[j++]; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2304860,
                "title": "defuse-the-bomb-solution-in-c",
                "content": "**Here You Go =>**\\n\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    int* result=malloc(codeSize*sizeof(int));\\n    int n1,sum;\\n    if (k>0){\\n        for (int i=0;i<codeSize;i++){           // To cover all elements in code array\\n            for (int j=1;j<=k;j++){             // Cover elements till k\\n                n1=code[(i+j)%codeSize];        // As it is a circular array, modulo by size of code array will give the desired result.\\n                                                // I recommend to DRY-RUN this line for Example in description to understand the working.\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;                               // Initialize n1 and sum to zero for next iteration.\\n            sum=0;\\n        }\\n    }\\n    \\n    // For k=0\\n    else if(k==0){\\n        for (int i=0;i<codeSize;i++)\\n            result[i]=0;                        // For k=0, simply initalize all elements in code array with 0\\n    }\\n    \\n    // For k<0\\n    else{\\n        for (int i=0;i<codeSize;i++){\\n            for (int j=1;j<=abs(k);j++){\\n                n1=code[(i+codeSize-j)%codeSize];       // Logic for negative k\\'s is almost same as of above. DRY-RUN this line of code for better understanding\\n                sum+=n1;\\n            }\\n            result[i]=sum;\\n            n1=0;\\n            sum=0;\\n        }   \\n    }\\n    *returnSize=codeSize;\\n    return result;              // Return the resultant array\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2256306,
                "title": "c-straightforward-modulo",
                "content": "![image](https://assets.leetcode.com/users/images/7d3784bc-ac6c-4d88-82be-bd82375afbbc_1657312778.1436577.png)\\n\\n**T->O(n * k) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tfor(int j=i-1;count<abs(k);j--){\\n\\t\\t\\t\\t\\t\\tif(j==-1)j=n-1;\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> decrypt(vector<int>& code, int k) {\\n\\t\\t\\tint n=code.size();\\n\\t\\t\\tvector<int>ans(n,0);\\n\\t\\t\\tif(k==0)return ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tif(k>0){\\n\\t\\t\\t\\t\\tfor(int j=(i+1)%n;count<k;j=(j+1)%n){\\n\\t\\t\\t\\t\\t\\tans[i]+=code[j];\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2179759,
                "title": "c-100-fast-0ms-easy-to-understand",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n         \\n         if(k==0)\\n             return ans;\\n         \\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0;\\n            int sum=0;\\n            int count=k;\\n            if(k>0)\\n            {\\n                 j=i+1;\\n                while(count--)\\n                {\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)\\n                   j=n-1;\\n                else\\n                   j=i-1;\\n                \\n                while(count++)\\n                {\\n                    sum+=code[j];\\n                    if(j==0)\\n                        j=n-1;\\n                    else\\n                        j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1674760,
                "title": "java-1ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len=code.length;\\n        int arr[]=new int[len];\\n        if(k==0)\\n            return arr;\\n        if(k>0)\\n        for(int i=0;i<len;i++)\\n        {\\n            int sum=0;\\n            for(int j=1;j<=k;j++)\\n            {\\n                sum+=code[(j+i)%len];\\n            }\\n            arr[i]=sum;\\n        }\\n        if(k<0)\\n        {\\n            k=-1*k;\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=1;j<=k;j++)\\n                {\\n                    sum+=code[(len-j+i)%len];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172514,
                "title": "python-beats-99-using-modulus",
                "content": "```\\n```\\nr=[]\\n        n=len(code)\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(n):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(n):\\n                e=i+k\\n                if e>0:\\n                    x=sum(code[e:i])\\n                else:\\n                    x=sum(code[:i])+sum(code[n+e:])\\n                r.append(x)\\n            return r\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114282,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        a = code.copy()\\n        res = []\\n        if k==0:\\n            return [0]*n\\n        elif k>0:\\n            a += code\\n            for i in range(n):\\n                res.append(sum(a[i+1:i+k+1]))\\n        else:\\n            a = code+a\\n            k =abs(k)\\n            for i in range(n,len(a)):\\n                res.append(sum(a[i-k:i]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010869,
                "title": "java-sum",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }\\n        }else if(k<0){\\n            k=-k;\\n            for(int i=0; i<len; i++){\\n                if(i-k>=0)\\n                    res[i] = sum[i]-sum[i-k];\\n                else\\n                    res[i] += sum[i]+sum[len]-sum[len-k+i];\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] sum = new int[len+1];\\n        int[] res = new int[len];\\n        for(int i=0; i<len; i++)\\n            sum[i+1] = sum[i] + code[i];\\n        if(k>0){\\n            for(int i=0; i<len; i++){\\n                if(i+k<len)\\n                    res[i] = sum[i+k+1]-sum[i+1];\\n                else\\n                    res[i] += sum[len]-sum[i+1]+sum[k-len+i+1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 941890,
                "title": "simple-5-line-python-faster-than-100-with-comments",
                "content": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def decrypt(self, num: List[int], k: int) -> List[int]:\\n        n, w = len(num), abs(k)\\n        sums = [sum(num[1:w+1])]*n                      # sums[i] is the sum of a window of size |k| after i\\n        for i in range(1,n):\\n            sums[i] = sums[i-1] + num[(i+w)%n] - num[i]\\n        return sums if k>=0 else sums[~w:]+sums[:~w]    # if k is negative all we need to do is shift the sums to the right by |k|\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938895,
                "title": "javascript-sliding-window",
                "content": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decrypt = (code, k) => {\\n  \\n  const decode = (code, k) => {\\n    const result = [];\\n    let sum = 0;\\n    for(let i = 0; i < k; i++)\\n      sum += code[i];\\n    \\n    for(let i = 0 ; i < code.length; i++){\\n      sum -= code[i];\\n      sum += code[(i+k) % code.length];\\n      result.push(sum);\\n    }\\n    return result;\\n  }\\n  \\n  return k > 0 ? decode(code,k) : decode(code.reverse(), -k).reverse();\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936310,
                "title": "c-presum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int N = code.size();\\n        vector<int> Sum(code), ans(N);\\n        for(int i=1; i<N; ++i) Sum[i] = Sum[i-1] + code[i];\\n        for(int i=0; i<N; ++i) {\\n            int start = (i + N + (k < 0 ? k - 1 : 0)) % N;\\n            int end = (i + N + (k > 0 ? k : -1)) % N;\\n            if(!k) ans[i] = 0;\\n            else if(start < end) ans[i] = Sum[end] - Sum[start];\\n            else                 ans[i] = Sum[end] + (Sum[N-1] - Sum[start]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935724,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        res = [0] * n\\n        if k > 0:\\n            res[0] = sum(code[1 : k + 1])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[(i + k) % n] - code[i]\\n        elif k < 0:\\n            res[0] = sum(code[n + k : n])\\n            for i in range(1, n):\\n                res[i] = res[i - 1] + code[i - 1] - code[(n + k + i - 1) % n]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935407,
                "title": "c-easy-solution-100-faster-100-less-space",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> decrypt(vector<int> &code, int k)\\n    {\\n        vector<int> res(code.size(), 0);\\n        int it; // count of k values while doing sum\\n        if (k == 0)\\n            return res;\\n        else\\n        {\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                it = 0;\\n                if (k > 0)\\n                {\\n                    for (int j = i + 1; it < k; j++)\\n                    {\\n                        if (j == code.size())\\n                            j = 0;\\n                        res[i] += code[j];\\n                        it++;\\n                    }\\n                }\\n                else if (k < 0)\\n                {\\n                    for (int j = i - 1; it > k; j--)\\n                    {\\n                        if (j < 0)\\n                            j = code.size() - 1;\\n                        res[i] += code[j];\\n                        it--;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935382,
                "title": "py3-duplicate-the-array-to-simplify-things",
                "content": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "solutionTags": [],
                "code": "```\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        if k == 0:\\n            return [0] * n\\n        arr = code + code\\n        res = [0] * n\\n        if k > 0:\\n            for i in range(n):\\n                res[i] = sum(arr[i+1:i+k+1])\\n        else:\\n            k = -k\\n            for i in range(n):\\n                res[i] = sum(arr[n+i-k:n+i])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3912887,
                "title": "simple-list-slicing-and-loop-process-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **O**(n)\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k>0:\\n            final=code+code[:k]\\n            for i in range(len(code)):\\n                code[i]=sum(final[i+1:k+1+i])\\n            return code\\n        if k==0:\\n            new=[0]*len(code)\\n            return new\\n        else:\\n            final=code[k:]+code\\n            for i in range(len(code)):\\n                code[i]=sum(final[i:i-k])\\n            return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674815,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> ans(n,0);\\n        if(k==0)\\n            return ans;\\n        for(int i=0; i<n; i++)\\n        {\\n            int j=0, sum=0, count=k;\\n            if(k>0)\\n            {\\n                j=i+1;\\n                while(count--){\\n                    sum+=code[j%n];\\n                    j++;\\n                }\\n            }\\n            else\\n            {\\n                if(i==0)  j=n-1;\\n                else   j=i-1;\\n                while(count++){\\n                    sum+=code[j];\\n                    if(j==0)    j=n-1;\\n                    else     j--;\\n                }\\n            }\\n            ans[i]=sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636938,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```\\n\\n***Please Upvote***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res=[]\\n        if k>0:       \\n            first=sum(code[:k])\\n            for i in range(len(code)):\\n                first=first-code[i]+code[(k+i)%(len(code))]\\n                res.append(first)\\n        elif k<0:\\n            first=sum(code[k:])\\n            print(first)\\n            for i in range(len(code)):\\n                res.append(first)\\n                first=first+code[i]-code[(k+i)%(len(code))]\\n        else:\\n            res=[0]*len(code)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436766,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        ind = 0\\n        li = [0 for i in range(len(code))]\\n        if k>0:\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(k):\\n                    if ind+1 >= len(code):\\n                        sum += code[(ind+1)%len(code)]\\n                    else:\\n                        sum += code[ind+1]\\n                    ind += 1\\n                li[j] = sum\\n        elif k<0:\\n            r = -k\\n            for j in range(len(code)):\\n                sum = 0\\n                ind = j\\n                for i in range(r):\\n                    if ind-1 <0:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                    else:\\n                        sum += code[ind-1]\\n                        ind -= 1\\n                li[j] = sum\\n        return li\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106935,
                "title": "easy-js-solution-in-10-lines",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let decoded = Array(code.length).fill(0)\\n    if (k==0) return decoded\\n\\n    let direction = k < 0 ? 1 : -1\\n\\n    for (let i = 0; i < code.length; i++)\\n        for (j=k; j != 0; j += direction){\\n            let idx = (i + j) % code.length // if our index is too high, lower it\\n            idx < 0 ? idx += code.length : idx // too low? increase it\\n            decoded[i] += code[idx]\\n        }\\n    return decoded\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2957477,
                "title": "runtime-55-ms-beats-100-memory-41-9-mb-beats-97-92",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/1fc69f57-672f-4bff-92c0-aa12825dcdb4_1672132892.8528547.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function (code, k) {\\n    if (k === 0) return new Array(code.length).fill(0);\\n    var arr = code.concat(code, code, code);\\n    // console.log(arr)\\n    let res = [];\\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        let x = i + 1;\\n        let y = (code.length - 1) + i;\\n        if (k > 0) {\\n            for (let j = 0; j < k; j++) {\\n                sum += arr[x];\\n                x++;\\n            }\\n            res.push(sum);\\n        } else if (k < 0) {\\n            for (let j = 0; j < -k; j++) {\\n                sum += arr[y];\\n                y--;\\n            }\\n            res.push(sum);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551093,
                "title": "java-brute-force-easy-to-understand",
                "content": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }\\n           return code;\\n       }\\n        else if(k>0){\\n            \\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i+1;\\n                if(i==code.length-1){\\n                    u=0;\\n                }\\n                for(int j=u;j<code.length;j++){\\n                    \\n                    sum+=code[j];\\n                    count++;\\n                    if(j==code.length-1){\\n                        j=-1;                       \\n                    }\\n                    if(count==k){\\n                        break;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                int sum=0;\\n                int count=0;\\n                int u=i-1;\\n                if(i==0){\\n                    u=code.length-1;\\n                }\\n                for(int j=u;j>=0;j--){\\n                    sum+=code[j];\\n                    count++;\\n                    if(count==Math.abs(k)){\\n                        break;\\n                    }\\n                    if(j==0){\\n                        j=code.length;\\n                    }\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n        \\n       \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] ans=new int[code.length];\\n       if(k==0){\\n           for(int i=0;i<code.length;i++){\\n               code[i]=0;\\n               \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2431302,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int n = code.size();\\n        \\n        vector<int> res(n);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sum = 0;\\n            \\n            if (k > 0)\\n                for(int j=1; j<=k; j++)\\n                    sum += code[(i + j) % n]; \\n            else if (k < 0)\\n                for(int j=1; j<=-k; j++)\\n                    sum += code[(i - j + n)%n];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323353,
                "title": "c-solution-with-12ms-runtime",
                "content": "Stats for this solution:\\nRuntime: 12 ms, faster than 5.85% of C++ online submissions for Defuse the Bomb.\\nMemory Usage: 8.2 MB, less than 73.28% of C++ online submissions for Defuse the Bomb.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);\\n        if(k == 0) return res;\\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(k > 0) {\\n                for(int j = (i + 1) % n; count < k; j = (j + 1) % n) {\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            } else {\\n                for(int j = i - 1; count < abs(k); j--) {\\n                    if(j == -1) j = n - 1;\\n                    res[i] += code[j];\\n                    count++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306730,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        length = len(code) \\n        code = code + code \\n        ans = [] \\n        \\n        if k > 0 :\\n            for i in range(length) :\\n                tmp = code[i+1:i+k+1]\\n                ans.append(sum(tmp))\\n        elif k < 0 : \\n            for i in range(length,len(code)):\\n                tmp = code[k+i:i]\\n                ans.append(sum(tmp))     \\n        else:\\n            return [0] * length \\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2051862,
                "title": "c-logic-two-loops-o-n2",
                "content": "Hi there , this is the simple logic that came into my mind at first, with O(n2) complexity\\nwould update a new thread if there comes another logic with better one.\\n\\nCODE- \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThanks for coming this far!  we can do thiss ! happy coding",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n= code.size();\\n         vector<int>res(n,0);\\n        if(k==0)\\n            return res;\\n        else if(k>0)\\n        {\\n            for(int ptr=0; ptr<n; ptr++)\\n            { \\n               int j=k;\\n                int i= ptr+1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i>n-1)\\n                       i%=n;\\n                   sum+=code[i];\\n                    i++;\\n               }\\n                res[ptr]=sum;\\n           }\\n        }\\n        else\\n        {\\n           for(int ptr=n-1; ptr>=0; ptr--)\\n           { \\n               int j=abs(k);\\n               int i=ptr-1;\\n               int sum=0;\\n               while(j--)\\n               {\\n                   if(i<0)\\n                       i= n-abs(i);\\n                   sum+= code[i];\\n                   i--;\\n               }\\n               res[ptr]=sum;\\n           }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033540,
                "title": "straight-forward-prefix-sum-solution",
                "content": "using a map to keep track of all prefix sum from 0 -> 2 * n - 1, since its a circular array.\\ntime: o(n), space: o(n)\\n```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint n = code.length;\\n\\tint[] res = new int[n];\\n\\tif (k == 0) {\\n\\t\\treturn res;\\n\\t}\\n\\n\\tMap<Integer, Integer> map = new HashMap<>();\\n\\tint[] temp = new int[n * 2];\\n\\n\\tfor (int i = 0; i < n * 2 ; i++) {\\n\\t\\ttemp[i] = code[i % n];\\n\\t}\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < temp.length; i++) {\\n\\t\\tsum += temp[i];\\n\\t\\tmap.put(i, sum);\\n\\t}\\n\\n\\tint[] res = new int[code.length];\\n\\tif (k > 0) {\\n\\t\\tfor (int i = 0; i < code.length; i++) {\\n\\t\\t\\tres[i] = map.get(i + k) - map.get(i);\\n\\t\\t}\\n\\t} else if (k < 0) {\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = n; i < temp.length; i++) {\\n\\t\\t\\tres[index++] = map.get(i - 1) - map.get(i + k - 1);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992107,
                "title": "c-solution-t-o-nk-s-1",
                "content": "### C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        \\n        int mod_k = abs(k);\\n        \\n        vector<int> decrypted_code(code.size());\\n        \\n        if (k == 0)\\n            return decrypted_code;\\n        else if (k < 0)\\n        {\\n            // circular right\\n            // formula: right = (start - distance + n) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i - j + code.size()) % code.size()]; \\n            }\\n        }\\n        else\\n        {\\n            // circular left\\n            // formula: left = (start + distance) % n\\n            for (int i = 0; i < code.size(); i++)\\n            {\\n                for (int j = 1; j <= mod_k; j++)\\n                    decrypted_code[i] += code[(i + j) % code.size()]; \\n            }\\n        }\\n        \\n        return decrypted_code;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985487,
                "title": "short-and-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int l = code.size(), s;\\n        vector<int> v(l);\\n        for(int i=0; i<l; ++i){\\n            s = 0;\\n            if(k>0){\\n                for(int j=0; j<k; ++j){\\n                    if(i+1+j <l)\\n                        s += code[i+1+j];\\n                    else \\n                        s += code[(i+1+j) % l];\\n                }\\n            }\\n            else{\\n                for(int j=0; j<fabs(k); ++j){\\n                    if(i-1-j >=0)\\n                        s += code[i-1-j];\\n                    else \\n                        s += code[l-1+i-j];\\n                } \\n            }\\n            v[i] = s;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967947,
                "title": "simple-javascript-solution-faster-than-70",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\n\\nvar decrypt = (code, k) => {\\n    \\n    let result = [];\\n    \\n    for (let i = 0; i < code.length; i++) {\\n        let sum = 0;\\n        \\n        if (k > 0) {\\n            for (let x = 1; x <= k; x++) {\\n                sum += code[(i+x) % code.length];\\n            }\\n        }\\n        \\n        if (k < 0) {\\n             for (let x = -1; x >= k; x--) {\\n                sum += code[(i + x + code.length) % code.length];\\n            }\\n        }\\n        \\n        result.push(sum);\\n    } \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862972,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        s=code*2\\n        for i in range(len(code)):\\n            if k==0:\\n                code[i]=0\\n            elif k>0:\\n                code[i]=sum(s[i+1:i+k+1])\\n            elif k<0:\\n                code[i] = sum(s[len(code) + i + k : len(code) + i])\\n        return code\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830648,
                "title": "python-solution-using-extra-memory",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        # Handle the case where k is 0\\n        if k == 0:\\n            for i in range(len(code)):\\n                code[i] = 0\\n        \\n        # Handle the case where k > 0\\n        elif k > 0:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[i + 1:i+ k + 1])\\n        \\n        # Handle the case where k < 0\\n        else:\\n            a = code + code\\n            for i in range(len(code)):\\n                code[i] = sum(a[len(code) + i + k : len(code) + i])\\n            \\n        return code        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818728,
                "title": "python-single-pass-no-reverse-no-if-s",
                "content": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        s = sum(code[i+1] for i in range(abs(k)))\\n        res = [0]*len(code)\\n        for i in range(len(code)):\\n            res[(i+(1-k)*(k<0))%len(code)] = s\\n            s -= code[(i+1)%len(code)]\\n            s += code[(i+1+abs(k))%len(code)]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1715964,
                "title": "easy-3-liner-python",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k < 0 : return self.decrypt(code[::-1], -k)[::-1]\\n        code = code * 2\\n        return [sum(code[i+1:i+k+1]) for i in range(len(code)//2)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640047,
                "title": "c-o-n-time-space-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        \\n        if(k==0)\\n        {\\n            return vector<int>(n);\\n        }\\n        \\n        int sum=0;\\n        int i=0;\\n        \\n        if(k>0)\\n        {\\n            vector<int> next_sum(n);\\n            \\n            for(i=0;i<k;i++)\\n            {\\n                sum+=code[i];\\n            }\\n\\n            for(int j=0;j<n;j++)\\n            {\\n                sum=sum-code[j]+code[i];\\n                next_sum[j]= sum;\\n                i=(i+1) % n;\\n            }\\n            \\n            return next_sum;\\n            \\n        }\\n        \\n         // if k<0\\n        \\n        k=abs(k);\\n        \\n        vector<int> pre_sum(n);\\n        sum=0;\\n        i=n-1;\\n        \\n        for(i=n-1;i>n-1-k;i--)\\n        {\\n            sum+=code[i];\\n        }\\n        \\n        for(int j=n-1;j>=0;j--)\\n        {\\n            sum=sum-code[j]+code[i];\\n            pre_sum[j]=sum;\\n            i=i-1;\\n            if(i<0) { i=n-1; }\\n        }\\n        \\n        return pre_sum;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623992,
                "title": "c-easy-to-understand-brute-force",
                "content": "**Brute force approach\\ntime complexity O(nxk)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int n=code.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=1,sum=0;\\n            int m=i;\\n            if(k<0)\\n            {\\n            m+=n;\\n            int j=-1;\\n            while(j>=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j--;\\n            }\\n            }\\n            else\\n            {\\n            while(j<=k)\\n            {\\n                sum+=code[(m+j)%n];\\n                j++;\\n            }\\n            }\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603868,
                "title": "rust-fast-100",
                "content": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n\\nstruct Solution{}\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if k == 0{\\n             return vec![0;code.len()];\\n        }else if k > 0{\\n            let mut v = vec![&code];\\n            for _ in 0..=(k/code.len() as i32){\\n                v.push(&code);\\n            }\\n            let chain = v.into_iter().flatten().collect::<Vec<&i32>>();\\n            let mut ans = vec![];\\n            for i in 0..code.len(){\\n                let mut x = 0;\\n                let mut count = 0;\\n                for j in (i+1)..chain.len(){\\n                    if count >= k{\\n                        break;\\n                    }\\n                    x += chain[j];\\n                    count +=1;\\n                }\\n                ans.push(x);                \\n            }\\n            ans\\n\\n        }else{\\n            let mut ans = vec![];          \\n            let vec = code.iter().cycle().take(((code.len() as i32 * code.len() as i32) - code.len() as i32) as usize).collect::<Vec<&i32>>();\\n            let v = vec.into_iter().rev().collect::<Vec<&i32>>();\\n            println!(\"{:?}\",v);\\n            let mut i= 0;\\n            while  i < v.len(){\\n                let mut m = 0;\\n                for j in 0..i32::abs(k){\\n                      m += v[i + j as usize];\\n                      print!(\"{} \",v[i+j as usize]);\\n                }\\n                println!();\\n                \\n                ans.push(m);\\n                i += code.len() - 1;       \\n            }\\n            ans\\n        }   \\n    }\\n}\\nfn main(){\\n    println!(\"{:?}\",Solution::decrypt(vec![2,4,9,3],-2));  \\n}\\n#[cfg(test)]\\nmod test{\\n    use crate::*;\\n\\n    #[test]\\n    fn basic(){\\n        assert_eq!(Solution::decrypt(vec![5,7,1,4],3),vec![12,10,16,13]);\\n        assert_eq!(Solution::decrypt(vec![1,2,3,4],0),vec![0,0,0,0]);\\n        assert_eq!(Solution::decrypt(vec![2,4,9,3],-2),vec![12,5,6,13]);\\n        assert_eq!(Solution::decrypt(vec![10,5,7,7,3,2,10,3,6,9,1,6],-4),vec![22,26,22,28,29,22,19,22,18,21,28,19]); \\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514918,
                "title": "c-0ms-o-n-k-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i+1); j <=(i+k); j++)\\n                    ans[i] += code[j%n];\\n            }\\n            \\n        }\\n        \\n        else if(k < 0)\\n        {\\n            for(int i = 0; i <n ;i++)\\n            {\\n                for(int j= (i-1)%n; j >=(i-abs(k))%n; j--)\\n                {\\n                    if(j < 0)\\n                        ans[i] += code[n+j];\\n                    \\n                    else ans[i] += code[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450462,
                "title": "easy-solution",
                "content": "just go with the flow \\ntwo things \\nto travel in counter clockwise direction:  **(n+j-1)%n**\\nto travel in clockwise direction:  **(n+i)%n**\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& nums, int k) \\n    {\\n    int n=nums.size();\\n    vector<int>ans(n,0);\\n    if(k==0)return ans;\\n    for(int i=0;i<n;i++)\\n    {\\n        int sum=0,j=k>0?(i+1)%n:(n+i-1)%n,count=0;\\n        if(k>0)while(count<k)sum+=nums[j],j=(j+1)%n,count++;\\n        if(k<0)while(count<abs(k))sum+=nums[j],j=(n+j-1)%n,count++;\\n        ans[i]=sum;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333655,
                "title": "python-solution",
                "content": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "solutionTags": [],
                "code": "class Solution:\\n    \\n\\tdef decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k == 0:\\n            return [0]*len(code)    \\n        temp = code\\n        code = code*2\\n        for i in range(0,len(temp)):\\n            if k > 0:\\n                temp[i] = sum(code[i+1:k+i+1])\\n            else:\\n                temp[i] = sum(code[i+len(temp)+k:i+len(temp)])\\n        \\n        return temp",
                "codeTag": "Java"
            },
            {
                "id": 1235556,
                "title": "python-two-lines-brute-force",
                "content": "Find the correct range based on the value of k, then sum the next/previous k values for each index using list comprehension.\\n\\n```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "solutionTags": [],
                "code": "```python\\ndef decrypt(self, code: List[int], k: int) -> List[int]:\\n        n, range_ = len(code), range(1,k+1) if k > 0 else range(k, 0)\\n        return [sum([code[(i+j)%n] for j in range_]) for i in range(n)] if k else [0]*n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1218451,
                "title": "100-python-array-concatenation-prefix-sum",
                "content": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def routine(self, code, k):\\n        append_times = int(math.ceil(abs(k) / len(code)))\\n        original_length = len(code)\\n        \\n        for i in range(1, append_times + 1):\\n            code += code\\n        \\n        prefixSum = [0]\\n        for num in code:\\n            prefixSum.append(prefixSum[-1] + num)\\n        \\n        if k > 0:\\n            for i in range(original_length):\\n                code[i] = prefixSum[i + k + 1] - prefixSum[i + 1]\\n        else:\\n            for i in range(original_length * append_times, len(code)):\\n                #    [0, 1, 0, 1]\\n                # [0, 0, 1, 1, 2]\\n                code[i] = prefixSum[i] - prefixSum[i + k]\\n        return code[: original_length] if k > 0 else code[-original_length:]\\n    \\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if not k:\\n            return [0] * len(code)\\n        return self.routine(code, k)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218059,
                "title": "javascript-solution",
                "content": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decrypt = function(code, k) {\\n    const n = code.length;\\n    \\n    if (k === 0) return new Array(n).fill(0);\\n    \\n    const res = new Array(n).fill(0);\\n    \\n    if (k > 0) {\\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            sum += code[(i + k) % n];\\n            sum -= code[i];\\n            \\n            res[i] = sum;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    if (k < 0) {\\n        k = -k;\\n        \\n        let sum = 0;\\n        \\n        for (let i = 0; i < k; i++) {\\n            sum += code[i];\\n        }\\n        \\n        for (let i = 0; i < n; i++) {\\n            res[(i + k) % n] = sum;\\n            \\n            sum -= code[i];\\n            sum += code[(i + k) % n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207790,
                "title": "python-94",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        lc = len(code)\\n        res = [0]*lc\\n        code += code\\n        if k == 0:\\n            return res\\n\\t\\t# if k < 0 just swap the code around and swap the result back at the end\\n        if k < 0:\\n            code = code[::-1]\\n        for i in range(lc):\\n            res[i] = sum(code[i+1:i+1+abs(k)])\\n        return res[::-1] if k < 0 else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1175703,
                "title": "100-efficient-solution-c",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=k;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n\\n                ans.push_back(s);\\n                k++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n        }\\n        else if(k < 0){\\n            t=abs(k);\\n            reverse(code.begin(),code.end());\\n            cout<<code.size();\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(t==code.size()){\\n                    break;\\n                }\\n                for(int j=c;j<=t;j++){\\n                    s=s+code[j];\\n                    c++;\\n                }\\n                ans.push_back(s);\\n                t++;\\n            }\\n            ans.erase(ans.begin()+(code.size()/2),ans.end());\\n            reverse(ans.begin(),ans.end());\\n        }\\n        else if(k==0){\\n             for(int i=1;i<=code.size()/2;i++){\\n                 ans.push_back(0);\\n             }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ans;\\n        int s=0,c=0,t;\\n        ans = code;\\n        code.insert(code.end(),ans.begin(),ans.end());\\n        ans.clear();\\n        if(k > 0){\\n            for(int i=1;i<=code.size();i++){\\n                s=0;\\n                c=i;\\n                if(k==code.size()){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1173463,
                "title": "rust-simple-solution",
                "content": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        let l  = code.len();\\n\\n        if k == 0 {\\n            return vec![0; l];\\n        };\\n\\n        let mut res = Vec::with_capacity(l);\\n        let mut start = match k.signum() {\\n            -1 => l as i32 + k,\\n            s => s,\\n        } as usize;\\n        let steps = k.abs() as usize;\\n\\n        for _ in 0..l {\\n            let mut s = 0;\\n            (start..start + steps).for_each(|j| s += code[j % l]);\\n            res.push(s);\\n            start += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172511,
                "title": "using-modulus",
                "content": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nr=[]\\n        n=len(code)\\n        x=0\\n        if k==0:\\n            for i in code:\\n                r.append(0)\\n            return r\\n        elif k>0:\\n            for i in range(len(code)):\\n                s=(i%n)\\n                e=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            return r\\n        else:\\n            for i in range(len(code)):\\n                e=(i%n)\\n                s=((i+k)%n)\\n                if(s>e):\\n                    x=sum(code[(s+1):])+sum(code[:(e+1)])\\n                else:\\n                    x=sum(code[(s+1):(e+1)])\\n                r.append(x)\\n            q=r[len(r)-1]\\n            r=r[:len(r)-1]\\n            r.insert(0,q)\\n            return r\\n            \\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114740,
                "title": "c-stupidly-concise",
                "content": "Sliding window. \\n\\n`i` is left, `j` is right, `n` is the sum of the current window. Keep moving `j` to the right, adding in whatever value we hit to our sum. \\n\\nIf the total window size hits the limit, pull up the left hand side of the window and drop the value at that index from our sum. Then set this sum into the correct index - just before the start of the window if `k` is positive, and just after the end of the window if `k` is negative.\\n```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n\\tvector<int> v(code.size());\\n\\tfor (int i = 0, j = 0, n = 0; i < code.size() && k; ++j) {\\n\\t\\tn += code[j % code.size()];\\n\\t\\tif (j - i == abs(k)) v[k > 0 ? i - 1 : (j + 1) % code.size()] = n -= code[i++];\\n\\t}\\n\\treturn v;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094993,
                "title": "python-solution-array-prefix-sum",
                "content": "Array Prefix sum approach.\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n_l=[]\\n        res=[]\\n        nn=1\\n        ctr=0\\n        if k<0:\\n            nn=0\\n        n=len(code)\\n        if k==0:\\n            return [0]*len(code)\\n        if not nn:\\n            k=k*-1\\n            code=code[::-1]\\n        for i in code:\\n            ctr+=i\\n            n_l.append(ctr)\\n        for i in range(n):\\n            if (i+k)<n:\\n                res.append(n_l[i+k]-n_l[i])\\n            else:\\n                res.append(n_l[n-1]-n_l[i]+n_l[(i+k)%n])\\n        if nn:\\n            return res\\n        else:\\n            return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080903,
                "title": "c-concise-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> ret;\\n        for (int i = 0; i < code.size(); i++) {\\n            int sum = 0;\\n            int direction = k > 0 ? 1 : -1;\\n\\t\\t\\tint j = i + direction;\\n            while (j != i + k + direction) {\\n                sum += code.at((j + code.size()) % code.size());\\n                j = j + direction;\\n            }\\n            ret.push_back(sum);\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069062,
                "title": "java-100",
                "content": "1. Calculation and its sequence are same for both directions.\\n2. If k is negative, rotate the result and return\\n```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] decrypt(int[] code, int k) {\\n        int[] cycle = new int[code.length];  \\n        if(k == 0) return cycle;\\n        \\n        int sum = 0;\\n        int t = Math.abs(k);\\n        \\n        for(int i = 0; i < t; i ++)\\n            sum += code[i];\\n        \\n        for(int i = 0; i < code.length; i ++){\\n            sum = sum - code[i] + code[(i + t)%code.length];\\n            cycle[i] = sum;\\n        }\\n        \\n        if(k > 0) return cycle;\\n        \\n        int[] res = new int[code.length];\\n        \\n        for(int i = 0; i < code.length; i ++)\\n            res[i] = cycle[(i + code.length - t - 1)%code.length];\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054478,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        \\n        x = []\\n        \\n        if k == 0 :\\n            return [0]*len(code)\\n        \\n        elif k > 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [i+1:i+1+k]))\\n                \\n        elif k < 0 :\\n            for i in range(len(code)) :\\n                \\n                x.append(sum((code + code) [len(code)+i+k:len(code)+i]))\\n        \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051935,
                "title": "0ms-simple-c-solution",
                "content": "\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* decrypt(int* code, int codeSize, int k, int* returnSize){\\n    \\n    int *ptr=(int*)malloc(sizeof(int)*codeSize);\\n    *returnSize=codeSize;\\n    \\n    int i,j;\\n    \\n    for(i=0;i<codeSize;i++)\\n    {\\n        int sum=0;\\n        if(k>0)\\n        {\\n            if(i+k<codeSize)\\n            {\\n                for(j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=i+1;j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=0;j<i+k+1-codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            ptr[i]=0;\\n        }\\n        else\\n        {\\n            if(i+k>=0)\\n            {\\n                for(j=i+k;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n            else\\n            {\\n                for(j=0;j<i;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                for(j=codeSize-(abs(k)-i);j<codeSize;j++)\\n                {\\n                    sum=sum+code[j];\\n                }\\n                ptr[i]=sum;\\n            }\\n        }\\n    }\\n    \\n    return ptr;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036396,
                "title": "simple-c-with-circle-arr-comment-100-faster-85-better-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sum = 0;\\n        int n = code.size();\\n        int cnt = 0;\\n        vector<int> v(n);\\n        \\n        if (k > 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i+1; cnt < k; j++) {\\n                    if (j == n) j = 0; // circle logic - code[n+1] = code[0]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            }\\n        }\\n        \\n        else if (k < 0) {\\n            for (int i = 0; i < n; ++i) {\\n                for (int j = i-1; cnt < -k; j--) {\\n                    if (j < 0) j = n-1; // circle logic - code[-1] = code[n-1]\\n                    sum += code[j];\\n                    cnt++;\\n                }\\n                v[i] = sum;\\n                sum = 0;\\n                cnt = 0;\\n            } \\n        }\\n        \\n        else {\\n            for (int i = 0; i < n; ++i) {\\n                v[i] = 0;    \\n            }\\n        }\\n                    \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029160,
                "title": "simple-c-solution-100-faster",
                "content": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "solutionTags": [],
                "code": "int n=code.size();\\n        if(k==0)\\n        {\\n            vector<int>v(n,0);\\n            return v;\\n        }\\n        \\n        vector<int>res;\\n        int q=0,sum=0,i=0,c=0;\\n         if(k>0)\\n        {\\n             i=1;\\n        while(q<n)\\n        {\\n            if(i<n)\\n            {  \\n                 sum=sum+code[i];\\n                c++;\\n                if(c==k)\\n                {\\n                    c=0;\\n                    res.push_back(sum);\\n                    sum=0;\\n                    q++;\\n                    i=q;\\n                }\\n                i++;\\n                     \\n            }\\n            else{\\n                i=0;\\n                \\n            }\\n            \\n        }\\n       \\n        return res;\\n        }\\n        else\\n        {\\n            i=n-1;\\n             while(q<n)\\n           {\\n                    if(i>=0)\\n                    {  \\n                          sum=sum+code[i];\\n                             c++;\\n                          if(c==abs(k))\\n                         {\\n                              c=0;\\n                             res.push_back(sum);\\n                             sum=0;\\n                             q++;\\n                              i=q;\\n                          }\\n                          i--;\\n                     \\n                     }\\n                     else\\n                          i=n-1;\\n        }\\n       \\n        return res;\\n        }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1029000,
                "title": "c-optimized-code-faster-than-90",
                "content": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }\\n        int check;\\n        if(k>0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n               int sum=0;\\n               check=k;\\n               j=i+1;\\n               while(check--)\\n               {\\n                    j=j%n;\\n                   sum+=code[j];\\n                   j++;\\n                   \\n                   \\n               }\\n                v[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                check=-k;\\n                j=i-1;\\n                if(j==-1)\\n                {\\n                    j=n-1;\\n                }\\n                while(check--)\\n                {\\n                    if(j==-1)\\n                    {\\n                        j=n-1;\\n                    }\\n                    sum+=code[j];\\n                    j--;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n       \\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        int i,j;\\n        vector< int>v(n,0);\\n        if(k==0)\\n        {\\n            return v;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1003515,
                "title": "python3-easy-solution-with-list-index-manipulation",
                "content": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\n\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        retList = []\\n        \\n        if k == 0:\\n            for i in range(len(code)):\\n                retList.append(0)\\n                \\n            return retList\\n        \\n        if k > 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(k):\\n                    if i+1+j < len(code):\\n                        sumup += code[i+1+j]\\n                    else:\\n                        sumup += code[i+1+j-len(code)]\\n                \\n                retList.append(sumup)\\n                \\n            return retList\\n        \\n        if k < 0:\\n            for i in range(len(code)):\\n                sumup = 0\\n                for j in range(abs(k)):\\n                    if i-j-1 < 0:\\n                        sumup += code[len(code)+i-j-1]\\n                    else:\\n                        sumup += code[i-j-1]\\n                        \\n                    \\n                retList.append(sumup)\\n                \\n            return retList",
                "codeTag": "Python3"
            },
            {
                "id": 992601,
                "title": "java-brute-force-solution-beats-47-08",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int l = code.length;\\n        int output[] = new int[l];\\n        if (k > 0) {\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i + 1; count < k; j++) {\\n                    c += code[j % l];\\n                    count++;\\n                }\\n\\n                output[i] = c;\\n            }\\n        } else if (k < 0) {\\n\\n            for (int i = 0; i < l; i++) {\\n                int c = 0;\\n                int count = 0;\\n                for (int j = i - 1; count < Math.abs(k); j--) {\\n                    c += code[(j + l) % l];\\n                    count++;\\n                }\\n                output[i] = c;\\n            }\\n\\n        } else {\\n            for (int i = 0; i < l; i++) {\\n                output[i] = 0;\\n            }\\n\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984880,
                "title": "rust-o-n",
                "content": "Working through those type conversions, a prev sol helped. :) \\n\\n\\n```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn decrypt(code: Vec<i32>, k: i32) -> Vec<i32> {\\n        if code.len() <= 0 {\\n            return code\\n        }\\n        let mut ret = vec![0; code.len()];\\n        let L  = ret.len();\\n        \\n        match k {\\n            0 => {}\\n            std::i32::MIN..=-1_i32 => {\\n                for i in 0..L {\\n                    for j in k..=-1 {\\n                        ret[i] += code[((i+L) as i32 + j ) as usize % L]\\n                    }\\n                }\\n            }\\n            1_i32..=std::i32::MAX => {\\n                for i in 0..L {\\n                    for j in 1..=k {\\n                        ret[i] += code[(i+j as usize)  % L]\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 967756,
                "title": "simple-python-solution",
                "content": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "solutionTags": [],
                "code": "```\\n    n = len(code) \\n    res = n * [0]\\n    code_extended = code * (abs(k)+1)  \\n    if k > 0:\\n        for i in range(n):\\n            res[i] = sum(code_extended[i+1:i+k+1])\\n    elif k < 0:\\n        k = abs(k)\\n        for i in range(k*n, (k+1)*n):\\n            res[i-k*n] = sum(code_extended[i-k:i])\\n    return res",
                "codeTag": "Unknown"
            },
            {
                "id": 963902,
                "title": "go-solution-0ms-2-5mb",
                "content": "The idea is to form a temp slice that mimic the feature of circular array. It\\'ll be easy to locate the target elements, but with cost of higher memory usage.\\neg: \\nInput: code = [5,7,1,4] , k = -2\\ntemp would become  [5,7,1,4,**5,7,1,4**,5,7,1,4]\\n\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var temp []int\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    temp = append(temp,code...)\\n    n := len(code)\\n    for i:=n;i<2*n;i++ {\\n        var sum, j int = 0, k\\n        for j != 0  {\\n            sum += temp[i+j]\\n            if j < 0 { j++ }\\n            if j > 0 { j-- }\\n        }\\n        code[i-n] = sum\\n    }\\n    return code\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959724,
                "title": "c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n = a.size(), s = 0;\\n        vector<int> prefix(n+1, 0);\\n        vector<int> ans(n, 0);\\n        // create prefix array \\n        for(int i=0; i<n; i++) {\\n            prefix[i+1] = prefix[i] + a[i];\\n        }\\n        \\n        if(k > 0) {\\n            for(int i=0; i<n; i++) {\\n\\t\\t\\t\\t// first part of the window \\n                int r = min(n-1, i+k);\\n                ans[i] += prefix[r+1] - prefix[i+1];\\n\\t\\t\\t\\t// second part of the window \\n                r = k - (r - i);\\n                ans[i] += prefix[r];\\n            }\\n        } else if(k < 0) {\\n            k = -k;\\n            for(int i=0; i<n; i++) {\\n                int l = max(0, i-k);\\n\\t\\t\\t\\t// first part of the window \\n                ans[i] += prefix[i] - prefix[l];\\n                l = k - (i - l);\\n\\t\\t\\t\\t// second part of the window \\n                ans[i] += prefix[n] - prefix[n-l]; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950114,
                "title": "java-solution-brute-force",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] h = new int[code.length];\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    if (i + j == code.length) {\\n                        g = 0;\\n                    } else {\\n                        g++;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        else if (k == 0){\\n            for (int i = 0; i < code.length; i++) {\\n                h[i] = 0;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int g = i;\\n                int sum = 0;\\n                for (int j = 1; j <= (-1) * k; j++) {\\n                    if (i - j < 0 && g == 0){\\n                        g = code.length - 1;\\n                    }\\n                    else {\\n                        g --;\\n                    }\\n                    sum += code[g];\\n                }\\n                h[i] = sum;\\n            }\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943955,
                "title": "python-3-without-modulo-94-time",
                "content": "Quite a lengthy code but it does the job.\\n\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = []\\n        for x,i in enumerate(code):\\n            if k > 0:\\n                if (x+k+1) > len(code):  #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[x+1:x+k+1]) + sum(code[:(k-(len(code)-1-x))]))\\n                else:\\n                    res.append(sum(code[x+1:x+k+1]))        \\n            elif k == 0:\\n                return [0]*len(code)\\n            elif k < 0:\\n                if k+x < 0: #This means we will have to loop over the array, so we add the remaining portion\\n                    res.append(sum(code[k+x:]) + sum(code[:x]))\\n                else:\\n                    res.append(sum(code[x+k:x]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938270,
                "title": "more-understandable",
                "content": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        #defining range if k positive or negative\\n        #ranger[start, end]\\n        ranger= [1, abs(k+1)] if k>0 else [k, 0]\\n        mylist = []\\n        #run every number\\n        for c in range(len(code)):\\n            sum = 0\\n            #go through the range\\n            for index in range(ranger[0], ranger[1]):\\n                sum += code[(c+index)%len(code)]\\n            mylist.append(sum)\\n        return mylist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937967,
                "title": "c-o-n-time-o-1-additional-space",
                "content": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n);\\n        int runsum = 0;\\n        bool rev = 0;\\n        \\n        if (k < 0) {\\n            rev = 1;\\n            k = -k;\\n            reverse(code.begin(), code.end());\\n        }\\n        \\n        for (int i = 0; i <= k; i++)\\n            runsum += code[i];\\n        \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\trunsum -= code[i];\\n            ans[i] = runsum;\\n            runsum += code[(i + k + 1) % n];\\n        }\\n        if (rev)\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936993,
                "title": "java-10-liner-o-n",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n\\tint currentSum = 0;\\n\\tfor(int i=0;i<Math.abs(k);i++) currentSum += code[k>0?i:code.length-1-i];\\n\\tint[] result = new int[code.length];\\n\\tif(k!=0)\\n\\t\\tfor(int i=0;i<code.length;i++) {\\n\\t\\t\\tint currentIndex = k > 0 ? i: code.length - 1 - i;\\n\\t\\t\\tcurrentSum = currentSum - code[currentIndex] + code[(code.length+currentIndex+k)%code.length];\\n\\t\\t\\tresult[currentIndex] = currentSum;\\n\\t\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936660,
                "title": "java-0ms-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) return new int[code.length];\\n        \\n        int n = code.length;\\n        int ksum = 0;\\n        int[] res = new int[n];\\n        \\n        // build k size sum.\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) ksum += code[i];\\n            \\n        } else {\\n            for (int i = n - 1; i >= (n + k); i--) ksum += code[i];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n                int next = code[((n + i + k) % n)];\\n                int curr = code [i];\\n                \\n                if (k > 0) {\\n                    res[i] = ksum - curr + next;\\n                    ksum = res[i];\\n                }\\n                else {\\n                    res[i] = ksum;\\n                    ksum = ksum + curr - next; \\n                }\\n                \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936226,
                "title": "defuse-the-bomb",
                "content": "c++  solution \\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n       \\n        \\n         int n=code.size();\\n         vector<int> ans;\\n         for(int i=0;i<n;i++){\\n             \\n             if(k==0){\\n                 ans.push_back(0);\\n             }\\n             else if(k>0){\\n                 int sum=0;\\n                 for(int j=i+1;j<=i+k;j++){\\n                     sum+=code[j%n];\\n                 }\\n                 ans.push_back(sum);\\n             }\\n             else{\\n                 int sum=0;\\n                 for(int j=i+k;j<=i-1;j++){\\n                     sum+=code[(j+n)%n];\\n                 }\\n                 ans.push_back(sum);     \\n             }\\n         }\\n         return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935446,
                "title": "javascript-o-n-k-time-complexity",
                "content": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar decrypt = function(code, k) {\\n  const n = code.length;\\n\\n  let res = new Array(n).fill(0)\\n  if (k == 0) {\\n    return res;\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (k > 0) {\\n      for (let j = 0; j < k; j++) {\\n        let index = (i+1+j) % n;\\n        res[i] += code[index];\\n      }\\n    } else if (k < 0) {\\n      for (let j = 0; j < -k; j++) {\\n        let index = (i+n-j-1) % n;\\n        res[i] += code[index];\\n      }\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935431,
                "title": "easy-to-understand-o-nk-soln",
                "content": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n        int n=code.length;\\n        int[] res=new int[n];\\n        if(k>0){\\n            for(int i=0;i<n;i++){\\n                for(int j=i+1;j<=i+k;j++)\\n                    res[i]+=code[j%n];\\n            }\\n        }\\n        else{\\n            for(int i=n-1;i>=0;i--){\\n                for(int j=i-1;j>=i+k;j--){\\n                    int idx=j>=0?j:j+n;\\n                    res[i]+=code[idx];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935393,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res = code;\\n        res.insert(res.end(),code.begin(),code.end());\\n        vector<int> ans;\\n        if(k>0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int i=code.size();i<res.size();i++)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    sum+=res[j];\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        else if(k==0)\\n        {\\n            for(int i=0;i<code.size();i++)\\n            {\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935391,
                "title": "java-simple-o-nk-and-sliding-window-o-n-time-solutions",
                "content": "`O(NK)` time solutions:\\nJust do what is asked in the question\\n\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\n`O(N)` time solution\\nCompute sum for the first element. Continue computing sum for others maintaining sliding window\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            int sum = 0;\\n            \\n            if (k > 0) {\\n                for (int j = 0; j < k; j++) {\\n                    sum += code[(i + j + 1) % n];\\n                }\\n            } else if (k < 0) {\\n                for (int j = 0; j < -k; j++) {\\n                    sum += code[(i + n - j - 1) % n];\\n                }\\n            }\\n            \\n            answer[i] = sum;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int n = code.length;\\n        int[] answer = new int[n];\\n        \\n        if (k == 0) {\\n            return answer;\\n        }\\n        \\n        int sum = 0;\\n        for (int idx = (n + k) % n, move = -k / Math.abs(k); idx != 0; idx = (idx + move) % n) {\\n            sum += code[idx];\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            answer[i] = sum;\\n            \\n            if (k < 0) {\\n                sum -= code[(n + k + i) % n];\\n                sum += code[i];\\n            } else {\\n                sum -= code[(i + 1) % n];\\n                sum += code[(i + k + 1) % n];\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935388,
                "title": "java-0-ms-faster-than-100-00-39-4-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        if (k == 0) {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        int sum = 0;\\n        int n = code.length;\\n        int[] res = new int[n];\\n        if (k > 0) {\\n            for (int i = 0; i < n + k; ++i) {\\n                sum += code[i % n];\\n                if (i >= k) {\\n                    sum -= code[i - k];\\n                    res[i - k] = sum;\\n                }\\n            }\\n        } else {\\n            k = -k;\\n            for (int i = 0; i < n + k; ++i) {\\n                if (i >= k) {\\n                    res[i % n] = sum;\\n                    sum -= code[i - k];\\n                }\\n                sum += code[i % n];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935385,
                "title": "brute-force-java",
                "content": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    public int[] decrypt(int[] code, int k) {\\n        \\n        if (k == 0)\\n        {\\n            return new int[code.length];\\n        }\\n        \\n        int[] res = new int[code.length];\\n        \\n        if(k > 0)\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                for(int j = i + 1; j <= i + k; j++)\\n                {\\n                    res[i] += code[j % code.length];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i = 0; i < code.length; i++)\\n            {\\n                int l = Math.abs(k);\\n                for(int j = i - 1 + code.length; l > 0; j--)\\n                {\\n                    res[i] += code[j % code.length];\\n                    l--;\\n                }\\n            }\\n        }\\n        \\n        return res;        \\n    }\\n\\t\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 935371,
                "title": "kt-js-py3-cpp-one-step-at-a-time",
                "content": "**Synopsis:**\\n\\nGenerate the answer `ans` one step at a time by accumulating the total sum of the `K` values adjacent to-the-right of each `i`<sup>th</sup> element of the input array `A`.  To simplify the code when `K` is negative, simply reverse `A` and return the reversed answer using positive `K`.\\n\\n---\\n\\n**Bi-Weekly Contest 39 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/2c2f0b1a-650d-43dc-bb60-fbd2340d74c1_1605370887.2933993.png)\\n\\nhttps://www.youtube.com/watch?v=tOBm0jYytpc\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun decrypt(A: IntArray, K: Int): IntArray {\\n        var N = A.size\\n        if (K == 0)\\n            return IntArray(N) { 0 }\\n        if (K < 0)\\n            return decrypt(A.reversed().toIntArray(), -K).reversed().toIntArray()\\n        var ans = mutableListOf<Int>()\\n        var step = { i: Int -> if (i + 1 < N) i + 1 else 0 }\\n        for (i in 0 until N) {\\n            var total = 0\\n            var j = step(i)\\n            for (steps in 0 until K) {\\n                total += A[j]\\n                j = step(j)\\n            }\\n            ans.add(total)\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet decrypt = (A, K, ans = []) => {\\n    let N = A.length;\\n    if (!K)\\n        return Array(N).fill(0);\\n    if (K < 0)\\n        return decrypt(A.reverse(), -K).reverse();\\n    let step = i => i + 1 < N ? i + 1 : 0;\\n    for (let i = 0; i < N; ++i) {\\n        let steps = K,\\n            total = 0,\\n            j = step(i);\\n        while (steps--) total += A[j], j = step(j);\\n        ans.push(total);\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def decrypt(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        if not K:\\n            return [0] * N\\n        if K < 0:\\n            return self.decrypt(A[::-1], -K)[::-1]\\n        step = lambda i: i + 1 if i + 1 < N else 0\\n        ans = []\\n        for i in range(N):\\n            steps = K\\n            total = 0\\n            j = step(i)\\n            for _ in range(steps): total += A[j]; j = step(j)\\n            ans.append(total)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decrypt(VI& A, int K, VI ans = {}) {\\n        auto N = A.size();\\n        if (!K)\\n            return VI(N);\\n        if (K < 0) {\\n            reverse(A.begin(), A.end());\\n            ans = decrypt(A, -K);\\n            return { ans.rbegin(), ans.rend() };\\n        }\\n        auto step = [=](auto i) { return i + 1 < N ? i + 1 : 0; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto steps = K,\\n                 total = 0,\\n                 j = step(i);\\n            while (steps--) total += A[j], j = step(j);\\n            ans.push_back(total);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090277,
                "title": "loop-solution-time-complexity-o-n-k",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe inner loop iterates from 1 to the absolute value of k (inclusive). The purpose of this loop is to perform a certain number of shifts on the code list elements.\\n\\nInside this nested loop, there\\'s a conditional statement that checks whether k is greater than 0. If it is, it calculates the new value of newNum by adding the code element at the index (i+j)%n to newNum. If k is less than 0, it calculates newNum by adding the code element at the index (i-j)%n to newNum.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(code)\\n        output = [0]*n\\n        if k == 0:\\n            return output\\n\\n        for i in range(n):\\n            newNum = 0\\n            for j in range(1,abs(k)+1):\\n                if k > 0:\\n                    newNum = newNum + code[(i+j)%n]\\n                else:\\n                    newNum = newNum + code[(i-j)%n]\\n            output[i] = newNum\\n        return output\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088740,
                "title": "easy-to-understand-java-solution-takes-only-1ms-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumg(int code[],int i,int k){//Function to find sum in case of k>0\\n        int s=0;i=i+1;\\n        while(k>0){\\n            if(i>code.length-1){\\n                 i=0;\\n                  s+=code[i];\\n            }\\n            else{\\n                s+=code[i];\\n            }\\n            i+=1;\\n            k--;\\n        }\\n        return s;\\n    }\\n    public int suml(int code[],int i,int k){//Function to find sum in case of k<0\\n       int s=0;i=i-1;\\n       while(k>0){\\n           if(i>=0&&i<code.length){\\n               s+=code[i];\\n           }\\n           else{\\n               i=code.length-1;\\n               s+=code[i];\\n           }\\n           i-=1;\\n           k-=1;\\n       }\\n       return s;\\n    }\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k==0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=0;\\n            }\\n            return ans;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=sumg(code,i,k);\\n            }\\n            return ans;\\n        }\\n        else{\\n            for(int i=0;i<code.length;i++){\\n                ans[i]=suml(code,i,k*(-1));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078307,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& a, int k) {\\n        int n=a.size(), j=0;\\n        vector<int> v(2*n, 0);\\n        vector<int> ret(n, 0);\\n        for(int i=0; i<n; ++i) v[i]=a[i];\\n        for(int i=n; i<2*n; ++i) v[i]=a[j++];\\n        if(k > 0) {\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=i+1; j<=i+k; ++j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n        } else if(k < 0) {\\n            k=abs(k);\\n            for(int i=0; i<n; ++i) {\\n                int sum=0;\\n                for(int j=n+i-1; j>(n+i-1)-k; --j) {\\n                    sum+=v[j];\\n                }\\n                ret[i]=sum;\\n            }\\n            \\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072718,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> v(code.size(), 0);\\n        if (k == 0){\\n            return v;\\n        }else if ( k > 0){\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    v[i] += code[(i+j)%code.size()];\\n                }\\n            }\\n            return v;\\n        }else{\\n            k = 0-k;\\n            for(int i=0; i<code.size(); i++){\\n                for(int j=1; j<=k; j++){\\n                    //cout << \"i \" << i << \" j \" << j << endl;\\n                    if ((i-j) >= 0){\\n                        v[i] += code[(i-j)%code.size()];\\n                    }else{\\n                        v[i] += code[code.size() - abs(i-j)%code.size()];\\n                    }\\n                }\\n            }\\n            return v;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4064331,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int sz = code.size();\\n        vector<int> ans(sz, 0);\\n        if(k == 0) return ans;\\n        int start = k > 0 ? 1 : sz+k, end = k > 0 ? k : sz-1;\\n        for(int i=0; i<sz; i++){\\n            if(i == 0){\\n                for(int j=start; j<=end; j++)\\n                    ans[i] += code[j%sz];\\n            }\\n            else if(k > 0) ans[i] = ans[i-1] - code[i] + code[(i+k)%sz];\\n            else ans[i] = ans[i-1] - code[(i-1+sz+k)%sz] + code[i-1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060974,
                "title": "2ms-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int result[]=new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                result[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<result.length;i++)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i+1;j<code.length*2;j++)\\n                {\\n                    sum+=code[j%code.length];\\n                    k1++;\\n                    if(k1==k)\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n        }\\n        else if(k<0) {\\n\\n            for(int i=result.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                int k1=0;\\n                for(int j=i-1;j>=(-code.length);j--)\\n                {\\n                    if(j>=0)\\n                    {\\n                        sum+=code[j];\\n                    }\\n                    else if (j<0)\\n                    {\\n                        sum+=code[j+code.length];\\n                    }\\n                    k1++;\\n                    if(k1==Math.abs(k))\\n                    {\\n                        break;\\n                    }\\n                }\\n                result[i]=sum;\\n            }\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055984,
                "title": "simpler-as-much-for-beginner-beatz-100",
                "content": "## Complexity\\n####  Time complexity: O(n^2) \\n#### Space complexity: O(n) \\n\\n## Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        res = [0]*len(code)\\n\\n        if k > 0:\\n            for i in range(len(code)):\\n                temp = code[i+1:] + code\\n                res[i] = sum(temp[:k])\\n            return res\\n\\n        if k == 0:\\n            return res\\n\\n        else:\\n            for i in range(len(code)):\\n                temp = code+code[:i]\\n                res[i] = sum(temp[k:])\\n            return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038589,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decrypt(_ code: [Int], _ k: Int) -> [Int] {\\n        var answer:[Int] = []\\n        let codeExt = code + code + code\\n        let count = code.count\\n\\n        if k == 0 {\\n            answer = Array(repeating: 0, count: count)\\n        } else if k > 0{\\n            for i in 0..<count{\\n                let add = codeExt[count+1+i...count+i+k]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        } else {\\n            for i in 0..<count{\\n                let add = codeExt[count+k+i...count+i-1]\\n                answer.append(add.reduce(0) {$0 + $1})\\n            }\\n        }\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034311,
                "title": "beats-100-with-0ms-optimal-solution-with-explanation-tc-o-n-sc-o-n",
                "content": "# Intuition\\nk is basically a window of elements and we see this window moving across as we move ahead to populate our indices in the new array.\\n\\n# Approach\\nWe break down the problem into 3 parts. k==0 is straight forward. Our window slides for K>0 and K<0. the movement of the window is same, its just the starting and ending indices we have to identify for the different tow different cases of k. Once we do that we just create a for loop where we slide our window.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) and I believe it can\\'t be lower than that as we are supposed to return an array and we should always create a new one rather than modifying our input unless asked to.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        int sumArr = 0;\\n        int startIndex = 0;\\n        int endIndex = 0;\\n\\n        // when K=0 return the array as it is.\\n\\n        if(k==0){\\n            return arr;\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k>0){\\n            startIndex = 1;\\n            endIndex = k;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // when K>0 , identify the start and end index of the window.\\n        if(k<0){\\n            startIndex = code.length+k;\\n            endIndex = code.length-1;\\n            for(int i=startIndex;i<=endIndex;i++){\\n                sumArr = sumArr + code[i];\\n            }\\n        }\\n\\n        // Now we just populate each index in the new array. while also incrementing our start and end index.\\n        for(int i = 0; i<code.length; i++){\\n            arr[i] = sumArr;\\n\\n            // if the pointer reaches the end, it comes back from the starting end and hence = 0.\\n            if(endIndex == code.length-1){\\n                endIndex = 0;\\n            }\\n            else{\\n                endIndex ++;\\n            }\\n            sumArr = sumArr - code[startIndex] + code[endIndex];\\n\\n            if(startIndex == code.length-1){\\n                startIndex = 0;\\n            }\\n            else{\\n                startIndex ++;\\n            }\\n        }\\n\\n        return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033458,
                "title": "one-line-solution-using-a-cyclic-iterator",
                "content": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\\n> More readable\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)] if k > 0 else [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)] if k < 0 else [0]*len(code)\\n```\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        if k > 0:\\n            return [sum(islice(cycle(code), i, i+k)) for i in range(1, len(code)+1)]\\n        if k < 0:\\n            return [sum(islice(cycle(reversed(code)), i, i-k)) for i in range(len(code), 0, -1)]\\n        return [0]*len(code)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020155,
                "title": "beats-100-00",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    let result = []\\n    let sum \\n  \\n\\n    if( k > 0) {\\n        for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+k;j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n    }\\n    if(k === 0) {\\n        for(let k = 0; k <code.length;k++) {\\n            result.push(0)\\n        }\\n    }\\n\\n    if(k < 0) {\\n          let reverse = code.reverse()\\n         for(let i = 0; i < code.length;i++) {\\n            sum = 0\\n            for(let j = i+1;j < i+1+(k*-1);j++) {\\n            sum+= code[j % code.length]\\n            \\n            }\\n            result.push(sum)\\n        } \\n        result.reverse()\\n\\n    }\\n    return result \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968965,
                "title": "c-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> res(n, 0);  // Initialize the result vector\\n        if (k != 0) {\\n            for (int i = 0; i < n; i++) {\\n                int sum = 0;\\n                // Define the step direction\\n                // int step = k > 0 ? 1 : -1;\\n                int step;\\n                if(k>0){\\n                    step = 1;\\n                } else{\\n                    step = -1;\\n                }\\n                for (int j = 1; j <= abs(k); j++) {\\n                    // Calculate the new index with wrap-around\\n                    int index = (i + j * step + n) % n;\\n                    sum += code[index];\\n                }    \\n                res[i] = sum;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964778,
                "title": "sliding-window-reverse",
                "content": "# Intuition\\nWe can use sliding window for k > 0, for k < 0 we can reverse input and calculated outout.\\n\\n# Approach\\nFor k > 0, we can start by calculating first value with index 0, and sum from 1 to k.\\nNext we need to update n numbers, on each step we remove i + 1, element from the sum and add, k + i + 1 element to it. Use % of n to ensure data is read from ring buffer.\\nFor case when k < 0 we need to reverse input and output.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        const int n = code.size();\\n\\n        vector<int> result(n, 0);\\n        if (k == 0) {\\n            return result;\\n        }\\n\\n        bool rr = false;\\n        if (k < 0) {\\n            reverse(code.begin(), code.end());\\n            k = -k;\\n            rr = true;\\n        }\\n\\n        int sum = 0;\\n        for (int i = 1;i <= k;i ++) {\\n            sum += code[i];\\n        }\\n\\n        int j = (k + 1) % n;\\n        for (int i = 0;i < code.size();i ++) {\\n            result[i] = sum;\\n            sum -= code[(i + 1) % n];\\n            sum += code[j % n];\\n            j ++;\\n        }\\n\\n        if (rr) {\\n            reverse(result.begin(), result.end());\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948273,
                "title": "cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> decrypt(vector<int> &code, int k)\\n        {\\n            int n = code.size(), sum = 0, t, idx = 0;\\n            vector<int> ans;\\n            if (k == 0)\\n            {\\n                vector<int> ans2(n);\\n                return ans2;\\n            }\\n            else if (k > 0)\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = k;\\n                    idx = i + 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == n)\\n                        {\\n                            idx = 0;\\n                        }\\n                        sum += code[idx++];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < n; i++)\\n                {\\n                    t = abs(k);\\n                    idx = i - 1;\\n                    sum = 0;\\n                    while (t-- > 0)\\n                    {\\n                        if (idx == -1)\\n                        {\\n                            idx = n - 1;\\n                        }\\n                        sum += code[idx--];\\n                    }\\n                    ans.push_back(sum);\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942997,
                "title": "java-straightforward-t-s-o-m-runtime-78-80-1-ms-memory-93-29-41-1-mb",
                "content": "# Intuition & Approach\\nThis `decrypt` method that takes an integer array `code` and an integer `k` as input, and it returns an integer array `decrypt` as output. The purpose of this method is to \"decrypt\" the input array `code` using the given value of `k`. \\n\\n**Let\\'s break down the code step by step:**\\n\\n```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n````\\nHere, the method starts by defining a few variables:\\n\\n- `M` represents the length of the input array `code`.\\n\\n- An integer array `decrypt` is created with the same length as `code` to store the decrypted values.\\n\\n- The `if` condition checks if `k` is equal to `0`. If `k` is indeed `0`, then the decrypt array is returned as is (in accordance with the instructions), and the method terminates.\\n\\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\\nIf `k` is not `0`, the method proceeds to this loop. This loop iterates through each index `i` of the `code` array. Here\\'s what happens in each iteration:\\n\\n- A variable `sgn` is set to either `-1` or `1` based on whether `k` is *negative* or *positive*. This is used to control the direction of decryption.\\n\\n- A variable `e` is set to the absolute value of `k`. This determines how many *steps of decryption will be performed*.\\n\\n- An integer variable `v` is initialized to `0`. This variable will accumulate the decrypted value for the current index `i`.\\n\\n- A variable `adj` is set to `M + i` if `k` is negative, or simply `i` if `k` is positive. This `adj` value is used to adjust the index when accessing elements from the `code` array.\\n\\n- An inner loop runs `e` times. In each iteration of the inner loop, it adds the value at the adjusted index `(adj + sgn * j) % M` to the variable `v`.\\n\\n- After the inner loop completes, the decrypted value for the current index `i` is stored in the `decrypt` array.\\n\\nFinally, the decrypted array `decrypt` is returned after the loop has processed all indices of the `code` array.\\n\\nIn summary, `decrypt` method decrypts the input code array by performing a series of circular shifts based on the value of `k`, and the result is stored in the `decrypt` array.\\n\\n\\n# Complexity\\n- Time complexity: $$T(M * e) = O(M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic int[] decrypt(int[] code, int k) {\\n    int M = code.length;\\n    int[] decrypt = new int[M];\\n    \\n    if(k == 0)\\n        return decrypt;\\n```\n```\\nfor(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n    int v = 0, adj = (k < 0) ? M + i : i;\\n    \\n    for(int j = 1; j <= e; j++) \\n        v += code[(adj + sgn * j) % M];\\n\\n    decrypt[i] = v;\\n}\\n```\n``` java []\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int M = code.length;\\n        int[] decrypt = new int[M];\\n        \\n        if(k == 0)\\n            return decrypt;\\n        \\n        for(int i = 0, sgn = (k < 0) ? -1 : 1, e = Math.abs(k); i < M; i++) {\\n            int v = 0, adj = (k < 0) ? M + i : i;\\n            \\n            for(int j = 1; j <= e; j++) \\n                v += code[(adj + sgn * j) % M];\\n\\n            decrypt[i] = v;\\n        }\\n\\n        return decrypt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914589,
                "title": "c-beginner-friendly-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans(n,0);\\n        if(k>0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<=k;j++)\\n                {\\n                    ans[i]=ans[i]+code[(i+j)%n];\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=-1;j>=k;j--)\\n                {\\n                    int ind=(i+j)%n;\\n                    if(ind<0)\\n                    {\\n                        ind=ind+n;\\n                    }\\n                    ans[i]=ans[i]+code[ind];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885410,
                "title": "runtime-54ms-memory-43-10-mb-easy-for-loop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function (code, k) {\\n    let arr = []\\n    if (k == 0) {\\n        return code.fill(0)\\n    }\\n    for (let i = 0; i < code.length; i++) {\\n        let val = 0\\n        let n = 0\\n        if (k < 0) {\\n            for (let j = i-1; n> k; j--) {\\n                 if (!code[j]) {\\n                    j = code.length-1\\n                } \\n                    val = val + code[j]\\n                    n--\\n            }\\n        }\\n        else {\\n            for (let j = i+1; n<k; j++) {\\n                if (!code[j]) {\\n                    j = 0\\n                } \\n                    val = val + code[j]\\n                    n++\\n            }\\n        }\\n        arr.push(val)\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3874629,
                "title": "simple-c-solution",
                "content": "# Intuition\\nGenerate the array just the way it is described in the problem description.\\n\\n# Approach\\nCreate an array of the same size, as all operations are done simultaneously, which means we should not edit the original array.\\n\\nFor every index in the array, we sum all the values that we need. \\n\\nsteps: the amount of steps we make. We have to make a total of abs(k) steps.\\nindex: The index of the value we add to sum. We have code to wrap it around if it goes beyond the array bounds.\\nsum: Sum of the values.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n\\n        vector<int> ans(n, 0);\\n\\n        for(int i = 0; i < code.size(); ++i) {\\n            int steps = 0;\\n            int index = i;\\n            int sum = 0;\\n            while(steps < abs(k)) {\\n                index += (k > 0) ? 1 : -1;\\n                if(index >= n) {\\n                    index = 0;\\n                } else if(index < 0) {\\n                    index = n - 1;\\n                }\\n\\n                sum += code[index];\\n                ++steps;\\n            }\\n\\n            ans[i] = sum;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868122,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        //next ele = (i+1)%n;\\n        //prev ele =(i-1+n)%n;\\n        int n = code.length;\\n        if(k==0)\\n        {\\n            Arrays.fill(code, 0);\\n            return code;\\n        }\\n        else if(k>0)\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i+1)%n;\\n                for(int j=1; j<=k; j++)\\n                {\\n                    sum += code[start];\\n                    start = (start+1)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        else\\n        {\\n            int[] ans = new int[code.length];\\n            for(int i=0; i<code.length; i++)\\n            {\\n                int sum= 0;\\n                int start = (i-1+n)%n;\\n                for(int j=1; j<=Math.abs(k); j++)\\n                {\\n                    sum += code[start];\\n                    start = (start-1+n)%n;\\n                }\\n               ans[i]= sum;\\n               \\n            }\\n            return ans;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861654,
                "title": "by-07chorno-c-o-ms-beats-1oo-the-best-answer-click-now-to-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int L = code.size(), tmp, j;\\n        vector<int> decode(L);\\n\\n        if(k == 0)\\n            return decode;\\n        else if(k > 0)\\n        {\\n            for(int i = 0; i < L; i ++)\\n            {\\n                j = i+1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j == L)\\n                        j = 0;\\n                    decode[i] += code[j++];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            k *= -1;\\n            for(int i = 0; i < L; i++)\\n            {\\n                j = i - 1;\\n                tmp = k;\\n                while(tmp > 0)\\n                {\\n                    if(j < 0)\\n                        j = L - 1;\\n                    decode[i] += code[j--];\\n                    tmp--;\\n                }\\n            }\\n        }\\n        return decode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838391,
                "title": "1652-defuse-the-bomb",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n\\n        int n=code.length;\\n        int res[]=new int[n];\\n\\n        if(k==0)\\n         return res;\\n\\n        else{\\n            int i=0,j=0,sum=0;\\n\\n            while(i<n){\\n                sum+=code[(j+n)%n];\\n\\n                if((j-i+1+n)%n<Math.abs(k))\\n                    j++; \\n\\n                else{\\n\\n                    if(k>0)\\n                     res[(i-1+n)%n]=sum;\\n\\n                    else\\n                     res[(j+1+n)%n]=sum;\\n                    sum-=code[(i+n)%n];\\n                    i++;\\n                    j++; \\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817286,
                "title": "my-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> sum(code.size(), 0);\\n        if(k>0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=1; i<=k; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                    \\n                }\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            for(int index=0; index<code.size(); index++)\\n            {\\n                for(int i=k; i<=-1; i++)\\n                {\\n                    sum[index] += getnumber(code, index+i);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n\\n\\n    int getnumber(vector<int>& code, int index)\\n    {\\n        int N = code.size();\\n        if(index>=0)\\n        {\\n            return code[index % N];\\n        }\\n        else\\n        {\\n            while(index < 0)\\n            {\\n                index += N;\\n            }\\n            return code[index % N];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814537,
                "title": "using-fixed-size-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n      int n = code.size();\\n      vector<int>ans(n,0);\\n      if( k == 0 )\\n      return ans;\\n      int s = 1, e = k;\\n\\n      if( k<0 )\\n      {\\n          k*= -1;\\n          s = n-k;\\n          e = n-1;\\n      }\\n\\n      int sum = 0;\\n      for( int  i = s; i<=e; i++)\\n      {\\n          sum+= code[i];\\n      } \\n\\n      for( int i = 0; i<n; i++)\\n      {\\n          ans[i] = sum;\\n          sum-= code[(s++)%n];\\n          sum+= code[(++e)%n];\\n      } \\n      return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810699,
                "title": "easy-sliding-window-solution-beats-100",
                "content": "\\n# Approach\\nI think this is minor variation of fixed sliding window. \\n1. Here window is fixed however windowstart and windowEnd isn\\'t starting with 0.\\n2. Main idea is how to initialise windowStart i.e. l and windoEnd i.e r. If  k> 0 then l=1 and r=1. Else for negative k -> l,r= code.length + k i.e. if k=-2 and n=4 then l,r = 2\\n3. Like most of sliding window solutions, we will iterate for Math.abs(k) to calculate sum of window. And doing that, we will increment r. We make sure that r is reinitiaze to 0 when it reaches end of array.\\n4. Once we have the window sum, then it is easy sliding window with maintaining boundry condition for both l and r;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n     int[] arr = new int[code.length];\\n     if(k==0){\\n         return arr;\\n     }\\n    int l = k > 0  ? 1 : code.length + k;\\n    int r=l;\\n    int itr = Math.abs(k);\\n    int sum=0;\\n    for(int i=0; i< itr ; i++){\\n        sum+=code[r];\\n        r++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n    }\\n    int idx =0;\\n    while(idx< code.length){\\n        arr[idx] = sum;\\n        sum = sum + code[r] - code[l];    \\n        idx++;\\n        r++;\\n        l++;\\n        if(r== code.length){\\n            r=0;\\n        }\\n        if(l== code.length){\\n            l=0;\\n        }\\n    }\\n     return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809538,
                "title": "defuse-the-bomb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if(k==0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                arr[i]=0;\\n            }\\n        }\\n        else if(k>0)\\n        {\\n            for(int i=0;i<code.length;i++)\\n            {\\n                int sum=0;\\n                for(int j=i+1;j<=i+k;j++)\\n                {\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        else if(k<0)\\n        {\\n            // int p=0;\\n            for(int i=code.length-1;i>=0;i--)\\n            {\\n                int sum=0;\\n                for(int j=i-1;j>=i+k;j--)\\n                {\\n                    if(j<0)\\n                    {\\n                        int l=j+code.length;\\n                        sum=sum+code[l%code.length];\\n                    }\\n                    else\\n                    sum=sum+code[j%code.length];\\n                }\\n                arr[i]=sum;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797556,
                "title": "c-sliding-window-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto work on the circular array .We just need to think of modulo everytime we want to acess the next\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int>ans1(n,0);\\n        vector<int>ans;\\n        int sum=0;\\n        if(k==0){\\n            return ans1;\\n        }\\n        else if(k>0){\\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n\\n            }\\n            return ans;\\n        }\\n        else{\\n            k=-1*k;\\n            reverse(code.begin(),code.end());\\n            //same code as in above \\n            for(int i=0;i<k;i++){\\n                sum+=code[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                sum-=code[i];\\n                sum+=code[(i+k)%n];\\n                ans.push_back(sum);\\n            }\\n            reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781729,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def decrypt(code: Array[Int], k: Int): Array[Int] = {\\n      val n = code.length\\n      val res = Array.ofDim[Int](n)\\n      if (k == 0) res\\n      else if (k > 0) {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to k) sum += code((i + j) % n)\\n          res(i) = sum\\n        }\\n        res\\n      } else {\\n        for (i <- 0 until n) {\\n          var sum = 0\\n          for (j <- 1 to -k) sum += code((i - j + n) % n)\\n          res(i) = sum\\n        }\\n        res\\n      }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3763431,
                "title": "easiest-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>&c , int k){\\n        int n=c.size();\\n        vector<int>v(n,0);\\n        if(k==0){\\n            return v;\\n        }\\n        else if(k>0){\\n            for(int i=0; i<n; i++){\\n                int p = k;\\n                int d = i+1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = d%n;\\n                    sum+=c[idx];\\n                    d++;\\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        else{\\n            for(int i=0; i<n; i++){\\n                int p = -k;\\n                int d = i-1;\\n                int sum=0;\\n                while(p--){\\n                    int idx = (d+n)%n;\\n                    sum+=c[idx];\\n                    d--; \\n                }\\n                v[i]=sum;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732757,
                "title": "solution-1652-defuse-the-bomb",
                "content": "# Intuition\\nThe code aims to decrypt an array of integers using a given key. It iterates through each element in the input array and calls the helperSum function to calculate the decrypted value. The helperSum function calculates the sum of elements based on the given key and the starting index.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] decrypt(int[] code, int k) {\\n        int len = code.length;\\n        int[] ans = new int[len];\\n\\n        for (int i = 0; i < len; i++) {\\n            ans[i] = helperSum(code, i, k, len);\\n        }\\n\\n        return ans;\\n    }\\n\\n    static int helperSum (int[] arr, int start, int k, int len) {\\n        int ans = 0;\\n        int s = start;\\n\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < k; i++) {\\n                ans += arr[(s + i + 1) % len];\\n            }\\n        }\\n\\n        if(k < 0) {\\n            k = Math.abs(k);\\n            int index = s - 1;\\n\\n            for (int i = 1; i <= k; i++) {\\n                if (index== -1) {\\n                    index = len - 1;\\n                }\\n                ans += arr[(index)];\\n                index--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732315,
                "title": "easy-ts-solution",
                "content": "# Code\\n```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction decrypt(code: number[], k: number): number[] {\\n    const codeLen = code.length;\\n    let defuseCode = []\\n\\n    if(k === 0) return Array(codeLen).fill(k)\\n    \\n    let sum = 0;\\n\\n    for(let i = 0; i < codeLen; i++) {\\n        for(let j = 1; j <= Math.abs(k); j++){\\n            const _j = k < 0 ? -j : j;\\n            const index = Math.abs((codeLen+i+_j)%codeLen);\\n            sum += code[index];    \\n        }\\n        defuseCode.push(sum);\\n        sum = 0\\n    }\\n\\n    return defuseCode\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3726835,
                "title": "basic-and-explained-c-solution-easy-to-understand-array-basics-beginner-friendly",
                "content": "# Intuition\\nSure! Let me explain the code in first person and discuss its complexity.\\n\\nIn this code, I see a class named `Solution` with a member function `decrypt`. This function takes a reference to a vector of integers `code` and an integer `k` as input. It aims to decrypt the given code using a specific algorithm.\\n\\n\\n# Approach\\nNow, let\\'s go through the code step by step:\\n\\n1. The code starts with an `if` condition that checks if `k` is equal to 0. If this condition is true, it means there is no encryption to decrypt, so the function creates a new vector `ans` with the same size as `code` and fills it with 0s. This is done to return a vector of zeros as the decryption result.\\n\\n2. If `k` is not equal to 0, the code proceeds to the main decryption logic. It initializes an empty vector `ans` to store the decryption results.\\n\\n3. The code then enters a `for` loop that iterates over the elements of the `code` vector. Inside this loop:\\n   - It initializes `sum` and `count` variables to 0, which will be used to calculate the sum of elements and keep track of the number of elements considered.\\n   - It checks if `k` is greater than 0. If `k` is positive, it means we need to decrypt the code in the forward direction.\\n     - If the current index `i` is the last index of `code`, a nested `for` loop is used to iterate from the first element to the `k`th element of `code`. It calculates the sum of these elements and increments the `count` variable.\\n     - If the current index `i` is not the last index, another nested `for` loop is used to iterate from the next index to `k` elements ahead, wrapping around to the beginning if necessary. Again, it calculates the sum of these elements and increments the `count` variable.\\n   - If `k` is less than or equal to 0, it means we need to decrypt the code in the backward direction. The logic is similar to the forward direction, but it iterates in reverse order and wraps around from the last index to the beginning if necessary.\\n   - Finally, the calculated `sum` is added to the `ans` vector.\\n\\n4. After the loop finishes, the function returns the `ans` vector containing the decrypted code.\\n\\n- # Complexity\\n- Time complexity : The code uses two nested loops, each iterating over the elements of the `code` vector. Therefore, the time complexity is O(n^2), where n is the size of the vector.\\n- - Space complexity : The space complexity is O(n) as it uses additional space to store the decrypted code in the `ans` vector, which has the same size as `code`.\\n\\n![star-wars-bb8.gif](https://assets.leetcode.com/users/images/34d33a9f-faca-4c62-9e31-54d0b6ef0d2b_1688640507.0608313.gif)\\n\\n![upvote-raccoon.gif](https://assets.leetcode.com/users/images/e6ce0476-7e4e-47de-b6ba-05c64c207f7e_1688640515.7785654.gif)\\n\\n#Please do Upvote if you find the solution good\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        if(k == 0)\\n        {\\n            vector<int> ans(code.size(),0);\\n            return ans;\\n        }\\n        vector<int> ans;\\n        int sum,count;\\n        for(int i = 0 ; i<code.size() ; i++)\\n        {\\n            sum = 0;\\n            count = 0 ;\\n            if(k > 0)\\n            {\\n                if(i == code.size()-1)\\n                {\\n                    for(int j = 0 ; j<code.size() , count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i+1 ; j<code.size() ,count<k ; j++)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == code.size()-1)\\n                        {\\n                            j = -1;\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n            else\\n            {\\n                if(i == 0)\\n                {\\n                    for(int j = code.size()-1 ; j>0 , count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                    }\\n                }\\n                else\\n                {\\n                    for(int j = i-1 ; j>=0 ,count<abs(k) ; j--)\\n                    {\\n                        sum = sum + code[j];\\n                        count++;\\n                        if(j == 0)\\n                        {\\n                            j = code.size();\\n                        }\\n                    }\\n                }\\n                ans.push_back(sum);\\n            }\\n        }\\n        return ans;\\n    }\\n}; //Please Upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701654,
                "title": "basic-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[]=new int[code.length];\\n        if(k>0){\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i+k-j)>=code.length)\\n                        sum+=code[(i+k-j)-code.length];\\n                    else\\n                        sum+=code[i+k-j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        if(k<0){\\n            k=-k;\\n            for(int i=0;i<code.length;i++){\\n                int j=0,sum=0;\\n                while(j<k){\\n                    if((i-k+j)<0)\\n                        sum+=code[code.length+i-k+j];\\n                    else\\n                        sum+=code[i-k+j];\\n                    j++;\\n                }\\n                ans[i]=sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692467,
                "title": "day-30",
                "content": "# Complexity\\n- Time complexity:\\n-       O(n * abs(k)), \\n        where n is the length of the code list. This is because for\\n        each element in code, we perform a loop of length abs(k)\\n        to calculate the sum.\\n- Space complexity:\\n-       O(n) \\n        because we create a new list result of size n\\n        to store the decrypted code.\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        n = len(code)\\n        result = [0] * n\\n        \\n        if k != 0:\\n            for i in range(n):\\n                if k > 0:\\n                    for j in range(i + 1, i + k + 1):\\n                        result[i] += code[j % n]\\n                else:\\n                    for j in range(i + k, i):\\n                        result[i] += code[(j + n) % n]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689987,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int arr[] = new int[code.length];\\n        if(k == 0) {\\n            return arr;\\n        }\\n\\n        if(k > 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        if(k < 0) {\\n            for(int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for(int j = 1; j <= k * -1; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n                }\\n                arr[i] = sum;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681291,
                "title": "sliding-window-solution-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n=code.size();\\n        vector<int> v(n);\\n        if(k>0){\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(n+i-1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else if(k<0){\\n            k=-k;\\n            int i=0,j=0,c=-1,sum=0;\\n            while(true){\\n                sum+=code[j%n];\\n                if(j-i+1<k){\\n                    j++;\\n                }\\n                else if(j-i+1==k){\\n                    // cout<<i<<\" \"<<j<<endl;\\n                    if(i%n==0 && j%n==k-1){\\n                        c++;\\n                    }\\n                    v[(j+1)%n]=sum;\\n                    sum-=code[i%n];\\n                    i++;\\n                    j++;\\n                }\\n                if(c==1){\\n                    break;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;++i){\\n                v[i]=0;\\n            }\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3680405,
                "title": "harshi-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& c, int k) {\\n        vector<int> l;\\n       int v=c.size();\\n        for(int i=0;i<c.size();i++){\\n             int s=0;\\n             int o=k;\\n             if(o<0){\\n             int p=abs(o);\\n             for(int j=o;j<0;j++){\\n                 int q;\\n                 if (i+j<0)\\n                    q=v+(i+j);\\n                 else  \\n                    q=i+j;\\n\\n                 s=s+c[q]; \\n                 o++;\\n             }\\n             }\\n             else{\\n                 for(int j=1;j<=o;j++)\\n             {  int r=(i+j)%(v);\\n                 s=s+c[r];\\n             }\\n             }\\n              l.push_back(s);\\n            }\\n        return l;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673326,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr = new int[code.length];\\n        if (k == 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                arr[i] = 0;\\n                return arr;\\n            }\\n        }\\n        int sum = 0;\\n        int ops;\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i + 1 <= code.length - 1 ? i + 1 : 0;\\n                int negative = 0;\\n                while (ops > 0) {\\n                    if (index <= code.length - 1) {\\n                        sum += code[index++];\\n                    } else {\\n                        sum += code[negative++];\\n                    }\\n                    ops--;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        } else {\\n            for (int i = 0; i < code.length; i++) {\\n                ops = k;\\n                int index = i > 0 ? i - 1 : code.length - 1;\\n                int negative = code.length - 1;\\n                while (ops < 0) {\\n                    if (index >= 0) {\\n                        sum += code[index--];\\n                    } else {\\n                        sum += code[negative--];\\n                    }\\n                    ops++;\\n                }\\n                arr[i] = sum;\\n                sum = 0;\\n            }\\n        }\\n        return arr;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665514,
                "title": "naive-method-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        vector<int> res;\\n        int sum = 0, n = code.size(); \\n        for(int i = 0; i<code.size();i++)\\n        {  \\n            sum =0; \\n             \\n            if(k>0)\\n            { \\n                for(int j = i+1;j<=i+k;j++)\\n                sum += code[j%n];\\n            }\\n            else if(k<0)\\n            {   \\n                for(int j =i-1; j>=i+k;j--)\\n                {\\n                     \\n                   sum += code[(j+n)%n];\\n                }\\n            }\\n            \\n            res.push_back(sum);\\n\\n        }\\n        \\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653280,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        int n = code.size();\\n        vector<int> ans(n,0);\\n\\n        if (k==0)\\n            return ans;\\n\\n        for (int i=0 ; i<n ; i++){\\n            int index;\\n            int sum = 0;\\n            if (k>0){\\n                int count = 0;\\n                index = i+1;\\n                while (index < n && count < k){\\n                    sum += code[index++];\\n                    count++;\\n                }\\n                if (count < k){\\n                    index = 0;\\n                    while (count < k){\\n                        sum += code[index++];\\n                        count++;\\n                    }\\n                }\\n            }\\n            else{\\n                int count = 0;\\n                index = i-1;\\n                while (index >= 0 && count < abs(k)){\\n                    sum += code[index--];\\n                    count++;\\n                }\\n                if (count < abs(k)){\\n                    index = n-1;\\n                    while (count < abs(k)){\\n                        sum += code[index--];\\n                        count++;\\n                    }\\n                }\\n            }\\n            ans[i]= sum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645630,
                "title": "go-solution-bomb-decode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decrypt(code []int, k int) []int {\\n    var flag bool\\n\\n    var result []int\\n\\n    if k < 0{\\n        for i := 0; i < len(code) / 2; i ++{\\n            code[i], code[len(code) - 1 - i] = code[len(code) - 1 - i], code[i]\\n        }\\n        flag = true\\n        k *= -1\\n    }\\n\\n    for i := 0; i < len(code); i++{\\n        var num int\\n        for j := 0; j < k; j++{\\n            var val int\\n            val = i + j + 1\\n            if val > len(code) - 1{\\n                val = val - len(code)\\n            }\\n            num += code[val]\\n        }\\n        result = append(result, num)\\n    }\\n\\n    if flag == true{\\n        for i := 0; i < len(result) / 2; i ++{\\n            result[i], result[len(result) - 1 - i] = result[len(result) - 1 - i], result[i]\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641800,
                "title": "java-easy-beginner-friendly-solution-80-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n    int n = code.length;\\n    int arr[] = new int[n];\\n    int sum=0;\\n   // for(int i=0;i<n;i++){\\n        if(k>0){\\n             for(int i=0;i<n;i++){\\n            for(int j=i+1;j<k+i+1;j++){\\n                if(j<n){\\n            sum+=code[j];\\n                }\\n                else{\\n                    sum+=code[j-n];\\n                }\\n            }\\n            arr[i] = sum;\\n        sum = 0;    \\n        }\\n        }\\n        if(k==0){\\n             for(int i=0;i<n;i++){\\n            arr[i] = 0;\\n        }\\n        }\\n        if(k<0) {\\n             for(int i=0;i<n;i++){\\n            for(int l=i-1;l>i-1+k;l--){\\n                if(l<0){\\n                    sum+=code[l+n];\\n                }\\n                else{\\n                    sum+=code[l];\\n                }\\n            }\\n            arr[i] = sum;\\n            sum=0;\\n        }\\n    }\\n    return arr;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629016,
                "title": "defuse-the-bomb-js-intuitive-solution",
                "content": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} code\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar decrypt = function(code, k) {\\n    len = code.length\\n    arr = []\\n\\n    for (let i = 0; i < len; i++) {        \\n        arr.push(scan(i))\\n    }\\n\\n    return arr\\n\\n    function scan(i) {        \\n        sum = 0\\n        s = k\\n\\n        if (s == 0) return 0\\n\\n        while (s > 0) {\\n            n = i + s\\n            if (n >= len) n = n - len             \\n            sum += code[n]\\n            s --\\n        }\\n\\n        while (s < 0) {\\n            n = i + s    \\n            sum += code.at(n)\\n            s ++\\n        }\\n\\n        return sum\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616240,
                "title": "c-100-faster-circular-sliding-window-with-explanation",
                "content": "# Intuition\\nThe problem clearly deals with an array and sub-array with a window size of k.\\n# Approach\\n3 cases:\\n 1. k==0 return res(output array) as it is with all 0s\\n 2. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. \\nElement to be updated given by i-1\\n 3. k>0 - we form a window of size k with pointers i and j, and move till i!=n-1 to ensure we calc the sum for each element. Element to be updated given by (j+1)%array.size()\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1) - excluding the output array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& v, int k) {\\n        \\n        int n(v.size()),i(0),j(0),sum(0);\\n        vector<int> res(n,0);\\n\\n        if(k==0) return res;\\n        else if(k>0)\\n        {\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[n-1]=sum;\\n\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[i-1]=sum;\\n            }\\n        }\\n        else\\n        {\\n            sum=0;\\n            j=0;\\n            i=0;\\n            k=abs(k);\\n            while(j!=k)\\n            {\\n                sum+=v[j];\\n                j++;\\n            }\\n            j=k-1;\\n            res[j+1]=sum;\\n            while(i!=n-1)\\n            {\\n                sum-=v[i];\\n                i++;\\n                j=(j+1)%n;\\n                sum+=v[j];\\n                res[(j+1)%n]=sum;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578348,
                "title": "100-time-beat-memory-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:  O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decrypt(vector<int>& code, int k) \\n    {\\n        int sum=0,n=code.size();\\n        bool flag=true;\\n        if(k<0)\\n        {\\n            k=-k;\\n            flag=false;\\n        }\\n        for(int i=1;i<=k;i++)\\n            sum+=code[i];\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(sum);\\n            sum+=code[(i+1+k)%n];\\n            sum-=code[(i+1)%n];\\n        }\\n        int l=v[0];\\n        if(flag==false)\\n        {\\n            for(int i=0;i<n;i++)\\n               code[i]=v[(n-k-1+i)%n];\\n            return code;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576292,
                "title": "lets-defuse-it-yeahhhhhhhhhhhhhh",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to replace each element in the given code array with the sum of the k elements that come after it (if k > 0) or before it (if k < 0), considering the array wraps around. The intuition is to iterate through the code array and calculate the replacement value based on the specified rules.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution iterates through the code array, calling the ReplaceNum function for each element. In ReplaceNum, the replacement value is calculated by iterating k times in the specified direction (forward or backward), summing up the values encountered. The index is adjusted using the modulo operator for wrapping around the array.\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nint Replacenum(vector<int> &code, int i, int k):\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index];\\n            if(index >= code.size()){\\n                index = 0;\\n            }else{\\n                index++;\\n            }\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        while(k--){\\n            value += code[index];\\n            if(index < 0){\\n                index = code.size()-1;\\n            }else{\\n                index--;\\n            }\\n        }\\n        return value;\\n    }\\n\\nfor(int i=0; i<code.size(); i++){\\n    code[i] = ReplaceNum(code, i, k);\\n}\\n*/\\nclass Solution {\\npublic:\\n\\nint ReplaceNum(vector<int> &code, int i, int k){\\n    int index;\\n    int value = 0;\\n    if(k > 0 ){\\n        index = i+1;\\n        while(k--){\\n            value += code[index % code.size()];\\n            index++;\\n        }\\n        return value;\\n    }\\n    else{\\n        index = i-1;\\n        if(index < 0 ){\\n            index = code.size()-1;\\n        }\\n        value += code[index];\\n        cout << index << \" \";\\n        int reps = abs(k)-1;\\n        while(reps--){\\n            cout << index << \" \";\\n            index--;\\n            if(index < 0){\\n                index = code.size()-1;\\n            }\\n            value += code[index];\\n        }\\n\\n        return value;\\n    };\\n};\\n    vector<int> decrypt(vector<int>& code, int k) {\\n        vector<int> Output_arr(code.size(),0);\\n        if(k == 0){\\n            return Output_arr;\\n        }\\n        for(int i=0; i<code.size(); i++){\\n            Output_arr[i] = ReplaceNum(code, i, k);\\n        }   \\n\\n        return Output_arr;\\n        \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3574874,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decrypt(self, code: List[int], k: int) -> List[int]:\\n        l=len(code)\\n        if k >0:\\n            ls = []\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,k):\\n                    dcode += code[(i+j+1)%l]\\n                ls.append(dcode)\\n        elif k==0:\\n            ls=[0]*l\\n        else:\\n            ls=[]\\n            for i in range(0,l):\\n                dcode=0\\n                for j in range(0,abs(k)):\\n                    dcode += code[(i-j-1)%l]\\n                ls.append(dcode)\\n        return ls\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570432,
                "title": "java-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    private int FindSum(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k-- > 0)\\n        {\\n            sum += code[idx % n];\\n            idx++;\\n        }\\n        return sum;\\n    }\\n    private int FindSum2(int idx, int code[], int k)\\n    {\\n        int sum = 0;\\n        int n = code.length;\\n        while(k++ < 0)\\n        {\\n            sum += code[(idx + n) % n];\\n            idx--;\\n        }\\n        return sum;\\n    }\\n    public int[] decrypt(int[] code, int k) \\n    {\\n        int n = code.length;\\n        int ans[] = new int[n];\\n        if(k == 0) return ans;\\n\\n        if(k > 0)\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum(i + 1, code, k);\\n        }\\n        else\\n        {\\n            for(int i = 0; i < n; i++)\\n                ans[i] = FindSum2(i - 1, code, k);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562620,
                "title": "beginner-friendly-solution-to-the-problem-2ms-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int [] ans = new int[code.length];\\n        int code_length = code.length;\\n        int sum;\\n        int index;\\n        int count;\\n        if(k > 0){\\n            index = 0;\\n            while(index < code_length){\\n                sum = 0;\\n                count = 0;\\n                int i = (index+1)%code_length;\\n                while(count < k){\\n                    sum = sum + code[i];\\n                    i = (i+1)%code_length;\\n                    count++;\\n                }\\n                ans[index] = sum;\\n                index++;\\n            }\\n        }\\n        else if(k < 0){\\n            int [] new_array = reverse_array(code);\\n            ans = decrypt(new_array, k*-1);\\n            ans = reverse_array(ans);\\n        }\\n        else {\\n            return ans;\\n        }\\n        return ans;\\n    }\\n    public int[] reverse_array(int[] array){\\n        int first = 0;\\n        int last = array.length - 1;\\n        while(first <  last){\\n            array[first]  = array[first] + array[last];\\n            array[last] = array[first] - array[last];\\n            array[first] = array[first] - array[last];\\n            first++;\\n            last--;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559879,
                "title": "python-beat-93",
                "content": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def decrypt(self, code, k):\\n        \"\"\"\\n        :type code: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k == 0:\\n            return [0]*len(code)\\n        \\n        # idea is that a circular array\\n        # can be represent as array + array\\n        # ie [5,7,1,4]\\n        # repeated [5,7,1,4,5,7,1,4]\\n        # now apply sliding window from the front\\n        # if k > 0 otherwise start from the back\\n        \\n        repeated = code + code\\n        res = []\\n \\n        if k > 0:\\n            start_index = 0;\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index+1:start_index+1+k]))\\n                start_index+=1\\n        \\n        if k < 0:\\n            start_index = len(repeated)-1\\n            for i in range (len(code)):\\n                res.append(sum(repeated[start_index-abs(k):start_index]))\\n                start_index-=1\\n            res.reverse()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559649,
                "title": "solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n         int[] ans = new int[code.length];\\n        if (k == 0) {\\n            return ans;\\n        }\\n\\n        if (k > 0) {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= k; j++) {\\n                    sum += code[(i + j) % code.length];\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        else {\\n            for (int i = 0; i < code.length; i++) {\\n                int sum = 0;\\n                for (int j = 1; j <= -1 * k; j++) {\\n                    sum += code[(i - j + code.length) % code.length];\\n\\n                }\\n                ans[i] = sum;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556345,
                "title": "defuse-the-bomb-java-easy",
                "content": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int[] arr=new int[code.length];\\n        if(k==0){return arr;}\\n        if(k>0)\\n        {\\n           for(int i=0;i<code.length;i++)\\n           {\\n                arr[i]=kPositive(code,i+1,k);\\n           }\\n            return arr; \\n        }\\n    \\n        for(int i=0;i<code.length;i++)\\n        {\\n            arr[i]=kNegative(code,i-1,k);\\n        }\\n        return arr;\\n        \\n        \\n    }\\n    public int kPositive(int[] code,int index,int k)\\n    {\\n        int postSum=0;\\n        while(k!=0)\\n        {\\n            postSum+=code[(index)%code.length];\\n            index++;\\n            k--;\\n        }\\n        return postSum;\\n    }\\n    public int kNegative(int[] code,int index,int k)\\n    {\\n        int preSum=0;\\n        while(k!=0)\\n        {  \\n            if(index<0)\\n            {\\n                preSum+=code[code.length+index];\\n            }\\n            else\\n            {\\n               preSum+=code[index]; \\n            }\\n            \\n            index--;\\n            k++;\\n        }\\n        return preSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556131,
                "title": "simple-and-easy-approch",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] arr, int k) {\\n        int op[] = new int[arr.length];\\n        int sum=0;\\n        for(int i=0; i<k; i++){\\n            sum+=arr[i];\\n        }\\n        if(k==0){\\n            return op;\\n        }else if(k>0){\\n            for(int i=0; i<arr.length; i++){\\n                op[i]=sum-arr[i]+arr[(i+k)%arr.length];\\n                sum=op[i];\\n            }\\n        }else{\\n            k=k*-1;\\n            for(int i=0; i<arr.length; i++){\\n                sum=0;\\n                for(int j=1; j<=k; j++){\\n                    sum+=arr[(arr.length-j+i)%arr.length];\\n                }\\n                op[i]=sum;\\n            }\\n        }\\n        \\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552363,
                "title": "java-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decrypt(int[] code, int k) {\\n        int ans[] = new int[code.length];\\n        int sum = 0;\\n        if(k<0){            \\n            for(int i=code.length-2;i>=code.length-1+k;i--){\\n                sum += code[i];\\n            }\\n            ans[code.length-1] = sum;\\n            for(int i = code.length-2;i>=0;i--){\\n                int index = i+k < 0 ? code.length+(i+k) : i+k;                \\n                ans[i] = ans[i+1]-code[i]+code[index];\\n            }\\n        }else if(k>0){            \\n            for(int i=1;i<=k;i++){\\n                sum += code[i];\\n            }\\n            ans[0] = sum;\\n            for(int i=1;i<code.length;i++){\\n                int index = i+k>=code.length?i+k-code.length : i+k;\\n                ans[i] = ans[i-1]-code[i]+code[index];\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743482,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 2043876,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1913659,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            },
            {
                "id": 1734530,
                "content": [
                    {
                        "username": "HamzaElkotb",
                        "content": "Call Of Duty, Let\\'s gooo"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": " @[leetcode](https://leetcode.com) `your inline code...your inline code...`"
                    },
                    {
                        "username": "user1269g",
                        "content": "what does returnSize pointer points to?"
                    },
                    {
                        "username": "Nerd69",
                        "content": "It is an integer, and you put the size of the output array there. For this problem just put *returnSize=codeSize; at the top of your code."
                    },
                    {
                        "username": "djslim",
                        "content": "Hard to do without Off-by-one kind of errors (when doing O(n) time)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Deletions to Make String Balanced",
        "question_content": "<p>You are given a string <code>s</code> consisting only of characters <code>&#39;a&#39;</code> and <code>&#39;b&#39;</code>.</p>\n\n<p>You can delete any number of characters in <code>s</code> to make <code>s</code> <strong>balanced</strong>. <code>s</code> is <strong>balanced</strong> if there is no pair of indices <code>(i,j)</code> such that <code>i &lt; j</code> and <code>s[i] = &#39;b&#39;</code> and <code>s[j]= &#39;a&#39;</code>.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of deletions needed to make </em><code>s</code><em> <strong>balanced</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;aababbab&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You can either:\nDelete the characters at 0-indexed positions 2 and 6 (&quot;aa<u>b</u>abb<u>a</u>b&quot; -&gt; &quot;aaabbb&quot;), or\nDelete the characters at 0-indexed positions 3 and 6 (&quot;aab<u>a</u>bb<u>a</u>b&quot; -&gt; &quot;aabbbb&quot;).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bbaaaaabb&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The only solution is to delete the first two characters.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is&nbsp;<code>&#39;a&#39;</code> or <code>&#39;b&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 935701,
                "title": "dp-solution-beats-100-with-explanation",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n\\t\\t//dp stores number of chars to remove to make s.substring(0, i) valid\\n        int[] dp = new int[l + 1];\\n        int bcount = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                //case 1: keep current a. ==> prev chars must be a...a\\n                //so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n                //case 2: remove current a ==> prev chars must be a...ab...b\\n                //so need to remove current a and whatever makes substring before current i valid which is dp[i];\\n                dp[i + 1] = Math.min(dp[i] + 1, bcount);\\n            } else {\\n                //since it is always valid to append \\'b\\' if substring before current i is valid, so just copy whatever makes substring before i valid which is dp[i];\\n                dp[i + 1] = dp[i];\\n                bcount++;\\n            }\\n        }\\n        \\n        return dp[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n\\t\\t//dp stores number of chars to remove to make s.substring(0, i) valid\\n        int[] dp = new int[l + 1];\\n        int bcount = 0;\\n        for (int i = 0; i < l; i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                //case 1: keep current a. ==> prev chars must be a...a\\n                //so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n                //case 2: remove current a ==> prev chars must be a...ab...b\\n                //so need to remove current a and whatever makes substring before current i valid which is dp[i];\\n                dp[i + 1] = Math.min(dp[i] + 1, bcount);\\n            } else {\\n                //since it is always valid to append \\'b\\' if substring before current i is valid, so just copy whatever makes substring before i valid which is dp[i];\\n                dp[i + 1] = dp[i];\\n                bcount++;\\n            }\\n        }\\n        \\n        return dp[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997750,
                "title": "6-different-approaches-from-basic-to-the-most-optimal-c",
                "content": "Approach 1: Three passes with space O(n)\\nIn the first pass, we compute vector \"b\" which stores the count of character \\'b\\'. \\nIn the second pass, we compute vector \"a\" which stores the count of character \\'a\\'.\\nIn the third pass, we iterate through the string s. \\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        vector<int> b(n,0);\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            b[i]=c;\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++) ans=min(ans,a[i]+b[i]);\\n        return ans;\\n        \\n    }\\n\\nApproach2: Two passes with space O(n)\\nWe compute vector a, and instead of computing vector b, we do the processing while iterating through the string itself.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(a[i]+c,ans);\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        return ans;\\n    }\\n\\nApproach 3: Two passes with space O(1).\\nInstead of using vector a and b, we use two variables count_a and count_b.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        //get the count of a\\'s in the first pass\\n        int count_a=0;\\n        for(int i=0;i<n;i++) if (s[i]==\\'a\\') count_a++;\\n        int count_b=0;\\n        int ans=n;\\n        //second pass\\n        //as you iterate through the string count b\\n        for(int i=0;i<n;i++)\\n        {\\n            if (s[i]==\\'a\\') count_a--;\\n            ans=min(ans,count_a+count_b);\\n            if (s[i]==\\'b\\') count_b++;\\n        }\\n        return ans;\\n        \\n    }\\n\\nApproach 4: Using stack(one pass and space O(n))\\n\\nIf we delete all occurrences of \"ba\", then we can get the desired string. We use stack for that.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        stack<char> stk;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n                stk.pop(),c++;\\n            else stk.push(s[i]);\\n        }\\n        return c;\\n    }\\n\\nApproach 5: Using DP approach: one pass with space O(n)\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') dp[i+1]=dp[i],count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                dp[i+1]=min(dp[i]+1,count_b);\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n\\nApproach 6: \\n\\nOne pass space O(1)\\nimprovisation on the approach 5\\n\\nNote that in the dp approach, to obtain the value of dp[i+1], we only need dp[i], and not dp[0]...dp[i-1]\\nHence, instead of dp array, we can also use a variable called ans to store dp[i].\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        //corresponingly ans variable represents dp[i]\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                ans=min(ans+1,count_b);\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "Approach 1: Three passes with space O(n)\\nIn the first pass, we compute vector \"b\" which stores the count of character \\'b\\'. \\nIn the second pass, we compute vector \"a\" which stores the count of character \\'a\\'.\\nIn the third pass, we iterate through the string s. \\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        vector<int> b(n,0);\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            b[i]=c;\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        for(int i=0;i<n;i++) ans=min(ans,a[i]+b[i]);\\n        return ans;\\n        \\n    }\\n\\nApproach2: Two passes with space O(n)\\nWe compute vector a, and instead of computing vector b, we do the processing while iterating through the string itself.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> a(n,0);\\n        int c=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            a[i]=c;\\n            if (s[i]==\\'a\\') c++;\\n        }\\n        int ans=n;\\n        c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(a[i]+c,ans);\\n            if (s[i]==\\'b\\') c++;\\n        }\\n        return ans;\\n    }\\n\\nApproach 3: Two passes with space O(1).\\nInstead of using vector a and b, we use two variables count_a and count_b.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        //get the count of a\\'s in the first pass\\n        int count_a=0;\\n        for(int i=0;i<n;i++) if (s[i]==\\'a\\') count_a++;\\n        int count_b=0;\\n        int ans=n;\\n        //second pass\\n        //as you iterate through the string count b\\n        for(int i=0;i<n;i++)\\n        {\\n            if (s[i]==\\'a\\') count_a--;\\n            ans=min(ans,count_a+count_b);\\n            if (s[i]==\\'b\\') count_b++;\\n        }\\n        return ans;\\n        \\n    }\\n\\nApproach 4: Using stack(one pass and space O(n))\\n\\nIf we delete all occurrences of \"ba\", then we can get the desired string. We use stack for that.\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        stack<char> stk;\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n                stk.pop(),c++;\\n            else stk.push(s[i]);\\n        }\\n        return c;\\n    }\\n\\nApproach 5: Using DP approach: one pass with space O(n)\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        vector<int> dp(n+1,0);\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') dp[i+1]=dp[i],count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                dp[i+1]=min(dp[i]+1,count_b);\\n            }\\n        }\\n        return dp[n];\\n        \\n    }\\n\\nApproach 6: \\n\\nOne pass space O(1)\\nimprovisation on the approach 5\\n\\nNote that in the dp approach, to obtain the value of dp[i+1], we only need dp[i], and not dp[0]...dp[i-1]\\nHence, instead of dp array, we can also use a variable called ans to store dp[i].\\n\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int ans=0;\\n        int count_b=0;\\n        //dp(i) gives the number of characters to be deleted to make substring s(0,i) valid\\n        //corresponingly ans variable represents dp[i]\\n        for(int i=0;i<n;i++)\\n        {\\n            //it is always valid to append b at the \\n            if (s[i]==\\'b\\') count_b++;\\n            else\\n            {\\n                //two cases arise\\n                //case1: we remove a\\n                //case2: keep a, then count_b number of characters will need to be removed\\n                ans=min(ans+1,count_b);\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935373,
                "title": "c-stack-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //Idea is to traverse from right to left & use stack to keep track if \\'b\\' comes before \\'a\\' in string\\n    //then we need to pop & need to delete that character\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int n =s.size();\\n        int res = 0;\\n        \\n        for(int i = n-1; i >=0; i--){\\n            char c = s[i];\\n            if(!st.empty() && st.top() < c){\\n                res++;\\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Idea is to traverse from right to left & use stack to keep track if \\'b\\' comes before \\'a\\' in string\\n    //then we need to pop & need to delete that character\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int n =s.size();\\n        int res = 0;\\n        \\n        for(int i = n-1; i >=0; i--){\\n            char c = s[i];\\n            if(!st.empty() && st.top() < c){\\n                res++;\\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936436,
                "title": "java-python-3-two-codes-1-pass-and-2-passes-w-brief-explanation-and-analysis",
                "content": "**Method 1: Use stack to cancel bad pairs**\\n\\nWhenever encounter a pair of `\"ba\"`, cancel both of them and count the number of cancellations; \\nWhy this works? \\nWhether delete `a` or `b` depending on the the character right after the last cancellation is `a` or `b`; If `a`, we have to delete `b`\\'s in all cancellations, otherwise delete either `a`\\'s or `b`\\'s. Therefore, we are sure there is no `ba` in the string.\\n\\n\\n**Q & A:**\\n\\nQ1: For this approach, it seems to be that it is more of `finding the number of deletions` rather than the `minimum` number of deletions. is there a proof that using a stack and cancelling bad pairs would lead us to the minimum deletions rather than just finding the number of deletions?\\nA1: All indices of character(s) inside stack are less than that  of those outside. Therefore, whenever we find a `\\'b\\'` inside and a `\\'a\\'` outside of the stack, we have to delete 1 (either `\\'a\\'` or `\\'b\\'`) to make the string balanced. In short, if there are total n bad pairs, then there must be n `\\'b\\'`\\'s in front of n `\\'a\\'`\\'s, and the n is the minimum deletions.\\n\\n**End of Q & A**.\\n\\n```java\\n    public int minimumDeletions(String s) {\\n        int cnt = 0;\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (char c : s.toCharArray()) {\\n            if (!stk.isEmpty() && stk.peek() == \\'b\\' && c == \\'a\\') {\\n                stk.pop();\\n                ++cnt;\\n            }else {\\n                stk.push(c);\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        cnt, stack = 0, []\\n        for c in s:\\n            if stack and stack[-1] == \\'b\\' and c == \\'a\\':\\n                stack.pop()\\n                cnt += 1\\n            else:\\n                stack.append(c)\\n        return cnt\\n```\\n**Analysis:**\\n\\nTime & space: O(n), n = s.length().\\n\\n----\\n\\n**Method 2: Two passes with space O(1).**\\n\\nCount the total occurrences of `\\'a\\'` on the right and `\\'b\\'` on the left for each index, find the mininum;\\n\\n```java\\n    public int minimumDeletions(String s) {\\n        int a = s.chars().map(i -> i == \\'a\\' ? 1 : 0).sum();\\n        int cnt = a, b = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'b\\') {\\n                cnt = Math.min(cnt, a + b++);\\n            }else {\\n                --a;\\n            }\\n        }\\n        return Math.min(cnt, b);\\n    }\\n```\\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        a, b, cnt = s.count(\\'a\\'), 0, len(s)\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt = min(cnt, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(cnt, b)\\n```\\n**Analysis:**\\n\\nTime: O(n), space: O(1), n = s.length().\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minimumDeletions(String s) {\\n        int cnt = 0;\\n        Deque<Character> stk = new ArrayDeque<>();\\n        for (char c : s.toCharArray()) {\\n            if (!stk.isEmpty() && stk.peek() == \\'b\\' && c == \\'a\\') {\\n                stk.pop();\\n                ++cnt;\\n            }else {\\n                stk.push(c);\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        cnt, stack = 0, []\\n        for c in s:\\n            if stack and stack[-1] == \\'b\\' and c == \\'a\\':\\n                stack.pop()\\n                cnt += 1\\n            else:\\n                stack.append(c)\\n        return cnt\\n```\n```java\\n    public int minimumDeletions(String s) {\\n        int a = s.chars().map(i -> i == \\'a\\' ? 1 : 0).sum();\\n        int cnt = a, b = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (s.charAt(i) == \\'b\\') {\\n                cnt = Math.min(cnt, a + b++);\\n            }else {\\n                --a;\\n            }\\n        }\\n        return Math.min(cnt, b);\\n    }\\n```\n```python\\n    def minimumDeletions(self, s: str) -> int:\\n        a, b, cnt = s.count(\\'a\\'), 0, len(s)\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt = min(cnt, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(cnt, b)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935464,
                "title": "python-dp-o-n-short-with-explanation",
                "content": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        cnt_b = 0\\n        dp = [0]\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt_b+=1\\n                dp.append( dp[-1] )\\n            else:\\n                dp.append( min(cnt_b,dp[-1]+1) )\\n        return dp[-1]\\n```\\nThe problem can be formulated as DP.\\n\\nAt every point when you see  \\'a\\' , you have 2 options, \\n1. remove all the b\\'s you found earlier.  --> total cost = count_of_b\\nOR\\n2. delete the current \\'a\\'. --> total cost = cur_total_cost + 1\\n\\nIf u see a \\'b\\' , then no more cost.\\n\\nThus maintain the count of \\'b\\'s you found. \\n\\nPlease Upvote!",
                "solutionTags": [],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        cnt_b = 0\\n        dp = [0]\\n        for c in s:\\n            if c == \\'b\\':\\n                cnt_b+=1\\n                dp.append( dp[-1] )\\n            else:\\n                dp.append( min(cnt_b,dp[-1]+1) )\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 935372,
                "title": "c-find-split-location-simple-o-n-time-o-1-mem",
                "content": "My intuition for this problem is to keep track of the extra As and Bs to the right and left of each position and find the position with the minimun extra letters. \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int as = 0, bs = 0;\\n        for( const char& c : s )\\n            if( c == \\'a\\' )\\n                ++as;\\n        \\n        int del = as;\\n        for( const char& c : s )\\n        {\\n            if( c == \\'b\\' )\\n                ++bs;\\n            else\\n                --as;\\n            \\n            del = min( del, (as+bs) );\\n        }\\n        return del;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int as = 0, bs = 0;\\n        for( const char& c : s )\\n            if( c == \\'a\\' )\\n                ++as;\\n        \\n        int del = as;\\n        for( const char& c : s )\\n        {\\n            if( c == \\'b\\' )\\n                ++bs;\\n            else\\n                --as;\\n            \\n            del = min( del, (as+bs) );\\n        }\\n        return del;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935422,
                "title": "python-greedy-iterate-from-the-back",
                "content": "Refer to @wareag1e in the comment, the explanation is way better there.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        a = 0\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'a\\':\\n                a += 1\\n            elif s[i] == \\'b\\':\\n                if a > 0:\\n                    a -= 1\\n                    res += 1\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        a = 0\\n        res = 0\\n        for i in range(n - 1, -1, -1):\\n            if s[i] == \\'a\\':\\n                a += 1\\n            elif s[i] == \\'b\\':\\n                if a > 0:\\n                    a -= 1\\n                    res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 935399,
                "title": "c-minimalism-o-n",
                "content": "#### Approach 1: Find the split point\\n```cpp\\nint minimumDeletions(string s) {\\n    int a = count(begin(s), end(s), \\'a\\'), b = 0, res = a;\\n    for (auto ch : s) {\\n        b += ch == \\'b\\';\\n        a -= ch == \\'a\\';\\n        res = min(res, b + a);\\n    }\\n    return res;\\n}\\n```\\n\\n#### Approach 2: Simulation\\nWe count the total number of \\'a\\' and \\'b\\'. Then, we \"eat\" all \\'a\\' from the left, and all \\'b\\' from the right.\\n\\nNow, we are at the decision point - do we remove from left of right?\\n\\nIt seems that greedy got accepted - we remove the charracter with the smaller count - but I am still thinking of the proof.\\n\\n```cpp\\nint minimumDeletions(string s) {\\n    int a = 0, b = 0, l = 0, r = s.size() - 1, res = 0;\\n    for (auto ch : s) {\\n        a += ch == \\'a\\'; \\n        b += ch == \\'b\\';\\n    }\\n    while (l < r) {\\n        if (a && s[l] == \\'a\\') {\\n            ++l;\\n            --a;\\n        }\\n        else if (b && s[r] == \\'b\\') {\\n            --r;\\n            --b;\\n        }\\n        else {\\n            ++res;\\n            if (a < b) {\\n                --a;\\n                --r;\\n            }\\n            else {\\n                --b;\\n                ++l;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minimumDeletions(string s) {\\n    int a = count(begin(s), end(s), \\'a\\'), b = 0, res = a;\\n    for (auto ch : s) {\\n        b += ch == \\'b\\';\\n        a -= ch == \\'a\\';\\n        res = min(res, b + a);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint minimumDeletions(string s) {\\n    int a = 0, b = 0, l = 0, r = s.size() - 1, res = 0;\\n    for (auto ch : s) {\\n        a += ch == \\'a\\'; \\n        b += ch == \\'b\\';\\n    }\\n    while (l < r) {\\n        if (a && s[l] == \\'a\\') {\\n            ++l;\\n            --a;\\n        }\\n        else if (b && s[r] == \\'b\\') {\\n            --r;\\n            --b;\\n        }\\n        else {\\n            ++res;\\n            if (a < b) {\\n                --a;\\n                --r;\\n            }\\n            else {\\n                --b;\\n                ++l;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038781,
                "title": "simple-python-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```\\n\\nAt every point in our traversal, if we encounter an \"a\", we can either delete every \"b\" up to that point, or we can delete that one \"a\".\\n\\n```result``` keeps a running total of the number of deletions we have made so far to keep the string up until the current point balanced.\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        result = 0\\n        b_count = 0\\n        \\n        for c in s:\\n            if c == \"a\":\\n                result = min(b_count, result + 1)\\n            else:\\n                b_count += 1\\n        \\n        return result\\n```\n```result```",
                "codeTag": "Java"
            },
            {
                "id": 1020107,
                "title": "python-dp-solution-easy-to-understand",
                "content": "* O(n) for loop each character of the string s\\n* Track the minimum number of deletions to make a balanced string till current character, either ending with \\'a\\' or \\'b\\'.\\n* In the end, find the min of these two numbers\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        # track the minimum number of deletions to make the current string balanced ending with \\'a\\', \\'b\\'\\n        end_a, end_b = 0,0 \\n        for val in s:\\n            if val == \\'a\\':\\n                # to end with \\'a\\', nothing to do with previous ending with \\'a\\'\\n                # to end with \\'b\\', need to delete the current \\'a\\' from previous ending with \\'b\\'\\n                end_b += 1\\n            else:\\n                # to end with \\'a\\', need to delete the current \\'b\\' from previous ending with \\'a\\'\\n                # to end with \\'b\\', nothing to do, so just pick smaller of end_a, end_b\\n                end_a, end_b = end_a+1, min(end_a, end_b)\\n        return min(end_a, end_b)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        # track the minimum number of deletions to make the current string balanced ending with \\'a\\', \\'b\\'\\n        end_a, end_b = 0,0 \\n        for val in s:\\n            if val == \\'a\\':\\n                # to end with \\'a\\', nothing to do with previous ending with \\'a\\'\\n                # to end with \\'b\\', need to delete the current \\'a\\' from previous ending with \\'b\\'\\n                end_b += 1\\n            else:\\n                # to end with \\'a\\', need to delete the current \\'b\\' from previous ending with \\'a\\'\\n                # to end with \\'b\\', nothing to do, so just pick smaller of end_a, end_b\\n                end_a, end_b = end_a+1, min(end_a, end_b)\\n        return min(end_a, end_b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935481,
                "title": "java-dp-17-ms-faster-than-100-00-39-7-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int dp = 0, cntb = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'a\\') dp = Math.min(dp + 1, cntb);\\n            else ++cntb;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int dp = 0, cntb = 0;\\n        for (char c : s.toCharArray()) {\\n            if (c == \\'a\\') dp = Math.min(dp + 1, cntb);\\n            else ++cntb;\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878367,
                "title": "java-simple-and-easy-to-understand-with-comments-o-n-time",
                "content": "The whole problem boils down to the positions of A and B (using A and B instead of \\'a\\' and \\'b\\' so its easier to read and understand). All is good until all the As are before the Bs. It is balanced. It becomes a problem when As appears after Bs.\\n\\nTo solve it, start going through the string, char by char, and keep a count of the Bs (increment it). Once you have your Bs, then if an A appears, then you have to cut down a A for every B (decrement it) only if the count of B is greater than 0. You also need to track the number of decrements of Bs counts (total number of removals).\\n\\nConsider this string - aabbabb\\n\\nAll is well and good until its index = 4 (\\'a\\'). Now the countB = 2, decrement it (becomes 1), and increment the removal (becomes 1).\\n\\n```\\npublic static int minimumDeletions(String s) {\\n\\n        if (s == null || s.isEmpty()) return 0;\\n\\n        int countB = 0; //keep a count of Bs\\n        int removals = 0; //keep a count of removed As\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            if (s.charAt(i) == \\'a\\') {\\n                if (countB > 0) { // only if there are Bs before this A\\n                    ++removals; // remove this A\\n                    --countB; // and decrement the Bs count\\n                }\\n            } else {\\n                ++countB; // keep incrementing the Bs count\\n            }\\n        }\\n       return removals;\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int minimumDeletions(String s) {\\n\\n        if (s == null || s.isEmpty()) return 0;\\n\\n        int countB = 0; //keep a count of Bs\\n        int removals = 0; //keep a count of removed As\\n\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            if (s.charAt(i) == \\'a\\') {\\n                if (countB > 0) { // only if there are Bs before this A\\n                    ++removals; // remove this A\\n                    --countB; // and decrement the Bs count\\n                }\\n            } else {\\n                ++countB; // keep incrementing the Bs count\\n            }\\n        }\\n       return removals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 943968,
                "title": "java-dp-accepted-explanation",
                "content": "**We use Dynamic programming approach because for each substring we need to consider all cases !**\\n\\nFor the sake of explanation:\\n1. we iterate from left->right\\n2. we consider ideal case for us as \"bbbbbbbbbbbbbbb.......bbb\"\\n\\nWe move from left->right and so we consider the ideal case as all b\\'s because any number of b\\'s is valid as move from left->right(with no a\\'s in between).\\n\\nSo we consider \\'b\\' as our friendly character and \\'a\\' as our enemy .\\n\\n**So whenever we see a \\'b\\' we just increase the bCount by one and our answer for that particular substring(0..i) is dp[idx-1].**\\n\\n**But if we see an \\'a\\' then we need to take into consideration 2 cases :**\\n\\n**case 1:** keep current a. ==> prev chars must be a...a , so need to remove all \\'b\\' chars before i, which is bcount\\n                \\n **case 2:** remove current a ==> prev chars must be a...ab...b, so need to remove current a and whatever makes substring before current i valid which is dp[idx-1]+1;\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        //ideal case :  bbbbbbbbb\\n        int[] dp =  new int[s.length()+1];\\n        int idx =1;\\n        int bCount=0;\\n        \\n        for(int i =0 ;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n             dp[idx] = Math.min(dp[idx-1]+1,bCount);   \\n            }\\n            else\\n            {\\n                dp[idx]=dp[idx-1];\\n                bCount++;\\n            }\\n            \\n            idx++;\\n        }\\n        return dp[s.length()];\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        //ideal case :  bbbbbbbbb\\n        int[] dp =  new int[s.length()+1];\\n        int idx =1;\\n        int bCount=0;\\n        \\n        for(int i =0 ;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'a\\')\\n            {\\n             dp[idx] = Math.min(dp[idx-1]+1,bCount);   \\n            }\\n            else\\n            {\\n                dp[idx]=dp[idx-1];\\n                bCount++;\\n            }\\n            \\n            idx++;\\n        }\\n        return dp[s.length()];\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912995,
                "title": "python-easy-to-read-and-understand-stack",
                "content": "**Count the total number of ba pairs**\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack, res = [], 0\\n        for i in range(len(s)):\\n            if stack and s[i] == \"a\" and stack[-1] == \"b\":\\n                stack.pop()\\n                res += 1\\n            else:\\n                stack.append(s[i])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "**Count the total number of ba pairs**\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack, res = [], 0\\n        for i in range(len(s)):\\n            if stack and s[i] == \"a\" and stack[-1] == \"b\":\\n                stack.pop()\\n                res += 1\\n            else:\\n                stack.append(s[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1025601,
                "title": "c-o-n-time-complexity-and-o-1-space",
                "content": "Greedy. Use bCnt to record count for preserved b (have no way to be replaced by a) up till now, use res to record deletion count.  \\n\\nTraverse string s, for each char ch:\\n(1) If it\\'s b, we don\\'t know whether to delete it or not, only increase bCnt by 1. \\n(2) If it\\'s a, we will make deletion only when bCnt is > 0, which means there\\'re b preserved before and has no way to be replaced by traversed a. We might delete current a, or delete previous b, but we don\\'t know yet since this is decided by furture remainig chars. But no matter what we delete, the deletion cnt res will always increase by 1. Use the greedy idea, even if we delete current a, still decrease bCnt by 1 to indicate this b can be replaced by a if later we need it to be replaced\\n\\neg1. aabba\\naabb -> res = 0, bCnt = 2; \\naabba -> res = 1, bCnt = 1; \\nans: aabb\\n\\neg2. aabbaaa\\naabb -> res = 0, bCnt = 2; \\naabba -> res = 1, bCnt = 1 (aabb, or aaba)\\naabbaa -> res = 2, bCnt = 0 (aabb, or aaaa)\\naabbaaa -> res = 2, bCnt = 0 (aaaaa)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCnt = 0;\\n        int res = 0;\\n        for (char& ch : s) {\\n            if (ch == \\'a\\' && bCnt > 0) {\\n                bCnt--;\\n                res++;\\n            }\\n            if (ch == \\'b\\') {\\n                bCnt++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCnt = 0;\\n        int res = 0;\\n        for (char& ch : s) {\\n            if (ch == \\'a\\' && bCnt > 0) {\\n                bCnt--;\\n                res++;\\n            }\\n            if (ch == \\'b\\') {\\n                bCnt++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948123,
                "title": "simple-c-solution-beats-90",
                "content": "The idea is really simple; you basically count the number of \\'a\\' characters in the string, and then iterate over the string to count the number of \\'b\\' characters. The sum of these 2 values at a given index is the number of deletions you need to make in order to balance the string. \\n\\nFrom there you simply return the minimum sum (deleteCount);\\n\\n```cpp\\nclass Solution {\\n    public:\\n        int minimumDeletions(string s) {\\n            int rightA = 0;\\n            int leftB = 0;\\n\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\'){\\n                    rightA += 1;\\n                }\\n            }\\n\\n            int deleteCount = leftB + rightA;\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\') {\\n                    rightA -= 1;\\n                } else {\\n                    leftB += 1;\\n                }\\n                \\n                if (leftB + rightA < deleteCount){\\n                    deleteCount = leftB + rightA;\\n                }\\n            }\\n            return deleteCount;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\n    public:\\n        int minimumDeletions(string s) {\\n            int rightA = 0;\\n            int leftB = 0;\\n\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\'){\\n                    rightA += 1;\\n                }\\n            }\\n\\n            int deleteCount = leftB + rightA;\\n\\n            for (int i=0; i<s.length(); i++){\\n                if (s[i] == \\'a\\') {\\n                    rightA -= 1;\\n                } else {\\n                    leftB += 1;\\n                }\\n                \\n                if (leftB + rightA < deleteCount){\\n                    deleteCount = leftB + rightA;\\n                }\\n            }\\n            return deleteCount;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510493,
                "title": "c-explained-intuitive-approach",
                "content": "My approach without using DP.\\n\\nThe resultant string must have all `a\\'s` to left and all `b\\'s` to the right.\\n\\n*  Count for every index, `number of b\\'s to there left` call it as array `bvec`\\n*  Count for every index, `number of a\\'s to there right`call it as array `avec`\\n*  Now, to remove all `b` from left and all `a` from right we need one index from which it will be minimum.\\n*  Therefore, we will traverse both the array and find the minimum `bvec[i] + avec[i]` for some `i` where `0 <= i < n`\\n\\nCode : \\n```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n = s.length();\\n        vector<int> bvec(n);\\n        vector<int> avec(n);\\n        \\n        int cnt = 0;\\n        // generate array for every index number of b\\'s to there left\\n        for(int i = 0; i < n; i++){\\n            bvec[i] = cnt;\\n            if(s[i] == \\'b\\'){\\n                cnt++;\\n            }\\n        }\\n        cnt = 0;\\n        // generate array for every index number of a\\'s to there right\\n        for(int i = n - 1; i >= 0; i--){\\n            avec[i] = cnt;\\n            if(s[i] == \\'a\\'){\\n                cnt++;\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            mini = min(mini, bvec[i] + avec[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n = s.length();\\n        vector<int> bvec(n);\\n        vector<int> avec(n);\\n        \\n        int cnt = 0;\\n        // generate array for every index number of b\\'s to there left\\n        for(int i = 0; i < n; i++){\\n            bvec[i] = cnt;\\n            if(s[i] == \\'b\\'){\\n                cnt++;\\n            }\\n        }\\n        cnt = 0;\\n        // generate array for every index number of a\\'s to there right\\n        for(int i = n - 1; i >= 0; i--){\\n            avec[i] = cnt;\\n            if(s[i] == \\'a\\'){\\n                cnt++;\\n            }\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            mini = min(mini, bvec[i] + avec[i]);\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935616,
                "title": "easy-to-understand-solutions-with-optimization",
                "content": "To begin with, we can think about that **if we want to obtain the min deletion, what we can do?** For each index, if we find a pair that is not banlanced, we must do 2 things to make it banlanced:\\n\\n**1. Delete all \\'b\\'s before this index**\\n\\t**2. Delete all \\'a\\'s on and after this index**\\n\\nThen we can compare those **sums of deleting times** to find the min.\\n\\nSo, we can use 2 array, *aSum* represents **how many \\'a\\'s on its right**, *bSum* represents **how many \\'b\\'s on its left**.\\n```\\npublic int minimumDeletions(String s) {\\n\\tint length = s.length(), aSum[] = new int[length], bSum[] = new int[length], curMin = Integer.MAX_VALUE;\\n\\tfor (int i = length - 1; i >= 0; i--) {\\n\\t\\taSum[i] = (i < length - 1 ? aSum[i + 1] : 0) + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tbSum[i] = (i > 0 ? bSum[i - 1] : 0) + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length + 1; i++) {\\n\\t\\tcurMin = Math.min(curMin, (i > 0 ? bSum[i - 1] : 0) + (i == length ? 0 : aSum[i]));\\n\\t}\\n\\treturn curMin;\\n}\\n```\\n\\nWe also notice that each element in *aSum* and *bSum* is only use once, so **we can change that 2 arrays to 2 variables**:\\n```\\npublic int minimumDeletions(String s) {\\n\\tint aSum = 0, bSum = 0; \\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (c == \\'a\\')\\n\\t\\t\\taSum += 1;\\n\\t\\telse {\\n\\t\\t\\taSum = Math.min(aSum, bSum);\\n\\t\\t\\tbSum += 1;\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(aSum, bSum);\\n}\\n```\\n\\n**Now we can see the space complexity reduce from O(n) to O(1).**\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(String s) {\\n\\tint length = s.length(), aSum[] = new int[length], bSum[] = new int[length], curMin = Integer.MAX_VALUE;\\n\\tfor (int i = length - 1; i >= 0; i--) {\\n\\t\\taSum[i] = (i < length - 1 ? aSum[i + 1] : 0) + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length; i++) {\\n\\t\\tbSum[i] = (i > 0 ? bSum[i - 1] : 0) + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n\\t}\\n\\tfor (int i = 0; i < length + 1; i++) {\\n\\t\\tcurMin = Math.min(curMin, (i > 0 ? bSum[i - 1] : 0) + (i == length ? 0 : aSum[i]));\\n\\t}\\n\\treturn curMin;\\n}\\n```\n```\\npublic int minimumDeletions(String s) {\\n\\tint aSum = 0, bSum = 0; \\n\\tfor (char c : s.toCharArray()) {\\n\\t\\tif (c == \\'a\\')\\n\\t\\t\\taSum += 1;\\n\\t\\telse {\\n\\t\\t\\taSum = Math.min(aSum, bSum);\\n\\t\\t\\tbSum += 1;\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(aSum, bSum);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1189982,
                "title": "top-down-dp-and-greedy-solution-c",
                "content": "### Top Down Dynamic Programming\\n\\n182 ms\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001][2];\\n    \\n    int getMinDeletions(string& s, bool bPrev = false, int current = 0) {\\n        if(current >= s.size()) return 0;\\n        if(dp[current][(int)bPrev]) return dp[current][(int)bPrev];\\n        char ch = s[current];\\n        if(ch == \\'a\\' && bPrev) { // Delete the current a\\n            dp[current][(int)bPrev] = 1 + getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(bPrev) { // Continue since current is b\\n            dp[current][(int)bPrev] =  getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(ch == \\'a\\') { // If no b before and current a\\n            dp[current][(int)bPrev] = getMinDeletions(s,false,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        // Current is b\\n        dp[current][(int)bPrev] = min(getMinDeletions(s,true,current+1), 1 + getMinDeletions(s,false,current+1));\\n        return dp[current][(int)bPrev];\\n    }\\n    \\n    int minimumDeletions(string s) {\\n        memset(dp,0,sizeof(dp));\\n        return getMinDeletions(s);\\n    }\\n};\\n```\\n\\n### Greedy Approach\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumDeletions(string s) {\\n        int prefA[s.size()+1];\\n        int prefB[s.size()+1];\\n        memset(prefA, 0, sizeof(prefA));\\n        memset(prefB, 0, sizeof(prefB));\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            prefA[i+1] = prefA[i] + (s[i] == \\'a\\' ? 1 : 0);\\n            prefB[i+1] = prefB[i] + (s[i] == \\'b\\' ? 1 : 0);\\n        }\\n        \\n        int minMoves = INT_MAX;\\n        \\n        for(int i=0; i<=s.size(); i++) {\\n            minMoves = min(minMoves, prefB[i] + (prefA[s.size()] - prefA[i]));\\n        }\\n        \\n        return minMoves;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[100001][2];\\n    \\n    int getMinDeletions(string& s, bool bPrev = false, int current = 0) {\\n        if(current >= s.size()) return 0;\\n        if(dp[current][(int)bPrev]) return dp[current][(int)bPrev];\\n        char ch = s[current];\\n        if(ch == \\'a\\' && bPrev) { // Delete the current a\\n            dp[current][(int)bPrev] = 1 + getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(bPrev) { // Continue since current is b\\n            dp[current][(int)bPrev] =  getMinDeletions(s,true,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        if(ch == \\'a\\') { // If no b before and current a\\n            dp[current][(int)bPrev] = getMinDeletions(s,false,current+1);\\n            return dp[current][(int)bPrev];\\n        }\\n        // Current is b\\n        dp[current][(int)bPrev] = min(getMinDeletions(s,true,current+1), 1 + getMinDeletions(s,false,current+1));\\n        return dp[current][(int)bPrev];\\n    }\\n    \\n    int minimumDeletions(string s) {\\n        memset(dp,0,sizeof(dp));\\n        return getMinDeletions(s);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\npublic:\\n    int minimumDeletions(string s) {\\n        int prefA[s.size()+1];\\n        int prefB[s.size()+1];\\n        memset(prefA, 0, sizeof(prefA));\\n        memset(prefB, 0, sizeof(prefB));\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            prefA[i+1] = prefA[i] + (s[i] == \\'a\\' ? 1 : 0);\\n            prefB[i+1] = prefB[i] + (s[i] == \\'b\\' ? 1 : 0);\\n        }\\n        \\n        int minMoves = INT_MAX;\\n        \\n        for(int i=0; i<=s.size(); i++) {\\n            minMoves = min(minMoves, prefB[i] + (prefA[s.size()] - prefA[i]));\\n        }\\n        \\n        return minMoves;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935410,
                "title": "java-get-number-of-a-from-left-and-b-from-right-o-n-time-and-o-n-space",
                "content": "Maintain number of `a` from left and number of `b` from right. Can be solved in `O(1)` space. Here is `O(N)` space solution\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int[] counts = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            counts[i] = counts[i + 1];\\n            if (s.charAt(i) == \\'a\\') {\\n                counts[i]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        int answer = counts[0];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'b\\') counter++;\\n            answer = Math.min(answer, counter + counts[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int[] counts = new int[n + 1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            counts[i] = counts[i + 1];\\n            if (s.charAt(i) == \\'a\\') {\\n                counts[i]++;\\n            }\\n        }\\n        \\n        int counter = 0;\\n        int answer = counts[0];\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == \\'b\\') counter++;\\n            answer = Math.min(answer, counter + counts[i + 1]);\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819350,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n            int countb=0;\\n    int ans=0;\\n    for(auto i:s)\\n    {\\n        if(i==\\'b\\'){countb++;}\\n        if(i==\\'a\\' && countb>0){ans++;countb--;}\\n    }\\n    \\n    return ans;\\n}\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n            int countb=0;\\n    int ans=0;\\n    for(auto i:s)\\n    {\\n        if(i==\\'b\\'){countb++;}\\n        if(i==\\'a\\' && countb>0){ans++;countb--;}\\n    }\\n    \\n    return ans;\\n}\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848583,
                "title": "easy-c-solution-fully-explained",
                "content": "**THE PROBLEM CAN BE EASILY SOLVED JUST WITH THE HELP OF OBSERVATION**\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE\\n\\n**STRING  S = \"A A A B A A\"**\\n\\nWE CAN EASILY SAY THAT THE ANSWER IS 1, BUT HOW DO WE ACHIEVE THAT\\n\\nSIMPLEE, **WE CONSIDER EVERY POINT AS BALANCING POINT**\\n\\n1) *ON THE LEFT OF BALANCING POINT EVEYTHING SHOULD BE \"A\" ( THERE SHOULD BE NO B ) *\\n2) ON THE RIGHT OF BALANCING POINT EVERYTHING SHOULB BE \"B\"(THERE SHOULD BE NO A)\\n\\nNOW, IT SIMPLY MEANS THAT FOR A BALANCING POINT IF THERE ARE ANY \"B\" ON THE RIGHT HAND SIDE WE HAVE TO DELETE THEM AND IF THERE ARE ANY \"A\" ON THE RIGHT HAND SIDE OF THE BALANCING POINT WE HAVE TO DELETE THEM\\n\\nTOTAL DELETION = NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   \\n\\nLET US CALCULATE FOR EVERY INDEX FOR THE ABOVE EXAMPLE\\n\" A A A B A A\"\\nNO OF B ON THE LEFT OF EVERY INDEX = [0 ,0 ,0 ,0 ,1 , 1];\\nNO OF A ON THE RIGHT OF EVERY INDEX = [4, 3, 2, 2, 1, 0];\\n\\nNOW FOR INDEX WE HAVE TO CALCULATE **THE  NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   **\\n\\nAND AFTER CALCULATING FOR EVERY INDEX WE HAVE TO JUST TAKE THE MINIMUM\\n\\nHERE WE CAN SEE THAT (1+0) IS THE BEST BALANCING POINT WHERE WE HAVE TO DELETE 1 \"B\" AND 0 \"A\"\\n\\nTHE CODE FOR THE ABOVE SOLUTION IS\\n```\\n  int back[100001]={-1};\\n        int front[100001]={-1};\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                back[i] = count;\\n                count++;\\n            }\\n            else\\n            {\\n                back[i]=count;\\n            }\\n            \\n        }\\n        \\n     count =0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                front[i]=count;\\n            }\\n            else\\n            {\\n                front[i]=count;\\n                count++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            \\n            \\n                int x = back[i]+front[i];\\n                //cout<<back[i]<<\" \";\\n                if(x<ans)\\n                {\\n                    ans = x;\\n                }\\n            \\n        }\\n        \\n        if(ans==INT_MAX)\\n        {\\n            return 0;\\n        }\\n        return ans;\\n        \\n        \\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "**THE PROBLEM CAN BE EASILY SOLVED JUST WITH THE HELP OF OBSERVATION**\\n\\nLET US TAKE A VERY SIMPLE EXAMPLE\\n\\n**STRING  S = \"A A A B A A\"**\\n\\nWE CAN EASILY SAY THAT THE ANSWER IS 1, BUT HOW DO WE ACHIEVE THAT\\n\\nSIMPLEE, **WE CONSIDER EVERY POINT AS BALANCING POINT**\\n\\n1) *ON THE LEFT OF BALANCING POINT EVEYTHING SHOULD BE \"A\" ( THERE SHOULD BE NO B ) *\\n2) ON THE RIGHT OF BALANCING POINT EVERYTHING SHOULB BE \"B\"(THERE SHOULD BE NO A)\\n\\nNOW, IT SIMPLY MEANS THAT FOR A BALANCING POINT IF THERE ARE ANY \"B\" ON THE RIGHT HAND SIDE WE HAVE TO DELETE THEM AND IF THERE ARE ANY \"A\" ON THE RIGHT HAND SIDE OF THE BALANCING POINT WE HAVE TO DELETE THEM\\n\\nTOTAL DELETION = NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   \\n\\nLET US CALCULATE FOR EVERY INDEX FOR THE ABOVE EXAMPLE\\n\" A A A B A A\"\\nNO OF B ON THE LEFT OF EVERY INDEX = [0 ,0 ,0 ,0 ,1 , 1];\\nNO OF A ON THE RIGHT OF EVERY INDEX = [4, 3, 2, 2, 1, 0];\\n\\nNOW FOR INDEX WE HAVE TO CALCULATE **THE  NO OF \"B\" ON THE LEFT OF BALANCING POINT + NO OF \"A\" ON THE RIGHT OF BALANCING POINT   **\\n\\nAND AFTER CALCULATING FOR EVERY INDEX WE HAVE TO JUST TAKE THE MINIMUM\\n\\nHERE WE CAN SEE THAT (1+0) IS THE BEST BALANCING POINT WHERE WE HAVE TO DELETE 1 \"B\" AND 0 \"A\"\\n\\nTHE CODE FOR THE ABOVE SOLUTION IS\\n```\\n  int back[100001]={-1};\\n        int front[100001]={-1};\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                back[i] = count;\\n                count++;\\n            }\\n            else\\n            {\\n                back[i]=count;\\n            }\\n            \\n        }\\n        \\n     count =0;\\n        for(int i=s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                front[i]=count;\\n            }\\n            else\\n            {\\n                front[i]=count;\\n                count++;\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            \\n            \\n                int x = back[i]+front[i];\\n                //cout<<back[i]<<\" \";\\n                if(x<ans)\\n                {\\n                    ans = x;\\n                }\\n            \\n        }\\n        \\n        if(ans==INT_MAX)\\n        {\\n            return 0;\\n        }\\n        return ans;\\n        \\n        \\n",
                "codeTag": "C++"
            },
            {
                "id": 1674644,
                "title": "c-solution-o-n-time-complexity-beginner-friendly",
                "content": "``` Easy implementation of stack. Time complexity is O(n) where n is length of string. ```\\n``` Just counted the pair of \"ba\" in the string. ```\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string str) {\\n        stack<char>s;         // Initialised the stack\\n        int c=0;\\n        s.push(str[0]);         // Pushed the first char of the string\\n        for(int i=1;i<str.length();i++)\\n        {\\n            if(s.empty())\\n                s.push(str[i]);\\n            else if(s.top()==\\'b\\' && str[i]==\\'a\\')     \\n            {\\n                c++;               // Increased the count of deletions\\n                s.pop();        // Pop the top of stack\\n            }\\n            else\\n                s.push(str[i]);\\n                \\n        }\\n        return c;\\n    }\\n};\\n```\\n``` If you like my approach then hit the like button to  keep me motivated to post more solutions like this.```",
                "solutionTags": [],
                "code": "``` Easy implementation of stack. Time complexity is O(n) where n is length of string. ```\n``` Just counted the pair of \"ba\" in the string. ```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string str) {\\n        stack<char>s;         // Initialised the stack\\n        int c=0;\\n        s.push(str[0]);         // Pushed the first char of the string\\n        for(int i=1;i<str.length();i++)\\n        {\\n            if(s.empty())\\n                s.push(str[i]);\\n            else if(s.top()==\\'b\\' && str[i]==\\'a\\')     \\n            {\\n                c++;               // Increased the count of deletions\\n                s.pop();        // Pop the top of stack\\n            }\\n            else\\n                s.push(str[i]);\\n                \\n        }\\n        return c;\\n    }\\n};\\n```\n``` If you like my approach then hit the like button to  keep me motivated to post more solutions like this.```",
                "codeTag": "Java"
            },
            {
                "id": 1643636,
                "title": "java-stack-simple-2-solutions-explained",
                "content": "The idea here is to simply push \\'b\\' onto a Stack whenever we encounter it.\\nBut what if we encounter \\'a\\', in this case we check if there is a \\'b\\' present already only then we pop \\'b\\' from the Stack (which signifies a Delete operation).\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        Stack<Character> balance = new Stack();\\n        char c = \\' \\';\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            c = s.charAt(i);\\n            if(!balance.empty() && (balance.peek() == \\'b\\' && c == \\'a\\'))\\n            {\\n                balance.pop();\\n                count++;\\n            }\\n            else if(c == \\'b\\')\\n                balance.push(c);\\n        }\\n        return count;\\n    }\\n}\\n```\\nA similar solution just without Stack \\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n        int prefix = 0;\\n        int total = 0;\\n        for (int i = 0; i < l; i++) \\n        {\\n            if (s.charAt(i) == \\'b\\') \\n                prefix++;\\n            else if(s.charAt(i) == \\'a\\' && prefix > 0)\\n            {\\n                prefix--;\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        Stack<Character> balance = new Stack();\\n        char c = \\' \\';\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            c = s.charAt(i);\\n            if(!balance.empty() && (balance.peek() == \\'b\\' && c == \\'a\\'))\\n            {\\n                balance.pop();\\n                count++;\\n            }\\n            else if(c == \\'b\\')\\n                balance.push(c);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int l = s.length();\\n        int prefix = 0;\\n        int total = 0;\\n        for (int i = 0; i < l; i++) \\n        {\\n            if (s.charAt(i) == \\'b\\') \\n                prefix++;\\n            else if(s.charAt(i) == \\'a\\' && prefix > 0)\\n            {\\n                prefix--;\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045562,
                "title": "best-and-easiest-solution-o-n-82-faster-solution",
                "content": "same as longest increasing subsequence concept\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else\\n                b++;\\n            a=min(a,b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int a=0;\\n        int b=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n                a++;\\n            else\\n                b++;\\n            a=min(a,b);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939185,
                "title": "python-3-one-pass",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \"\"\"\\n        Given a string s, this program determines the minimum\\n        number of deletions in s needed to make s balanced.\\n        \\n        At any point in s, it can be balanced by deleting all\\n        b\\'s to the left and all a\\'s to the right. This program\\n        scans s, determines the number of deletions at each\\n        point, and returns the minimum.\\n\\n        :param s: string containing only a\\'s and b\\'s\\n        :type s: str\\n        :return: minimum number of deletions in s needed to\\n                 make s balanced\\n        :rtype: int\\n        \"\"\"\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        delete_counts = [a_count + b_count]\\n        for char in s:\\n            if char == \\'a\\':\\n                a_count -= 1\\n            else:\\n                b_count += 1\\n            delete_counts.append(a_count + b_count)\\n        return min(delete_counts)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \"\"\"\\n        Given a string s, this program determines the minimum\\n        number of deletions in s needed to make s balanced.\\n        \\n        At any point in s, it can be balanced by deleting all\\n        b\\'s to the left and all a\\'s to the right. This program\\n        scans s, determines the number of deletions at each\\n        point, and returns the minimum.\\n\\n        :param s: string containing only a\\'s and b\\'s\\n        :type s: str\\n        :return: minimum number of deletions in s needed to\\n                 make s balanced\\n        :rtype: int\\n        \"\"\"\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        delete_counts = [a_count + b_count]\\n        for char in s:\\n            if char == \\'a\\':\\n                a_count -= 1\\n            else:\\n                b_count += 1\\n            delete_counts.append(a_count + b_count)\\n        return min(delete_counts)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935460,
                "title": "simplest-solution-greedy-o-n",
                "content": "* Given a desired format (`aaa....aaabbbb....bbbb`), lets call the boundary where the transition happens from `a` to `b` as pivot.\\n* To get the desired format, we want to remove all `b` to the left of the pivot. Similarly, we want to remove all `a` to the right of the pivot.\\n* Instead of actually removing, we will keep the counts of `b` to the left of current index and `a` to the right of current index.\\n\\n```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = s.count(\\'a\\')\\n        b = 0\\n        res = len(s)\\n        for ch in s:\\n            if ch == \\'b\\':\\n                res = min(res, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(res, a+b)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = s.count(\\'a\\')\\n        b = 0\\n        res = len(s)\\n        for ch in s:\\n            if ch == \\'b\\':\\n                res = min(res, a + b)\\n                b += 1\\n            else:\\n                a -= 1\\n        return min(res, a+b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452670,
                "title": "python-stack-beats-95",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count = 0\\n        stack = []        \\n        for c in s:\\n            if c == \\'b\\':\\n                stack.append(c)\\n            elif stack:\\n                stack.pop()\\n                count += 1\\n        return count\\n               \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count = 0\\n        stack = []        \\n        for c in s:\\n            if c == \\'b\\':\\n                stack.append(c)\\n            elif stack:\\n                stack.pop()\\n                count += 1\\n        return count\\n               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000518,
                "title": "java-dp",
                "content": "Store min operation to make length `i` string balanced. To make `i+1` balanced, if `i+1`th character is `b`, keep the same, otherwise either delete all `b`s or delete one more `a` which is one more extra from `i`th result.\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        var len=s.length();\\n        int dp=0,bc=0;\\n        for(int i=0;i<len;i++) {\\n            if(s.charAt(i)==\\'b\\') bc++;\\n            else dp=Math.min(dp+1,bc);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        var len=s.length();\\n        int dp=0,bc=0;\\n        for(int i=0;i<len;i++) {\\n            if(s.charAt(i)==\\'b\\') bc++;\\n            else dp=Math.min(dp+1,bc);\\n        }\\n        return dp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935403,
                "title": "python-o-n",
                "content": "`a_right_count[i]`: the number of a at the right of index i\\n`b_left_count[i]`: the number of b at the left of index i\\n`a_right_count[i] + b_left_count[i]`: the number of deleted characters at index i\\n\\n```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_right_count = [0] * len(s)\\n        b_left_count = [0] * len(s)\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            b_left_count[i] = count\\n            if s[i] == \\'b\\':\\n                count += 1\\n        \\n        count = 0\\n        for i in range(len(s) - 1 ,-1, -1):\\n            a_right_count[i] = count\\n            if s[i] == \\'a\\':\\n                count += 1\\n        \\n        min_delete = len(s)\\n        for i in range(len(s)):\\n            min_delete = min(min_delete, a_right_count[i] + b_left_count[i])\\n        return min_delete\\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_right_count = [0] * len(s)\\n        b_left_count = [0] * len(s)\\n        \\n        count = 0\\n        for i in range(len(s)):\\n            b_left_count[i] = count\\n            if s[i] == \\'b\\':\\n                count += 1\\n        \\n        count = 0\\n        for i in range(len(s) - 1 ,-1, -1):\\n            a_right_count[i] = count\\n            if s[i] == \\'a\\':\\n                count += 1\\n        \\n        min_delete = len(s)\\n        for i in range(len(s)):\\n            min_delete = min(min_delete, a_right_count[i] + b_left_count[i])\\n        return min_delete\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041057,
                "title": "prefix-suffix-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), cnt = 0, ans = 1e9;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), cnt = 0, ans = 1e9;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309277,
                "title": "dp-with-o-1-space",
                "content": "```\\n   int minimumDeletions(string s) \\n   {\\n        int i;\\n        int best = 0;\\n        int count = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n                best = min(best+1, count); // if we have seen \\'a\\' then best will be minimun of converting all \\'b\\' till now or whatever was the best till now + 1 for this new \\'a\\' conversion.\\n            if(s[i] == \\'b\\')\\n                count++;  // count the number of \\'b\\'\\n        }\\n        return best;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```\\n   int minimumDeletions(string s) \\n   {\\n        int i;\\n        int best = 0;\\n        int count = 0;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(s[i] == \\'a\\')\\n                best = min(best+1, count); // if we have seen \\'a\\' then best will be minimun of converting all \\'b\\' till now or whatever was the best till now + 1 for this new \\'a\\' conversion.\\n            if(s[i] == \\'b\\')\\n                count++;  // count the number of \\'b\\'\\n        }\\n        return best;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2186582,
                "title": "c-prefix-suffix",
                "content": "* We want to make a sequence of characters such that all `a\\'s` are on left and all `b\\'s` are on right.\\n\\n * At each index of `s` , Keep all `a\\'s` from left till `i` and keep all `b\\'s`  from right till `i`. **Delete all remaining**. **Find minimum out of those**\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>pref , suff ;\\n        int a = 0 ;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            a += s[i] == \\'a\\' ;\\n            pref.push_back(a) ;\\n        }\\n        int b = 0 ;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i ){\\n            b += s[i] == \\'b\\' ;\\n            suff.push_back(b) ;\\n        }\\n        reverse(begin(suff),end(suff)) ; \\n        \\n        int dels = s.size() ;\\n        for(int i = 0 ; i < s.size() ; ++i ) dels = min(dels,(int)s.size() - pref[i] - suff[i]) ;\\n        return dels ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>pref , suff ;\\n        int a = 0 ;\\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            a += s[i] == \\'a\\' ;\\n            pref.push_back(a) ;\\n        }\\n        int b = 0 ;\\n        for(int i = s.size() - 1 ; i >= 0 ; --i ){\\n            b += s[i] == \\'b\\' ;\\n            suff.push_back(b) ;\\n        }\\n        reverse(begin(suff),end(suff)) ; \\n        \\n        int dels = s.size() ;\\n        for(int i = 0 ; i < s.size() ; ++i ) dels = min(dels,(int)s.size() - pref[i] - suff[i]) ;\\n        return dels ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075592,
                "title": "java-o-n-solution",
                "content": "```\\npublic int minimumDeletions(String s) {\\n\\n        int bCnt = 0;\\n        int ans =0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch ==\\'b\\')bCnt++;\\n            if(bCnt>0 && ch==\\'a\\'){\\n                bCnt--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minimumDeletions(String s) {\\n\\n        int bCnt = 0;\\n        int ans =0;\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            if(ch ==\\'b\\')bCnt++;\\n            if(bCnt>0 && ch==\\'a\\'){\\n                bCnt--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1941430,
                "title": "easy-javascript-bidirectional-dp",
                "content": "This uses the same solution from https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/solution/\\nwhere you count the number of \\'b\\' you need to delete going from the left, and count the number of \\'a\\' you need to delete going from the right.\\nOnce you have a count, you find the min_deletion = left_dpA[i] + right_dpB[i]. Note, the bidirectional left shift and right shift is removed, by incrementing the counter after, which yields an non-inclusive character count. The character at i, can be either \\'a\\' or \\'b\\' and it wouldn\\'t effect the minimum delete because that intersection point will belong to left or right.\\n```\\nvar minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minimumDeletions = function(s) {\\n    const dpA = [];\\n    let counter = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        dpA[i] = counter;\\n        if (s[i] === \\'b\\') {\\n            counter++;\\n        }\\n    }\\n    \\n    counter = 0;\\n    const dpB = [];\\n    for (let i = s.length - 1; i >= 0; i--) {\\n        dpB[i] = counter;\\n        if (s[i] === \\'a\\') {\\n            counter++;\\n        }\\n    }\\n\\n    let minDelete = s.length;\\n    for (let i = 0; i < s.length; i++) {\\n        minDelete = Math.min(minDelete, dpA[i] + dpB[i]);\\n    }\\n    \\n    return minDelete;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700646,
                "title": "java-o-1-space-o-n-complexity",
                "content": "assume we have got answer for string s, then lets suppose a new character comes and get added\\nwe then have below situations for that new character:\\n1. if it is a \\'b\\' then nothing needed, because \\'b\\' at the end will still be balanced\\n2. if it is a \\'a\\' then number of deletion have to be increased from previous no_of_deletions\\nso new no_of_deletions = no_of_deletions + 1.\\nNow we have 2 counters, no_of_b & no_of_deletions. We will take whichever is lesser of the two.\\n```\\n        int b = 0, no_of_deletions = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'b\\') b++;\\n            else no_of_deletions++;\\n            no_of_deletions = Math.min(no_of_deletions, b);\\n        }\\n        return no_of_deletions;\\n```",
                "solutionTags": [],
                "code": "```\\n        int b = 0, no_of_deletions = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i) == \\'b\\') b++;\\n            else no_of_deletions++;\\n            no_of_deletions = Math.min(no_of_deletions, b);\\n        }\\n        return no_of_deletions;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1093898,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        ans = suffix = 0\\n        for c in reversed(s):\\n            if c == \"a\": suffix += 1\\n            else: ans = min(1 + ans, suffix)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        ans = suffix = 0\\n        for c in reversed(s):\\n            if c == \"a\": suffix += 1\\n            else: ans = min(1 + ans, suffix)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965905,
                "title": "c-100-o-n-time-o-1-space-dp-solution-with-explanation",
                "content": "This is classic DP problem. \\n```\\nLet nda[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'a\\'\\nLet ndb[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'b\\'\\n```\\n\\nNow loop over each char of str\\n```\\n\\tcase \\'a\\'\\n\\t\\tnda[i] = nda[i-1]   //No deletions required \\n\\t\\tndb[i] = ndb[i-1] + 1  // 1 deletion required\\n\\t\\tbreak;\\n\\tcase \\'b\\'\\n\\t\\tndb[i] = min(nda[i-1], ndb[i-1]) // previous sub-string doesnt matter, it can be \\'aa\\' or \\'bb\\' or \\'ab\\'\\n\\t\\tnda[i] = nda[i-1] + 1 // 1 deletion required\\n```\\nNow simply return Min of nda[last], ndb[last]\\nDry Run:\\n____aababbab\\nnda 00112334\\nndb 11011122\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>nda(s.size()+1,0);\\n        vector<int>ndb(s.size()+1,0);\\n        int i=1;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                ndb[i] = ndb[i-1] + 1;\\n                nda[i] = nda[i-1] + 0;\\n            }\\n            else{\\n                ndb[i] = min(ndb[i-1],nda[i-1]);\\n                nda[i] = nda[i-1] + 1;\\n            }\\n            i++;\\n        }\\n        return min(ndb[s.size()],nda[s.size()]);\\n    }\\n};\\n/*\\n____aababbab\\nnda 00112334\\nndb 11011122\\n*/\\n```\\nWe can Optimise into O(1) Space since we need only 2 variables\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int a = 0;\\n        int b = 0;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return min(a,b);\\n    }\\n};\\n/*\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nLet nda[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'a\\'\\nLet ndb[i] denote number of deletions for sub-string[0:i] such that it is ending at \\'b\\'\\n```\n```\\n\\tcase \\'a\\'\\n\\t\\tnda[i] = nda[i-1]   //No deletions required \\n\\t\\tndb[i] = ndb[i-1] + 1  // 1 deletion required\\n\\t\\tbreak;\\n\\tcase \\'b\\'\\n\\t\\tndb[i] = min(nda[i-1], ndb[i-1]) // previous sub-string doesnt matter, it can be \\'aa\\' or \\'bb\\' or \\'ab\\'\\n\\t\\tnda[i] = nda[i-1] + 1 // 1 deletion required\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>nda(s.size()+1,0);\\n        vector<int>ndb(s.size()+1,0);\\n        int i=1;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                ndb[i] = ndb[i-1] + 1;\\n                nda[i] = nda[i-1] + 0;\\n            }\\n            else{\\n                ndb[i] = min(ndb[i-1],nda[i-1]);\\n                nda[i] = nda[i-1] + 1;\\n            }\\n            i++;\\n        }\\n        return min(ndb[s.size()],nda[s.size()]);\\n    }\\n};\\n/*\\n____aababbab\\nnda 00112334\\nndb 11011122\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int a = 0;\\n        int b = 0;\\n        for(char ch:s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return min(a,b);\\n    }\\n};\\n/*\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938408,
                "title": "a-few-solutions",
                "content": "Consider each `i`<sup>th</sup> index as a \"pivot\" position where we can balance `s` via the following 2 operations:\\n\\n1. delete all characters `\\'b\\'`  \\uD83D\\uDC48 to-the-left of `i`\\n2. delete all characters `\\'a\\'`  \\uD83D\\uDC49 to-the-right of `i`\\n\\nLet us denote the results of operation 1 and and operation 2 above as `prefix` and `suffix` correspondingly.  Then we can find the minimum amount of deletions via `prefix[i] + suffix[i] - 1`, ie. add each `i`<sup>th</sup> `prefix` + `i`<sup>th</sup> `suffix` and subtract by `1` (since we only need to delete `\\'a\\'` xor `\\'b\\'`, but *not* both, at each candidate `i`<sup>th</sup> \"pivot\" index).\\n\\n*Example 1:*\\n```\\nInput: s = \"aababbab\"\\nOutput: 2\\n\\n     s = a a b a b b a b\\nprefix = 0 0 1 1 2 3 3 4\\nsuffix = 4 3 2 2 1 1 1 0\\n cands = 3 2 2 2 2 3 3 3  <-- minimum candidate is 2\\n```\\n\\n*Example 2:*\\n```\\nInput: s = \"bbaaaaabb\"\\nOutput: 2\\n\\n     s = b b a a a a a b b\\nprefix = 1 2 2 2 2 2 2 3 4\\nsuffix = 5 5 5 4 3 2 1 0 0\\n cands = 5 6 6 5 4 3 2 2 3  <-- minimum candidate is 2\\n ```\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumDeletions(s: String): Int {\\n        var N = s.length\\n        var prefix = IntArray(N) { 0 }\\n        var suffix = IntArray(N) { 0 }\\n        var beg = 0\\n        var end = N - 1\\n        for (i in beg..end)     prefix[i] = (if (s[i] == \\'b\\') 1 else 0) + (if (beg < i) prefix[i - 1] else 0)\\n        for (i in end downTo 0) suffix[i] = (if (s[i] == \\'a\\') 1 else 0) + (if (i < end) suffix[i + 1] else 0)\\n        return prefix.zip(suffix){ a, b -> a + b }.min()!!.minus(1)  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumDeletions = s => {\\n    let N = s.length;\\n    let A = s.split(\\'\\');\\n    let prefix = Array(N).fill(0),\\n        suffix = Array(N).fill(0);\\n    let beg = 0,\\n        end = N - 1;\\n    for (let i = beg; i <= end; ++i) prefix[i] = Number(A[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n    for (let i = end; beg <= i; --i) suffix[i] = Number(A[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n    return Math.min(..._.zip(prefix, suffix).map(([a, b]) => a + b)) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        N = len(s)\\n        prefix = [0] * N\\n        suffix = [0] * N\\n        for i in range(N):             prefix[i] = int(s[i] == \\'b\\') + (prefix[i - 1] if 0 < i     else 0)\\n        for i in range(N - 1, -1, -1): suffix[i] = int(s[i] == \\'a\\') + (suffix[i + 1] if i < N - 1 else 0)\\n        return min(a + b for a, b in zip(prefix, suffix)) - 1  # \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_deletions(s: String) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut prefix = vec![0; N];\\n        let mut suffix = vec![0; N];\\n        let (beg, end) = (0, N - 1);\\n        for i in 0..N {\\n            prefix[i] = if s[i] == \\'b\\' { 1 } else { 0 } + if beg < i { prefix[i - 1] } else { 0 };\\n        }\\n        for j in (0..N).rev() {\\n            suffix[j] = if s[j] == \\'a\\' { 1 } else { 0 } + if j < end { suffix[j + 1] } else { 0 };\\n        }\\n        prefix.iter().zip(suffix).map(|(a, b)| a + b).min().unwrap() - 1 // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumDeletions(string s) {\\n        int N = s.size();\\n        VI prefix(N),\\n           suffix(N),\\n           cands(N);\\n        int beg = 0,\\n            end = N - 1;\\n        for (auto i{ beg }; i <= end; ++i) prefix[i] = int(s[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n        for (auto i{ end }; beg <= i; --i) suffix[i] = int(s[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n        for (auto i{ 0 }; i < N; ++i)\\n            cands[i] = prefix[i] + suffix[i];\\n        return *min_element(cands.begin(), cands.end()) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nInput: s = \"aababbab\"\\nOutput: 2\\n\\n     s = a a b a b b a b\\nprefix = 0 0 1 1 2 3 3 4\\nsuffix = 4 3 2 2 1 1 1 0\\n cands = 3 2 2 2 2 3 3 3  <-- minimum candidate is 2\\n```\n```\\nInput: s = \"bbaaaaabb\"\\nOutput: 2\\n\\n     s = b b a a a a a b b\\nprefix = 1 2 2 2 2 2 2 3 4\\nsuffix = 5 5 5 4 3 2 1 0 0\\n cands = 5 6 6 5 4 3 2 2 3  <-- minimum candidate is 2\\n ```\n```\\nclass Solution {\\n    fun minimumDeletions(s: String): Int {\\n        var N = s.length\\n        var prefix = IntArray(N) { 0 }\\n        var suffix = IntArray(N) { 0 }\\n        var beg = 0\\n        var end = N - 1\\n        for (i in beg..end)     prefix[i] = (if (s[i] == \\'b\\') 1 else 0) + (if (beg < i) prefix[i - 1] else 0)\\n        for (i in end downTo 0) suffix[i] = (if (s[i] == \\'a\\') 1 else 0) + (if (i < end) suffix[i + 1] else 0)\\n        return prefix.zip(suffix){ a, b -> a + b }.min()!!.minus(1)  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\n```\\nlet minimumDeletions = s => {\\n    let N = s.length;\\n    let A = s.split(\\'\\');\\n    let prefix = Array(N).fill(0),\\n        suffix = Array(N).fill(0);\\n    let beg = 0,\\n        end = N - 1;\\n    for (let i = beg; i <= end; ++i) prefix[i] = Number(A[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n    for (let i = end; beg <= i; --i) suffix[i] = Number(A[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n    return Math.min(..._.zip(prefix, suffix).map(([a, b]) => a + b)) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n};\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        N = len(s)\\n        prefix = [0] * N\\n        suffix = [0] * N\\n        for i in range(N):             prefix[i] = int(s[i] == \\'b\\') + (prefix[i - 1] if 0 < i     else 0)\\n        for i in range(N - 1, -1, -1): suffix[i] = int(s[i] == \\'a\\') + (suffix[i + 1] if i < N - 1 else 0)\\n        return min(a + b for a, b in zip(prefix, suffix)) - 1  # \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn minimum_deletions(s: String) -> i32 {\\n        let s: Vec<char> = s.chars().collect();\\n        let N = s.len();\\n        let mut prefix = vec![0; N];\\n        let mut suffix = vec![0; N];\\n        let (beg, end) = (0, N - 1);\\n        for i in 0..N {\\n            prefix[i] = if s[i] == \\'b\\' { 1 } else { 0 } + if beg < i { prefix[i - 1] } else { 0 };\\n        }\\n        for j in (0..N).rev() {\\n            suffix[j] = if s[j] == \\'a\\' { 1 } else { 0 } + if j < end { suffix[j + 1] } else { 0 };\\n        }\\n        prefix.iter().zip(suffix).map(|(a, b)| a + b).min().unwrap() - 1 // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" index\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minimumDeletions(string s) {\\n        int N = s.size();\\n        VI prefix(N),\\n           suffix(N),\\n           cands(N);\\n        int beg = 0,\\n            end = N - 1;\\n        for (auto i{ beg }; i <= end; ++i) prefix[i] = int(s[i] == \\'b\\') + (beg < i ? prefix[i - 1] : 0);\\n        for (auto i{ end }; beg <= i; --i) suffix[i] = int(s[i] == \\'a\\') + (i < end ? suffix[i + 1] : 0);\\n        for (auto i{ 0 }; i < N; ++i)\\n            cands[i] = prefix[i] + suffix[i];\\n        return *min_element(cands.begin(), cands.end()) - 1;  // \\u2B50\\uFE0F -1 since we only need to delete \\'a\\' xor \\'b\\' at the optimal \"pivot\" \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936514,
                "title": "javascript-time-o-n-space-o-1-100-both",
                "content": "I contrast to counting number of characters to delete, I count characters that I can keep in a balanced string that is subsequence of the whole string and calculate number of chars to delete by extracting it from the total string length. `lena` and `lenb` are lengths of the longest subsequences ending with `a` or `b` respectively. \\n- `a` can be appended only to subsequence ending with `a`, so the length of new subsequence ending with newly added `a` is `lena + 1`.\\n- `b` can be appended both to subsequence ending with `a` or `b` so the length of new subsequence will be `max(lena, lenb) + 1`.\\n```javascript\\nvar minimumDeletions = function (s) {\\n  let lena = 0;\\n  let lenb = 0;\\n  for (let ch of s) {\\n    if (\\'a\\' == ch) {\\n      ++lena;\\n    } else {\\n      lenb = Math.max(lena, lenb) + 1;\\n    }\\n  }\\n\\n  return s.length - Math.max(lena, lenb);\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar minimumDeletions = function (s) {\\n  let lena = 0;\\n  let lenb = 0;\\n  for (let ch of s) {\\n    if (\\'a\\' == ch) {\\n      ++lena;\\n    } else {\\n      lenb = Math.max(lena, lenb) + 1;\\n    }\\n  }\\n\\n  return s.length - Math.max(lena, lenb);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935437,
                "title": "time-o-n-space-o-1-without-stack",
                "content": "We count number of \\'a\\' and \\'b\\'.\\nAnd during traversing we make a decision:\\n1. either we remove \\'b\\'.\\n2. or we remove all upcoming \\'a\\'.\\n\\n```\\npublic int minimumDeletions(String s) {\\n    int a = 0, b = 0;\\n    for(char c : s.toCharArray()) {\\n        if (c == \\'a\\') a++;\\n        else b++;\\n    }\\n    int cA = 0, cB = 0, min = 0, delAll = a;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (a - cA == 0) break;\\n        if (c == \\'a\\') {\\n            cA++;\\n        } else {\\n            cB++;\\n            delAll = Math.min(a - cA + min, delAll);\\n            min++;\\n        }\\n    }\\n    return Math.min(delAll, min);;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minimumDeletions(String s) {\\n    int a = 0, b = 0;\\n    for(char c : s.toCharArray()) {\\n        if (c == \\'a\\') a++;\\n        else b++;\\n    }\\n    int cA = 0, cB = 0, min = 0, delAll = a;\\n    for(int i = 0; i < s.length(); i++) {\\n        char c = s.charAt(i);\\n        if (a - cA == 0) break;\\n        if (c == \\'a\\') {\\n            cA++;\\n        } else {\\n            cB++;\\n            delAll = Math.min(a - cA + min, delAll);\\n            min++;\\n        }\\n    }\\n    return Math.min(delAll, min);;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935387,
                "title": "python-short-and-simple-5-lines-o-n",
                "content": "If we are standing at some position, to make the string balanced by converting the left side to all *a*\\'s and the right side to all *b*\\'s, we need the number of deletions to equal the number of *b*\\'s on the left plus the number of *a*\\'s on the right.\\n\\nLet\\'s start with imaginary position right before the first (index 0) character. The number of needed deletions is the number of *a*\\'s on the right. To move to the next position in the string (between position 0 and 1, then between position 1 and 2, etc.), we need to subtract 1 from the calculated deletions if the current character is *a* (becase if moves from the right part to the left; thus, the number of needed deletions on the right decreases) and add 1 if the current character is b (becase if moves to the left part from the current position; i.e., the number of needed deletions on the left increases). \\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        min_del=del_chars=s.count(\"a\")\\n        for char in s+\"b\":\\n            min_del=min(min_del, del_chars)\\n            del_chars=del_chars+1 if char==\"b\" else del_chars-1\\n        return min_del\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        min_del=del_chars=s.count(\"a\")\\n        for char in s+\"b\":\\n            min_del=min(min_del, del_chars)\\n            del_chars=del_chars+1 if char==\"b\" else del_chars-1\\n        return min_del\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824481,
                "title": "c-very-easy-stack-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            if(c == \\'a\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                    count++;\\n                }\\n            }\\n            else{\\n               st.push(c);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            char c = s[i];\\n            if(c == \\'a\\'){\\n                if(!st.empty()){\\n                    st.pop();\\n                    count++;\\n                }\\n            }\\n            else{\\n               st.push(c);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267946,
                "title": "lis-dp-o-n",
                "content": "# Approach\\nThe longest nonstrictly increasing subsequence is computed and then this is subtracted from the length of the input string.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n\\n$n$ is the length of the input string.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int lis(vector<int> & nums, int i, int p, vector<vector<int>> & dp) {\\n\\n        int n = nums.size();\\n\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int res = 0;\\n\\n        if(nums[i] >= p)\\n            res = max(res, 1 + lis(nums, i + 1, nums[i], dp));\\n            \\n        res = max(res, lis(nums, i + 1, p, dp));\\n\\n        dp[i][p] = res;\\n\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int> & nums) {\\n        \\n        int n = nums.size();\\n\\n        int uniqueNums = 2;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(uniqueNums, -1));\\n\\n        return lis(nums, 0, 0, dp);\\n    }\\n\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(auto c : s) {\\n            if(c == \\'a\\')\\n                nums.push_back(0);\\n            else \\n                nums.push_back(1);\\n        }\\n\\n        return s.length() - lengthOfLIS(nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    int lis(vector<int> & nums, int i, int p, vector<vector<int>> & dp) {\\n\\n        int n = nums.size();\\n\\n        if(i >= n)\\n            return 0;\\n\\n        if(dp[i][p] != -1)\\n            return dp[i][p];\\n\\n        int res = 0;\\n\\n        if(nums[i] >= p)\\n            res = max(res, 1 + lis(nums, i + 1, nums[i], dp));\\n            \\n        res = max(res, lis(nums, i + 1, p, dp));\\n\\n        dp[i][p] = res;\\n\\n        return res;\\n    }\\n\\n    int lengthOfLIS(vector<int> & nums) {\\n        \\n        int n = nums.size();\\n\\n        int uniqueNums = 2;\\n\\n        vector<vector<int>> dp(n + 1, vector<int>(uniqueNums, -1));\\n\\n        return lis(nums, 0, 0, dp);\\n    }\\n\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(auto c : s) {\\n            if(c == \\'a\\')\\n                nums.push_back(0);\\n            else \\n                nums.push_back(1);\\n        }\\n\\n        return s.length() - lengthOfLIS(nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198090,
                "title": "very-easy-approach-can-be-used-for-many-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach PREFIX AND SUFFIX SUM\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.length(), cnt = 0;\\n        int ans = INT_MAX;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.length(), cnt = 0;\\n        int ans = INT_MAX;\\n        vector<int> cnta(n), cntb(n);\\n\\n        for(int i=0; i<n; i++) {\\n            cntb[i] = cnt;\\n            if(s[i] == \\'b\\') cnt++;\\n        }\\n        cnt = 0;\\n        for(int i=n-1; i>=0; i--) {\\n            cnta[i] = cnt;\\n            if(s[i] == \\'a\\') cnt++;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, cnta[i] + cntb[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971585,
                "title": "time-o-n-space-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[ Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/solutions/2912351/flip-string-to-monotone-increasing//)\\n\\nExactly Same\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        rightDel = s.count(\\'a\\')\\n        leftDel = 0\\n        ans = rightDel\\n        for i in range(len(s)):\\n            if s[i] == \\'b\\':\\n                leftDel += 1\\n            else:\\n                rightDel -= 1\\n                ans = min(ans,leftDel+rightDel)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        rightDel = s.count(\\'a\\')\\n        leftDel = 0\\n        ans = rightDel\\n        for i in range(len(s)):\\n            if s[i] == \\'b\\':\\n                leftDel += 1\\n            else:\\n                rightDel -= 1\\n                ans = min(ans,leftDel+rightDel)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918899,
                "title": "python3-solution-clean-concise-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```Python\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        ans, count = 0, 0\\n        for i in s:\\n            if i == \\'b\\':\\n                count += 1\\n            elif count:\\n                ans += 1\\n                count -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        ans, count = 0, 0\\n        for i in s:\\n            if i == \\'b\\':\\n                count += 1\\n            elif count:\\n                ans += 1\\n                count -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362604,
                "title": "python3-one-pass-o-1-mem-simple-and-intuitive",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n\\n        a_len = 0\\n        ab_len = 0\\n\\n        for c in s:\\n            if c == \"a\":\\n                a_len += 1\\n            else:\\n                ab_len = max(ab_len+1, a_len+1)\\n\\n        return n - max(a_len, ab_len)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n\\n        a_len = 0\\n        ab_len = 0\\n\\n        for c in s:\\n            if c == \"a\":\\n                a_len += 1\\n            else:\\n                ab_len = max(ab_len+1, a_len+1)\\n\\n        return n - max(a_len, ab_len)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340836,
                "title": "my-java-code-o-n-time-o-1-space",
                "content": "This question is similar to->  [https://leetcode.com/problems/flip-string-to-monotone-increasing/]\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int i = 0;\\n        for(i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'b\\')\\n                break;\\n        }\\n        int countflips = 0;\\n        int countb = 0;\\n        for(i=i; i < s.length(); i++){\\n            if(s.charAt(i)==\\'a\\') countflips++;\\n            \\n            else countb++;\\n            \\n            countflips = Math.min(countflips, countb);\\n        }    \\n        return countflips;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int i = 0;\\n        for(i = 0; i < s.length(); i++){\\n            if(s.charAt(i)==\\'b\\')\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2288528,
                "title": "this-should-be-classified-as-easy-problem-simple-java-solution",
                "content": "This is a very simple question.\\n\\tThe idea is straightforward, we need to keep a count of all the `\\'b\\'` that we have encountered. If we encounter an `\\'a\\'`, we need to decrement the count of `b`, since we have found more `b`s before `a`s. And doing that, we need to increment `deleteCt` since we have more `b` and we need to remove that.\\n\\n\\n```\\n    public int minimumDeletions(String s) {\\n        int bCt = 0, deleteCt = 0;\\n        for(char ch: s.toCharArray()){\\n            if(ch == \\'b\\')\\n                bCt = bCt <= 0 ? 1 : bCt + 1;\\n            else {\\n                if(bCt > 0){\\n                    deleteCt++;\\n                    bCt--;\\n                }\\n            }\\n        }\\n        return deleteCt;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int minimumDeletions(String s) {\\n        int bCt = 0, deleteCt = 0;\\n        for(char ch: s.toCharArray()){\\n            if(ch == \\'b\\')\\n                bCt = bCt <= 0 ? 1 : bCt + 1;\\n            else {\\n                if(bCt > 0){\\n                    deleteCt++;\\n                    bCt--;\\n                }\\n            }\\n        }\\n        return deleteCt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228525,
                "title": "faster-than-83-clean-dp-solution-with-explanation",
                "content": "The idea is pretty simple here, we will iterate from index 0 to n-1 and calculate the current max length of balanced string from starting (0) to the current index i ( with the element i being present in it ).\\nNow for example  a a b a b a .\\nIn the above string dp[0]  = 1 ( the max length of balanced string is 1 including the index 0)\\nsimilary for dp[1] = 2 ( a a ).\\nSo we will keep a count of \\'a\\' , and anytime we will encounter a new \\'a\\' the current max length of balanced string would be  count_a + 1. ( The reasoning behind this is that if you want to end your balanced string with an \\'a\\' then you cant include the \\'b\\' in it ).\\nfor example in    a a b a b a \\nthe maximum length of balanced string that you can from ending at index 5 is 4 ( a a a a ) excluding the 2 \\'b\\'s .\\nNow what if we encounter a \\'b\\' , what would be the maximum length of balanced string ending at that index.\\nWell that would be max( previous_b_length , count_a) +1 , because there can be a \\'b\\' or an \\'a\\' before the next b and we would like to take the maximum of the the case.\\n\\nCode:\\n```\\n  int minimumDeletions(string s) {\\n        \\n        int n= s.size(),prevb=0;\\n        int dp[n],maxi=-1;\\n        int i,j,la=0,lb=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                la++;\\n                dp[i] = la;\\n                maxi = max(maxi,dp[i]);\\n            }\\n            if(s[i]==\\'b\\')\\n            {\\n                dp[i] =  max(la,prevb) + 1;\\n                maxi = max(maxi,dp[i]);\\n                prevb = dp[i];\\n            }\\n        }\\n        return n-maxi;\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The idea is pretty simple here, we will iterate from index 0 to n-1 and calculate the current max length of balanced string from starting (0) to the current index i ( with the element i being present in it ).\\nNow for example  a a b a b a .\\nIn the above string dp[0]  = 1 ( the max length of balanced string is 1 including the index 0)\\nsimilary for dp[1] = 2 ( a a ).\\nSo we will keep a count of \\'a\\' , and anytime we will encounter a new \\'a\\' the current max length of balanced string would be  count_a + 1. ( The reasoning behind this is that if you want to end your balanced string with an \\'a\\' then you cant include the \\'b\\' in it ).\\nfor example in    a a b a b a \\nthe maximum length of balanced string that you can from ending at index 5 is 4 ( a a a a ) excluding the 2 \\'b\\'s .\\nNow what if we encounter a \\'b\\' , what would be the maximum length of balanced string ending at that index.\\nWell that would be max( previous_b_length , count_a) +1 , because there can be a \\'b\\' or an \\'a\\' before the next b and we would like to take the maximum of the the case.\\n\\nCode:\\n```\\n  int minimumDeletions(string s) {\\n        \\n        int n= s.size(),prevb=0;\\n        int dp[n],maxi=-1;\\n        int i,j,la=0,lb=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                la++;\\n                dp[i] = la;\\n                maxi = max(maxi,dp[i]);\\n            }\\n            if(s[i]==\\'b\\')\\n            {\\n                dp[i] =  max(la,prevb) + 1;\\n                maxi = max(maxi,dp[i]);\\n                prevb = dp[i];\\n            }\\n        }\\n        return n-maxi;\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1977265,
                "title": "easy-o-n-time-o-1-space",
                "content": "Basic idea is pretty simple you have to convert string to aaaaa..(n times)bbbb...(m times) so for this, you can select after what index there should be no a\\'s present in the string and before that index there should be no b\\'s. You have to find the index which will give minimum sum of count of: b\\'s from start to index and a\\'s from index to end. Your answer is the sum. \\nSteps:\\n1) Calculate the countA.\\n2) Start iterating by keeping count of a and b, and ans = min(ans,countA-a+b).\\n3) Initially your ans will be countA (no a is considered initially).\\n![image](https://assets.leetcode.com/users/images/6b49cfb3-dbb9-4d2b-83d5-f90030230b8d_1650776896.3743162.png)\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int countA = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                countA++;\\n            }\\n        }\\n        int ans = countA;\\n        int tempA = 0;\\n        int tempB = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                tempA++;\\n            }\\n            else{\\n                tempB++;\\n            }\\n            ans = min(ans,(countA-tempA+tempB));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int countA = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                countA++;\\n            }\\n        }\\n        int ans = countA;\\n        int tempA = 0;\\n        int tempB = 0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\'){\\n                tempA++;\\n            }\\n            else{\\n                tempB++;\\n            }\\n            ans = min(ans,(countA-tempA+tempB));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775152,
                "title": "java-flip-string-to-monotone-increasing-o-n-time-o-1-space-one-pass",
                "content": "This question is exactly similar to the question Flip String to Monotone Increasing :\\nhttps://leetcode.com/problems/flip-string-to-monotone-increasing/\\n\\nThere we were trying to get minimum number of flips where in this question flip is same as delete.\\n\\n* Flip String to monotone Increasing :\\n\\n \\n        int flips=0;\\n\\t\\tint countOnes=0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\t\\n\\t\\t\\tif (s.charAt(i) == \\'0\\'  &&  countOnes > 0) {\\n\\t\\t\\t\\tflips += 1;\\n\\t\\t\\t\\tcountOnes --;\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(s.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcountOnes += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn flips;    \\n    \\n\\t\\n* \\tMinimum deletions to make a string balanced :\\n\\n        int deletes=0;\\n\\t\\tint countBs=0;  //count number of consecutive b s\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\tif(s.charAt(i) == \\'a\\'  &&  countBs > 0) {\\n\\t\\t\\t\\tdeletes += 1;\\n\\t\\t\\t\\tcountBs --;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\tif(s.charAt(i) == \\'b\\') {\\n\\t\\t\\t\\tcountBs += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn deletes;\\n    \\n\\n\\t",
                "solutionTags": [],
                "code": "This question is exactly similar to the question Flip String to Monotone Increasing :\\nhttps://leetcode.com/problems/flip-string-to-monotone-increasing/\\n\\nThere we were trying to get minimum number of flips where in this question flip is same as delete.\\n\\n* Flip String to monotone Increasing :\\n\\n \\n        int flips=0;\\n\\t\\tint countOnes=0;\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\t\\n\\t\\t\\tif (s.charAt(i) == \\'0\\'  &&  countOnes > 0) {\\n\\t\\t\\t\\tflips += 1;\\n\\t\\t\\t\\tcountOnes --;\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(s.charAt(i) == \\'1\\') {\\n\\t\\t\\t\\tcountOnes += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn flips;    \\n    \\n\\t\\n* \\tMinimum deletions to make a string balanced :\\n\\n        int deletes=0;\\n\\t\\tint countBs=0;  //count number of consecutive b s\\n\\t\\t\\n\\t\\tfor(int i = 0; i < s.length() ;i++) {\\n\\t\\t\\tif(s.charAt(i) == \\'a\\'  &&  countBs > 0) {\\n\\t\\t\\t\\tdeletes += 1;\\n\\t\\t\\t\\tcountBs --;\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\tif(s.charAt(i) == \\'b\\') {\\n\\t\\t\\t\\tcountBs += 1;\\n\\t\\t\\t}\\t\\n\\t\\t}\\n\\t\\treturn deletes;\\n    \\n\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1662781,
                "title": "easy-c-solution-using-stack-start-counting-from-the-end-of-the-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        stack<char>t;\\n        \\n        int i=n-1;\\n        while(i>=0){\\n            \\n            if(t.empty()){\\n                t.push(s[i]);     \\n            }\\n            \\n            else if(t.top()==\\'a\\' && s[i]==\\'b\\'){\\n                c++;\\n                t.pop();         \\n            }\\n            \\n            else t.push(s[i]); \\n            i--;\\n        }    \\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int n=s.size();\\n        int c=0;\\n        stack<char>t;\\n        \\n        int i=n-1;\\n        while(i>=0){\\n            \\n            if(t.empty()){\\n                t.push(s[i]);     \\n            }\\n            \\n            else if(t.top()==\\'a\\' && s[i]==\\'b\\'){\\n                c++;\\n                t.pop();         \\n            }\\n            \\n            else t.push(s[i]); \\n            i--;\\n        }    \\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511951,
                "title": "java-find-divide-point-solution-o-n-time-o-1-memory",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int aCount = 0;\\n        \\n\\t\\t// Count total number of a\\'s\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount++;\\n            }\\n        }\\n\\n        int bCount = 0;\\n        int min = aCount + bCount; // Base case when all numbers needs to be deleted\\n\\t\\t\\n\\t\\t// aCount = number of a\\'s on right, bCount = number of b\\'s at left\\n\\t\\t// at divide index `i`, there will be no a\\'s at index >= `i` and no b\\'s at index < `i`\\n\\t\\t// minimum number to be deleted = number of b\\'s deleted before divide index `i` + number of a\\'s deleted after divide index `i`\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount--; \\n            } else {\\n                bCount++;\\n            }\\n            \\n            min = Integer.min(aCount + bCount, min);\\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int aCount = 0;\\n        \\n\\t\\t// Count total number of a\\'s\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount++;\\n            }\\n        }\\n\\n        int bCount = 0;\\n        int min = aCount + bCount; // Base case when all numbers needs to be deleted\\n\\t\\t\\n\\t\\t// aCount = number of a\\'s on right, bCount = number of b\\'s at left\\n\\t\\t// at divide index `i`, there will be no a\\'s at index >= `i` and no b\\'s at index < `i`\\n\\t\\t// minimum number to be deleted = number of b\\'s deleted before divide index `i` + number of a\\'s deleted after divide index `i`\\n        for(int idx = 0; idx < s.length(); idx++) {\\n            if(s.charAt(idx) == \\'a\\') {\\n                aCount--; \\n            } else {\\n                bCount++;\\n            }\\n            \\n            min = Integer.min(aCount + bCount, min);\\n        }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406992,
                "title": "3-different-python-easy-solution",
                "content": "# Using stack\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack = []\\n        count = 0\\n        \\n        for i in s:\\n            if stack and stack[-1] == \\'b\\' and i == \\'a\\':\\n                stack.pop()\\n                count += 1\\n            \\n            else:\\n                stack.append(i)\\n                \\n        return count\\n```\\n\\n        \\n\\n\\n# Using O(1) space, most optimal\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        ans = len(s) + 1\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                ans = min(ans, a_count + b_count)\\n                \\n            else:\\n                ans = min(ans, a_count + b_count)\\n                b_count += 1\\n                \\n        return ans\\n```\\n        \\n        \\n        \\n        \\n        \\n\\n# Using O(n) space\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = []\\n        b = []\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                a.append(a_count)\\n                b.append(b_count)\\n            \\n            else:\\n                a.append(a_count)\\n                b.append(b_count)\\n                b_count += 1\\n                \\n        ans = len(s) + 1\\n        \\n        for i in range(0,len(s)):\\n            ans = min(ans, a[i] + b[i])            \\n\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        stack = []\\n        count = 0\\n        \\n        for i in s:\\n            if stack and stack[-1] == \\'b\\' and i == \\'a\\':\\n                stack.pop()\\n                count += 1\\n            \\n            else:\\n                stack.append(i)\\n                \\n        return count\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        ans = len(s) + 1\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                ans = min(ans, a_count + b_count)\\n                \\n            else:\\n                ans = min(ans, a_count + b_count)\\n                b_count += 1\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a = []\\n        b = []\\n        a_count = s.count(\\'a\\')\\n        b_count = 0\\n        \\n        for i in s:\\n            if i == \\'a\\':\\n                a_count -= 1\\n                a.append(a_count)\\n                b.append(b_count)\\n            \\n            else:\\n                a.append(a_count)\\n                b.append(b_count)\\n                b_count += 1\\n                \\n        ans = len(s) + 1\\n        \\n        for i in range(0,len(s)):\\n            ans = min(ans, a[i] + b[i])            \\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369807,
                "title": "easy-c-solution-o-n-time-with-explanation",
                "content": "Any time if we see an \\'a\\' we need to make a decision whether we: \\n- delete that \\'a\\'\\n- or delete all the previous \\'b\\'s\\n\\nwe calculate the deletion count for that \\'a\\' depending on which is least expensive - if the number of \\'b\\'s before this \\'a\\' is greater than the deletion count after deleting this \\'a\\' (i.e. +1 to the previous deletion count), then it makes sense NOT to delete all the previous \\'b\\'s because it would prove to be costlier than deleting this \\'a\\'.\\n\\nSimliarly, if the number of \\'b\\'s is lesser than the count of deletion after deleting this \\'a\\', we are better off deleting all the previous \\'b\\'s\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCountSoFar = 0, deleteCount = 0;\\n        for (char ch: s) {\\n//             at any point if we see \\'a\\', we either delete it or delete all previous \\'b\\'s depending on which is less expensive\\n            if (ch == \\'a\\') {\\n//                 if number of \\'b\\'s so far is greater, then delete this \\'a\\'\\n                if(bCountSoFar > deleteCount + 1)\\n                    deleteCount++;\\n//                 or else we delete the previous \\'b\\'s\\n                else deleteCount = bCountSoFar;\\n            }\\n            // keep counting the number of \\'b\\'s\\n            else if (ch == \\'b\\') ++bCountSoFar;\\n        }\\n        return deleteCount;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bCountSoFar = 0, deleteCount = 0;\\n        for (char ch: s) {\\n//             at any point if we see \\'a\\', we either delete it or delete all previous \\'b\\'s depending on which is less expensive\\n            if (ch == \\'a\\') {\\n//                 if number of \\'b\\'s so far is greater, then delete this \\'a\\'\\n                if(bCountSoFar > deleteCount + 1)\\n                    deleteCount++;\\n//                 or else we delete the previous \\'b\\'s\\n                else deleteCount = bCountSoFar;\\n            }\\n            // keep counting the number of \\'b\\'s\\n            else if (ch == \\'b\\') ++bCountSoFar;\\n        }\\n        return deleteCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341776,
                "title": "c-pre-computed-arrays-basic-dp-explanation",
                "content": "Here I have pre-computed the two arrays \\'a\\' and \\'b\\' which hold the elements to be deleted.\\narray \\'a\\' : number of alphabets \\'a\\' to be deleted at index \\'i\\'.\\narray \\'b\\' : number of alphabets \\'b\\' to be deleted at index \\'i\\'.\\n\\n```\\nint minimumDeletions(string s) {\\n        vector<int>a(s.size(), 0), b(s.size(), 0);\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if(s[i] == \\'b\\')\\n                b[i] += i > 0 ? 1 + b[i - 1] : 1;\\n            else\\n                b[i] = (i > 0) ? b[i - 1] : 0;\\n            if(s[s.size() - 1 - i] == \\'a\\')\\n                a[s.size() - 1 - i] += (s.size() - 1 - i < s.size() - 1) ? 1 + a[s.size() - i] : 1;\\n            else\\n                a[s.size() - 1 - i] = (s.size() - 1 - i < s.size() - 1) ? a[s.size() - i] : 0;\\n        }\\n        int ans = min(a[0], b[s.size() - 1]);\\n        for(int i=0; i<s.size() - 1; ++i)\\n            ans = min(ans, b[i] + a[i + 1]);\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Here I have pre-computed the two arrays \\'a\\' and \\'b\\' which hold the elements to be deleted.\\narray \\'a\\' : number of alphabets \\'a\\' to be deleted at index \\'i\\'.\\narray \\'b\\' : number of alphabets \\'b\\' to be deleted at index \\'i\\'.\\n\\n```\\nint minimumDeletions(string s) {\\n        vector<int>a(s.size(), 0), b(s.size(), 0);\\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            if(s[i] == \\'b\\')\\n                b[i] += i > 0 ? 1 + b[i - 1] : 1;\\n            else\\n                b[i] = (i > 0) ? b[i - 1] : 0;\\n            if(s[s.size() - 1 - i] == \\'a\\')\\n                a[s.size() - 1 - i] += (s.size() - 1 - i < s.size() - 1) ? 1 + a[s.size() - i] : 1;\\n            else\\n                a[s.size() - 1 - i] = (s.size() - 1 - i < s.size() - 1) ? a[s.size() - i] : 0;\\n        }\\n        int ans = min(a[0], b[s.size() - 1]);\\n        for(int i=0; i<s.size() - 1; ++i)\\n            ans = min(ans, b[i] + a[i + 1]);\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1272492,
                "title": "c-simple-and-clear-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int x=0, y=0;\\n        vector<int> dp(n+1,0);\\n        if(s[0]==\\'a\\')\\n            x++;\\n        else\\n            y++;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && y!=0)\\n            {\\n                dp[i] = min(dp[i-1]+1, min(y,x+1));\\n            }\\n            else\\n                dp[i] = dp[i-1];\\n            if(s[i]==\\'a\\')\\n                x++;\\n            else\\n                y++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.length();\\n        int x=0, y=0;\\n        vector<int> dp(n+1,0);\\n        if(s[0]==\\'a\\')\\n            x++;\\n        else\\n            y++;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && y!=0)\\n            {\\n                dp[i] = min(dp[i-1]+1, min(y,x+1));\\n            }\\n            else\\n                dp[i] = dp[i-1];\\n            if(s[i]==\\'a\\')\\n                x++;\\n            else\\n                y++;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168221,
                "title": "cpp-dp-change-the-view-of-the-problem",
                "content": "You can change the view of the problem.\\nThe intent of the original problem is to find the minimum.\\nYou can find the maximum subsequence of the original string.\\nThe subsequence is like ->   a\\\\*b\\\\* , and then subtract the length of the subsequence from the original length.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int last_a = -1;\\n        int last_b = -1;\\n    \\n        int len = s.size();\\n        int max_len[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'a\\') {\\n                if (last_a == -1) {\\n                    last_a = i;\\n                    max_len[i] = 1;\\n                } else {\\n                    max_len[i] = max_len[last_a] + 1;\\n                    last_a = i;\\n                }\\n            }\\n            \\n            if (s[i] == \\'b\\') {\\n                if (last_b == -1) {\\n                    last_b = i;\\n                    if (last_a == -1)\\n                        max_len[i] = 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a] + 1,1);\\n                } else {\\n                    if (last_a == -1)\\n                        max_len[i] = max_len[last_b] + 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a], max_len[last_b]) + 1;\\n                    last_b = i;\\n                }\\n            }\\n        }\\n        \\n        int maxmm = -1;\\n        for (int i = 0; i < len; i++)\\n            maxmm = max(maxmm, max_len[i]);\\n        \\n        return len - maxmm;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int last_a = -1;\\n        int last_b = -1;\\n    \\n        int len = s.size();\\n        int max_len[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (s[i] == \\'a\\') {\\n                if (last_a == -1) {\\n                    last_a = i;\\n                    max_len[i] = 1;\\n                } else {\\n                    max_len[i] = max_len[last_a] + 1;\\n                    last_a = i;\\n                }\\n            }\\n            \\n            if (s[i] == \\'b\\') {\\n                if (last_b == -1) {\\n                    last_b = i;\\n                    if (last_a == -1)\\n                        max_len[i] = 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a] + 1,1);\\n                } else {\\n                    if (last_a == -1)\\n                        max_len[i] = max_len[last_b] + 1;\\n                    else\\n                        max_len[i] = max(max_len[last_a], max_len[last_b]) + 1;\\n                    last_b = i;\\n                }\\n            }\\n        }\\n        \\n        int maxmm = -1;\\n        for (int i = 0; i < len; i++)\\n            maxmm = max(maxmm, max_len[i]);\\n        \\n        return len - maxmm;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163332,
                "title": "javascript-3-unique-solutions-stack-dp",
                "content": "Time: `O(N)`\\nSpace: `O(N)`\\n## Solution 1: Stack\\n```javascript\\nvar minimumDeletions = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        if(stack.length && stack[stack.length-1] > s[i]) {\\n            count++;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    return count;\\n};\\n```\\n## Solution 2: DP\\n```javascript\\nvar minimumDeletions = function(s) {\\n    const dp = [0];\\n    let bCount = 0;\\n    \\n    if(s[0] == \\'b\\') bCount++;\\n    \\n    for(let i = 1; i < s.length; i++) {\\n        if(s[i] === \\'a\\') {\\n            dp[i] = Math.min(dp[i-1] + 1, bCount);\\n        } else {\\n            dp[i] = dp[i-1];\\n            bCount++\\n        }\\n    }\\n    return dp[s.length-1];\\n};\\n```\\n## Solution 3\\n```\\nvar minimumDeletions = function(s) {\\n    const aList = [], bList = [];\\n    let countA = 0, countB = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let j = s.length - 1 - i; // going backwards\\n        if(s[i] === \\'b\\') countB++;\\n        if(s[j] === \\'a\\') countA++;\\n        bList[i] = countB;\\n        aList[j] = countA;\\n    }\\n    \\n    function deleteCount(idx, til) {\\n        if(idx >= s.length-1) return 0;\\n        \\n        if(s[idx] === \\'b\\' && s[idx+1] === \\'a\\') {\\n            const deleteA = aList[idx];\\n            const deleteB = deleteCount(idx+2, idx) + bList[idx] - (bList[til] || 0);\\n            return Math.min(deleteA, deleteB);\\n        }\\n        return deleteCount(idx+1, til);\\n    }\\n    return deleteCount(0, -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```javascript\\nvar minimumDeletions = function(s) {\\n    const stack = [];\\n    let count = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        if(stack.length && stack[stack.length-1] > s[i]) {\\n            count++;\\n            stack.pop();\\n        } else {\\n            stack.push(s[i]);\\n        }\\n    }\\n    return count;\\n};\\n```\n```javascript\\nvar minimumDeletions = function(s) {\\n    const dp = [0];\\n    let bCount = 0;\\n    \\n    if(s[0] == \\'b\\') bCount++;\\n    \\n    for(let i = 1; i < s.length; i++) {\\n        if(s[i] === \\'a\\') {\\n            dp[i] = Math.min(dp[i-1] + 1, bCount);\\n        } else {\\n            dp[i] = dp[i-1];\\n            bCount++\\n        }\\n    }\\n    return dp[s.length-1];\\n};\\n```\n```\\nvar minimumDeletions = function(s) {\\n    const aList = [], bList = [];\\n    let countA = 0, countB = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let j = s.length - 1 - i; // going backwards\\n        if(s[i] === \\'b\\') countB++;\\n        if(s[j] === \\'a\\') countA++;\\n        bList[i] = countB;\\n        aList[j] = countA;\\n    }\\n    \\n    function deleteCount(idx, til) {\\n        if(idx >= s.length-1) return 0;\\n        \\n        if(s[idx] === \\'b\\' && s[idx+1] === \\'a\\') {\\n            const deleteA = aList[idx];\\n            const deleteB = deleteCount(idx+2, idx) + bList[idx] - (bList[til] || 0);\\n            return Math.min(deleteA, deleteB);\\n        }\\n        return deleteCount(idx+1, til);\\n    }\\n    return deleteCount(0, -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1133563,
                "title": "c-3-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int lasta = 0, lastb = 0;\\n        for(char i:s){\\n            if(i == \\'a\\') lastb++;\\n            else lastb=min(lasta++,lastb);\\n        }\\n        return min(lasta,lastb);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int lasta = 0, lastb = 0;\\n        for(char i:s){\\n            if(i == \\'a\\') lastb++;\\n            else lastb=min(lasta++,lastb);\\n        }\\n        return min(lasta,lastb);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937912,
                "title": "c-prefix-sum-with-explanation-and-example",
                "content": "A balance string is simply a lexical sorted string (all the `a` appear at left, `b` at right).\\nThe idea is to find the rightmost `a` in the longest balanced string.\\n\\ne.g. `s = \"aababbab\"`\\n\\nif choosing the `a` in index 6 as the last `a`, I will have to delete all the `b` at its left, and all the `a` at its right.\\n```\\n\"aababbab\"\\n       ^\\n\"aaxaxxxb\"\\n```\\nHowever, if I choose the `a` in index 3, I only have to delete `b` in index 2, `a` in index 6.\\n```\\n\"aababbab\"\\n    ^\\n\"aaxabbxb\"\\n```\\nBy observation, I have to use some way to efficiently get the number of `b`s on a given `a`\\'s left, and the number of `a`s on it\\'s right.\\n\\nThe way to achieve that is to use prefix sum:\\n```\\ns        = \"aababbab\"\\nas       = 432211100\\nbs       = 000112334\\n-----------------------\\ndeletion =  32323434\\n```\\nYou can see that the minimum deletion occurs when you choose `a` at index 1 and 3, which yields the answer `2`.\\n\\nNote: for handling cases that does not contain `a`, I add a dummy `a` infront of the original string. (that does not affect the answer since it is already at it\\'s right place)\\n```\\nint minimumDeletions(string s) {\\n    s = \\'a\\' + s;\\n    vector<int> as(s.size()+1);\\n    vector<int> bs(s.size()+1);\\n    int n = s.size();\\n\\n    for (int i = 0; i < s.size(); i++) {\\n      as[n-i-1] = as[n-i] + (s[n-i-1] == \\'a\\');\\n      bs[i+1] = bs[i] + (s[i] == \\'b\\');\\n    }\\n    \\n    int ans = n;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (s[i] == \\'a\\') {\\n        ans = min(ans, as[i+1] + bs[i]);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n\"aababbab\"\\n       ^\\n\"aaxaxxxb\"\\n```\n```\\n\"aababbab\"\\n    ^\\n\"aaxabbxb\"\\n```\n```\\ns        = \"aababbab\"\\nas       = 432211100\\nbs       = 000112334\\n-----------------------\\ndeletion =  32323434\\n```\n```\\nint minimumDeletions(string s) {\\n    s = \\'a\\' + s;\\n    vector<int> as(s.size()+1);\\n    vector<int> bs(s.size()+1);\\n    int n = s.size();\\n\\n    for (int i = 0; i < s.size(); i++) {\\n      as[n-i-1] = as[n-i] + (s[n-i-1] == \\'a\\');\\n      bs[i+1] = bs[i] + (s[i] == \\'b\\');\\n    }\\n    \\n    int ans = n;\\n    for (int i = 0; i < s.size(); i++) {\\n      if (s[i] == \\'a\\') {\\n        ans = min(ans, as[i+1] + bs[i]);\\n      }\\n    }\\n    \\n    return ans;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 935739,
                "title": "python-solution",
                "content": "Initialize `res = [0] * len(s)`, and let `res[i]` be the solution of the problem for `s[:i + 1]`, i.e., `res[i]` is the number of minimum deletions to make `s[:i+1]` balanced. It\\'s easy to see that `res[0] = 0`, because a single character is always balanced. Then we loop `i` over `range(1, len(s))`, we know that if `s[i] == \\'b\\'`, then `res[i] = res[i - 1]`, because a trailing `\\'b\\'` appending to a balanced string will always be balanced. Hence the minimum deletion that makes `s[:i]` balanced will also make `s[:i+1]` balanced; Otherwise if `s[i] == \\'a\\'`, then `res[i] = min(res[i - 1] + 1, count_b)`, where `count_b` is the number of `\\'b\\'`s in `s[:i]`, this is because to make `s[:i+1]` balanced, we have two options -- either delete the last `a`, in which case the minimum deletion to make `s[:i+1]` balanced is `res[i - 1] + 1`, or delete all the `b`s in `s[:i]`, in  which case the minimum deletion to make `s[:i+1]` balanced is `count_b`. The overall minimum is then `res[i] = min(res[i - 1] + 1, count_b)`. Finally, we return `res[-1]` to be the solution of the problem.\\n\\nTime complexity: O(n), space complexity: O(n).\\n\\nSpace complexity can be further reduced to O(1), because we don\\'t really need the array `res`, we only need to save the minimum deletions for the previous iteration.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        count_b = 0\\n        if s[0] == \\'b\\':\\n            count_b = 1\\n        for i in range(1, n):\\n            if s[i] == \\'a\\':\\n                res[i] = min(1 + res[i - 1], count_b)\\n            else:\\n                count_b += 1\\n                res[i] = res[i - 1]\\n        return res[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        res = [0] * n\\n        count_b = 0\\n        if s[0] == \\'b\\':\\n            count_b = 1\\n        for i in range(1, n):\\n            if s[i] == \\'a\\':\\n                res[i] = min(1 + res[i - 1], count_b)\\n            else:\\n                count_b += 1\\n                res[i] = res[i - 1]\\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935455,
                "title": "java-easy-stack-solution",
                "content": "We iterate through the string and greedily adjust to make sure there are no (a)\\'s after any (b)\\'s. If we do, we remove the (b) and add to our min counter.\\n```\\n    public int minimumDeletions(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int min = 0;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (!st.isEmpty() && st.peek() > c) {\\n                st.pop();\\n                min++;\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        \\n        return min;\\n    }",
                "solutionTags": [],
                "code": "We iterate through the string and greedily adjust to make sure there are no (a)\\'s after any (b)\\'s. If we do, we remove the (b) and add to our min counter.\\n```\\n    public int minimumDeletions(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int min = 0;\\n        \\n        for (char c : s.toCharArray()) {\\n            if (!st.isEmpty() && st.peek() > c) {\\n                st.pop();\\n                min++;\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        \\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935406,
                "title": "c-dp-o-n-easy-to-understand",
                "content": "Algorithm:\\n\\t1. Use DP to record the number of a and b.\\n\\t2. Find the suitable index(How to is in Implementation).\\n\\t3. Erase all \"b\"\\'s left to the index.\\n\\t4. Erase all \"a\"\\'s right to the index.\\n\\nImplementation:\\n\\t1.dp_a records frequency of \"a\" from right to left\\n\\t2.dp_b records frequency of \"b\" from left to right\\n\\t3.sum up dp_a and dp_b and find the smallest value substracted by 1\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp_a(s.size(),0);\\n        vector<int>dp_b(s.size(),0);\\n\\t\\t//record b\\n        for(int i = 0 ; i < s.size();++i){\\n            if(i==0&&s[i]==\\'b\\')\\n                dp_b[i]=1;\\n            else if(i==0&&s[i]==\\'a\\')\\n                dp_b[i]=0;\\n            else if(s[i]==\\'b\\')\\n                dp_b[i] = dp_b[i-1]+1;\\n            else\\n                dp_b[i]=dp_b[i-1];\\n        }\\n\\t\\t//record a\\n        for(int i = s.size()-1 ;i>=0;--i){\\n            if(i==s.size()-1&&s[i]==\\'a\\')\\n                dp_a[i]=1;\\n            else if(i==s.size()-1&&s[i]==\\'b\\')\\n                dp_a[i]=0;\\n            else if(s[i]==\\'a\\')\\n                dp_a[i] = dp_a[i+1]+1;\\n            else\\n                dp_a[i] = dp_a[i+1];\\n        }\\n\\t\\t//sum up dp_a and dp_b and find the smallest one\\n        int res=INT_MAX;\\n        for(int i = 0 ; i < s.size() ;++i){\\n            res=min(dp_b[i]+dp_a[i],res);\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp_a(s.size(),0);\\n        vector<int>dp_b(s.size(),0);\\n\\t\\t//record b\\n        for(int i = 0 ; i < s.size();++i){\\n            if(i==0&&s[i]==\\'b\\')\\n                dp_b[i]=1;\\n            else if(i==0&&s[i]==\\'a\\')\\n                dp_b[i]=0;\\n            else if(s[i]==\\'b\\')\\n                dp_b[i] = dp_b[i-1]+1;\\n            else\\n                dp_b[i]=dp_b[i-1];\\n        }\\n\\t\\t//record a\\n        for(int i = s.size()-1 ;i>=0;--i){\\n            if(i==s.size()-1&&s[i]==\\'a\\')\\n                dp_a[i]=1;\\n            else if(i==s.size()-1&&s[i]==\\'b\\')\\n                dp_a[i]=0;\\n            else if(s[i]==\\'a\\')\\n                dp_a[i] = dp_a[i+1]+1;\\n            else\\n                dp_a[i] = dp_a[i+1];\\n        }\\n\\t\\t//sum up dp_a and dp_b and find the smallest one\\n        int res=INT_MAX;\\n        for(int i = 0 ; i < s.size() ;++i){\\n            res=min(dp_b[i]+dp_a[i],res);\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935377,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        l, r = 0, n - 1\\n        c = Counter(s)\\n        res = 0\\n        while l < r:\\n            if s[r] == \\'b\\':\\n                r -= 1\\n                c[\\'b\\'] -= 1\\n                continue\\n            elif s[l] == \\'a\\':\\n                l += 1\\n                c[\\'a\\'] -= 1\\n                continue\\n            else: # b - a\\n                if c[\\'a\\'] <= c[\\'b\\']:\\n                    c[\\'a\\'] -= 1\\n                    res += 1\\n                    r -= 1\\n                else:\\n                    c[\\'b\\'] -= 1\\n                    res += 1\\n                    l += 1\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        n = len(s)\\n        l, r = 0, n - 1\\n        c = Counter(s)\\n        res = 0\\n        while l < r:\\n            if s[r] == \\'b\\':\\n                r -= 1\\n                c[\\'b\\'] -= 1\\n                continue\\n            elif s[l] == \\'a\\':\\n                l += 1\\n                c[\\'a\\'] -= 1\\n                continue\\n            else: # b - a\\n                if c[\\'a\\'] <= c[\\'b\\']:\\n                    c[\\'a\\'] -= 1\\n                    res += 1\\n                    r -= 1\\n                else:\\n                    c[\\'b\\'] -= 1\\n                    res += 1\\n                    l += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 4030220,
                "title": "c-without-dp-lis-prefix-suffix-o-n-tc-o-1-sc",
                "content": "# Intuition\\nAs also mentioned in Hint , we need to find for every index the number of Bs before it and the number of A\\'s after it and the minimum one will be our answer .\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int cnta = 0, cntb = 0, ans = 1e5;\\n        for(auto i : s) cnta += i == \\'a\\';\\n        \\n        // Delete all the a\\'s that could be possible ans \\n        ans = cnta;\\n\\n        for(int i = 0 ; i<s.length() ; i++){\\n            cntb += s[i] == \\'b\\';\\n            cnta -= s[i] == \\'a\\';\\n\\n            ans = min(ans, cntb+cnta);\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int cnta = 0, cntb = 0, ans = 1e5;\\n        for(auto i : s) cnta += i == \\'a\\';\\n        \\n        // Delete all the a\\'s that could be possible ans \\n        ans = cnta;\\n\\n        for(int i = 0 ; i<s.length() ; i++){\\n            cntb += s[i] == \\'b\\';\\n            cnta -= s[i] == \\'a\\';\\n\\n            ans = min(ans, cntb+cnta);\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877461,
                "title": "lis-binary-search-tc-o-nlogn-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlength of LIS using binary search.\\n`Result = size of string - lengthOfLIS`\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(const char& ch : s) {\\n            if(ch == \\'a\\') nums.push_back(0);\\n            else nums.push_back(1);\\n        }\\n\\n        return s.size() - lengthOfLIS(nums);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] >= lis.back())\\n                lis.push_back(nums[i]);\\n            else{\\n                int idx = findCeil(lis, 0, lis.size(), nums[i]);\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int findCeil(vector<int> &lis, int l, int r, int x){\\n        while(l<r){\\n            int m = l + (r-l)/2;\\n            if(lis[m] > x)\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return r;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> nums;\\n\\n        for(const char& ch : s) {\\n            if(ch == \\'a\\') nums.push_back(0);\\n            else nums.push_back(1);\\n        }\\n\\n        return s.size() - lengthOfLIS(nums);\\n    }\\n\\n    int lengthOfLIS(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> lis;\\n        lis.push_back(nums[0]);\\n        \\n        for(int i=1; i<n; i++){\\n            if(nums[i] >= lis.back())\\n                lis.push_back(nums[i]);\\n            else{\\n                int idx = findCeil(lis, 0, lis.size(), nums[i]);\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return lis.size();\\n    }\\n    \\n    int findCeil(vector<int> &lis, int l, int r, int x){\\n        while(l<r){\\n            int m = l + (r-l)/2;\\n            if(lis[m] > x)\\n                r = m;\\n            else\\n                l = m+1;\\n        }\\n        \\n        return r;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824477,
                "title": "very-easy-stack-solution-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ans = 0;\\n\\n        stack<char> st;\\n\\n        for(int i=0;i<s.size();i++){\\n\\n            if(s[i]==\\'a\\'){\\n            if(!st.empty()){\\n                char top = st.top();\\n                if(top==\\'b\\') ans++;\\n                st.pop();\\n                }\\n            }\\n            else{\\n                st.push(\\'b\\');\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ans = 0;\\n\\n        stack<char> st;\\n\\n        for(int i=0;i<s.size();i++){\\n\\n            if(s[i]==\\'a\\'){\\n            if(!st.empty()){\\n                char top = st.top();\\n                if(top==\\'b\\') ans++;\\n                st.pop();\\n                }\\n            }\\n            else{\\n                st.push(\\'b\\');\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760035,
                "title": "simple-python-solution-using-dynamic-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_cnt = s.count(\\'a\\')\\n        result = a_cnt\\n        left_b = 0\\n        right_a = a_cnt\\n\\n        for char in s:\\n            if char == \\'a\\':\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n            result = min(result, right_a + left_b)\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "``` python3 []\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        a_cnt = s.count(\\'a\\')\\n        result = a_cnt\\n        left_b = 0\\n        right_a = a_cnt\\n\\n        for char in s:\\n            if char == \\'a\\':\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n            result = min(result, right_a + left_b)\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203527,
                "title": "python-idea-of-moving-partition-with-detailed-explanation-easy-understanding",
                "content": "# Intuition\\nWe need to find a partition such that if we remove the number of \"b\" to the left of that partition and remove the number of \"a\" on the right of that partition we get a balanced string. Details and example is shown below.\\n\\nWe would then check if the number of deletions with that particular partition and checck if this is a candidate for the minimum number of deletions. \\n\\n# Approach\\nWe can visualize the partition as following:-\\n\\nGiven s = \"aababbab\"\\n\\n`Partition at index 0: \" | aababbab \"` -> To make this balanced remove all b\\'s on left of the partition and remove all a\\'s on the right. So with this partition we would convert the string into \"bbbb\" since we would have to remove all a\\'s to the right(no b\\'s on the left of the partition)\\n\\n`Partition at index 1: \" a | ababbab \"` -> Following the above logic we try to convert it to a balanced string \"abbbb\" and check if the resultant string is a candidate for the answer by comparing to the current answer.\\n\\n`Partition at index 2: \" aa | babbab \"` -> possible balanced string is \"aabbbb\". So total 2 deletions of a\\'s on the right\\n\\n`Partition at index 3: \"aab | abbab\"` -> \"aabbb\"\\n`Partition at index 4: \" aaba | bbab \"` -> \"aaabbb\"\\n`Partition at index 5: \" aabab | bab \"` -> \"aaabb\"\\n`Partition at index 6: \" aababb | ab \"` -> \"aaab\"\\n`Partition at index 7: \" aababba | b \"` -> \"aaaab\"\\n`Partition at index 8: \" aababbab | \"` -> \"aaaa\"\\n\\n**Implementation :-**\\nMaintain variables to keep the count of a\\'s on left and right of partition and the number of b\\'s on the left and right. \\n\\nI have named them as `left_a, left_b, right_a, right_b`. Just add or subtract them as we move the partition. \\n\\nRather than explicitly moving a \"partition\" from LEFT to RIGHT, I am adding the characters into the LEFT-HALF of the partition as the implementation becomes easy that way. \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        C = Counter(s)\\n        left_a, left_b = 0, 0\\n        right_a, right_b = C[\"a\"], C[\"b\"]\\n\\n        deletions = right_a\\n        for char in s:\\n            if char == \"a\":\\n                right_a -= 1\\n                left_a += 1\\n            else:\\n                left_b += 1\\n                right_b -= 1\\n            deletions = min(deletions, left_b + right_a)\\n        \\n        return deletions\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        C = Counter(s)\\n        left_a, left_b = 0, 0\\n        right_a, right_b = C[\"a\"], C[\"b\"]\\n\\n        deletions = right_a\\n        for char in s:\\n            if char == \"a\":\\n                right_a -= 1\\n                left_a += 1\\n            else:\\n                left_b += 1\\n                right_b -= 1\\n            deletions = min(deletions, left_b + right_a)\\n        \\n        return deletions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086296,
                "title": "python-stack-approach",
                "content": "It is given that the string can be balanced, only if there are no pairs like -> \"ba\" in the string. \\n\\nAnd that\\'s the only thing which will make the string invalid. Hence, what we can do is, whenever we come across a situation where the previous character was a \"b\" but the current character is an \"a\", we know we have to make one deletion here. \\n\\nSo, we can simply use a stack to keep track of all the previous \"b\" and whenever we come across an \"a\", we can then check whether we have a \"b\" in the stack. If yes, it means, one deletion has to be made.\\n\\n```\\ndef minimumDeletions(self, s: str) -> int:\\n        # Since we want to ensure that the string is balanced in such as way that\\n        # There is no \"a\" after \"b\" in the final string\\n        # It means, whenever we come across something like \"ba\", we know we have to make one deletion\\n        deletions = 0\\n        \\n        # We will use this stack to put the \"b\" in it whenever we come across one\\n        # In short, this stack is only to keep track of previous \"b\"\\n        stack = []\\n        \\n        # Go through each character of the string\\n        for c in s:\\n            # If this is an \"a\"\\n            if c == \"a\":\\n                # Then, if the stack is not empty\\n                # It means, there was a \"b\" before it\\n                # So we need to make a deletion here\\n                if stack:\\n                    stack.pop()\\n                    deletions += 1\\n            # If it is a \"b\", just push it to the stack\\n            else: stack.append(c)\\n                \\n        return deletion\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n        # Since we want to ensure that the string is balanced in such as way that\\n        # There is no \"a\" after \"b\" in the final string\\n        # It means, whenever we come across something like \"ba\", we know we have to make one deletion\\n        deletions = 0\\n        \\n        # We will use this stack to put the \"b\" in it whenever we come across one\\n        # In short, this stack is only to keep track of previous \"b\"\\n        stack = []\\n        \\n        # Go through each character of the string\\n        for c in s:\\n            # If this is an \"a\"\\n            if c == \"a\":\\n                # Then, if the stack is not empty\\n                # It means, there was a \"b\" before it\\n                # So we need to make a deletion here\\n                if stack:\\n                    stack.pop()\\n                    deletions += 1\\n            # If it is a \"b\", just push it to the stack\\n            else: stack.append(c)\\n                \\n        return deletion\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2793615,
                "title": "python-98-beats-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\n        l=len(s)\\n        i=0\\n        while i<l and s[i]!=\\'b\\':\\n            i+=1\\n        j=l-1\\n        while j>=0 and s[j]!=\\'a\\':\\n            j-=1\\n        if i==l or j==-1:\\n            return 0\\n        \\n        ca=0\\n        cb=0\\n        ans=0\\n        for k in range(i,j+1):\\n            if s[k]==\\'a\\':\\n                if cb>0: \\n                    if ca>=cb:\\n                        ans+=cb\\n                        ca=0\\n                        cb=0\\n                    else:\\n                        ca+=1\\n            else:\\n                cb+=1\\n        ans+=min(ca,cb)\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\n        l=len(s)\\n        i=0\\n        while i<l and s[i]!=\\'b\\':\\n            i+=1\\n        j=l-1\\n        while j>=0 and s[j]!=\\'a\\':\\n            j-=1\\n        if i==l or j==-1:\\n            return 0\\n        \\n        ca=0\\n        cb=0\\n        ans=0\\n        for k in range(i,j+1):\\n            if s[k]==\\'a\\':\\n                if cb>0: \\n                    if ca>=cb:\\n                        ans+=cb\\n                        ca=0\\n                        cb=0\\n                    else:\\n                        ca+=1\\n            else:\\n                cb+=1\\n        ans+=min(ca,cb)\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633113,
                "title": "c-using-prefix-and-suffix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int l[n];//number of b\\'s from left\\n        int r[n];//number of a\\'s from right\\n        l[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=l[i-1];\\n            l[i]+=(s[i-1]==\\'b\\')? 1:0;\\n        }\\n        r[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=r[i+1];\\n            r[i]+=(s[i+1]==\\'a\\')? 1:0;\\n        }\\n        int ans=INT_MAX;\\n        //for(int i=0;i<n;i++){cout<<r[i]<<\" \";}\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        int l[n];//number of b\\'s from left\\n        int r[n];//number of a\\'s from right\\n        l[0]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            l[i]=l[i-1];\\n            l[i]+=(s[i-1]==\\'b\\')? 1:0;\\n        }\\n        r[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            r[i]=r[i+1];\\n            r[i]+=(s[i+1]==\\'a\\')? 1:0;\\n        }\\n        int ans=INT_MAX;\\n        //for(int i=0;i<n;i++){cout<<r[i]<<\" \";}\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,l[i]+r[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2568565,
                "title": "python-solution",
                "content": "use b to count current number of \"b\", use res to keep tracking current solution, res[0] is min deletions needed if keeping current \"a\", res[1] is min deletions needed if not keeping current \"a\".\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, res = 0, [0, 0]\\n        for c in s:\\n            if c == \"a\":\\n                res = [b, min(res) + 1]\\n            else:\\n                b += 1\\n        return min(res)\\n```\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, a = 0, s.count(\"a\")\\n        res = a\\n        for c in s:\\n            if c == \"a\":\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, res = 0, [0, 0]\\n        for c in s:\\n            if c == \"a\":\\n                res = [b, min(res) + 1]\\n            else:\\n                b += 1\\n        return min(res)\\n```\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        b, a = 0, s.count(\"a\")\\n        res = a\\n        for c in s:\\n            if c == \"a\":\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524041,
                "title": "monotonic-string-solution",
                "content": "MInimum number of deletions =Minimum flip required to convert into montonic string\\n\\t\\t   \\n\\t\\t   int count_b=0;\\n        int flip=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                count_b++;\\n            else\\n                flip++;\\n            \\n            flip=min(count_b,flip);\\n        }\\n        \\n        return flip;\\n    }",
                "solutionTags": [],
                "code": "MInimum number of deletions =Minimum flip required to convert into montonic string\\n\\t\\t   \\n\\t\\t   int count_b=0;\\n        int flip=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                count_b++;\\n            else\\n                flip++;\\n            \\n            flip=min(count_b,flip);\\n        }\\n        \\n        return flip;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2520410,
                "title": "c-o-n-tc-space-complexity-o-1",
                "content": "* Iterate from last index to \\'0\\'.\\n* Keep the count of \\'a\\'\\n* If \\'b\\' encounters decrease count_of_a and increase your ans by 1\\n\\n\\n\\nclass Solution {\\npublic:\\n    int find_collision(string &s){\\n         int n = s.size();\\n        \\n        \\n        int ct_a=0;    // counter for \\'a\\'\\n        int ans=0;     // our answer\\n        \\n        for(int i = n-1 ; i>=0; --i){\\n            if(s[i]==\\'a\\')ct_a++;\\n            else if(s[i]==\\'b\\' && ct_a>0){\\n                ++ans; \\n                --ct_a;\\n            }\\n        }\\n        \\n        return ans;\\n      \\n    }\\n    \\n    \\n    \\n   int minimumDeletions(string s) {\\n      return find_collision(s);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int find_collision(string &s){\\n         int n = s.size();\\n        \\n        \\n        int ct_a=0;    // counter for \\'a\\'\\n        int ans=0;     // our answer\\n        \\n        for(int i = n-1 ; i>=0; --i){\\n            if(s[i]==\\'a\\')ct_a++;\\n            else if(s[i]==\\'b\\' && ct_a>0){\\n                ++ans; \\n                --ct_a;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2405583,
                "title": "partition-at-every-index-very-simple-c-solution",
                "content": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\n// get the number of characters that can be included in balanced string \\n\\n// keeping count for the number of a\\'s on left side\\n// traverse the string , making partition around every index \\n\\n\\nint minimumDeletions(string s) {    \\n    int n = s.size();\\n    int maxi = 0;\\n    int a_left = 0, b_right = 0;\\n\\n    for(char ch : s) {\\n        if(ch == \\'b\\') b_right++;\\n    }\\n\\n    for(int i = 0; i < n; i++) {\\n        if(s[i] == \\'a\\') {\\n            a_left++;\\n            maxi = max(maxi, a_left + b_right);\\n        }\\n        else  {\\n            // maxi = max(maxi, a_left + b_right);\\n            b_right--;\\n        }\\n    }\\n\\n    return n - maxi;\\n}\\n\\n\\nint main() {   \\n    string s = \"babaabbba\";\\n    cout<<minimumDeletions(s)<<endl;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\n\\n// get the number of characters that can be included in balanced string \\n\\n// keeping count for the number of a\\'s on left side\\n// traverse the string , making partition around every index \\n\\n\\nint minimumDeletions(string s) {    \\n    int n = s.size();\\n    int maxi = 0;\\n    int a_left = 0, b_right = 0;\\n\\n    for(char ch : s) {\\n        if(ch == \\'b\\') b_right++;\\n    }\\n\\n    for(int i = 0; i < n; i++) {\\n        if(s[i] == \\'a\\') {\\n            a_left++;\\n            maxi = max(maxi, a_left + b_right);\\n        }\\n        else  {\\n            // maxi = max(maxi, a_left + b_right);\\n            b_right--;\\n        }\\n    }\\n\\n    return n - maxi;\\n}\\n\\n\\nint main() {   \\n    string s = \"babaabbba\";\\n    cout<<minimumDeletions(s)<<endl;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2383148,
                "title": "no-dp-simple-programming-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int n=s.size();\\n        \\n        int sol = INT_MAX;  int a=0, b=0, c1=0, c2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\') c1++;  else c2++;\\n        }\\n        if(c1==0 || c2==0) return 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sol = min(sol, (b + (c1-a)));\\n            if(s[i]==\\'a\\') a++;  else b++;\\n        }\\n        sol = min(sol, (b + (c1-a)));\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n        int n=s.size();\\n        \\n        int sol = INT_MAX;  int a=0, b=0, c1=0, c2=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\') c1++;  else c2++;\\n        }\\n        if(c1==0 || c2==0) return 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            sol = min(sol, (b + (c1-a)));\\n            if(s[i]==\\'a\\') a++;  else b++;\\n        }\\n        sol = min(sol, (b + (c1-a)));\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271337,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        int cntl = 0, cntr = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'b\\'){\\n                cntl++;\\n            }\\n            left[i] = cntl;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i]==\\'a\\'){\\n                cntr++;\\n            }\\n            right[i] = cntr;\\n        }\\n        int res = min(right[0],left[n-1]);\\n        for(int i=0; i<n-1; i++){\\n            res = min(res,left[i]+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        int cntl = 0, cntr = 0;\\n        for(int i=0; i<n; i++){\\n            if(s[i]==\\'b\\'){\\n                cntl++;\\n            }\\n            left[i] = cntl;\\n        }\\n        for(int i=n-1; i>=0; i--){\\n            if(s[i]==\\'a\\'){\\n                cntr++;\\n            }\\n            right[i] = cntr;\\n        }\\n        int res = min(right[0],left[n-1]);\\n        for(int i=0; i<n-1; i++){\\n            res = min(res,left[i]+right[i+1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271324,
                "title": "70-tc-and-78-sc-easy-python-solution",
                "content": "```\\ndef minimumDeletions(self, s: str) -> int:\\n\\tstart = [0]\\n\\tlast = [0]\\n\\tfor i in s:\\n\\t\\tstart.append(start[-1] + int(i==\"b\"))\\n\\tfor i in s[::-1]:\\n\\t\\tlast.append(last[-1] + int(i==\"a\"))\\n\\tans = 10000000000\\n\\tfor i in range(len(start)):\\n\\t\\tans = min(ans, start[i] + last[-i-1])\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef minimumDeletions(self, s: str) -> int:\\n\\tstart = [0]\\n\\tlast = [0]\\n\\tfor i in s:\\n\\t\\tstart.append(start[-1] + int(i==\"b\"))\\n\\tfor i in s[::-1]:\\n\\t\\tlast.append(last[-1] + int(i==\"a\"))\\n\\tans = 10000000000\\n\\tfor i in range(len(start)):\\n\\t\\tans = min(ans, start[i] + last[-i-1])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2254688,
                "title": "c-o-n-clean-code-two-approach",
                "content": "### **Approach 1: Without Stack**\\n\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n\\t// we are initializing ans with a, to consider the case where we want to delete all occurances of a.\\n        int a = count(s.begin(), s.end(), \\'a\\'), b = 0, ans = a;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            a -= s[i] == \\'a\\';\\n            b += s[i] == \\'b\\';\\n            \\n            ans = min(ans, b + a);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n**Time: O(N), Space: O(1).**\\n\\n### **Approach 2: Using Stack**\\n\\nclass Solution {\\npublic:\\n\\n\\tint minimumDeletions(string s) {\\n    int n=s.length();\\n    stack<char> stk;\\n    int c=0;\\n    for(int i=0;i<n;i++) {\\n        if (!stk.empty() && stk.top()==\\'b\\' && s[i]==\\'a\\')\\n\\t\\t\\t\\tstk.pop(),c++;\\n\\t\\t\\telse stk.push(s[i]);\\n\\t\\t}\\n\\t\\treturn c;\\n\\t}\\n};\\n\\n**Time: O(N), Space: O(N);**\\n\\nNote: Dry run for better understanding.\\nComment below for doubt or query.\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n\\t// we are initializing ans with a, to consider the case where we want to delete all occurances of a.\\n        int a = count(s.begin(), s.end(), \\'a\\'), b = 0, ans = a;\\n        \\n        for(int i=0; i<s.size(); ++i){\\n            a -= s[i] == \\'a\\';\\n            b += s[i] == \\'b\\';\\n            \\n            ans = min(ans, b + a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2209310,
                "title": "simple-java-solution-with-o-n-time-and-o-1-space",
                "content": "\\n    \\n\\tpublic int minimumDeletions(String s) {\\n        \\n\\t\\tint n=s.length();\\n\\t\\tint min=Integer.MAX_VALUE;;\\n\\t\\tint countA=0, countB=0;\\n        \\n        for(int i=0; i<n; i++)\\n            countA = s.charAt(i) == \\'a\\' ? countA+1 : countA;\\n\\n        for(int i=0; i<n; i++){\\n            countA = s.charAt(i) == \\'a\\' ? countA-1 : countA;\\n            min=Math.min(min, countA + countB);\\n            countB = s.charAt(i) == \\'b\\' ? countB+1 : countB;\\n        }\\n        \\n        return min;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    \\n\\tpublic int minimumDeletions(String s) {\\n        \\n\\t\\tint n=s.length();\\n\\t\\tint min=Integer.MAX_VALUE;;\\n\\t\\tint countA=0, countB=0;\\n        \\n        for(int i=0; i<n; i++)\\n            countA = s.charAt(i) == \\'a\\' ? countA+1 : countA;\\n\\n        for(int i=0; i<n; i++){\\n            countA = s.charAt(i) == \\'a\\' ? countA-1 : countA;\\n            min=Math.min(min, countA + countB);\\n            countB = s.charAt(i) == \\'b\\' ? countB+1 : countB;\\n        }\\n        \\n        return min;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2181270,
                "title": "o-n-and-o-nlogn-solutions-in-c",
                "content": "**Method 1:** O(NlogN) - Map \\'a\\' -> 0 and \\'b\\' -> 1. Find longest non-decreasing sub-sequence\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int len = s.length();\\n        vector <int> arr;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int d = s[i] - \\'a\\';\\n                \\n            if(arr.empty()) {\\n                arr.push_back(d);\\n            }\\n            else {\\n                if(d >= arr.back()) {\\n                    arr.push_back(d);\\n                }\\n                else {\\n                    int idx = upper_bound(arr.begin(), arr.end(), d) - arr.begin();\\n                    arr[idx] = d;\\n                }\\n            }\\n        }\\n        \\n        return len - arr.size();\\n    }\\n};\\n```\\n\\n**Method 2:** O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ta = 0, tb = 0, len = s.length();\\n        for(const char &ch : s) {\\n            tb += (ch == \\'b\\');\\n            ta += (ch == \\'a\\');\\n        }\\n        \\n        int x = 0, a = 0, b = 0, res = min(tb, ta); // make all \\'a\\' or all \\'b\\'\\n        for(const char &ch : s) {\\n            a += (ch == \\'a\\');\\n            b += (ch == \\'b\\');\\n            x++;\\n            \\n            // make left part (a) and right part (b)\\n            int op = b + (ta - a);\\n            \\n            res = min(res, op);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int len = s.length();\\n        vector <int> arr;\\n        \\n        for(int i = 0; i < len; i++) {\\n            int d = s[i] - \\'a\\';\\n                \\n            if(arr.empty()) {\\n                arr.push_back(d);\\n            }\\n            else {\\n                if(d >= arr.back()) {\\n                    arr.push_back(d);\\n                }\\n                else {\\n                    int idx = upper_bound(arr.begin(), arr.end(), d) - arr.begin();\\n                    arr[idx] = d;\\n                }\\n            }\\n        }\\n        \\n        return len - arr.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int ta = 0, tb = 0, len = s.length();\\n        for(const char &ch : s) {\\n            tb += (ch == \\'b\\');\\n            ta += (ch == \\'a\\');\\n        }\\n        \\n        int x = 0, a = 0, b = 0, res = min(tb, ta); // make all \\'a\\' or all \\'b\\'\\n        for(const char &ch : s) {\\n            a += (ch == \\'a\\');\\n            b += (ch == \\'b\\');\\n            x++;\\n            \\n            // make left part (a) and right part (b)\\n            int op = b + (ta - a);\\n            \\n            res = min(res, op);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127919,
                "title": "simple-o-n-java-solution-without-dp",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int[] aS = new int[s.length()];\\n        int[] bS = new int[s.length()];\\n        \\n        int cnt = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            aS[i] = cnt;\\n            if(s.charAt(i) == \\'a\\') cnt++;\\n        }\\n        \\n        cnt = 0;\\n        for(int i = 0; i< s.length(); i++) {\\n            bS[i] = cnt;\\n            if(s.charAt(i) == \\'b\\') cnt++;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i< s.length(); i++) {\\n            ans = Math.min(ans , aS[i] + bS[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int[] aS = new int[s.length()];\\n        int[] bS = new int[s.length()];\\n        \\n        int cnt = 0;\\n        for(int i = s.length() - 1; i >= 0; i--) {\\n            aS[i] = cnt;\\n            if(s.charAt(i) == \\'a\\') cnt++;\\n        }\\n        \\n        cnt = 0;\\n        for(int i = 0; i< s.length(); i++) {\\n            bS[i] = cnt;\\n            if(s.charAt(i) == \\'b\\') cnt++;\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i< s.length(); i++) {\\n            ans = Math.min(ans , aS[i] + bS[i]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108657,
                "title": "simplest-shortest-solution",
                "content": "a = max len string of the form aaa....aaa with possibly 0 a\\nab = max len string of the form aaa...aabb....bb with possibly 0 a and/or 0 b\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), a = 0, ab = 0;\\n        for(char &c : s) {\\n            if (c == \\'a\\') {\\n                a++;\\n                ab = max(ab, a);\\n            } else ab++;\\n        }\\n        return n - ab;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n = s.size(), a = 0, ab = 0;\\n        for(char &c : s) {\\n            if (c == \\'a\\') {\\n                a++;\\n                ab = max(ab, a);\\n            } else ab++;\\n        }\\n        return n - ab;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032143,
                "title": "python-simple-o-n-find-split-point",
                "content": "Basically, we want the string to end up to be \"aaaaaaaa\", or \"bbbbbbb\" or \"aaaabbbbb\". We just need to find an optimum split point in the string, whereby number of \"b\" to the left of split point + number of \"a\" to the right of split point is the minimum. \\n\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:        \\n\\n        left_b = 0  ###Keep track of number of \"b\" to the left of split point\\n        right_a = s.count(\"a\") ###Keep track of number of \"a\" to the right of split point\\n        \\n        min_deletion = right_a ###Delete all a\\n        \\n        ###Iterate through all potential position split point\\n        for i, char in enumerate(s):\\n            if char == \"a\":\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n                \\n            min_deletion = min(min_deletion, left_b + right_a)\\n            \\n            \\n        return min_deletion\\n            \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:        \\n\\n        left_b = 0  ###Keep track of number of \"b\" to the left of split point\\n        right_a = s.count(\"a\") ###Keep track of number of \"a\" to the right of split point\\n        \\n        min_deletion = right_a ###Delete all a\\n        \\n        ###Iterate through all potential position split point\\n        for i, char in enumerate(s):\\n            if char == \"a\":\\n                right_a -= 1\\n            else:\\n                left_b += 1\\n                \\n            min_deletion = min(min_deletion, left_b + right_a)\\n            \\n            \\n        return min_deletion\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013333,
                "title": "python-prefix-sum",
                "content": "The question is similar to **926. Flip String to Monotone Increasing.**\\n\\nWe can apply the same logic as in the solution for question 926, create a prefix sum and find the sum of *\\'b\\'* to the left of a position in the string and *\\'a\\'* to the right of the position in the string, this sum would be the number of deletions required to make the string balanced.\\n\\nThen find the minimum of this sum by considering every possible position in the string.\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        prefix = [0]\\n        for i in range(0,len(s)):\\n            prefix.append(prefix[-1]+1 if s[i]==\\'b\\' else prefix[-1])\\n        print(prefix)\\n        mini = float(\\'inf\\')\\n        for i in range(len(prefix)):\\n            val=prefix[i]+(len(s)-i)-(prefix[-1]-prefix[i])\\n            mini=min(mini,val)\\n        return mini if mini!=float(\\'inf\\') else 0\\n```",
                "solutionTags": [
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        prefix = [0]\\n        for i in range(0,len(s)):\\n            prefix.append(prefix[-1]+1 if s[i]==\\'b\\' else prefix[-1])\\n        print(prefix)\\n        mini = float(\\'inf\\')\\n        for i in range(len(prefix)):\\n            val=prefix[i]+(len(s)-i)-(prefix[-1]-prefix[i])\\n            mini=min(mini,val)\\n        return mini if mini!=float(\\'inf\\') else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011120,
                "title": "c-dp-tabulation-and-space-optimized-solution-with-explanation-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n        \\n        //============================Tabulation DP Approach O(N) Time O(N) Space==============================//\\n//         vector<int> dp(s.size()+1);\\n//         int b = 0;\\n//         dp[0] = 0;\\n//         for(int i = 1; i<=s.size(); i++)\\n//         {\\n//             if(s[i-1]==\\'a\\')\\n//             {\\n//                 dp[i] = min(1+dp[i-1],b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n//             }\\n//             else\\n//             {\\n//                 dp[i] = dp[i-1], ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n//             }\\n//         }\\n//         return dp[s.size()];\\n        \\n        \\n        //========================Space Optimized DP O(N) Time O(1) Space =================================//\\n        //Since we are only using current and previous state of the dp array...!\\n        int prev = 0, curr = 0;\\n        int b = 0;\\n        for(int i = 1; i<=s.size(); i++)\\n        {\\n            if(s[i-1]==\\'a\\')\\n            {\\n                curr = min(1+prev,b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n            }\\n            else\\n            {\\n                curr = prev, ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n            }\\n            prev = curr;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumDeletions(string s) {\\n        \\n        //============================Tabulation DP Approach O(N) Time O(N) Space==============================//\\n//         vector<int> dp(s.size()+1);\\n//         int b = 0;\\n//         dp[0] = 0;\\n//         for(int i = 1; i<=s.size(); i++)\\n//         {\\n//             if(s[i-1]==\\'a\\')\\n//             {\\n//                 dp[i] = min(1+dp[i-1],b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n//             }\\n//             else\\n//             {\\n//                 dp[i] = dp[i-1], ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n//             }\\n//         }\\n//         return dp[s.size()];\\n        \\n        \\n        //========================Space Optimized DP O(N) Time O(1) Space =================================//\\n        //Since we are only using current and previous state of the dp array...!\\n        int prev = 0, curr = 0;\\n        int b = 0;\\n        for(int i = 1; i<=s.size(); i++)\\n        {\\n            if(s[i-1]==\\'a\\')\\n            {\\n                curr = min(1+prev,b); //if current character is \\'a\\', we can either remove all b\\'s that have appeared before it OR we can remove the current character \\'a\\' itself\\n            }\\n            else\\n            {\\n                curr = prev, ++b; //we can consider \\'b\\' in any case, doesn\\'t matter if \\'a\\' or \\'b\\' have appeared before or not...we just count b at every occurence\\n            }\\n            prev = curr;\\n        }\\n        \\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006722,
                "title": "easy-to-understand-dp-solution-using-python-o-n",
                "content": "First we will create two arrays of n+1 size for storing a\\'s and b\\'s count. Now, the size of array needs to be n+1 because, we want to know that what will be the answer if we want to consider the first and last index.\\nStep1. Traverse the string and store count of a\\'s from left to right in dp_fron, including a on that position, we will start filling array from index 1 not 0\\nStep2. Repeat step1 from Right to Left for b\\'s cound and for this we will start filling from index n-1\\nStep3. We will count the a\\'s count and b\\'s count of each position and store the maximum count.\\nStep4. Subtract the max count with the length of array to get number of elements to remove.\\n```\\nn=len(s)\\ndp_front=[0]*(n+1)\\ndp_last=[0]*(n+1)\\n\\n\\nfor i in range(n):\\n    if s[i]==\"a\":\\n        dp_front[i+1]=dp_front[i]+1\\n    else:\\n        dp_front[i+1]=dp_front[i]\\n\\nfor i in range(n-1,-1,-1):\\n    if s[i]==\"b\":\\n        dp_last[i]=dp_last[i+1]+1\\n    else:\\n        dp_last[i]=dp_last[i+1]\\n\\nmax_val=0\\nfor i in range(n+1):\\n    max_val=max(max_val,dp_front[i]+dp_last[i])\\nans=n-max_val\\nprint(ans)\\n\\n```\\nThanks for reading it out, hope you finds this solution useful.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nn=len(s)\\ndp_front=[0]*(n+1)\\ndp_last=[0]*(n+1)\\n\\n\\nfor i in range(n):\\n    if s[i]==\"a\":\\n        dp_front[i+1]=dp_front[i]+1\\n    else:\\n        dp_front[i+1]=dp_front[i]\\n\\nfor i in range(n-1,-1,-1):\\n    if s[i]==\"b\":\\n        dp_last[i]=dp_last[i+1]+1\\n    else:\\n        dp_last[i]=dp_last[i+1]\\n\\nmax_val=0\\nfor i in range(n+1):\\n    max_val=max(max_val,dp_front[i]+dp_last[i])\\nans=n-max_val\\nprint(ans)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1965368,
                "title": "java",
                "content": "\"\"\"\\nclass Solution \\n{\\n    public int minimumDeletions(String s) \\n    {\\n        int aLeft = 0, bLeft = 0;\\n        int aRight = findCount(s, \\'a\\'), bRight = findCount(s, \\'b\\');\\n        \\n        /*Any one of the 2 can be utilized :\\n                 -------------------\\n              | int minDel = bRight; |\\n              | int minDel = aRight; |\\n                ---------------------\\n            i.e To get the right sequence, we can either delete all the a\\'s\\n            or all the b\\'s towards the right hand side*/\\n        \\n        \\n        int minDel = aRight;\\n        \\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            //To get the valid result, we need to delete all the b\\'s appearing towards the left and all the a\\'s appearing towards the right\\n            minDel = Math.min(minDel, bLeft + aRight);\\n            \\n            //Update the 4 counter variables appropriately (aRight, aLeft, bRight, bLeft)\\n            if(s.charAt(i) == \\'a\\')\\n            {\\n                aRight -= 1;\\n                aLeft += 1;\\n            }\\n            else\\n            {\\n                bRight -= 1;\\n                bLeft += 1;\\n            }\\n        }\\n        \\n        minDel = Math.min(minDel, bLeft + aRight);\\n        return minDel;\\n    }\\n    \\n    //Returns the count of character c in the String \\n    private int findCount(String s, char c)\\n    {\\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == c)\\n            {\\n                count += 1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\"\"\"",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public int minimumDeletions(String s) \\n    {\\n        int aLeft = 0, bLeft = 0;\\n        int aRight = findCount(s, \\'a\\'), bRight = findCount(s, \\'b\\');\\n        \\n        /*Any one of the 2 can be utilized :\\n                 -------------------\\n              | int minDel = bRight; |\\n              | int minDel = aRight; |\\n                ---------------------\\n            i.e To get the right sequence, we can either delete all the a\\'s\\n            or all the b\\'s towards the right hand side*/\\n        \\n        \\n        int minDel = aRight;\\n        \\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            //To get the valid result, we need to delete all the b\\'s appearing towards the left and all the a\\'s appearing towards the right\\n            minDel = Math.min(minDel, bLeft + aRight);\\n            \\n            //Update the 4 counter variables appropriately (aRight, aLeft, bRight, bLeft)\\n            if(s.charAt(i) == \\'a\\')\\n            {\\n                aRight -= 1;\\n                aLeft += 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1948314,
                "title": "weeb-does-python-c-prefix-suffix-sum",
                "content": "**Python**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef minimumDeletions(self, s: str) -> int:\\n\\t\\t\\tpreSum = [0] * (len(s) + 1)\\n\\t\\t\\tsufSum = [0] * (len(s) + 1)\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"a\":\\n\\t\\t\\t\\t\\tpreSum[i] += 1 + preSum[i-1]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpreSum[i] = preSum[i-1]\\n\\n\\t\\t\\t\\tif s[len(s)-i-1] == \"b\":\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += sufSum[len(s)-i]\\n\\n\\t\\t\\tmaxStringLength = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif preSum[i] + sufSum[i] > maxStringLength:\\n\\t\\t\\t\\t\\tmaxStringLength = preSum[i] + sufSum[i]\\n\\n\\t\\t\\treturn len(s) - maxStringLength\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeletions(string s) {\\n\\t\\t\\tvector<int> preSum(s.size(), 0);\\n\\t\\t\\tvector<int> sufSum(s.size(), 0);\\n\\n\\t\\t\\tif (s[0] == \\'a\\') preSum[0] = 1;\\n\\t\\t\\tif (s[s.size()-1] == \\'b\\') sufSum[s.size()-1] = 1;\\n\\n\\t\\t\\tfor (int i=1; i<s.size(); i++){\\n\\t\\t\\t\\tif (s[i] == \\'a\\') preSum[i] += 1 + preSum[i-1];\\n\\n\\t\\t\\t\\telse{preSum[i] = preSum[i-1];}\\n\\n\\t\\t\\t\\tif (s[s.size()-i-1] == \\'b\\') sufSum[s.size()-i-1] += 1 + sufSum[s.size()-i];\\n\\n\\t\\t\\t\\telse{sufSum[s.size()-i-1] += sufSum[s.size()-i];}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxStringLen = 0;\\n\\n\\t\\t\\tfor (int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif (preSum[i] + sufSum[i] > maxStringLen) maxStringLen = preSum[i] + sufSum[i];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s.size() - maxStringLen;\\n\\t\\t}\\n\\t};\\n\\nTake a break, watch some anime\\nCheck out **\\u6BBA\\u3057\\u611B (Love of Kill)**\\n\\n\\n# Episodes: 12\\n# Genres: Action, Romance\\n# Themes: Adult Cast, Organized Crime\\n\\nIts a nice anime, watch it",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n\\t\\tdef minimumDeletions(self, s: str) -> int:\\n\\t\\t\\tpreSum = [0] * (len(s) + 1)\\n\\t\\t\\tsufSum = [0] * (len(s) + 1)\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif s[i] == \"a\":\\n\\t\\t\\t\\t\\tpreSum[i] += 1 + preSum[i-1]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tpreSum[i] = preSum[i-1]\\n\\n\\t\\t\\t\\tif s[len(s)-i-1] == \"b\":\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tsufSum[len(s)-i-1] += sufSum[len(s)-i]\\n\\n\\t\\t\\tmaxStringLength = 0\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tif preSum[i] + sufSum[i] > maxStringLength:\\n\\t\\t\\t\\t\\tmaxStringLength = preSum[i] + sufSum[i]\\n\\n\\t\\t\\treturn len(s) - maxStringLength\\n\\n**C++**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumDeletions(string s) {\\n\\t\\t\\tvector<int> preSum(s.size(), 0);\\n\\t\\t\\tvector<int> sufSum(s.size(), 0);\\n\\n\\t\\t\\tif (s[0] == \\'a\\') preSum[0] = 1;\\n\\t\\t\\tif (s[s.size()-1] == \\'b\\') sufSum[s.size()-1] = 1;\\n\\n\\t\\t\\tfor (int i=1; i<s.size(); i++){\\n\\t\\t\\t\\tif (s[i] == \\'a\\') preSum[i] += 1 + preSum[i-1];\\n\\n\\t\\t\\t\\telse{preSum[i] = preSum[i-1];}",
                "codeTag": "Java"
            },
            {
                "id": 1946583,
                "title": "c-o-1-space-same-as-lc926-simple-solution-with-explanation",
                "content": "We just have two options when current character `s[i]` is `a`, and we already have best solution `res` for `0~i-1` : \\n(1) delete all `b` we have counted before\\n(2) only delete current character, sum with `res`\\nso `res = min(res+1, bcnt)`\\n\\n* time: `O(n)`\\n* space: `O(1)`\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bcnt = 0, res = 0;\\n        for (auto &ch: s) {\\n            if (ch == \\'a\\') {\\n                res = min(res+1, bcnt);\\n            } else {\\n                ++bcnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int bcnt = 0, res = 0;\\n        for (auto &ch: s) {\\n            if (ch == \\'a\\') {\\n                res = min(res+1, bcnt);\\n            } else {\\n                ++bcnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918029,
                "title": "elegant-c-solution",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int cnt1=0, cnt2=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                cnt1++; // the number of b appearing before a\\n            }\\n            else if(cnt1>0)\\n            {\\n                cnt1--; \\n                cnt2++;  \\n            }\\n            i++;\\n        }\\n        return cnt2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int cnt1=0, cnt2=0;\\n        int i=0;\\n        while(i<s.length())\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                cnt1++; // the number of b appearing before a\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901549,
                "title": "python-o-n-stack-with-explanation",
                "content": "Idea is to count the number of pairs of \"b\" and \"a\" such that \"a\" has appeared after a \"b\"\\n        \\n\\tuse stack\\n            see b? push to stack\\n            see a?\\n                if stack not empty: \\n                     pop from the stack and count it as a deletion \\nTime and space: O(n)\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\t\\tstack = [] \\n        counter = 0 \\n        \\n        for char in s:\\n            if char == \"b\":\\n                stack.append(char)\\n            \\n            elif stack:\\n                counter += 1\\n                stack.pop()\\n        \\n        return counter \\n            \\n        \\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n\\t\\tstack = [] \\n        counter = 0 \\n        \\n        for char in s:\\n            if char == \"b\":\\n                stack.append(char)\\n            \\n            elif stack:\\n                counter += 1\\n                stack.pop()\\n        \\n        return counter \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897453,
                "title": "cpp-prefix-sum-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        if(n==1)\\n        {\\n            if(s[0]==\\'a\\')\\n                return 0;\\n        }\\n        vector<int> a(n,0),b(n,0);\\n        if(s[0]==\\'b\\')\\n        {\\n            b[0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                b[i]=b[i-1]+1;\\n            }\\n            else\\n            {\\n                b[i]=b[i-1];\\n            }\\n        }\\n        if(s[n-1]==\\'a\\')\\n        {\\n            a[n-1]=1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                a[i]=a[i+1]+1;\\n            }\\n            else\\n            {\\n                a[i]=a[i+1];\\n            }\\n        }\\n        int mi=n;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            mi=min(mi,a[i+1]+b[i-1]);\\n        }\\n        if(b[n-1]==n||a[0]==n)\\n            return 0;\\n        mi=min(mi,a[0]);\\n        mi=min(mi,b[n-1]);\\n        return mi;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        if(n==1)\\n        {\\n            if(s[0]==\\'a\\')\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1893179,
                "title": "java-find-the-longest-valid-sequence",
                "content": "This question translates to find the longest valid sequence and the answer would be length of string minus that. \\n\\nLet `a` be the length of a valid sequence that ends with an `a`.\\nLet `b` be the length of a valid sequence that ends with an `b`.\\n\\nCase 1 - When current char equals to a: We increment `a` by 1 as there is no way to transition from a valid sequence that ends with a `b` to `a`.\\nCase 2 - When current char equals to b: We can append this `b` to either `a` or `b` to form a valid sequence, that is, we take from `max(a, b)` and plus 1.\\n\\n\\n```Java\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (char ch : s.toCharArray()){\\n            if (ch == \\'a\\'){\\n                a++;\\n            }else{\\n                b = Math.max(a, b) + 1;\\n            }\\n        }\\n\\n        return s.length() - Math.max(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (char ch : s.toCharArray()){\\n            if (ch == \\'a\\'){\\n                a++;\\n            }else{\\n                b = Math.max(a, b) + 1;\\n            }\\n        }\\n\\n        return s.length() - Math.max(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880018,
                "title": "without-stack-o-1-space",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int count=0;\\n        //stack<char> st;\\n        int countb=0;\\n        int counta=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            \\n            else{\\n                counta++;\\n            }\\n            \\n            if(countb!=0 && s[i]==\\'a\\'){\\n                countb--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int count=0;\\n        //stack<char> st;\\n        int countb=0;\\n        int counta=0;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==\\'b\\'){\\n                countb++;\\n            }\\n            \\n            else{\\n                counta++;\\n            }\\n            \\n            if(countb!=0 && s[i]==\\'a\\'){\\n                countb--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1873217,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        \\n        int ans=INT_MIN;\\n        int cntb=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                cntb++;\\n        }       \\n        int a=0,b=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                a++;\\n                ans=max(ans,a+cntb-b);\\n            }\\n            else\\n            {\\n                b++;\\n                ans=max(ans,a+cntb-b+1);\\n            }\\n            \\n        }\\n        \\n        return n-ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n=s.size();\\n        \\n        int ans=INT_MIN;\\n        int cntb=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(s[i]==\\'b\\')\\n                cntb++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1813674,
                "title": "c-prefix-sum-o-n",
                "content": "**Idea**\\nThere will exist atleast one index `i` before which we have to remove all `b` and after which will have to remove all `a`. Bulid a prefix(`left`) and suffix(`right`) array which contains no. of `b` till index `i` and no. of `a` after index `i` including `i`.\\nThen calculate min no. of operations by `min(left[i-1]+right[i])`. Take care of boundary cases.\\n**Time: O(n)**\\n**Space: O(n)**\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> left(s.size(),0),right(s.size(),0);\\n        \\n        if(s[0]==\\'b\\') left[0]++;\\n        for(int i = 1; i<s.size();++i){\\n            left[i] = left[i-1];\\n            if(s[i]==\\'b\\') left[i]++;\\n        }\\n        \\n        if(s[s.size()-1]==\\'a\\') right[s.size()-1]++;\\n        for(int i = s.size()-2;i>=0;--i){\\n            right[i] = right[i+1];\\n            if(s[i]==\\'a\\') right[i]++;\\n        }\\n        \\n        int re = min(right[0],left[s.size()-1]);\\n        for(int i = 1;i<s.size()-1;++i) re = min(re,left[i-1]+right[i]);\\n        \\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> left(s.size(),0),right(s.size(),0);\\n        \\n        if(s[0]==\\'b\\') left[0]++;\\n        for(int i = 1; i<s.size();++i){\\n            left[i] = left[i-1];\\n            if(s[i]==\\'b\\') left[i]++;\\n        }\\n        \\n        if(s[s.size()-1]==\\'a\\') right[s.size()-1]++;\\n        for(int i = s.size()-2;i>=0;--i){\\n            right[i] = right[i+1];\\n            if(s[i]==\\'a\\') right[i]++;\\n        }\\n        \\n        int re = min(right[0],left[s.size()-1]);\\n        for(int i = 1;i<s.size()-1;++i) re = min(re,left[i-1]+right[i]);\\n        \\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760353,
                "title": "c-o-n-t-c-o-1-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n         int n = s.size();\\n        \\n           // edge case\\n           if(n == 1) return 0;\\n        \\n           int count_a = 0;\\n           for(char ch : s){\\n               if(ch == \\'a\\') count_a++;\\n           }\\n           \\n           if(count_a == 0)  return 0;\\n           int curCount_b = 0, curCount_a;\\n        \\n           int ans = INT_MAX;\\n        \\n           for(char ch : s){\\n               if(ch == \\'a\\'){\\n                   curCount_a++;\\n                   ans = min(ans, curCount_b + count_a - curCount_a);\\n               }\\n               else {\\n                      ans = min(ans, curCount_b + count_a - curCount_a); \\n                      curCount_b++;\\n               }\\n           }\\n         \\n           return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n         int n = s.size();\\n        \\n           // edge case\\n           if(n == 1) return 0;\\n        \\n           int count_a = 0;\\n           for(char ch : s){\\n               if(ch == \\'a\\') count_a++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1754652,
                "title": "javascript-iterative-dynamic-programming-explanation",
                "content": "```\\n/** https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s) {\\n  if (s.length === 1) {\\n    return 0;\\n  }\\n  \\n  let bCount = Array(s.length+1).fill(0);\\n  \\n  // Count how many \\'b\\' from `0...i-1`\\n  for (let i = 0; i < s.length; i++) {\\n    bCount[i+1] = bCount[i];\\n    \\n    if (s[i] === \\'b\\') {\\n      bCount[i+1] += 1;\\n    }\\n  }\\n  \\n  let out = Infinity;\\n  \\n  // Find the least deletion operation needed to make string balance\\n  // To achieve that, we delete all \\'a\\' on the right + all \\'b\\' on the left of `i`\\n  for (let i = 0; i < s.length; i++) {\\n    // How many \\'b\\' on the left\\n    let bOnLeft = bCount[i];\\n    \\n    // How many \\'a\\' on the right\\n    // The formula is the length of `s` (0 indexed) - current position `i` minus how many \\'b\\' on the right\\n    // How many \\'b\\' on the right is easy to calculate by taking last \\'b\\' count and minus how many \\'b\\' at `i+1` then we get \\'b\\' count from `i...s.length-1`\\n    let length = s.length - 1;\\n    let bOnRight = bCount[bCount.length - 1] - bCount[i + 1];\\n    let aOnRight = length - i - bOnRight;\\n    \\n    out = Math.min(out, bOnLeft + aOnRight);\\n  }\\n  \\n  return out;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\n/** https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s) {\\n  if (s.length === 1) {\\n    return 0;\\n  }\\n  \\n  let bCount = Array(s.length+1).fill(0);\\n  \\n  // Count how many \\'b\\' from `0...i-1`\\n  for (let i = 0; i < s.length; i++) {\\n    bCount[i+1] = bCount[i];\\n    \\n    if (s[i] === \\'b\\') {\\n      bCount[i+1] += 1;\\n    }\\n  }\\n  \\n  let out = Infinity;\\n  \\n  // Find the least deletion operation needed to make string balance\\n  // To achieve that, we delete all \\'a\\' on the right + all \\'b\\' on the left of `i`\\n  for (let i = 0; i < s.length; i++) {\\n    // How many \\'b\\' on the left\\n    let bOnLeft = bCount[i];\\n    \\n    // How many \\'a\\' on the right\\n    // The formula is the length of `s` (0 indexed) - current position `i` minus how many \\'b\\' on the right\\n    // How many \\'b\\' on the right is easy to calculate by taking last \\'b\\' count and minus how many \\'b\\' at `i+1` then we get \\'b\\' count from `i...s.length-1`\\n    let length = s.length - 1;\\n    let bOnRight = bCount[bCount.length - 1] - bCount[i + 1];\\n    let aOnRight = length - i - bOnRight;\\n    \\n    out = Math.min(out, bOnLeft + aOnRight);\\n  }\\n  \\n  return out;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699321,
                "title": "python3-simple-and-fast-o-n-time-o-1-space",
                "content": "We should loop through the string and keep track of the number of ***a***\\'s in the right side and the number of ***b***\\'s in the left side, the minimum sum of these two counts is the answer.\\n```\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        a, b = s.count(\\'a\\'), 0\\n        res = a + b\\n        for char in s:\\n            if char == \\'a\\':\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s):\\n        a, b = s.count(\\'a\\'), 0\\n        res = a + b\\n        for char in s:\\n            if char == \\'a\\':\\n                a -= 1\\n            else:\\n                b += 1\\n            res = min(res, a + b)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641169,
                "title": "c-o-n-time-space-amateur-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(string s) {\\n        int n = s.length();\\n        \\n        \\n        \\n        //1. Calculate the number of \\'b\\'s appearing before index i\\n        vector<int> leftB(n,0); \\n        for(int i=1;i<n;i++){\\n            leftB[i] = (s[i-1] == \\'b\\') + leftB[i-1];\\n        }\\n        \\n        //2. Calculate the number of \\'a\\'s appearing after index i\\n        vector<int> rightA(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            rightA[i] = (s[i+1] == \\'a\\') + rightA[i+1];\\n        }\\n        \\n        //3. deletion for each index i = leftB[i] + rightA[i]\\n        //   find the index with minimum deletions\\n        int minDeletions = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            minDeletions = min(minDeletions, leftB[i] + rightA[i]);\\n        }\\n        \\n        return minDeletions;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumDeletions(string s) {\\n        int n = s.length();\\n        \\n        \\n        \\n        //1. Calculate the number of \\'b\\'s appearing before index i\\n        vector<int> leftB(n,0); \\n        for(int i=1;i<n;i++){\\n            leftB[i] = (s[i-1] == \\'b\\') + leftB[i-1];\\n        }\\n        \\n        //2. Calculate the number of \\'a\\'s appearing after index i\\n        vector<int> rightA(n,0);\\n        for(int i=n-2;i>=0;i--){\\n            rightA[i] = (s[i+1] == \\'a\\') + rightA[i+1];\\n        }\\n        \\n        //3. deletion for each index i = leftB[i] + rightA[i]\\n        //   find the index with minimum deletions\\n        int minDeletions = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            minDeletions = min(minDeletions, leftB[i] + rightA[i]);\\n        }\\n        \\n        return minDeletions;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624492,
                "title": "java-easy-10-line-o-n-o-1-dp-solution",
                "content": "@a: maximum length of valid string end with a\\n@b: maximum length of valid string end with b\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') a = a+1;\\n            else  b = Math.max(b+1, a+1);\\n        }\\n        return s.length()-Math.max(a,b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') a = a+1;\\n            else  b = Math.max(b+1, a+1);\\n        }\\n        return s.length()-Math.max(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591448,
                "title": "dp-c-easy-to-understand",
                "content": "You can remove only all the \\'a\\' after a certain point and the \\'b\\' before that point.\\nSo you are supposed to find the minimum among all those possible value.\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ca=0,cb=0;\\n        for(auto c:s){\\n            if(c==\\'a\\')ca++;\\n            else cb++;\\n        }\\n        int n=s.length();\\n        int ans=ca;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\')a++;\\n            else b++;\\n            ans=min(ans,ca-a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ca=0,cb=0;\\n        for(auto c:s){\\n            if(c==\\'a\\')ca++;\\n            else cb++;\\n        }\\n        int n=s.length();\\n        int ans=ca;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'a\\')a++;\\n            else b++;\\n            ans=min(ans,ca-a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583404,
                "title": "c-time-o-n-space-o-1-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // let endA[i] be the length of the longest balanced string up to position i and ending with \\'a\\'\\n    // let endB[i] be the length of the longest balanced string up to position i and ending with \\'b\\'\\n    //\\n    // now, consider position i+1\\n    //\\n    // if s[i+1] == \\'a\\', we can form a longer balanced string by appending \\'a\\'\\n\\t// to the the longest balanced string ending with \\'a\\' up to position i,\\n    // thus\\n    //    endA[i+1] = endA[i] + 1\\n    // we cannot append \\'a\\' to a string ending with \\'b\\' to form a balance string so endB stays the same\\n    //    endB[i+1] = endB[i]\\n\\t//\\n    // if s[i+1] == \\'b\\', we can form a longer balanced string by appending \\'b\\'\\n\\t// to either the longest blanced string ending with \\'b\\' or \\'a\\' up to position i,\\n    // thus\\n    //    endB[i+1] = max(endB[i], endA[i]) + 1\\n    // endA stays the same\\n    //    endA[i+1] = endA[i]\\n    //\\n    // answer will be s.size() - max(endA[n], endB[n]);\\n\\t\\n    int minimumDeletions(string s) {\\n        std::ios_base::sync_with_stdio(0);\\n        std::cin.tie(0);\\n        \\n        int endA = 0, endB = 0;\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'a\\') {\\n                endA = endA + 1;\\n            } else {\\n                endB = std::max(endB + 1, endA + 1);\\n            }\\n        }\\n        \\n        return s.size() - std::max(endA, endB);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // let endA[i] be the length of the longest balanced string up to position i and ending with \\'a\\'\\n    // let endB[i] be the length of the longest balanced string up to position i and ending with \\'b\\'\\n    //\\n    // now, consider position i+1\\n    //\\n    // if s[i+1] == \\'a\\', we can form a longer balanced string by appending \\'a\\'\\n\\t// to the the longest balanced string ending with \\'a\\' up to position i,\\n    // thus\\n    //    endA[i+1] = endA[i] + 1\\n    // we cannot append \\'a\\' to a string ending with \\'b\\' to form a balance string so endB stays the same\\n    //    endB[i+1] = endB[i]\\n\\t//\\n    // if s[i+1] == \\'b\\', we can form a longer balanced string by appending \\'b\\'\\n\\t// to either the longest blanced string ending with \\'b\\' or \\'a\\' up to position i,\\n    // thus\\n    //    endB[i+1] = max(endB[i], endA[i]) + 1\\n    // endA stays the same\\n    //    endA[i+1] = endA[i]\\n    //\\n    // answer will be s.size() - max(endA[n], endB[n]);\\n\\t\\n    int minimumDeletions(string s) {\\n        std::ios_base::sync_with_stdio(0);\\n        std::cin.tie(0);\\n        \\n        int endA = 0, endB = 0;\\n        \\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == \\'a\\') {\\n                endA = endA + 1;\\n            } else {\\n                endB = std::max(endB + 1, endA + 1);\\n            }\\n        }\\n        \\n        return s.size() - std::max(endA, endB);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566086,
                "title": "java-dp-two-states-switch",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int end_a = 0;\\n        int end_b = 0;\\n        for(char c : s.toCharArray()){\\n            int cur_end_a;\\n            int cur_end_b;\\n            if(c == \\'a\\'){\\n                cur_end_a = end_a;\\n                cur_end_b = Math.min(end_a + 1, end_b + 1);\\n            }else{\\n                cur_end_a = end_a + 1;\\n                cur_end_b = Math.min(end_a, end_b);\\n            }\\n            end_a = cur_end_a;\\n            end_b = cur_end_b;\\n        }\\n        return Math.min(end_a, end_b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int end_a = 0;\\n        int end_b = 0;\\n        for(char c : s.toCharArray()){\\n            int cur_end_a;\\n            int cur_end_b;\\n            if(c == \\'a\\'){\\n                cur_end_a = end_a;\\n                cur_end_b = Math.min(end_a + 1, end_b + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1551143,
                "title": "o-1-space-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b = 0 , ans = 0;\\n        for(int i = 0 ;i< s.length();i++){\\n            if(s[i] == \\'a\\'){\\n                ans = min(ans+1 , b);                \\n            }\\n            else b++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b = 0 , ans = 0;\\n        for(int i = 0 ;i< s.length();i++){\\n            if(s[i] == \\'a\\'){\\n                ans = min(ans+1 , b);                \\n            }\\n            else b++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540821,
                "title": "simple-python-solution",
                "content": "```\\ndef minimumDeletions(self, st: str) -> int:\\n        bCount = 0\\n        bCarr = []\\n        ln = 0\\n        for item in st:\\n            if item == \\'b\\':\\n                bCount +=1\\n            bCarr.append(bCount)\\n            ln +=1\\n\\n        dl = 0\\n        for i in range(ln):\\n            if st[i] == \\'a\\':\\n                if bCarr[i] - dl > 0:\\n                    dl +=1\\n\\n        return dl\\n```\\n\\n981MS, 17.8MB",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minimumDeletions(self, st: str) -> int:\\n        bCount = 0\\n        bCarr = []\\n        ln = 0\\n        for item in st:\\n            if item == \\'b\\':\\n                bCount +=1\\n            bCarr.append(bCount)\\n            ln +=1\\n\\n        dl = 0\\n        for i in range(ln):\\n            if st[i] == \\'a\\':\\n                if bCarr[i] - dl > 0:\\n                    dl +=1\\n\\n        return dl\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1530385,
                "title": "c-o-n-time-complexity-and-o-1-space-complexity-simple-and-concise-solution",
                "content": "```\\nint minimumDeletions(string s) {\\n        int res=0;\\n        int count_a=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'b\\' and count_a>0)\\n            {\\n                res++;\\n                count_a--;\\n            }\\n            else\\n                {\\n                if(s[i]==\\'a\\') count_a++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(string s) {\\n        int res=0;\\n        int count_a=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'b\\' and count_a>0)\\n            {\\n                res++;\\n                count_a--;\\n            }\\n            else\\n                {\\n                if(s[i]==\\'a\\') count_a++;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527058,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int countB = 0;\\n        int countA = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'b\\')\\n            {\\n                countB++;\\n            }\\n            else\\n            {\\n                countA++;\\n            }\\n            countA = Math.min(countA,countB);\\n        }\\n        return countA;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumDeletions(String s) {\\n        int countB = 0;\\n        int countA = 0;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==\\'b\\')\\n            {\\n                countB++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1459817,
                "title": "simple-c-solutions-same-as-926-flip-string-to-monotone-increasing",
                "content": "This is same as **problem 926(Flip String to Monotone Increasing)** where we need to **flip** 1\\'s or 0\\'s to make string monotone increasing. Here, we need to **delete** a\\'s or b\\'s to make it increasing.\\n**Explanation**: For every index we can store number of b\\'s before that index (**bs in the code**) and keep a variable **del(required deletions)** and increment it when we see a\\'s and for every index find min of del and number of bs.\\n\\n```\\n\\t\\tint bs=0;\\n\\t\\tint del= 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                bs++;\\n            }\\n            else\\n            {\\n                del++;\\n            }\\n            del= min(del, bs);\\n        }\\n        return del;\\n\\t\\t\\n\\t```\\n\\n**Dry run:**\\nex: s= \"aababbab\"\\n(Here we need to delete a\\'s at index 3 and 6 to make s as \"aabbbb\")\\ni=0:\\nbs=0, del=1\\ndel= min(del, bs) =>del=  min(0, 1)=0\\ni=1:\\nbs=0, del=1\\ndel= min(del, bs) =>del=  min(0, 1)=0\\ni=2:\\nbs=1, del=0\\ndel= min(del, bs) =>del=  min(1, 0)=0\\ni=3:\\nbs=1, del=1\\ndel= min(del, bs) =>del=  min(1, 1)=1\\ni=4:\\nbs=2, del=1\\ndel= min(del, bs) =>del=  min(1, 2)=1\\ni=5:\\nbs= 3, del= 1\\ndel= min(del, bs) =>del=  min(1, 3)=1\\ni=6:\\nbs= 3, del=2\\ndel= min(del, bs) =>del=  min(2, 3)=2\\ni=7:\\nbs= 4, del=2\\ndel= min(del, bs) =>del=  min(2, 4)=2\\n\\n(Hope this is clear, pls let me know if anything\\'s not clear)\\n",
                "solutionTags": [],
                "code": "```\\n\\t\\tint bs=0;\\n\\t\\tint del= 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==\\'b\\')\\n            {\\n                bs++;\\n            }\\n            else\\n            {\\n                del++;\\n            }\\n            del= min(del, bs);\\n        }\\n        return del;\\n\\t\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453672,
                "title": "dp-solution-o-n",
                "content": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp(s.size()+1);\\n        int bcount=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                dp[i+1]=min(1+dp[i],bcount);\\n            }\\n            else\\n            {\\n                dp[i+1]=dp[i];\\n                bcount++;\\n            }\\n        }\\n       return dp[s.size()];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int>dp(s.size()+1);\\n        int bcount=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                dp[i+1]=min(1+dp[i],bcount);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1402109,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'a\\') {\\n                b++;\\n            } else {\\n                b = min(a, b);\\n                a++;\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a = 0, b = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'a\\') {\\n                b++;\\n            } else {\\n                b = min(a, b);\\n                a++;\\n            }\\n        }\\n        return min(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395482,
                "title": "c-minimization-maximization-solution-o-n",
                "content": "**Minimization Approach:**\\n\\nThe problem is exactly similar to [926. Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/). Its solution is described [here](https://leetcode.com/problems/flip-string-to-monotone-increasing/discuss/1395348/C++-Solution-O(N)).\\n\\n\\n```\\nHere we have to delete char from string such that there is no i<j and s[j]=a and s[i]=b means we have to\\ndelete chars to make it monotonic increasing from a to b which is same as monotonic increasing of binary\\nstring where a=0 and b=1. Also flipping 0 to 1 and 1 to 0 can be equally considered as a delete operation\\nfor this problem. So, we use the same solution approach of 926. Flip String to Monotone Increasing. \\n```\\n\\nRuntime: 84 ms, faster than 90.98% of C++ online submissions for Minimum Deletions to Make String Balanced.\\nMemory Usage: 22 MB, less than 93.87% of C++ online submissions for Minimum Deletions to Make String Balanced.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n        \\n        //track number of delete \\n        int del = 0;\\n        \\n        // counts prefix bs \\n        int b_c = 0;\\n        \\n        for(int i=0;i<sl;i++)\\n        {\\n            // need to delete when prefix b exists, otherwise ignore\\n            if(s[i]==\\'a\\')\\n            {\\n                if(b_c>0)del++;\\n                else continue;\\n            }\\n            else b_c++; // track prefix 1 count\\n            \\n            // get the minimum between delete and b count\\n            // if delete > b count then it means there is more suffix a then prefix b\\n            del = min(del,b_c);\\n        }\\n        \\n        return del;\\n    }\\n};\\n```\\n\\n**Maximization Approach:**\\n\\n```\\nAnother way to think about this problem is finding the Length of Longest Monotonic Increasing\\nSubsequence. Then the minimum delete will be String Length - Max LMIS. \\n\\nNow as there are only 2 char type in the string we can easily calculate the Max LMIS for ending char\\na and b. Let they are a_c and b_c. Now the LMIS ending with a must contain all previous \\'a\\' char and\\nso we just increment its count. Other hand, Max LMIS ending with b can have previous a chars a_c or \\nprevious Max LMIS of ending with b, b_c and we update b_c as max(a_c,b_c) + 1. The max LMIS will be\\nthe max value between a_c and b_c at last and thus minimum delete will be String Length - Max LMIS.\\n\\nExample : \\n\\nMax LMIS ending with a => \"aaaaaaaa\"\\n\\nMax LMIS ending with b => \"aaaaaaab\"  or \"aaaabbb\" or \"bbbbbbb\"\\n```\\n\\nRuntime: 88 ms, faster than 81.27% of C++ online submissions for Minimum Deletions to Make String Balanced.\\nMemory Usage: 22 MB, less than 75.72% of C++ online submissions for Minimum Deletions to Make String Balanced.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n                \\n        // Length of LMIS ending with a\\n        int a_c = 0;\\n        // Length of LMIS ending with a\\n        int b_c = 0;\\n\\n        // loop through string and find max LMIS ending with a and b\\n        for(int i=0;i<sl;i++)\\n        {\\n            // Max LMIS ending with a can only have previous a element and so we increment its count\\n            if(s[i]==\\'a\\')a_c++;\\n            \\n            // Max LMIS ending with b can have all previous a element or previous Max LMIS ending with b elements\\n            // thus we take the max between those and add the current b\\n            else b_c = max(a_c,b_c) + 1;\\n        }\\n        \\n        // minimum delete => Total length - Max LMIS => String Length - max(a_c,b_c)\\n        return sl-max(a_c,b_c);\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nHere we have to delete char from string such that there is no i<j and s[j]=a and s[i]=b means we have to\\ndelete chars to make it monotonic increasing from a to b which is same as monotonic increasing of binary\\nstring where a=0 and b=1. Also flipping 0 to 1 and 1 to 0 can be equally considered as a delete operation\\nfor this problem. So, we use the same solution approach of 926. Flip String to Monotone Increasing. \\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n        \\n        //track number of delete \\n        int del = 0;\\n        \\n        // counts prefix bs \\n        int b_c = 0;\\n        \\n        for(int i=0;i<sl;i++)\\n        {\\n            // need to delete when prefix b exists, otherwise ignore\\n            if(s[i]==\\'a\\')\\n            {\\n                if(b_c>0)del++;\\n                else continue;\\n            }\\n            else b_c++; // track prefix 1 count\\n            \\n            // get the minimum between delete and b count\\n            // if delete > b count then it means there is more suffix a then prefix b\\n            del = min(del,b_c);\\n        }\\n        \\n        return del;\\n    }\\n};\\n```\n```\\nAnother way to think about this problem is finding the Length of Longest Monotonic Increasing\\nSubsequence. Then the minimum delete will be String Length - Max LMIS. \\n\\nNow as there are only 2 char type in the string we can easily calculate the Max LMIS for ending char\\na and b. Let they are a_c and b_c. Now the LMIS ending with a must contain all previous \\'a\\' char and\\nso we just increment its count. Other hand, Max LMIS ending with b can have previous a chars a_c or \\nprevious Max LMIS of ending with b, b_c and we update b_c as max(a_c,b_c) + 1. The max LMIS will be\\nthe max value between a_c and b_c at last and thus minimum delete will be String Length - Max LMIS.\\n\\nExample : \\n\\nMax LMIS ending with a => \"aaaaaaaa\"\\n\\nMax LMIS ending with b => \"aaaaaaab\"  or \"aaaabbb\" or \"bbbbbbb\"\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        \\n        int sl = s.length();\\n                \\n        // Length of LMIS ending with a\\n        int a_c = 0;\\n        // Length of LMIS ending with a\\n        int b_c = 0;\\n\\n        // loop through string and find max LMIS ending with a and b\\n        for(int i=0;i<sl;i++)\\n        {\\n            // Max LMIS ending with a can only have previous a element and so we increment its count\\n            if(s[i]==\\'a\\')a_c++;\\n            \\n            // Max LMIS ending with b can have all previous a element or previous Max LMIS ending with b elements\\n            // thus we take the max between those and add the current b\\n            else b_c = max(a_c,b_c) + 1;\\n        }\\n        \\n        // minimum delete => Total length - Max LMIS => String Length - max(a_c,b_c)\\n        return sl-max(a_c,b_c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385337,
                "title": "c-simple-intuitive-solution-with-o-1-space",
                "content": "The idea here is to maintain a counter for the number of \\'b\\'.\\nTraversing the string from left to right, when the current character is \\'b\\', simply increment the counter by 1.\\nWhen the current character is \\'a\\', check if the counter is positive. If yes, simply decrement it by 1, and increase the answer by 1.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n     \\n        int ans=0,cb=0,i=0,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && cb>0)\\n            {\\n                cb--;\\n                ans++;\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                cb++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n     \\n        int ans=0,cb=0,i=0,n=s.size();\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\' && cb>0)\\n            {\\n                cb--;\\n                ans++;\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                cb++;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345829,
                "title": "short-c-solution-o-n-time-o-1-space-w-explanation",
                "content": "The resulting string will always be some number of a\\'s then some number of b\\'s\\nSo we know that we need find a split of the string such that the number of b\\'s in the left side + the number of a\\'s on the right side is minimised\\nThis can be done in constant time by first counting how many a\\'s there are in the string then iterate through the string and count the number of a\\'s and b\\'s seen so far. We know the number of a\\'s to the right of the current position is just total number of a\\'s minus current count of a\\'s.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int at = 0, bc = 0, ac = 0;\\n        for(char c : s) if(c == \\'a\\') ++at;\\n        int ans = at;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\') ++ac;\\n            else ++bc;\\n            int dels = bc + (at - ac);\\n            ans = min(ans, dels);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int at = 0, bc = 0, ac = 0;\\n        for(char c : s) if(c == \\'a\\') ++at;\\n        int ans = at;\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'a\\') ++ac;\\n            else ++bc;\\n            int dels = bc + (at - ac);\\n            ans = min(ans, dels);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318797,
                "title": "very-intuitive-two-pointer-python-o-n-time-and-o-1-space-solution",
                "content": "The idea is to use two pointers i and j where i traverses from left to right and j traverses from right to left.\\nWhile traversing right, get to the first position where s[i] == \\'b\\' and similarly while traversing left, get to the first position where s[j] == \\'a\\'. We also keep on adjusting the count of \\'a\\' and \\'b\\' accordingly. Now we reach to a point where s[0:i] is all \\'a\\' and s[j+1:] is all \\'b\\'. At this point we need to decide whether we want to delete \\'a\\' or \\'b\\'. So we go greedy and delete that char whose count is less. So if count_a < count_b, we delete char \\'a\\' else we delete char \\'b\\'.\\n\\n```\\ndef get_a_count(word):\\n    count = 0\\n    for ch in word:\\n        if ch == \\'a\\':\\n            count += 1\\n    return count        \\n    \\n\\ndef get_minimum_deletions(word):\\n    result = 0\\n    i = 0\\n    j = len(word)-1\\n    count_a = get_a_count(word)\\n    count_b = len(word)-count_a\\n    while i < j:\\n\\t    # get to the point where word[i] = \\'b\\'\\n        while i < j and word[i] == \\'a\\':\\n            i += 1\\n            count_a -= 1\\n\\t\\t# get to the point where word[j] = \\'a\\'\\t\\n        while i < j and word[j] == \\'b\\':\\n            j -= 1\\n            count_b -= 1\\n            \\n\\t\\t# we go greedy here and delete that char whose count is less\\n        if count_a != 0 and count_b != 0:\\n            if count_a < count_b:\\n                j -= 1  # simulates deletion of \\'a\\'\\n                result += 1\\n                count_a -= 1\\n            else:\\n                i += 1  # simulates deletion of \\'b\\'\\n                result += 1\\n                count_b -= 1\\n    return result\\n```\\t\\n\\t\\n",
                "solutionTags": [],
                "code": "```\\ndef get_a_count(word):\\n    count = 0\\n    for ch in word:\\n        if ch == \\'a\\':\\n            count += 1\\n    return count        \\n    \\n\\ndef get_minimum_deletions(word):\\n    result = 0\\n    i = 0\\n    j = len(word)-1\\n    count_a = get_a_count(word)\\n    count_b = len(word)-count_a\\n    while i < j:\\n\\t    # get to the point where word[i] = \\'b\\'\\n        while i < j and word[i] == \\'a\\':\\n            i += 1\\n            count_a -= 1\\n\\t\\t# get to the point where word[j] = \\'a\\'\\t\\n        while i < j and word[j] == \\'b\\':\\n            j -= 1\\n            count_b -= 1\\n            \\n\\t\\t# we go greedy here and delete that char whose count is less\\n        if count_a != 0 and count_b != 0:\\n            if count_a < count_b:\\n                j -= 1  # simulates deletion of \\'a\\'\\n                result += 1\\n                count_a -= 1\\n            else:\\n                i += 1  # simulates deletion of \\'b\\'\\n                result += 1\\n                count_b -= 1\\n    return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1087213,
                "title": "dp-python-simplest-constant-space-o-n-solution",
                "content": "Idea: The problem can be converted to longest aaa\\\\*bbbb\\\\* subsequence. \\n- t0 means the longest subsequence ending with a. \\n- t1 means the longest subsequence ending with b.\\nTime complexity is O(N)\\nSpace: O(1)\\n```python\\ndef minimumDeletions(self, s: str) -> int:\\n\\tt0 = t1 = 0\\n\\tfor c in s:\\n\\t\\t# carry the previous status\\n\\t\\tn0, n1 = t0, t1 \\n\\t\\tif c == \\'a\\':\\n\\t\\t\\tn0 = t0 + 1\\n\\t\\telse:\\n\\t\\t\\tn1 = max(t0, t1) + 1\\n\\t\\tt0, t1 = n0, n1\\n\\treturn len(s) - max(t0, t1)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumDeletions(self, s: str) -> int:\\n\\tt0 = t1 = 0\\n\\tfor c in s:\\n\\t\\t# carry the previous status\\n\\t\\tn0, n1 = t0, t1 \\n\\t\\tif c == \\'a\\':\\n\\t\\t\\tn0 = t0 + 1\\n\\t\\telse:\\n\\t\\t\\tn1 = max(t0, t1) + 1\\n\\t\\tt0, t1 = n0, n1\\n\\treturn len(s) - max(t0, t1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1009031,
                "title": "java-greedy-tc-o-n-space-o-1-17ms-faster-thn-99-with-explained-easily",
                "content": "```\\n/* idea is we think of removing a\\'s occruing after b\\'s to make the string balanced ,so we conut the number of a\\'s \\nafter b\\'s , BUT if we see that the count of b is less than count of a uptill now , we remove the b\\'s instead of the \\na\\'s beacuse it costs less .\\nThen just reset both a , b count and continue iterating the string \\nlastly it might happen that count (a) > count (b) never occurs for the entire string or for some part of the \\nstring after some removals , so we add count of a after coming out of the for loop .\\n\\n*/\\n\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0 , b = 0 ,cnt = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'a\\'){\\n                if(b == 0)\\n                    continue ;\\n                a++;\\n                if(a > b){\\n                    cnt += b ;\\n                    b = 0;\\n                    a = 0;\\n                }\\n            }\\n            else\\n                b++;\\n        }\\n        // consider -> baababbaabbaaabaabbabbbabaaaaaabaabababaaababbb\"\\n        // add the cnt of the single a in the index == 43 in the last part becasue a > b never triggers \\n        // if it triggers a will be 0 !\\n        cnt += a; \\n        return cnt ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* idea is we think of removing a\\'s occruing after b\\'s to make the string balanced ,so we conut the number of a\\'s \\nafter b\\'s , BUT if we see that the count of b is less than count of a uptill now , we remove the b\\'s instead of the \\na\\'s beacuse it costs less .\\nThen just reset both a , b count and continue iterating the string \\nlastly it might happen that count (a) > count (b) never occurs for the entire string or for some part of the \\nstring after some removals , so we add count of a after coming out of the for loop .\\n\\n*/\\n\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int a = 0 , b = 0 ,cnt = 0;\\n        for(char c : s.toCharArray()){\\n            if(c == \\'a\\'){\\n                if(b == 0)\\n                    continue ;\\n                a++;\\n                if(a > b){\\n                    cnt += b ;\\n                    b = 0;\\n                    a = 0;\\n                }\\n            }\\n            else\\n                b++;\\n        }\\n        // consider -> baababbaabbaaabaabbabbbabaaaaaabaabababaaababbb\"\\n        // add the cnt of the single a in the index == 43 in the last part becasue a > b never triggers \\n        // if it triggers a will be 0 !\\n        cnt += a; \\n        return cnt ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004397,
                "title": "simplest-c-o-n-without-dp-same-as-monotone-increasing",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b=0,a=0,ans=0;\\n        for(char c:s){\\n            if(c==\\'a\\') a++;\\n        }\\n        ans=a;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'b\\'){\\n                b++;\\n            }\\n            else{\\n                a--;\\n            }\\n            ans=min(ans,a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int b=0,a=0,ans=0;\\n        for(char c:s){\\n            if(c==\\'a\\') a++;\\n        }\\n        ans=a;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'b\\'){\\n                b++;\\n            }\\n            else{\\n                a--;\\n            }\\n            ans=min(ans,a+b);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000047,
                "title": "java-very-easy-to-understand-solution",
                "content": "Question says that there shouldn\\'t be any **b** between **a\\'s sequences** and there shouldn\\'t be any **a** in **b\\'s sequences** and **b\\'s sequences** should be after **a\\'s sequences**.To make the string balance we can try to balance every substring and atlast our string will be balanced.\\n\\n*Intution*\\n1. Loop over the character of s\\n2. If the character is \\'b\\' then we don\\'t need to delete anything.\\n3. Otherwise we have two option.We can delete that character and our delete count increases by 1 or we want to delete every b to get this substring valid.\\n4. Our answer is the minimum of this value.\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int bcnt = 0;\\n        int deleted = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'b\\') bcnt++;\\n            else{\\n                deleted = Math.min(deleted+1,bcnt);\\n            }\\n        }\\n        return deleted;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int bcnt = 0;\\n        int deleted = 0;\\n        for(int i=0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch == \\'b\\') bcnt++;\\n            else{\\n                deleted = Math.min(deleted+1,bcnt);\\n            }\\n        }\\n        return deleted;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 975389,
                "title": "java-solution-using-stack-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n       Stack<Character> st = new Stack<>();\\n       int min_del = 0;\\n       for(char c : s.toCharArray()){\\n         //whenever find \\'b\\' on top of stack and \\'a\\' on string we\\n         //delete both from the stack but we delete only \\'a\\' or \\'b\\' depending\\n         //on the no of b\\'s on the left and the no of a\\'s on the right\\n         //to eliminate b a.\\n         if(!st.isEmpty() && st.peek() == \\'b\\' && c == \\'a\\'){\\n           st.pop();\\n           min_del++;\\n         }else st.push(c);\\n        }\\n       return min_del;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n       Stack<Character> st = new Stack<>();\\n       int min_del = 0;\\n       for(char c : s.toCharArray()){\\n         //whenever find \\'b\\' on top of stack and \\'a\\' on string we\\n         //delete both from the stack but we delete only \\'a\\' or \\'b\\' depending\\n         //on the no of b\\'s on the left and the no of a\\'s on the right\\n         //to eliminate b a.\\n         if(!st.isEmpty() && st.peek() == \\'b\\' && c == \\'a\\'){\\n           st.pop();\\n           min_del++;\\n         }else st.push(c);\\n        }\\n       return min_del;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965912,
                "title": "100-javascript-dp-o-1-space",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s)  {\\n        let a = 0;\\n        let b = 0;\\n        for(let ch of s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = Math.min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return Math.min(a,b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minimumDeletions = function(s)  {\\n        let a = 0;\\n        let b = 0;\\n        for(let ch of s){\\n            if(ch==\\'a\\'){\\n                b = b + 1;\\n                a = a + 0;\\n            }\\n            else{\\n                b = Math.min(b,a);\\n                a = a + 1;\\n            }\\n        }\\n        return Math.min(a,b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955662,
                "title": "java-dp-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int len = s.length();\\n\\t\\t//endA and endB store the number of deletions if the resulting valid string ends with A and B\\n        int endA = 0, endB = 0;\\n        for (int i=0; i<len; i++) {\\n\\t\\t\\t//if current char is a, we need to delete it to make string ending with b valid\\n            if (s.charAt(i) == \\'a\\') {\\n                endB++;\\n            }\\n\\t\\t\\t//if b, we can append it to the string with minimum deletion to make a valid string ending with b\\n            else {\\n                endB = Math.min(endA, endB);\\n                endA++;\\n            }\\n        }\\n        return Math.min(endA, endB);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int len = s.length();\\n\\t\\t//endA and endB store the number of deletions if the resulting valid string ends with A and B\\n        int endA = 0, endB = 0;\\n        for (int i=0; i<len; i++) {\\n\\t\\t\\t//if current char is a, we need to delete it to make string ending with b valid\\n            if (s.charAt(i) == \\'a\\') {\\n                endB++;\\n            }\\n\\t\\t\\t//if b, we can append it to the string with minimum deletion to make a valid string ending with b\\n            else {\\n                endB = Math.min(endA, endB);\\n                endA++;\\n            }\\n        }\\n        return Math.min(endA, endB);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941114,
                "title": "6-line-c-dp-o-n-time-o-1-space-change-the-problem-definition-makes-it-easier",
                "content": "Explain in comments.\\n```\\nint minimumDeletions(string s) {\\n\\t// Change the problem to be: longest accending string you can get\\n\\t// DP: two states\\n\\t//      a: longest string ending with \\'a\\'\\n\\t//      b: longest string ending with \\'b\\'\\n\\t// Iterate through string, if we meet \\'a\\', a++. Otherwise, the string can either be:\\n\\t//      1. previous longest string ending with \\'a\\' plus the current \\'b\\'\\n\\t//      2. previous longest string ending with \\'b\\' plus the current \\'b\\'\\n\\t// The minimun deletion would be length of string minus the longer one ending in either \\'a\\' or \\'b\\'.\\n\\tint a = 0, b = 0;\\n\\tfor (auto c: s) {\\n\\t\\tif (c == \\'a\\') a++;\\n\\t\\telse b = max(a, b) + 1;\\n\\t}\\n\\treturn s.length() - max(a, b);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumDeletions(string s) {\\n\\t// Change the problem to be: longest accending string you can get\\n\\t// DP: two states\\n\\t//      a: longest string ending with \\'a\\'\\n\\t//      b: longest string ending with \\'b\\'\\n\\t// Iterate through string, if we meet \\'a\\', a++. Otherwise, the string can either be:\\n\\t//      1. previous longest string ending with \\'a\\' plus the current \\'b\\'\\n\\t//      2. previous longest string ending with \\'b\\' plus the current \\'b\\'\\n\\t// The minimun deletion would be length of string minus the longer one ending in either \\'a\\' or \\'b\\'.\\n\\tint a = 0, b = 0;\\n\\tfor (auto c: s) {\\n\\t\\tif (c == \\'a\\') a++;\\n\\t\\telse b = max(a, b) + 1;\\n\\t}\\n\\treturn s.length() - max(a, b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939879,
                "title": "java-solution-easy-to-understand-concise-o-3n",
                "content": "```java\\n public int minimumDeletions(String s) {\\n        int[] a = new int[s.length() + 1];\\n        int[] b = new int[s.length() + 1];\\n        for (int i = 0; i < s.length(); i++) {\\n            a[i + 1] = a[i] + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n        }\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            b[i] = b[i + 1] + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n        }\\n        int r = s.length();\\n        for (int i = 0; i < s.length() + 1; i++) {\\n            r = Math.min(r, s.length() - a[i] - b[i]);\\n        }\\n        return r;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public int minimumDeletions(String s) {\\n        int[] a = new int[s.length() + 1];\\n        int[] b = new int[s.length() + 1];\\n        for (int i = 0; i < s.length(); i++) {\\n            a[i + 1] = a[i] + (s.charAt(i) == \\'a\\' ? 1 : 0);\\n        }\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            b[i] = b[i + 1] + (s.charAt(i) == \\'b\\' ? 1 : 0);\\n        }\\n        int r = s.length();\\n        for (int i = 0; i < s.length() + 1; i++) {\\n            r = Math.min(r, s.length() - a[i] - b[i]);\\n        }\\n        return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 939861,
                "title": "o-n-very-simple-idea",
                "content": "Say the final answer begins at position p in the original string. To make position p a valid position, you have to delete all b\\'s before that position and all a\\'s after that position. Now we just iterate over the string and consider each possible position and try to find a p where number of deletions is minimum :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> countA(s.length(), 0);\\n        int cnt = 0;\\n        for(int i = s.length()-1; i >=0 ; i--)\\n        {\\n            countA[i] = cnt;\\n            if(s[i] == \\'a\\')\\n                cnt++;\\n        }\\n        \\n        vector<int> countB(s.length(), 0);    \\n        cnt = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            countB[i] = cnt;\\n            if(s[i] == \\'b\\')\\n                cnt++;\\n        }\\n        \\n        int minDel = s.length();\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            minDel = min(minDel, countB[i]+countA[i]);\\n        }\\n        \\n        return minDel;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> countA(s.length(), 0);\\n        int cnt = 0;\\n        for(int i = s.length()-1; i >=0 ; i--)\\n        {\\n            countA[i] = cnt;\\n            if(s[i] == \\'a\\')\\n                cnt++;\\n        }\\n        \\n        vector<int> countB(s.length(), 0);    \\n        cnt = 0;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            countB[i] = cnt;\\n            if(s[i] == \\'b\\')\\n                cnt++;\\n        }\\n        \\n        int minDel = s.length();\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            minDel = min(minDel, countB[i]+countA[i]);\\n        }\\n        \\n        return minDel;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939204,
                "title": "runtime-beats-98-93-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n =s.size()-1,a = 0,res = 0;\\n        \\n        for(int i=n;i>=0;i--)\\n            if(s[i] == \\'a\\') a++;\\n            else if( s[i] == \\'b\\'&& a > 0) a--,res ++;\\n        \\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int n =s.size()-1,a = 0,res = 0;\\n        \\n        for(int i=n;i>=0;i--)\\n            if(s[i] == \\'a\\') a++;\\n            else if( s[i] == \\'b\\'&& a > 0) a--,res ++;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936487,
                "title": "min-deletions-of-left-b-and-right-a",
                "content": "```\\n    fun minimumDeletions(s: String): Int {\\n        val N = s.length\\n        var (la, lb) = 0 to 0\\n        var ra = s.count { it == \\'a\\' }\\n        var rb = N - ra\\n        var ans = ra  \\n        for (ch in s) {\\n            if (ch == \\'a\\') {\\n                la += 1\\n                ra -= 1\\n            } else {\\n                lb += 1\\n                rb -= 1\\n            }\\n            ans = minOf(ans, lb + ra)\\n        }\\n        return ans\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun minimumDeletions(s: String): Int {\\n        val N = s.length\\n        var (la, lb) = 0 to 0\\n        var ra = s.count { it == \\'a\\' }\\n        var rb = N - ra\\n        var ans = ra  \\n        for (ch in s) {\\n            if (ch == \\'a\\') {\\n                la += 1\\n                ra -= 1\\n            } else {\\n                lb += 1\\n                rb -= 1\\n            }\\n            ans = minOf(ans, lb + ra)\\n        }\\n        return ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936468,
                "title": "swift-clean-code-o-n-time-o-1-space",
                "content": "result = length(s) - length of the valid longest subsequence\\n```\\nclass Solution {\\n    func minimumDeletions(_ s: String) -> Int {\\n        let n = s.count\\n        // maxA is the length of the longest subsequence end with \"a\" \\n        var maxA = 0\\n        // maxB is the length of the longest subsequence end with \"b\" \\n        var maxB = 0\\n        for c in s {\\n            if c == \"a\" {\\n                maxA += 1\\n            } else {\\n                maxB = max(maxA, maxB) + 1\\n            }\\n        }\\n        return n - max(maxA, maxB)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumDeletions(_ s: String) -> Int {\\n        let n = s.count\\n        // maxA is the length of the longest subsequence end with \"a\" \\n        var maxA = 0\\n        // maxB is the length of the longest subsequence end with \"b\" \\n        var maxB = 0\\n        for c in s {\\n            if c == \"a\" {\\n                maxA += 1\\n            } else {\\n                maxB = max(maxA, maxB) + 1\\n            }\\n        }\\n        return n - max(maxA, maxB)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936240,
                "title": "minimum-deletions-to-make-string-balanced",
                "content": "Minimum Deletions to Make String Balanced\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n       int n=s.size();\\n       int  pre[100005]={0},suff[100005]={0};\\n        \\n       pre[0]=0; \\n       for(int i=0;i<n;i++){\\n           pre[i+1]=pre[i];\\n           if(s[i]==\\'b\\'){\\n               pre[i+1]++;\\n           }\\n       }\\n        \\n       suff[n]=0;\\n       for(int i=n-1;i>=0;i--){\\n           suff[i]=suff[i+1];\\n           if(s[i]==\\'a\\'){\\n               suff[i]++;\\n           }\\n       }\\n        \\n    \\n        int ans=1e9;\\n        for(int i=0;i<=s.size();i++)\\n             ans=min(ans,pre[i]+suff[i]);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n       int n=s.size();\\n       int  pre[100005]={0},suff[100005]={0};\\n        \\n       pre[0]=0; \\n       for(int i=0;i<n;i++){\\n           pre[i+1]=pre[i];\\n           if(s[i]==\\'b\\'){\\n               pre[i+1]++;\\n           }\\n       }\\n        \\n       suff[n]=0;\\n       for(int i=n-1;i>=0;i--){\\n           suff[i]=suff[i+1];\\n           if(s[i]==\\'a\\'){\\n               suff[i]++;\\n           }\\n       }\\n        \\n    \\n        int ans=1e9;\\n        for(int i=0;i<=s.size();i++)\\n             ans=min(ans,pre[i]+suff[i]);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935797,
                "title": "java-count-the-number-of-a-s-and-b-s-left-and-right",
                "content": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int cntA = 0;\\n        int cntB = 0;\\n        int[] leftA = new int[n];\\n        int[] leftB = new int[n];\\n        int[] rightA = new int[n];\\n        int[] rightB = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            leftA[i] = cntA;\\n            leftB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        cntA = cntB = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightA[i] = cntA;\\n            rightB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        int min = n;\\n        for (int i = 0; i < n; i++) {\\n            min = Math.min(min, leftB[i] + rightA[i]);\\n            if (s.charAt(i) == \\'a\\') {\\n                min = Math.min(min, leftB[i] + rightB[i]);\\n                min = Math.min(min, leftA[i] + rightA[i] + 1);\\n            }\\n            if (s.charAt(i) == \\'b\\') {\\n                min = Math.min(min, leftA[i] + rightA[i]);\\n                min = Math.min(min, leftB[i] + rightB[i] + 1);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int cntA = 0;\\n        int cntB = 0;\\n        int[] leftA = new int[n];\\n        int[] leftB = new int[n];\\n        int[] rightA = new int[n];\\n        int[] rightB = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            leftA[i] = cntA;\\n            leftB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        cntA = cntB = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightA[i] = cntA;\\n            rightB[i] = cntB;\\n            cntA += s.charAt(i) == \\'a\\' ? 1 : 0;\\n            cntB += s.charAt(i) == \\'b\\' ? 1 : 0;\\n        }\\n        int min = n;\\n        for (int i = 0; i < n; i++) {\\n            min = Math.min(min, leftB[i] + rightA[i]);\\n            if (s.charAt(i) == \\'a\\') {\\n                min = Math.min(min, leftB[i] + rightB[i]);\\n                min = Math.min(min, leftA[i] + rightA[i] + 1);\\n            }\\n            if (s.charAt(i) == \\'b\\') {\\n                min = Math.min(min, leftA[i] + rightA[i]);\\n                min = Math.min(min, leftB[i] + rightB[i] + 1);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935691,
                "title": "java-simple-o-n-dp-solution-beats-100-time-and-space",
                "content": "dp[i] == Number of deletions to balance `str[0, i]`. Also `dp[0] == 0` since it\\'s balanced.\\nNow if we see an `a` then we have two choices\\n\\t- Delete the `a` in which case total steps will be `dp[i-1]+1`\\n\\t- Keep the `a` and delete all preceding `b`, in which case dp[i] = `total b count so far`\\n\\t- We pick the min of the above two\\nIf we see a `b` then nothing needs to be done as `b` at end is legit. We just update counter for number of seen `b`.\\nWe can make it work with no additional space by just tracking the total deletions so far.\\n\\nTime `O(N)`\\nSpace `O(1)`\\n\\n\\n\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int totDel = 0, totB = s.charAt(0) == \\'b\\' ? 1 : 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                totDel = Math.min(totDel+1, totB);\\n            } else {\\n                totB++;\\n            }\\n        }\\n        return totDel;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int totDel = 0, totB = s.charAt(0) == \\'b\\' ? 1 : 0;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'a\\') {\\n                totDel = Math.min(totDel+1, totB);\\n            } else {\\n                totB++;\\n            }\\n        }\\n        return totDel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935555,
                "title": "easy-c-100-better-in-time-and-100-better-in-space",
                "content": "\\'\\'\\'\\n\\npublic int MinimumDeletions(string s) {\\n        \\n        if(s.Length == 0) {\\n            return 0;\\n        }\\n        var minDeletes = s.Length;\\n        var deletes = new int[s.Length];\\n        var bCounts = 0;\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            deletes[i] = bCounts;\\n            if(s[i] == \\'b\\') {\\n                 bCounts++;\\n            }\\n        }\\n        \\n        var aCounts = 0;\\n        for(var i = s.Length-1; i >= 0; i--)\\n        {\\n             \\n            deletes[i] += aCounts;\\n            minDeletes = Math.Min(minDeletes,deletes[i]);\\n            if(s[i] == \\'a\\') {\\n                aCounts++;\\n             }\\n             \\n        }\\n        return minDeletes;\\n    }",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\npublic int MinimumDeletions(string s) {\\n        \\n        if(s.Length == 0) {\\n            return 0;\\n        }\\n        var minDeletes = s.Length;\\n        var deletes = new int[s.Length];\\n        var bCounts = 0;\\n        for(var i = 0; i < s.Length; i++)\\n        {\\n            deletes[i] = bCounts;\\n            if(s[i] == \\'b\\') {\\n                 bCounts++;\\n            }\\n        }\\n        \\n        var aCounts = 0;\\n        for(var i = s.Length-1; i >= 0; i--)\\n        {\\n             \\n            deletes[i] += aCounts;\\n            minDeletes = Math.Min(minDeletes,deletes[i]);\\n            if(s[i] == \\'a\\') {\\n                aCounts++;\\n             }\\n             \\n        }\\n        return minDeletes;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 935488,
                "title": "simple-python3-time-o-n-space-o-n",
                "content": "1. Counting all \"b\" from left to right, storing in array A.\\n2. Counting all \"a\" from right to left, storing is not needed\\n3. stored value in array A plus actual value of \"b\\' is number of deletions, if the point of \"...ab...\" is here\\n\\n\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        m=len(s)\\n        if m<2: return 0\\n        \\n        A=[0]*m\\n        L=0\\n        b=0 # counting \"b\" from left\\n        while L<m:\\n            b+=s[L]==\\'b\\'\\n            A[L]=b\\n            L+=1\\n        \\n        minDel=b\\n        R=m-1\\n        a=0 # counting \"a\" from right\\n        while 0<=R:\\n            a+=s[R]==\\'a\\'\\n            minDel=min(minDel,A[R-1]+a)\\n            R-=1 \\n            \\n        return min(minDel,a) \\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        m=len(s)\\n        if m<2: return 0\\n        \\n        A=[0]*m\\n        L=0\\n        b=0 # counting \"b\" from left\\n        while L<m:\\n            b+=s[L]==\\'b\\'\\n            A[L]=b\\n            L+=1\\n        \\n        minDel=b\\n        R=m-1\\n        a=0 # counting \"a\" from right\\n        while 0<=R:\\n            a+=s[R]==\\'a\\'\\n            minDel=min(minDel,A[R-1]+a)\\n            R-=1 \\n            \\n        return min(minDel,a) \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 935418,
                "title": "easy-dp-c-explained-o-n-t-c",
                "content": "***Note : Random people downvote without even reading, do read and if helps dont atleast downvote, Thank You.***\\n***Note: Always welcome for optimisations, changes and advices.***\\n\\n***Intiution***\\n 1) Keep counting the number of encountered \\'b\\', uptill current index.\\n 2) If the current element is \\'b\\' , increse the count, and solution uptill current index will be same as of previous.\\n 3) If the element is an \\'a\\'. two case arise either previous encountered number of \\'b\\' is zero then solution upto current index is same as upto previous, else it will be the minimum of previous solution + 1 and deleting the previously encountered \\'b\\' uptill now.\\n \\n\\n```\\n\\nclass Solution \\n{\\npublic:\\n    int minimumDeletions(string s)\\n    {\\n        int no_of_b = 0;\\n        vector<int> dp( s.length(), 0 );\\n        \\n        no_of_b += ( s[0] == \\'b\\' ) ? 1 : 0;\\n        \\n        for( int i = 1; i<s.length(); i++ )\\n        {\\n            if( s[i] == \\'b\\' )\\n            {\\n                no_of_b++;\\n                dp[i] = dp[i-1];\\n            }\\n            else\\n            {\\n                if( no_of_b == 0 ) dp[i] = dp[i-1];\\n                else dp[i] = min( dp[i-1] + 1, no_of_b );\\n            }\\n        }\\n        \\n        return dp[s.length()-1];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution \\n{\\npublic:\\n    int minimumDeletions(string s)\\n    {\\n        int no_of_b = 0;\\n        vector<int> dp( s.length(), 0 );\\n        \\n        no_of_b += ( s[0] == \\'b\\' ) ? 1 : 0;\\n        \\n        for( int i = 1; i<s.length(); i++ )\\n        {\\n            if( s[i] == \\'b\\' )\\n            {\\n                no_of_b++;\\n                dp[i] = dp[i-1];\\n            }\\n            else\\n            {\\n                if( no_of_b == 0 ) dp[i] = dp[i-1];\\n                else dp[i] = min( dp[i-1] + 1, no_of_b );\\n            }\\n        }\\n        \\n        return dp[s.length()-1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935416,
                "title": "python-variant-of-the-longest-increasing-subsequence",
                "content": "```\\nclass Solution(object):\\n    def minimumDeletions(self, s):\\n        dp = []\\n        for c in s:\\n            if c == \\'b\\':\\n                dp += c,\\n            else:\\n                if not dp:\\n                    dp += c,\\n                else:\\n                    if dp[-1] == \\'a\\':\\n                        dp += c,\\n                    else:\\n                        idx = bisect_right(dp, c)\\n                        dp[idx] = c\\n        return len(s) - len(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minimumDeletions(self, s):\\n        dp = []\\n        for c in s:\\n            if c == \\'b\\':\\n                dp += c,\\n            else:\\n                if not dp:\\n                    dp += c,\\n                else:\\n                    if dp[-1] == \\'a\\':\\n                        dp += c,\\n                    else:\\n                        idx = bisect_right(dp, c)\\n                        dp[idx] = c\\n        return len(s) - len(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935411,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> a;\\n        int n = s.size();\\n        if(s.size() == 1){\\n            return 0;\\n        }\\n        a.push_back(0);\\n        if(s[0] == \\'a\\')\\n            a[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            a.push_back(a[i - 1]);\\n            if(s[i] == \\'a\\'){\\n                a[i] ++;\\n            }\\n        }\\n        if(s.size() - a.back() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = INT_MAX;\\n        int local;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                local = i - a[i] + a.back() - a[i];\\n                ans = min(ans, local);\\n            }\\n            \\n            \\n        }\\n        local = s.size() - a.back();\\n        ans = min(ans, local);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        vector<int> a;\\n        int n = s.size();\\n        if(s.size() == 1){\\n            return 0;\\n        }\\n        a.push_back(0);\\n        if(s[0] == \\'a\\')\\n            a[0] = 1;\\n        for(int i = 1; i < n; i++){\\n            a.push_back(a[i - 1]);\\n            if(s[i] == \\'a\\'){\\n                a[i] ++;\\n            }\\n        }\\n        if(s.size() - a.back() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = INT_MAX;\\n        int local;\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                local = i - a[i] + a.back() - a[i];\\n                ans = min(ans, local);\\n            }\\n            \\n            \\n        }\\n        local = s.size() - a.back();\\n        ans = min(ans, local);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083281,
                "title": "easy-to-understand-javascript-solution-dp",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nvar minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumDeletions = function(s) {\\n    let a = b = 0;\\n\\n    for (const char of s) {\\n        char === \\'a\\'\\n            ? b = Math.min(a, b + 1)\\n            : a += 1;\\n    }\\n    return Math.min(a, b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039498,
                "title": "most-easiest-solution-using-stack-must-see-too-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                st.push(\\'b\\');\\n            }\\n\\n            else if(s[i] == \\'a\\'){\\n                if(st.size() != 0){\\n                    if(st.top() == \\'b\\'){\\n                        st.pop();\\n                        count++;\\n                    }\\n                }\\n\\n                else{\\n                    st.push(\\'a\\');\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        stack<char> st;\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'b\\'){\\n                st.push(\\'b\\');\\n            }\\n\\n            else if(s[i] == \\'a\\'){\\n                if(st.size() != 0){\\n                    if(st.top() == \\'b\\'){\\n                        st.pop();\\n                        count++;\\n                    }\\n                }\\n\\n                else{\\n                    st.push(\\'a\\');\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005377,
                "title": "c-simple-solution-tc-o-n-sc-o-1-explanation",
                "content": "# EXPLANATION \\nAt first we count the number of **\\'a\\'** present in string and store in **a**.\\nThen again traverse in string **s**.\\nIf that char is \\'a\\' then we decrease count of **a** and do **ans=min(ans,a+b)**.\\nElse, then we do **ans=min(ans,a+b)** and increase the count of \\'b\\' in **b**.\\nOur idea is that if current is \\'a\\' then we count the number of \\'b\\' in left of it and the number of \\'a\\' on right of it.\\nElse if that current is \\'b\\' then we count the number of \\'a\\' on right and \\'b\\' on left.\\nFinally return the minimum of it and return as **ans**.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ans=INT_MAX;\\n        for(auto x:s)\\n            if(x==\\'a\\')\\n                a++;\\n        for(auto x:s){\\n            if(x==\\'a\\'){\\n                a--;\\n                ans=min(ans,a+b);\\n            }\\n            else{\\n                ans=min(ans,b+a);\\n                b++;\\n            }\\n        }\\n        ans=(ans==INT_MAX)?0:ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int a=0,b=0,ans=INT_MAX;\\n        for(auto x:s)\\n            if(x==\\'a\\')\\n                a++;\\n        for(auto x:s){\\n            if(x==\\'a\\'){\\n                a--;\\n                ans=min(ans,a+b);\\n            }\\n            else{\\n                ans=min(ans,b+a);\\n                b++;\\n            }\\n        }\\n        ans=(ans==INT_MAX)?0:ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002666,
                "title": "without-using-any-extra-space-and-without-using-dp-and-stack-here-is-my-o-n-time-and-o-1-space",
                "content": "# Intuition\\n  **Have a look at the below image :** \\n\\n![leetcode.jpg](https://assets.leetcode.com/users/images/18eea307-3a95-4dde-b808-9fded7848a88_1693852109.88309.jpeg)\\n\\nJust a simple approach man as we know that we don\\'t want that our string consist of \\'a\\' character after the \\'b\\' character and we can keep track of this thing from the back of the string because in the beginning we don\\'t know after \\'b\\' how many \\'a\\' were there and before \\'a\\' how many \\'b\\' were there and we don\\'t know whether we will get the minimum deletions at the left end or right hand but at the same time we can keep track of \"ba\" from the end in an easy manner.\\n\\nJust we need to keep the count of \\'a\\' character and as soon as we got the \\'b\\' character then simply we will check if the count of \\'a\\' is greater than 0 and if it that means we need to delete either \\'a\\' or \\'b\\' which will take 1 deletion operation only so in such cases we will increment our answer by 1 and will decrement the count of \\'a\\' by 1 because we have already deleted it.\\n\\nAt the end we will simply return our answer variable which will contains the required answer.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int ans=0,a=0;\\n        for(int i=n-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch==\\'a\\') a++;\\n            else if(ch==\\'b\\' && a!=0){\\n                ans+=1;\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# **If you find this helpful then please upvote me :)**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int n = s.length();\\n        int ans=0,a=0;\\n        for(int i=n-1;i>=0;i--){\\n            char ch = s.charAt(i);\\n            if(ch==\\'a\\') a++;\\n            else if(ch==\\'b\\' && a!=0){\\n                ans+=1;\\n                a--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998778,
                "title": "o-n-o-1-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        // stack<char> st;\\n        // int cnt=0;\\n        // for(auto ch:s)\\n        // {\\n        //     if(ch==\\'b\\')\\n        //     st.push(\\'b\\');\\n        //     if(ch==\\'a\\' && !st.empty())\\n        //     {\\n        //         st.pop();\\n        //         cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n        int cnt=0;\\n        int cntB=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'b\\')\\n            cntB++;\\n            else if(ch==\\'a\\' && cntB)\\n            {\\n                cntB--;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        // stack<char> st;\\n        // int cnt=0;\\n        // for(auto ch:s)\\n        // {\\n        //     if(ch==\\'b\\')\\n        //     st.push(\\'b\\');\\n        //     if(ch==\\'a\\' && !st.empty())\\n        //     {\\n        //         st.pop();\\n        //         cnt++;\\n        //     }\\n        // }\\n        // return cnt;\\n        int cnt=0;\\n        int cntB=0;\\n        for(auto ch:s)\\n        {\\n            if(ch==\\'b\\')\\n            cntB++;\\n            else if(ch==\\'a\\' && cntB)\\n            {\\n                cntB--;\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981945,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int totalA = 0, totalB = 0;\\n        for(char c:s) {\\n            if(c ==\\'a\\'){\\n                totalA++;\\n            } else {\\n                totalB++;\\n            }\\n        }\\n        int min = std::min(totalA, totalB), pastA=0, pastB=0;\\n        for(int pos =1; pos<s.size(); pos++) {\\n            if(s[pos-1]==\\'a\\'){\\n                pastA++;\\n            } else {\\n                pastB++;\\n            }\\n            if(s[pos-1]==\\'a\\'&&s[pos]==\\'b\\') {\\n                int del = totalA-pastA + pastB;\\n                if(del<min){min = del;}\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) {\\n        int totalA = 0, totalB = 0;\\n        for(char c:s) {\\n            if(c ==\\'a\\'){\\n                totalA++;\\n            } else {\\n                totalB++;\\n            }\\n        }\\n        int min = std::min(totalA, totalB), pastA=0, pastB=0;\\n        for(int pos =1; pos<s.size(); pos++) {\\n            if(s[pos-1]==\\'a\\'){\\n                pastA++;\\n            } else {\\n                pastB++;\\n            }\\n            if(s[pos-1]==\\'a\\'&&s[pos]==\\'b\\') {\\n                int del = totalA-pastA + pastB;\\n                if(del<min){min = del;}\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971463,
                "title": "minimum-deletions-to-make-string-valid-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        int len = s.length();\\n         \\n        Stack<Character> st = new Stack<Character>(); \\n         if (s == null || s.isEmpty()) return 0;\\n\\n        for( int i = 0 ; i < len ; i++){\\n          char c  = s.charAt(i);\\n\\n         if(!st.isEmpty() && c == \\'a\\'){\\n             st.pop();\\n             count++;\\n         }\\n         if(c == \\'b\\'){\\n             st.push(c);\\n          }\\n        }  \\n         return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumDeletions(String s) {\\n        int count = 0;\\n        int len = s.length();\\n         \\n        Stack<Character> st = new Stack<Character>(); \\n         if (s == null || s.isEmpty()) return 0;\\n\\n        for( int i = 0 ; i < len ; i++){\\n          char c  = s.charAt(i);\\n\\n         if(!st.isEmpty() && c == \\'a\\'){\\n             st.pop();\\n             count++;\\n         }\\n         if(c == \\'b\\'){\\n             st.push(c);\\n          }\\n        }  \\n         return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958486,
                "title": "simple-python3-solution-92-47-simple-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution is to count the occurrences of \\'a\\' and \\'b\\' characters and use these counts to determine the minimum number of deletions needed to balance the string. We can match \\'a\\' characters with \\'b\\' characters to create pairs and eliminate the need for deletions. The goal is to minimize the total number of deletions required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two variables a_count and b_count to keep track of the counts of \\'a\\' and \\'b\\' characters encountered in the string, and another variable total_deletions to track the total number of deletions needed.\\n\\n2. Iterate through each character c in the input string s:\\n\\n- If c is \\'a\\':\\n\\n    - If there are \\'b\\' characters encountered before (b_count > 0), it means we can form a balanced pair by matching this \\'a\\' with a \\'b\\', so decrement b_count and increment total_deletions by 1.\\n    - Otherwise, increment a_count by 1, indicating that we\\'ve encountered an \\'a\\' character.\\n\\n- If c is \\'b\\':\\n\\n    - Increment b_count by 1, indicating that we\\'ve encountered a \\'b\\' character.\\n\\n3. After processing all characters, the total_deletions will represent the minimum number of deletions needed to make the string balanced\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\nBeats 85.96%of users with Python3\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\nBeats 92.47%of users with Python3\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count_a = 0\\n        count_b = 0\\n        min_deleted = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"a\":\\n                if count_b >0:\\n                    count_b-=1\\n                    min_deleted+=1\\n                else:\\n                    count_a += 1\\n            elif s[i] == \"b\":\\n                count_b +=1\\n\\n        return min_deleted\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        count_a = 0\\n        count_b = 0\\n        min_deleted = 0\\n\\n        for i in range(len(s)):\\n            if s[i] == \"a\":\\n                if count_b >0:\\n                    count_b-=1\\n                    min_deleted+=1\\n                else:\\n                    count_a += 1\\n            elif s[i] == \"b\":\\n                count_b +=1\\n\\n        return min_deleted\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958325,
                "title": "c-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n            int countb=0;\\n            int ans=0;\\n            for(auto i:s)\\n            {\\n                if(i==\\'b\\')\\n                countb++;\\n                if(i==\\'a\\' && countb>0)\\n                {\\n                    ans++;\\n                    countb--;\\n                }\\n            }\\n        return ans;\\n    }  \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumDeletions(string s) \\n    {\\n            int countb=0;\\n            int ans=0;\\n            for(auto i:s)\\n            {\\n                if(i==\\'b\\')\\n                countb++;\\n                if(i==\\'a\\' && countb>0)\\n                {\\n                    ans++;\\n                    countb--;\\n                }\\n            }\\n        return ans;\\n    }  \\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1895764,
                "content": [
                    {
                        "username": "Aayush65",
                        "content": "Can anybody tell me why is this giving TLE, when that same (61st test case) is running in 300ms when run in the console.\\nCode:\\n```\\nclass Solution:\\n    def minimumDeletions(self, s: str) -> int:\\n        \\n        memo = {}\\n        def dp(l: int, r: int) -> int:\\n            if (l, r) in memo:\\n                return memo[(l, r)]\\n            key = (l, r)\\n            while l < r and s[l] == \\'a\\':\\n                l += 1\\n            while r > l and s[r] == \\'b\\':\\n                r -= 1\\n            if l == r:\\n                return 0\\n            res = 1 + min(dp(l + 1, r), dp(l, r - 1))\\n            memo[key] = res\\n            return res\\n            \\n        return dp(0, len(s) - 1)\\n```"
                    },
                    {
                        "username": "vishalgunawad",
                        "content": "what is the (61st test case) ?"
                    }
                ]
            }
        ]
    }
]