[
    {
        "title": "Merge Intervals",
        "question_content": "Given an array&nbsp;of intervals&nbsp;where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\n&nbsp;\nConstraints:\n\n\t1 <= intervals.length <= 104\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 104",
        "solutions": [
            {
                "id": 21222,
                "title": "a-simple-java-solution",
                "content": "The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous \"extended\" interval and start over.\\n\\nSorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)).\\n\\nI used a lambda comparator (Java 8) and a for-each loop to try to keep the code clean and simple.\\n\\nEDIT: The function signature changed in april 2019.\\nHere is a new version of the algorithm with arrays. To make more memory efficient, I reused the initial array (sort of \"in-place\") but it would be easy to create new subarrays if you wanted to keep the initial data.\\nIt takes less memory than 99% of the other solutions (sometimes 90% depending on the run) and is more than 10 times faster than the previous version with lists.\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] merge(int[][] intervals) {\\n\\t\\t\\tif (intervals.length <= 1)\\n\\t\\t\\t\\treturn intervals;\\n\\n\\t\\t\\t// Sort by ascending starting point\\n\\t\\t\\tArrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tint[] newInterval = intervals[0];\\n\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif (interval[0] <= newInterval[1]) // Overlapping intervals, move the end if needed\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\telse {                             // Disjoint intervals, add the new interval to the list\\n\\t\\t\\t\\t\\tnewInterval = interval;\\n\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t\\t}\\n\\t}\\n\\nPrevious version with lists.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n        if (intervals.size() <= 1)\\n            return intervals;\\n        \\n        // Sort by ascending starting point using an anonymous Comparator\\n        intervals.sort((i1, i2) -> Integer.compare(i1.start, i2.start));\\n        \\n        List<Interval> result = new LinkedList<Interval>();\\n        int start = intervals.get(0).start;\\n        int end = intervals.get(0).end;\\n        \\n        for (Interval interval : intervals) {\\n            if (interval.start <= end) // Overlapping intervals, move the end if needed\\n                end = Math.max(end, interval.end);\\n            else {                     // Disjoint intervals, add the previous one and reset bounds\\n                result.add(new Interval(start, end));\\n                start = interval.start;\\n                end = interval.end;\\n            }\\n        }\\n        \\n        // Add the last interval\\n        result.add(new Interval(start, end));\\n        return result;\\n    }\\n\\nEDIT: Updated with Java 8 lambda comparator.\\nEDIT 25/05/2019: Updated for new method signature.",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] merge(int[][] intervals) {\\n\\t\\t\\tif (intervals.length <= 1)\\n\\t\\t\\t\\treturn intervals;\\n\\n\\t\\t\\t// Sort by ascending starting point\\n\\t\\t\\tArrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tint[] newInterval = intervals[0];\\n\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif (interval[0] <= newInterval[1]) // Overlapping intervals, move the end if needed\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\telse {                             // Disjoint intervals, add the new interval to the list\\n\\t\\t\\t\\t\\tnewInterval = interval;\\n\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 21227,
                "title": "7-lines-easy-python",
                "content": "Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don't.\\n\\n    def merge(self, intervals):\\n        out = []\\n        for i in sorted(intervals, key=lambda i: i.start):\\n            if out and i.start <= out[-1].end:\\n                out[-1].end = max(out[-1].end, i.end)\\n            else:\\n                out += i,\\n        return out",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don't.\\n\\n    def merge(self, intervals):\\n        out = []\\n        for i in sorted(intervals, key=lambda i: i.start):\\n            if out and i.start <= out[-1].end:\\n                out[-1].end = max(out[-1].end, i.end)\\n            else:\\n                out += i,\\n        return out",
                "codeTag": "Python3"
            },
            {
                "id": 3161191,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n      if(intervals.size()==1)\\n         return intervals;\\n      vector<pair<int,int>> p;\\n      for(int i=0;i<intervals.size();i++)\\n      {\\n          p.push_back({intervals[i][0],intervals[i][1]});\\n      } \\n      sort(p.begin(),p.end());\\n\\n      vector<vector<int>> ans;\\n      int f=p[0].first,s=p[0].second;\\n      for(int i=0;i<p.size()-1;i++)\\n      {\\n          vector<int> a(2);\\n          if(s>=p[i+1].first)\\n          {\\n              s=max(s,p[i+1].second);\\n          }\\n          else\\n          {\\n              a[0]=f;\\n              a[1]=s;\\n              f=p[i+1].first;\\n              s=p[i+1].second;\\n              ans.push_back(a);\\n          }\\n      } \\n      int n=intervals.size();\\n      ans.push_back({f,s});\\n      return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x: x [0])\\n\\n        ans = []\\n\\n        for interval in intervals:\\n            if not ans or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        \\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tmin = Math.min(min, intervals[i][0]);\\n\\t\\t\\tmax = Math.max(max, intervals[i][0]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] range = new int[max - min + 1];\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\trange[intervals[i][0] - min] = Math.max(intervals[i][1] - min, range[intervals[i][0] - min]); \\n\\t\\t}\\n\\t\\t\\n\\t\\tint start = 0, end = 0;\\n\\t\\tLinkedList<int[]> result = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < range.length; i++) {\\n\\t\\t\\tif (range[i] == 0) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (i <= end) {\\n\\t\\t\\t\\tend = Math.max(range[i], end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = range[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n      if(intervals.size()==1)\\n         return intervals;\\n      vector<pair<int,int>> p;\\n      for(int i=0;i<intervals.size();i++)\\n      {\\n          p.push_back({intervals[i][0],intervals[i][1]});\\n      } \\n      sort(p.begin(),p.end());\\n\\n      vector<vector<int>> ans;\\n      int f=p[0].first,s=p[0].second;\\n      for(int i=0;i<p.size()-1;i++)\\n      {\\n          vector<int> a(2);\\n          if(s>=p[i+1].first)\\n          {\\n              s=max(s,p[i+1].second);\\n          }\\n          else\\n          {\\n              a[0]=f;\\n              a[1]=s;\\n              f=p[i+1].first;\\n              s=p[i+1].second;\\n              ans.push_back(a);\\n          }\\n      } \\n      int n=intervals.size();\\n      ans.push_back({f,s});\\n      return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x: x [0])\\n\\n        ans = []\\n\\n        for interval in intervals:\\n            if not ans or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        \\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tmin = Math.min(min, intervals[i][0]);\\n\\t\\t\\tmax = Math.max(max, intervals[i][0]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] range = new int[max - min + 1];\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\trange[intervals[i][0] - min] = Math.max(intervals[i][1] - min, range[intervals[i][0] - min]); \\n\\t\\t}\\n\\t\\t\\n\\t\\tint start = 0, end = 0;\\n\\t\\tLinkedList<int[]> result = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < range.length; i++) {\\n\\t\\t\\tif (range[i] == 0) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (i <= end) {\\n\\t\\t\\t\\tend = Math.max(range[i], end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = range[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21242,
                "title": "c-10-line-solution-easing-understanding",
                "content": "    vector<Interval> merge(vector<Interval>& ins) {\\n        if (ins.empty()) return vector<Interval>{};\\n        vector<Interval> res;\\n        sort(ins.begin(), ins.end(), [](Interval a, Interval b){return a.start < b.start;});\\n        res.push_back(ins[0]);\\n        for (int i = 1; i < ins.size(); i++) {\\n            if (res.back().end < ins[i].start) res.push_back(ins[i]);\\n            else\\n                res.back().end = max(res.back().end, ins[i].end);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<Interval> merge(vector<Interval>& ins) {\\n        if (ins.empty()) return vector<Interval>{};\\n        vector<Interval> res;\\n        sort(ins.begin(), ins.end(), [](Interval a, Interval b){return a.start < b.start;});\\n        res.push_back(ins[0]);\\n        for (int i = 1; i < ins.size(); i++) {\\n            if (res.back().end < ins[i].start) res.push_back(ins[i]);\\n            else\\n                res.back().end = max(res.back().end, ins[i].end);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 482195,
                "title": "c-9-lines-99-run-time-easy-to-understand-solution",
                "content": "```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]) output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            else output.push_back(intervals[i]); \\n        }\\n        return output;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]) output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            else output.push_back(intervals[i]); \\n        }\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21223,
                "title": "beat-98-java-sort-start-end-respectively",
                "content": "  The idea is that for the result distinct Interval, the latter one's start must > previous one's end.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\t// sort start&end\\n\\t\\tint n = intervals.size();\\n\\t\\tint[] starts = new int[n];\\n\\t\\tint[] ends = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tstarts[i] = intervals.get(i).start;\\n\\t\\t\\tends[i] = intervals.get(i).end;\\n\\t\\t}\\n\\t\\tArrays.sort(starts);\\n\\t\\tArrays.sort(ends);\\n\\t\\t// loop through\\n\\t\\tList<Interval> res = new ArrayList<Interval>();\\n\\t\\tfor (int i = 0, j = 0; i < n; i++) { // j is start of interval.\\n\\t\\t\\tif (i == n - 1 || starts[i + 1] > ends[i]) {\\n\\t\\t\\t\\tres.add(new Interval(starts[j], ends[i]));\\n\\t\\t\\t\\tj = i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "  The idea is that for the result distinct Interval, the latter one's start must > previous one's end.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\t// sort start&end\\n\\t\\tint n = intervals.size();\\n\\t\\tint[] starts = new int[n];\\n\\t\\tint[] ends = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tstarts[i] = intervals.get(i).start;\\n\\t\\t\\tends[i] = intervals.get(i).end;\\n\\t\\t}\\n\\t\\tArrays.sort(starts);\\n\\t\\tArrays.sort(ends);\\n\\t\\t// loop through\\n\\t\\tList<Interval> res = new ArrayList<Interval>();\\n\\t\\tfor (int i = 0, j = 0; i < n; i++) { // j is start of interval.\\n\\t\\t\\tif (i == n - 1 || starts[i + 1] > ends[i]) {\\n\\t\\t\\t\\tres.add(new Interval(starts[j], ends[i]));\\n\\t\\t\\t\\tj = i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1644017,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations",
                "content": "# **Two Types of Code || Normal & Solely relying on built in methods of STL library**\\n\\n**Intuition:-**\\nAfter reading the question we get that we need to merge the over lapping intervals and return the result by keeping the rest of the elements as it is.\\nTo find the overlapping intervals the intervals should be atleast sorted think about this .\\nThus for solving we need to sort and then check the consecutive intervals.  Once we find the overlapping interval. we will take the max element from it.\\n\\n**Algorithm:-**\\n1. Firstly, the base case : if there are no intervals return [] .\\n2. Sort the intervals .\\n3. While traversing the intervals vector we will come accross two coditions\\n* First condition : if there is a overlapping between the intervals then just take out the max element from the ending point and thus we merged them \\neg:- [1,4],[2,8]  =Mergerd intervals will be> [1,8]\\n* second condition : if there is no overlapping then simply push those interval to our resultant vector .\\n4. Now let\\'s move our finger\\'s to coding :)\\n \\n**Code type 1:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> result;\\n        //base case when threr are no intervals\\n        if(interval.size()==0)return result;\\n        //sort takes O(nlogn) time\\n        sort(interval.begin(),interval.end());\\n        //insert the the the first interval in the result\\n        result.push_back(interval[0]);\\n        int j=0;\\n        //Traverse the whole vector .Takes O(n) time\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            //if intevals are overlapping\\n            if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Code type 2:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //base case\\n        if(intervals.size()<=1) return intervals;\\n        //resultan vector\\n        vector<vector<int>> result;\\n        //sort takes O(nlogn) time\\n        sort(intervals.begin(), intervals.end()); \\n        //insert the the the first interval in the result\\n        result.push_back(intervals[0]);\\n         //Traverse the whole vector .Takes O(n) time\\n        for(int i=1; i<intervals.size(); i++) {\\n             //if intevals are overlapping\\n            if(result.back()[1] >= intervals[i][0]) result.back()[1] = max(result.back()[1] , intervals[i][1]);\\n            //else they are not overlapping\\n            else result.push_back(intervals[i]); \\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Time complexity :** *`O(nlogn) [for using the sort function] + O(n) [for traversing the interval] = O(nlogn)`*\\n**Space Complexity :** *`O(n) [For our resultant vector]`*\\n***\\n**Feel free to comment if you have some suggestions or upvote if you liked it.**\\n***\\nHere\\'s my [github link](https://github.com/Jatin-Shihora) where I keep my solutions.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> result;\\n        //base case when threr are no intervals\\n        if(interval.size()==0)return result;\\n        //sort takes O(nlogn) time\\n        sort(interval.begin(),interval.end());\\n        //insert the the the first interval in the result\\n        result.push_back(interval[0]);\\n        int j=0;\\n        //Traverse the whole vector .Takes O(n) time\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            //if intevals are overlapping\\n            if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //base case\\n        if(intervals.size()<=1) return intervals;\\n        //resultan vector\\n        vector<vector<int>> result;\\n        //sort takes O(nlogn) time\\n        sort(intervals.begin(), intervals.end()); \\n        //insert the the the first interval in the result\\n        result.push_back(intervals[0]);\\n         //Traverse the whole vector .Takes O(n) time\\n        for(int i=1; i<intervals.size(); i++) {\\n             //if intevals are overlapping\\n            if(result.back()[1] >= intervals[i][0]) result.back()[1] = max(result.back()[1] , intervals[i][1]);\\n            //else they are not overlapping\\n            else result.push_back(intervals[i]); \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350272,
                "title": "python3-sort-o-nlog-n",
                "content": "```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key =lambda x: x[0])\\n        merged =[]\\n        for i in intervals:\\n\\t\\t\\t# if the list of merged intervals is empty \\n\\t\\t\\t# or if the current interval does not overlap with the previous,\\n\\t\\t\\t# simply append it.\\n            if not merged or merged[-1][-1] < i[0]:\\n                merged.append(i)\\n\\t\\t\\t# otherwise, there is overlap,\\n\\t\\t\\t#so we merge the current and previous intervals.\\n            else:\\n                merged[-1][-1] = max(merged[-1][-1], i[-1])\\n        return merged\\n```\\n\\n* Time complexity:\\n\\tIn python, use sort method to a list costs [O(nlogn)](https://wiki.python.org/moin/TimeComplexity), where n is the length of the list.\\n\\tThe for-loop used to merge intervals, costs O(n).\\n\\tO(nlogn)+O(n) = O(nlogn)\\n\\tSo the total time complexity is O(nlogn).\\n* Space complexity\\n\\tThe algorithm used a merged list and a variable i.\\n\\tIn the worst case, the merged list is equal to the length of the input intervals list. So the space complexity is O(n), where n is the length of the input list.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()\\n        merged = []\\n        for i in range(len(intervals)):\\n            if merged == []:\\n                merged.append(intervals[i])\\n            else:\\n                previous_end = merged[-1][1]\\n                current_start = intervals[i][0]\\n                current_end = intervals[i][1]\\n                if previous_end >= current_start: # overlap\\n                    merged[-1][1] = max(previous_end,current_end)\\n                else:\\n                    merged.append(intervals[i])\\n        return merged\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key =lambda x: x[0])\\n        merged =[]\\n        for i in intervals:\\n\\t\\t\\t# if the list of merged intervals is empty \\n\\t\\t\\t# or if the current interval does not overlap with the previous,\\n\\t\\t\\t# simply append it.\\n            if not merged or merged[-1][-1] < i[0]:\\n                merged.append(i)\\n\\t\\t\\t# otherwise, there is overlap,\\n\\t\\t\\t#so we merge the current and previous intervals.\\n            else:\\n                merged[-1][-1] = max(merged[-1][-1], i[-1])\\n        return merged\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()\\n        merged = []\\n        for i in range(len(intervals)):\\n            if merged == []:\\n                merged.append(intervals[i])\\n            else:\\n                previous_end = merged[-1][1]\\n                current_start = intervals[i][0]\\n                current_end = intervals[i][1]\\n                if previous_end >= current_start: # overlap\\n                    merged[-1][1] = max(previous_end,current_end)\\n                else:\\n                    merged.append(intervals[i])\\n        return merged\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186112,
                "title": "best-c-solution-ever-sorting-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Array + Sorting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of the Vector(intervals).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output) which can go upto size N , however the output does not count towards the space complexity.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of\\n    the Vector(intervals).\\n\\n    Space Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output)\\n    which can go upto size N , however the output does not count towards the space complexity.\\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        for(auto interval : intervals){\\n            if(output.empty() || output.back()[1] < interval[0]){\\n                output.push_back(interval);\\n            }\\n            else{\\n                output.back()[1] = max(output.back()[1], interval[1]);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of\\n    the Vector(intervals).\\n\\n    Space Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output)\\n    which can go upto size N , however the output does not count towards the space complexity.\\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        for(auto interval : intervals){\\n            if(output.empty() || output.back()[1] < interval[0]){\\n                output.push_back(interval);\\n            }\\n            else{\\n                output.back()[1] = max(output.back()[1], interval[1]);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600013,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nInitially sort the array and then push the first element into the answer for speculation.\\nWe have two condition if the first elements second part of ans array is greater than or equal to the second element first part of the \\ninterval array.\\nThe other condition we have to tackle is what if its not? then we push the particular element into the ans array which will be then be under speculation.\\ninterval: [[1,3],[2,6],[8,10],[15,18]]\\n             i\\nWe initally push the 1st element into the ans array:\\nans=[[1,3]]\\n      j        j points to the latest pushed element\\nThen we i is incremented.\\n[[1,3],[2,6],[8,10],[15,18]]\\n         i\\nNow the ans[j][1]>interval[i][0] this means there is a possiblity of merging so we merger them\\nRemember the way we merge is to take the second element as max(ans[j][1],interval[i][1])\\ncuz imagine we have this\\n[1,7][2,4] --->merge should be ---->[1,7]\\n\\nans=[[1,6]]\\n\\nthen we move i forward\\n\\n[[1,3],[2,6],[8,10],[15,18]]\\n               i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nThus we will push this into the ans array and speculate.\\n\\nans=[[1,6][8,10]]\\n            j   <----j is moved forward\\ni is moved forward \\n[[1,3],[2,6],[8,10],[15,18]]\\n                       i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nans=[[1,6][8,10][15,18]]\\n                  j\\n\\nThus yielding our final answer.\\n\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> ans;\\n        if(interval.size()==0)return ans;\\n        sort(interval.begin(),interval.end());\\n        ans.push_back(interval[0]);\\n        int j=0;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            if(ans[j][1]>=interval[i][0])\\n                ans[j][1]=max(ans[j][1],interval[i][1]);\\n            else\\n            {\\n                j++;\\n                ans.push_back(interval[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nInitially sort the array and then push the first element into the answer for speculation.\\nWe have two condition if the first elements second part of ans array is greater than or equal to the second element first part of the \\ninterval array.\\nThe other condition we have to tackle is what if its not? then we push the particular element into the ans array which will be then be under speculation.\\ninterval: [[1,3],[2,6],[8,10],[15,18]]\\n             i\\nWe initally push the 1st element into the ans array:\\nans=[[1,3]]\\n      j        j points to the latest pushed element\\nThen we i is incremented.\\n[[1,3],[2,6],[8,10],[15,18]]\\n         i\\nNow the ans[j][1]>interval[i][0] this means there is a possiblity of merging so we merger them\\nRemember the way we merge is to take the second element as max(ans[j][1],interval[i][1])\\ncuz imagine we have this\\n[1,7][2,4] --->merge should be ---->[1,7]\\n\\nans=[[1,6]]\\n\\nthen we move i forward\\n\\n[[1,3],[2,6],[8,10],[15,18]]\\n               i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nThus we will push this into the ans array and speculate.\\n\\nans=[[1,6][8,10]]\\n            j   <----j is moved forward\\ni is moved forward \\n[[1,3],[2,6],[8,10],[15,18]]\\n                       i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nans=[[1,6][8,10][15,18]]\\n                  j\\n\\nThus yielding our final answer.\\n\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> ans;\\n        if(interval.size()==0)return ans;\\n        sort(interval.begin(),interval.end());\\n        ans.push_back(interval[0]);\\n        int j=0;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            if(ans[j][1]>=interval[i][0])\\n                ans[j][1]=max(ans[j][1],interval[i][1]);\\n            else\\n            {\\n                j++;\\n                ans.push_back(interval[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355318,
                "title": "fully-explained-and-clean-interval-tree-for-facebook-follow-up-no-sorting",
                "content": "Inspired by https://leetcode.com/problems/merge-intervals/discuss/21452/Share-my-interval-tree-solution-no-sorting\\n\\n**Question**: How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\\n\\nWe need to have two functions for the tree (`add` interval and `query` tree). \\n\\n##### Implementation Details\\n`TreeNode` - On top of the left child, right child, start boundary, and end boundary, we have a **`middle` field** that determines whether a new interval goes to the left child, right right or merged with the current node.\\n\\n`add` - If the new interval touches or crosses the `middle` of the current node, we update the current node. Otherwise, we put the new interval into the left subtree or right subtree. \\n- Why do we use `middle` for comparison and not `start` or `end` boundaries? \\nThe reason is that we can use merge-sort technique to `query` the merged intervals result when the left subtree does not overlap with the right subtree. \\n\\n`query` - Use merge-sort technique by retrieving the merged intervals of the left subtree (i.e. `left_intervals`) and those of the right subtree (i.e. `right_intervals`). Because of the implementation of `add`, we can guarantee that\\n- if there\\'s an interval in the `left_intervals` that overlaps with the current node, then we know that all the intervals after that interval overlaps with the current node.\\n- The first few intervals or zero intervals in the `right_intervals` overlap with the current node.  \\n\\nHere\\'s the visualization:\\n```\\nleft_res = [ (intervals that do not overlap), (intervals that overlap with current node) ]\\nright_res = [ (intervals that overlap with current node), (intervals that do not overlap) ]\\n```\\n\\n##### Code\\n\\n```python\\nclass TreeNode:\\n    def __init__(self, start, end, middle):\\n        self.start = start\\n        self.end = end\\n        self.middle = middle\\n        self.left = self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = None\\n    \\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        for start, end in intervals:\\n            if not self.root:\\n                self.root = TreeNode(start, end, (start + end) // 2)\\n            else:\\n                self.add(self.root, start, end)\\n        \\n        return self.query(self.root)\\n    \\n    \\n    def add(self, node, start, end):     \\n        if end < node.middle:\\n            if node.left:\\n                self.add(node.left, start, end)\\n            else:\\n                node.left = TreeNode(start, end, (start + end) // 2)\\n        \\n        elif start > node.middle:\\n            if node.right:\\n                self.add(node.right, start, end)\\n            else:\\n                node.right = TreeNode(start, end, (start + end) // 2)\\n        \\n        else:\\n            node.start = min(node.start, start)\\n            node.end = max(node.end, end)\\n    \\n    def query(self, node):\\n        if not node:\\n            return []\\n        \\n        # merge-sort divide and conquer\\n        left_intervals = self.query(node.left)\\n        right_intervals = self.query(node.right)\\n        res = []\\n        \\n        inserted = False\\n        \\n        for lres in left_intervals:\\n            if lres[1] < node.start:\\n                res.append(lres)\\n            else:\\n                res.append([min(lres[0], node.start), node.end])\\n                inserted = True\\n                break\\n        \\n        if not inserted:\\n            res.append([node.start, node.end])\\n        \\n        for rres in right_intervals:\\n            if rres[0] <= node.end:\\n                res[-1][1] = max(node.end, rres[1])\\n            else:\\n                res.append(rres)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nleft_res = [ (intervals that do not overlap), (intervals that overlap with current node) ]\\nright_res = [ (intervals that overlap with current node), (intervals that do not overlap) ]\\n```\n```python\\nclass TreeNode:\\n    def __init__(self, start, end, middle):\\n        self.start = start\\n        self.end = end\\n        self.middle = middle\\n        self.left = self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = None\\n    \\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        for start, end in intervals:\\n            if not self.root:\\n                self.root = TreeNode(start, end, (start + end) // 2)\\n            else:\\n                self.add(self.root, start, end)\\n        \\n        return self.query(self.root)\\n    \\n    \\n    def add(self, node, start, end):     \\n        if end < node.middle:\\n            if node.left:\\n                self.add(node.left, start, end)\\n            else:\\n                node.left = TreeNode(start, end, (start + end) // 2)\\n        \\n        elif start > node.middle:\\n            if node.right:\\n                self.add(node.right, start, end)\\n            else:\\n                node.right = TreeNode(start, end, (start + end) // 2)\\n        \\n        else:\\n            node.start = min(node.start, start)\\n            node.end = max(node.end, end)\\n    \\n    def query(self, node):\\n        if not node:\\n            return []\\n        \\n        # merge-sort divide and conquer\\n        left_intervals = self.query(node.left)\\n        right_intervals = self.query(node.right)\\n        res = []\\n        \\n        inserted = False\\n        \\n        for lres in left_intervals:\\n            if lres[1] < node.start:\\n                res.append(lres)\\n            else:\\n                res.append([min(lres[0], node.start), node.end])\\n                inserted = True\\n                break\\n        \\n        if not inserted:\\n            res.append([node.start, node.end])\\n        \\n        for rres in right_intervals:\\n            if rres[0] <= node.end:\\n                res[-1][1] = max(node.end, rres[1])\\n            else:\\n                res.append(rres)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644409,
                "title": "c-python-simple-solutions-w-explanation-sort-merge-o-nlogn-count-sort-o-n-r",
                "content": "We are given array of intervals and we need to merge all the overlapping intervals\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Sort & Merge)***\\n\\nTwo intervals `i1` and `i2` overlap only if `i1[1] >= i2[0]` and `i2[1] >= i1[0]` or vice-versa. So, whenever we find two such intervals, we need to merge them as `[min(i1[0], i2[0]), max(i1[1], i2[1])]`. However, directly using this approach would require us compare each pair of intervals, merge them if they overlap and restart the same process & continue the same till we dont find any overlapping between any pairs. This would lead to more than `O(N^2)` time complexity.\\n\\nA better approach would be to sort the given intervals first. This would allow us to iterate one by one and only compare between adjacent pair of intervals instead of every pair. We can maintain a sorted list and merge/insert new intervals one by one. Since, we have sorted the intervals, one of the condition of overlap is already satisfied - `i2[1] >= i1[0]` (since `i2[0] >= i1[0]` after sort & `i2[1] >= i2[0]`). \\n\\nThus, we only need to check if the new interval\\'s start (`i[0]` in below code) is <= last interval of sorted list (`ans.back()[1]`) formed till now. If it is overlapping, then we merge the two intervals by updating the last interval of the sorted list. If the intervals dont overlap, we can just add the new interval to the end of sorted list.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        vector<vector<int>> ans {I[0]};                        // adding 1st interval to avoid checking ans.empty() each time in loop\\n        for(auto i : I)\\n            if(i[0] <= ans.back()[1])                          // merge intervals if they overlap\\n                ans.back()[1] = max(ans.back()[1], i[1]);\\n            else                                               // else insert new interval\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        ans = [I[0]]\\n        for i in I:\\n            if i[0] <= ans[-1][1]:\\n                ans[-1][1] = max(ans[-1][1], i[1])\\n            else:\\n                ans.append(i)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(NlogN)</code>\\n***Space Complexity :*** `O(sort)`, required for in-built sort algortihm. The extra space used for output is generally not included in space complexity.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Inplace Merge)***\\n\\nYou could further optimize on space if you are allowed to modify the input itself in which case you can directly merge in-place. We could keep track of length of sorted sub-list in `I` in an variable `R` (denoting right end of sorted list formed till now). The rest of logic would be same as above. We would just replace last interval of sorted list denoted by `ans.back()` in previous approach with `I[R]` since we are merge inplace.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])                          \\n                I[R][1] = max(I[R][1], i[1]);\\n            else                                              \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\\n\\n***Time Complexity :*** <code>O(NlogN)</code>\\n***Space Complexity :*** `O(sort)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Counting Sort & Merge)***\\n\\nWe can sort the intervals using counting sort as well. This approach would be more efficient if the number of intervals are greater but the range is small. \\n\\nWe declare an array `ends` of length equal to greatest start of an interval. `ends[i]` will store the array of ends of interval starting at `i`. Once we fill `ends` using intervals from `I`, we can update intervals back into `I` in a sorted order. The rest of the code remains the same\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    void countingSort(vector<vector<int>>& I) {\\n        int range = 1 + (*max_element(begin(I), end(I), [](auto& i1, auto& i2){return i1[0] < i2[0];}))[0];\\n        vector<vector<int>> ends(range);          // ends[i] stores array of ends of interval starting at i\\n        for(auto& i : I) \\n            ends[i[0]].push_back(i[1]);\\n        for(int i = 0, j = 0; i < range; i++)     // insert intervals back into I in sorted order\\n            for(auto end : ends[i])\\n                I[j++] = {i, end};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        countingSort(I);\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])\\n                I[R][1] = max(I[R][1], i[1]);\\n            else               \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        def countingSort():\\n            ends, j = defaultdict(list), 0\\n            for i in I:\\n                ends[i[0]].append(i[1])\\n            for i in range(1 + max(I, key = lambda i : i[0])[0]):\\n                for end in ends[i]:\\n                    I[j] = [i, end]\\n                    j += 1\\n                    \\n        countingSort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\\n\\n***Time Complexity :*** <code>O(N + R)</code>, where `R` is the range of intervals determined by largest start value of an interval\\n***Space Complexity :*** `O(R)`, required for storing `ends`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        vector<vector<int>> ans {I[0]};                        // adding 1st interval to avoid checking ans.empty() each time in loop\\n        for(auto i : I)\\n            if(i[0] <= ans.back()[1])                          // merge intervals if they overlap\\n                ans.back()[1] = max(ans.back()[1], i[1]);\\n            else                                               // else insert new interval\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        ans = [I[0]]\\n        for i in I:\\n            if i[0] <= ans[-1][1]:\\n                ans[-1][1] = max(ans[-1][1], i[1])\\n            else:\\n                ans.append(i)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])                          \\n                I[R][1] = max(I[R][1], i[1]);\\n            else                                              \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void countingSort(vector<vector<int>>& I) {\\n        int range = 1 + (*max_element(begin(I), end(I), [](auto& i1, auto& i2){return i1[0] < i2[0];}))[0];\\n        vector<vector<int>> ends(range);          // ends[i] stores array of ends of interval starting at i\\n        for(auto& i : I) \\n            ends[i[0]].push_back(i[1]);\\n        for(int i = 0, j = 0; i < range; i++)     // insert intervals back into I in sorted order\\n            for(auto end : ends[i])\\n                I[j++] = {i, end};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        countingSort(I);\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])\\n                I[R][1] = max(I[R][1], i[1]);\\n            else               \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        def countingSort():\\n            ends, j = defaultdict(list), 0\\n            for i in I:\\n                ends[i[0]].append(i[1])\\n            for i in range(1 + max(I, key = lambda i : i[0])[0]):\\n                for end in ends[i]:\\n                    I[j] = [i, end]\\n                    j += 1\\n                    \\n        countingSort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21452,
                "title": "share-my-interval-tree-solution-no-sorting",
                "content": "I want to do it without sorting, because:\\nhttps://leetcode.com/discuss/67748/share-my-bst-interval-tree-solution-c-no-sorting?show=67748#q67748\\n\\nIn that post, I used BST of intervals. However, as you can see from that post, if each node is an interval, it is very difficult to keep each node disjoint. Although that code achieved this, it is hard to read. \\n\\nSo, I use interval tree in this post. You can google and find its variations, I am using the basic structure. Basically, each node will maintains a lot of intervals, depending on whether the interval intersect the middle of the node. It is easy to insert/delete an interval. The only difficult is: given an interval tree, how to get the final result, how to merge them in the final step?\\n\\n    class IntervalTree{\\n    public:\\n        int middle;\\n        int start, end;\\n        IntervalTree *left, *right;\\n        IntervalTree(int s, int e): start(s), end(e), middle((s+e)/2){\\n            this->left=this->right=NULL;\\n        }\\n};\\n\\n\\n    void InsertInterval(IntervalTree *node, Interval \\xa4tInterval){\\n    if(node == NULL)\\n        return;\\n\\n    if(currentInterval.end<node->middle){\\n        if(node->left)\\n            return InsertInterval(node->left, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->left = newnode;\\n            return;\\n        }\\n    }\\n\\n    if(currentInterval.start>node->middle){\\n        if(node->right)\\n            return InsertInterval(node->right, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->right = newnode;\\n            return;\\n        }\\n    }\\n\\n    //insert it to current node\\n    node->start=min(node->start, currentInterval.start);\\n    node->end=max(node->end, currentInterval.end);\\n\\n}\\n\\nSo, when you want to merge the intervals, you will do something like below:\\n\\n    void QueryInterval(vector<Interval> &retV, IntervalTree *node){\\n    //retV is the return vector\\n    vector<Interval> leftIntervals;\\n    vector<Interval> rightIntervals;\\n\\n    bool mergeleft = false; //whether current node merge with any intervals from left child. \\n    if(node->left){\\n        //return the merge of all intervals in left child. \\n        QueryInterval(leftIntervals, node->left);\\n        //merge left interval with myself. \\n        MergeLeftInterval(leftIntervals, node, retV, mergeleft);\\n    }\\n    if(!mergeleft){ //if we did not merge left intervals, add a new one\\n        Interval newinterval;\\n        newinterval.start = node->start;\\n        newinterval.end = node->end;\\n        retV.push_back(newinterval);\\n    }\\n    \\n    if(node->right){\\n        QueryInterval(rightIntervals, node->right);\\n        MergeRightInterval(rightIntervals, node, retV);\\n    }\\n    \\n    return;\\n}\\n\\n\\nAnd finally, the 2 child functions used above:\\n\\n    void MergeLeftInterval(vector<Interval> &leftIntervals, IntervalTree *node, vector<Interval> &retV, bool &merged){\\n    for(int i=0; i<leftIntervals.size(); i++){\\n        if(leftIntervals[i].end>=node->start){\\n            Interval newinterval;\\n            newinterval.start = min(leftIntervals[i].start, node->start);\\n            newinterval.end = node->end;\\n            retV.push_back(newinterval);\\n            merged = true;\\n            break;\\n        }\\n        else{\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n\\nvoid MergeRightInterval(vector<Interval> &rightIntervals, IntervalTree *node, vector<Interval> &retV){\\n    for(int i=0; i<rightIntervals.size(); i++){\\n        if(rightIntervals[i].start<=node->end){\\n            retV[retV.size()-1].end = max(rightIntervals[i].end, node->end);\\n        }\\n        else{\\n            retV.push_back(rightIntervals[i]);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "C++"
                ],
                "code": "I want to do it without sorting, because:\\nhttps://leetcode.com/discuss/67748/share-my-bst-interval-tree-solution-c-no-sorting?show=67748#q67748\\n\\nIn that post, I used BST of intervals. However, as you can see from that post, if each node is an interval, it is very difficult to keep each node disjoint. Although that code achieved this, it is hard to read. \\n\\nSo, I use interval tree in this post. You can google and find its variations, I am using the basic structure. Basically, each node will maintains a lot of intervals, depending on whether the interval intersect the middle of the node. It is easy to insert/delete an interval. The only difficult is: given an interval tree, how to get the final result, how to merge them in the final step?\\n\\n    class IntervalTree{\\n    public:\\n        int middle;\\n        int start, end;\\n        IntervalTree *left, *right;\\n        IntervalTree(int s, int e): start(s), end(e), middle((s+e)/2){\\n            this->left=this->right=NULL;\\n        }\\n};\\n\\n\\n    void InsertInterval(IntervalTree *node, Interval \\xa4tInterval){\\n    if(node == NULL)\\n        return;\\n\\n    if(currentInterval.end<node->middle){\\n        if(node->left)\\n            return InsertInterval(node->left, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->left = newnode;\\n            return;\\n        }\\n    }\\n\\n    if(currentInterval.start>node->middle){\\n        if(node->right)\\n            return InsertInterval(node->right, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->right = newnode;\\n            return;\\n        }\\n    }\\n\\n    //insert it to current node\\n    node->start=min(node->start, currentInterval.start);\\n    node->end=max(node->end, currentInterval.end);\\n\\n}\\n\\nSo, when you want to merge the intervals, you will do something like below:\\n\\n    void QueryInterval(vector<Interval> &retV, IntervalTree *node){\\n    //retV is the return vector\\n    vector<Interval> leftIntervals;\\n    vector<Interval> rightIntervals;\\n\\n    bool mergeleft = false; //whether current node merge with any intervals from left child. \\n    if(node->left){\\n        //return the merge of all intervals in left child. \\n        QueryInterval(leftIntervals, node->left);\\n        //merge left interval with myself. \\n        MergeLeftInterval(leftIntervals, node, retV, mergeleft);\\n    }\\n    if(!mergeleft){ //if we did not merge left intervals, add a new one\\n        Interval newinterval;\\n        newinterval.start = node->start;\\n        newinterval.end = node->end;\\n        retV.push_back(newinterval);\\n    }\\n    \\n    if(node->right){\\n        QueryInterval(rightIntervals, node->right);\\n        MergeRightInterval(rightIntervals, node, retV);\\n    }\\n    \\n    return;\\n}\\n\\n\\nAnd finally, the 2 child functions used above:\\n\\n    void MergeLeftInterval(vector<Interval> &leftIntervals, IntervalTree *node, vector<Interval> &retV, bool &merged){\\n    for(int i=0; i<leftIntervals.size(); i++){\\n        if(leftIntervals[i].end>=node->start){\\n            Interval newinterval;\\n            newinterval.start = min(leftIntervals[i].start, node->start);\\n            newinterval.end = node->end;\\n            retV.push_back(newinterval);\\n            merged = true;\\n            break;\\n        }\\n        else{\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n\\nvoid MergeRightInterval(vector<Interval> &rightIntervals, IntervalTree *node, vector<Interval> &retV){\\n    for(int i=0; i<rightIntervals.size(); i++){\\n        if(rightIntervals[i].start<=node->end){\\n            retV[retV.size()-1].end = max(rightIntervals[i].end, node->end);\\n        }\\n        else{\\n            retV.push_back(rightIntervals[i]);\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 21276,
                "title": "a-clean-java-solution",
                "content": "    public class Solution {\\n        public List<Interval> merge(List<Interval> intervals) {\\n            Collections.sort(intervals, new Comparator<Interval>(){\\n                @Override\\n                public int compare(Interval obj0, Interval obj1) {\\n                    return obj0.start - obj1.start;\\n                }\\n            });\\n    \\n            List<Interval> ret = new ArrayList<>();\\n            Interval prev = null;\\n            for (Interval inter : intervals) {\\n                if (  prev==null || inter.start>prev.end ) {\\n                    ret.add(inter);\\n                    prev = inter;\\n                } else if (inter.end>prev.end) {\\n                    // Modify the element already in list\\n                    prev.end = inter.end;\\n                }\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Interval> merge(List<Interval> intervals) {\\n            Collections.sort(intervals, new Comparator<Interval>(){\\n                @Override\\n                public int compare(Interval obj0, Interval obj1) {\\n                    return obj0.start - obj1.start;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 179876,
                "title": "thinking-process",
                "content": "In order to merge overlapped intervals, we should be able to tell whether two intervals are overlapped.\\n\\nGiven two intervals `[a, b]` and `[c, d]`, they do not overlap with each other if `b < c or d < a`.\\n\\nSo they overlap if `a <= d and c <= b` as below examples:\\n```\\n1)\\n-----\\na   b\\n\\n  -----\\n  c   d\\n2)\\n\\t-----\\n\\ta   b\\n\\n  -----\\n  c   d\\n```\\n\\nIf we sort intervals by starts of both intervals, then `a <= c`, since `c < d`, so `a < d` -- one requirement of overlapped intervals is met.\\n\\nThus, after we sort intervals by starts, two intervals overlap if `c <= b`.\\n\\nAll in all, we sort the intervals given in the problem by starts, and then iterate through the sorted intervals - we merge overlapped intervals on the fly.\\n\\nIs that one-pass enough to merge over-lapped intervals? Yes, since intervals[i + 1] cannot overlap with intervals[i - 1] if intervals[i] doesn\\'t in the sorted sequence.\\n****\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda interval : interval[0])\\n        res = [intervals[0]]\\n        for [start, end] in intervals:\\n            prev_start, prev_end = res[-1]\\n            if start <= prev_end:  # overlap\\n                res.pop()\\n                res.append([prev_start, max(prev_end, end)])\\n            else:\\n                res.append([start, end])\\n        return res\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n1)\\n-----\\na   b\\n\\n  -----\\n  c   d\\n2)\\n\\t-----\\n\\ta   b\\n\\n  -----\\n  c   d\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda interval : interval[0])\\n        res = [intervals[0]]\\n        for [start, end] in intervals:\\n            prev_start, prev_end = res[-1]\\n            if start <= prev_end:  # overlap\\n                res.pop()\\n                res.append([prev_start, max(prev_end, end)])\\n            else:\\n                res.append([start, end])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21332,
                "title": "short-python-solution",
                "content": "Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one.\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            if len(intervals) == 0: return []\\n            intervals = sorted(intervals, key = lambda x: x.start)\\n            res = [intervals[0]]\\n            for n in intervals[1:]:\\n                if n.start <= res[-1].end: res[-1].end = max(n.end, res[-1].end)\\n                else: res.append(n)\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one.\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            if len(intervals) == 0: return []\\n            intervals = sorted(intervals, key = lambda x: x.start)\\n            res = [intervals[0]]\\n            for n in intervals[1:]:\\n                if n.start <= res[-1].end: res[-1].end = max(n.end, res[-1].end)\\n                else: res.append(n)\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 1644169,
                "title": "java-simple-steps-explained-simple-sort",
                "content": "# \\u2705 Approach 1 : Sorting \\n\\n---\\n\\n> ##### Sort by start of intervals, keep track of merging interval\\n\\n\\nOur task in this question is to merge the intervals which can merge:\\n* Only those intervals can merge whose start lies between the start and end of other interval .\\n*  I1 =  [1,5]   and I2 = [2,8] ,these intervals can merge as the start of I2 is lies between then interval range of I1\\n*  Now inorder to know adjacent interval which  can possibly merge we will sort all interval on the basis of start \\n\\n\\n**Steps :**\\n\\n---\\n* **Take some initial range** ( taking 0th index interval as initial range)\\n* Now, start iterating from 1 index in intervals array\\n* if its start lies in intial range , then increase your range by \\n```\\t \\t \\n\\t\\t\\t\\t\\t end =  Math.max(end,interval[i][1])                       `\\t\\t \\n```\\n * if there is no intersection of this interval with our range then add this range in ans arraylis and intialize new range by current index interval\\n \\n ####  Lets see code for more better understanding \\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB\\uD83D\\uDCBB :\\n ---\\n \\n ```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n\\t\\t// sort our intervals \\n      Arrays.sort(intervals, (o1,o2)->o1[0]-o2[0]);\\n   \\n        ArrayList<int[]> ans  =  new ArrayList<>();\\n\\t\\t// intial range \\n        int start  =  intervals[0][0];\\n        int end =  intervals[0][1]; \\n        \\n        int  i =1;\\n        while(i<intervals.length){\\n            int s = intervals[i][0];\\n            int e = intervals[i][1];\\n            // next interval start is smaller than prev end and array is sorted\\n            // so these two internal can merge\\n            if( s<=end  ) { \\n                // so merge both intervals \\n                end =  Math.max(end,e);\\n            }\\n            else{ // if merge not possible , then insert prev interval into list\\n                ans.add(new int[]{start,end});\\n                start = s;\\n                end =  e;                \\n            }\\n           i++;\\n        }\\n        \\n        ans.add(new int[] {start,end});\\n\\t\\t\\n\\t\\t  int arr[][] =  new int[ans.size()][];\\n\\t        for(int i=0;i<ans.size();i++) {\\n\\t        \\tint a[] =  new int[2];\\n\\t        \\tfor(int j=0;j<2;j++) {\\n\\t        \\t\\ta[j] =  ans.get(i).get(j);\\n\\t        \\t}\\n\\t        \\tarr[i] =  a;\\n\\t        }\\n\\t        \\n\\t        return   arr;\\n\\t\\t\\n\\t\\t // or \\n\\t\\t //  return ans.toArray(new int[0][]);\\n        \\n        \\n        \\n    }\\n}\\n```\\n\\n\\n\\n\\n---\\n\\n# **\\u2705** Approach 2 : Using TreeSet\\n\\n\\n\\n\\n```\\nclass Solution {\\n\\n    public int[][] merge(int[][] intervals) {       \\n        for (int interval[] : intervals) {\\n            add(interval[0], interval[1]);\\n        }\\n        int i = 0;\\n        int ans[][] = new int[map.size()][2];\\n        for (Map.Entry<Integer, Integer> it : map.entrySet()) {\\n            ans[i++] = new int[] { it.getKey(), it.getValue() };\\n        }\\n        return ans;\\n    }\\n\\n\\t// storing , {start,end} of interval \\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public void add(int left, int right) {\\n\\t\\t// finding greatest , smaller key than right \\n        if (map.floorKey(right) == null || map.get(map.floorKey(right)) < left) {\\n            map.put(left, right);\\n        } else {\\n            int start = left, end = right;\\n            while (true) {\\n                int l = map.floorKey(end);\\n                int r = map.get(l);\\n                start = Math.min(l, start);\\n                end = Math.max(r, end);\\n\\n                map.remove(l);\\n\\t\\t\\t\\t// if no longer merge can be done then break\\n                if (map.floorKey(end) == null || map.get(map.floorKey(end)) < start) {\\n                    break;\\n                }\\n            }\\n\\n            map.put(start, end);\\n        }\\n    }\\n}\\n\\n```\\n\\n >**Time Complexity** : **n*logn** , (each add operation  armotrised logn  )\\n >**space : O(n)**\\n >\\n\\n\\n### Do upvote if found useful\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\t \\t \\n\\t\\t\\t\\t\\t end =  Math.max(end,interval[i][1])                       `\\t\\t \\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n\\t\\t// sort our intervals \\n      Arrays.sort(intervals, (o1,o2)->o1[0]-o2[0]);\\n   \\n        ArrayList<int[]> ans  =  new ArrayList<>();\\n\\t\\t// intial range \\n        int start  =  intervals[0][0];\\n        int end =  intervals[0][1]; \\n        \\n        int  i =1;\\n        while(i<intervals.length){\\n            int s = intervals[i][0];\\n            int e = intervals[i][1];\\n            // next interval start is smaller than prev end and array is sorted\\n            // so these two internal can merge\\n            if( s<=end  ) { \\n                // so merge both intervals \\n                end =  Math.max(end,e);\\n            }\\n            else{ // if merge not possible , then insert prev interval into list\\n                ans.add(new int[]{start,end});\\n                start = s;\\n                end =  e;                \\n            }\\n           i++;\\n        }\\n        \\n        ans.add(new int[] {start,end});\\n\\t\\t\\n\\t\\t  int arr[][] =  new int[ans.size()][];\\n\\t        for(int i=0;i<ans.size();i++) {\\n\\t        \\tint a[] =  new int[2];\\n\\t        \\tfor(int j=0;j<2;j++) {\\n\\t        \\t\\ta[j] =  ans.get(i).get(j);\\n\\t        \\t}\\n\\t        \\tarr[i] =  a;\\n\\t        }\\n\\t        \\n\\t        return   arr;\\n\\t\\t\\n\\t\\t // or \\n\\t\\t //  return ans.toArray(new int[0][]);\\n        \\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int[][] merge(int[][] intervals) {       \\n        for (int interval[] : intervals) {\\n            add(interval[0], interval[1]);\\n        }\\n        int i = 0;\\n        int ans[][] = new int[map.size()][2];\\n        for (Map.Entry<Integer, Integer> it : map.entrySet()) {\\n            ans[i++] = new int[] { it.getKey(), it.getValue() };\\n        }\\n        return ans;\\n    }\\n\\n\\t// storing , {start,end} of interval \\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public void add(int left, int right) {\\n\\t\\t// finding greatest , smaller key than right \\n        if (map.floorKey(right) == null || map.get(map.floorKey(right)) < left) {\\n            map.put(left, right);\\n        } else {\\n            int start = left, end = right;\\n            while (true) {\\n                int l = map.floorKey(end);\\n                int r = map.get(l);\\n                start = Math.min(l, start);\\n                end = Math.max(r, end);\\n\\n                map.remove(l);\\n\\t\\t\\t\\t// if no longer merge can be done then break\\n                if (map.floorKey(end) == null || map.get(map.floorKey(end)) < start) {\\n                    break;\\n                }\\n            }\\n\\n            map.put(start, end);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21451,
                "title": "share-my-bst-interval-tree-solution-c-no-sorting",
                "content": "I share this solution because my friend was asked in his FB interview. He was asked to do it without sorting, for a large stream of intervals. The solution can be interval tree, but that is too complicated. Here I maintain a BST of distinct intervals. We dont need to maintain all the intervals like interval tree. We will merge intervals while we inserting. The code did not balance the tree. That is why performance is still 500+ms. \\n\\nSuppose we already have a BST of disjoint intervals. Given a new interval A, it will first find the toppest interval that has overlapping with A. Suppose it is B. Until now everything is easy. We simply traversed tree to reach this. \\n\\nThen, it will try to expand interval B. Now it becomes tricky. There are 3 cases. 1 case is simple. For the other 2 cases, you will need to delete currentNode, because it is already merged. You need to always correctly maintain prevNode and direction, in order to merge correctly in next round. For 1 case, you can end there. For another case, you need to continue exploration. \\nThe 2nd and 3rd case have duplicate code. However, I just keep it for better understanding.\\n\\nThe whole reason we can do this, is because: we will never meet a situation that we delete 1 node with 2 children but still keep its 2 children. If we remove 1 node, that means either his left or right is deleted. So, this is not really traditional node deletion in BST!!!!!! \\n\\nI only share my code that insert a new interval to a BST. Other parts are simple. \\nPlease see notes when we exploring left Children, comments are omitted when exploring right children.\\n\\n    void InsertInterval(BSTInterval *node, Interval \\xa4tInterval, BSTInterval *prev, int sign){\\n    //sign=1 if prev->left = node, sign=-1 if prev->right=node. \\n    \\n    int start=currentInterval.start, end = currentInterval.end;\\n    if(node==NULL){\\n        BSTInterval *newnode = new BSTInterval(start, end);\\n        if(sign==1){\\n            prev->left = newnode;\\n            return;\\n        }\\n        else{\\n            prev->right = newnode;\\n            return;\\n        }\\n    }\\n    if (node->start<=start && node->end>=end)\\n        return;\\n        \\n    if (node->start>end){\\n        InsertInterval(node->left, currentInterval, node, 1);\\n        return;\\n    }\\n    if (node->end<start){\\n        InsertInterval(node->right, currentInterval, node, -1);\\n        return;\\n    }\\n    \\n    \\n    /* Now we find the node that overlap with the interval we want to insert. \\n       We start from here and merge intervals. */\\n    //newLeft is always the new start after explore. \\n    int newLeft=min(start, node->start);\\n    if(start<node->start){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newLeft>currentNode->end){\\n                //apparently need to explore right direction. \\n                prevNode = currentNode;\\n                currentNode = currentNode->right;\\n                sign = -1;\\n            }\\n            else if (newLeft>currentNode->start){\\n                //apparently currentNode is not node, otherwise will not hit here\\n                //so, it is safe to delete currentNode\\n                //also, in this case, no need to explore more nodes, why?\\n                newLeft=currentNode->start;\\n                clear(currentNode->right);\\n                currentNode->right=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->left;\\n                else\\n                    prevNode->right = currentNode->left;\\n                //we don't need to explore. \\n                delete currentNode;\\n                break;//no need to continue, why?\\n            }\\n            else{ \\n                //be careful: currentNode will be deleted if it is not node\\n                //then, we need to update prevNode and sign directly\\n                //otherwise we can not properly delete next node!!!\\n                //this case still needs exploration.\\n                BSTInterval *leftChild = currentNode->left;\\n                if(currentNode!=node){\\n                    //prevNode and sign not changed. Just delete currentNode\\n                    clear(currentNode->right);\\n                    currentNode->right=NULL;\\n                    if(sign==1)\\n                        prevNode->left = leftChild;\\n                    else\\n                        prevNode->right = leftChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    //prevNode and sign changed. \\n                    prevNode = currentNode;\\n                    sign = 1;\\n                }\\n                currentNode=leftChild;\\n            }\\n        }\\n    }\\n    node->start = newLeft;\\n\\n    int newRight=max(end, node->end);\\n    if(end>node->end){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newRight<currentNode->start){\\n                prevNode = currentNode;\\n                currentNode = currentNode->left;\\n                sign = +1;\\n            }\\n            else if (newRight<currentNode->end){\\n                newRight=currentNode->end;\\n                clear(currentNode->left);\\n                currentNode->left=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->right;\\n                else\\n                    prevNode->right = currentNode->right;\\n                delete currentNode;\\n                break;\\n            }\\n            else{ \\n                BSTInterval *rightChild = currentNode->right;\\n                if(currentNode!=node){\\n                    clear(currentNode->left);\\n                    currentNode->left=NULL;\\n                    if(sign==1)\\n                        prevNode->left = rightChild;\\n                    else\\n                        prevNode->right = rightChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    prevNode = currentNode;\\n                    sign = -1;\\n                }\\n                currentNode=rightChild;                    \\n            }\\n        }\\n    }\\n    node->end = newRight;\\n\\n    return;\\n}",
                "solutionTags": [],
                "code": "I share this solution because my friend was asked in his FB interview. He was asked to do it without sorting, for a large stream of intervals. The solution can be interval tree, but that is too complicated. Here I maintain a BST of distinct intervals. We dont need to maintain all the intervals like interval tree. We will merge intervals while we inserting. The code did not balance the tree. That is why performance is still 500+ms. \\n\\nSuppose we already have a BST of disjoint intervals. Given a new interval A, it will first find the toppest interval that has overlapping with A. Suppose it is B. Until now everything is easy. We simply traversed tree to reach this. \\n\\nThen, it will try to expand interval B. Now it becomes tricky. There are 3 cases. 1 case is simple. For the other 2 cases, you will need to delete currentNode, because it is already merged. You need to always correctly maintain prevNode and direction, in order to merge correctly in next round. For 1 case, you can end there. For another case, you need to continue exploration. \\nThe 2nd and 3rd case have duplicate code. However, I just keep it for better understanding.\\n\\nThe whole reason we can do this, is because: we will never meet a situation that we delete 1 node with 2 children but still keep its 2 children. If we remove 1 node, that means either his left or right is deleted. So, this is not really traditional node deletion in BST!!!!!! \\n\\nI only share my code that insert a new interval to a BST. Other parts are simple. \\nPlease see notes when we exploring left Children, comments are omitted when exploring right children.\\n\\n    void InsertInterval(BSTInterval *node, Interval \\xa4tInterval, BSTInterval *prev, int sign){\\n    //sign=1 if prev->left = node, sign=-1 if prev->right=node. \\n    \\n    int start=currentInterval.start, end = currentInterval.end;\\n    if(node==NULL){\\n        BSTInterval *newnode = new BSTInterval(start, end);\\n        if(sign==1){\\n            prev->left = newnode;\\n            return;\\n        }\\n        else{\\n            prev->right = newnode;\\n            return;\\n        }\\n    }\\n    if (node->start<=start && node->end>=end)\\n        return;\\n        \\n    if (node->start>end){\\n        InsertInterval(node->left, currentInterval, node, 1);\\n        return;\\n    }\\n    if (node->end<start){\\n        InsertInterval(node->right, currentInterval, node, -1);\\n        return;\\n    }\\n    \\n    \\n    /* Now we find the node that overlap with the interval we want to insert. \\n       We start from here and merge intervals. */\\n    //newLeft is always the new start after explore. \\n    int newLeft=min(start, node->start);\\n    if(start<node->start){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newLeft>currentNode->end){\\n                //apparently need to explore right direction. \\n                prevNode = currentNode;\\n                currentNode = currentNode->right;\\n                sign = -1;\\n            }\\n            else if (newLeft>currentNode->start){\\n                //apparently currentNode is not node, otherwise will not hit here\\n                //so, it is safe to delete currentNode\\n                //also, in this case, no need to explore more nodes, why?\\n                newLeft=currentNode->start;\\n                clear(currentNode->right);\\n                currentNode->right=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->left;\\n                else\\n                    prevNode->right = currentNode->left;\\n                //we don't need to explore. \\n                delete currentNode;\\n                break;//no need to continue, why?\\n            }\\n            else{ \\n                //be careful: currentNode will be deleted if it is not node\\n                //then, we need to update prevNode and sign directly\\n                //otherwise we can not properly delete next node!!!\\n                //this case still needs exploration.\\n                BSTInterval *leftChild = currentNode->left;\\n                if(currentNode!=node){\\n                    //prevNode and sign not changed. Just delete currentNode\\n                    clear(currentNode->right);\\n                    currentNode->right=NULL;\\n                    if(sign==1)\\n                        prevNode->left = leftChild;\\n                    else\\n                        prevNode->right = leftChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    //prevNode and sign changed. \\n                    prevNode = currentNode;\\n                    sign = 1;\\n                }\\n                currentNode=leftChild;\\n            }\\n        }\\n    }\\n    node->start = newLeft;\\n\\n    int newRight=max(end, node->end);\\n    if(end>node->end){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newRight<currentNode->start){\\n                prevNode = currentNode;\\n                currentNode = currentNode->left;\\n                sign = +1;\\n            }\\n            else if (newRight<currentNode->end){\\n                newRight=currentNode->end;\\n                clear(currentNode->left);\\n                currentNode->left=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->right;\\n                else\\n                    prevNode->right = currentNode->right;\\n                delete currentNode;\\n                break;\\n            }\\n            else{ \\n                BSTInterval *rightChild = currentNode->right;\\n                if(currentNode!=node){\\n                    clear(currentNode->left);\\n                    currentNode->left=NULL;\\n                    if(sign==1)\\n                        prevNode->left = rightChild;\\n                    else\\n                        prevNode->right = rightChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    prevNode = currentNode;\\n                    sign = -1;\\n                }\\n                currentNode=rightChild;                    \\n            }\\n        }\\n    }\\n    node->end = newRight;\\n\\n    return;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 738403,
                "title": "python3-solution-with-a-detailed-explanation",
                "content": "\\n\\nI\\'ve found [this](https://leetcode.com/problems/merge-intervals/discuss/350272/Python3-Sort-O(Nlog(N))) and [this](https://leetcode.com/problems/merge-intervals/discuss/21332/Short-python-solution) solutions super helpful. \\n\\nWhat we\\'re trying to do is to merge intervals with overlap right? One a piece of paper try to merge `a = [1,3]` and `b = [2,5]`. How will you do that? If the right side of `a` (basically `a[1]`) is larger than the left side of `b` (meaning `b[0]`), then you can merge them. Otherwise, you can\\'t. Makes sense? So basically, you go overe all the intervals in `intervals` list, check them one by one and see whether they have overlap or not. Merge them if they had overlap, otherwise, add them to the `res` variable without any change. \\n\\nNote that if there is no interval in `intervals`, we don\\'t need to do anythingm right? (line `#1`), we return `[]`. In order to formalize this, we first `sort` the array (line `#2`). Check [sorted](https://realpython.com/python-sort/). Unlike to `sort()`, `sorted` accepts a key by which you can do useful stuff. We sort here by first element of each interval. Does this make sense? Once we sort it, we add the first interval to the output `res`. Note that, the first element of first interval should have the least amount of all. Let\\'s say `res = [[c,d]]. Now, we check the rest of `intervals` (line `#4`). Let\\'s say the next interval is `[e,f]`. There are two possibilities! Either `e <= d` or `e > d`, right? If `e > d`, the intervals don\\'t have any overlap. But, if `e <=d`, there is an overlap for sure (or at least we have `e = d` which still means that if `f > e`, we should merge the two intervals. That\\'s what we\\'re doing here. \\n\\n\\n`current` interval is compared with the last interval in the `res`, why? Because the last interval is an interval without any overlap to the interval before it in `res` except if there\\'s only one interval in `res`, and since we\\'ve sorted the list initially, current should not have any overlap with intervals before `res[-1]`. Makes sense? So if ` e <= d`, we change `d` with `f` (line `#6`). Otherwise, we append the `current` interval to `res`. We keep doing it until the last interval in `intervals` is visited. \\n\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: #1\\n            return []\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0]) #2\\n        res = [intervals[0]] #3\\n        \\n        for current in intervals[1:]: #4\\n            if current[0] <= res[-1][1]: #5\\n                res[-1][1] = max(current[1], res[-1][1]) #6\\n            else: \\n                res.append(current) #7\\n        return res #1\\n```\\n\\nThis explanation from [here](https://leetcode.com/problems/merge-intervals/discuss/350272/Python3-Sort-O(Nlog(N))) is super helpful to understand the procedure:\\n\\n```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\\n\\n\\n\\n===============================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it\\n\\nFinal note 2: I\\'m doing this writing since I think explaining something in a simple way to others would help me to understand better. Thanks for reading.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: #1\\n            return []\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0]) #2\\n        res = [intervals[0]] #3\\n        \\n        for current in intervals[1:]: #4\\n            if current[0] <= res[-1][1]: #5\\n                res[-1][1] = max(current[1], res[-1][1]) #6\\n            else: \\n                res.append(current) #7\\n        return res #1\\n```\n```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338834,
                "title": "python-3-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Heap**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        minHeap = intervals\\n        heapify(minHeap)  # Heapify in increasing by the starting time order\\n        ans = []\\n        while minHeap:\\n            start, end = heappop(minHeap)\\n            while minHeap and minHeap[0][0] <= end:\\n                end = max(end, heappop(minHeap)[1])\\n            ans.append([start, end])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Sort (Version 1)**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n        ans = []\\n        n, i = len(intervals), 0\\n        while i < n:\\n            start, end = intervals[i]\\n            i += 1\\n            while i < n and intervals[i][0] <= end:\\n                end = max(end, intervals[i][1])\\n                i += 1\\n            ans.append([start, end])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(logN)`, for sorting.\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Sort (Version 2)**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n \\n        lastStart = lastEnd = intervals[0][0]\\n        ans = []\\n        for s, e in intervals:\\n            if s <= lastEnd:\\n                lastEnd = max(lastEnd, e)\\n            else:\\n                ans.append([lastStart, lastEnd])\\n                lastStart = s\\n                lastEnd = e\\n        ans.append([lastStart, lastEnd])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(logN)`, for sorting.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        minHeap = intervals\\n        heapify(minHeap)  # Heapify in increasing by the starting time order\\n        ans = []\\n        while minHeap:\\n            start, end = heappop(minHeap)\\n            while minHeap and minHeap[0][0] <= end:\\n                end = max(end, heappop(minHeap)[1])\\n            ans.append([start, end])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n        ans = []\\n        n, i = len(intervals), 0\\n        while i < n:\\n            start, end = intervals[i]\\n            i += 1\\n            while i < n and intervals[i][0] <= end:\\n                end = max(end, intervals[i][1])\\n                i += 1\\n            ans.append([start, end])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n \\n        lastStart = lastEnd = intervals[0][0]\\n        ans = []\\n        for s, e in intervals:\\n            if s <= lastEnd:\\n                lastEnd = max(lastEnd, e)\\n            else:\\n                ans.append([lastStart, lastEnd])\\n                lastStart = s\\n                lastEnd = e\\n        ans.append([lastStart, lastEnd])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21507,
                "title": "javascript-solution",
                "content": "    function merge(intervals) {\\n      if (!intervals.length) return intervals\\n      intervals.sort((a, b) => a.start !== b.start ? a.start - b.start : a.end - b.end)\\n      var prev = intervals[0]\\n      var res = [prev]\\n      for (var curr of intervals) {\\n        if (curr.start <= prev.end) {\\n          prev.end = Math.max(prev.end, curr.end)\\n        } else {\\n          res.push(curr)\\n          prev = curr\\n        }\\n      }\\n      return res\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function merge(intervals) {\\n      if (!intervals.length) return intervals\\n      intervals.sort((a, b) => a.start !== b.start ? a.start - b.start : a.end - b.end)\\n      var prev = intervals[0]\\n      var res = [prev]\\n      for (var curr of intervals) {\\n        if (curr.start <= prev.end) {\\n          prev.end = Math.max(prev.end, curr.end)\\n        } else {\\n          res.push(curr)\\n          prev = curr\\n        }\\n      }\\n      return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1553054,
                "title": "56-merge-intervals-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> answer = new ArrayList<>();\\n        \\n        if(intervals.length != 0 || intervals != null){\\n            Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n            \\n            int start = intervals[0][0];\\n            int end = intervals[0][1];\\n            for(int[] i: intervals){\\n                if(i[0] <= end){\\n                    end = Math.max(end, i[1]);\\n                } else {\\n                    answer.add(new int[]{start,end});\\n                    start = i[0];\\n                    end = i[1];\\n                }\\n            }\\n            answer.add(new int[]{start,end}); \\n            \\n        }\\n        \\n        return answer.toArray(new int[0][]); \\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> answer = new ArrayList<>();\\n        \\n        if(intervals.length != 0 || intervals != null){\\n            Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n            \\n            int start = intervals[0][0];\\n            int end = intervals[0][1];\\n            for(int[] i: intervals){\\n                if(i[0] <= end){\\n                    end = Math.max(end, i[1]);\\n                } else {\\n                    answer.add(new int[]{start,end});\\n                    start = i[0];\\n                    end = i[1];\\n                }\\n            }\\n            answer.add(new int[]{start,end}); \\n            \\n        }\\n        \\n        return answer.toArray(new int[0][]); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462187,
                "title": "clean-and-concise-java-code-with-comments",
                "content": "``` java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0)\\n            return intervals;\\n        \\n        // sort intervals by starting value\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n\\t\\t// if end of previous interval is more than the start of current interval then there is a overlap\\n        LinkedList<int[]> mergedIntervals = new LinkedList<>();\\n        for(int[] curr : intervals) {\\n            //  if list empty or no overlap simply add current interval\\n            if(mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])\\n                mergedIntervals.add(curr);\\n            // else if overlap exists then merge curren tinterval with the previous interval\\n            else \\n                mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);\\n        }\\n        \\n        return mergedIntervals.toArray(new int[0][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0)\\n            return intervals;\\n        \\n        // sort intervals by starting value\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n\\t\\t// if end of previous interval is more than the start of current interval then there is a overlap\\n        LinkedList<int[]> mergedIntervals = new LinkedList<>();\\n        for(int[] curr : intervals) {\\n            //  if list empty or no overlap simply add current interval\\n            if(mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])\\n                mergedIntervals.add(curr);\\n            // else if overlap exists then merge curren tinterval with the previous interval\\n            else \\n                mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);\\n        }\\n        \\n        return mergedIntervals.toArray(new int[0][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400090,
                "title": "c-easy-beginner-friendly-detailed-explaination",
                "content": "\\n\\n# Code : \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        vector<vector<int>> ans;\\n        ans.push_back({arr[0][0], arr[0][1]});\\n        int i = 0;\\n        int merge = 0;\\n\\n        for(; i < n - 1; i++){\\n            int j = i+1;\\n            if(ans[i - merge][1] >= arr[j][0]){\\n                ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n                merge++;\\n            }else{\\n                ans.push_back({arr[j][0], arr[j][1]});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n---\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. $$Sort$$ the $$intervals$$ based on their start times so that we can easily identify which $$intervals$$ $$overlap$$.\\n2. $$Iterate$$ through the $$sorted$$ $$intervals$$ and $$merge$$ $$overlapping$$ $$intervals$$ into a $$single$$ $$interval$$.\\n3. $$Return$$ the $$merged$$ intervals.\\n   This approach would require $$iterating$$ over the intervals $$twice$$ - once for $$sorting$$ and once for $$merging$$. However, it should be noted that there may be more efficient ways to solve the problem, and the approach may need to be modified based on the specifics of the input and output requirements.\\n\\n\\n---\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The first step is to $$sort$$ the $$intervals$$ by their start time. We use the $$sort()$$ function from the $$STL$$ $$library$$ to do this. This is done to simplify the merging process as we will compare only adjacent intervals to determine if they overlap or not.\\n \\n```\\n    sort(arr.begin(), arr.end());\\n```\\n\\n2. Next, we $$initialize$$ $$an$$ $$empty$$ $$vector$$ ans to store the merged intervals. We then push the first interval to ans, as it cannot overlap with any other interval. \\n\\n```\\n    vector<vector<int>> ans;\\n    ans.push_back({arr[0][0], arr[0][1]});\\n```\\n\\n3. We then $$iterate$$ over the $$remaining$$ $$intervals$$, starting from index 1. If the current interval overlaps with the last interval in ans, we update the ending time of the last interval in ans to the maximum of its original ending time and the ending time of the current interval. We also increment a variable merge to keep track of the number of merged intervals.\\n\\n```\\n    int i = 0;\\n    int merge = 0;\\n    for(; i < n - 1; i++){\\n        int j = i+1;\\n        if(ans[i - merge][1] >= arr[j][0]){\\n            ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n            merge++;\\n        }\\n\\n```\\n\\n4. If the current interval does not overlap with the last interval in ans, we add the current interval to ans.\\n\\n```\\n    else {\\n        ans.push_back({arr[j][0], arr[j][1]});\\n    }\\n```\\n\\n5. Finally, we return ans, which contains the merged intervals.\\n\\n```\\n     return ans;\\n```\\n\\n\\n---\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The code sorts the given vector of intervals based on their starting position using sort().\\n`Time complexity: O(n log n)`\\n- It initializes a new vector ans to store the merged intervals and pushes the first interval to ans.\\n`Time complexity: O(1)`\\n- It iterates through the remaining intervals and checks if they overlap with the last interval in ans.\\n`Time complexity: O(n)`\\n- If the intervals overlap, it updates the ending position of the last interval in ans to the maximum of its original ending position and the ending position of the current interval.\\n`Time complexity: O(1)`\\n- If the intervals do not overlap, it adds the current interval to ans.\\n`Time complexity: O(1)`\\n- Finally, it returns ans containing the merged intervals.\\n`Time complexity: O(n)`\\n\\n- **To summarize, the given code implements a simple and efficient solution to merge overlapping intervals in $$O(n log n) $$time. Its clear and concise implementation makes it easy to understand and maintain. It\\'s definitely a good solution to upload in LeetCode\\'s solution section.**\\n\\n\\n---\\n\\n\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the approach I outlined is O(n), where n is the number of intervals. This is because we need to store the merged intervals in a vector. In the worst case scenario where none of the intervals overlap, the merged vector would be the same size as the input vector. However, in practice, the number of merged intervals will be less than or equal to the number of input intervals. Overall, the space complexity of the approach is linear in the size of the input.\\n\\n---\\n\\n![cat upvote.png](https://assets.leetcode.com/users/images/9e396fb7-dcf4-4c24-b108-9239ca73718d_1681118559.9426527.png)\\n\\n\\n![upvote.png](https://assets.leetcode.com/users/images/62c16602-a9cc-4762-b53e-ec2417f76648_1687507600.6519113.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        vector<vector<int>> ans;\\n        ans.push_back({arr[0][0], arr[0][1]});\\n        int i = 0;\\n        int merge = 0;\\n\\n        for(; i < n - 1; i++){\\n            int j = i+1;\\n            if(ans[i - merge][1] >= arr[j][0]){\\n                ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n                merge++;\\n            }else{\\n                ans.push_back({arr[j][0], arr[j][1]});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\n    sort(arr.begin(), arr.end());\\n```\n```\\n    vector<vector<int>> ans;\\n    ans.push_back({arr[0][0], arr[0][1]});\\n```\n```\\n    int i = 0;\\n    int merge = 0;\\n    for(; i < n - 1; i++){\\n        int j = i+1;\\n        if(ans[i - merge][1] >= arr[j][0]){\\n            ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n            merge++;\\n        }\\n\\n```\n```\\n    else {\\n        ans.push_back({arr[j][0], arr[j][1]});\\n    }\\n```\n```\\n     return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810795,
                "title": "python-js-go-c-by-sort-merge-w-visualization",
                "content": "**Diagram and Visualization**\\n\\nAfter soring on endpoint pair, there are 3 possible cases for interval pairs during merging\\n\\n![image](https://assets.leetcode.com/users/images/8fee36e8-d9d4-4efb-8e91-05d3b0240a4f_1598347860.5559268.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/f6550399-4197-4ec4-8eeb-7c38de6672e8_1598347895.2212944.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/07c2b4fa-bd43-46df-b6a4-259840c0649b_1598347927.5255473.png)\\n\\n---\\n\\n**Implementation** by sort-and-merge\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        \\n        # predefined constant for start (left endpoint), and end (right endpoint)\\n        START, END = 0, 1\\n        \\n        result = []\\n        \\n        # make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        intervals.sort( key = lambda x: (x[START], x[END] ) ) \\n        \\n        for interval in intervals:\\n            \\n            if not result or ( result[-1][END] < interval[START] ):\\n\\t\\t\\t\\t# no overlapping\\n                result.append( interval )\\n            \\n            else:\\n\\t\\t\\t\\t# has overlapping\\n\\t\\t\\t\\t# merge with previous interval\\n                result[-1][END] = max(result[-1][END], interval[END])\\n                \\n        return result\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar merge = function(intervals) {\\n    \\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const [START, END] = [0, 1];\\n    \\n    let result = [];\\n    \\n    // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n    intervals.sort( (a, b) => a[START] != b[START] ? a[START] - b[START] : a[END] - b[END] );\\n    \\n    for( const curInterval of intervals){\\n        \\n        if( (result.length == 0) || ( result[result.length-1][END] < curInterval[START]) ){\\n            // no overlapping\\n            result.push( curInterval );\\n\\n            \\n        \\n        }else{\\n            // has overlapping\\n            // merge with previous interval\\n            result[result.length-1][END] = Math.max( result[result.length-1][END], curInterval[END] );\\n\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc max(x, y int) int {\\n    \\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n//---------------------\\n\\n\\nfunc merge(intervals [][]int) [][]int {\\n\\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const START, END = 0, 1\\n    \\n    result := make( [][]int, 0);\\n    \\n    sort.Slice(intervals, func(a, b int) bool {\\n        return (intervals[a][0] < intervals[b][0]) || ( (intervals[a][0] == intervals[b][0]) && (intervals[a][1] < intervals[b][1]) )\\n    })\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if ( len(result) == 0 ) || ( result[len(result)-1][END] < curInterval[START] ){\\n            \\n            // no overlapping\\n            result = append(result, curInterval)\\n            \\n        }else{\\n            \\n            // has overlapping\\n            // merge with previous interval\\n            result[len(result)-1][END] = max( result[len(result)-1][END], curInterval[END] )\\n        }\\n        \\n    }\\n    \\n    return result\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        // predefined constant for start (left endpoint), as well as end ( right endpoint)\\n        const int START=0, END=1;   \\n        \\n        vector< vector<int> > result;\\n    \\n        // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        sort( intervals.begin(), intervals.end() );\\n        \\n        for( auto const &curInterval : intervals ){\\n            \\n            if ( (result.size() == 0 ) || (result.back()[END] < curInterval[START] ) ){\\n                // no overlapping\\n                result.push_back( curInterval );\\n                \\n            }else{\\n                // has overlapping\\n                // merge with previous interval\\n                result.back()[END] = max( result.back()[END], curInterval[END] );\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        \\n        # predefined constant for start (left endpoint), and end (right endpoint)\\n        START, END = 0, 1\\n        \\n        result = []\\n        \\n        # make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        intervals.sort( key = lambda x: (x[START], x[END] ) ) \\n        \\n        for interval in intervals:\\n            \\n            if not result or ( result[-1][END] < interval[START] ):\\n\\t\\t\\t\\t# no overlapping\\n                result.append( interval )\\n            \\n            else:\\n\\t\\t\\t\\t# has overlapping\\n\\t\\t\\t\\t# merge with previous interval\\n                result[-1][END] = max(result[-1][END], interval[END])\\n                \\n        return result\\n```\n```\\nvar merge = function(intervals) {\\n    \\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const [START, END] = [0, 1];\\n    \\n    let result = [];\\n    \\n    // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n    intervals.sort( (a, b) => a[START] != b[START] ? a[START] - b[START] : a[END] - b[END] );\\n    \\n    for( const curInterval of intervals){\\n        \\n        if( (result.length == 0) || ( result[result.length-1][END] < curInterval[START]) ){\\n            // no overlapping\\n            result.push( curInterval );\\n\\n            \\n        \\n        }else{\\n            // has overlapping\\n            // merge with previous interval\\n            result[result.length-1][END] = Math.max( result[result.length-1][END], curInterval[END] );\\n\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nfunc max(x, y int) int {\\n    \\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n//---------------------\\n\\n\\nfunc merge(intervals [][]int) [][]int {\\n\\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const START, END = 0, 1\\n    \\n    result := make( [][]int, 0);\\n    \\n    sort.Slice(intervals, func(a, b int) bool {\\n        return (intervals[a][0] < intervals[b][0]) || ( (intervals[a][0] == intervals[b][0]) && (intervals[a][1] < intervals[b][1]) )\\n    })\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if ( len(result) == 0 ) || ( result[len(result)-1][END] < curInterval[START] ){\\n            \\n            // no overlapping\\n            result = append(result, curInterval)\\n            \\n        }else{\\n            \\n            // has overlapping\\n            // merge with previous interval\\n            result[len(result)-1][END] = max( result[len(result)-1][END], curInterval[END] )\\n        }\\n        \\n    }\\n    \\n    return result\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        // predefined constant for start (left endpoint), as well as end ( right endpoint)\\n        const int START=0, END=1;   \\n        \\n        vector< vector<int> > result;\\n    \\n        // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        sort( intervals.begin(), intervals.end() );\\n        \\n        for( auto const &curInterval : intervals ){\\n            \\n            if ( (result.size() == 0 ) || (result.back()[END] < curInterval[START] ) ){\\n                // no overlapping\\n                result.push_back( curInterval );\\n                \\n            }else{\\n                // has overlapping\\n                // merge with previous interval\\n                result.back()[END] = max( result.back()[END], curInterval[END] );\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716744,
                "title": "javascript-clean-code",
                "content": "```javascript\\nvar merge = function(intervals) {\\n    if(!intervals.length) return [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    const result = [intervals[0]];\\n    \\n    for(let [start, end] of intervals) {\\n        const endPrev = result.at(-1)[1]\\n        if(start <= endPrev) result.at(-1)[1] = Math.max(end, endPrev);\\n        else result.push([start, end]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar merge = function(intervals) {\\n    if(!intervals.length) return [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    const result = [intervals[0]];\\n    \\n    for(let [start, end] of intervals) {\\n        const endPrev = result.at(-1)[1]\\n        if(start <= endPrev) result.at(-1)[1] = Math.max(end, endPrev);\\n        else result.push([start, end]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21488,
                "title": "my-easy-c-solution",
                "content": "    static bool comp(const Interval& a, const Interval& b){\\n        return a.start < b.start;\\n    }\\n    vector<Interval> merge(vector<Interval> &intervals) {\\n        vector<Interval> result;\\n        if(intervals.empty()){\\n            return result;\\n        }\\n        sort(intervals.begin(), intervals.end(), comp);\\n        result.push_back(intervals[0]);\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i].start <= result.back().end){\\n                Interval temp(result.back().start, max(result.back().end, intervals[i].end));\\n                result.pop_back();\\n                result.push_back(temp);\\n            }\\n            else{\\n                result.push_back(intervals[i]);\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    static bool comp(const Interval& a, const Interval& b){\\n        return a.start < b.start;\\n    }\\n    vector<Interval> merge(vector<Interval> &intervals) {\\n        vector<Interval> result;\\n        if(intervals.empty()){\\n            return result;\\n        }\\n        sort(intervals.begin(), intervals.end(), comp);\\n        result.push_back(intervals[0]);\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i].start <= result.back().end){\\n                Interval temp(result.back().start, max(result.back().end, intervals[i].end));\\n                result.pop_back();\\n                result.push_back(temp);\\n            }\\n            else{\\n                result.push_back(intervals[i]);\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1528228,
                "title": "multiple-c-solution",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n# Method 01\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        \\n        sort(v.begin(),v.end());\\n        vector<vector<int>>ans;\\n   \\n        ans.push_back(v[0]);\\n\\n        int first = ans[0][0];\\n        int last = ans[0][1];\\n        int k=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n\\n            if(v[i][0]<=last)\\n            {\\n                ans[k][1] = max(v[i][1],last);\\n                ans[k][0] =  min(v[i][0],first);\\n                first = ans[k][0];\\n                last = ans[k][1];\\n            }\\n            else{\\n\\n                vector<int>temp;\\n                temp.push_back(v[i][0]);\\n                temp.push_back(v[i][1]);\\n\\n                ans.push_back(temp);\\n\\n                k++;\\n                first =  ans[k][0];\\n                last =  ans[k][1];\\n\\n            }\\n    }\\n            return ans;\\n    }\\n\\n};\\n```\\n# Method 02\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        int n = intervals.size();\\n        ans.push_back({intervals[0][0],intervals[0][1]});\\n       \\n        if(n==1)\\n            return ans;\\n        \\n        int a=0, b=0, i=1;\\n        while(i<n){\\n            if(ans[a][1]>=intervals[i][0]){\\n                ans[a][1]= max(ans[a][1],intervals[i][1]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n                a++;\\n            }\\n        }\\n        return ans;     \\n    }\\n};\\n```\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        \\n        sort(v.begin(),v.end());\\n        vector<vector<int>>ans;\\n   \\n        ans.push_back(v[0]);\\n\\n        int first = ans[0][0];\\n        int last = ans[0][1];\\n        int k=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n\\n            if(v[i][0]<=last)\\n            {\\n                ans[k][1] = max(v[i][1],last);\\n                ans[k][0] =  min(v[i][0],first);\\n                first = ans[k][0];\\n                last = ans[k][1];\\n            }\\n            else{\\n\\n                vector<int>temp;\\n                temp.push_back(v[i][0]);\\n                temp.push_back(v[i][1]);\\n\\n                ans.push_back(temp);\\n\\n                k++;\\n                first =  ans[k][0];\\n                last =  ans[k][1];\\n\\n            }\\n    }\\n            return ans;\\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        int n = intervals.size();\\n        ans.push_back({intervals[0][0],intervals[0][1]});\\n       \\n        if(n==1)\\n            return ans;\\n        \\n        int a=0, b=0, i=1;\\n        while(i<n){\\n            if(ans[a][1]>=intervals[i][0]){\\n                ans[a][1]= max(ans[a][1],intervals[i][1]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n                a++;\\n            }\\n        }\\n        return ans;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939998,
                "title": "python-sort-and-traverse-explained",
                "content": "Let us sort our intervals by its starts and then iterate them one by one: we can have two options:\\n\\n1. The current ending point in our `ans` is less than `beg` of new interval: it means that we have a gap and we need to add new interval to our answer.\\n2. In the opposite case our intervals are overlapping, so we need to update the end for last interval we created.\\n\\n**Complexity:** time complexity is `O(n log n)` to sort intervals and space complexity is `O(n)` to keep sorted intervals and answer.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals):\\n        ans = []\\n        \\n        for beg, end in sorted(intervals):\\n            if not ans or ans[-1][1] < beg:\\n                ans += [[beg, end]]\\n            else:\\n                ans[-1][1] = max(ans[-1][1], end)\\n\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals):\\n        ans = []\\n        \\n        for beg, end in sorted(intervals):\\n            if not ans or ans[-1][1] < beg:\\n                ans += [[beg, end]]\\n            else:\\n                ans[-1][1] = max(ans[-1][1], end)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358410,
                "title": "c-brute-force-optimal-solution-commented-time-o-nlogn-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end()); // Time taken by sort() is O(NlogN)\\n        vector<vector<int>> res;\\n        for(int i=0;i<len;i++){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            // for loop inside for loop takes time of O(N^2)\\n            for(int j=i+1;j<len;j++){\\n                int c=intervals[j][0];\\n                int d=intervals[j][1];\\n                if(b>=c){ \\n                    // Comparing pairs : (a,b) & (c,d)\\n                    // Interval overlap condition example - a=3,b=7,c=5,d=9\\n                    //  Real Line---a(3)------c(5)******b(7)-------d(9)----\\n                    // (a,max(b,d)) should be inserted in result(res) vector.\\n                    // b will only get updated if there is an overlap \\n                    // so as to merge maximum number of intervals\\n                    b=max(b,d);\\n                    // i pointer should now point to the pair pointed by j \\n                    // and in next iteration of j loop, j will point to the \\n                    // pair next to the one pointed by this i\\n                    i=j;\\n                }\\n            } \\n            res.push_back({a,b});\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Optimal Solution Time O(NlogN) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res; // result vector\\n        // insert the first element into the result vector\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<len;i++){\\n            if(res.back()[1]>=intervals[i][0])\\n                // back() points to the final element of the vector.\\n                // Update the endpoint of final element of result \\n                // vector if there is an overlap with intervals[i]\\n                res.back()[1]=max(res.back()[1], intervals[i][1]);\\n            else\\n                // If no overlap, insert intervals[i]\\n                res.push_back(intervals[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end()); // Time taken by sort() is O(NlogN)\\n        vector<vector<int>> res;\\n        for(int i=0;i<len;i++){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            // for loop inside for loop takes time of O(N^2)\\n            for(int j=i+1;j<len;j++){\\n                int c=intervals[j][0];\\n                int d=intervals[j][1];\\n                if(b>=c){ \\n                    // Comparing pairs : (a,b) & (c,d)\\n                    // Interval overlap condition example - a=3,b=7,c=5,d=9\\n                    //  Real Line---a(3)------c(5)******b(7)-------d(9)----\\n                    // (a,max(b,d)) should be inserted in result(res) vector.\\n                    // b will only get updated if there is an overlap \\n                    // so as to merge maximum number of intervals\\n                    b=max(b,d);\\n                    // i pointer should now point to the pair pointed by j \\n                    // and in next iteration of j loop, j will point to the \\n                    // pair next to the one pointed by this i\\n                    i=j;\\n                }\\n            } \\n            res.push_back({a,b});\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Optimal Solution Time O(NlogN) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res; // result vector\\n        // insert the first element into the result vector\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<len;i++){\\n            if(res.back()[1]>=intervals[i][0])\\n                // back() points to the final element of the vector.\\n                // Update the endpoint of final element of result \\n                // vector if there is an overlap with intervals[i]\\n                res.back()[1]=max(res.back()[1], intervals[i][1]);\\n            else\\n                // If no overlap, insert intervals[i]\\n                res.push_back(intervals[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200549,
                "title": "faster-than-99-86-c-submissions-with-explanation",
                "content": "```\\n// There can be three cases with two intervals \\n// Casee 1:- No overlap\\n\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n\\n//  _______________\\n// | left interval |\\n// |_______________|\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // Sort the intervals so that the comparison between two intervals becomes easier \\n        sort(v.begin(),v.end());\\n        int n=v.size(),left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n        while(left<n && right<n)\\n        {\\n            // Case 1(No overlap so proceed)\\n            if(v[left][1]<v[right][0])\\n            {\\n                left=right;\\n                right++;\\n            }\\n            // Else overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                // Case 3(Full overlap)\\n                if(v[left][1]>=v[right][1])\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2(partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        // Now we\\'ll traverse the intervals again and populate the ans vector i.e the result vector\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        // Finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n// There can be three cases with two intervals \\n// Casee 1:- No overlap\\n\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n\\n//  _______________\\n// | left interval |\\n// |_______________|\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // Sort the intervals so that the comparison between two intervals becomes easier \\n        sort(v.begin(),v.end());\\n        int n=v.size(),left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n        while(left<n && right<n)\\n        {\\n            // Case 1(No overlap so proceed)\\n            if(v[left][1]<v[right][0])\\n            {\\n                left=right;\\n                right++;\\n            }\\n            // Else overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                // Case 3(Full overlap)\\n                if(v[left][1]>=v[right][1])\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2(partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        // Now we\\'ll traverse the intervals again and populate the ans vector i.e the result vector\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        // Finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733718,
                "title": "python-using-start-and-end-easy-to-understand",
                "content": "Instead of using start and end use [0] and [1]. It works\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: \\n            return []\\n        intervals.sort() #sort the list according to start index\\n        stack = [intervals[0]] #push the first element into the stack\\n        for current in intervals[1:]:\\n            if current[0] <= stack[-1][1]: #if the start of current element is less than or equal to the end of top element of stack then set\\n                #stack top element end = max( current end, stack top end)\\n                stack[-1][1] = max(current[1], stack[-1][1])\\n            else: \\n                #else append the current element into stack\\n                stack.append(current)\\n        return stack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: \\n            return []\\n        intervals.sort() #sort the list according to start index\\n        stack = [intervals[0]] #push the first element into the stack\\n        for current in intervals[1:]:\\n            if current[0] <= stack[-1][1]: #if the start of current element is less than or equal to the end of top element of stack then set\\n                #stack top element end = max( current end, stack top end)\\n                stack[-1][1] = max(current[1], stack[-1][1])\\n            else: \\n                #else append the current element into stack\\n                stack.append(current)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683624,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        if (intervals == null || intervals.Length == 0 || intervals.Length == 1)\\n            return intervals;\\n        \\n        List<int[]> res = new List<int[]>();\\n        \\n        intervals = intervals.OrderBy(x => x[0]).ToArray();\\n        \\n        int s = intervals[0][0],\\n            e = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.Length; i++)\\n            if (intervals[i][0] > e)\\n            {\\n                res.Add(new int[] { s, e });\\n                s = intervals[i][0];\\n                e = intervals[i][1];\\n            }\\n            else\\n                e = Math.Max(e, intervals[i][1]);\\n        \\n        res.Add(new int[] { s, e });\\n        \\n        return res.ToArray();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        if (intervals == null || intervals.Length == 0 || intervals.Length == 1)\\n            return intervals;\\n        \\n        List<int[]> res = new List<int[]>();\\n        \\n        intervals = intervals.OrderBy(x => x[0]).ToArray();\\n        \\n        int s = intervals[0][0],\\n            e = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.Length; i++)\\n            if (intervals[i][0] > e)\\n            {\\n                res.Add(new int[] { s, e }",
                "codeTag": "Java"
            },
            {
                "id": 3462073,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 158 videos for leetcode questions as of April 28, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\n\\nhttps://youtu.be/IuzSG0YEdXU\\n\\n---\\n\\n# Intuition\\nSort intervals with start points. It takes advantage of the fact that the intervals are sorted by start point, which allows us to avoid comparing every interval to every other interval.\\n\\n# Approach\\nThis is based on Python code. Other languages might be different.\\n\\n1. The merge method takes a list of lists as an argument. Each inner list represents an interval, and the first element of the inner list is the start point, and the second element is the end point.\\n\\n2. Check if the given list is empty, if yes, return an empty list.\\n\\n3. Initialize an empty list named merged to store the merged intervals.\\n\\n4. Sort the given list of intervals by the first element of each interval using the sort method and a lambda function.\\n\\n5. Set the variable prev to the first interval of the sorted intervals list.\\n\\n6. Iterate over the sorted intervals list, starting from the second interval.\\n\\n7. Check if the start point of the current interval is less than or equal to the end point of the previous interval.\\n\\n8. If yes, then update the end point of the previous interval with the maximum of the current interval\\'s end point and the previous interval\\'s end point.\\n9. If no, then append the previous interval to the merged list and set prev to the current interval.\\n\\n10. After the loop, append the last interval (prev) to the merged list.\\nReturn the merged list containing the merged intervals.\\n\\n# Complexity\\nThis is based on Python code. Other languages might be different.\\n\\n- Time complexity: O(n log n)\\nn is the length of the input list \\'intervals\\'. This is because the code sorts the intervals list in O(n log n) time using the built-in Python sorting algorithm, and then iterates over the sorted list once in O(n) time to merge overlapping intervals.\\n\\n- Space complexity: O(n)\\nn is the length of the input list \\'intervals\\'. This is because the code creates a new list \\'merged\\' to store the merged intervals, which can contain up to n elements if there are no overlapping intervals. Additionally, the code uses a constant amount of space to store the \\'prev\\' variable and other temporary variables, which does not depend on the size of the input.\\n\\n---\\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n---\\n\\n# Python\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        merged = []\\n        intervals.sort(key=lambda x: x[0])\\n\\n        prev = intervals[0]\\n\\n        for interval in intervals[1:]:\\n            if interval[0] <= prev[1]:\\n                prev[1] = max(prev[1], interval[1])\\n            else:\\n                merged.append(prev)\\n                prev = interval\\n        \\n        merged.append(prev)\\n\\n        return merged\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    if (!intervals || intervals.length === 0) {\\n        return [];\\n    }\\n\\n    let merged = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    let mergedInterval = intervals[0];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n\\n        if (interval[0] <= mergedInterval[1]) {\\n            mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n        } else {\\n            merged.push(mergedInterval);\\n            mergedInterval = interval;\\n        }\\n    }\\n\\n    merged.push(mergedInterval);\\n\\n    return merged;    \\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0) {\\n            return new int[0][];\\n        }\\n\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        List<int[]> merged = new ArrayList<>();\\n        int[] mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.add(mergedInterval);\\n                mergedInterval = interval; \\n            }\\n        }\\n\\n        merged.add(mergedInterval);\\n\\n        return merged.toArray(new int[merged.size()][]);        \\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) {\\n            return {};\\n        }\\n\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        vector<vector<int>> merged;\\n        vector<int> mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            const vector<int>& interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.push_back(mergedInterval);\\n                mergedInterval = interval;\\n            }\\n        }\\n\\n        merged.push_back(mergedInterval);\\n\\n        return merged;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        merged = []\\n        intervals.sort(key=lambda x: x[0])\\n\\n        prev = intervals[0]\\n\\n        for interval in intervals[1:]:\\n            if interval[0] <= prev[1]:\\n                prev[1] = max(prev[1], interval[1])\\n            else:\\n                merged.append(prev)\\n                prev = interval\\n        \\n        merged.append(prev)\\n\\n        return merged\\n```\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    if (!intervals || intervals.length === 0) {\\n        return [];\\n    }\\n\\n    let merged = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    let mergedInterval = intervals[0];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n\\n        if (interval[0] <= mergedInterval[1]) {\\n            mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n        } else {\\n            merged.push(mergedInterval);\\n            mergedInterval = interval;\\n        }\\n    }\\n\\n    merged.push(mergedInterval);\\n\\n    return merged;    \\n};\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0) {\\n            return new int[0][];\\n        }\\n\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        List<int[]> merged = new ArrayList<>();\\n        int[] mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.add(mergedInterval);\\n                mergedInterval = interval; \\n            }\\n        }\\n\\n        merged.add(mergedInterval);\\n\\n        return merged.toArray(new int[merged.size()][]);        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) {\\n            return {};\\n        }\\n\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        vector<vector<int>> merged;\\n        vector<int> mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            const vector<int>& interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.push_back(mergedInterval);\\n                mergedInterval = interval;\\n            }\\n        }\\n\\n        merged.push_back(mergedInterval);\\n\\n        return merged;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319024,
                "title": "98-96-super-easy-understand-javascript-solution-with-explains",
                "content": "```\\nvar merge = function(intervals) {\\n    if(intervals.length < 2) return intervals; \\n    intervals.sort((a,b) => a[0] - b[0]) //Arr have smaller element come first\\n    for(let i = 1; i < intervals.length; i += 1){\\n        curr = intervals[i];\\n        prev = intervals[i-1];\\n        if(curr[0] <= prev[1]){\\n            intervals[i] = [Math.min(prev[0],curr[0]), Math.max(prev[1],curr[1])]\\n            intervals.splice(i-1,1);\\n            i -= 1  // After merge, the arr become shorter\\n        }\\n    }\\n    return intervals\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    if(intervals.length < 2) return intervals; \\n    intervals.sort((a,b) => a[0] - b[0]) //Arr have smaller element come first\\n    for(let i = 1; i < intervals.length; i += 1){\\n        curr = intervals[i];\\n        prev = intervals[i-1];\\n        if(curr[0] <= prev[1]){\\n            intervals[i] = [Math.min(prev[0],curr[0]), Math.max(prev[1],curr[1])]\\n            intervals.splice(i-1,1);\\n            i -= 1  // After merge, the arr become shorter\\n        }\\n    }\\n    return intervals\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287714,
                "title": "new-c-solution-o-nlogn-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comparator( vector<int>& a, vector<int>& b )\\n    {\\n        return a[0] < b[0];\\n    }\\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        //Handle Edge cases\\n        if( intervals.empty() )\\n        {\\n            return res;\\n        }\\n        \\n        if( intervals.size() == 1 )\\n        {\\n            res.push_back( intervals[0]);\\n            return res;\\n        }\\n        \\n        //Sort the inetrvals first based on the start of interval\\n        sort( intervals.begin(), intervals.end(), comparator );\\n        \\n        //Push the first interval into the result\\n        res.push_back( intervals[0] );\\n        int i = 1;\\n        while( i < intervals.size() )\\n        {\\n            vector<int>& last = res.back();\\n            //Check for overlapping boundaries in the intervals and merge them suitably\\n            if( last[1] < intervals[i][0] )\\n            {\\n                res.push_back( intervals[i] );\\n            }\\n            else\\n            {\\n                last[1] = max( last[1], intervals[i][1] );\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comparator( vector<int>& a, vector<int>& b )\\n    {\\n        return a[0] < b[0];\\n    }\\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        //Handle Edge cases\\n        if( intervals.empty() )\\n        {\\n            return res;\\n        }\\n        \\n        if( intervals.size() == 1 )\\n        {\\n            res.push_back( intervals[0]);\\n            return res;\\n        }\\n        \\n        //Sort the inetrvals first based on the start of interval\\n        sort( intervals.begin(), intervals.end(), comparator );\\n        \\n        //Push the first interval into the result\\n        res.push_back( intervals[0] );\\n        int i = 1;\\n        while( i < intervals.size() )\\n        {\\n            vector<int>& last = res.back();\\n            //Check for overlapping boundaries in the intervals and merge them suitably\\n            if( last[1] < intervals[i][0] )\\n            {\\n                res.push_back( intervals[i] );\\n            }\\n            else\\n            {\\n                last[1] = max( last[1], intervals[i][1] );\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780416,
                "title": "c-100-east-9-lines-code-o-nlogn",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat we are going to do is first we will push the first interval in the vector and will iterate over all the other intervals in the array.\\n\\nconsidering each interval[a,b] in the array we will check if the start of the interval is smaller than the end of the last interval[x,y] present in our vector i.e. y>a\\nif it is so then we will update the end value we will update the end value y with max(y,b)\\n\\nif y!>a then we will simply push the interval in the vector\\n\\nfollow the same steps for rest of the array elements and return the vector after reaching at the end\\n\\n\\n# Dry Run:\\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\\n1 ) push(1,3) int the ans vector\\n\\n2 ) check if end point of the last interval present in the ans vector is greater than the start point of the next interval  if(ans.back()[1] >= intervals[i][0]) i.e. if(3>=2) ...if yes then update the end point of the last interval of the vector..ans.back()[1] = max(ans.back()[1] , intervals[i][1]);   i.e max(3,6)\\nnow out vector ans = {(1,6)}\\n\\nif(ans.back()[1] >= intervals[i][0]) is now true then simply push that element int ans vector\\n\\n3)follow step 2 for all other elements of interval array and return ans at the end of the program\\n\\n\\n\\n# Code\\n```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\\n    {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(ans.back()[1] >= intervals[i][0]) ans.back()[1] = max(ans.back()[1] , intervals[i][1]);\\n            else ans.push_back(intervals[i]); \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\\n    {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(ans.back()[1] >= intervals[i][0]) ans.back()[1] = max(ans.back()[1] , intervals[i][1]);\\n            else ans.push_back(intervals[i]); \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558586,
                "title": "best-and-simple-c-solution",
                "content": "Just take two pointers \"**start**\" and \"**end**\" pointing to the first index.\\nIterate through the vector:\\n\\t1. Update the **end** if the current index can merge with the \"**start**\" and \"**end**\" else\\n\\t2. Push the {start, end} into the answer, and make \"**start**\" and \"**end**\" pointing to current index.\\n\\n```\\nvector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        sort(v.begin(), v.end());\\t\\t\\n        int start = v[0][0];\\n        int end = v[0][1];        \\n\\t\\tvector<vector<int>> ans;\\n        \\n\\t\\tfor(int i=1;i<v.size();i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][0] <= end)\\n            {\\n                end = max(end, v[i][1]);\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        sort(v.begin(), v.end());\\t\\t\\n        int start = v[0][0];\\n        int end = v[0][1];        \\n\\t\\tvector<vector<int>> ans;\\n        \\n\\t\\tfor(int i=1;i<v.size();i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][0] <= end)\\n            {\\n                end = max(end, v[i][1]);\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349104,
                "title": "c-o-n-log-n-sort-by-start-time-and-merge-intervals",
                "content": "``` csharp\\nclass Interval\\n{\\n    public readonly int Start;\\n    public readonly int End;\\n    \\n    public Interval(int start, int end)\\n    {\\n        Start = start;\\n        End = end;\\n    }\\n}\\n\\npublic class Solution \\n{\\n    public int[][] Merge(int[][] input) \\n    {\\n        if(input == null || input.GetLength(0) <= 1)\\n        {\\n            return input;\\n        }\\n        \\n        List<Interval> intervals = new List<Interval>();\\n        List<int[]> result = new List<int[]>();\\n        \\n        for(int i = 0; i < input.GetLength(0); i++)\\n        {\\n            intervals.Add(new Interval(input[i][0], input[i][1]));\\n        }\\n        \\n        intervals = intervals.OrderBy(x => x.Start).ThenBy(x => x.End).ToList();\\n        \\n        int start = 0;\\n        int end = 0;        \\n        int j = 0;\\n        \\n        while(j < intervals.Count)\\n        {\\n            start = intervals[j].Start;\\n            end = intervals[j].End;\\n            j++;\\n            \\n            while(j < intervals.Count && intervals[j].Start <= end)\\n            {\\n                end = Math.Max(end, intervals[j].End);   \\n                j++;\\n            }       \\n            result.Add(new int[] { start, end});           \\n        }                \\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "``` csharp\\nclass Interval\\n{\\n    public readonly int Start;\\n    public readonly int End;\\n    \\n    public Interval(int start, int end)\\n    {\\n        Start = start;\\n        End = end;\\n    }\\n}\\n\\npublic class Solution \\n{\\n    public int[][] Merge(int[][] input) \\n    {\\n        if(input == null || input.GetLength(0) <= 1)\\n        {\\n            return input;\\n        }\\n        \\n        List<Interval> intervals = new List<Interval>();\\n        List<int[]> result = new List<int[]>();\\n        \\n        for(int i = 0; i < input.GetLength(0); i++)\\n        {\\n            intervals.Add(new Interval(input[i][0], input[i][1]));\\n        }\\n        \\n        intervals = intervals.OrderBy(x => x.Start).ThenBy(x => x.End).ToList();\\n        \\n        int start = 0;\\n        int end = 0;        \\n        int j = 0;\\n        \\n        while(j < intervals.Count)\\n        {\\n            start = intervals[j].Start;\\n            end = intervals[j].End;\\n            j++;\\n            \\n            while(j < intervals.Count && intervals[j].Start <= end)\\n            {\\n                end = Math.Max(end, intervals[j].End);   \\n                j++;\\n            }       \\n            result.Add(new int[] { start, end});           \\n        }                \\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651683,
                "title": "solution-swift-merge-intervals",
                "content": "```swift\\nclass Solution {\\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        \\n        let sorted = intervals.sorted(by: {$0[0] < $1[0]})\\n        guard let first = sorted.first else { return [[Int]]() }\\n\\n        var merged = [first]\\n        \\n        for current in sorted {\\n            guard let last = merged.last else { continue }\\n\\n            let prev = last[0]\\n            let penult = last[1]\\n            \\n            let start = current[0], end = current[1]\\n            \\n            if penult >= start {\\n                merged[merged.count - 1] = [prev, max(penult, end)]\\n            } else {\\n                merged.append(current)\\n            }\\n        }\\n        return merged\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        \\n        let sorted = intervals.sorted(by: {$0[0] < $1[0]})\\n        guard let first = sorted.first else { return [[Int]]() }\\n\\n        var merged = [first]\\n        \\n        for current in sorted {\\n            guard let last = merged.last else { continue }\\n\\n            let prev = last[0]\\n            let penult = last[1]\\n            \\n            let start = current[0], end = current[1]\\n            \\n            if penult >= start {\\n                merged[merged.count - 1] = [prev, max(penult, end)]\\n            } else {\\n                merged.append(current)\\n            }\\n        }\\n        return merged\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325159,
                "title": "c-solution-with-easy-complete-explaination",
                "content": "**Time complexity - O(n logn) + O(n)**  \\n **space complexity - O(n)** \\n \\n steps:\\n 1. sort the given intervals on the basis of the starting point \\n    suppose- [3,5] 3 is the starting point(0) and  5 is the ending point(1) \\n2. After sorting there will be 3 cases coming up:\\n   case 1:\\n   If there is no overlapping in the intervals. in this take the max of the       ending points\\n   case 2:\\n   if there is partial overapping\\n   case 3 : \\n   when there is no overlapping\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n            \\n        vector<vector<int>> mergedIntervals;\\n        if(intervals.size()==0)\\n            return mergedIntervals;\\n        \\n        sort(intervals.begin(),intervals.end());// sort\\n        vector<int> pre_interval = intervals[0];\\n        // 0 is starting point\\n        //1 is ending point\\n        \\n        for(auto interval:intervals)\\n        {\\n            if(interval[0]<=pre_interval[1])// means there is overlapping of intervals\\n            {\\n                pre_interval[1]=max(interval[1],pre_interval[1]); // need to check which has max ending points hence we will make ending point of pre_interval to max\\n            }\\n            else\\n            { // if there is no overlapping\\n                mergedIntervals.push_back(pre_interval); // simplely push pre-interval to mergedintervals vector\\n                pre_interval=interval;\\n            }     \\n        }\\n        \\n        mergedIntervals.push_back(pre_interval);\\n        return mergedIntervals;\\n    }\\n};\\n```\\n***Please upvote if you like the solution and comment if have doubts***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n            \\n        vector<vector<int>> mergedIntervals;\\n        if(intervals.size()==0)\\n            return mergedIntervals;\\n        \\n        sort(intervals.begin(),intervals.end());// sort\\n        vector<int> pre_interval = intervals[0];\\n        // 0 is starting point\\n        //1 is ending point\\n        \\n        for(auto interval:intervals)\\n        {\\n            if(interval[0]<=pre_interval[1])// means there is overlapping of intervals\\n            {\\n                pre_interval[1]=max(interval[1],pre_interval[1]); // need to check which has max ending points hence we will make ending point of pre_interval to max\\n            }\\n            else\\n            { // if there is no overlapping\\n                mergedIntervals.push_back(pre_interval); // simplely push pre-interval to mergedintervals vector\\n                pre_interval=interval;\\n            }     \\n        }\\n        \\n        mergedIntervals.push_back(pre_interval);\\n        return mergedIntervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186514,
                "title": "python3-line-sweep-for-merge-interval-and-employee-free-time",
                "content": "`Merge Interval` and `Employee Free Time` are opposite to each other. \\nThe former computes the `occupied time`; the latter computes the `free time`. \\n\\nBoth questions can be solved using line-sweep method. \\n\\nSuppose `schedule = [[1,3],[6,7],[2,4],[2,5],[9,12]]`, \\nwe can represent it as a sorted array: `1( 2( 2( 3) 4) 5) 6( 7) 9( 12)`\\nIgnoring numbers, we have a schedule structure like `((())),(),()`\\nThe merged interval would be `(--),(--),(--)`\\nThe free time would be `(),--(),--()`\\n\\n``` python\\n\"\"\" Merge Interval\"\"\"\\nclass Solution:\\n    def merge(self, intervals):        \\n        START, END = 0, 1   # open first at same time\\n        events = []\\n        for iv in intervals:\\n            events.append((iv.start, START))\\n            events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        for i, (t, ev) in enumerate(events):\\n            if balance == 0: prev = t\\n            balance += (1 if ev == START else -1)\\n            if balance == 0: res.append(Interval(prev, t))\\n                \\n        return res\\n```\\n\\n``` python\\n\"\"\" Free Time\"\"\"\\nclass Solution:\\n    def employeeFreeTime(self, schedule):\\n        START, END = 0, 1    # open first at same time\\n        events = []\\n        for emp in schedule:\\n            for iv in emp:\\n                events.append((iv.start, START))\\n                events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        prev = None\\n        for t, event in events:\\n            if balance == 0 and prev is not None: res.append(Interval(prev, t))\\n            balance += (1 if event == START else -1)\\n            if balance == 0: prev = t\\n        return res\\n```",
                "solutionTags": [],
                "code": "``` python\\n\"\"\" Merge Interval\"\"\"\\nclass Solution:\\n    def merge(self, intervals):        \\n        START, END = 0, 1   # open first at same time\\n        events = []\\n        for iv in intervals:\\n            events.append((iv.start, START))\\n            events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        for i, (t, ev) in enumerate(events):\\n            if balance == 0: prev = t\\n            balance += (1 if ev == START else -1)\\n            if balance == 0: res.append(Interval(prev, t))\\n                \\n        return res\\n```\n``` python\\n\"\"\" Free Time\"\"\"\\nclass Solution:\\n    def employeeFreeTime(self, schedule):\\n        START, END = 0, 1    # open first at same time\\n        events = []\\n        for emp in schedule:\\n            for iv in emp:\\n                events.append((iv.start, START))\\n                events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        prev = None\\n        for t, event in events:\\n            if balance == 0 and prev is not None: res.append(Interval(prev, t))\\n            balance += (1 if event == START else -1)\\n            if balance == 0: prev = t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520772,
                "title": "c-java-python-javascript-array-tc-o-n-log-n-easy-to-understand-solution",
                "content": "# Intuition:\\nThe idea is to sort the intervals by their start time, and then merge them by checking if the end time of the previous interval is greater than or equal to the start time of the current interval. If so, we merge the intervals by updating the end time of the previous interval to be the maximum of its current end time and the end time of the current interval. Otherwise, we add the previous interval to the answer vector and update the previous interval to be the current interval.\\n\\n# Approach:\\n1. Sort the intervals based on their start time.\\n2. Initialize an empty vector of vectors to store the merged intervals.\\n3. Initialize a temporary vector to store the first interval from the sorted input vector.\\n4. Iterate over the input intervals from the second interval.\\n5. If the start time of the current interval is less than or equal to the end time of the temporary interval, update the end time of the temporary interval to be the maximum of its current end time and the end time of the current interval.\\n6. Otherwise, add the temporary interval to the answer vector and update the temporary interval to be the current interval.\\n7. After the loop, add the last temporary interval to the answer vector.\\n8. Return the answer vector.\\n# Complexity:\\n- Time Complexity:\\nThe time complexity of this approach is O(n log n) due to the sorting operation, where n is the number of intervals. The for loop takes O(n) time to iterate over all intervals, and the inner operations take constant time.\\n\\n- Space Complexity:\\nThe space complexity of this approach is O(n) to store the answer vector and the temporary vector.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        if(intervals.size()==0){\\n            return ans;\\n        }\\n        vector <int> temp = intervals[0];\\n        for(int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]<=temp[1]){\\n                temp[1]=max(temp[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(temp);\\n                temp=intervals[i];\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# Java\\n```java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> ans = new ArrayList<>();\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n\\n        if (intervals.length == 0) {\\n            return ans.toArray(new int[0][]);\\n        }\\n\\n        int[] temp = intervals[0];\\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][0] <= temp[1]) {\\n                temp[1] = Math.max(temp[1], intervals[i][1]);\\n            } else {\\n                ans.add(temp);\\n                temp = intervals[i];\\n            }\\n        }\\n        ans.add(temp);\\n\\n        return ans.toArray(new int[0][]);\\n    }\\n}\\n```\\n---\\n# Python\\n```py\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        intervals.sort()\\n\\n        if len(intervals) == 0:\\n            return ans\\n\\n        temp = intervals[0]\\n        for interval in intervals:\\n            if interval[0] <= temp[1]:\\n                temp[1] = max(temp[1], interval[1])\\n            else:\\n                ans.append(temp)\\n                temp = interval\\n        ans.append(temp)\\n\\n        return ans\\n\\n```\\n---\\n# JavaScript\\n```js\\nvar merge = function(intervals) {\\n    let ans = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    if (intervals.length === 0) {\\n        return ans;\\n    }\\n\\n    let temp = intervals[0];\\n    for (let i = 0; i < intervals.length; i++) {\\n        if (intervals[i][0] <= temp[1]) {\\n            temp[1] = Math.max(temp[1], intervals[i][1]);\\n        } else {\\n            ans.push(temp);\\n            temp = intervals[i];\\n        }\\n    }\\n    ans.push(temp);\\n\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        if(intervals.size()==0){\\n            return ans;\\n        }\\n        vector <int> temp = intervals[0];\\n        for(int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]<=temp[1]){\\n                temp[1]=max(temp[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(temp);\\n                temp=intervals[i];\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> ans = new ArrayList<>();\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n\\n        if (intervals.length == 0) {\\n            return ans.toArray(new int[0][]);\\n        }\\n\\n        int[] temp = intervals[0];\\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][0] <= temp[1]) {\\n                temp[1] = Math.max(temp[1], intervals[i][1]);\\n            } else {\\n                ans.add(temp);\\n                temp = intervals[i];\\n            }\\n        }\\n        ans.add(temp);\\n\\n        return ans.toArray(new int[0][]);\\n    }\\n}\\n```\n```py\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        intervals.sort()\\n\\n        if len(intervals) == 0:\\n            return ans\\n\\n        temp = intervals[0]\\n        for interval in intervals:\\n            if interval[0] <= temp[1]:\\n                temp[1] = max(temp[1], interval[1])\\n            else:\\n                ans.append(temp)\\n                temp = interval\\n        ans.append(temp)\\n\\n        return ans\\n\\n```\n```js\\nvar merge = function(intervals) {\\n    let ans = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    if (intervals.length === 0) {\\n        return ans;\\n    }\\n\\n    let temp = intervals[0];\\n    for (let i = 0; i < intervals.length; i++) {\\n        if (intervals[i][0] <= temp[1]) {\\n            temp[1] = Math.max(temp[1], intervals[i][1]);\\n        } else {\\n            ans.push(temp);\\n            temp = intervals[i];\\n        }\\n    }\\n    ans.push(temp);\\n\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454316,
                "title": "java-treemap-simple-solution-with-explanation",
                "content": "The idea is to use both starts and ends as keys, but +1 for a start and -1 for an end as values. So, going by sorted keys and gathering sum of values we will know for sure when current interval finishes (we have + 1 at start and -1 at finish -> 0 when interval finishes). \\nIn case of overlaps starts will sum up (3 starts crossed -> 3) and eventually at the last finish(3 finishes crossed -> 3 -3 = 0) it became 0 nevertheless. \\n\\nComplexity is n(log(n)) due to the nature of tree map.\\n\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> list = new LinkedList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] interval : intervals) {\\n            map.put(interval[0], map.getOrDefault(interval[0], 0) + 1);\\n            map.put(interval[1], map.getOrDefault(interval[1], 0) - 1);\\n        }\\n        \\n        int activeInterval = 0;\\n        int start = 0;\\n        for (int key: map.keySet()) {\\n            if (activeInterval == 0) {\\n                start = key;\\n            }    \\n            activeInterval += map.get(key);\\n            if (activeInterval == 0) {\\n                list.add(new int[]{start, key});\\n            }\\n        }\\n        \\n        return listToArray(list);\\n    }\\n    \\n    private int[][] listToArray(List<int[]> list) {\\n        int[][] result = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            result[i] = list.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> list = new LinkedList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] interval : intervals) {\\n            map.put(interval[0], map.getOrDefault(interval[0], 0) + 1);\\n            map.put(interval[1], map.getOrDefault(interval[1], 0) - 1);\\n        }\\n        \\n        int activeInterval = 0;\\n        int start = 0;\\n        for (int key: map.keySet()) {\\n            if (activeInterval == 0) {\\n                start = key;\\n            }    \\n            activeInterval += map.get(key);\\n            if (activeInterval == 0) {\\n                list.add(new int[]{start, key});\\n            }\\n        }\\n        \\n        return listToArray(list);\\n    }\\n    \\n    private int[][] listToArray(List<int[]> list) {\\n        int[][] result = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            result[i] = list.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438042,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n\\t\\t\\treturn intervals;\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n\\t\\tfor (int[] interval : intervals) {\\n            // if list is empty or does not overlap with the previous, just append\\n            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {\\n                result.add(interval);\\n            } else {\\n                // if overlap, merge the current and previous intervals\\n                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);\\n            }\\n\\t\\t}\\n\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n\\t\\t\\treturn intervals;\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n\\t\\tfor (int[] interval : intervals) {\\n            // if list is empty or does not overlap with the previous, just append\\n            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {\\n                result.add(interval);\\n            } else {\\n                // if overlap, merge the current and previous intervals\\n                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);\\n            }\\n\\t\\t}\\n\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928341,
                "title": "easy-js-solution",
                "content": "```\\nvar merge = function(intervals) {\\n    if (intervals.length == 0) return [];\\n    \\n    intervals.sort((a,b) => a[0] - b[0]);\\n    let stack = [];\\n    stack.push(intervals[0]);\\n    \\n    for (let i = 1; i < intervals.length; i++) {\\n        let prev = stack.pop();\\n        let cur = intervals[i];\\n        if (prev[1] >= cur[0]) {\\n            stack.push( [prev[0], Math.max(prev[1], cur[1])] );\\n        } else {\\n            stack.push(prev, cur);\\n        }\\n    }\\n    \\n    return stack;\\n    // Time Complexity: O(Nlog(N))\\n    // Space Complexity: O(N)\\n};\\n\\n// (1) [[1,3], [2,6]] => [[1,6]]\\n// (2) [[1,4],[2,3]] => [[1,4]]\\n// Two possible cases to perform merger:\\n// 1st case: we merge two arrays and obtain a bigger interval\\n// 2nd case: one array absorbs another array and the size doesn\\'t change.\\n// Therefore, to cover both cases, when we merge two arrays, we perform the following:\\n// [start of first arr, max(end of first arr, end of second arr)]\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    if (intervals.length == 0) return [];\\n    \\n    intervals.sort((a,b) => a[0] - b[0]);\\n    let stack = [];\\n    stack.push(intervals[0]);\\n    \\n    for (let i = 1; i < intervals.length; i++) {\\n        let prev = stack.pop();\\n        let cur = intervals[i];\\n        if (prev[1] >= cur[0]) {\\n            stack.push( [prev[0], Math.max(prev[1], cur[1])] );\\n        } else {\\n            stack.push(prev, cur);\\n        }\\n    }\\n    \\n    return stack;\\n    // Time Complexity: O(Nlog(N))\\n    // Space Complexity: O(N)\\n};\\n\\n// (1) [[1,3], [2,6]] => [[1,6]]\\n// (2) [[1,4],[2,3]] => [[1,4]]\\n// Two possible cases to perform merger:\\n// 1st case: we merge two arrays and obtain a bigger interval\\n// 2nd case: one array absorbs another array and the size doesn\\'t change.\\n// Therefore, to cover both cases, when we merge two arrays, we perform the following:\\n// [start of first arr, max(end of first arr, end of second arr)]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21560,
                "title": "fast-ana-simple-java-code",
                "content": "\\n The idea is to sort intervals based on start and iterate all itervals to merge them if:\\n\\n    curr.end >= iter.start\\n\\nThe time complexity is : sort nO(logn)+ merge: O(n) = nO(logn)\\n\\nNo Extra space except necessary result : )\\n\\n       public class Solution {\\n            public List<Interval> merge(List<Interval> intervals) {\\n                List<Interval> res = new LinkedList<Interval>();\\n                if(intervals.size()<2) return intervals;\\n                Collections.sort(intervals, new Comparator<Interval>() {\\n                @Override\\n                    public int compare(Interval o1, Interval o2) {\\n                        return o1.start-o2.start;\\n                    }\\n                });\\n                Interval curr = intervals.get(0);\\n                for(Interval iter: intervals) {\\n                    if(curr.end >= iter.start) {\\n                        curr.end = Math.max(curr.end,iter.end);\\n                    }else {\\n                        res.add(curr);\\n                        curr = iter;\\n                    }\\n                }\\n                res.add(curr);\\n                return res;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public List<Interval> merge(List<Interval> intervals) {\\n                List<Interval> res = new LinkedList<Interval>();\\n                if(intervals.size()<2) return intervals;\\n                Collections.sort(intervals, new Comparator<Interval>() {\\n                @Override\\n                    public int compare(Interval o1, Interval o2) {\\n                        return o1.start-o2.start;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3732852,
                "title": "most-optimal-solution-with-explanation-c-and-java-code",
                "content": "\\n\\n# Approach\\n- First, the intervals are sorted in ascending order based on their start times using the sort function. This is important for efficient merging.\\n\\n- A new vector called ans is created to store the merged intervals.\\n\\n- The solution iterates through each interval in the sorted intervals array.\\n\\n- If ans is empty or the start time of the current interval is greater than the end time of the last interval in ans, it means there is no overlap. In this case, the current interval is added to ans as a new non-overlapping interval.\\n\\n- If there is an overlap, the end time of the last interval in ans is updated to be the maximum of the current interval\\'s end time and the end time of the last interval in ans. This ensures that the merged interval covers the maximum range.\\n\\n- After iterating through all intervals, the function returns the ans vector, which contains the merged non-overlapping intervals.\\n\\nOverall, the solution works by sorting the intervals based on start times and then merging them iteratively, updating the end time as needed. This approach ensures that all overlapping intervals are merged, resulting in a set of non-overlapping intervals that cover the entire input array.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn + n)\\n\\n- Space complexity:\\nO(1). O(n) to store the answer\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for(int i = 0; i< intervals.size(); i++){\\n            if(ans.empty() || intervals[i][0]>ans.back()[1]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else {\\n                ans.back()[1] = max(intervals[i][1], ans.back()[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for (int[] interval : intervals) {\\n            if (ans.isEmpty() || interval[0] > ans.get(ans.size() - 1)[1]) {\\n                ans.add(interval);\\n            } else {\\n                ans.get(ans.size() - 1)[1] = Math.max(interval[1], ans.get(ans.size() - 1)[1]);\\n            }\\n        }\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for(int i = 0; i< intervals.size(); i++){\\n            if(ans.empty() || intervals[i][0]>ans.back()[1]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else {\\n                ans.back()[1] = max(intervals[i][1], ans.back()[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for (int[] interval : intervals) {\\n            if (ans.isEmpty() || interval[0] > ans.get(ans.size() - 1)[1]) {\\n                ans.add(interval);\\n            } else {\\n                ans.get(ans.size() - 1)[1] = Math.max(interval[1], ans.get(ans.size() - 1)[1]);\\n            }\\n        }\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311657,
                "title": "simplest-way-to-solve-easy-java-code-o-nlogn",
                "content": "class Solution {\\n\\n    public int[][] merge(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (o1,o2)->Integer.compare(o1[0],o2[0]));          //sort the array on the basis of first interval\\n        ArrayList<int[]> list = new ArrayList<>();                              //to store the merge intervals\\n        int start = intervals[0][0];                                            //initialize start and end by the interval of the first row\\n        int end = intervals[0][1];\\n        \\n        for(int i=1;i<intervals.length;i++){                    //initialize i by 1, zeorth index intervals  already stored in start & end\\n           int s = intervals[i][0];                             //now store the intervals to compare with the previous one\\n            int e = intervals[i][1];\\n            \\n            if(s<=end){                                         //Now compare if the start (s) interval is less than the previous end interval then \\n                end=Math.max(end,e);                            //merge them, means update our end by the greater value of the end interval\\n            }else{                                              //if not means that interval is not overlapping in the current interval               \\n                list.add(new int[]{start,end});                 //add that previous merged interval into list and update start & end by the current intervals\\n                start = s;\\n                end = e;\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});                         //Don\\'t forget to add the last updated interval\\n        \\n        // int[][] res = new int[list.size()][2];               //we have to return the ans int 2D array format, you can do this or can also return directly\\n        // int i=0;\\n        // for(int[] ans : list){\\n        //     res[i] = ans;\\n        //     i++;\\n        // }\\n        \\n        return list.toArray(new int[list.size()][2]);            //by using toArray in built function BOTH are correct!\\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[][] merge(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (o1,o2)->Integer.compare(o1[0],o2[0]));          //sort the array on the basis of first interval\\n        ArrayList<int[]> list = new ArrayList<>();                              //to store the merge intervals\\n        int start = intervals[0][0];                                            //initialize start and end by the interval of the first row\\n        int end = intervals[0][1];\\n        \\n        for(int i=1;i<intervals.length;i++){                    //initialize i by 1, zeorth index intervals  already stored in start & end\\n           int s = intervals[i][0];                             //now store the intervals to compare with the previous one\\n            int e = intervals[i][1];\\n            \\n            if(s<=end){                                         //Now compare if the start (s) interval is less than the previous end interval then \\n                end=Math.max(end,e);                            //merge them, means update our end by the greater value of the end interval\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1805268,
                "title": "go-clean-code-with-explanation-and-visual-10ms-100",
                "content": "Hello Gophers!\\n\\n\\n## [Problem: Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n\\n> Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\\n\\nWe want to merge all overlapping intervals, here is a quick example:\\n\\nParams: `[][]int{{x1, y1}, {x2, y2}, {x3, y3}}`  \\n```\\n|-----------|\\nx1          y1\\n     |-----------|\\n     x2          y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\\n\\nAs you can see, the two first intervals `{x1, y1}` and `{x2, y2}` are overlapping (`{x2, y1}`), so we need to merge them.\\n\\nResponse: `[][]int{{x1, y2}, {x3, y3}}`  \\n```\\n|----------------|\\nx1              y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\\n\\nThe goal is to have a slice (array) of non-overlapping intervals.\\n\\n### Constraints\\n\\n1. `1 <= intervals.length <= 104`\\n2. `intervals[i].length == 2`\\n3. `0 <= starti <= endi <= 104`\\n\\n\\n## Definitions\\n\\nAn interval `[x, y]` is \"overlapping\" with the interval `[a, b]` if `x` <= `b` && `y` >= `a` (or `y` >= `a` && `x` >= `b`):\\n\\n```\\n|-----------|           |          |-----------|\\nx           y           |          x           y \\n     |-----------|      |     |-----------| \\n     a           b      |     a           b \\n```\\n\\nAn interval `[x, y]` is \"completely overlapping\" with the interval `[a, b]` if `x` <= `a` && `y` >= `b`:\\n\\n```\\n|----------------|\\nx                y\\n     |-----|\\n     a     b\\n```\\n\\n\\n## Algorithm\\n\\nThe algorithm is simple, let\\'s say an interval has two items `{x, y}`:\\n1. Sort the slice (array) of intervals `intervals`\\n2. We create a new slice of intervals (from the first interval of `intervals`) nammed `mergedIntervals` (it will be the returned value)\\n3. We iterate on every items (except the first one) of the `intervals` slice (let\\'s call it `interval`)  \\nand we compare it with the last item of the `mergedIntervals` slice (let\\'s call it `top`)\\n\\t4. **If the `interval` \"completely overlap\" `top`**: change `interval` for `top`\\n\\t5. **Else if`interval` \"overlap\" (but not completely) `top`**: change the `y` value of `interval` for the `y` value of `top`\\n\\t6. **Else**: do nothing\\n\\n### Solution (code)\\n\\nTime: `O(nlogn)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(n)\\nfunc merge(intervals [][]int) [][]int {\\n    if len(intervals) <= 1 {\\n        return intervals\\n    }\\n\\n\\t// Time: O(nlogn)\\n    sortIntervals(intervals)\\n    \\n\\t// Space: O(n)\\n    mergedIntervals := make([][]int, 0, len(intervals))\\n    mergedIntervals = append(mergedIntervals, intervals[0])\\n\\n\\t// Time: O(n)\\n    for _, interval := range intervals[1:] {        \\n        if top := mergedIntervals[len(mergedIntervals)-1]; interval[0] > top[1] {\\n            mergedIntervals = append(mergedIntervals, interval)\\n        } else if interval[1] > top[1] {\\n            top[1] = interval[1]\\n        }\\n    }\\n    \\n    return mergedIntervals\\n}\\n\\n// If an interval is {x, y},\\n// sortIntervals sorts the intervals by their \"x\" value.\\n// Time: O(nlogn)\\n// Space: O(1)\\nfunc sortIntervals(intervals [][]int) {\\n\\t// Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n}\\n```\\n\\n## Example\\n\\n`intervals`: `[][]int{{1, 4}, {0, 3}, {5, 7}, {1, 2}}`  \\n```\\n    |---------------|\\n    1               4\\n|--------------|\\n0              3\\n\\t                      |-----------|\\n                          5           7\\n    |------|\\n    1      2\\n```\\n\\n`intervals` sorted with `sortIntervals(...)`: `[][]int{{0, 3}, {1, 4}, {1, 2}, {5, 7}}`  \\n```\\n|--------------|\\n0              3\\n    |---------------|\\n    1               4\\n    |------|\\n    1      2\\n\\t                      |-----------|\\n                          5           7\\n```\\n\\n`mergedIntervals` creation with the first item of `intervals`: `[][]int{{0, 3}}`  \\n\\n```\\n|--------------|\\n0              3\\n```\\n\\n`mergedIntervals` after second `interval` `{1, 4}`: `[][]int{{0, 4}}`  (`{0, 3}` overlaps `{1, 4}`)\\n\\n```\\n|-------------------|\\n0                   4\\n```\\n\\n`mergedIntervals` after third `interval` `{1, 2}`: `[][]int{{0, 4}}`    (`{0, 4}` completely overlaps `{1, 4}`)\\n\\n```\\n|-------------------|\\n0                   4\\n```\\n\\n`mergedIntervals` after fourth `interval` `{5, 7}`: `[][]int{{0, 4}, {5, 7}}`   (no overlapping)\\n\\n```\\n|-------------------|\\n0                   4\\n\\t                      |-----------|\\n                          5           7\\n```\\n\\n## Follow-up\\n\\nA way to not have `O(n)` as space complexity would be to update the intervals sent in params (instead of creating a new one).\\n\\n## Similar Questions\\n\\n1. [[Medium] 56. Merge Intervals](https://leetcode.com/problems/merge-intervals/discuss/1805268/Go-Clean-Code-with-explanation-and-visual-(10ms-100)) **(this problem)**\\n2. [[Easy] 495. Teemo Attacking](https://leetcode.com/problems/teemo-attacking/discuss/1805603/Go-Clean-code-with-comments-(30ms-98))\\n3. [[Medium] 57. Insert Interval](https://leetcode.com/problems/insert-interval/discuss/1807161/Go-Clean-Code-with-visual-(1ms-100))\\n4. [[Medium] 986. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/discuss/1823039/Go-Clean-Code-with-explanation-and-visual-(10ms-100))\\n5. [[Easy] 252. Meeting Rooms](https://leetcode.com/problems/meeting-rooms/discuss/1512776/Go-Meeting-Rooms-Clean-solution)\\n6. [[Medium] 253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/1826838/Go-Multiple-Solutions-(0ms-100)) \\n7. [[Medium] 435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/discuss/1843676/Go-Clean-solution-(185ms-100))\\n8. [[Medium] 763. Partition Labels](https://leetcode.com/problems/partition-labels/discuss/2027004/Go-Merge-and-Sort-Intervals-0ms-(100))\\n9. [[Medium] Single-Threaded CPU](https://leetcode.com/problems/single-threaded-cpu/)\\n10. [[Hard] 759. Employee Free Time](https://leetcode.com/problems/employee-free-time/)\\n\\nI hope it helped! :)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n|-----------|\\nx1          y1\\n     |-----------|\\n     x2          y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\n```\\n|----------------|\\nx1              y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\n```\\n|-----------|           |          |-----------|\\nx           y           |          x           y \\n     |-----------|      |     |-----------| \\n     a           b      |     a           b \\n```\n```\\n|----------------|\\nx                y\\n     |-----|\\n     a     b\\n```\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(n)\\nfunc merge(intervals [][]int) [][]int {\\n    if len(intervals) <= 1 {\\n        return intervals\\n    }\\n\\n\\t// Time: O(nlogn)\\n    sortIntervals(intervals)\\n    \\n\\t// Space: O(n)\\n    mergedIntervals := make([][]int, 0, len(intervals))\\n    mergedIntervals = append(mergedIntervals, intervals[0])\\n\\n\\t// Time: O(n)\\n    for _, interval := range intervals[1:] {        \\n        if top := mergedIntervals[len(mergedIntervals)-1]; interval[0] > top[1] {\\n            mergedIntervals = append(mergedIntervals, interval)\\n        } else if interval[1] > top[1] {\\n            top[1] = interval[1]\\n        }\\n    }\\n    \\n    return mergedIntervals\\n}\\n\\n// If an interval is {x, y},\\n// sortIntervals sorts the intervals by their \"x\" value.\\n// Time: O(nlogn)\\n// Space: O(1)\\nfunc sortIntervals(intervals [][]int) {\\n\\t// Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n}\\n```\n```\\n    |---------------|\\n    1               4\\n|--------------|\\n0              3\\n\\t                      |-----------|\\n                          5           7\\n    |------|\\n    1      2\\n```\n```\\n|--------------|\\n0              3\\n    |---------------|\\n    1               4\\n    |------|\\n    1      2\\n\\t                      |-----------|\\n                          5           7\\n```\n```\\n|--------------|\\n0              3\\n```\n```\\n|-------------------|\\n0                   4\\n```\n```\\n|-------------------|\\n0                   4\\n```\n```\\n|-------------------|\\n0                   4\\n\\t                      |-----------|\\n                          5           7\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912536,
                "title": "100-fastest-swift-solution-time-o-n-log-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(n)), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n    \\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [] }\\n        var intervals = intervals.sorted(by: { $0[0] < $1[0] })\\n        \\n        var ans = [[Int]]()\\n        var start = intervals[0][0]\\n        var end = intervals[0][1]\\n        \\n        for interval in intervals {\\n            guard end < interval[0] else {\\n                end = max(end, interval[1])\\n                continue\\n            }\\n            ans.append([start, end])\\n            start = interval[0]\\n            end = interval[1]\\n        }\\n        \\n        ans.append([start, end])\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(n)), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n    \\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [] }\\n        var intervals = intervals.sorted(by: { $0[0] < $1[0] })\\n        \\n        var ans = [[Int]]()\\n        var start = intervals[0][0]\\n        var end = intervals[0][1]\\n        \\n        for interval in intervals {\\n            guard end < interval[0] else {\\n                end = max(end, interval[1])\\n                continue\\n            }\\n            ans.append([start, end])\\n            start = interval[0]\\n            end = interval[1]\\n        }\\n        \\n        ans.append([start, end])\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810276,
                "title": "simple-java-solution",
                "content": "#### ***PLS UPVOTE :)***\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n        //declaring an array list to store the pairs\\n        ArrayList<int[]> list=new ArrayList<>();\\n        \\n        //sorting the given interval array based on starting point\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        \\n        //defining start and end point\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        \\n        //we will iterate through the 2d array intervals so in each iteration we will get a row[1D array] as i\\n        \\n        for(int[] i:intervals){\\n            //check if end point of 1st pair if greater than the starting point of the 2nd pair or not, basically we check it\\'s in overlapping condition or not\\n            \\n            if(i[0]<=end){\\n                end=Math.max(end,i[1]);\\n            }\\n            \\n            //otherwise add it in the list\\n            else{\\n                list.add(new int[]{start,end});\\n                start=i[0];\\n                end=i[1];\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});\\n        return list.toArray(new int[0][]);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n        //declaring an array list to store the pairs\\n        ArrayList<int[]> list=new ArrayList<>();\\n        \\n        //sorting the given interval array based on starting point\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        \\n        //defining start and end point\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        \\n        //we will iterate through the 2d array intervals so in each iteration we will get a row[1D array] as i\\n        \\n        for(int[] i:intervals){\\n            //check if end point of 1st pair if greater than the starting point of the 2nd pair or not, basically we check it\\'s in overlapping condition or not\\n            \\n            if(i[0]<=end){\\n                end=Math.max(end,i[1]);\\n            }\\n            \\n            //otherwise add it in the list\\n            else{\\n                list.add(new int[]{start,end});\\n                start=i[0];\\n                end=i[1];\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});\\n        return list.toArray(new int[0][]);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351533,
                "title": "a-java-sorting-solution",
                "content": "The basic idea is to compare current end time with next start time, if next start time is smaller than current end time, then there is a collapse. In order to achieve this approach, we need to \\n\\n1.  Seperate start time and end time into different arrays and sort them in ascending order.\\n2.  For each end time, compare it with next start time. We use j to mark start time and i to mark end time.  When collapse appears, record start time and end time, and move j to next end time(which is i++) as the new start.\\n3.  Since this approach will miss the last stat time, add the last time section with start time j and the final end time.\\n```\\npublic int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0){\\n            return new int[0][];\\n        }\\n\\t\\t// seperate start and end \\n        int[] start = new int[intervals.length];\\n        int[] end = new int[intervals.length];\\n        List<int[]> res = new LinkedList<>();\\n        for(int i = 0; i < intervals.length; i++){\\n            start[i] = intervals[i][0];\\n            end[i] = intervals[i][1];\\n        }\\n\\t\\t\\n\\t\\t// sort start[] end[] respectively\\n        Arrays.sort(start);\\n        Arrays.sort(end);\\n\\t\\t\\n        int j = 0; // start time\\n        for(int i = 0; i < intervals.length - 1; i++) { // iterate end time\\n            if(start[i + 1] > end[i]) { // when collapse appears\\n                res.add(new int[] {start[j], end[i]}); // record\\n                j = i + 1; // move previous start time \\n            }    \\n        }\\n        res.add(new int[] {start[j], end[intervals.length - 1]}); // add last one\\n        return res.toArray(new int[res.size()][]);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "The basic idea is to compare current end time with next start time, if next start time is smaller than current end time, then there is a collapse. In order to achieve this approach, we need to \\n\\n1.  Seperate start time and end time into different arrays and sort them in ascending order.\\n2.  For each end time, compare it with next start time. We use j to mark start time and i to mark end time.  When collapse appears, record start time and end time, and move j to next end time(which is i++) as the new start.\\n3.  Since this approach will miss the last stat time, add the last time section with start time j and the final end time.\\n```\\npublic int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0){\\n            return new int[0][];\\n        }\\n\\t\\t// seperate start and end \\n        int[] start = new int[intervals.length];\\n        int[] end = new int[intervals.length];\\n        List<int[]> res = new LinkedList<>();\\n        for(int i = 0; i < intervals.length; i++){\\n            start[i] = intervals[i][0];\\n            end[i] = intervals[i][1];\\n        }\\n\\t\\t\\n\\t\\t// sort start[] end[] respectively\\n        Arrays.sort(start);\\n        Arrays.sort(end);\\n\\t\\t\\n        int j = 0; // start time\\n        for(int i = 0; i < intervals.length - 1; i++) { // iterate end time\\n            if(start[i + 1] > end[i]) { // when collapse appears\\n                res.add(new int[] {start[j], end[i]}); // record\\n                j = i + 1; // move previous start time \\n            }    \\n        }\\n        res.add(new int[] {start[j], end[intervals.length - 1]}); // add last one\\n        return res.toArray(new int[res.size()][]);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 299582,
                "title": "clean-python-beats-95",
                "content": "```\\ndef merge(self, intervals: \\'List[Interval]\\') -> \\'List[Interval]\\':\\n\\tif not intervals: return []\\n\\tintervals.sort()\\n\\n\\tunique = []\\n\\tlast = intervals[0]\\n\\tfor cur in intervals:\\n\\t\\tif cur[0] <= last[1]:\\n\\t\\t\\tlast[1] = max(last[1], cur[1])\\n\\t\\telse:\\n\\t\\t\\tunique.append(last)\\n\\t\\t\\tlast = cur\\n\\n\\tunique.append(last)\\n\\treturn unique\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef merge(self, intervals: \\'List[Interval]\\') -> \\'List[Interval]\\':\\n\\tif not intervals: return []\\n\\tintervals.sort()\\n\\n\\tunique = []\\n\\tlast = intervals[0]\\n\\tfor cur in intervals:\\n\\t\\tif cur[0] <= last[1]:\\n\\t\\t\\tlast[1] = max(last[1], cur[1])\\n\\t\\telse:\\n\\t\\t\\tunique.append(last)\\n\\t\\t\\tlast = cur\\n\\n\\tunique.append(last)\\n\\treturn unique\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3129464,
                "title": "95-javascript-fast-very-very-easy-to-understand-solution-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/EqL8ce_yZbI\\n\\nKorean video!\\n\\nhttps://youtu.be/CYGaPW7S5v4\\n# Code\\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    intervals.sort((a,b)=>a[0]-b[0])\\n    for(let i =1; i<intervals.length;i++){\\n        let [x,y] = intervals[i]\\n        let [prevX,prevY] = intervals[i-1]\\n        if(x <= prevY) {\\n            intervals[i-1][1] = Math.max(y,prevY);\\n            intervals.splice(i,1)\\n            i--\\n        }\\n    }\\n    return intervals    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    intervals.sort((a,b)=>a[0]-b[0])\\n    for(let i =1; i<intervals.length;i++){\\n        let [x,y] = intervals[i]\\n        let [prevX,prevY] = intervals[i-1]\\n        if(x <= prevY) {\\n            intervals[i-1][1] = Math.max(y,prevY);\\n            intervals.splice(i,1)\\n            i--\\n        }\\n    }\\n    return intervals    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21404,
                "title": "easy-python-first-sort-with-start",
                "content": "    # Definition for an interval.\\n    # class Interval(object):\\n    #     def __init__(self, s=0, e=0):\\n    #         self.start = s\\n    #         self.end = e\\n    \\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda x: x.start)\\n            n=len(intervals)\\n            if n==0:\\n                return []\\n            re=[]\\n            re.append(intervals[0])\\n            for i in range(1,n):\\n                a=re[-1]\\n                b=intervals[i]\\n                if b.start>a.end:\\n                    re.append(b)\\n                else:\\n                    re[-1].end=max(a.end,b.end)\\n            return re",
                "solutionTags": [],
                "code": "    # Definition for an interval.\\n    # class Interval(object):\\n    #     def __init__(self, s=0, e=0):\\n    #         self.start = s\\n    #         self.end = e\\n    \\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda x: x.start)\\n            n=len(intervals)\\n            if n==0:\\n                return []\\n            re=[]\\n            re.append(intervals[0])\\n            for i in range(1,n):\\n                a=re[-1]\\n                b=intervals[i]\\n                if b.start>a.end:\\n                    re.append(b)\\n                else:\\n                    re[-1].end=max(a.end,b.end)\\n            return re",
                "codeTag": "Java"
            },
            {
                "id": 3707961,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0])\\n            ans.back()[1]=max(ans.back()[1],intervals[i][1]);\\n            else ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```Please upvote to motivate me write more solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0])\\n            ans.back()[1]=max(ans.back()[1],intervals[i][1]);\\n            else ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788731,
                "title": "c-easy-solution",
                "content": "\\n```\\nvector<vector<int>> merge(vector<vector<int>>& v) // v = intervals; \\n    {\\n        const int n = v.size();\\n        //now sort the vector such that v[i][0]\\'s will be in decreasing order and\\n        //                              v[i][1]\\'s will be in increasing order\\n        sort(v.begin(), v.end(), [&] (const vector<int> &a, const vector<int> &b)\\n        {\\n            if(a[0] != b[0])\\n                return a[0] < b[0];\\n            else\\n                return a[1] > b[1];\\n        });\\n        \\n        vector<vector<int>> ans;\\n        \\n        int start = v[0][0];\\n        int end = v[0][1];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][1] > end)\\n            {\\n                end = v[i][1];\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& v) // v = intervals; \\n    {\\n        const int n = v.size();\\n        //now sort the vector such that v[i][0]\\'s will be in decreasing order and\\n        //                              v[i][1]\\'s will be in increasing order\\n        sort(v.begin(), v.end(), [&] (const vector<int> &a, const vector<int> &b)\\n        {\\n            if(a[0] != b[0])\\n                return a[0] < b[0];\\n            else\\n                return a[1] > b[1];\\n        });\\n        \\n        vector<vector<int>> ans;\\n        \\n        int start = v[0][0];\\n        int end = v[0][1];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][1] > end)\\n            {\\n                end = v[i][1];\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089761,
                "title": "python-easy-solutions-with-explanation",
                "content": "\\n      #So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index.\\n\\n         intervals.sort(key = lambda x:x[0])\\n         i = 1\\n        while i < len(intervals):\\n            if intervals[i][0]<= intervals[i-1][1]:\\n            \\n        #This is to see which is min between 1, 2 . Checking the starting index of both arrays\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n            \\n            \\n         #Similarly finding the max value for ending pos\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i) #deleteing the i the part after merging \\n            \\n            \\n            else:\\n                i+=1\\n                continue\\n                \\n                \\n        return intervals\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n#If you find it helpful please upvote \\n#for any questions comment down I will reply asap",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n      #So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index.\\n\\n         intervals.sort(key = lambda x:x[0])\\n         i = 1\\n        while i < len(intervals):\\n            if intervals[i][0]<= intervals[i-1][1]:\\n            \\n        #This is to see which is min between 1, 2 . Checking the starting index of both arrays\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n            \\n            \\n         #Similarly finding the max value for ending pos\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i) #deleteing the i the part after merging \\n            \\n            \\n            else:\\n                i+=1\\n                continue\\n                \\n                \\n        return intervals\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n#If you find it helpful please upvote \\n#for any questions comment down I will reply asap",
                "codeTag": "Unknown"
            },
            {
                "id": 1083890,
                "title": "7-lines-c-simplest-solution-with-complete-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        // sorting intervals by their starting time\\n        sort(intervals.begin(), intervals.end());\\n        \\n        // keeping track of starting and ending of current interval \\n        int startingInterval = intervals[0][0], endingInterval = intervals[0][1];\\n        \\n        // starting from index 1 because we will start comparing current interval from the\\n        // last interval we have processed so far\\n        \\n        for(int i = 1; i < intervals.size(); ++i) {\\n            \\n            // if starting of current interval is less then or equal to ending of last \\n            // processed interval\\n            // then will update endingInterval so that it could be considered as merged\\n            if(intervals[i][0] <= endingInterval)\\n                endingInterval = max(endingInterval, intervals[i][1]);\\n            \\n            // inserting interval as till now we have minimum starting interval and maximum ending\\n            // interval which is merged so far, and updating our startingInterval and endingInterval\\n            // with the bounds of current interval\\n            else {\\n                ans.push_back({startingInterval , endingInterval});\\n                startingInterval = intervals[i][0];\\n                endingInterval  = intervals[i][1];\\n            }\\n        }\\n        \\n        // adding last pair which is left because loop will terminate at intervals size\\n        ans.push_back({startingInterval, endingInterval});\\n        return ans;\\n    }\\n};\\n```\\nKindly upvote if you understood the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        // sorting intervals by their starting time\\n        sort(intervals.begin(), intervals.end());\\n        \\n        // keeping track of starting and ending of current interval \\n        int startingInterval = intervals[0][0], endingInterval = intervals[0][1];\\n        \\n        // starting from index 1 because we will start comparing current interval from the\\n        // last interval we have processed so far\\n        \\n        for(int i = 1; i < intervals.size(); ++i) {\\n            \\n            // if starting of current interval is less then or equal to ending of last \\n            // processed interval\\n            // then will update endingInterval so that it could be considered as merged\\n            if(intervals[i][0] <= endingInterval)\\n                endingInterval = max(endingInterval, intervals[i][1]);\\n            \\n            // inserting interval as till now we have minimum starting interval and maximum ending\\n            // interval which is merged so far, and updating our startingInterval and endingInterval\\n            // with the bounds of current interval\\n            else {\\n                ans.push_back({startingInterval , endingInterval});\\n                startingInterval = intervals[i][0];\\n                endingInterval  = intervals[i][1];\\n            }\\n        }\\n        \\n        // adding last pair which is left because loop will terminate at intervals size\\n        ans.push_back({startingInterval, endingInterval});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940596,
                "title": "c-5-lines-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a) {\\n        sort(a.begin(), a.end());\\n        int i = 0, n = a.size();\\n        for (int j = 1; j < n; j++) \\n            if (a[j][0] > a[i][1]) a[++i] = a[j];\\n            else a[i][1] = max(a[i][1], a[j][1]);\\n        while (--n > i) a.pop_back(); \\n        return a;\\n    }\\n};\\n```\\nO(N) modified space :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a) {\\n        sort(a.begin(), a.end());\\n        int i = 0, n = a.size();\\n        for (int j = 1; j < n; j++) \\n            if (a[j][0] > a[i][1]) a[++i] = a[j];\\n            else a[i][1] = max(a[i][1], a[j][1]);\\n        while (--n > i) a.pop_back(); \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940325,
                "title": "c-python-linear-scan",
                "content": "Approach 1: C++\\n```\\nclass Solution { // Linear scan\\npublic: // Time/Space: O(NlogN); O(N)\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){return a[0] < b[0];});\\n\\t\\tsort(intervals.begin(), intervals.end()); // same as above above line\\n        vector<vector<int>> ans;\\n        for(auto& e: intervals){\\n            if(ans.empty() || e[0] > ans.back()[1]) ans.push_back(e);\\n            else ans.back()[1] = max(ans.back()[1], e[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: Python\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:        \\n        ans = []        \\n        for i in sorted(intervals):\\n            if not ans or ans[-1][1]< i[0]:  ans.append(i)\\n            else:  ans[-1][1] = max(ans[-1][1], i[1])\\n        return ans             \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution { // Linear scan\\npublic: // Time/Space: O(NlogN); O(N)\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){return a[0] < b[0];});\\n\\t\\tsort(intervals.begin(), intervals.end()); // same as above above line\\n        vector<vector<int>> ans;\\n        for(auto& e: intervals){\\n            if(ans.empty() || e[0] > ans.back()[1]) ans.push_back(e);\\n            else ans.back()[1] = max(ans.back()[1], e[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:        \\n        ans = []        \\n        for i in sorted(intervals):\\n            if not ans or ans[-1][1]< i[0]:  ans.append(i)\\n            else:  ans[-1][1] = max(ans[-1][1], i[1])\\n        return ans             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 21467,
                "title": "my-c-o-nlogn-solution-580ms",
                "content": "Just copy the input to res and do sorting (in ascending order of start). Then try to merge the sorted interval: cur is the last processed interval and i is the current to-be-processed interval. if cur is ahead of i and no overlapping, just copy i to cur+1, and update cur to cur+1, otherwise, merge interval cur and i and move to i+1. At last, we need to resize res to remove the redundent intervals.  \\n\\n    class Solution {\\n    public:\\n        vector<Interval> merge(vector<Interval>& intervals) {\\n            int len = intervals.size(),i,cur;\\n            vector<Interval> res(intervals);\\n            if(len>1)\\n            {\\n                std::sort(res.begin(), res.end(), [](Interval i, Interval j){return i.start<j.start;});\\n                for(cur=0, i=1;i<len; ++i)\\n                    if(res[cur].end<res[i].start) res[++cur] = res[i]; // no overlapping, copy to cur+1, \\n                    else res[cur].end = max(res[cur].end, res[i].end); // cur and i overlap with each other, merge\\n                res.resize(cur+1); // resize to remove redundant intervals\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<Interval> merge(vector<Interval>& intervals) {\\n            int len = intervals.size(),i,cur;\\n            vector<Interval> res(intervals);\\n            if(len>1)\\n            {\\n                std::sort(res.begin(), res.end(), [](Interval i, Interval j){return i.start<j.start;}",
                "codeTag": "Java"
            },
            {
                "id": 1036776,
                "title": "simple-sorting-python-solution-o-n-log-n-time",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals)\\n        \\n        ans = []\\n        start = intervals[0][0]\\n        end = intervals[0][1]\\n        for i in intervals:\\n            if i[0] > end:\\n                ans.append([start, end])\\n                start, end = i[0], i[1]\\n            else:\\n                end = max(end, i[1])\\n        ans.append([start, end])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals)\\n        \\n        ans = []\\n        start = intervals[0][0]\\n        end = intervals[0][1]\\n        for i in intervals:\\n            if i[0] > end:\\n                ans.append([start, end])\\n                start, end = i[0], i[1]\\n            else:\\n                end = max(end, i[1])\\n        ans.append([start, end])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030287,
                "title": "9-line-javascript-solution",
                "content": "Sort the intervals by the start index in ascending order. We can tell if the current interval overlap with the previous one if the current start value > the previous end value. Update the previous interval accordingly. \\n\\n```\\nvar merge = function(intervals) {\\n  intervals.sort((a, b) => a[0] - b[0])\\n  const res = [intervals[0]]\\n  for (let curr of intervals) {\\n    prev = res[res.length - 1]\\n    if (prev[1] >= curr[0]) {\\n      prev[1] = Math.max(curr[1], prev[1])\\n    } else {\\n      res.push(curr)\\n    }\\n  }\\n  return res\\n};\\n```\\n*Note that modifying prev array also modifies the original res array due to JavaScript object copying properties.",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n  intervals.sort((a, b) => a[0] - b[0])\\n  const res = [intervals[0]]\\n  for (let curr of intervals) {\\n    prev = res[res.length - 1]\\n    if (prev[1] >= curr[0]) {\\n      prev[1] = Math.max(curr[1], prev[1])\\n    } else {\\n      res.push(curr)\\n    }\\n  }\\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855286,
                "title": "brute-force-approach-for-simple-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        int m = intervals.size();\\n        if(m==0)\\n            return res;\\n        int n = intervals[0].size();\\n\\n        \\n        for(int i=0; i<intervals.size(); i++){\\n            int tru = 0;\\n            \\n            for(int j=i+1; j<intervals.size(); j++){\\n                \\n                int a = intervals[i][0];\\n                int b = intervals[i][1];\\n                \\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n                \\n                if((a>=c && a<=d) || (b>=c && b<=d) || (c>=a && c<=b) || (d>=a && d<=b)){\\n                    intervals.erase(intervals.begin()+i);\\n                    intervals.erase(intervals.begin()+j-1);\\n                    intervals.push_back({min(a,c), max(b,d)});\\n                    i--;\\n                    tru = 1;\\n                    break;\\n                }                                            \\n            }\\n            if(tru==0)\\n                res.push_back({intervals[i][0], intervals[i][1]});\\n        }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        int m = intervals.size();\\n        if(m==0)\\n            return res;\\n        int n = intervals[0].size();\\n\\n        \\n        for(int i=0; i<intervals.size(); i++){\\n            int tru = 0;\\n            \\n            for(int j=i+1; j<intervals.size(); j++){\\n                \\n                int a = intervals[i][0];\\n                int b = intervals[i][1];\\n                \\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n                \\n                if((a>=c && a<=d) || (b>=c && b<=d) || (c>=a && c<=b) || (d>=a && d<=b)){\\n                    intervals.erase(intervals.begin()+i);\\n                    intervals.erase(intervals.begin()+j-1);\\n                    intervals.push_back({min(a,c), max(b,d)});\\n                    i--;\\n                    tru = 1;\\n                    break;\\n                }                                            \\n            }\\n            if(tru==0)\\n                res.push_back({intervals[i][0], intervals[i][1]});\\n        }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717511,
                "title": "cpp-c-solution-log-n-linear",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {  \\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n      //  cout.tie(NULL);\\n        vector<vector<int>>ans;  \\n        if(intervals.size()==0)\\n            return ans;\\n        sort(intervals.begin(),intervals.end()); \\n        int f=intervals[0][0]; \\n        int e=intervals[0][1]; \\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            int f2=intervals[i][0]; \\n            int e2=intervals[i][1]; \\n            if(max(f,f2)<=min(e,e2))//overlapping happens here\\n            {\\n                f=min(f,f2); \\n                e=max(e,e2);\\n            } \\n            else\\n            {\\n                ans.push_back({f,e}); \\n                f=f2; \\n                e=e2;\\n            }\\n\\n        } \\n        ans.push_back({f,e});\\n        return ans;\\n    }\\n\\t``` \\n\\tPlease upvote if you like my solution.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {  \\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n      //  cout.tie(NULL);\\n        vector<vector<int>>ans;  \\n        if(intervals.size()==0)\\n            return ans;\\n        sort(intervals.begin(),intervals.end()); \\n        int f=intervals[0][0]; \\n        int e=intervals[0][1]; \\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            int f2=intervals[i][0]; \\n            int e2=intervals[i][1]; \\n            if(max(f,f2)<=min(e,e2))//overlapping happens here\\n            {\\n                f=min(f,f2); \\n                e=max(e,e2);\\n            } \\n            else\\n            {\\n                ans.push_back({f,e}); \\n                f=f2; \\n                e=e2;\\n            }\\n\\n        } \\n        ans.push_back({f,e});\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 281356,
                "title": "c-sort-then-merge",
                "content": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        var n = intervals.Length;\\n\\n        if (n <= 1) {\\n            return intervals;\\n        }\\n\\n        /* NOTE:\\n            better, because it does not modify the input (try best to immutability)\\n            but Time Limit Exceeded :(\\n        */ \\n        // var sortedIntervals = intervals.OrderBy(interval => interval[0]);\\n        Array.Sort(intervals, (a, b) => a[0] - b[0]);\\n\\n        var result = new List<int[]>();\\n        result.Add(intervals.ElementAt(0));\\n        for (int i = 1; i < n; i++) {\\n            var cur = intervals.ElementAt(i);\\n            var lastFromResult = result.Last();\\n\\n            if (lastFromResult[1] >= cur[0]) {\\n                lastFromResult[1] = Math.Max(lastFromResult[1], cur[1]);\\n            } else {\\n                result.Add(cur);\\n            }\\n        }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        var n = intervals.Length;\\n\\n        if (n <= 1) {\\n            return intervals;\\n        }\\n\\n        /* NOTE:\\n            better, because it does not modify the input (try best to immutability)\\n            but Time Limit Exceeded :(\\n        */ \\n        // var sortedIntervals = intervals.OrderBy(interval => interval[0]);\\n        Array.Sort(intervals, (a, b) => a[0] - b[0]);\\n\\n        var result = new List<int[]>();\\n        result.Add(intervals.ElementAt(0));\\n        for (int i = 1; i < n; i++) {\\n            var cur = intervals.ElementAt(i);\\n            var lastFromResult = result.Last();\\n\\n            if (lastFromResult[1] >= cur[0]) {\\n                lastFromResult[1] = Math.Max(lastFromResult[1], cur[1]);\\n            } else {\\n                result.Add(cur);\\n            }\\n        }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21510,
                "title": "c-vanilla",
                "content": "Sort `intervals` according to `start`, scan from left to right and merge overlapping ones.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](Interval& l, Interval& r) {return l.start < r.start;});\\n        vector<Interval> ans;\\n        for (Interval& interval : intervals) {\\n            if (!ans.empty() && ans.back().end >= interval.start) {\\n                ans.back().end = max(ans.back().end, interval.end);\\n            } else {\\n                ans.push_back(interval);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](Interval& l, Interval& r) {return l.start < r.start;});\\n        vector<Interval> ans;\\n        for (Interval& interval : intervals) {\\n            if (!ans.empty() && ans.back().end >= interval.start) {\\n                ans.back().end = max(ans.back().end, interval.end);\\n            } else {\\n                ans.push_back(interval);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008939,
                "title": "super-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n    Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));\\n        List<int[]> res=new ArrayList<>();\\n        int low=intervals[0][0];\\n        int high=intervals[0][1];\\n\\n        for(int i=1;i<intervals.length;i++)\\n        {\\n           if(intervals[i][0]<=high){\\n               if(high<intervals[i][1])\\n               high=intervals[i][1];\\n           }\\n           else{\\n               res.add(new int[]{low,high});\\n               low=intervals[i][0];\\n               high=intervals[i][1];\\n           }\\n        }\\n        res.add(new int[]{low,high});  \\n       return res.toArray(new int[0][]);     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n    Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));\\n        List<int[]> res=new ArrayList<>();\\n        int low=intervals[0][0];\\n        int high=intervals[0][1];\\n\\n        for(int i=1;i<intervals.length;i++)\\n        {\\n           if(intervals[i][0]<=high){\\n               if(high<intervals[i][1])\\n               high=intervals[i][1];\\n           }\\n           else{\\n               res.add(new int[]{low,high});\\n               low=intervals[i][0];\\n               high=intervals[i][1];\\n           }\\n        }\\n        res.add(new int[]{low,high});  \\n       return res.toArray(new int[0][]);     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693730,
                "title": "java-easy-approach-with-comments-merge-intervals",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)-> Integer.compare(a[0],b[0]));\\n        Stack<int[]> stack = new Stack();\\n        stack.add(intervals[0]);    //pushing 1st interval\\n        \\n        //2nd interval se compare krenge\\n        for(int i=1;i<intervals.length;i++){\\n            \\n            int startpoint2 = intervals[i][0];  //2nd interval ka start point isliye 2\\n            int endpoint2 = intervals[i][1];\\n            \\n            //first interval stack mai h toh usse pop kro\\n            int poparray[] = stack.pop();\\n            \\n            int startpoint1 = poparray[0];\\n            int endpoint1 = poparray[1];\\n            \\n            //1 3\\n            //2 6  inko comapre\\n            int endmax = Math.max(endpoint2,endpoint1);\\n                \\n            if(endpoint1 >= startpoint2){\\n                int [] merge = new int[]{startpoint1,endmax};\\n                stack.add(merge);      //merge karne ke baad stack mai dal do \\n            }else{\\n                stack.add(poparray);\\n                 stack. add(intervals[i]);\\n            }        \\n        }\\n        int [][] output = new int [stack.size()][2];\\n        for(int i=output.length-1;i>=0;i--){\\n            int []poparray = stack.pop();\\n            output[i][0] = poparray[0];\\n            output[i][1] = poparray[1];\\n        }\\n        return output;\\n    }                           \\n}\\n```\\n![image](https://assets.leetcode.com/users/images/848bc7b1-68bc-433d-b411-03b6fca15cd8_1665573877.8034868.png)\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)-> Integer.compare(a[0],b[0]));\\n        Stack<int[]> stack = new Stack();\\n        stack.add(intervals[0]);    //pushing 1st interval\\n        \\n        //2nd interval se compare krenge\\n        for(int i=1;i<intervals.length;i++){\\n            \\n            int startpoint2 = intervals[i][0];  //2nd interval ka start point isliye 2\\n            int endpoint2 = intervals[i][1];\\n            \\n            //first interval stack mai h toh usse pop kro\\n            int poparray[] = stack.pop();\\n            \\n            int startpoint1 = poparray[0];\\n            int endpoint1 = poparray[1];\\n            \\n            //1 3\\n            //2 6  inko comapre\\n            int endmax = Math.max(endpoint2,endpoint1);\\n                \\n            if(endpoint1 >= startpoint2){\\n                int [] merge = new int[]{startpoint1,endmax};\\n                stack.add(merge);      //merge karne ke baad stack mai dal do \\n            }else{\\n                stack.add(poparray);\\n                 stack. add(intervals[i]);\\n            }        \\n        }\\n        int [][] output = new int [stack.size()][2];\\n        for(int i=output.length-1;i>=0;i--){\\n            int []poparray = stack.pop();\\n            output[i][0] = poparray[0];\\n            output[i][1] = poparray[1];\\n        }\\n        return output;\\n    }                           \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914800,
                "title": "python-simple-explanation-8-line",
                "content": "Create a temporary list and add elements when there is no overlap. If there is then perfrom merge.\\n\\n    def merge(self, l: List[List[int]]) -> List[List[int]]:\\n        k = []\\n        l.sort()\\n        for i in l:\\n            if not k or k[-1][1] < i[0]:\\n                k.append(i)\\n            else:\\n                k[-1][1] = max(k[-1][1],i[1])\\n        return k\\n\\t\\t\\n\\t\\t\\nRuntime: 163 ms\\nMemory Usage: 18.1 MB\\n\\n**Upvote if you found it useful**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "Create a temporary list and add elements when there is no overlap. If there is then perfrom merge.\\n\\n    def merge(self, l: List[List[int]]) -> List[List[int]]:\\n        k = []\\n        l.sort()\\n        for i in l:\\n            if not k or k[-1][1] < i[0]:\\n                k.append(i)\\n            else:\\n                k[-1][1] = max(k[-1][1],i[1])\\n        return k\\n\\t\\t\\n\\t\\t\\nRuntime: 163 ms\\nMemory Usage: 18.1 MB\\n\\n**Upvote if you found it useful**",
                "codeTag": "Python3"
            },
            {
                "id": 1444462,
                "title": "followup-bst-implementation-c",
                "content": "# **Facebook Followup - Stream of Intervals**\\n**General Question**: What if the data comes as a stream in real time - No meaningful sorting can be done.\\n\\nImplementation based on Interval based BSTs so that we can `query` multiple times. We also create an `insert` method that we will need for the interval tree.\\n\\n### Implementation Details & Code \\n \\n- `IntervalTree` is the new class that we need to define, and we will use it to define `start`, `end` and `mid` points for each node.\\n- `insertInterval` method - if the interval to be added touches or crosses the `middle` of the current node, we merge them directly, else we insert the new interval in the `left` or `right` subtree.\\n```\\nvoid insertInterval(IntervalTree *node, Interval *currentInterval) {\\n    if (currentInterval->end < node->middle) { // Check if the entire interval is included before middle.\\n        if (node->left) {\\n            insertInterval(node->left, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->left = newNode;\\n        }\\n    }\\n    else if (currentInterval->start > node->middle) { // Check if the entire interval is included after middle.\\n        if (node->right) {\\n            insertInterval(node->right, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->right = newNode;\\n        }\\n    }\\n    else { // Merge directly if the new interval does not fit before OR after the middle point.\\n        node->start = min(node->start, currentInterval->start);\\n        node->end = max(node->end, currentInterval->end);\\n    }\\n}\\n```\\n- `queryInterval` method - retrieve merged intervals of the `left` subtree, `leftIntervals` and those of the `right` subtree `rightIntervals`. \\n```\\nvoid queryInterval(vector<Interval *> &retV, IntervalTree *node) { \\n    // retV is the collection vector.\\n    vector<Interval *> leftIntervals;\\n    vector<Interval *> rightIntervals;\\n    \\n    // Check if we can merge the current node with intervals from the left subtree.\\n    bool mergeLeft = false; \\n    \\n    if (node->left) {\\n        queryInterval(leftIntervals, node->left); // Merge all the intervals in left subtree.\\n        mergeLeftInterval(leftIntervals, node, retV, mergeLeft); // Find the merge point with the leftIntervals.\\n    }\\n    \\n    if (!mergeLeft) { // If we didn\\'t merge left, create a new interval.\\n        Interval *newInterval = new Interval(node->start, node->end);\\n        retV.push_back(newInterval);\\n    }\\n    \\n    if (node->right) {\\n        queryInterval(rightIntervals, node->right); //Merge all the intervals in the right subtree.\\n        mergeRightInterval(rightIntervals, node, retV); // Find the merge point with the rightIntervals.\\n    }\\n}\\n```\\n- the two merge methods `mergeLeftInterval` and `mergeRightInterval` are implemented similarly\\n\\t- if we find an interval that overlaps with the current `node`, we know that everything after will overlap\\n\\t- the first intervals that overlap will be all merged and the rest inserted at the end\\n```\\nvoid mergeLeftInterval(vector<Interval *> &leftIntervals, IntervalTree *node, \\n                       vector<Interval *> &retV, bool &merged) {\\n    for (int i = 0; i < leftIntervals.size(); i++) { \\n\\t\\t// If any of the left intervals intersects with the current interval, we merge it and break.\\n        if (leftIntervals[i]->end >= node->start) { \\n            Interval *newInterval = new Interval(min(leftIntervals[i]->start, node->start), node->end); \\n            retV.push_back(newInterval);\\n            merged = true;\\n            break;\\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n```\\n```\\nvoid mergeRightInterval(vector<Interval *> &rightIntervals, IntervalTree *node,\\n                        vector<Interval *> &retV) {\\n    for (int i = 0; i < rightIntervals.size(); i++) {\\n        if (rightIntervals[i]->start <= node->end) {\\n\\t\\t\\t// We extend the right end of the last appended interval whenever an intersection takes place.\\n            retV[retV.size() - 1]->end = max(rightIntervals[i]->end, node->end); \\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(rightIntervals[i]); \\n        }\\n    }\\n}\\n```\\n\\nInspiration comes from this post: https://leetcode.com/problems/merge-intervals/discuss/21452/Share-my-interval-tree-solution-no-sorting\\n\\nAnd the explanation in [yongzx](https://leetcode.com/yongzx/) \\'s comment at the bottom of the solution tab. \\n\\nI am thankful to both of them for posting about this problem / followup! \\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nvoid insertInterval(IntervalTree *node, Interval *currentInterval) {\\n    if (currentInterval->end < node->middle) { // Check if the entire interval is included before middle.\\n        if (node->left) {\\n            insertInterval(node->left, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->left = newNode;\\n        }\\n    }\\n    else if (currentInterval->start > node->middle) { // Check if the entire interval is included after middle.\\n        if (node->right) {\\n            insertInterval(node->right, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->right = newNode;\\n        }\\n    }\\n    else { // Merge directly if the new interval does not fit before OR after the middle point.\\n        node->start = min(node->start, currentInterval->start);\\n        node->end = max(node->end, currentInterval->end);\\n    }\\n}\\n```\n```\\nvoid queryInterval(vector<Interval *> &retV, IntervalTree *node) { \\n    // retV is the collection vector.\\n    vector<Interval *> leftIntervals;\\n    vector<Interval *> rightIntervals;\\n    \\n    // Check if we can merge the current node with intervals from the left subtree.\\n    bool mergeLeft = false; \\n    \\n    if (node->left) {\\n        queryInterval(leftIntervals, node->left); // Merge all the intervals in left subtree.\\n        mergeLeftInterval(leftIntervals, node, retV, mergeLeft); // Find the merge point with the leftIntervals.\\n    }\\n    \\n    if (!mergeLeft) { // If we didn\\'t merge left, create a new interval.\\n        Interval *newInterval = new Interval(node->start, node->end);\\n        retV.push_back(newInterval);\\n    }\\n    \\n    if (node->right) {\\n        queryInterval(rightIntervals, node->right); //Merge all the intervals in the right subtree.\\n        mergeRightInterval(rightIntervals, node, retV); // Find the merge point with the rightIntervals.\\n    }\\n}\\n```\n```\\nvoid mergeLeftInterval(vector<Interval *> &leftIntervals, IntervalTree *node, \\n                       vector<Interval *> &retV, bool &merged) {\\n    for (int i = 0; i < leftIntervals.size(); i++) { \\n\\t\\t// If any of the left intervals intersects with the current interval, we merge it and break.\\n        if (leftIntervals[i]->end >= node->start) { \\n            Interval *newInterval = new Interval(min(leftIntervals[i]->start, node->start), node->end); \\n            retV.push_back(newInterval);\\n            merged = true;\\n            break;\\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n```\n```\\nvoid mergeRightInterval(vector<Interval *> &rightIntervals, IntervalTree *node,\\n                        vector<Interval *> &retV) {\\n    for (int i = 0; i < rightIntervals.size(); i++) {\\n        if (rightIntervals[i]->start <= node->end) {\\n\\t\\t\\t// We extend the right end of the last appended interval whenever an intersection takes place.\\n            retV[retV.size() - 1]->end = max(rightIntervals[i]->end, node->end); \\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(rightIntervals[i]); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398334,
                "title": "c-simple-with-explanation-pattern-for-interval-problems",
                "content": "There are some interval based problems which are not really associated with any other data structure or algorithm but are all solved using a similar technique: Sort the intervals + One pass to update/calculate greedily.\\n\\n**1. Merge Intervals**\\n\\nWe want to merge any overlapping intervals. Let us start with the interval with the least left end. Then, we don\\'t want to miss any intervals that start immediately before it ends. If we sort the intervals by starting index, we will not miss any intervals while iterating over the sorted intervals. \\n\\nHow to merge greedily? First set **start** and **end** to the limits of the first interval in the sorted list. Then, if for an element i, starting[i] <= end, we know it overlaps because sorting by the first interval means start < starting[i] (so it means start < starting[i] <= end). Now, since we know the interval overlaps, we have to update the present interval. The start value doesn\\'t have to be updated since it is already the leftmost index possible in all the overlapping arrays. However the end index should be the rightmost index possible in all overlapping arrays, so end should be updated with the maximum of itself and ending[i].\\n\\nIf while iterating, starting[i] > end, we can add the range covered by {start,end} to the merged array, and restart merging like at i = 0 by setting start = starting[i] and end = ending[i].\\n\\nOnce we have completed traversal, the final merged element needs to be added (since we add an element only after the next interval does not overlap, but for the last element we cannot do this check). This completes merge intervals.\\n\\n```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        vector<vector<int>> merged;\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] <= end)\\n            {\\n                end = max(end, intervals[i][1]);\\n            }\\n            else\\n            {\\n                merged.push_back({start,end});\\n                \\n                start = intervals[i][0];\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        merged.push_back({start,end});\\n        \\n        return merged;\\n    }\\n```\\n\\n**2. Non-overlapping Intervals**\\n\\nThe problem asks to find \"*the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping*\". First is the sorting step. Suppose we sort like with merged intervals based on first index. Then, when we find overlapping intervals, which one should we delete? If we choose the interval which ends earlier we will have more space to accommodate more intervals. Hence we maintain only the earliest ending interval out of all overlapping intervals. \\n\\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n                \\n                if(intervals[i][1] < end)\\n                {\\n                    end = intervals[i][1];\\n                }\\n            }\\n            else\\n            {\\n                end = intervals[i][1];   \\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\\n\\nIf we sort by the second index, then the intervals are already arranged in least ending first order, so we can process the intervals more simply, on finding an overlap we can just remove the present interval (guaranteed to have a later ending than the one being compared to). \\n\\nHence another solution is to sort by the second index and then pick the first interval, remove all intervals in front of it overlapping with it, then update to the next interval and do the same, similar to how the intervals were processed for merging but with the second index.\\n\\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[1] < b[1];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n            }\\n            else\\n            {\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\\n\\nOther problems based on interval pattern (sort + greedy processing)\\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/ (already discussed)\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ (similar to non overlapping intervals)\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/\\nhttps://leetcode.com/problems/insert-interval/ (only greedy processing, good to familiarize with interval processing)",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        vector<vector<int>> merged;\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] <= end)\\n            {\\n                end = max(end, intervals[i][1]);\\n            }\\n            else\\n            {\\n                merged.push_back({start,end});\\n                \\n                start = intervals[i][0];\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        merged.push_back({start,end});\\n        \\n        return merged;\\n    }\\n```\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n                \\n                if(intervals[i][1] < end)\\n                {\\n                    end = intervals[i][1];\\n                }\\n            }\\n            else\\n            {\\n                end = intervals[i][1];   \\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[1] < b[1];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n            }\\n            else\\n            {\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21498,
                "title": "clean-java-sort-solution-using-comparator",
                "content": "    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\tif (intervals.isEmpty())\\n\\t\\t\\treturn intervals;\\n\\n\\t\\tCollections.sort(intervals, new Comparator<Interval>() {\\n\\t\\t\\tpublic int compare(Interval a, Interval b) {\\n\\t\\t\\t\\t// TODO Auto-generated method stub\\n\\t\\t\\t\\treturn a.start - b.start;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tList<Interval> ans = new LinkedList<Interval>();\\n\\t\\tInterval hold = intervals.get(0);\\n\\t\\tfor (int i = 1; i < intervals.size(); i++) {\\n\\t\\t\\tInterval current = intervals.get(i);\\n\\t\\t\\tif (hold.end >= current.start) {\\n\\t\\t\\t\\thold.end = Math.max(current.end, hold.end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans.add(hold);\\n\\t\\t\\t\\thold = current;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!ans.contains(hold))\\n\\t\\t\\tans.add(hold);\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\tif (intervals.isEmpty())\\n\\t\\t\\treturn intervals;\\n\\n\\t\\tCollections.sort(intervals, new Comparator<Interval>() {\\n\\t\\t\\tpublic int compare(Interval a, Interval b) {\\n\\t\\t\\t\\t// TODO Auto-generated method stub\\n\\t\\t\\t\\treturn a.start - b.start;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tList<Interval> ans = new LinkedList<Interval>();\\n\\t\\tInterval hold = intervals.get(0);\\n\\t\\tfor (int i = 1; i < intervals.size(); i++) {\\n\\t\\t\\tInterval current = intervals.get(i);\\n\\t\\t\\tif (hold.end >= current.start) {\\n\\t\\t\\t\\thold.end = Math.max(current.end, hold.end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans.add(hold);\\n\\t\\t\\t\\thold = current;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!ans.contains(hold))\\n\\t\\t\\tans.add(hold);\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3713888,
                "title": "java-striver-easy-understanding",
                "content": "**Time Complexity:** O(nlogn)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) return intervals;\\n\\n        Arrays.sort(intervals, (arr1, arr2) - > Integer.compare(arr1[0], arr2[0]));\\n\\n        List < int[] > output_arr = new ArrayList < > ();\\n        int[] current_interval = intervals[0];\\n        output_arr.add(current_interval);\\n\\n        for (int[] interval: intervals) {\\n            int current_begin = current_interval[0];\\n            int current_end = current_interval[1];\\n            int next_begin = interval[0];\\n            int next_end = interval[1];\\n\\n            if (current_end >= next_begin) {\\n                current_interval[1] = Math.max(current_end, next_end);\\n            } else {\\n                current_interval = interval;\\n                output_arr.add(current_interval);\\n            }\\n        }\\n        return output_arr.toArray(new int[output_arr.size()][]);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) return intervals;\\n\\n        Arrays.sort(intervals, (arr1, arr2) - > Integer.compare(arr1[0], arr2[0]));\\n\\n        List < int[] > output_arr = new ArrayList < > ();\\n        int[] current_interval = intervals[0];\\n        output_arr.add(current_interval);\\n\\n        for (int[] interval: intervals) {\\n            int current_begin = current_interval[0];\\n            int current_end = current_interval[1];\\n            int next_begin = interval[0];\\n            int next_end = interval[1];\\n\\n            if (current_end >= next_begin) {\\n                current_interval[1] = Math.max(current_end, next_end);\\n            } else {\\n                current_interval = interval;\\n                output_arr.add(current_interval);\\n            }\\n        }\\n        return output_arr.toArray(new int[output_arr.size()][]);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320349,
                "title": "c-fast-simple-sorting-169-ms-beats-82-2-51-1-mb-beats-83-68",
                "content": "# Approach\\nThe code is very simple at first we will sort the 2D array based on the first column. after that we will create a list of array and add the first row from the sorted 2D array. then we will just loop the 2D array and check if the list last array\\'s last element is greater than the current sorted array\\'s first element if yes then we will change the list element based on value, else we will add the element to the list.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) \\n    {\\n        List<int[]> output = new List<int[]>();\\n\\n        Array.Sort(intervals, (a,b)=>{return a[0]-b[0];});\\n\\n        output.Add(intervals[0]);\\n\\n        for(int i = 1; i < intervals.Length; i++)\\n        {\\n            if(output[output.Count - 1][1] >= intervals[i][0])\\n            {\\n                if(output[output.Count - 1][1] <= intervals[i][1]) \\n                    output[output.Count - 1][1] = intervals[i][1];\\n            }\\n            else output.Add(intervals[i]);\\n        }\\n\\n        return output.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) \\n    {\\n        List<int[]> output = new List<int[]>();\\n\\n        Array.Sort(intervals, (a,b)=>{return a[0]-b[0];});\\n\\n        output.Add(intervals[0]);\\n\\n        for(int i = 1; i < intervals.Length; i++)\\n        {\\n            if(output[output.Count - 1][1] >= intervals[i][0])\\n            {\\n                if(output[output.Count - 1][1] <= intervals[i][1]) \\n                    output[output.Count - 1][1] = intervals[i][1];\\n            }\\n            else output.Add(intervals[i]);\\n        }\\n\\n        return output.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215453,
                "title": "simple-c-solution",
                "content": "If you find it to be helpful please like and upvote \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ans[j][1]>=intervals[i][0])\\n            {\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }           \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ans[j][1]>=intervals[i][0])\\n            {\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }           \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205936,
                "title": "c-detailed-explaination-beats-100-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Explanation:**\\n* Sort the 2D vector.\\n* Then initialize a temp variable with the 1st pair from the intervals.\\n* Now we take each pair and compare its 1st element to the 2nd element of the temp to check whether it intersects with the pair.\\n* If it\\'s <= then we take max of temp\\'s 2nd element and the pair\\'s 2nd element and update it to the 2nd element of the temp.\\n* Else we just push temp to answer vector and update temp with the current pair from the loop.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        if(intervals.size()==0) \\n            return ans;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<int> temp=intervals[0];\\n        \\n        for(auto it: intervals)\\n        {\\n            if(it[0]<=temp[1])\\n            {\\n                temp[1]=max(it[1],temp[1]);\\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\\n\\nT.C -> `O(Nlog(N)) +O(N)`\\nS.C=`O(N)`\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        if(intervals.size()==0) \\n            return ans;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<int> temp=intervals[0];\\n        \\n        for(auto it: intervals)\\n        {\\n            if(it[0]<=temp[1])\\n            {\\n                temp[1]=max(it[1],temp[1]);\\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871008,
                "title": "c-very-very-simple-code-easy-to-understand",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        int n=intervals.size(),start=intervals[0][0],end=intervals[0][1];\\n        for(int i=1;i<n;++i){\\n            if(intervals[i][0]<=end) end=max(end,intervals[i][1]);\\n            else res.push_back({start,end}),start=intervals[i][0],end=intervals[i][1];\\n        }\\n        res.push_back({start,end});\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        int n=intervals.size(),start=intervals[0][0],end=intervals[0][1];\\n        for(int i=1;i<n;++i){\\n            if(intervals[i][0]<=end) end=max(end,intervals[i][1]);\\n            else res.push_back({start,end}),start=intervals[i][0],end=intervals[i][1];\\n        }\\n        res.push_back({start,end});\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1644276,
                "title": "python-java-c-2-simple-solutions-o-n-r-and-o-nlogn-image-visualized-explanation",
                "content": "**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!** \\uD83D\\uDE01\\n\\n* **step 1: sort the intervals**\\n\\t* that means` intervals[i][0] >= intervals[i - 1][0]` after sorting\\n* **step 2: for each interval `[x, y]` in `intervals`:**\\n\\t* compare `[x, y]` and `ans.back() or ans[-1]`\\n\\t* There are 3 possible situations as shown in the figure below\\n\\t\\t* 1st: nothing to do\\n\\t\\t* 2nd: enlarge the `ans[-1][1] = y`\\n\\t\\t* 3rd: append `[x, y]` to `ans`\\n\\n![image](https://assets.leetcode.com/users/images/fba68a60-56fb-4158-b66a-dcb8c235242d_1640323116.0364041.jpeg)\\n\\n* **The difference between 2 solutions focus on the sort approach.**\\n\\t* **Solusion 1 O(NlogN)**\\n\\t\\t* use some standard sort approach like quick sort cost `O(NlogN)`\\n\\t* **Solution 2 O(N+R)**\\n\\t\\t* Fortunately, since `0 <= start_i <= end_i <= 10000`, we can use Hash Sort with hash bucket `R = max(start_i)` cost `O(N)` time.\\n\\t\\t\\t```\\n\\t\\t        R = max([x for [x, _] in intervals]) + 1\\n\\t\\t\\t\\tdata = [[] for x in range(R)]\\n\\t\\t\\t\\tfor [x, y] in intervals:\\n\\t\\t\\t\\t\\tdata[x].append(y)\\n\\t\\t\\t```\\n\\t\\t* Then traverse all `intervals` cost `O(N+R)` time\\n\\n\\n**C++ O(NlogN) Runtime: 12 ms, faster than 98.58%**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < intervals.size(); i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.empty() || x > ans.back()[1])\\n                ans.push_back(intervals[i]);\\n            else if (ans.back()[1] < y)\\n                ans.back()[1] = y;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Python O(NlogN) Runtime: 56 ms, faster than 98.37%**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        for [x, y] in sorted(intervals):\\n            if not ans or x > ans[-1][1]:\\n                ans.append([x, y])\\n            elif ans[-1][1] < y:\\n                ans[-1][1] = y\\n        return ans\\n```\\n**Python O(N+R) Runtime: 60 ms, faster than 94.11%**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        R = max([x for [x, _] in intervals]) + 1\\n        data = [[] for x in range(R)]\\n        for [x, y] in intervals:\\n            data[x].append(y)\\n        ans = []\\n        for x in range(R):\\n            for y in data[x]:\\n                if not ans or x > ans[-1][1]:\\n                    ans.append([x, y])\\n                elif ans[-1][1] < y:\\n                    ans[-1][1] = y\\n        return ans\\n```\\n\\n**Java O(NlogN) Runtime: 5 ms, faster than 95.64%**\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n        ArrayList<int[]> ans = new ArrayList<>(intervals.length);  \\n        for (int i = 0; i < intervals.length; i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.isEmpty() || x > ans.get(ans.size() - 1)[1])\\n                ans.add(intervals[i]);\\n            else if (ans.get(ans.size() - 1)[1] < y)\\n                ans.get(ans.size() - 1)[1] = y;\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [],
                "code": "```\\n\\t\\t        R = max([x for [x, _] in intervals]) + 1\\n\\t\\t\\t\\tdata = [[] for x in range(R)]\\n\\t\\t\\t\\tfor [x, y] in intervals:\\n\\t\\t\\t\\t\\tdata[x].append(y)\\n\\t\\t\\t```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < intervals.size(); i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.empty() || x > ans.back()[1])\\n                ans.push_back(intervals[i]);\\n            else if (ans.back()[1] < y)\\n                ans.back()[1] = y;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        for [x, y] in sorted(intervals):\\n            if not ans or x > ans[-1][1]:\\n                ans.append([x, y])\\n            elif ans[-1][1] < y:\\n                ans[-1][1] = y\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        R = max([x for [x, _] in intervals]) + 1\\n        data = [[] for x in range(R)]\\n        for [x, y] in intervals:\\n            data[x].append(y)\\n        ans = []\\n        for x in range(R):\\n            for y in data[x]:\\n                if not ans or x > ans[-1][1]:\\n                    ans.append([x, y])\\n                elif ans[-1][1] < y:\\n                    ans[-1][1] = y\\n        return ans\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n        ArrayList<int[]> ans = new ArrayList<>(intervals.length);  \\n        for (int i = 0; i < intervals.length; i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.isEmpty() || x > ans.get(ans.size() - 1)[1])\\n                ans.add(intervals[i]);\\n            else if (ans.get(ans.size() - 1)[1] < y)\\n                ans.get(ans.size() - 1)[1] = y;\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643943,
                "title": "python3-easy-to-understand-explained",
                "content": "First of all, we have to sort the input intervals by the start value. That will let us easily merge overlapping intervals. We just iterate over sorted intervals and compare the start and the end of adjacent intervals. If the end of the previous interval is greater or equal to the start of the next one, that means we can merge them. To merge two intervals we just expand the end of the previous interval to the end of the next.\\n\\nTime: **O(NlogN)** - sorting\\nSpace: **O(N)** - sorting in Python\\n\\nRuntime: 76 ms, faster than **97.62%** of Python3 online submissions for Merge Intervals.\\nMemory Usage: 16.2 MB, less than **10.13%** of Python3 online submissions for Merge Intervals.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        sortedInt = sorted(intervals, key = lambda i: i[0])\\n        res = list()\\n\\n        for start, end in sortedInt:\\n            if res and res[-1][1] >= start:\\n                res[-1][1] = max(res[-1][1], end)\\n            else:\\n                res.append([start, end])\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        sortedInt = sorted(intervals, key = lambda i: i[0])\\n        res = list()\\n\\n        for start, end in sortedInt:\\n            if res and res[-1][1] >= start:\\n                res[-1][1] = max(res[-1][1], end)\\n            else:\\n                res.append([start, end])\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408247,
                "title": "simple-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        int n = intervals.length;\\n        if(n==0) return new int[0][0];\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        List<int[]> res = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int[] temp = intervals[i];\\n            int j = i+1;\\n            while(j<n && intervals[j][0]<=temp[1]){\\n                temp[1] = Math.max(temp[1], intervals[j][1]);\\n                j+=1;\\n            }\\n            i = j - 1;\\n            res.add(temp);\\n        }\\n        int m = res.size();\\n        return res.toArray(new int[m][2]);\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        int n = intervals.length;\\n        if(n==0) return new int[0][0];\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        List<int[]> res = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int[] temp = intervals[i];\\n            int j = i+1;\\n            while(j<n && intervals[j][0]<=temp[1]){\\n                temp[1] = Math.max(temp[1], intervals[j][1]);\\n                j+=1;\\n            }\\n            i = j - 1;\\n            res.add(temp);\\n        }\\n        int m = res.size();\\n        return res.toArray(new int[m][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577210,
                "title": "go",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    var res [][]int\\n    i := 0\\n    for i < len(intervals) {\\n        left, right := intervals[i][0], intervals[i][1]\\n        j := i+1\\n        for j < len(intervals) && intervals[j][0] <= right {\\n            right = max(right, intervals[j][1])\\n            j++\\n        }\\n        res = append(res, []int{left, right})\\n        i = j\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    var res [][]int\\n    i := 0\\n    for i < len(intervals) {\\n        left, right := intervals[i][0], intervals[i][1]\\n        j := i+1\\n        for j < len(intervals) && intervals[j][0] <= right {\\n            right = max(right, intervals[j][1])\\n            j++\\n        }\\n        res = append(res, []int{left, right})\\n        i = j\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387369,
                "title": "simple-java-o-n-log-n-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0)\\n            return new int[0][0];\\n        \\n        Arrays.sort(intervals, ((x, y) -> x[0] - y[0]));\\n        List<int[]> merged = new ArrayList<>();\\n        int[] current = intervals[0];\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (current[1] >= intervals[i][0])\\n                current[1] = Math.max(current[1], intervals[i][1]);\\n            else {\\n                merged.add(current);\\n                current = intervals[i];                \\n            }\\n        }\\n        merged.add(current);\\n        return merged.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0)\\n            return new int[0][0];\\n        \\n        Arrays.sort(intervals, ((x, y) -> x[0] - y[0]));\\n        List<int[]> merged = new ArrayList<>();\\n        int[] current = intervals[0];\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (current[1] >= intervals[i][0])\\n                current[1] = Math.max(current[1], intervals[i][1]);\\n            else {\\n                merged.add(current);\\n                current = intervals[i];                \\n            }\\n        }\\n        merged.add(current);\\n        return merged.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153979,
                "title": "elegant-c-solutions-one-without-modifying-intervals-and-one-inplace",
                "content": "# Without modifying `intervals`\\nSince we can\\'t sort interval, we want to instead ensure our destination vector is sorted. A insertion sort is required then. Insertion should be done as follows;\\n1. Find first destination interval that _ends_ after the incoming interval _starts_. Called _it_\\n2. If no such interval is found or the incoming interval _end_ is less than found intervals _start_ then we can just insert and be done.\\n3. Otherwise there must be an overlap, but it could be more than one. Do another search, this time for the first interval whose _start_ is greater than incoming interval _end_. Called _last_\\n4. Everything from [_it_, _last_) can be merged together with incoming interval into a single interval\\n\\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      std::vector<Interval> ret;\\n      \\n      for (auto& interval : intervals) {\\n        auto it = std::lower_bound(ret.begin(), ret.end(), interval.start, [](const Interval& l, int r) { return l.end < r; });\\n        \\n        if (it == ret.end() || interval.end < it->start) \\n          // No overlap, insert as is\\n          ret.insert(it, interval);\\n        else {\\n          // There is an overlap, there might be more, so find the upper bound too\\n          it->start = std::min(it->start, interval.start);\\n          auto last = std::upper_bound(it, ret.end(), interval.end, [](int l, const Interval& r) { return l < r.start; });\\n          it->end = std::max((last - 1)->end, interval.end);\\n          ret.erase(it + 1, last);\\n        }\\n      }\\n      return ret;\\n    }\\n```\\n\\n# Modifying `intervals`\\nIt would be helpful if the question specified whether or not the intervals are sorted, since the examples provided are sorted (by start). Never the less, once you get over that, and sort the list yourself, there is really only two options to consider.\\n\\n1. Two adjacent intervals don\\'t overlap\\n2. Two adjacent intervals overlap\\n\\nWell the first case is simple, there is nothing to see and we can just move alone to the next pair.\\nIn the second case, we know that _a[i].end_ is greater than or equal to _a[i + 1].start_ or there would be no overlap. Therefore the intervals can and should be merged into one. The merge is quite simple, we know that _a[i].start_ is less or equal to _a[i + 1].start_ since we sorted it that way. Hence the merged interval must start with _a[i].start_. The only other thing to consider is which interval ends last and do a simple max.\\n\\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      if (1 >= intervals.size()) {\\n        return intervals;\\n      }\\n      \\n      std::sort(intervals.begin(), intervals.end(), [](const Interval& l, const Interval& r) { return l.start < r.start; });\\n      \\n      auto curr = intervals.begin();\\n      auto next = curr;\\n      while (++next != intervals.end()) {\\n        if (curr->end >= next->start) {\\n          // There is an overlap, merge the two into the current\\n          curr->end = std::max(curr->end, next->end);\\n        } else {\\n          // There is no overlap, move the next to the end of our accepted intervals\\n          // If one or more preceeding intervals are no longer required, then one will be overwritten here\\n          *(++curr) = *next;\\n        }\\n      }\\n      // Mop up the rest\\n      intervals.erase(curr + 1, intervals.end());\\n      return intervals;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      std::vector<Interval> ret;\\n      \\n      for (auto& interval : intervals) {\\n        auto it = std::lower_bound(ret.begin(), ret.end(), interval.start, [](const Interval& l, int r) { return l.end < r; });\\n        \\n        if (it == ret.end() || interval.end < it->start) \\n          // No overlap, insert as is\\n          ret.insert(it, interval);\\n        else {\\n          // There is an overlap, there might be more, so find the upper bound too\\n          it->start = std::min(it->start, interval.start);\\n          auto last = std::upper_bound(it, ret.end(), interval.end, [](int l, const Interval& r) { return l < r.start; });\\n          it->end = std::max((last - 1)->end, interval.end);\\n          ret.erase(it + 1, last);\\n        }\\n      }\\n      return ret;\\n    }\\n```\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      if (1 >= intervals.size()) {\\n        return intervals;\\n      }\\n      \\n      std::sort(intervals.begin(), intervals.end(), [](const Interval& l, const Interval& r) { return l.start < r.start; });\\n      \\n      auto curr = intervals.begin();\\n      auto next = curr;\\n      while (++next != intervals.end()) {\\n        if (curr->end >= next->start) {\\n          // There is an overlap, merge the two into the current\\n          curr->end = std::max(curr->end, next->end);\\n        } else {\\n          // There is no overlap, move the next to the end of our accepted intervals\\n          // If one or more preceeding intervals are no longer required, then one will be overwritten here\\n          *(++curr) = *next;\\n        }\\n      }\\n      // Mop up the rest\\n      intervals.erase(curr + 1, intervals.end());\\n      return intervals;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811263,
                "title": "5-line-easy-code-simple-line-by-line-code-explanation-sorting",
                "content": "# \\u2705Intuition \\u2705\\nif the ending time of current intervals is greater than or eqaul to starting time of next interval, in this case overlapping of intervals occuring. in this case we merge these both intervals together.\\nexample:\\n[2,4] [3,6] [7,13] [10,12]\\n\\n1. in above example interval 1 and 2 will be overlap as ending time of 1st interval(which is 4) is greater than starting time of 2nd interval(which is 3). now merged interval range will be [2,6]\\nwe take max(4,6) for find ending  time of merged interval.so intetval will be [2,6]\\n\\n2. now we start comparing of new formed interval to next interval.\\n\\n3. In this time we have to compare [2,6] with [7,13] ,since 6 is less than 7 so here is no interval.\\n\\n4. Last we have [7,13] and [10,12] , since 10 is less than 13 so here will be overlapping. now we have to merge these both intervals but there is question that what will be ending time of merged interval.\\n\\nending time of merged interval will be :: max(13,12) which is 13.\\n \\nso, in this case final merged interval will be [7,13].\\n \\n\\n# Approach\\u2705\\n  Carefully read above intitution part you will find complete answer. how we have to approach this question\\u2705.\\n\\n\\n **if you find helpful, kindly upvote \\uD83D\\uDE80 ... Thanks** \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        for(int i = 0 ; i<n ;i++){\\n            if(ans.empty()){//1st time ans will be empty then simply push_back intervals in ans\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                vector<int>&v = ans.back();\\n                int y = v[1]; // end time of previous intervals compare y with i\\'s start time\\n                //intervals[i][0] ---> means start time || intervals[i][1] --> end time \\n             //in case of overlapping of intervals   \\n             if(intervals[i][0] <= y){//start time next interv. is <=prev. interval(overlap)\\n                //[2,4] [3,5] ---->merged interval will[2,5],end point will be max(4,5) \\n                   v[1] = max(intervals[i][1] , y);\\n                }\\n                // in case of no overlapping\\n                else{\\n                   ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Brainteaser",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        for(int i = 0 ; i<n ;i++){\\n            if(ans.empty()){//1st time ans will be empty then simply push_back intervals in ans\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                vector<int>&v = ans.back();\\n                int y = v[1]; // end time of previous intervals compare y with i\\'s start time\\n                //intervals[i][0] ---> means start time || intervals[i][1] --> end time \\n             //in case of overlapping of intervals   \\n             if(intervals[i][0] <= y){//start time next interv. is <=prev. interval(overlap)\\n                //[2,4] [3,5] ---->merged interval will[2,5],end point will be max(4,5) \\n                   v[1] = max(intervals[i][1] , y);\\n                }\\n                // in case of no overlapping\\n                else{\\n                   ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777963,
                "title": "c-sc-o-1-without-using-another-data-structure-i-e-in-place-solution",
                "content": "# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end());\\n\\n        for(int i = 1;i < v.size();){\\n            if(v[i - 1][1] >= v[i][0]){\\n                v[i - 1][1] = max(v[i][1],v[i - 1][1]);\\n                v.erase(v.begin() + i);\\n            }\\n            else i++;\\n            // why i++ in else (dry run this TC)\\n            // [0,2],[1,4],[3,5]\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end());\\n\\n        for(int i = 1;i < v.size();){\\n            if(v[i - 1][1] >= v[i][0]){\\n                v[i - 1][1] = max(v[i][1],v[i - 1][1]);\\n                v.erase(v.begin() + i);\\n            }\\n            else i++;\\n            // why i++ in else (dry run this TC)\\n            // [0,2],[1,4],[3,5]\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452633,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1){\\n            return intervals;\\n        } \\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]){\\n                output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            } \\n            else{\\n                output.push_back(intervals[i]); \\n            }\\n        }\\n        return output;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1){\\n            return intervals;\\n        } \\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]){\\n                output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            } \\n            else{\\n                output.push_back(intervals[i]); \\n            }\\n        }\\n        return output;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058812,
                "title": "simple-c-sorting-merging",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all we should sort so that we can do linear search ,otherwise we have to do it in O(n^2) because if unsorted then some intervals will be left at end some will be at begining so if we sort we will have contiguous intervals and then we can merge them in linear fashion.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just check if intervals are overlapping and if are then just merge \\nand this can be done by two operations :\\n- `min(a[1], b[1]) - max(a[0], b[0]) >= 0;` can be used to detect if some element is common between two intervals u can just take an exapmple and dry run it.\\n- `{min(a[0], b[0]), max(a[1], b[1])};` gives us the resulting merged interval.\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool doesIntervalsOverlap(vector<int>& a, vector<int>& b) {\\n        return min(a[1], b[1]) - max(a[0], b[0]) >= 0;\\n    }\\n\\n     vector<int> mergeIntervals(vector<int>& a, vector<int>& b) {\\n        return {min(a[0], b[0]), max(a[1], b[1])};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& inv) {\\n        int n=inv.size();\\n        vector<vector<int>>v;\\n        int i=0;\\n        sort(inv.begin(),inv.end());\\n        while(i<n){\\n            vector<int>curr=inv[i++];\\n            vector<int>merge=curr;\\n           while(i<n and doesIntervalsOverlap(curr,inv[i])){\\n               merge=mergeIntervals(curr,inv[i]);\\n               curr=merge;\\n               i++;\\n           }\\n           v.push_back(merge);\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool doesIntervalsOverlap(vector<int>& a, vector<int>& b) {\\n        return min(a[1], b[1]) - max(a[0], b[0]) >= 0;\\n    }\\n\\n     vector<int> mergeIntervals(vector<int>& a, vector<int>& b) {\\n        return {min(a[0], b[0]), max(a[1], b[1])};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& inv) {\\n        int n=inv.size();\\n        vector<vector<int>>v;\\n        int i=0;\\n        sort(inv.begin(),inv.end());\\n        while(i<n){\\n            vector<int>curr=inv[i++];\\n            vector<int>merge=curr;\\n           while(i<n and doesIntervalsOverlap(curr,inv[i])){\\n               merge=mergeIntervals(curr,inv[i]);\\n               curr=merge;\\n               i++;\\n           }\\n           v.push_back(merge);\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051071,
                "title": "c-easy-solution-with-explanation",
                "content": "\\n# Approach\\nSort the given array intervals.\\nConsider a new array answer. Insert into it the first elements of intervals. Now consider the next elements of intervals. If the smaller number of next elements of intervals is less than or equal to larger number of previous elements, update the larger number of previous elements by maximum of the larger number of both elements.\\nOtherwise, simply insert the next elements in the answer.   \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        int i=0;\\n        int j=0;\\n        sort(intervals.begin(),intervals.end());\\n        ans.push_back(intervals[0]);//insert the first element\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=ans[j][1]){\\n                //update previous element\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else{\\n                //add new element to answer\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        int i=0;\\n        int j=0;\\n        sort(intervals.begin(),intervals.end());\\n        ans.push_back(intervals[0]);//insert the first element\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=ans[j][1]){\\n                //update previous element\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else{\\n                //add new element to answer\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285879,
                "title": "c-easy-explanation-brute-to-optimal-interview-prep",
                "content": "# Intuition\\n- First we will check if the array of intervals given is already `sorted or not`.\\n- If not then we will `sort` it .\\n- Then we for merging we will check if the `first index of second interval is less than second index of first interval`.\\n- If the above case satisfies then we will merge them otherwise we will push that interval as it is in the result and use it for further comparison.\\n- The above logic is more explained in the approaches below.\\n# Approaches\\n## 1.Brute Force\\n- `Sorting` the intervals in ascending order.\\n- Using `2 loops` for $$iterating$$ and `linear searching of interval`.\\n- `Outer loop` is for iterating the array .\\n- `Inner Loop` is for linear search that if the any interval is overlapping with the interval of the current iteration.\\n### Code\\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& arr) {\\n    int n = arr.size(); // Get the size of the input vector\\n    sort(arr.begin(), arr.end()); // Sort the intervals based on their starting points\\n    vector<vector<int>> ans; // Initialize an empty vector to store the merged intervals\\n\\n    for (int i = 0; i < n; i++) { // Iterate through each interval\\n        int start = arr[i][0], end = arr[i][1];\\n\\n        // If the last interval in the merged intervals vector overlaps with the current interval, skip the current interval\\n        if (!ans.empty()) {\\n            if (start <= ans.back()[1]) {\\n                continue;\\n            }\\n        }\\n\\n        // Iterate through the remaining intervals and merge overlapping intervals\\n        for (int j = i + 1; j < n; j++) {\\n            if (arr[j][0] <= end) {\\n                end = max(end, arr[j][1]);\\n            }\\n        }\\n\\n        // Store the merged interval in the answer vector\\n        end = max(end, arr[i][1]);\\n        ans.push_back({start, end});\\n    }\\n\\n    return ans; // Return the merged intervals\\n}\\n```\\n### Complexity\\n- **Time Complexity** - $O(NlogN)+O(N*N). O(NlogN)$\\n- **Space Complexity** - $O(N)$\\n## 2. Optimal Approach\\n- Linearly iterate over the array if the data structure is empty insert the interval in the data structure.\\n- If the last element in the data structure overlaps with the current interval we merge the intervals by updating the last element in the data structure, and if the current interval does not overlap with the last element in the data structure simply insert it into the data structure.\\n- Since we have sorted the intervals, the intervals which will be merging are bound to be adjacent. \\n- We `kept on merging simultaneously` as we were traversing through the array and when the element was non-overlapping we simply inserted the element in our data structure.\\n### Code\\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    vector<vector<int>> mergedInterval; // Initialize an empty vector to store merged intervals\\n    if(intervals.size()==0)\\n      {\\n        return mergedInterval;\\n      }\\n    sort(intervals.begin(),intervals.end()); // Sort the input intervals based on the start time\\n\\n    vector<int> tempInterval = intervals[0]; // Initialize a temporary interval with the first interval in the sorted list\\n\\n    for(auto i:intervals)\\n    {\\n        if(i[0]<= tempInterval[1]) // If the current interval\\'s start time is less than or equal to the end time of the temporary interval\\n        {\\n            tempInterval[1]=max(i[1],tempInterval[1]); // Update the end time of the temporary interval with the maximum of the end times of current interval and the temporary interval\\n        }\\n        else\\n        {\\n            mergedInterval.push_back(tempInterval); // If the current interval\\'s start time is greater than the end time of the temporary interval, push the temporary interval into the merged intervals vector\\n            tempInterval = i; // Update the temporary interval with the current interval\\n        }\\n    }\\n    mergedInterval.push_back(tempInterval); // Push the last temporary interval into the merged intervals vector\\n    return mergedInterval; // Return the merged intervals vector\\n}\\n```\\n### Complexity\\n- **Time Complexity -** $O(NlogN) + O(N). O(NlogN)$\\n- **Space Complexity -** $O(N)$\\n\\n**Thank You!** for reading . Do upvote\\uD83D\\uDC4Dif you like the explanantion and if there is any scope of improvement do mention it in the comments  \\uD83D\\uDE01.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\nvector<vector<int>> merge(vector<vector<int>>& arr) {\\n    int n = arr.size(); // Get the size of the input vector\\n    sort(arr.begin(), arr.end()); // Sort the intervals based on their starting points\\n    vector<vector<int>> ans; // Initialize an empty vector to store the merged intervals\\n\\n    for (int i = 0; i < n; i++) { // Iterate through each interval\\n        int start = arr[i][0], end = arr[i][1];\\n\\n        // If the last interval in the merged intervals vector overlaps with the current interval, skip the current interval\\n        if (!ans.empty()) {\\n            if (start <= ans.back()[1]) {\\n                continue;\\n            }\\n        }\\n\\n        // Iterate through the remaining intervals and merge overlapping intervals\\n        for (int j = i + 1; j < n; j++) {\\n            if (arr[j][0] <= end) {\\n                end = max(end, arr[j][1]);\\n            }\\n        }\\n\\n        // Store the merged interval in the answer vector\\n        end = max(end, arr[i][1]);\\n        ans.push_back({start, end});\\n    }\\n\\n    return ans; // Return the merged intervals\\n}\\n```\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    vector<vector<int>> mergedInterval; // Initialize an empty vector to store merged intervals\\n    if(intervals.size()==0)\\n      {\\n        return mergedInterval;\\n      }\\n    sort(intervals.begin(),intervals.end()); // Sort the input intervals based on the start time\\n\\n    vector<int> tempInterval = intervals[0]; // Initialize a temporary interval with the first interval in the sorted list\\n\\n    for(auto i:intervals)\\n    {\\n        if(i[0]<= tempInterval[1]) // If the current interval\\'s start time is less than or equal to the end time of the temporary interval\\n        {\\n            tempInterval[1]=max(i[1],tempInterval[1]); // Update the end time of the temporary interval with the maximum of the end times of current interval and the temporary interval\\n        }\\n        else\\n        {\\n            mergedInterval.push_back(tempInterval); // If the current interval\\'s start time is greater than the end time of the temporary interval, push the temporary interval into the merged intervals vector\\n            tempInterval = i; // Update the temporary interval with the current interval\\n        }\\n    }\\n    mergedInterval.push_back(tempInterval); // Push the last temporary interval into the merged intervals vector\\n    return mergedInterval; // Return the merged intervals vector\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1755996,
                "title": "merge-intervals",
                "content": "class Solution{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a)\\n\\t{\\n         vector<vector<int>> res;\\n        \\n         if (a.size() == 0)\\n            return res;\\n        \\n        sort(a.begin(), a.end());\\n        res.push_back(a[0]);\\n        int j = 0;\\n        for (int i = 1; i < a.size(); i++)\\n        {\\n            if (res[j][1] >= a[i][0])\\n            {\\n                res[j][1] = max(res[j][1], a[i][1]);\\n            }\\n            else\\n            {\\n                res.push_back(a[i]);\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a)\\n\\t{\\n         vector<vector<int>> res;\\n        \\n         if (a.size() == 0)\\n            return res;\\n        \\n        sort(a.begin(), a.end());\\n        res.push_back(a[0]);\\n        int j = 0;\\n        for (int i = 1; i < a.size(); i++)\\n        {\\n            if (res[j][1] >= a[i][0])\\n            {\\n                res[j][1] = max(res[j][1], a[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1660021,
                "title": "java-simple-and-clean-solution-understandable-explanation",
                "content": "1) First we sort the list based on interval[i][0];\\n2) Compare end of current to start of next -\\n\\ti) if end of current is larger than start of next then we merge the interval but not add to list to check further intervals(we track this with s,e,start and end variables)\\n\\tii) if above condition is not met then we add interval to list(start,end).\\n3. we convert list to array and return.\\n\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals,(o1,o2)->Integer.compare(o1[0], o2[0]));\\n        List<int[]> ansList = new ArrayList<int[]>();\\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        int e,s;\\n        int i =0;\\n        int[] newInterval = intervals[0];\\n        while(i<intervals.length)\\n        {\\n            s = intervals[i][0];\\n            e = intervals[i][1];\\n            if(s<=end)\\n                end = Math.max(end,e);\\n            else\\n            {\\n                ansList.add(new int[]{start,end});\\n                start = s;\\n                end =  e;  \\n            }\\n            i++;\\n        }\\n        ansList.add(new int[] {start,end});\\n        return ansList.toArray(new int[ansList.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals,(o1,o2)->Integer.compare(o1[0], o2[0]));\\n        List<int[]> ansList = new ArrayList<int[]>();\\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        int e,s;\\n        int i =0;\\n        int[] newInterval = intervals[0];\\n        while(i<intervals.length)\\n        {\\n            s = intervals[i][0];\\n            e = intervals[i][1];\\n            if(s<=end)\\n                end = Math.max(end,e);\\n            else\\n            {\\n                ansList.add(new int[]{start,end});\\n                start = s;\\n                end =  e;  \\n            }\\n            i++;\\n        }\\n        ansList.add(new int[] {start,end});\\n        return ansList.toArray(new int[ansList.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067545,
                "title": "python-beats-90",
                "content": "```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not intervals or len(intervals) == 1:\\n            return intervals\\n        \\n        intervals = sorted(intervals, key=lambda x: x[0])\\n        \\n        mergedIntervals = []\\n        \\n        for interval in intervals:\\n            if not mergedIntervals or interval[0] > mergedIntervals[-1][1]:\\n                mergedIntervals.append(interval)\\n            else:\\n                mergedIntervals[-1][1] = max(interval[1], mergedIntervals[-1][1])\\n        \\n        return mergedIntervals\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not intervals or len(intervals) == 1:\\n            return intervals\\n        \\n        intervals = sorted(intervals, key=lambda x: x[0])\\n        \\n        mergedIntervals = []\\n        \\n        for interval in intervals:\\n            if not mergedIntervals or interval[0] > mergedIntervals[-1][1]:\\n                mergedIntervals.append(interval)\\n            else:\\n                mergedIntervals[-1][1] = max(interval[1], mergedIntervals[-1][1])\\n        \\n        return mergedIntervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940485,
                "title": "simple-o-nlogn-solution-sort-and-merge",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        intervals.sort(key=lambda x: x[0])\\n        begin, end = intervals[0][0], intervals[0][1]\\n        for interval in intervals[1:]:\\n            if interval[0] <= end:\\n                end = max(end, interval[1])\\n            else:\\n                result.append([begin, end])\\n                begin, end = interval[0], interval[1]\\n        result.append([begin, end])\\n        return result\\n```\\n\\nExplanation:-\\n```\\n1. sort the input, where key is starting time/frist value\\n2. We pick the first interval from the input and iterate over remaining intervals to see which of the following intervals can we merge with the previous interval\\n3. since intervals were sorted based on first value we try to find the overlap by comparing start value of new interval with end value of previous interval\\n4. if there is no overlapping portion, we append previous interval to the output/answer and we reset what is considered to be previous interval\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        intervals.sort(key=lambda x: x[0])\\n        begin, end = intervals[0][0], intervals[0][1]\\n        for interval in intervals[1:]:\\n            if interval[0] <= end:\\n                end = max(end, interval[1])\\n            else:\\n                result.append([begin, end])\\n                begin, end = interval[0], interval[1]\\n        result.append([begin, end])\\n        return result\\n```\n```\\n1. sort the input, where key is starting time/frist value\\n2. We pick the first interval from the input and iterate over remaining intervals to see which of the following intervals can we merge with the previous interval\\n3. since intervals were sorted based on first value we try to find the overlap by comparing start value of new interval with end value of previous interval\\n4. if there is no overlapping portion, we append previous interval to the output/answer and we reset what is considered to be previous interval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874757,
                "title": "help-please-line-1052-char-9-runtime-error-reference-binding-to-null-pointer-of-type",
                "content": "\\nMy code is failing at the 168th test case and I\\'m getting this error, I\\'m not sure why this error is coming, this error is generally encountered due to out of bounds exception, but I don\\'t think there is any problem in my code? Can someone please help me identify the error and help me understand it. Thank you.\\n\\nExact Error: Line 1052: Char 9: runtime error: reference binding to null pointer of type \\'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type\\' (aka \\'const int\\') (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9\\n\\n\\n```\\n bool myComp(const vector<int>& v1, const vector<int>& v2) {\\n        if (v1[0] != v2[0]) {\\n            return v1[0] < v2[0];\\n        } else if (v1[1] != v2[1]) {\\n            return v1[1] < v2[1];\\n        }\\n        return true;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    \\n   \\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        \\n        \\n        if (intervals.empty()) {\\n            return intervals;\\n        }\\n        if (intervals.size() <= 1) {\\n            return intervals;\\n        }\\n        \\n         vector<vector<int>> out;\\n      \\n        sort(intervals.begin(), intervals.end(), myComp);\\n        \\n        \\n        \\n        out.push_back(intervals[0]);\\n        \\n        vector<int> currInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); i++) {\\n            \\n            \\n            if (intervals[i][0] <= currInterval[1]) {\\n                \\n                out[out.size()-1][1] = max(currInterval[1], intervals[i][1]);\\n                currInterval = out[out.size()-1];\\n                \\n            } else {\\n                out.push_back(intervals[i]);\\n                currInterval = intervals[i];\\n            }\\n            \\n        }\\n        return out;\\n        \\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n bool myComp(const vector<int>& v1, const vector<int>& v2) {\\n        if (v1[0] != v2[0]) {\\n            return v1[0] < v2[0];\\n        } else if (v1[1] != v2[1]) {\\n            return v1[1] < v2[1];\\n        }\\n        return true;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    \\n   \\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        \\n        \\n        if (intervals.empty()) {\\n            return intervals;\\n        }\\n        if (intervals.size() <= 1) {\\n            return intervals;\\n        }\\n        \\n         vector<vector<int>> out;\\n      \\n        sort(intervals.begin(), intervals.end(), myComp);\\n        \\n        \\n        \\n        out.push_back(intervals[0]);\\n        \\n        vector<int> currInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); i++) {\\n            \\n            \\n            if (intervals[i][0] <= currInterval[1]) {\\n                \\n                out[out.size()-1][1] = max(currInterval[1], intervals[i][1]);\\n                currInterval = out[out.size()-1];\\n                \\n            } else {\\n                out.push_back(intervals[i]);\\n                currInterval = intervals[i];\\n            }\\n            \\n        }\\n        return out;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590996,
                "title": "my-c-code",
                "content": "inplace\\n```\\nint cmpfunc(int** a, int** b)\\n{\\n    return (*a)[0] - (*b)[0];\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    int* temp=NULL;\\n    int i;\\n    int count = 0;\\n    \\n    if((intervals==NULL) || (intervalsSize==0))\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    qsort(intervals, intervalsSize,sizeof(int*),cmpfunc);\\n    \\n    temp = intervals[0];\\n    for(i=1;i<intervalsSize;i++)\\n    {\\n        if(temp[1] >= intervals[i][0])\\n        {\\n            temp[1] = (temp[1] > intervals[i][1])?temp[1]:intervals[i][1];\\n        }\\n        else\\n        {\\n            intervals[count][0] = temp[0];\\n            intervals[count][1] = temp[1];\\n            count++;\\n            temp = intervals[i];\\n        }\\n    }\\n    intervals[count][0] = temp[0];\\n    intervals[count][1] = temp[1];\\n    count++;\\n\\n    *returnSize = count;\\n    (*returnColumnSizes) = (int*)malloc(count*sizeof(int));\\n    for(i=0;i<count;i++)\\n    {\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    return intervals;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(int** a, int** b)\\n{\\n    return (*a)[0] - (*b)[0];\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    int* temp=NULL;\\n    int i;\\n    int count = 0;\\n    \\n    if((intervals==NULL) || (intervalsSize==0))\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    qsort(intervals, intervalsSize,sizeof(int*),cmpfunc);\\n    \\n    temp = intervals[0];\\n    for(i=1;i<intervalsSize;i++)\\n    {\\n        if(temp[1] >= intervals[i][0])\\n        {\\n            temp[1] = (temp[1] > intervals[i][1])?temp[1]:intervals[i][1];\\n        }\\n        else\\n        {\\n            intervals[count][0] = temp[0];\\n            intervals[count][1] = temp[1];\\n            count++;\\n            temp = intervals[i];\\n        }\\n    }\\n    intervals[count][0] = temp[0];\\n    intervals[count][1] = temp[1];\\n    count++;\\n\\n    *returnSize = count;\\n    (*returnColumnSizes) = (int*)malloc(count*sizeof(int));\\n    for(i=0;i<count;i++)\\n    {\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    return intervals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365871,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals.length <= 1)\\n            return intervals;\\n        \\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n        int[] newInterval = intervals[0];\\n        result.add(newInterval);\\n        for(int[] interval : intervals){\\n            if(newInterval[1] >= interval[0])\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            else{\\n                newInterval = interval;\\n                result.add(newInterval);\\n            }\\n        }\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```\\n\\nRuntime: 38 ms, faster than 25.25% of Java online submissions for Merge Intervals.\\nMemory Usage: 37.4 MB, less than 98.55% of Java online submissions for Merge Intervals.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals.length <= 1)\\n            return intervals;\\n        \\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n        int[] newInterval = intervals[0];\\n        result.add(newInterval);\\n        for(int[] interval : intervals){\\n            if(newInterval[1] >= interval[0])\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            else{\\n                newInterval = interval;\\n                result.add(newInterval);\\n            }\\n        }\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354775,
                "title": "python-short-and-easy-to-understand-solution-0-nlog-n",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x[0]):\\n            if res and i[0]<=res[-1][1]:\\n                 res[-1][1] = max(i[1], res[-1][1])\\n            else:\\n                res +=[i]\\n        return res\\n\\t\\t\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x[0]):\\n            if res and i[0]<=res[-1][1]:\\n                 res[-1][1] = max(i[1], res[-1][1])\\n            else:\\n                res +=[i]\\n        return res\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 295485,
                "title": "two-java-solutions-with-updated-input",
                "content": "The input of this question has been changed from `List<Interval>` to `int[][] intervals`. \\nHere are two solutions based on sorting the input. \\nTheoretically, both of their runtimes are `O(nlogn)` from sorting. \\nI personally like Solution1, but somehow Solution2 runs faster. \\n\\nSolution 1: \\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;   \\n        int len = intervals.length; \\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0])); // O(nlogn)\\n        int start = intervals[0][0]; \\n        int end = intervals[0][1]; \\n        \\n        List<int[]> result = new ArrayList<>(); \\n        \\n        for(int[] interval : intervals){\\n            if(interval[0] <= end){\\n                end = Math.max(end, interval[1]); \\n            }\\n            else{\\n                result.add(new int[]{start, end}); \\n                start = interval[0]; \\n                end = interval[1]; \\n            }\\n        }\\n        result.add(new int[]{start, end}); \\n\\t\\t\\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```\\n\\nSolution2: \\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;\\n        \\n        int len = intervals.length; \\n        int[] starts = new int[len]; \\n        int[] ends = new int[len]; \\n        \\n        for(int i = 0; i < len; i++){\\n            starts[i] = intervals[i][0]; \\n            ends[i] = intervals[i][1]; \\n        }\\n        \\n        Arrays.sort(starts); // O(nlogn)\\n        Arrays.sort(ends); \\n        \\n        int i = 0;   // i -> index for starts[]\\n        int j = 0;   // j -> index for ends[]\\n        List<int[]> result = new ArrayList<>(); \\n        \\n        while(j < len){   // j will be the index that travals faster. No need to worry about i here\\n            if(j == len - 1 || starts[j + 1] > ends[j]){   // if j reaches the end, add the last interval to result\\n                result.add(new int[]{starts[i], ends[j]}); \\n                i = j + 1; \\n            }\\n            j++; \\n        }\\n        \\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;   \\n        int len = intervals.length; \\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0])); // O(nlogn)\\n        int start = intervals[0][0]; \\n        int end = intervals[0][1]; \\n        \\n        List<int[]> result = new ArrayList<>(); \\n        \\n        for(int[] interval : intervals){\\n            if(interval[0] <= end){\\n                end = Math.max(end, interval[1]); \\n            }\\n            else{\\n                result.add(new int[]{start, end}); \\n                start = interval[0]; \\n                end = interval[1]; \\n            }\\n        }\\n        result.add(new int[]{start, end}); \\n\\t\\t\\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;\\n        \\n        int len = intervals.length; \\n        int[] starts = new int[len]; \\n        int[] ends = new int[len]; \\n        \\n        for(int i = 0; i < len; i++){\\n            starts[i] = intervals[i][0]; \\n            ends[i] = intervals[i][1]; \\n        }\\n        \\n        Arrays.sort(starts); // O(nlogn)\\n        Arrays.sort(ends); \\n        \\n        int i = 0;   // i -> index for starts[]\\n        int j = 0;   // j -> index for ends[]\\n        List<int[]> result = new ArrayList<>(); \\n        \\n        while(j < len){   // j will be the index that travals faster. No need to worry about i here\\n            if(j == len - 1 || starts[j + 1] > ends[j]){   // if j reaches the end, add the last interval to result\\n                result.add(new int[]{starts[i], ends[j]}); \\n                i = j + 1; \\n            }\\n            j++; \\n        }\\n        \\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21241,
                "title": "swift-o-n-log-n-solution-with-inline-comments",
                "content": "Brief Swift implementation with step by step comments.\\n```\\nclass Solution {\\n    func merge(_ intervals: [Interval]) -> [Interval] {\\n        var result: [Interval] = []\\n        // sort the intervals by start so we can test for overlaps sequentially\\n        let intervalsSorted = intervals.sorted(by: {$0.start < $1.start})\\n        \\n        // iterate the intervals\\n        for interval in intervalsSorted {\\n            // does the current interval overlap the last\\n            if !result.isEmpty && interval.start <= result.last!.end {\\n                // there is overlap, rewrite the last interval with the\\n                // higher end value, the start value must be <= current\\n                // due to the prior sort\\n                result.last!.end = max(result.last!.end, interval.end)\\n            } else {\\n                // no overlap (or no last), append current interval\\n                result.append(interval)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func merge(_ intervals: [Interval]) -> [Interval] {\\n        var result: [Interval] = []\\n        // sort the intervals by start so we can test for overlaps sequentially\\n        let intervalsSorted = intervals.sorted(by: {$0.start < $1.start})\\n        \\n        // iterate the intervals\\n        for interval in intervalsSorted {\\n            // does the current interval overlap the last\\n            if !result.isEmpty && interval.start <= result.last!.end {\\n                // there is overlap, rewrite the last interval with the\\n                // higher end value, the start value must be <= current\\n                // due to the prior sort\\n                result.last!.end = max(result.last!.end, interval.end)\\n            } else {\\n                // no overlap (or no last), append current interval\\n                result.append(interval)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21474,
                "title": "14ms-java-in-place-merge-solution",
                "content": "    public class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        int N = intervals.size();\\n        Collections.sort(intervals, new Comparator<Interval>(){\\n        \\tpublic int compare(Interval i, Interval j){\\n                    return i.end - j.end;\\n        \\t}\\n        });\\n        for(int i = N-1; i>0;i--){\\n            Interval inter1 = intervals.get(i-1);\\n\\t        Interval inter2 = intervals.get(i);\\n\\t        if(inter1.end >= inter2.start){\\n\\t            inter1.start = Math.min(inter1.start, inter2.start);\\n\\t            inter1.end = inter2.end; //inter1.end is always smaller than inter2.end because of the sort, so no need to use Math.max()\\n\\t            intervals.remove(i);\\n\\t        }\\n\\t    }\\n        return intervals;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        int N = intervals.size();\\n        Collections.sort(intervals, new Comparator<Interval>(){\\n        \\tpublic int compare(Interval i, Interval j){\\n                    return i.end - j.end;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3432844,
                "title": "easy-python-solution-with-linear-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals=sorted(intervals)\\n        res=[intervals[0]]\\n        for start,end in intervals[1:]:\\n            lastEnd=res[-1][1]\\n            if lastEnd>=start:\\n                res[-1][1]=max(lastEnd,end)\\n            else:\\n                res.append([start,end])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals=sorted(intervals)\\n        res=[intervals[0]]\\n        for start,end in intervals[1:]:\\n            lastEnd=res[-1][1]\\n            if lastEnd>=start:\\n                res[-1][1]=max(lastEnd,end)\\n            else:\\n                res.append([start,end])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425508,
                "title": "awesome-logic-problems",
                "content": "\\n\\n# Python solutions\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x:x[0])\\n        list1=[intervals[0]]\\n        for i ,j in intervals[1:]:\\n            if list1[-1][1]>=i:\\n                list1[-1][1]=max(list1[-1][1],j)\\n            else:\\n                list1.append([i,j])\\n        return list1\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x:x[0])\\n        list1=[intervals[0]]\\n        for i ,j in intervals[1:]:\\n            if list1[-1][1]>=i:\\n                list1[-1][1]=max(list1[-1][1],j)\\n            else:\\n                list1.append([i,j])\\n        return list1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379595,
                "title": "best-o-nlogn-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort (intervals.begin(), intervals.end());\\n        vector<vector<int>> merged;\\n        for (int i = 0; i < n; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            if (!merged.empty()) {\\n                auto last = merged.back();\\n                if (end <= last[1])\\n                    continue;\\n            }  \\n            for (int j = i + 1; j < n; j++) {\\n                if (intervals[j][0] <= end) \\n                    end = max (intervals[j][1], end);\\n            }\\n            merged.push_back({start, end});\\n        }\\n        return merged;\\n    }\\n};\\n```\\n\\n# Approach 2\\nSorting\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> merged;\\n        if (intervals.size() == 0)\\n            return merged;\\n        sort (intervals.begin(), intervals.end());\\n        vector <int> cur = intervals[0];\\n        for (auto it : intervals) {\\n            if (it[0] <= cur[1]) {\\n                cur[1] = max (it[1], cur[1]);\\n            } else {\\n                merged.push_back(cur);\\n                cur = it;\\n            }\\n        }\\n        merged.push_back(cur);\\n        return merged;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort (intervals.begin(), intervals.end());\\n        vector<vector<int>> merged;\\n        for (int i = 0; i < n; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            if (!merged.empty()) {\\n                auto last = merged.back();\\n                if (end <= last[1])\\n                    continue;\\n            }  \\n            for (int j = i + 1; j < n; j++) {\\n                if (intervals[j][0] <= end) \\n                    end = max (intervals[j][1], end);\\n            }\\n            merged.push_back({start, end});\\n        }\\n        return merged;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> merged;\\n        if (intervals.size() == 0)\\n            return merged;\\n        sort (intervals.begin(), intervals.end());\\n        vector <int> cur = intervals[0];\\n        for (auto it : intervals) {\\n            if (it[0] <= cur[1]) {\\n                cur[1] = max (it[1], cur[1]);\\n            } else {\\n                merged.push_back(cur);\\n                cur = it;\\n            }\\n        }\\n        merged.push_back(cur);\\n        return merged;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338016,
                "title": "you-got-it-in-single-sight",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>&ii) {\\n        sort(ii.begin(),ii.end());\\n        vector<vector<int>>ans;\\n        int n=ii.size();\\n        int a=ii[0][0];\\n        int b=ii[0][1];\\n        for(int i=1;i<n;i++){\\n            if(ii[i][0]<=b){\\n                b=max(b,ii[i][1]);\\n            }\\n            else{\\n                ans.push_back({a,b});\\n                a=ii[i][0];\\n                b=ii[i][1];\\n\\n            }\\n        }\\n        ans.push_back({a,b});\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>&ii) {\\n        sort(ii.begin(),ii.end());\\n        vector<vector<int>>ans;\\n        int n=ii.size();\\n        int a=ii[0][0];\\n        int b=ii[0][1];\\n        for(int i=1;i<n;i++){\\n            if(ii[i][0]<=b){\\n                b=max(b,ii[i][1]);\\n            }\\n            else{\\n                ans.push_back({a,b});\\n                a=ii[i][0];\\n                b=ii[i][1];\\n\\n            }\\n        }\\n        ans.push_back({a,b});\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321081,
                "title": "best-c-solution-using-by-reference-vector-and-implementation",
                "content": "# Intuition :\\nObserve the pattern is more clear in case of sorted vector.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : \\nImplementation based \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)+O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n      sort(intervals.begin(), intervals.end());//So that it becomes easier to merge all the smaller intervals first\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n          vector<int> &temp= ans.back();//Accessing last element fo ans vector\\n          if(temp[1]>=intervals[i][0]){\\n            //updating it . This change will also get reflected in ans vector as we have taken temp vector as by reference \\n            temp[1]=max(temp[1], intervals[i][1]);\\n          }\\n          else ans.push_back(intervals[i]);// Just push the element if condition doesn\\'t matched or satisfied\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n      sort(intervals.begin(), intervals.end());//So that it becomes easier to merge all the smaller intervals first\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n          vector<int> &temp= ans.back();//Accessing last element fo ans vector\\n          if(temp[1]>=intervals[i][0]){\\n            //updating it . This change will also get reflected in ans vector as we have taken temp vector as by reference \\n            temp[1]=max(temp[1], intervals[i][1]);\\n          }\\n          else ans.push_back(intervals[i]);// Just push the element if condition doesn\\'t matched or satisfied\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016465,
                "title": "java-solution-using-stack-and-sorting-o-nlogn",
                "content": "# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    // 8 Jaynary 2023\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a1,a2)-> a1[0]-a2[0]); // O(NlogN)\\n\\n        Stack<int[]> stack = new Stack<>(); //O(N)\\n        stack.push(intervals[0]);\\n        int i=1;\\n        while(!stack.isEmpty() && i < intervals.length){ //O(N)\\n            int[] current = stack.peek();\\n            int[] next = intervals[i++];\\n            if(current[1]>=next[0]){\\n                stack.pop();\\n                current[1] = Math.max(current[1], next[1]);\\n                stack.push(current);\\n            }else{\\n                stack.push(next);\\n            }\\n        }\\n\\n        return stack.toArray(new int[stack.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    // 8 Jaynary 2023\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a1,a2)-> a1[0]-a2[0]); // O(NlogN)\\n\\n        Stack<int[]> stack = new Stack<>(); //O(N)\\n        stack.push(intervals[0]);\\n        int i=1;\\n        while(!stack.isEmpty() && i < intervals.length){ //O(N)\\n            int[] current = stack.peek();\\n            int[] next = intervals[i++];\\n            if(current[1]>=next[0]){\\n                stack.pop();\\n                current[1] = Math.max(current[1], next[1]);\\n                stack.push(current);\\n            }else{\\n                stack.push(next);\\n            }\\n        }\\n\\n        return stack.toArray(new int[stack.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848227,
                "title": "intuitive-c-solution-tc-o-nlogn-sc-o-n-single-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf two intervals are overlapping, the new interval will start from the starting time of the first interval and end at the ending time of the maximum end time of the two intervals.\\n\\nThis approach can be generalised for n intervals: If n intervals are overlapping, the resultant interval will start at the starting time of the first interval and end at the ending time of the maximum end time of the n intervals.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the given \\'intervals\\' array. This will ensure that the interval with the lowest starting time is at the beginning.\\n\\nIterate the entire array and initialize a variable \\'maxEnd\\' as the ending value of the ith interval. Also, initialize another variable \\'j\\' with the value after the ith interval.\\n\\nNow, while j is less than the size of the array and the starting time of j is less than (or equal to) maxEnd, assign maxEnd the maximum value of maxEnd and ending time. Finally, increment j.\\n\\nOnce loop is exited (upon either or both conditions being false), pushback into the solution the starting value of i and maxEnd as the starting and ending times of the new interval respectively.\\n\\nSince i will eventually get incremented (due to it being in for loop) and j is now pointing to the new interval, re-initialize i as the value prior to j.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<vector<int>> sol;\\n\\n        sort(intervals.begin(), intervals.end());\\n\\n        for(int i=0;i<n;i++){\\n            int maxEnd=intervals[i][1];\\n            int j=i+1;\\n\\n            while((j<n)&&(intervals[j][0]<=maxEnd)){\\n                maxEnd=max(maxEnd, intervals[j][1]);\\n                j++;\\n            }\\n            sol.push_back({intervals[i][0], maxEnd});\\n            i=j-1;\\n        }   \\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sort",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<vector<int>> sol;\\n\\n        sort(intervals.begin(), intervals.end());\\n\\n        for(int i=0;i<n;i++){\\n            int maxEnd=intervals[i][1];\\n            int j=i+1;\\n\\n            while((j<n)&&(intervals[j][0]<=maxEnd)){\\n                maxEnd=max(maxEnd, intervals[j][1]);\\n                j++;\\n            }\\n            sol.push_back({intervals[i][0], maxEnd});\\n            i=j-1;\\n        }   \\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567482,
                "title": "c-easy-and-fast-solution-o-nlog-n",
                "content": "\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705\\n\\t\\tsort(in.begin(),in.end());\\n        vector<vector<int>>vec; int first,last;\\n            first=in[0][0];  last=in[0][1];\\n        for(int i=1;i<in.size();i++)\\n        {\\n            if(in[i][1]<=last) continue;\\n            else if(in[i][0]<=last and last<=in[i][1]) last=in[i][1];\\n            else \\n            {\\n                vec.push_back({first,last});  \\n                first=in[i][0];  last=in[i][1];\\n            }\\n        }\\n        vec.push_back({first,last});\\n        return vec;\\n\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705\\n\\t\\tsort(in.begin(),in.end());\\n        vector<vector<int>>vec; int first,last;\\n            first=in[0][0];  last=in[0][1];\\n        for(int i=1;i<in.size();i++)\\n        {\\n            if(in[i][1]<=last) continue;\\n            else if(in[i][0]<=last and last<=in[i][1]) last=in[i][1];\\n            else \\n            {\\n                vec.push_back({first,last});  \\n                first=in[i][0];  last=in[i][1];\\n            }\\n        }\\n        vec.push_back({first,last});\\n        return vec;\\n\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705",
                "codeTag": "Unknown"
            },
            {
                "id": 2413048,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0]){\\n                ans.back()[1] = max(ans.back()[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0]){\\n                ans.back()[1] = max(ans.back()[1],intervals[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2002088,
                "title": "easy-to-follow-javascript-solution",
                "content": "```\\nvar merge = function(intervals) {\\n    let sorted = intervals.sort((a, b) => a[0] - b[0]);\\n    let res = [sorted[0]]\\n    \\n    for (let i = 1; i < sorted.length; i++) {\\n      let currStart = sorted[i][0]\\n      let currEnd = sorted[i][1];\\n      let lastEnd = res[res.length - 1][1];\\n      \\n      if (currStart <= lastEnd) {\\n        res[res.length - 1][1] = Math.max(lastEnd, currEnd);\\n      }\\n      else {\\n        res.push(sorted[i])\\n      }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    let sorted = intervals.sort((a, b) => a[0] - b[0]);\\n    let res = [sorted[0]]\\n    \\n    for (let i = 1; i < sorted.length; i++) {\\n      let currStart = sorted[i][0]\\n      let currEnd = sorted[i][1];\\n      let lastEnd = res[res.length - 1][1];\\n      \\n      if (currStart <= lastEnd) {\\n        res[res.length - 1][1] = Math.max(lastEnd, currEnd);\\n      }\\n      else {\\n        res.push(sorted[i])\\n      }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693265,
                "title": "java-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int[][] merge(int[][] intervals) {\\n    int[] start = new int[10000];\\n    int[] end = new int[10000];\\n    List<int[]> retList = new ArrayList<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int max = 0;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < intervals.length; i++) {\\n      start[intervals[i][0]]++;\\n      end[intervals[i][1]]++;\\n      max = Math.max(max, intervals[i][1]);\\n    }\\n\\n    // Time O(n)\\n    int[] range = new int[2];\\n    for (int i = 0; i <= max; i++) {\\n      if (start[i] > 0) {\\n        if (stack.isEmpty()) {\\n          range = new int[2];\\n          range[0] = i;\\n          retList.add(range);\\n        }\\n        for (int j = 0; j < start[i]; j++) stack.push(i);\\n      }\\n      \\n      if (end[i] > 0) {\\n        for (int j = 0; j < end[i]; j++) stack.pop();\\n        if (stack.isEmpty()) {\\n          range[1] = i;\\n          retList.set(retList.size() - 1, range);\\n        }\\n      }\\n    }\\n\\n    // Time O(n)\\n    return retList.toArray(new int[retList.size()][]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int[][] merge(int[][] intervals) {\\n    int[] start = new int[10000];\\n    int[] end = new int[10000];\\n    List<int[]> retList = new ArrayList<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int max = 0;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < intervals.length; i++) {\\n      start[intervals[i][0]]++;\\n      end[intervals[i][1]]++;\\n      max = Math.max(max, intervals[i][1]);\\n    }\\n\\n    // Time O(n)\\n    int[] range = new int[2];\\n    for (int i = 0; i <= max; i++) {\\n      if (start[i] > 0) {\\n        if (stack.isEmpty()) {\\n          range = new int[2];\\n          range[0] = i;\\n          retList.add(range);\\n        }\\n        for (int j = 0; j < start[i]; j++) stack.push(i);\\n      }\\n      \\n      if (end[i] > 0) {\\n        for (int j = 0; j < end[i]; j++) stack.pop();\\n        if (stack.isEmpty()) {\\n          range[1] = i;\\n          retList.set(retList.size() - 1, range);\\n        }\\n      }\\n    }\\n\\n    // Time O(n)\\n    return retList.toArray(new int[retList.size()][]);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644466,
                "title": "c-solution-using-inplace",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        if(n==0)\\n        {\\n            return {};\\n        }\\n        int j=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[j][1]>=nums[i][0])\\n            {\\n                nums[j][1]=max({nums[j][1],nums[i][1]});\\n            }\\n            else\\n            {\\n                nums[++j]=nums[i];\\n            }\\n        }\\n        return vector<vector<int>>(nums.begin(),nums.begin()+j+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        if(n==0)\\n        {\\n            return {};\\n        }\\n        int j=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[j][1]>=nums[i][0])\\n            {\\n                nums[j][1]=max({nums[j][1],nums[i][1]});\\n            }\\n            else\\n            {\\n                nums[++j]=nums[i];\\n            }\\n        }\\n        return vector<vector<int>>(nums.begin(),nums.begin()+j+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628093,
                "title": "java-solution",
                "content": "```\\n/**\\ncases: edge overlapping, full overlapping, none\\n[[1,3],[2,4],[4,5],[6,7],[8,12],[10,11]]\\ntime: O(nlogn) - length of interval array\\nspace: O(n)\\n*/\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n            return intervals;\\n        }\\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0])); // sort by start point\\n\\n        List<int[]> result = new ArrayList<>();\\n        int[] currInterval = intervals[0]; // grab first interval to compare\\n        \\n        int i = 1;\\n        while (i < intervals.length) {\\n            if (intervals[i][0] > currInterval[1]) { // no overlap\\n                result.add(currInterval);\\n                currInterval = intervals[i]; // move to the next interval if no overlap\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            else if (currInterval[1] >= intervals[i][0]) { // if overlap\\n                currInterval[0] = Math.min(currInterval[0], intervals[i][0]);\\n                currInterval[1] = Math.max(currInterval[1], intervals[i][1]);\\n                // result.add(currInterval); // no need to add, we are just expanding interval\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][]); // convert parent List to array\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\ncases: edge overlapping, full overlapping, none\\n[[1,3],[2,4],[4,5],[6,7],[8,12],[10,11]]\\ntime: O(nlogn) - length of interval array\\nspace: O(n)\\n*/\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n            return intervals;\\n        }\\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0])); // sort by start point\\n\\n        List<int[]> result = new ArrayList<>();\\n        int[] currInterval = intervals[0]; // grab first interval to compare\\n        \\n        int i = 1;\\n        while (i < intervals.length) {\\n            if (intervals[i][0] > currInterval[1]) { // no overlap\\n                result.add(currInterval);\\n                currInterval = intervals[i]; // move to the next interval if no overlap\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            else if (currInterval[1] >= intervals[i][0]) { // if overlap\\n                currInterval[0] = Math.min(currInterval[0], intervals[i][0]);\\n                currInterval[1] = Math.max(currInterval[1], intervals[i][1]);\\n                // result.add(currInterval); // no need to add, we are just expanding interval\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][]); // convert parent List to array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531770,
                "title": "python-using-heap",
                "content": "```\\nfrom heapq import heappop, heappush\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        heap =[]\\n        res = []\\n        intervals.sort()\\n        for i in intervals:\\n            if not heap:\\n                heapq.heappush(heap, i)\\n            elif heap[0][1]>=i[0]:\\n                    m, n = heapq.heappop(heap)\\n                    \\n                    heapq.heappush( heap, [min(m, i[0]), max(i[1], n)])\\n            else:\\n                res.append(heapq.heappop(heap))\\n                heapq.heappush(heap, i)\\n        \\n        if heap:\\n            res.extend(heap)\\n        print(res)\\n        return res\\n                    \\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappop, heappush\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        heap =[]\\n        res = []\\n        intervals.sort()\\n        for i in intervals:\\n            if not heap:\\n                heapq.heappush(heap, i)\\n            elif heap[0][1]>=i[0]:\\n                    m, n = heapq.heappop(heap)\\n                    \\n                    heapq.heappush( heap, [min(m, i[0]), max(i[1], n)])\\n            else:\\n                res.append(heapq.heappop(heap))\\n                heapq.heappush(heap, i)\\n        \\n        if heap:\\n            res.extend(heap)\\n        print(res)\\n        return res\\n                    \\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461378,
                "title": "c-comments-merge-intervals",
                "content": "```\\n// There can be three cases with two intervals \\n// Case 1:- No overlap\\n//  [1,           2]      [3,             4]\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n// [1,             3]      \\n//  _______________\\n// | left interval |\\n// |_______________|\\n//           [2,            4]\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n//  [1,                 4]\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//   [2,             3]\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // sort intervals on basis of start value\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n\\t\\tint left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n\\t\\t\\n        while(left<n && right<n)\\n        {\\n            if(v[left][1]<v[right][0])    // Case 1 : (No overlap )\\n            {\\n                left=right;\\n                right++;\\n            }\\n            //  overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                if(v[left][1]>=v[right][1])  // Case 3: (Full overlap)\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2: (partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n// There can be three cases with two intervals \\n// Case 1:- No overlap\\n//  [1,           2]      [3,             4]\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n// [1,             3]      \\n//  _______________\\n// | left interval |\\n// |_______________|\\n//           [2,            4]\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n//  [1,                 4]\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//   [2,             3]\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // sort intervals on basis of start value\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n\\t\\tint left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n\\t\\t\\n        while(left<n && right<n)\\n        {\\n            if(v[left][1]<v[right][0])    // Case 1 : (No overlap )\\n            {\\n                left=right;\\n                right++;\\n            }\\n            //  overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                if(v[left][1]>=v[right][1])  // Case 3: (Full overlap)\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2: (partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367823,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var merge = function(intervals) {\\n        if(intervals.length == 0) return []    // edge cases\\n        else if(intervals.length == 1) return intervals // edge cases\\n    \\n        intervals.sort((a,b) => {\\n            return a[0]-b[0];\\n        })\\n    \\n        let result = [intervals[0]]\\n    \\n        for(let interval of intervals) {\\n            let recentInterval = result[result.length-1]\\n            if(recentInterval[1] >= interval[0]) {\\n                recentInterval[1] = Math.max(recentInterval[1], interval[1])\\n            } else {\\n                result.push(interval)\\n            }\\n        }\\n        return result\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var merge = function(intervals) {\\n        if(intervals.length == 0) return []    // edge cases\\n        else if(intervals.length == 1) return intervals // edge cases\\n    \\n        intervals.sort((a,b) => {\\n            return a[0]-b[0];\\n        })\\n    \\n        let result = [intervals[0]]\\n    \\n        for(let interval of intervals) {\\n            let recentInterval = result[result.length-1]\\n            if(recentInterval[1] >= interval[0]) {\\n                recentInterval[1] = Math.max(recentInterval[1], interval[1])\\n            } else {\\n                result.push(interval)\\n            }\\n        }\\n        return result\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1261003,
                "title": "zero-bullshit-c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        sort(intervals.begin(),intervals.end());\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        sort(intervals.begin(),intervals.end());\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1246685,
                "title": "easy-to-understand-clean-well-explained-every-step-with-comments-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) \\n    {\\n        //Checking if there is only one interval\\n        if(intervals.size()<=1)return intervals;\\n        \\n        //Sorting the intervals on the basis of starting time\\n        sort(intervals.begin(),intervals.end());\\n        \\n        //Creating vector of vectors to store the intervals\\n        vector<vector<int>>ans;\\n        \\n        //Storing the 1st interval in temp vector(It will containg start time and end time)\\n        vector<int>temp=intervals[0];\\n        \\n        //It will be vector of intervals start and end time\\n        for(auto it:intervals)\\n        {\\n            //if EndTime of Ith Interval is greate than start of i+1th Interval\\n            //We\\'ll merge the interval The End Time of merged interval Will be  \\n            //Max of end time of both the ith and i+1th interval\\n            if(temp[1]>=it[0])\\n            {\\n                temp[1]=max(temp[1],it[1]);\\n                \\n            }\\n            //If Merging is not possible we\\'ll put the i+1th interval in ans\\n            //And we\\'ll update the temp with i+1th interval and repeat the process for next\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        //Putting the Last Interval in the ans array\\n        ans.push_back(temp);\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) \\n    {\\n        //Checking if there is only one interval\\n        if(intervals.size()<=1)return intervals;\\n        \\n        //Sorting the intervals on the basis of starting time\\n        sort(intervals.begin(),intervals.end());\\n        \\n        //Creating vector of vectors to store the intervals\\n        vector<vector<int>>ans;\\n        \\n        //Storing the 1st interval in temp vector(It will containg start time and end time)\\n        vector<int>temp=intervals[0];\\n        \\n        //It will be vector of intervals start and end time\\n        for(auto it:intervals)\\n        {\\n            //if EndTime of Ith Interval is greate than start of i+1th Interval\\n            //We\\'ll merge the interval The End Time of merged interval Will be  \\n            //Max of end time of both the ith and i+1th interval\\n            if(temp[1]>=it[0])\\n            {\\n                temp[1]=max(temp[1],it[1]);\\n                \\n            }\\n            //If Merging is not possible we\\'ll put the i+1th interval in ans\\n            //And we\\'ll update the temp with i+1th interval and repeat the process for next\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        //Putting the Last Interval in the ans array\\n        ans.push_back(temp);\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213592,
                "title": "easiest-and-best-c-solution-beats-99-submissions",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i = 1 ; i < intervals.size() ; i++){\\n            if(res.back()[1] >= (intervals[i])[0]){\\n                res.back()[1] = max(res.back()[1],(intervals[i])[1]);\\n            }\\n            else{\\n                res.push_back(intervals[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i = 1 ; i < intervals.size() ; i++){\\n            if(res.back()[1] >= (intervals[i])[0]){\\n                res.back()[1] = max(res.back()[1],(intervals[i])[1]);\\n            }\\n            else{\\n                res.push_back(intervals[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081743,
                "title": "clean-streaming-solution-for-followup",
                "content": "```\\n// use a balanced binary search tree to store intervals in sorted order as they come in\\n// if we add a new one, we need to iterate over all intervals and merge as needed\\n// as we iterate, if newInterval and current interval overlap, then remove currentInterval and merge\\n// keep removing and merging until we have no overlap, add merged interval back in\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        TreeSet<int[]> bbst = new TreeSet<int[]>((a, b) -> a[0]-b[0]);\\n        for(int[] interval: intervals) {\\n            Iterator<int[]> itr = bbst.iterator();\\n            while(itr.hasNext()) {\\n                int[] currInterval = itr.next();\\n                if(overlap(currInterval, interval)) {\\n                    interval = merge(currInterval, interval);\\n                    itr.remove();\\n                }\\n            }\\n            bbst.add(interval);\\n        }\\n        \\n        int size = bbst.size();\\n        int[][] res = new int[size][2];\\n        int idx = 0;\\n        for(int[] interval: bbst) {\\n            res[idx] = interval;\\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean overlap(int[] intervalA, int[] intervalB) {\\n        return Math.max(intervalA[0], intervalB[0]) <= Math.min(intervalA[1], intervalB[1]);\\n    }\\n    \\n    public int[] merge(int[] intervalA, int[] intervalB) {\\n        int start = Math.min(intervalA[0], intervalB[0]);\\n        int end = Math.max(intervalA[1], intervalB[1]);\\n        return new int[]{start, end};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// use a balanced binary search tree to store intervals in sorted order as they come in\\n// if we add a new one, we need to iterate over all intervals and merge as needed\\n// as we iterate, if newInterval and current interval overlap, then remove currentInterval and merge\\n// keep removing and merging until we have no overlap, add merged interval back in\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        TreeSet<int[]> bbst = new TreeSet<int[]>((a, b) -> a[0]-b[0]);\\n        for(int[] interval: intervals) {\\n            Iterator<int[]> itr = bbst.iterator();\\n            while(itr.hasNext()) {\\n                int[] currInterval = itr.next();\\n                if(overlap(currInterval, interval)) {\\n                    interval = merge(currInterval, interval);\\n                    itr.remove();\\n                }\\n            }\\n            bbst.add(interval);\\n        }\\n        \\n        int size = bbst.size();\\n        int[][] res = new int[size][2];\\n        int idx = 0;\\n        for(int[] interval: bbst) {\\n            res[idx] = interval;\\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean overlap(int[] intervalA, int[] intervalB) {\\n        return Math.max(intervalA[0], intervalB[0]) <= Math.min(intervalA[1], intervalB[1]);\\n    }\\n    \\n    public int[] merge(int[] intervalA, int[] intervalB) {\\n        int start = Math.min(intervalA[0], intervalB[0]);\\n        int end = Math.max(intervalA[1], intervalB[1]);\\n        return new int[]{start, end};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963251,
                "title": "golang-solution",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    res := make([][]int, 0)\\n    sort.Slice(intervals, func(a, b int)bool {\\n        return intervals[a][0] < intervals[b][0]\\n    })\\n    \\n    res = append(res, intervals[0])\\n    \\n    for i := 1; i < len(intervals); i++ {\\n        if intervals[i][0] <= res[len(res) - 1][1] {\\n            //update last range in result case\\n            res[len(res) - 1][1] = max(res[len(res) - 1][1], intervals[i][1])\\n        } else {\\n            //insert new range into result case\\n            res = append(res, intervals[i])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int)int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    res := make([][]int, 0)\\n    sort.Slice(intervals, func(a, b int)bool {\\n        return intervals[a][0] < intervals[b][0]\\n    })\\n    \\n    res = append(res, intervals[0])\\n    \\n    for i := 1; i < len(intervals); i++ {\\n        if intervals[i][0] <= res[len(res) - 1][1] {\\n            //update last range in result case\\n            res[len(res) - 1][1] = max(res[len(res) - 1][1], intervals[i][1])\\n        } else {\\n            //insert new range into result case\\n            res = append(res, intervals[i])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int)int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845362,
                "title": "java-sol-sort-and-merge-intervals",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> res = new ArrayList<>();\\n        \\n        if (intervals == null || intervals.length == 0) {\\n            return res.toArray(new int[][] {});\\n        }\\n        \\n        // Sort intervals ascending by start value\\n        Arrays.sort(intervals, (pair1, pair2) -> {\\n            return pair1[0] - pair2[0];\\n        });\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[i][1] < end) {\\n                // Ignore current interval, it is a subset of the previous\\n                continue;\\n            }\\n            \\n            if (intervals[i][0] > end) {\\n                res.add(new int[]{ start, end });\\n                \\n                start = intervals[i][0];\\n            }\\n            \\n            end = intervals[i][1];\\n        }\\n        \\n        res.add(new int[]{ start, end });\\n        \\n        return res.toArray(new int[][] {});\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> res = new ArrayList<>();\\n        \\n        if (intervals == null || intervals.length == 0) {\\n            return res.toArray(new int[][] {});\\n        }\\n        \\n        // Sort intervals ascending by start value\\n        Arrays.sort(intervals, (pair1, pair2) -> {\\n            return pair1[0] - pair2[0];\\n        });\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[i][1] < end) {\\n                // Ignore current interval, it is a subset of the previous\\n                continue;\\n            }\\n            \\n            if (intervals[i][0] > end) {\\n                res.add(new int[]{ start, end });\\n                \\n                start = intervals[i][0];\\n            }\\n            \\n            end = intervals[i][1];\\n        }\\n        \\n        res.add(new int[]{ start, end });\\n        \\n        return res.toArray(new int[][] {});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578912,
                "title": "go-runtime-99-39-mem-100",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\\n    \\n    res := [][]int{}\\n    for i, interval := range intervals {\\n        if i == 0 {\\n            res = append(res, interval)\\n            continue\\n        }\\n        \\n        r := res[len(res)-1]\\n        if interval[0] <= r[1] && r[1] < interval[1] {\\n            res[len(res)-1] = []int{r[0], interval[1]}\\n        }\\n        if r[1] < interval[0] {\\n            res = append(res, interval)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\\n    \\n    res := [][]int{}\\n    for i, interval := range intervals {\\n        if i == 0 {\\n            res = append(res, interval)\\n            continue\\n        }\\n        \\n        r := res[len(res)-1]\\n        if interval[0] <= r[1] && r[1] < interval[1] {\\n            res[len(res)-1] = []int{r[0], interval[1]}\\n        }\\n        if r[1] < interval[0] {\\n            res = append(res, interval)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524522,
                "title": "python-3-simple-and-easy-solution",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0:\\n            return []\\n        \\n        sorted_intervals = sorted(intervals, key=lambda l:l[0])\\n        \\n        res = [sorted_intervals[0]]\\n        for interval in sorted_intervals[1:]:\\n            if res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0:\\n            return []\\n        \\n        sorted_intervals = sorted(intervals, key=lambda l:l[0])\\n        \\n        res = [sorted_intervals[0]]\\n        for interval in sorted_intervals[1:]:\\n            if res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293571,
                "title": "c-why-do-i-get-runtime-error-depending-on-whenther-sort-comp-function-is-or",
                "content": "The following fails when comp function is a[0]<=b[0]\\nrun time error is reference binding to null pointer of type \\'value_type\\' (stl_vector.h)\\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<=b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```\\nBut this comp function a[0]<b[0] solution succeeds\\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<=b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21305,
                "title": "c-sort-by-start-simple-5-lines",
                "content": "Iterate over the array sorted by start and compare the start of each element to the end of the last item on your output.  Either extend the last element of the output or add a new element to the output.\\n\\n```\\n    public IList<Interval> Merge(IList<Interval> intervals) \\n    {\\n        IList<Interval> res = new List<Interval>();\\n        foreach (Interval curr in intervals.OrderBy(x => x.start))\\n        {\\n            if (res.Count == 0 || res[res.Count-1].end < curr.start) res.Add(new Interval(curr.start, curr.end));\\n            else res[res.Count-1].end = Math.Max(res[res.Count-1].end, curr.end);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<Interval> Merge(IList<Interval> intervals) \\n    {\\n        IList<Interval> res = new List<Interval>();\\n        foreach (Interval curr in intervals.OrderBy(x => x.start))\\n        {\\n            if (res.Count == 0 || res[res.Count-1].end < curr.start) res.Add(new Interval(curr.start, curr.end));\\n            else res[res.Count-1].end = Math.Max(res[res.Count-1].end, curr.end);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21359,
                "title": "clean-treeset-solution-in-java",
                "content": "```\\npublic class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        \\n        TreeSet<Interval> tree = new TreeSet<Interval>(new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval i1, Interval i2) {\\n                if (i1.end < i2.start) return -1;\\n                else if (i1.start > i2.end) return 1;\\n                else return 0;\\n            }\\n        });\\n        \\n        for (Interval i: intervals) {\\n            while (tree.contains(i)) {\\n                Interval x = tree.ceiling(i);\\n                tree.remove(x);\\n                i = new Interval(Math.min(i.start, x.start), Math.max(i.end, x.end));\\n            }\\n            tree.add(i);\\n        }\\n        \\n        return new ArrayList<Interval>(tree);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        \\n        TreeSet<Interval> tree = new TreeSet<Interval>(new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval i1, Interval i2) {\\n                if (i1.end < i2.start) return -1;\\n                else if (i1.start > i2.end) return 1;\\n                else return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 21485,
                "title": "concise-python-code-easy-understanding",
                "content": "\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda interval:interval.start)\\n            result = []\\n            interval, l = intervals[0], len(intervals)\\n            for i in range(1, l):\\n                interval2 = intervals[i]\\n                if interval2.start > interval.end:\\n                    result.append(interval)\\n                    interval = interval2\\n                else:\\n                    interval.end = max\\uff08interval.end, interval2.end)\\n            \\n            result.append(interval)\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda interval:interval.start)\\n            result = []\\n            interval, l = intervals[0], len(intervals)\\n            for i in range(1, l):\\n                interval2 = intervals[i]\\n                if interval2.start > interval.end:\\n                    result.append(interval)\\n                    interval = interval2\\n                else:\\n                    interval.end = max\\uff08interval.end, interval2.end)\\n            \\n            result.append(interval)\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 21551,
                "title": "sort-function-problems",
                "content": "I use the sort function to sort the starting points of all intervals,\\n\\n    sort(intervals.begin(),intervals.end(),compareInterval); \\n\\nHowever, when I am trying to use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<=b.start);\\n    }\\n\\nthe compiler outputs some Runtime error, however, the compiler accepts the code if I use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<b.start);\\n    }\\n\\nany genius here have some ideas?",
                "solutionTags": [],
                "code": "I use the sort function to sort the starting points of all intervals,\\n\\n    sort(intervals.begin(),intervals.end(),compareInterval); \\n\\nHowever, when I am trying to use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<=b.start);\\n    }\\n\\nthe compiler outputs some Runtime error, however, the compiler accepts the code if I use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<b.start);\\n    }\\n\\nany genius here have some ideas?",
                "codeTag": "Unknown"
            },
            {
                "id": 3908055,
                "title": "easy-c-solution-using-sorting-basic-approach-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n       vector<vector<int>>v;\\n       int start;\\n       int end;\\n       int i;\\n        sort(nums.begin(), nums.end(), [](const vector<int>& a, const vector<int>& b) {\\n           return a[0] < b[0];\\n       });\\n       \\n       for( i=0;i<nums.size();i++)\\n       {\\n           int start=nums[i][0];\\n           int end=nums[i][1]; \\n            while(i!=nums.size()-1 && end>=nums[i+1][0])\\n           {\\n               end= max(end,nums[i+1][1]);\\n               i++;\\n           }\\n           \\n           \\n           vector<int> temp={start,end};\\n           v.push_back(temp);\\n       } \\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n       vector<vector<int>>v;\\n       int start;\\n       int end;\\n       int i;\\n        sort(nums.begin(), nums.end(), [](const vector<int>& a, const vector<int>& b) {\\n           return a[0] < b[0];\\n       });\\n       \\n       for( i=0;i<nums.size();i++)\\n       {\\n           int start=nums[i][0];\\n           int end=nums[i][1]; \\n            while(i!=nums.size()-1 && end>=nums[i+1][0])\\n           {\\n               end= max(end,nums[i+1][1]);\\n               i++;\\n           }\\n           \\n           \\n           vector<int> temp={start,end};\\n           v.push_back(temp);\\n       } \\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760303,
                "title": "fast-solution-beats-99-simple-code-self-explanatory-with-comments",
                "content": "Solution:\\n\\n    class Solution(object):\\n\\n        def merge(self, intervals):\\n            \\n            #sort the intervals\\n            intervals.sort()\\n\\n            #base case \\n            if len(intervals)==1:\\n                return intervals\\n\\n            #the answer array\\n            ans = [intervals[0]]\\n            for i in range(1, len(intervals)):\\n\\n                #if the intervals are non overlapping \\n                if intervals[i][0]>ans[-1][1]:\\n                    ans.append(intervals[i])\\n\\n                #if two intervals overlap\\n                else:\\n                    new = [min(intervals[i][0], ans[-1][0]), max(intervals[i][1], ans[-1][1])]\\n                    ans.pop()\\n                    ans.append(new)\\n\\n            return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solution:\\n\\n    class Solution(object):\\n\\n        def merge(self, intervals):\\n            \\n            #sort the intervals\\n            intervals.sort()\\n\\n            #base case \\n            if len(intervals)==1:\\n                return intervals\\n\\n            #the answer array\\n            ans = [intervals[0]]\\n            for i in range(1, len(intervals)):\\n\\n                #if the intervals are non overlapping \\n                if intervals[i][0]>ans[-1][1]:\\n                    ans.append(intervals[i])\\n\\n                #if two intervals overlap\\n                else:\\n                    new = [min(intervals[i][0], ans[-1][0]), max(intervals[i][1], ans[-1][1])]\\n                    ans.pop()\\n                    ans.append(new)\\n\\n            return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2964594,
                "title": "c-easy-to-understand-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, two array will be taken arr1 for all intervals[i][0]\\nand second array arr2 for all intervals[i][1] then sortboth of them.Therefore, only one condition in for loop: if arr2[i]<arr2[i+1]...\\n\\nKindly like this solution if you are able to understand.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>>ans;\\n        vector<int>res;\\n        vector<int>arr1;\\n        vector<int>arr2;\\n        for(int i =0;i<intervals.size();i++){\\n            arr1.push_back(intervals[i][0]);\\n            arr2.push_back(intervals[i][1]);\\n        }\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n\\nres.push_back(arr1[0]);\\nfor(int i =0;i<intervals.size()-1;i++){\\nif(arr2[i]<arr1[i+1]){\\nres.push_back(arr2[i]);\\nans.push_back(res);\\nres.clear();\\nres.push_back(arr1[i+1]);\\n}\\n}\\nres.push_back(arr2[arr2.size()-1]);\\nans.push_back(res);\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>>ans;\\n        vector<int>res;\\n        vector<int>arr1;\\n        vector<int>arr2;\\n        for(int i =0;i<intervals.size();i++){\\n            arr1.push_back(intervals[i][0]);\\n            arr2.push_back(intervals[i][1]);\\n        }\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n\\nres.push_back(arr1[0]);\\nfor(int i =0;i<intervals.size()-1;i++){\\nif(arr2[i]<arr1[i+1]){\\nres.push_back(arr2[i]);\\nans.push_back(res);\\nres.clear();\\nres.push_back(arr1[i+1]);\\n}\\n}\\nres.push_back(arr2[arr2.size()-1]);\\nans.push_back(res);\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951764,
                "title": "python-simple-solution",
                "content": "# Approach\\nSort by the start of the interval. Then check if the end of an interval is equal to or greater than the start of the next interval. If yes merge it, and remove that interval, otherwise continue. Return the array after parsing through.\\n\\n# Complexity\\n- Time complexity: O(n * logn)\\n\\n- Space complexity: O(1)?\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: x[0])\\n        index = 0\\n        while index < len(intervals)-1:\\n            if intervals[index][1] >= intervals[index+1][0]:\\n                intervals[index][1] = max(intervals[index+1][1],intervals[index][1])\\n                intervals.remove(intervals[index+1])\\n            else:\\n                index += 1\\n        return intervals\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: x[0])\\n        index = 0\\n        while index < len(intervals)-1:\\n            if intervals[index][1] >= intervals[index+1][0]:\\n                intervals[index][1] = max(intervals[index+1][1],intervals[index][1])\\n                intervals.remove(intervals[index+1])\\n            else:\\n                index += 1\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856777,
                "title": "easy-and-swift-python-solution",
                "content": "- Sort the array based on the order of first element.\\n- Check if the second element of each nested array is within the range of prev array.\\n- Combine the arrays if necessary.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if intervals == []:\\n            return\\n        \\n        intervals.sort(key = lambda x: x[0])\\n        res = [intervals[0]]\\n        \\n        for i in range(1, len(intervals)):\\n\\n            if intervals[i][0] <= res[-1][1]:\\n                res[-1][1] = max(intervals[i][1], res[-1][1])\\n                continue\\n            \\n            res.append(intervals[i])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if intervals == []:\\n            return\\n        \\n        intervals.sort(key = lambda x: x[0])\\n        res = [intervals[0]]\\n        \\n        for i in range(1, len(intervals)):\\n\\n            if intervals[i][0] <= res[-1][1]:\\n                res[-1][1] = max(intervals[i][1], res[-1][1])\\n                continue\\n            \\n            res.append(intervals[i])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773288,
                "title": "python-solution-onlogn",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: (x[0]))\\n        mergedIntervals = []\\n        mergedIntervalIndex = 0\\n        mergedIntervals.append(intervals[0])\\n        for i in range(1,len(intervals)):\\n            currentInterval = intervals[i]\\n            currentMergedInterval = mergedIntervals[mergedIntervalIndex]\\n            if currentInterval[0] <= currentMergedInterval[1] and currentInterval[1] >= currentMergedInterval[0]:\\n                mergedIntervals[mergedIntervalIndex] = [min(currentMergedInterval[0], currentInterval[0]), max(currentInterval[1], currentMergedInterval[1])]\\n            else:\\n                mergedIntervals.append(currentInterval)\\n                mergedIntervalIndex += 1\\n        return mergedIntervals\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: (x[0]))\\n        mergedIntervals = []\\n        mergedIntervalIndex = 0\\n        mergedIntervals.append(intervals[0])\\n        for i in range(1,len(intervals)):\\n            currentInterval = intervals[i]\\n            currentMergedInterval = mergedIntervals[mergedIntervalIndex]\\n            if currentInterval[0] <= currentMergedInterval[1] and currentInterval[1] >= currentMergedInterval[0]:\\n                mergedIntervals[mergedIntervalIndex] = [min(currentMergedInterval[0], currentInterval[0]), max(currentInterval[1], currentMergedInterval[1])]\\n            else:\\n                mergedIntervals.append(currentInterval)\\n                mergedIntervalIndex += 1\\n        return mergedIntervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726014,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n\\t\\tint n=intervals.size();\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<n;i++){\\n            if(ans[ans.size()-1][1]<intervals[i][0]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                ans[ans.size()-1][1]=max(ans[ans.size()-1][1],intervals[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n\\t\\tint n=intervals.size();\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<n;i++){\\n            if(ans[ans.size()-1][1]<intervals[i][0]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                ans[ans.size()-1][1]=max(ans[ans.size()-1][1],intervals[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664674,
                "title": "90-time-beats-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intr) {\\n        sort(intr.begin(),intr.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intr[0]);\\n        for(int i = 1; i < intr.size(); i++){\\n            if(intr[i][0]>ans[ans.size()-1][1]){\\n                ans.push_back(intr[i]);\\n            }else{\\n                ans[ans.size()-1][1] = max(intr[i][1],ans[ans.size()-1][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intr) {\\n        sort(intr.begin(),intr.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intr[0]);\\n        for(int i = 1; i < intr.size(); i++){\\n            if(intr[i][0]>ans[ans.size()-1][1]){\\n                ans.push_back(intr[i]);\\n            }else{\\n                ans[ans.size()-1][1] = max(intr[i][1],ans[ans.size()-1][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538215,
                "title": "c-easy-to-understand-solution-95-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tvector<vector<int>> ans = {arr[0]};\\n\\t\\t\\tfor(int i = 0 ; i < arr.size() ; i++){\\n\\t\\t\\t\\tint s = arr[i][0] , e = arr[i][1];\\n\\t\\t\\t\\tint as = ans[ans.size()-1][0] , ae = ans[ans.size()-1][1];\\n\\t\\t\\t\\tif(as <= s and s <= ae) {\\n\\t\\t\\t\\t\\tans[ans.size()-1][1] = max(e,ae); \\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tans.push_back({s,e});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tvector<vector<int>> ans = {arr[0]}",
                "codeTag": "Java"
            },
            {
                "id": 2516355,
                "title": "c-8-line-simplest-solution-with-linear-time-complexity",
                "content": "Hey Guys,\\nHope you all are doing well!\\nIn this post, I\\'ve provided one of the easiest approach to merge all overlapping intervals in a given array.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        vector<vector<int>>ans;\\n        sort(v.begin(),v.end());\\n        for(int i=0; i<v.size(); i++){\\n            if(ans.size()==0 || v[i][0]>ans.back()[1])\\n                ans.push_back(v[i]);\\n            else ans.back()[1]=max(ans.back()[1],v[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\nHappy Coding!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        vector<vector<int>>ans;\\n        sort(v.begin(),v.end());\\n        for(int i=0; i<v.size(); i++){\\n            if(ans.size()==0 || v[i][0]>ans.back()[1])\\n                ans.push_back(v[i]);\\n            else ans.back()[1]=max(ans.back()[1],v[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375726,
                "title": "a-simple-c-solution",
                "content": "**Runtime: 24 ms, faster than 99.96% of C++ online submissions for Merge Intervals.\\nMemory Usage: 19.1 MB, less than 44.98% of C++ online submissions for Merge Intervals.**\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\tsort(intervals.begin(),intervals.end());\\n\\tvector<vector<int>> ans;\\n\\tint start=intervals[0][0],end=intervals[0][1];\\n\\tfor(int i=1;i<intervals.size();i++){\\n\\t\\tif(intervals[i][0]<=end){\\n\\t\\t\\tend=max(end,intervals[i][1]);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tans.push_back({start,end});\\n\\t\\t\\tstart=intervals[i][0],end=intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\tans.push_back({start,end});\\n\\treturn ans;\\n}\\n```\\n\\nKeep Coding.\\nPlease do Upvote.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\tsort(intervals.begin(),intervals.end());\\n\\tvector<vector<int>> ans;\\n\\tint start=intervals[0][0],end=intervals[0][1];\\n\\tfor(int i=1;i<intervals.size();i++){\\n\\t\\tif(intervals[i][0]<=end){\\n\\t\\t\\tend=max(end,intervals[i][1]);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tans.push_back({start,end});\\n\\t\\t\\tstart=intervals[i][0],end=intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\tans.push_back({start,end});\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329982,
                "title": "interview-ready-with-explanation",
                "content": "```\\nclass Solution {\\n    //Time: O(n log n) for sorting the given intervals\\n    //Space O(n) where n represent the length of given intervals\\n    public int[][] merge(int[][] intervals) {\\n\\t\\t//Edge case\\n\\t\\tif(intervals.length == 1) return intervals;\\n\\t\\n        //sort by intervals start time\\n        Arrays.sort(intervals, (a,b)-> a[0] - b[0]);\\n        \\n        //create a list of int[]\\n        List<int[]> result = new ArrayList<>();\\n        \\n        //get the first interval from intervals\\n        int aStart = intervals[0][0],\\n            aEnd = intervals[0][1];\\n        \\n        //loop through the rest of intervals\\n        for(int i = 1; i < intervals.length; i++){\\n            //if b.Start <= aEnd meaning it is overlapping\\n            if(intervals[i][0] <= aEnd){\\n                //find the new max\\n                aEnd = Math.max(aEnd, intervals[i][1]);\\n            }\\n            else{\\n                //if not add it to the result and change the a.start and a.end\\n                result.add(new int[]{aStart, aEnd});\\n                aStart = intervals[i][0];\\n                aEnd = intervals[i][1];\\n            }\\n        }\\n        \\n        //add the last values\\n        result.add(new int[]{aStart, aEnd});\\n        \\n        //return the result\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    //Time: O(n log n) for sorting the given intervals\\n    //Space O(n) where n represent the length of given intervals\\n    public int[][] merge(int[][] intervals) {\\n\\t\\t//Edge case\\n\\t\\tif(intervals.length == 1) return intervals;\\n\\t\\n        //sort by intervals start time\\n        Arrays.sort(intervals, (a,b)-> a[0] - b[0]);\\n        \\n        //create a list of int[]\\n        List<int[]> result = new ArrayList<>();\\n        \\n        //get the first interval from intervals\\n        int aStart = intervals[0][0],\\n            aEnd = intervals[0][1];\\n        \\n        //loop through the rest of intervals\\n        for(int i = 1; i < intervals.length; i++){\\n            //if b.Start <= aEnd meaning it is overlapping\\n            if(intervals[i][0] <= aEnd){\\n                //find the new max\\n                aEnd = Math.max(aEnd, intervals[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2274410,
                "title": "beginner-friendly-javascript-python-solution",
                "content": "**Time Complexity : O(n)**\\n**JavaScript**\\n```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0])\\n    let merged = [], len = 0\\n    for(let i of intervals){\\n        if(merged.length > 0 && merged[len-1][1] >= i[0]){\\n            merged[len-1][1] = Math.max(merged[len-1][1], i[1])\\n        }else{\\n            merged.push(i)\\n            len++\\n        }\\n    }\\n    return merged\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        intervals.sort()\\n        merged = []\\n        n = 0\\n        for i in intervals:\\n            if len(merged) > 0 and merged[n-1][1] >= i[0]:\\n                merged[n-1][1] = max(merged[n-1][1], i[1])\\n            else:\\n                merged.append(i)\\n                n += 1\\n        return merged\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0])\\n    let merged = [], len = 0\\n    for(let i of intervals){\\n        if(merged.length > 0 && merged[len-1][1] >= i[0]){\\n            merged[len-1][1] = Math.max(merged[len-1][1], i[1])\\n        }else{\\n            merged.push(i)\\n            len++\\n        }\\n    }\\n    return merged\\n};\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        intervals.sort()\\n        merged = []\\n        n = 0\\n        for i in intervals:\\n            if len(merged) > 0 and merged[n-1][1] >= i[0]:\\n                merged[n-1][1] = max(merged[n-1][1], i[1])\\n            else:\\n                merged.append(i)\\n                n += 1\\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105757,
                "title": "simple-javascript",
                "content": "Hi,\\nhere is my javascript solution.\\n\\n```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0]);\\n    const results = [];\\n    for(let interval of intervals) {\\n        const prev = results.at(-1);\\n        if (!results.length || prev[1] < interval[0]) {\\n            results.push(interval);\\n        } else {\\n            prev[1] = Math.max(prev[1], interval[1])\\n        }\\n    }\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0]);\\n    const results = [];\\n    for(let interval of intervals) {\\n        const prev = results.at(-1);\\n        if (!results.length || prev[1] < interval[0]) {\\n            results.push(interval);\\n        } else {\\n            prev[1] = Math.max(prev[1], interval[1])\\n        }\\n    }\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2025008,
                "title": "easy-c-sorting-o-nlogn",
                "content": "***DO UPVOTE IF IT HELPS!!!!***\\n\\n\\tvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<vector<int>> ans;\\n        int n=intervals.size();\\n               \\n        int res=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<=intervals[res][1]){\\n                intervals[res][0]=min (intervals[res][0],intervals[i][0]);\\n                intervals[res][1]=max(intervals[res][1],intervals[i][1]);\\n            }\\n            else{\\n                res++;\\n                intervals[res]=intervals[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<=res;i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "***DO UPVOTE IF IT HELPS!!!!***\\n\\n\\tvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<vector<int>> ans;\\n        int n=intervals.size();\\n               \\n        int res=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<=intervals[res][1]){\\n                intervals[res][0]=min (intervals[res][0],intervals[i][0]);\\n                intervals[res][1]=max(intervals[res][1],intervals[i][1]);\\n            }\\n            else{\\n                res++;\\n                intervals[res]=intervals[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<=res;i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1996645,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int lengthOfIntervals = intervals.size();\\n\\t\\tif(lengthOfIntervals == 0)return {{}};\\n\\n\\t\\tsort(intervals.begin(),intervals.end(),[](vector<int> firstInterval, vector<int> secondInterval){\\n\\t\\t\\treturn firstInterval[0]<secondInterval[0];\\n\\t\\t});\\n\\n\\t\\tvector<vector<int>> mergedIntervals;\\n\\t\\tmergedIntervals.push_back(intervals[0]);\\t\\n\\n\\t\\tfor(int i = 1;i<lengthOfIntervals;i++){\\n\\t\\t\\tvector<int> lastPushedIntervalInTheResult = mergedIntervals.back();\\n\\t\\t\\tif(intervals[i][0]>lastPushedIntervalInTheResult[1])\\n\\t\\t\\t\\tmergedIntervals.push_back(intervals[i]);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmergedIntervals.back()[1] = max(mergedIntervals.back()[1],intervals[i][1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mergedIntervals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int lengthOfIntervals = intervals.size();\\n\\t\\tif(lengthOfIntervals == 0)return {{}};\\n\\n\\t\\tsort(intervals.begin(),intervals.end(),[](vector<int> firstInterval, vector<int> secondInterval){\\n\\t\\t\\treturn firstInterval[0]<secondInterval[0];\\n\\t\\t});\\n\\n\\t\\tvector<vector<int>> mergedIntervals;\\n\\t\\tmergedIntervals.push_back(intervals[0]);\\t\\n\\n\\t\\tfor(int i = 1;i<lengthOfIntervals;i++){\\n\\t\\t\\tvector<int> lastPushedIntervalInTheResult = mergedIntervals.back();\\n\\t\\t\\tif(intervals[i][0]>lastPushedIntervalInTheResult[1])\\n\\t\\t\\t\\tmergedIntervals.push_back(intervals[i]);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmergedIntervals.back()[1] = max(mergedIntervals.back()[1],intervals[i][1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mergedIntervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966180,
                "title": "c-simple-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    //compartor for sorting the intervals\\n    static bool compare(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end(),compare);\\n        // sorting the intervals\\n        vector<vector<int>> res;\\n        res.push_back(nums[0]);\\n        // pushing 1st interval to result\\n        for(int i=1;i<nums.size();i++){\\n            // checking if current interval overlaps with last interval\\n            if(res[res.size()-1][1] >= nums[i][0]){\\n\\t\\t\\t\\t// we just update out interval\\n\\t\\t\\t\\t// y here should be there larger of 2 intervals\\n                res[res.size()-1][1]=max(res[res.size()-1][1],nums[i][1]);\\n            }else{\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nUpvote if you found it helpful.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //compartor for sorting the intervals\\n    static bool compare(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end(),compare);\\n        // sorting the intervals\\n        vector<vector<int>> res;\\n        res.push_back(nums[0]);\\n        // pushing 1st interval to result\\n        for(int i=1;i<nums.size();i++){\\n            // checking if current interval overlaps with last interval\\n            if(res[res.size()-1][1] >= nums[i][0]){\\n\\t\\t\\t\\t// we just update out interval\\n\\t\\t\\t\\t// y here should be there larger of 2 intervals\\n                res[res.size()-1][1]=max(res[res.size()-1][1],nums[i][1]);\\n            }else{\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846983,
                "title": "simple-kotlin-solution-with-explanation",
                "content": "Here is a simple Kotlin solution.\\nThe logic is simple.\\n1. Sort the intervals using the start value (O(NlogN))\\n2. Loop through the array of intervals (O(N))\\n3. Given an interval, \\n   1) no overlap case - if the start value is greater than end value of the last `result` interval then add the interval to `result `\\n   2) overlap case -  just get the Max end value of a) last `result` interval or b) the current interval (this covers edge case where current interval falls within the last `result` interval)\\n\\n* checking result is empty is a special case for 1) no overlap\\n\\n```kotlin\\nfun mergeIntervals2(intervals: Array<IntArray>): Array<IntArray> {\\n        intervals.sortBy{ it[0] }\\n        val result = mutableListOf<IntArray>()\\n        intervals.forEach{\\n            if(result.isEmpty() || result.last()[1] < it[0]) {\\n                result.add(it)\\n            } else {\\n                result.last()[1] = maxOf(result.last()[1], it[1])\\n            }\\n        }\\n        return result.toTypedArray()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nfun mergeIntervals2(intervals: Array<IntArray>): Array<IntArray> {\\n        intervals.sortBy{ it[0] }\\n        val result = mutableListOf<IntArray>()\\n        intervals.forEach{\\n            if(result.isEmpty() || result.last()[1] < it[0]) {\\n                result.add(it)\\n            } else {\\n                result.last()[1] = maxOf(result.last()[1], it[1])\\n            }\\n        }\\n        return result.toTypedArray()\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1573219,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1849602,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566121,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566131,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574619,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576565,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568394,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565574,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573219,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1849602,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566121,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566131,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574619,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576565,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568394,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565574,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573399,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1573375,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1572372,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571138,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571139,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2001699,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1758109,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1734797,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1572810,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571140,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1567581,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2076035,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2052436,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2037298,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2037269,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2032857,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2001692,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1980319,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1964672,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1959146,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1952091,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1922819,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1915199,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1898059,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1887702,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1885784,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1844220,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1807815,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1807019,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1804679,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1801156,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1799815,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1791113,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1791112,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1775220,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1766551,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1755485,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1742517,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1738835,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1735110,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1729146,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1720918,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1714398,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1710364,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1707869,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1707650,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1680562,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1648697,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1637633,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1631126,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Upside Down",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1575643,
                "content": [
                    {
                        "username": "elangovan911",
                        "content": "Am I missing something in this problem? the description says \"it is guaranteed that every node in the given tree has either 0 or 2 children.\" but the 3rd test case is [1,2]!!! Where is the right child and why does the root node get to have only one child? Also, there is no clear description given that says ignore the right subtree from this rearrangement. for the testcase of [1,2,3,4,5,6,7,8,9,10] i would expect 10 to become the root of 5 at the end but the final solution tree is same as original i.e. 5 is still the root of 10."
                    },
                    {
                        "username": "siulungdlaw",
                        "content": "The question is ambiguous.\n\nIn the case where the tree is \n1\n2, 3\n4,5, 6, 7\nThen what is parent of 3 after the transformation?\nOn one hand, 2 is supposed the parent because it is the right child of 1.\nOn the other hand, 6 is supposed the parent because 6 is the left child of 3.\n\n\n\n"
                    }
                ]
            },
            {
                "id": 1756545,
                "content": [
                    {
                        "username": "elangovan911",
                        "content": "Am I missing something in this problem? the description says \"it is guaranteed that every node in the given tree has either 0 or 2 children.\" but the 3rd test case is [1,2]!!! Where is the right child and why does the root node get to have only one child? Also, there is no clear description given that says ignore the right subtree from this rearrangement. for the testcase of [1,2,3,4,5,6,7,8,9,10] i would expect 10 to become the root of 5 at the end but the final solution tree is same as original i.e. 5 is still the root of 10."
                    },
                    {
                        "username": "siulungdlaw",
                        "content": "The question is ambiguous.\n\nIn the case where the tree is \n1\n2, 3\n4,5, 6, 7\nThen what is parent of 3 after the transformation?\nOn one hand, 2 is supposed the parent because it is the right child of 1.\nOn the other hand, 6 is supposed the parent because 6 is the left child of 3.\n\n\n\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Paint House",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564574,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1569675,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1576970,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1574974,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1571998,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1968722,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1921476,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            }
        ]
    },
    {
        "title": "Line Reflection",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565228,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1566501,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1572506,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1570322,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 2007950,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1820293,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1571631,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 2066317,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            }
        ]
    },
    {
        "title": "132 Pattern",
        "question_content": "<p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p>\n\n<p>Return <code>true</code><em> if there is a <strong>132 pattern</strong> in </em><code>nums</code><em>, otherwise, return </em><code>false</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no 132 pattern in the sequence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,4,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a 132 pattern in the sequence: [1, 4, 2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,3,2,0]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 94071,
                "title": "single-pass-c-o-n-space-and-time-solution-8-lines-with-detailed-explanation",
                "content": "QUESTION: To search for a subsequence (`s1,s2,s3`) such that `s1 < s3 < s2`.\\n\\nINTUITION: Suppose we want to find a `123` sequence with `s1 < s2 < s3`, we just need to find `s3`, followed by `s2` and `s1`. Now if we want to find a `132` sequence with `s1 < s3 < s2`, we need to switch up the order of searching. we want to first find `s2`, followed by `s3`, then `s1`. \\n\\nDETECTION: More precisely, we keep track of highest value of `s3` for each valid `(s2 > s3)` pair while searching for a valid `s1` candidate to the left.  Once we encounter any number on the left that is smaller than the largest `s3` we have seen so far, we know we found a valid sequence, since `s1 < s3` implies `s1 < s2`.\\n\\nALGORITHM: We can start from either side but I think starting from the right allow us to finish in a single pass. The idea is to start from end and search for valid `(s2,s3)` pairs, we just need to remember the largest valid `s3` value, using a `stack` will be effective for this purpose. A number becomes a candidate for `s3` if there is any number on the left bigger than it. \\n\\nCORRECTNESS: As we scan from right to left, we can easily keep track of the largest `s3` value of all `(s2,s3)` candidates encountered so far. Hence, each time we compare `nums[i]` with the largest candidate for `s3` within the interval `nums[i+1]...nums[n-1]` we are effectively asking the question: **Is there any 132 sequence with `s1 = nums[i]`?**  Therefore, if the function returns false, there must be no 132 sequence.\\n\\nIMPLEMENTATION: \\n1) Have a `stack`, each time we store a new number, we first `pop` out all numbers that are smaller than that number. The numbers that are `popped` out becomes candidate for `s3`.\\n2) We keep track of the `maximum` of such `s3` (which is always the most recently `popped` number from the `stack`).\\n3) Once we encounter any number smaller than `s3`, we know we found a valid sequence since `s1 < s3` implies `s1 < s2`.\\n\\nRUNTIME: Each item is `pushed` and `popped` once at most, the time complexity is therefore O(n).\\n\\nEXAMPLE: \\n`i = 6`, **nums** =  [ 9, 11, 8, 9, 10, 7, `9` ], **S1 candidate** = `9`, **S3 candidate** = `None`, **Stack** = `Empty`\\n`i = 5`, **nums** =  [ 9, 11, 8, 9, 10, `7`, 9 ], **S1 candidate** = `7`, **S3 candidate** = `None`, **Stack** = `[9]`\\n`i = 4`, **nums** =  [ 9, 11, 8, 9, `10`, 7, 9 ], **S1 candidate** = `10`, **S3 candidate** = `None`, **Stack** = `[9,7]`\\n`i = 3`, **nums** =  [ 9, 11, 8, `9`, 10, 7, 9 ], **S1 candidate** = `9`, **S3 candidate** = `9`, **Stack** = `[10]`\\n`i = 2`, **nums** =  [ 9, 11, `8`, 9, 10, 7, 9 ], **S1 candidate** = `8`, **S3 candidate** = `9`, **Stack** = `[10,9]` **We have `8<9`, sequence `(8,10,9)` found!**\\n\\nEDIT: Thanks @Pumpkin78 and @dalwise for pointing out that the maximum candidate for s3 is always the recently popped number from the stack, because if we encounter any entry smaller than the current candidate, the function would already have returned.\\nEDIT 2: Rephrased explanations and added a sketch of the correctness proof.\\n\\n```\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94089,
                "title": "java-solutions-from-o-n-3-to-o-n-for-132-pattern-updated-with-one-pass-slution",
                "content": "This is a summary of the four solutions for this problem. It starts with the `O(n^3)` naive solution, then transition to the `O(n^2)` sub-optimal solution and finally to the two optimized `O(n)` solutions (one is two-pass while the other is one-pass). \\n\\n---\\n\\n**`I. Naive O(n^3) solution`**\\n\\nThe naive `O(n^3)` solution is a no-brainer --- simply check every `(i, j, k)` combination to see if there is any `132` pattern.\\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n        for (int j = i + 1; j < nums.length; j++) {\\n            for (int k = j + 1; k < nums.length; k++) {\\n                if (nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\nAnd of course it will get rejected due to TLE. So let's see how we can do better.\\n\\n---\\n\\n**`II. Improved O(n^2) solution`**\\n\\nTo reduce the time complexity down to `O(n^2)`, we need to do some observations. In the naive solution above, let's assume we have index `j` fixed, what should index `i` be so that it is most probable we will have a `132` pattern? Or in other words, what should `i` be so that we will be certain there is no such `132` pattern for combination `(*, j, *)` whenever there is no `132` pattern for combination of `(i, j, *)`? (Here `*` means any index before or after index `j`.)\\n\\nThe answer lies in the fact that once the first two numbers `nums[i]` and `nums[j]` are fixed, we are up to find the third number `nums[k]` which will be within the range `(nums[i], nums[j])` (the two boundaries are exclusive). Intuitively the larger the range is, the more likely there will be a number \"falling into\" it. Therefore we need to choose index `i` which will maximize the range `(nums[i], nums[j])`. Since the upper bound `nums[j]` is fixed, this is equivalent to minimizing the lower bound `nums[i]`. Thus it is clear `i` should be the index of the minimum element of the subarray `nums[0, j)` (left inclusive, right exclusive).\\n\\nSince we are scanning index `j` from the beginning of the input array `nums`, we can keep track of the minimum element of the subarray from index `0` up to `j - 1` without rescanning it. Therefore the first two loops in the naive solution can be combined into one and leads to the following `O(n^2)` solution:\\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int j = 0, min = Integer.MAX_VALUE; j < nums.length; j++) {\\n         min = Math.min(nums[j], min);\\n         if (min == nums[j]) continue;\\n         \\n         for (int k = nums.length - 1; k > j; k--) {\\n             if (min < nums[k] && nums[k] < nums[j]) return true;\\n         }\\n     }\\n     \\n     return false;\\n}\\n```\\nWhile this solution can be accepted, it runs slow. One obvious drawback is that in the second loop we are throwing away information about elements in the right part of `nums` that may be \"useful\" for later combinations. It turns out we can retain this \"useful\" information by applying the classic space-time tradeoff, which leads to the following `O(n)` time and `O(n)` space solution.\\n\\n---\\n\\n**`III. Optimized O(n) solution`**\\n\\nAs I mentioned, to further reduce the time complexity, we need to record the \"useful\" information about elements in the right part of the input array `nums`. Since these elements are located at the right part of `nums`, it will be hard to do so if we are scanning the array from the beginning. So the idea is to scan it from the end while in the meantime keep track of the \"useful\" information. But still at each index `j`, we need to know the minimum element for subarray `nums[0, j)`. This can be done by doing a pre-scan in the forward direction and memorize the results for each index in an auxiliary array (we will call the array as `arr` whose element `arr[j]` will denote the minimum element in the subarray `nums[0, j)`).\\n\\nUntil now we are kinda vague about the exact meaning of \"useful\" information, so let's try to be more specific. Assume we're currently scanning (from the end) the element with index `j`, our task is to find two elements `nums[i]` and `nums[k]` to determine if there exists a `132` pattern, with `i < j < k`. The left element `nums[i]`, as it has been shown in part `II`, will be chosen as `arr[j]`, the minimum element of subarray `nums[0, j)`. What about the right element `nums[k]`?\\n\\nThe answer to that will address the meaning of \"useful\" information. First note we are only interested in elements that are greater than `arr[j]`, so it is sensible to maintain only those elements. Second, among all these qualified elements, which one will be the most probable to fall into the range `(nums[i], nums[j])`? I would say it is the smallest one (i.e., if the smallest one is out of the range, all others will also be out of range). So to sum up, the \"useful\" information for current index `j` will be a collection of scanned elements that are greater than `arr[j]`, and `nums[k]` will be chosen as the smallest one if the collection is not empty.\\n\\nFrom the analyses above, it looks like we have to do some sorting stuff for the retained elements (or at least find a way to figure out its smallest element). Well, it turns out these elements will be sorted automatically due to the fact that `arr[j'] >= arr[j]` as long as `j' < j`. Here is how it goes, which is a proof by induction.\\n\\nAt the beginning we have an empty collection and of course it is sorted. Now suppose we are at index `j` and the corresponding collection is still sorted, let's see if it remains so at index `j - 1`. First we will check if `nums[j]` is greater than `arr[j]`. If not, we simply continue to `j - 1`. Since the collection is intact so it will be sorted at `j - 1`. Otherwise, we need to remove elements in the collection that are no greater than `arr[j]` (this is necessary because some smaller elements may be left over in the collection from previous steps). After removal, we then compare the first element in the collection with `nums[j]` to see if a `132` pattern has been found, provided the collection is not empty. If so, return true. Otherwise one of the following must be true: the collection is empty or `nums[j]` is no greater than the first element in the collection. In either case the collection is sorted. Now if we have `arr[j - 1] < nums[j]`, we need to add `nums[j]` to the collection since it is a qualified number for `arr[j - 1]`. Again in either case the collection will remain sorted after addition (if it is empty, after addition there is only one element; otherwise since the added element is no greater than the first element in the collection before addition, it will become the new first element after addition and the collection stays sorted).\\n\\nHere is the program with `O(n)` time and space complexity. There is one minor optimization based on the observation that the total number of elements in the collection will never exceed the total number of elements scanned so far. Therefore the right part of the `arr` array can be used to serve as the collection. For time complexity, each element in the input array `nums` will be pushed into and popped out from the collection (or stack to be exact) at most once, the time complexity will be `O(n)` despite of the nested loop.\\n```\\npublic boolean find132pattern(int[] nums) {\\n    int[] arr = Arrays.copyOf(nums, nums.length);\\n\\n    for (int i = 1; i < nums.length; i++) {\\n        arr[i] = Math.min(nums[i - 1], arr[i - 1]);\\n    }\\n    \\n    for (int j = nums.length - 1, top = nums.length; j >= 0; j--) {\\n        if (nums[j] <= arr[j]) continue;\\n        while (top < nums.length && arr[top] <= arr[j]) top++;\\n        if (top < nums.length && nums[j] > arr[top]) return true;\\n        arr[--top] = nums[j];\\n    }\\n        \\n    return false;\\n}\\n```\\n\\n---\\n\\n**`IV -- One-pass O(n) solution`**\\n\\nIt turned out that we don't need the `arr` array in part **`III`**, thus can get rid of the pre-scan. The idea is to do backward traversal of the input array and keep track of the maximum value (denoted as `third`) of all possible third numbers obtained so far (an element can be a candidate for the third number if and only if there is another element coming before and greater than it). This is because for two candidate third numbers `a` and `b`, if `a <= b` and there is no `132` pattern for `b`, then there must be no `132` pattern for `a` either. The idea is elaborated as follows. \\n\\nFor the current element being examined, we first check if it can be the first number by comparing it with `third`. If this is the case, a `132` pattern has been found. Otherwise, it will be treated as the second number to qualify scanned elements so far as candidate third numbers (note we are doing backward scan so the current element will always come before scanned elements). Of course we cannot do this for all scanned elements, as it will lead to an `O(n^2)` solution. Fortunately it suffices only to process scanned elements that are greater than `third`. This is because after an element is qualified to be the third number, it will only be used to update `third`. For those elements smaller than `third`, even if they are qualified to be the third number, they won't make `third` any larger and therefore can be ignored.\\n\\nSo we need to maintain a collection (stack, to be exact) for scanned elements that are greater than `third`. After the current element is done, it will be added to this collection for future processing. It can be shown by mathematical induction that elements in the collection will be sorted automatically, similar to that in part **`III`**. At the beginning the collection is empty so the base case is true. Assume the collection is sorted immediately before processing the current element, which is presumed to be `>= third` (otherwise a `132` pattern is found). We will scan the collection and pop out all elements smaller than the current element to find all qualified third numbers and update `third` accordingly. At the end, all remaining elements in the collection are no less than the current element, therefore adding the current element to the collection won't break the sorted property. So our induction assumption is also true.\\n\\nHere is the one-pass `O(n)` solution. We can also optimize the space cost to `O(1)` if the input array can act as the collection by taking advantage of the fact that size of the collection will never exceed the number of elements scanned so far.\\n\\n```\\npublic boolean find132pattern(int[] nums) {\\n    int n = nums.length, top = n, third = Integer.MIN_VALUE;\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (nums[i] < third) return true;\\n        while (top < n && nums[i] > nums[top]) third = nums[top++];\\n        nums[--top] = nums[i];\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean find132pattern(int[] nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n        for (int j = i + 1; j < nums.length; j++) {\\n            for (int k = j + 1; k < nums.length; k++) {\\n                if (nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int j = 0, min = Integer.MAX_VALUE; j < nums.length; j++) {\\n         min = Math.min(nums[j], min);\\n         if (min == nums[j]) continue;\\n         \\n         for (int k = nums.length - 1; k > j; k--) {\\n             if (min < nums[k] && nums[k] < nums[j]) return true;\\n         }\\n     }\\n     \\n     return false;\\n}\\n```\n```\\npublic boolean find132pattern(int[] nums) {\\n    int[] arr = Arrays.copyOf(nums, nums.length);\\n\\n    for (int i = 1; i < nums.length; i++) {\\n        arr[i] = Math.min(nums[i - 1], arr[i - 1]);\\n    }\\n    \\n    for (int j = nums.length - 1, top = nums.length; j >= 0; j--) {\\n        if (nums[j] <= arr[j]) continue;\\n        while (top < nums.length && arr[top] <= arr[j]) top++;\\n        if (top < nums.length && nums[j] > arr[top]) return true;\\n        arr[--top] = nums[j];\\n    }\\n        \\n    return false;\\n}\\n```\n```\\npublic boolean find132pattern(int[] nums) {\\n    int n = nums.length, top = n, third = Integer.MIN_VALUE;\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (nums[i] < third) return true;\\n        while (top < n && nums[i] > nums[top]) third = nums[top++];\\n        nums[--top] = nums[i];\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906789,
                "title": "short-java-o-n-solution-with-detailed-explanation-sample-test-case-stack-100",
                "content": "*------Please **upvote** if you like the solution.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION**:\\n\\n*Here, if we fix the peak, i.e. **3** in the **132 pattern**, then we can determine if any numbers on its left and right satisfy the given pattern.  We will do this with the help of a stack. Our stack implementation will take care of the **32 pattern** and then we will iterate over the array to find if any number satisfies the **1 pattern**.  See the algorithm below for better understanding*.  \\n\\n**Algorithm:**\\n\\n1. Create a stack and initialize a variable **second** with INT_MIN value.\\n2. Start traversing from the end of array.\\n3. Check if the current number is lesser than **second**. If it is, then it means our **132 pattern** is satisfied as the stack is taking care of the **32 pattern** and the current number satisfies the entire pattern. So return **true**.\\n4. If the above is not true, update the peak value in the stack. Keep popping from the stack until stack is empty OR the top value is greater than the current value.\\n5. Push the current number into the stack.\\n6. If the loop terminates, it means that the pattern was not found in the array.  So, return **false**.\\n\\n***Take the sample input as [3, 6, 4, 1, 2] and try out this algorithm using a pen & paper. You will be able to visualize the method then.***\\n\\nBasically, the **top** of stack is containing the **highest** number so far, i.e. **3** and **second** is containing the **second highest** number after the highest number, i.e. **2**.  So, this satisfies the **32 pattern**. Now, we will just keep updating **second** and **stack top** when we encounter a number which is greater than the highest number.\\n\\n```\\nclass Solution {\\n    public boolean find132pattern (int[] nums) {\\n        Stack <Integer> stack = new Stack ();\\n        int second = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums [i] < second)\\n                return true;\\n            while (!stack.isEmpty() && nums [i] > stack.peek ())\\n                second = stack.pop ();\\n            stack.push (nums [i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern (int[] nums) {\\n        Stack <Integer> stack = new Stack ();\\n        int second = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums [i] < second)\\n                return true;\\n            while (!stack.isEmpty() && nums [i] > stack.peek ())\\n                second = stack.pop ();\\n            stack.push (nums [i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94081,
                "title": "10-line-python-solution",
                "content": "```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        import sys\\n        stack = []\\n        s3 = -sys.maxint\\n        for n in nums[::-1]:\\n            if n < s3:\\n                return True\\n            while stack and stack[-1] < n:\\n                s3 = stack.pop()\\n            stack.append(n)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        import sys\\n        stack = []\\n        s3 = -sys.maxint\\n        for n in nums[::-1]:\\n            if n < s3:\\n                return True\\n            while stack and stack[-1] < n:\\n                s3 = stack.pop()\\n            stack.append(n)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94077,
                "title": "java-o-n-solution-using-stack-in-detail-explanation",
                "content": "The idea is that we can use a stack to keep track of previous min-max intervals. \\n\\nHere is the principle to maintain the stack:\\n\\nFor each number ```num``` in the array\\n\\nIf stack is empty:\\n\\n* push a new Pair of ```num``` into stack\\n\\nIf stack is not empty:\\n\\n* if ```num``` < ```stack.peek().min```,  push a new Pair of ```num``` into stack\\n\\n* if ```num```  >= ```stack.peek().min```, we first pop() out the peek element, denoted as ```last```\\n     * if  ```num```  < ```last.max```, we are done, return ```true```;\\n     \\n     * if  ```num```  >= ```last.max```, we merge ```num``` into ```last```, which means ```last.max``` = ```num```.  \\nOnce we update ```last```,  if stack is empty, we just push back ```last```. \\n**However, the crucial part is:** \\nIf stack is not empty, the updated ```last``` might:  \\n       \\n         * Entirely covered stack.peek(), i.e. ```last.min``` < ```stack.peek().min``` (which is always true) && ```last.max``` >= ```stack.peek().max```, in which case we keep popping out stack.peek().\\n         * Form a 1-3-2 pattern, we are done ,return ```true```\\n\\nSo at any time in the stack, **non-overlapping** ```Pairs``` are formed in descending order by their min value, which means the min value of peek element in the stack is always the min value globally. \\n\\n```\\n   class Pair{\\n        int min, max;\\n        public Pair(int min, int max){\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Pair> stack = new Stack();\\n        for(int n: nums){\\n            if(stack.isEmpty() || n <stack.peek().min ) stack.push(new Pair(n,n));\\n            else if(n > stack.peek().min){ \\n                Pair last = stack.pop();\\n                if(n < last.max) return true;\\n                else {\\n                    last.max = n;\\n                    while(!stack.isEmpty() && n >= stack.peek().max) stack.pop();\\n                    // At this time, n < stack.peek().max (if stack not empty)\\n                    if(!stack.isEmpty() && stack.peek().min < n) return true;\\n                    stack.push(last);\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```num```\n```num```\n```num```\n```stack.peek().min```\n```num```\n```num```\n```stack.peek().min```\n```last```\n```num```\n```last.max```\n```true```\n```num```\n```last.max```\n```num```\n```last```\n```last.max```\n```num```\n```last```\n```last```\n```last```\n```last.min```\n```stack.peek().min```\n```last.max```\n```stack.peek().max```\n```true```\n```Pairs```\n```\\n   class Pair{\\n        int min, max;\\n        public Pair(int min, int max){\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Pair> stack = new Stack();\\n        for(int n: nums){\\n            if(stack.isEmpty() || n <stack.peek().min ) stack.push(new Pair(n,n));\\n            else if(n > stack.peek().min){ \\n                Pair last = stack.pop();\\n                if(n < last.max) return true;\\n                else {\\n                    last.max = n;\\n                    while(!stack.isEmpty() && n >= stack.peek().max) stack.pop();\\n                    // At this time, n < stack.peek().max (if stack not empty)\\n                    if(!stack.isEmpty() && stack.peek().min < n) return true;\\n                    stack.push(last);\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906876,
                "title": "python-o-n-solution-with-decreasing-stack-explained",
                "content": "Let us keep evaluate `min_list`, where `min_list[i] = min(nums[0], ..., nums[i])`.\\nAlso let us traverse our `nums` from the end and keep stack with decreasing elements, which are more than `min_list[j]` for given `j`.\\nWe will try to find `132` pattern, where `nums[j]` is middle number in this pattern.\\n\\nLet us look through the code and see what is going on:\\n1. If `nums[j] <= min_list[j]`, there is no need to put this number to stack: it means actually that `nums[j]` is less than all previous numbers and it can not be the middle element in our `132` pattern.\\n2. Now, if `nums[j] > min_list[j]`, we need to keep our stack clean: if we have numbers which are leaa or equal than `min_list[j]`, we remove them from our stack. So, we have now `stack[-1] > min_list[j]`. If it is also happen, that `stack[-1] < nums[j]`, then we are happy: we found our pattern: we choose `stack[-1]` for our `2` in pattern, `nums[j]` for our `3` and element where minumum reached: `min_list[j]` for our `1`:  we have our `1` less than `2` and `2` less than `3`. In this case we immedietly return `True`. In the end we append `nums[j]` to our stack.\\n3. If we traversed all list and did not found pattern, we return `False`.\\n\\nSo, what exaclty will be in our stack on each step? \\n1. There always be numbers more  or equal than  `nums[j]` inside\\n2. Which are going in decreasing order. \\n\\nWhy it will not change on the next step? If our next number (`nums[j-1]`) is more than top of our stack, we found our `132` pattern! If it is less, then we put it into our stack and decreasing order is satisfied (property s) and if we have top of our stack equal to `nums[j-1]`, so property `1` is also satisfied.\\n\\n**Complexty** is `O(n)`, both for time and memory, because we traverse our list twice: once in one direction and once in opposite\\n\\n\\n```\\nclass Solution:\\n    def find132pattern(self, nums):\\n        min_list = list(accumulate(nums, min))\\n        stack, n = [], len(nums)\\n        \\n        for j in range(n-1, -1, -1):\\n            if nums[j] > min_list[j]:\\n                while stack and stack[-1] <= min_list[j]:\\n                    stack.pop()\\n                if stack and stack[-1] < nums[j]:\\n                    return True\\n                stack.append(nums[j])           \\n        return False\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums):\\n        min_list = list(accumulate(nums, min))\\n        stack, n = [], len(nums)\\n        \\n        for j in range(n-1, -1, -1):\\n            if nums[j] > min_list[j]:\\n                while stack and stack[-1] <= min_list[j]:\\n                    stack.pop()\\n                if stack and stack[-1] < nums[j]:\\n                    return True\\n                stack.append(nums[j])           \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166953,
                "title": "easy-and-concise-c-solution-using-a-stack-with-explanation-very-easy-to-understand",
                "content": "This question is asking us to find \"132\" pattern in the array. This reminds me of the stack-sortable permutation, which was introduced by Knuth. Please read [the detailed explanation](https://en.wikipedia.org/wiki/Stack-sortable_permutation) at the Wikipedia first.\\n\\n**Stack-sortable permutations** are the sequence of numbers that are sortable using a stack and thus it should not contain \"231\" pattern. Once you read the article, you can easily understand why the \"231\" pattern prevents it from being sorted.\\n\\nThis question is very similar with the problem that identifies the sequence of number is stack-sortable or not. Knuth\\'s algorithm finds \"231\" pattern, but we need to find \"132\" pattern in this question.\\n\\nHere is my idea. How about reversing the input array and then trying to find \"132\" pattern in it? In other words, this question is asking whether **the reversed input array is stack-sortable or not**.\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> s;\\n        int prev = INT_MIN;\\n        \\n        for (auto it = nums.rbegin(); it != nums.rend(); it++) {\\n            while (!s.empty() && s.top() < *it) {\\n                if (prev > s.top())\\n                    return true;\\n                prev = s.top();\\n                s.pop();\\n            }\\n            \\n            s.push(*it);\\n        }\\n        \\n        return !s.empty() && prev > s.top();\\n    }\\n};\\n```\\n\\nIn my opinion, explanation in this way is much easier than the official one.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> s;\\n        int prev = INT_MIN;\\n        \\n        for (auto it = nums.rbegin(); it != nums.rend(); it++) {\\n            while (!s.empty() && s.top() < *it) {\\n                if (prev > s.top())\\n                    return true;\\n                prev = s.top();\\n                s.pop();\\n            }\\n            \\n            s.push(*it);\\n        }\\n        \\n        return !s.empty() && prev > s.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425027,
                "title": "java-simple-and-clean-o-n-solution-similar-idea-with-next-greater-element",
                "content": "The idea is the same as the problem \"find next greater element\", but here we change to find the next smaller. \\nFrom end to start, if we find nums[i] is less than the maximum element that is smaller than another, then we can say we find the pattern.\\nupdate @ 12/15/2019\\n For example [..., 4, 6, 1, 3, ...], when finding the 132 pattern from left to right, we need to find the target in the range (1, 3) and (4, 6), these are incontinuous intervals, but from right to left, we only need to check whether the number n is in range (-inf, 3), if yes, then [n, 4or6, 3] is in pattern 132.\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int max = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            while (!stack.isEmpty() && stack.peek() < nums[i]) {\\n                max = stack.pop();\\n            }\\n            if (nums[i] > max) stack.push(nums[i]);\\n            if (nums[i] < max) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int max = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            while (!stack.isEmpty() && stack.peek() < nums[i]) {\\n                max = stack.pop();\\n            }\\n            if (nums[i] > max) stack.push(nums[i]);\\n            if (nums[i] < max) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206575,
                "title": "previous-greater-element-stack-o-n-no-reverse",
                "content": "we will keep a variable smallest to know the smallest number to the left (index i) of the current element (index j) so that there will be higher chance we find k which k > j > i and A[j] > A[k] > A[i] (because now we already have j > i and A[j] > A[i] the only thing we need to do is find if there is a element to the right of A[j] which smaller than A[j] and greater than A[i]), each time we will pop the stack until the last number of the last element in the stack greater than the current number, if Stack[-1][0] > current element it means we  found 1 3 2 pattern (this step is exactly the same with finding previous greater element).\\n```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        smallest = float(\\'inf\\')\\n        stack = []\\n        for i in nums:\\n            while stack and i >= stack[-1][-1]:\\n                stack.pop()\\n            if stack and i > stack[-1][0]:\\n                return True\\n            stack.append((smallest,i)) \\n            smallest = min(smallest,i)\\n        return False\\n            \\n            \\n",
                "solutionTags": [],
                "code": "we will keep a variable smallest to know the smallest number to the left (index i) of the current element (index j) so that there will be higher chance we find k which k > j > i and A[j] > A[k] > A[i] (because now we already have j > i and A[j] > A[i] the only thing we need to do is find if there is a element to the right of A[j] which smaller than A[j] and greater than A[i]), each time we will pop the stack until the last number of the last element in the stack greater than the current number, if Stack[-1][0] > current element it means we  found 1 3 2 pattern (this step is exactly the same with finding previous greater element).\\n```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        smallest = float(\\'inf\\')\\n        stack = []\\n        for i in nums:\\n            while stack and i >= stack[-1][-1]:\\n                stack.pop()\\n            if stack and i > stack[-1][0]:\\n                return True\\n            stack.append((smallest,i)) \\n            smallest = min(smallest,i)\\n        return False\\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1541296,
                "title": "o-n-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    // We need s1<s3<s2\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini[n];\\n\\t\\t//mini at any position will be our candidate for s1\\n        mini[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            mini[i]=min(mini[i-1], nums[i]);\\n        stack<int> st;\\n        for(int j=n-1;j>=0;j--){ //nums[j] will be our candidate for s2\\n            if(nums[j]>mini[j]){ //s1<s2\\n                while(!st.empty() && st.top()<=mini[j]){ //discarding all elements right to s2 which are smaller than s1 as we need s3>s1\\n                    st.pop();\\n                }\\n                if(!st.empty() && st.top()<nums[j]) //now st.top() is our candidate for s3 and we have ensured s1<s3<s2\\n                    return true;\\n                st.push(nums[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // We need s1<s3<s2\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini[n];\\n\\t\\t//mini at any position will be our candidate for s1\\n        mini[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            mini[i]=min(mini[i-1], nums[i]);\\n        stack<int> st;\\n        for(int j=n-1;j>=0;j--){ //nums[j] will be our candidate for s2\\n            if(nums[j]>mini[j]){ //s1<s2\\n                while(!st.empty() && st.top()<=mini[j]){ //discarding all elements right to s2 which are smaller than s1 as we need s3>s1\\n                    st.pop();\\n                }\\n                if(!st.empty() && st.top()<nums[j]) //now st.top() is our candidate for s3 and we have ensured s1<s3<s2\\n                    return true;\\n                st.push(nums[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906994,
                "title": "c-easy-and-o-n-stack-solution",
                "content": "if you like it pls upvote\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int> stack;\\n        int second =  -2147483648;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums [i] < second)\\n                return true;\\n            while (stack.size() >0 && nums [i] > stack.top()){\\n                second = stack.top ();\\n                stack.pop();\\n            }\\n                \\n            stack.push (nums [i]);\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int> stack;\\n        int second =  -2147483648;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums [i] < second)\\n                return true;\\n            while (stack.size() >0 && nums [i] > stack.top()){\\n                second = stack.top ();\\n                stack.pop();\\n            }\\n                \\n            stack.push (nums [i]);\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015125,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        if len(nums)<3:\\n            return False\\n      \\n        second_num = -math.inf\\n        stck = []\\n        # Try to find nums[i] < second_num < stck[-1]\\n        for i in range(len(nums) - 1, -1, -1):\\n            if nums[i] < second_num:\\n                return True\\n            # always ensure stack can be popped in increasing order\\n            while stck and stck[-1] < nums[i]:\\n\\t\\t\\t\\tsecond_num = stck.pop()  # this will ensure  second_num < stck[-1] for next iteration\\n\\n            stck.append(nums[i])\\n        return False\\n        \\n```\\n\\n**T = O(N)**\\n**S = O(N)** - needed for stack\\n\\n---\\n\\nI am adding an explanation for using `second_num`. The following was shared by [@zayne-siew](https://leetcode.com/zayne-siew) \\n\\nWe consider the largest possible `second_num` so that the `nums[i] < second_num` check has the largest possible range of values of `nums[i]` for it to return true. (We can guarantee that `second_num` is the largest possible second number for the current index since we popped it from `stck`, which is monotonically decreasing.) Consider the following example:\\n\\n```\\nnums = [ 1, 4, 3, 2 ]\\n\\nWhen idx = 3, stck = [ ], second_num = -inf\\nWhen idx = 2, stck = [2], second_num = -inf\\nWhen idx = 1, stck = [3], second_num = 2\\nWhen idx = 0, stck = [4], second_num = 3\\n\\n132 pattern found: ( 1, 4, 3 )\\n```\\nNote that `( 1, 4, 2 )` is also a valid `132` pattern, even though we discarded the `2` for the `3` when `idx = 1`. However, either way, the function will return true. Hence, **the earlier popped numbers can also be candidates for `second_num`, but we will be able to find the 132 pattern (if any) just using the largest possible `second_num`**.\\n\\nNote also that the same thing can be said for the largest number; even though `( 1, 3, 2 )` is a valid 132 pattern, the largest number `3` is popped from stck and replaced with `4` when` idx = 1`. Again, either way, the function returns true.\\n\\n----\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        if len(nums)<3:\\n            return False\\n      \\n        second_num = -math.inf\\n        stck = []\\n        # Try to find nums[i] < second_num < stck[-1]\\n        for i in range(len(nums) - 1, -1, -1):\\n            if nums[i] < second_num:\\n                return True\\n            # always ensure stack can be popped in increasing order\\n            while stck and stck[-1] < nums[i]:\\n\\t\\t\\t\\tsecond_num = stck.pop()  # this will ensure  second_num < stck[-1] for next iteration\\n\\n            stck.append(nums[i])\\n        return False\\n        \\n```\n```\\nnums = [ 1, 4, 3, 2 ]\\n\\nWhen idx = 3, stck = [ ], second_num = -inf\\nWhen idx = 2, stck = [2], second_num = -inf\\nWhen idx = 1, stck = [3], second_num = 2\\nWhen idx = 0, stck = [4], second_num = 3\\n\\n132 pattern found: ( 1, 4, 3 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015224,
                "title": "4-approaches-bf-o-n-3-bf-o-n-2-treemap-monotonic-stack",
                "content": "[Leetcode](https://leetcode.com/) [456. 132 Pattern](https://leetcode.com/problems/132-pattern/).\\n\\n***By Frank Luo***\\n\\nHere are **4** approaches to solve this problem in Java: BF $O(n^3)$, BF $O(n^2)$, **TreeMap**, **Monotonic Stack**.\\n\\n\\n# BF O(n^3)\\n\\nIt\\'s easy to use **3 loops** to find $3$ elements which is $132$ pattern, but the time complexity is $O(n^3)$, so it wouldn\\'t accepted as **TLE**!\\n\\n```java\\n    public boolean find132pattern_bf(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < len - 2; i++) {\\n            for (int j = i + 1; j < len - 1; j++) {\\n                for (int k = j + 1; k < len; k++) {\\n                    if (nums[i] < nums[k] && nums[k] < nums[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^3)$.\\n- **Space Complexity**: $O(1)$.\\n\\n\\n# BF O(n^2)\\n\\nNoticed that $\\\\textit{nums}[j]$ is the peak of the $3$ elements, suppose the current element is $\\\\textit{nums}[j]$, we have to find the element $\\\\textit{nums}[k]$ that is smaller than $\\\\textit{nums}[j]$ after $j$, and the element $\\\\textit{nums}[i]$ that is smaller than $\\\\textit{nums}[k]$ before $j$. \\n\\n1. Scan left from $j$ to $0$, $0 \\\\le i \\\\lt j$, whether there is $\\\\textit{nums}[i] < \\\\textit{nums}[j]$, update the mininum $\\\\textit{leftMin}$;\\n\\n2. Scan right from $j$ to the end, $j + 1 \\\\le k \\\\lt len$, whether there is $\\\\textit{nums}[k] < \\\\textit{nums}[j]$, update the maxinum $\\\\textit{rightMax}$;\\n\\n3. If exists and $\\\\textit{leftMin} < \\\\textit{rightMax}$, return **true**.\\n\\n\\nLet\\'s coding it.\\n\\n```java\\n    public boolean find132pattern_bf_opt(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        for (int j = 1; j < len - 1; j++) {\\n            int leftMin = Integer.MAX_VALUE;\\n            boolean leftFlag = false;\\n            for (int i = j - 1; i >= 0; i--) {\\n                if (nums[i] < nums[j]) {\\n                    leftFlag = true;\\n                    leftMin = Math.min(leftMin, nums[i]);\\n                }\\n            }\\n\\n            int rightMax = Integer.MIN_VALUE;\\n            boolean rightFlag = false;\\n            for (int k = j + 1; k < len; k++) {\\n                if (nums[k] < nums[j]) {\\n                    rightFlag = true;\\n                    rightMax = Math.max(rightMax, nums[k]);\\n                }\\n            }\\n\\n            if (leftFlag && rightFlag && leftMin < rightMax) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$.\\n- **Space Complexity**: $O(1)$.\\n\\n\\n# TreeMap\\n\\nMethod 2 is $O(n^2)$. With extra $O(n)$ space to store the elements of the array, we can reduce the time complexity to $O(n)$.\\n\\nWe have to maintain all the values of the array in the right of $j$. As we have determined $nums[i]$ and $\\\\textit{nums}[j]$, we only need to query the smallest element $\\\\textit{nums}[k]$ in the sorted set which is strictly larger than $\\\\textit{nums}[i]$. \\n\\nThen if $\\\\textit{nums}[k] < \\\\textit{nums}[j]$, which means we have found the $3$ elements of $132$ pattern.\\n\\n```java\\n    public static boolean find132pattern_map(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        TreeMap<Integer, Integer> rightMap = new TreeMap<>();\\n        for (int i = 2; i < len; i++) {\\n            rightMap.put(nums[i], rightMap.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int leftMin = nums[0];\\n        for (int j = 1; j < len - 1; j++) {\\n            if (leftMin < nums[j]) {\\n                Integer numK = rightMap.ceilingKey(leftMin + 1);\\n                if (numK != null && numK < nums[j]) {\\n                    return true;\\n                }\\n            }\\n\\n            leftMin = Math.min(leftMin, nums[j]);\\n            rightMap.put(nums[j + 1], rightMap.get(nums[j + 1]) - 1);\\n            if (rightMap.get(nums[j + 1]) == 0) {\\n                rightMap.remove(nums[j + 1]);\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$.\\n- **Space Complexity**: $O(n)$.\\n\\n\\n# Monotonic Stack\\n\\nWe can use a stack to store the element of the array from the back to front, find $\\\\textit{nums}[k]$ in the stack, and then continue to scan forward to find $\\\\textit{nums}[i]$. \\n\\nThe stack must store elements with a larger index and a smaller value than $\\\\textit{nums}[j]$.\\n\\nThe process is like this:\\n\\n1. Scanning from the back to the front, if the current element $\\\\textit{nums}[i]$ is larger than the top of the stack, which means $\\\\textit{nums}[i]$ may be the $\\\\textit{nums}[j]$ we are looking for;\\n\\n2. Pop all the elements in the stack that are smaller than it. These elements are the the $\\\\textit{nums}[k]$, and the last pop-up is the maximum qualified $\\\\textit{nums}[k]$. \\n\\n3. If this $\\\\textit{nums}[k]$ is larger than the $\\\\textit{nums}[i]$ scanned forward, we find the answer.\\n\\n\\n```java\\n    public boolean find132pattern_stack(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        Deque<Integer> stk = new ArrayDeque<>();\\n        int k = -1;\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (k > -1 && nums[k] > nums[i]) {\\n                return true;\\n            }\\n\\n            while (!stk.isEmpty() && nums[i] > nums[stk.peek()]) {\\n                k = stk.pop();\\n            }\\n\\n            stk.push(i);\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n)$.\\n\\n----------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```java\\n    public boolean find132pattern_bf(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < len - 2; i++) {\\n            for (int j = i + 1; j < len - 1; j++) {\\n                for (int k = j + 1; k < len; k++) {\\n                    if (nums[i] < nums[k] && nums[k] < nums[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    public boolean find132pattern_bf_opt(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        for (int j = 1; j < len - 1; j++) {\\n            int leftMin = Integer.MAX_VALUE;\\n            boolean leftFlag = false;\\n            for (int i = j - 1; i >= 0; i--) {\\n                if (nums[i] < nums[j]) {\\n                    leftFlag = true;\\n                    leftMin = Math.min(leftMin, nums[i]);\\n                }\\n            }\\n\\n            int rightMax = Integer.MIN_VALUE;\\n            boolean rightFlag = false;\\n            for (int k = j + 1; k < len; k++) {\\n                if (nums[k] < nums[j]) {\\n                    rightFlag = true;\\n                    rightMax = Math.max(rightMax, nums[k]);\\n                }\\n            }\\n\\n            if (leftFlag && rightFlag && leftMin < rightMax) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    public static boolean find132pattern_map(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        TreeMap<Integer, Integer> rightMap = new TreeMap<>();\\n        for (int i = 2; i < len; i++) {\\n            rightMap.put(nums[i], rightMap.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int leftMin = nums[0];\\n        for (int j = 1; j < len - 1; j++) {\\n            if (leftMin < nums[j]) {\\n                Integer numK = rightMap.ceilingKey(leftMin + 1);\\n                if (numK != null && numK < nums[j]) {\\n                    return true;\\n                }\\n            }\\n\\n            leftMin = Math.min(leftMin, nums[j]);\\n            rightMap.put(nums[j + 1], rightMap.get(nums[j + 1]) - 1);\\n            if (rightMap.get(nums[j + 1]) == 0) {\\n                rightMap.remove(nums[j + 1]);\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    public boolean find132pattern_stack(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        Deque<Integer> stk = new ArrayDeque<>();\\n        int k = -1;\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (k > -1 && nums[k] > nums[i]) {\\n                return true;\\n            }\\n\\n            while (!stk.isEmpty() && nums[i] > nums[stk.peek()]) {\\n                k = stk.pop();\\n            }\\n\\n            stk.push(i);\\n        }\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 700414,
                "title": "python-detailed-explanation-stack-solution",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. We Create Minimum Array, till that position => O(n)\\n        ## 2. We start iterating from reverse of given array.\\n        ## 3. Remember we are using Stack and TopOfStack to determine, 2 in 132 pattern. ( so we have to check)\\n        ## 4. At any position, we push all elements IF greater than minimum (possible 2 in 132 pattern)\\n        ## 5. At any position, we pop all stack elements IF topOfStack is less or EQUAL to minimum (invalid element to form 132 pattern)\\n        ## 6. SATISFYING CONDITION : at any stage if min_nums[i] < stack[-1] < nums[i] we return True.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        ## EDGE CASE : While checking the conditions 4,5,6. We should perform pop operation first i.e remove invalid elements before inserting the current element into the stack.\\n        \\n        if len(set(nums)) < 3:\\n            return False\\n\\n        min_nums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            min_nums.append(min(nums[i], min_nums[-1]))\\n            \\n        stack = []  \\n        i = len(nums) - 1\\n        for i in range(len(nums)-1, -1, -1):\\n            # 4\\n            if( nums[i] > min_nums[i] ):\\n                # 5\\n                while( stack and stack[-1] <= min_nums[i] ):\\n                    stack.pop()\\n                # 6\\n                if(stack and min_nums[i] < stack[-1] < nums[i] ):\\n                    return True\\n                # 4\\n                stack.append(nums[i])\\n        return False       \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. We Create Minimum Array, till that position => O(n)\\n        ## 2. We start iterating from reverse of given array.\\n        ## 3. Remember we are using Stack and TopOfStack to determine, 2 in 132 pattern. ( so we have to check)\\n        ## 4. At any position, we push all elements IF greater than minimum (possible 2 in 132 pattern)\\n        ## 5. At any position, we pop all stack elements IF topOfStack is less or EQUAL to minimum (invalid element to form 132 pattern)\\n        ## 6. SATISFYING CONDITION : at any stage if min_nums[i] < stack[-1] < nums[i] we return True.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        ## EDGE CASE : While checking the conditions 4,5,6. We should perform pop operation first i.e remove invalid elements before inserting the current element into the stack.\\n        \\n        if len(set(nums)) < 3:\\n            return False\\n\\n        min_nums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            min_nums.append(min(nums[i], min_nums[-1]))\\n            \\n        stack = []  \\n        i = len(nums) - 1\\n        for i in range(len(nums)-1, -1, -1):\\n            # 4\\n            if( nums[i] > min_nums[i] ):\\n                # 5\\n                while( stack and stack[-1] <= min_nums[i] ):\\n                    stack.pop()\\n                # 6\\n                if(stack and min_nums[i] < stack[-1] < nums[i] ):\\n                    return True\\n                # 4\\n                stack.append(nums[i])\\n        return False       \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094481,
                "title": "c-o-n-solution-using-monotone-stack-easy",
                "content": "Use a decreasing stack to store the value of num[k], and use a variable third to store the value of num[j]. **All the elements in stack need to bigger than third to satisfy nums[k] < nums[j]**. Inversely traverse the array to indicate the first value. if the first value is smaller than the third than return true. if not than put it in the stack.\\n\\nSince we need to hold the monotone of the stack, if the num[i] value is bigger than the top of the stack, we let **third = stack.top() and pop out the top of stack**, which mean that we can form a bigger num[k] (nums[ptr]) and a bigger nums[j] (stack.top()),  So if the next iterate can let the first value smaller than the third more easily.\\n```\\nint third = INT_MIN;\\n        stack<int> s;\\n        for (int i = nums.size() - 1; i >= 0; -- i) {\\n            if (nums[i] < third) return true;\\n            while (!s.empty() && nums[i] > s.top()) {\\n                third = s.top(); \\n                s.pop();\\n                \\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint third = INT_MIN;\\n        stack<int> s;\\n        for (int i = nums.size() - 1; i >= 0; -- i) {\\n            if (nums[i] < third) return true;\\n            while (!s.empty() && nums[i] > s.top()) {\\n                third = s.top(); \\n                s.pop();\\n                \\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94133,
                "title": "simple-java-accepted-well-explained-o-n-2-solution",
                "content": "```\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null || nums.length < 3) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int bigger = nums[i];    \\n            for(int j = i + 1; j < nums.length; j++) {\\n                // 1. We don't care about numbers\\n                // less than a[i]\\n                if(nums[j] <= nums[i]) continue;\\n                \\n                // 2. If num is greater than bigger\\n                // then update bigger\\n                if(nums[j] >= bigger) {\\n                    bigger = nums[j];\\n                } else {\\n                    // Now this number is greater than nums[i]\\n                    // see 1. and less than bigger, see 2.\\n                    return true;\\n                }  \\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null || nums.length < 3) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int bigger = nums[i];    \\n            for(int j = i + 1; j < nums.length; j++) {\\n                // 1. We don't care about numbers\\n                // less than a[i]\\n                if(nums[j] <= nums[i]) continue;\\n                \\n                // 2. If num is greater than bigger\\n                // then update bigger\\n                if(nums[j] >= bigger) {\\n                    bigger = nums[j];\\n                } else {\\n                    // Now this number is greater than nums[i]\\n                    // see 1. and less than bigger, see 2.\\n                    return true;\\n                }  \\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015708,
                "title": "c-8-line-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       int s3 = INT_MIN;\\n       int n = nums.size();\\n        stack<int>s;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(nums[i]<s3)\\n                return true;\\n            else\\n            {\\n                while(!s.empty() && nums[i]>s.top())\\n                {\\n                    s3 = s.top();\\n                    s.pop();\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       int s3 = INT_MIN;\\n       int n = nums.size();\\n        stack<int>s;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(nums[i]<s3)\\n                return true;\\n            else\\n            {\\n                while(!s.empty() && nums[i]>s.top())\\n                {\\n                    s3 = s.top();\\n                    s.pop();\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973635,
                "title": "c-o-n-solution-stack-with-simplest-possible-explanation",
                "content": "# Brief Overview\\n**// firstly we will calculate the minimum value i.e at ith position\\n// then we fixed j and search for a value which is less then nums[j] but greater than nums[i] \\n// which is equal to nums[k]**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    bool find132pattern(vector<int> &nums)\\n    {\\n        if (nums.empty())\\n            return false;\\n        int n = nums.size();\\n        vector<int> minVal(n);\\n        minVal[0] = nums[0];\\n        stack<int> st;\\n        for (int i = 1; i < n; i++)\\n        {\\n            minVal[i] = min(minVal[i - 1], nums[i]);\\n        }\\n        for (int j = n - 1; j > 0; j--)\\n        // here j is the second element so it cannot be at 0th position\\n        {\\n            while (!st.empty() && nums[st.top()] < nums[j])\\n            {\\n                // while the stack is not empty and the top is less than nums[j], this could be our possible k\\n                // only if the if condition satisfy\\n                // i.e it should be greater than the minVal i.e nums[i]\\n                if (nums[st.top()] > minVal[j - 1])\\n                {\\n                    return true;\\n                }\\n                // else remove the position from stack\\n                st.pop();\\n            }\\n            st.push(j);\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Tried to explain in the simplest possible words, Hope it helps**\\n**Please Upvote if it helped you, your suggestions are welcome**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool find132pattern(vector<int> &nums)\\n    {\\n        if (nums.empty())\\n            return false;\\n        int n = nums.size();\\n        vector<int> minVal(n);\\n        minVal[0] = nums[0];\\n        stack<int> st;\\n        for (int i = 1; i < n; i++)\\n        {\\n            minVal[i] = min(minVal[i - 1], nums[i]);\\n        }\\n        for (int j = n - 1; j > 0; j--)\\n        // here j is the second element so it cannot be at 0th position\\n        {\\n            while (!st.empty() && nums[st.top()] < nums[j])\\n            {\\n                // while the stack is not empty and the top is less than nums[j], this could be our possible k\\n                // only if the if condition satisfy\\n                // i.e it should be greater than the minVal i.e nums[i]\\n                if (nums[st.top()] > minVal[j - 1])\\n                {\\n                    return true;\\n                }\\n                // else remove the position from stack\\n                st.pop();\\n            }\\n            st.push(j);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94076,
                "title": "share-my-easy-and-simple-solution",
                "content": "Idea: Find peak and bottom\\n\\nFor every [bottom, peak], find if there is one number `bottom<number<peak`. \\n\\n```java\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3) return false;\\n        Integer low = null, high = null;\\n        int start = 0, end = 0;\\n        while(start<nums.length-1){\\n            while(start<nums.length-1 && nums[start]>=nums[start+1]) start++;\\n            // start is lowest now\\n            int m = start+1;\\n            while(m<nums.length-1 && nums[m]<=nums[m+1]) m++;\\n            // m is highest now\\n            int j = m+1;\\n            while(j<nums.length){\\n                if(nums[j]>nums[start] && nums[j]<nums[m]) return true;\\n                j++;\\n            }\\n            start = m+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3) return false;\\n        Integer low = null, high = null;\\n        int start = 0, end = 0;\\n        while(start<nums.length-1){\\n            while(start<nums.length-1 && nums[start]>=nums[start+1]) start++;\\n            // start is lowest now\\n            int m = start+1;\\n            while(m<nums.length-1 && nums[m]<=nums[m+1]) m++;\\n            // m is highest now\\n            int j = m+1;\\n            while(j<nums.length){\\n                if(nums[j]>nums[start] && nums[j]<nums[m]) return true;\\n                j++;\\n            }\\n            start = m+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015584,
                "title": "c-monotonic-stack",
                "content": "This implementation is based on a monotonic decreasing stack ( keeping values in decreasing order in stack / top value being the lowest among all) . We keep a track of values before a particular index in decresing order and also the minimun value before these values along with them. So for a particular index , we check if the top of stack is greater (if not we pop as we maintain a decreasing stack) , if yes , then we check if the min present with it is less than our current value (if yes we got a valid triplet , return true) .If not we push this to the stack .\\n\\n\\n```\\n        \\n        stack<pair<int,int>> s;  //*** stack with first as value at index and second as minimum value encountered before current index\\n        \\n        int mini = INT_MAX;   // keeping track of minimum value encountered before our current index\\n        \\n        for(int i = 0;i<nums.size();i++){\\n            \\n            if(s.size()!=0)\\n            mini = min(mini,s.top().first);  // since we have to keep it for a value before current , we will check it here as the value of previous index will always be there at top\\n            \\n            \\n            while(s.size()!=0 && nums[i]>s.top().first){   //**  keeping the stack in decreasing order\\n                \\n                s.pop();\\n            }\\n            \\n            \\n            if(s.size()!=0){         // find if the value we got at the top is greater than our current and also the min with that value is smaller than current value\\n                \\n            if((s.top().first > nums[i]) && (nums[i] > s.top().second))return true;\\n            }\\n            \\n            s.push({nums[i],mini});  \\n           \\n        \\n        }\\n        \\n        \\n        \\n        return false;\\n        \\n        \\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n        \\n        stack<pair<int,int>> s;  //*** stack with first as value at index and second as minimum value encountered before current index\\n        \\n        int mini = INT_MAX;   // keeping track of minimum value encountered before our current index\\n        \\n        for(int i = 0;i<nums.size();i++){\\n            \\n            if(s.size()!=0)\\n            mini = min(mini,s.top().first);  // since we have to keep it for a value before current , we will check it here as the value of previous index will always be there at top\\n            \\n            \\n            while(s.size()!=0 && nums[i]>s.top().first){   //**  keeping the stack in decreasing order\\n                \\n                s.pop();\\n            }\\n            \\n            \\n            if(s.size()!=0){         // find if the value we got at the top is greater than our current and also the min with that value is smaller than current value\\n                \\n            if((s.top().first > nums[i]) && (nums[i] > s.top().second))return true;\\n            }\\n            \\n            s.push({nums[i],mini});  \\n           \\n        \\n        }\\n        \\n        \\n        \\n        return false;\\n        \\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908889,
                "title": "bst-o-nlogn-solution-thought-process",
                "content": "Below is my thought process to arrive at a solution using a self-balancing binary search tree. \\n\\nThe time complexity is `~O(N logN)` and a space complexity is `~O(N)`, where `N` is the length of the input.\\n\\nAs stated in the official solution, we can start from the brute force solution that takes `~O(N^2)` time.\\n\\n```java\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) {\\n            return false;\\n        }\\n        \\n        int min_i = Integer.MAX_VALUE;\\n        for (int j = 0; j < n; j++) {\\n            min_i = Math.min(min_i, nums[j]);\\n            for (int k = j + 1; k < n; k++) {\\n                if (nums[k] < nums[j] && nums[k] > min_i) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nThe above solution iterates through a possible `nums[j]`, while keeping track of the minimum `nums[i]` encountered so far. For the rest of the array `nums[j+1...]`, we iterate through the values one by one to find `nums[k]` such that:\\n\\n* `nums[k] < nums[j]` and\\n* `nums[k] > min_i`\\n\\n## What is the bottleneck?\\n\\nA possible bottleneck is that,  for each value of `j`, we keep iterating through the rest of the array to check for an existence of a suitable `nums[k]`. Let\\'s see if we can do better.\\n\\nWhy do we have to iterate through the rest of the array? The goal is to find `nums[k]` such that `min_i < nums[k] < nums[j]`, as stated above. Is there a better way to search for such element that falls withtin the desired range?\\n\\n## Improvement\\n\\n**Binary search tree** supports range query in time proportional to its height, because it keeps the elements in a certain order. Concretely, for each node, no child on the left subtree is greater than the node, and no child on the right subtree is less than the node.\\n\\nFor self-balancing BST such as Red-Black trees, it is possible to support all ordered operations in logarithmic time. In Java, `TreeMap` is an implementation of a Red-Black tree. Let us use that to keep each value, and their counts. Since there might be dupliate numbers, we need to keep track of the counts. Otherwise, we could have also used `TreeSet`.\\n\\n```java\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n\\t\\t\\n\\t\\t// impossible\\n        if (n < 3) {\\n            return false;\\n        }\\n        \\n\\t\\t// a self-balancing BST to keep track of numbers and their counts.\\n        TreeMap<Integer, Integer> t = new TreeMap();\\n        for (int i = 1; i < n; i++) {\\n            t.put(nums[i], t.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        int min_i = Integer.MAX_VALUE;\\n        for (int j = 1; j < n; j++) {\\n            min_i = Math.min(min_i, nums[j-1]);\\n\\t\\t\\t\\n\\t\\t\\t// exclude the current nums[j] from the search space\\n\\t\\t\\t// if the count is 0, simply discard the node from the BST.\\n            t.put(nums[j], t.get(nums[j]) - 1);\\n            if (t.get(nums[j]) == 0) {\\n                t.remove(nums[j]);\\n            }\\n            \\n            if (nums[j] < min_i) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// check if a number, nums[k], exists in the current search space\\n\\t\\t\\t// such that min_i < nums[k] < nums[j].\\n            if (t.subMap(min_i, false, nums[j], false).size() > 0) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nBy using the right data structure, we obviated the need for continued iteration throughout the rest of the array. Instead of iterating for find a suitable `nums[k]`, we can simply rely on the ordered operation on a BST whose height is guaranteed to be `~O(logN)`.",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) {\\n            return false;\\n        }\\n        \\n        int min_i = Integer.MAX_VALUE;\\n        for (int j = 0; j < n; j++) {\\n            min_i = Math.min(min_i, nums[j]);\\n            for (int k = j + 1; k < n; k++) {\\n                if (nums[k] < nums[j] && nums[k] > min_i) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n\\t\\t\\n\\t\\t// impossible\\n        if (n < 3) {\\n            return false;\\n        }\\n        \\n\\t\\t// a self-balancing BST to keep track of numbers and their counts.\\n        TreeMap<Integer, Integer> t = new TreeMap();\\n        for (int i = 1; i < n; i++) {\\n            t.put(nums[i], t.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        int min_i = Integer.MAX_VALUE;\\n        for (int j = 1; j < n; j++) {\\n            min_i = Math.min(min_i, nums[j-1]);\\n\\t\\t\\t\\n\\t\\t\\t// exclude the current nums[j] from the search space\\n\\t\\t\\t// if the count is 0, simply discard the node from the BST.\\n            t.put(nums[j], t.get(nums[j]) - 1);\\n            if (t.get(nums[j]) == 0) {\\n                t.remove(nums[j]);\\n            }\\n            \\n            if (nums[j] < min_i) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// check if a number, nums[k], exists in the current search space\\n\\t\\t\\t// such that min_i < nums[k] < nums[j].\\n            if (t.subMap(min_i, false, nums[j], false).size() > 0) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902824,
                "title": "c-stack-o-n-solution-explained",
                "content": "Runtime: 20 ms, faster than 99.71% of C++ online submissions for 132 Pattern.\\nMemory Usage: 12.9 MB, less than 10.09% of C++ online submissions for 132 Pattern.\\n\\n```\\nGiven array nums, find nums[i] < nums[k] < nums[j] such that i < j < k\\n\\nFor tracking nums[i] we can use minValue array where ith value stores \\nmin value in range 0 to i-1 index\\n\\nNow we can loop from end to start and store the next greater number \\nof minValue[x] in the stack and check if stack.top < nums[x] then return true\\n    \\nminValue[x] (nums[i]) < stack.top (nums[k]) < nums[x] (nums[j])\\n\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // no 132 pattern possible\\n        if(n<3) return false;\\n        \\n        // track min value in range 0 to i-1\\n        vector<int>minValues(n,INT_MAX);\\n        \\n        // store min values\\n        for(int i=1;i<n;i++)\\n            minValues[i] = min(minValues[i-1],nums[i-1]);\\n        \\n        stack<int>stak;\\n        \\n        // Loop through end to start\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            // pop numbers from stack which are less or equal to minValue[i]\\n            // find next greater number of minValue[i]\\n            while(!stak.empty() && stak.top()<=minValues[i])\\n                stak.pop();\\n            \\n            // stack.top < nums[i] then it is a 132 pattern as stack.top > minValue[i]\\n            if(!stak.empty() && stak.top()< nums[i]) return true;\\n            \\n            stak.push(nums[i]);\\n        }\\n        \\n        return false;\\n\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nGiven array nums, find nums[i] < nums[k] < nums[j] such that i < j < k\\n\\nFor tracking nums[i] we can use minValue array where ith value stores \\nmin value in range 0 to i-1 index\\n\\nNow we can loop from end to start and store the next greater number \\nof minValue[x] in the stack and check if stack.top < nums[x] then return true\\n    \\nminValue[x] (nums[i]) < stack.top (nums[k]) < nums[x] (nums[j])\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // no 132 pattern possible\\n        if(n<3) return false;\\n        \\n        // track min value in range 0 to i-1\\n        vector<int>minValues(n,INT_MAX);\\n        \\n        // store min values\\n        for(int i=1;i<n;i++)\\n            minValues[i] = min(minValues[i-1],nums[i-1]);\\n        \\n        stack<int>stak;\\n        \\n        // Loop through end to start\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            // pop numbers from stack which are less or equal to minValue[i]\\n            // find next greater number of minValue[i]\\n            while(!stak.empty() && stak.top()<=minValues[i])\\n                stak.pop();\\n            \\n            // stack.top < nums[i] then it is a 132 pattern as stack.top > minValue[i]\\n            if(!stak.empty() && stak.top()< nums[i]) return true;\\n            \\n            stak.push(nums[i]);\\n        }\\n        \\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015153,
                "title": "easy-and-simple-code-with-3-aproaches",
                "content": "***APROACH 1: BRUTE FORCE {TLE}***\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        for(int i = 0; i < nums.length - 2; ++i){\\n            if(nums[i] >= nums[i + 1]){\\n                continue;\\n            }\\n            for(int j = i + 1; j < nums.length - 1; ++j){\\n                if(nums[j] <= nums[j + 1]){\\n                    continue;\\n                }\\n                for(int k = j + 1; k < nums.length; ++k){\\n                    if(nums[k] >= nums[j] || nums[k] <= nums[i]){\\n                        continue;\\n                    }\\n                    return true;\\n                }\\n                \\n                i = j;\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n}\\n```\\n***APROACH 2 : USING STACK***\\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        if(n < 3){\\n            return false;\\n        }\\n        int[] mins = new int[n];\\n        // make list of mins at num index\\n        mins[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            mins[i] = Math.min(mins[i-1],nums[i]);\\n        }\\n        Stack<Integer> stack = new Stack<>(); // keep track of potential k\\'s in decreasing order\\n        for(int i=n-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(nums[i]);\\n            };\\n            while(!stack.isEmpty() && stack.peek() <= mins[i]){ // while potential k is smaller than i\\n                stack.pop();\\n            }\\n            if(stack.isEmpty()){ // no more potential k\\'s\\n                stack.push(nums[i]);\\n                continue;\\n            }\\n            if(stack.peek() >= nums[i]){ // bigger than j\\n                stack.push(nums[i]);\\n            }else if(stack.peek() > mins[i]){ // between i and j\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n***APROACH 3: GREEDY {WITHOUT STACK}***\\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        int[] rmax = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            rmax[i] = i + 1 < nums.length ? Math.max(rmax[i + 1], nums[i]) : nums[i];\\n        }\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (min > nums[i - 2] && (rmax[i] <= min || nums[i - 1] >= max)) {\\n                min = nums[i - 2];\\n                max = nums[i - 1];\\n            } else {\\n\\t\\t\\t\\tmax = Math.max(nums[i - 1], max);\\n\\t\\t\\t}\\n            if (min < nums[i] && nums[i] < max) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        for(int i = 0; i < nums.length - 2; ++i){\\n            if(nums[i] >= nums[i + 1]){\\n                continue;\\n            }\\n            for(int j = i + 1; j < nums.length - 1; ++j){\\n                if(nums[j] <= nums[j + 1]){\\n                    continue;\\n                }\\n                for(int k = j + 1; k < nums.length; ++k){\\n                    if(nums[k] >= nums[j] || nums[k] <= nums[i]){\\n                        continue;\\n                    }\\n                    return true;\\n                }\\n                \\n                i = j;\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        if(n < 3){\\n            return false;\\n        }\\n        int[] mins = new int[n];\\n        // make list of mins at num index\\n        mins[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            mins[i] = Math.min(mins[i-1],nums[i]);\\n        }\\n        Stack<Integer> stack = new Stack<>(); // keep track of potential k\\'s in decreasing order\\n        for(int i=n-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(nums[i]);\\n            };\\n            while(!stack.isEmpty() && stack.peek() <= mins[i]){ // while potential k is smaller than i\\n                stack.pop();\\n            }\\n            if(stack.isEmpty()){ // no more potential k\\'s\\n                stack.push(nums[i]);\\n                continue;\\n            }\\n            if(stack.peek() >= nums[i]){ // bigger than j\\n                stack.push(nums[i]);\\n            }else if(stack.peek() > mins[i]){ // between i and j\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        int[] rmax = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            rmax[i] = i + 1 < nums.length ? Math.max(rmax[i + 1], nums[i]) : nums[i];\\n        }\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (min > nums[i - 2] && (rmax[i] <= min || nums[i - 1] >= max)) {\\n                min = nums[i - 2];\\n                max = nums[i - 1];\\n            } else {\\n\\t\\t\\t\\tmax = Math.max(nums[i - 1], max);\\n\\t\\t\\t}\\n            if (min < nums[i] && nums[i] < max) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525914,
                "title": "java-count-from-end-and-use-max-stack",
                "content": "1, count from n-1 to 0;\\n2, use mid to store the mid value;\\n3, maintain a max stack to find the max mid.\\n4, find any next num that is lower than mid\\n```\\npublic boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int mid = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < mid) return true;\\n            while (!st.isEmpty() && nums[i] > st.peek()) {\\n                mid = st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int mid = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < mid) return true;\\n            while (!st.isEmpty() && nums[i] > st.peek()) {\\n                mid = st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94090,
                "title": "python-o-n-solution-using-stack",
                "content": "Scan `nums` only once. The `stack` maintains a list of disjoint intervals (except the end point)  where the lower  and upper bound of each interval denote the minimum and maximum in the '132' pattern respectively. Thus any subsequent number which is strictly contained in any intervals in the `stack` will form a '132' pattern.\\n The order of intervals in the `stack` are maintained in a way such that if the right end of interval `A`  is less than or equal to the left end of interval `B`, then `A` is above `B` in the `stack`. The time complexity is O(N), since each number will at most be pushed and popped once. \\n```\\n    def find132pattern(self, nums):\\n        if len(set(nums)) < 3:\\n            return False\\n        stack = [[nums[0], nums[0]]]\\n        current_min = nums[0]\\n        for i in range(1, len(nums)):\\n            curr = nums[i]\\n            if curr >= stack[0][1]:  # curr >= max(nums[:i])\\n                stack = [[current_min, curr]]\\n            elif curr < current_min:  # curr < min(nums[:i])\\n                stack.append([curr, curr])\\n                current_min = curr\\n            elif curr == current_min:\\n                continue\\n            else:\\n                while stack and curr > stack[-1][0]:\\n                    if curr < stack[-1][1]:\\n                        return True\\n                    else:\\n                        stack.pop()\\n                stack.append([current_min, curr])\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def find132pattern(self, nums):\\n        if len(set(nums)) < 3:\\n            return False\\n        stack = [[nums[0], nums[0]]]\\n        current_min = nums[0]\\n        for i in range(1, len(nums)):\\n            curr = nums[i]\\n            if curr >= stack[0][1]:  # curr >= max(nums[:i])\\n                stack = [[current_min, curr]]\\n            elif curr < current_min:  # curr < min(nums[:i])\\n                stack.append([curr, curr])\\n                current_min = curr\\n            elif curr == current_min:\\n                continue\\n            else:\\n                while stack and curr > stack[-1][0]:\\n                    if curr < stack[-1][1]:\\n                        return True\\n                    else:\\n                        stack.pop()\\n                stack.append([current_min, curr])\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3686808,
                "title": "python-3-strictly-monotonic-decreasing-stack-not-reversed",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack, minVal = [], float(\\'inf\\')\\n\\n        for n in nums:\\n            while stack and stack[-1][0] <= n:\\n                stack.pop()\\n\\n            if stack and stack[-1][1] < n:\\n                return True\\n            \\n            minVal = min(minVal, n)\\n            stack.append([n, minVal])\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack, minVal = [], float(\\'inf\\')\\n\\n        for n in nums:\\n            while stack and stack[-1][0] <= n:\\n                stack.pop()\\n\\n            if stack and stack[-1][1] < n:\\n                return True\\n            \\n            minVal = min(minVal, n)\\n            stack.append([n, minVal])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466905,
                "title": "java-o-n-2-solution-o-n-solution-easy-to-understand",
                "content": "O(n^2) Solution\\n```\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) {\\n         if(nums.length < 3)\\n            return false;\\n        \\n         for(int i=1;i<nums.length-1;i++)\\n         {\\n             int min1 = Integer.MAX_VALUE;//min2 = Integer.MAX_VALUE;\\n             for(int j = 0;j<i;j++)\\n                min1 = Math.min(min1,nums[j]);\\n             for(int j = i+1;j<nums.length;j++)\\n             {\\n                 if(min1 < nums[j] && nums[j] < nums[i])\\n                     return true;\\n             }\\n            \\n         }\\n        \\n        return false;\\n     }\\n}\\n```\\nO(n^2 ) will fail for last test case.\\n\\nO(n) solution\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[0] = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)\\n            min[i] = Math.min(min[i-1],nums[i]);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int j=nums.length-1;j>=0;j--)\\n        {\\n            while(st.size()>0 && st.peek() <= min[j])\\n                st.pop();\\n            if(st.size() > 0 && st.peek() < nums[j])\\n                return true;\\n            st.push(nums[j]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) {\\n         if(nums.length < 3)\\n            return false;\\n        \\n         for(int i=1;i<nums.length-1;i++)\\n         {\\n             int min1 = Integer.MAX_VALUE;//min2 = Integer.MAX_VALUE;\\n             for(int j = 0;j<i;j++)\\n                min1 = Math.min(min1,nums[j]);\\n             for(int j = i+1;j<nums.length;j++)\\n             {\\n                 if(min1 < nums[j] && nums[j] < nums[i])\\n                     return true;\\n             }\\n            \\n         }\\n        \\n        return false;\\n     }\\n}\\n```\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[0] = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)\\n            min[i] = Math.min(min[i-1],nums[i]);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int j=nums.length-1;j>=0;j--)\\n        {\\n            while(st.size()>0 && st.peek() <= min[j])\\n                st.pop();\\n            if(st.size() > 0 && st.peek() < nums[j])\\n                return true;\\n            st.push(nums[j]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123741,
                "title": "c-stack-easy-with-explanation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo the Idea behind this approach is :\\n- First we gonna talk about Brute force that will be done by using three loops checking every triplet and if any triplet satisfy the condtion we gonna return true. (But --> $$O(N^3)$$\\uD83D\\uDE14)\\n- Second little better brute force that can be checking using two loops only whether  \\n    - checking frist two two elemnts through i and jth loop and third can be chekced from a map which stores elemnts one by one from back and we have to check if arr[i]<arr[j] and maps biggest elemnt >arr[i] and <arr[j] . \\n    - Or we can have a mini variable  in ith loop (i.e left hand side) and we check  arr[i]<arr[j] and arr[i]>mini beacsue mini is in front so we can do this using two loops.\\n    \\n- **Now coming to the beast O(N)**:\\n- So the idea behind that appraoch is since traversing from back will be more handy in this case so try to imagine that way . If we somehow can check what gonna be our arr[k] our work is done because then we have to only find a number less than it and our answer will be true. That is because if we take an example e.g 9 3 6 5 4 3\\n- so here traversing from back side first we will take 3 but we are not confirm if it gonna be our arr[k] , but we take so after we check if some elemnt is greater than it if yes we gonna now need only arr[i] now if our arr[k]>arr[i] we gonna return true so \\n- take 3 i.e arr[k] now 4 is greter than 3 i.e arr[j] so now 5 but want less than 3 we can\\'t find so the thing is we are not sure of selecting arr[k] , arr[j] can be biggest in array and arr[i] can smallest in array but not sure about arr[k] so we somehow have to first take and untake that after some condition so we are gonna use **stack** beacuse we can pop earlier values and focus on new .That was the idea why we will use stack\\n- So the idea is first initialze **kth with INT_MIN** then start the loop from back and check if current element is less than k return true else check in stack if st.top is lesser than curr it can be taken as arr[j] and rest all will be popped and top can be taken as k and also keep pushing the elements in stack at the end as well. Now if next elemnt is less than k return true or if not check if its bigger than st.top again pop elemnts and take kth  as st.top.\\n-  we are doing this beacuse we want the kth element  lesser than jth but enough bigger tha ith . So once an element is less than kth we will return true.\\n- Also if we observe on thing until some elemnt is not bigger than our st.top our k will not be intilaized until that\\n-  so in this way in the given example first our k is 3 then 4 then 5 then 3 will come which less than 5 so will return true .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo in Nutshell keep stack in a way that our k should be maximized and we also check if its less than some elemnt also beacsue we need the jth > kth . once out jth is going biggr n bigger we change our k gradually  with that so it should have more possiblity to be greater than ith.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& arr) {\\n        int n=arr.size();\\n        int kth=INT_MIN;\\n        stack<int>st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]<kth)return true;\\n            else {\\n                while(!st.empty() and arr[i]>st.top()){\\n                    kth=st.top();\\n                    st.pop();\\n                }\\n            }\\n            st.push(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& arr) {\\n        int n=arr.size();\\n        int kth=INT_MIN;\\n        stack<int>st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]<kth)return true;\\n            else {\\n                while(!st.empty() and arr[i]>st.top()){\\n                    kth=st.top();\\n                    st.pop();\\n                }\\n            }\\n            st.push(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015333,
                "title": "o-n-3-o-n-2-o-n-how-to-solve-a-problem-step-by-step-one-pass",
                "content": "\\n\\n\\n**1st and 2nd solution gives TLE\\nthis sol gives idea how to solve a problem o(n^3)-->o(n^2)\\nTime Complexity :- BigO(N^3)\\nSpace Complexity :- BigO(1)**\\n```\\n\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(nums[k]<nums[j] && nums[k]>nums[i])return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n2nd solution\\n\\nTime Complexity :- BigO(N^2)\\n\\nSpace Complexity :- BigO(1)\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int m=nums[0];\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int k=j+1;k<n;k++)\\n            {\\n                if(nums[k]>m && nums[j]>nums[k])return true;\\n                m=min(m,nums[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\nsol 3\\n\\n.firstly take a stack st.\\n.than we add a new number  \\nfirstly we pop out all the number that are small that number \\nin this way last elemnt pop than become s3 \\n. we find maximum  s3(recently poped number)\\n\\n Time Complexity :- BigO(N)\\nSpace Complexity :- BigO(N)\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(nums[k]<nums[j] && nums[k]>nums[i])return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int m=nums[0];\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int k=j+1;k<n;k++)\\n            {\\n                if(nums[k]>m && nums[j]>nums[k])return true;\\n                m=min(m,nums[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718263,
                "title": "c-solution-with-complete-explanation",
                "content": "This question is variation of the question NEXT GREATEST ELEMENT, So the first intuition comes to optimize it is using stack somehow in our solution.\\n\\n \\n\\nIs it possible to find three indexes, i,j,k where i<j<k and arr[i]<arr[k] and arr[k]<arr[j], if there exist the conditions return true or false.\\n\\n \\n\\nNow, how we approach this question, I presume you\\'re familiar with NEXT GREATEST INTEGER/ELEMENT, if not, I strongly suggest you to go and do it first before proceeding with this question since it will be a lot easier to understand then. Before we go to stack, let\\'s have a vector which will store our minimums on the left side of each and every index, WHY??. We will use this information, in our stack and we are marking that at every index i, the minimum calculated will be referred to as building 1 or i. \\n\\n \\n\\nNow after we have our vector ready of all minimums to the left, we will now create a stack and proceed forward with the algorithm, Here I\\'ll show how the calculation of minimum vector has saved us for all chaos.\\n\\n \\n\\nNow, you have created a vector, now we will iterate on original array from the back, WHY?? Because iterating from back will help us be sure that every iterative element will the 2rd building  or the j index building, Now we will have 2 conditions that this index must SATISFY,\\n\\n \\n\\nIF THE VECTOR WHICH HOLDS ALL MINIMUM SHOULD HAVE THIS Min(INDEX VALUE) \\u2265 STACK TOP, well this pretty my signifies that the 1st building i.e. the i-th building height is greater than K-th building or the 3rd building, because top will always consist of last element and hence 3rd building  . Remember I told you while calculating minimum we will use it, If this is the case its invalid, since according to question we need to have 3rd building or the k-th building larger than the 1st building or the i-th building, so we pop element from this stack till the condition becomes invalid\\nAfter we come out of while loop, we either have exhausted our stack which means this is not an answer so we continue iterating in the array, and if the stack is not empty check if the min[index]<arr[i] (it means building i < building j , which is true and check if arr[i]>s.top() , which means building j is greater than building k. If these all conditions satisfy return true,\\nElse run the iteration till index 0 and if true answer is still not returned return false.\\n \\n\\nMathematically, what we did here:-\\n\\n \\n\\nAssuming  three indexes for \\n\\ni=Building 1 , j=Building 2 and k=Building 3,\\n\\nAccording to Question,\\n\\n indexes should be in increasing order and hence\\n\\n                       i<j<k \\n\\nand their values should be  satisfying\\n\\n                  |i|<|k|   &&  |j|>|k|\\n\\nHence we can say that j is greatest of all, i,e,\\n\\n                             |i|<|k|<|j|\\n\\t\\t\\t\\t\\t\\t\\t \\n``\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini[n];\\n        mini[0]=nums[0];\\n        \\n        for(int i = 1; i<n ; i++){\\n            mini[i] = min(mini[i-1],nums[i]); \\n        }\\n        stack<int> st;\\n        for(int j = n-1 ; j>=0 ; j--){\\n            if(nums[j]>mini[j]){\\n                while(!st.empty() && st.top()<=mini[j])\\n                    st.pop();\\n                \\n                if(!st.empty() && st.top()<nums[j])\\n                    return true;\\n                st.push(nums[j]);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini[n];\\n        mini[0]=nums[0];\\n        \\n        for(int i = 1; i<n ; i++){\\n            mini[i] = min(mini[i-1],nums[i]); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2387128,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 2 ms, faster than 98.34% of Java online submissions for 132 Pattern.\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min = Integer.MIN_VALUE;\\n        int peak = nums.length;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            // We find a \"132\" pattern if nums[i] < min, so return true...\\n            if (nums[i] < min)\\n                return true;\\n            // If peak < nums.length & nums[i] is greater than the peak element...\\n            while (peak < nums.length && nums[i] > nums[peak])\\n                min = nums[peak++];\\n            // Now we have nums[i] <= nums[peak]\\n            // We push nums[i] to the \"stack\"            \\n            peak--;\\n            nums[peak] = nums[i];\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# **C++ Solution (Using Stack):**\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        // Initialise a empty stack \"s\"...\\n        stack<int> s;\\n        // To keep track of minimum element...\\n        int min = INT_MIN;\\n        // Run a Loop from last to first index...\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            // If min is greater than nums[i], return true...\\n            if (nums[i] < min)\\n                return true;\\n            // If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            while (!s.empty() && nums[i] > s.top()) {\\n                min = s.top();\\n                s.pop();\\n            }\\n            // Otherwise, push nums[i] into stack...\\n            s.push(nums[i]);\\n        }\\n        // If the condition is not satisfied, return false.\\n        return false;\\n    }\\n};\\n```\\n\\n# **Python Solution (Using Stack):**\\n```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        # Base Condition...\\n        if len(nums) < 3:\\n            return False\\n        m = float(\\'-inf\\')\\n        # Initialise a empty stack...\\n        stack = []\\n        # Run a Loop from last to first index...\\n        for i in range(len(nums)-1, -1, -1):\\n            # If m is greater than nums[i], return true...\\n            if nums[i] < m:\\n                return True\\n            # If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    m = stack.pop()\\n            # Otherwise, append nums[i] into stack...\\n            stack.append(nums[i])\\n        # If the condition is not satisfied, return false.\\n        return False\\n```\\n        \\n# **JavaScript Solution (Using Stack):**\\n```\\nvar find132pattern = function(nums) {\\n    let m = -Infinity\\n    // Initialise a empty stack...\\n    const stack = []\\n    // Run a Loop from last to first index...\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        // If nums[i] is greater than the top element of stack, then pop the element...\\n        while (nums[i] > stack[stack.length - 1]) {\\n            m = stack.pop()\\n        }\\n        // If m is greater than nums[i], return true...\\n        if (nums[i] < m) {\\n            return true\\n        }\\n        // Otherwise, push nums[i] into stack...\\n        stack.push(nums[i])\\n    }\\n    // If the condition is not satisfied, return false.\\n    return false\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool find132pattern(int* nums, int numsSize){\\n    int peak = numsSize, min = INT_MIN;\\n    for (int i = numsSize - 1; i > -1; i--) {\\n        if (nums[i] < min)\\n            return true;\\n        while (peak < numsSize && nums[i] > nums[peak]) {\\n            min = nums[peak];\\n            peak++;\\n        }\\n        peak--;\\n        nums[peak] = nums[i];\\n    }\\n    return false;\\n}\\n```\\n\\n# **Python3 Solution (Using Stack):**\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        # Base Condition...\\n        if len(nums) < 3:\\n            return False\\n        # To keep track of minimum element...\\n        mini = float(\\'-inf\\')\\n        # Initialise a empty stack...\\n        stack = []\\n        # Run a Loop from last to first index...\\n        for i in range(len(nums)-1, -1, -1):\\n            # If min is greater than nums[i], return true...\\n            if nums[i] < mini:\\n                return True\\n            # If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    mini = stack.pop()\\n            # Otherwise, append nums[i] into stack...\\n            stack.append(nums[i])\\n        # If the condition is not satisfied, return false.\\n        return False\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min = Integer.MIN_VALUE;\\n        int peak = nums.length;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            // We find a \"132\" pattern if nums[i] < min, so return true...\\n            if (nums[i] < min)\\n                return true;\\n            // If peak < nums.length & nums[i] is greater than the peak element...\\n            while (peak < nums.length && nums[i] > nums[peak])\\n                min = nums[peak++];\\n            // Now we have nums[i] <= nums[peak]\\n            // We push nums[i] to the \"stack\"            \\n            peak--;\\n            nums[peak] = nums[i];\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        // Initialise a empty stack \"s\"...\\n        stack<int> s;\\n        // To keep track of minimum element...\\n        int min = INT_MIN;\\n        // Run a Loop from last to first index...\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            // If min is greater than nums[i], return true...\\n            if (nums[i] < min)\\n                return true;\\n            // If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            while (!s.empty() && nums[i] > s.top()) {\\n                min = s.top();\\n                s.pop();\\n            }\\n            // Otherwise, push nums[i] into stack...\\n            s.push(nums[i]);\\n        }\\n        // If the condition is not satisfied, return false.\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        # Base Condition...\\n        if len(nums) < 3:\\n            return False\\n        m = float(\\'-inf\\')\\n        # Initialise a empty stack...\\n        stack = []\\n        # Run a Loop from last to first index...\\n        for i in range(len(nums)-1, -1, -1):\\n            # If m is greater than nums[i], return true...\\n            if nums[i] < m:\\n                return True\\n            # If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    m = stack.pop()\\n            # Otherwise, append nums[i] into stack...\\n            stack.append(nums[i])\\n        # If the condition is not satisfied, return false.\\n        return False\\n```\n```\\nvar find132pattern = function(nums) {\\n    let m = -Infinity\\n    // Initialise a empty stack...\\n    const stack = []\\n    // Run a Loop from last to first index...\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        // If nums[i] is greater than the top element of stack, then pop the element...\\n        while (nums[i] > stack[stack.length - 1]) {\\n            m = stack.pop()\\n        }\\n        // If m is greater than nums[i], return true...\\n        if (nums[i] < m) {\\n            return true\\n        }\\n        // Otherwise, push nums[i] into stack...\\n        stack.push(nums[i])\\n    }\\n    // If the condition is not satisfied, return false.\\n    return false\\n};\\n```\n```\\nbool find132pattern(int* nums, int numsSize){\\n    int peak = numsSize, min = INT_MIN;\\n    for (int i = numsSize - 1; i > -1; i--) {\\n        if (nums[i] < min)\\n            return true;\\n        while (peak < numsSize && nums[i] > nums[peak]) {\\n            min = nums[peak];\\n            peak++;\\n        }\\n        peak--;\\n        nums[peak] = nums[i];\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        # Base Condition...\\n        if len(nums) < 3:\\n            return False\\n        # To keep track of minimum element...\\n        mini = float(\\'-inf\\')\\n        # Initialise a empty stack...\\n        stack = []\\n        # Run a Loop from last to first index...\\n        for i in range(len(nums)-1, -1, -1):\\n            # If min is greater than nums[i], return true...\\n            if nums[i] < mini:\\n                return True\\n            # If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    mini = stack.pop()\\n            # Otherwise, append nums[i] into stack...\\n            stack.append(nums[i])\\n        # If the condition is not satisfied, return false.\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016943,
                "title": "o-n-2-o-nlogn-thinking-solution-with-comments",
                "content": "**Please note in this post i have covered thought process for building a solution in 30 minutes, I could not reach O(N) in 30 minutes and feel free to ignore this post incase you are interested in best solution for this problem. This is only for helping someone who is stuck building thought process**\\n\\n\\n**Solution1**\\n*Thought process*\\n1. Lets suppose we traverse the array taking one element at a time. The element we are on says, I am the greatest element among three elements we have to find i.e. I am j.\\n2. Now for saying that this element is greatest among 3 we have to select. There should be atleast one element smaller than this in left. This gave me a idea while I am traversing array I will keep track of what was minimum so far. Keeping track of minimum so far is not a big deal I will maintain one minElement so far. This minElement can be our ith element.\\n3. Now we know we got i and j. For k we will go to every element in right of j and find one element which is greater than minElement we have so far and less than current element i.e. nums[j]\\n4. If we found any such element in right. Congratulations we reached the solution and return true. If we didn\\'t got any k in right for sure this element can not be j.\\n5. In the end if we dont find any possible j. Return false.\\n\\n````\\nint minElement=nums[0]\\nfor(int j=1;j<nums.size()-1;j++){ \\n//why nums.size()-1 I am j. There should be k in right so j cannot be last atleast. Definitely going till last element -1 makes sense and going till end doesn\\'t\\n\\tfor(int k=j+1;k<nums.size();k++){\\n\\t   if(nums[k]>minElement && nums[k]<nums[j]){\\n\\t\\t return true;\\n      }\\n   }\\n   minElement=min(minElement, nums[j]);\\n}\\nreturn false;\\n````\\n\\n**Time Complexity** O(N^2)\\n**Space Complexity** O(1)\\n\\n\\nCan we do something better in above apporach ?\\nThink for a while. \\n\\nIf you are not able to think, take this hint and think again.\\nHint: The only part bothering us is for every j we have to check every element in its right hand side which is greater than minElement so far i.e. our ith element and smaller than jth element i.e. current element in loop.\\n\\n\\nWhat if we maintain list of all elements after j in sorted order, and then search for lower_bound of minElement+1. If the element we got is less than element at jth index. Yay we got the solution.  We can acheive this with set definitely. \\n\\nWhy search for lower_bound(minElement+1)?\\nBecuase among all the elements present after j. We have to find an element just greater than minElement so far. It is therefore minElement+1. Now the lowerBound we got there can be two scenarios:\\na. Lower bound we got is the element which is greater than nums[j]. We are not interested in it then.\\nb. Lower bound we got is the element which is less than nums[j]. We are interested. Why?? Because its what we wanted. We got a pair.\\n\\n\\nBased on above intution only i tried submitting my code it again gave me TLE and errors as well since i used Set to maintain sorted list. Set contains unique element where as there can be duplicate elements as well.\\n\\nMy solution\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int sz=nums.size();\\n        if(sz<3){\\n            return false;\\n        }\\n        \\n        int minFront = nums[0];\\n        map<int, int> numToHash; // I am using this map to keep track of number of occurrenes of elements\\n        set<int> back; // A set which contains all the elements after j\\n        for(int j=sz-1;j>=2;j--){\\n            back.insert(nums[j]);\\n            numToHash[nums[j]]++;\\n        }        \\n        \\n        \\n        for(int j=1;j<sz-1;j++){\\n            set<int>::iterator it = lower_bound(back.begin(), back.end(), minFront+1);\\n            if(it!=back.end() && nums[j]>minFront && *it>minFront && nums[j]>*it){\\n                return true;\\n            }\\n            minFront=min(minFront, nums[j]);\\n            numToHash[nums[j+1]]--;\\n            if(numToHash[nums[j+1]]==0){\\n\\t\\t\\t//Remember set contains all elements which are after j in sorted order ...\\n\\t\\t\\t//so when we move forward remove the next element as after moving it became jth element. Whereas we have to keep track of elements after j.\\n                back.erase(nums[j+1]);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n\\nBased on same intution instead of set now i used min heap. Since set alone is not possible as there can be duplicates as well. \\nUsing min heap it got submitted. Not writing the complete answer again using min heap, Intution is same.\\n\\nCode\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int sz=nums.size();\\n        if(sz<3){\\n            return false;\\n        }\\n        \\n        int minFront[sz];//Keeps track of minimum element so far starting from 0\\n        int minimum=nums[0];\\n        for(int i=1;i<sz;i++){\\n            minFront[i]=minimum;\\n            minimum=min(minimum, nums[i]);\\n        }\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        pq.push(nums[sz-1]);\\n        \\n        for(int i=sz-2;i>=1;i--){\\n            while(pq.size() && pq.top()<=minFront[i]){\\n                pq.pop();\\n            }\\n            \\n            if(pq.size() && pq.top()<nums[i]){\\n                return true;\\n            }else{\\n                pq.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Time Complexity** O(NLogN)\\n**Space Complexity** O(N) \\n\\nI completely understand priority queue solution is not explained. See based on above intuition now if you can approach the problem in NlogN. \\n\\n*Remember the motive of this post was just to explain how to build thought process. Please upvote in case you find my thought process useful, It motivates me.*",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "````\\nint minElement=nums[0]\\nfor(int j=1;j<nums.size()-1;j++){ \\n//why nums.size()-1 I am j. There should be k in right so j cannot be last atleast. Definitely going till last element -1 makes sense and going till end doesn\\'t\\n\\tfor(int k=j+1;k<nums.size();k++){\\n\\t   if(nums[k]>minElement && nums[k]<nums[j]){\\n\\t\\t return true;\\n      }\\n   }\\n   minElement=min(minElement, nums[j]);\\n}\\nreturn false;\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int sz=nums.size();\\n        if(sz<3){\\n            return false;\\n        }\\n        \\n        int minFront = nums[0];\\n        map<int, int> numToHash; // I am using this map to keep track of number of occurrenes of elements\\n        set<int> back; // A set which contains all the elements after j\\n        for(int j=sz-1;j>=2;j--){\\n            back.insert(nums[j]);\\n            numToHash[nums[j]]++;\\n        }        \\n        \\n        \\n        for(int j=1;j<sz-1;j++){\\n            set<int>::iterator it = lower_bound(back.begin(), back.end(), minFront+1);\\n            if(it!=back.end() && nums[j]>minFront && *it>minFront && nums[j]>*it){\\n                return true;\\n            }\\n            minFront=min(minFront, nums[j]);\\n            numToHash[nums[j+1]]--;\\n            if(numToHash[nums[j+1]]==0){\\n\\t\\t\\t//Remember set contains all elements which are after j in sorted order ...\\n\\t\\t\\t//so when we move forward remove the next element as after moving it became jth element. Whereas we have to keep track of elements after j.\\n                back.erase(nums[j+1]);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int sz=nums.size();\\n        if(sz<3){\\n            return false;\\n        }\\n        \\n        int minFront[sz];//Keeps track of minimum element so far starting from 0\\n        int minimum=nums[0];\\n        for(int i=1;i<sz;i++){\\n            minFront[i]=minimum;\\n            minimum=min(minimum, nums[i]);\\n        }\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        pq.push(nums[sz-1]);\\n        \\n        for(int i=sz-2;i>=1;i--){\\n            while(pq.size() && pq.top()<=minFront[i]){\\n                pq.pop();\\n            }\\n            \\n            if(pq.size() && pq.top()<nums[i]){\\n                return true;\\n            }else{\\n                pq.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534094,
                "title": "python-3-stack-o-n",
                "content": "The num which is larger than the `third` and before `third` is stored in the \\'`stack`\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        stack, third = [], float(\\'-inf\\')\\n        for i in range(n-1,-1,-1):\\n            if nums[i]< third: return True\\n            while stack and nums[i]>stack[-1]:\\n                third = stack.pop()\\n            stack.append(nums[i])\\n        return False\\n            \\n```\\n\\n\\n***\\nCheck on my [repo](https://github.com/zengtian006/LeetCode) to get Leetcode solution(Python) with classification: https://github.com/zengtian006/LeetCode\\n***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        stack, third = [], float(\\'-inf\\')\\n        for i in range(n-1,-1,-1):\\n            if nums[i]< third: return True\\n            while stack and nums[i]>stack[-1]:\\n                third = stack.pop()\\n            stack.append(nums[i])\\n        return False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 94092,
                "title": "c-o-n-greedy-solution-using-stack",
                "content": "Since, it is 132 pattern. The smallest of the three is in front of the other two. We'd better scan from back to front. In this way, we can maintain a pair of biggest numbers (S3 and S2) and looking for S1 which is smaller than S2 (S1 < S2). Otherwise, we pop numbers in stack and update S2 accordingly.\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int s2 = INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < s2)\\n                return true;\\n            \\n            while (!stk.empty() && stk.top() < nums[i]) {\\n                s2 = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int s2 = INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < s2)\\n                return true;\\n            \\n            while (!stk.empty() && stk.top() < nums[i]) {\\n                s2 = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044567,
                "title": "c-intuitive-solution-with-stack-explained",
                "content": "This was a really good question. It can be solved using brute force but even its **brute force** would be difficult. As we have to find two numbers, one in left, another in right and with the condition that k>j and i>k>j. To achieve this, we will have to run three nested loops taking the complexity to **O(N^3)**\\nInstead, a little knowledge of stack, more specifically monotonic stack, would help a lot in this problem. In case you don\\'t know what a monotonic stack is, please watch *[this video](https://www.youtube.com/watch?v=j313ttNJjo0)*. He has explained it beautifully. To practice a few questions, please solve *[this](https://leetcode.com/problems/daily-temperatures/)*\\n\\nAfter you have a sufficient amount of knowlede of monotonic stacks, you can have some intuition of this problem too. \\nLets first see what this question demands. It want us to find three numbers, let\\'s name them `i, j, k`, such that` j>k>i`. \\nTo achieve that, we can maintain a ***monotonically decreasing*** stack. \\n***Why decreasing?*** Well, if we will have a decreasing stack, we would have two numbers,` j` and `k`, and our task will reduce to finding an `i` such that `i<k<j,` and its in the left of `j`. Our stack will always ensure that `j>k` and `k` is in the right of `j. `\\nTo find a suitable `i`, what we can do is we can have a **prefix array, that stores the minimum element on the left so far**. Now having that data with us, in each iteration, we can now check if our stack has some elements, and if it does, we check if the prefix (`minimum_so_far`) element is smaller than stack top, ie `k`. If we get that, we return `true`.\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack <pair<int,int>> st;\\n        vector<int> prefix(nums.size(), INT_MAX);\\n\\n        int mini = INT_MAX;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            prefix[i] = mini;\\n            mini = min(mini, nums[i]);    \\n        }\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            if(st.empty()) st.push({nums[i],i});\\n            else{\\n                while(!st.empty() and nums[i]>=st.top().first) st.pop();\\n\\n                if(!st.empty() and prefix[st.top().second]<nums[i]) return true;\\n                \\n                st.push({nums[i],i});\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack <pair<int,int>> st;\\n        vector<int> prefix(nums.size(), INT_MAX);\\n\\n        int mini = INT_MAX;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            prefix[i] = mini;\\n            mini = min(mini, nums[i]);    \\n        }\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            if(st.empty()) st.push({nums[i],i});\\n            else{\\n                while(!st.empty() and nums[i]>=st.top().first) st.pop();\\n\\n                if(!st.empty() and prefix[st.top().second]<nums[i]) return true;\\n                \\n                st.push({nums[i],i});\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016584,
                "title": "java-stack-sollution-o-n-space-and-time-with-required-explanation",
                "content": "Algorithm:\\n\\n* Create a stack and initialize a variable second with Integer.MIN_VALUE value.\\n* Start traversing from the right to left of teh array to maintain the Next greater Element like stack.\\n* Check if the current number is lesser than second. If it is, then it means our 132 pattern is satisfied as the stack is taking care of the 32 pattern and the current number satisfies the entire pattern. So return true.\\n* If the above is not true, update the top/peak value of the stack. Pop the element from the stack until stack becoms empty OR current element less then top/peek value.\\n* Push the current number into the stack.(To maintain the highest number in stack like from \"132\", \"3\" remains in stack)\\n* If the loop ends, it means that the pattern was not found in the array. So, return false.\\n\\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        //length of the array.\\n        int n = nums.length;\\n        //stack to maintain \"3 2\" pattern from \"1 3 2\"\\n        Stack<Integer> st = new Stack<>();\\n        //second represent second highest number i.e, 2 from \"1 3 2\"\\n        int second = Integer.MIN_VALUE;\\n        \\n        //Now, we are finding 1 as nums[i], stack will contain pattern 32 and we havee to find nums[i] which is less then second so it will also less then st.peek()\\n        for(int i = n-1; i >= 0; i--){\\n            if(nums[i] < second)\\n                return true;\\n            while(!st.isEmpty() && nums[i] > st.peek()){\\n                second = st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nUpvote if you like it ;)",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        //length of the array.\\n        int n = nums.length;\\n        //stack to maintain \"3 2\" pattern from \"1 3 2\"\\n        Stack<Integer> st = new Stack<>();\\n        //second represent second highest number i.e, 2 from \"1 3 2\"\\n        int second = Integer.MIN_VALUE;\\n        \\n        //Now, we are finding 1 as nums[i], stack will contain pattern 32 and we havee to find nums[i] which is less then second so it will also less then st.peek()\\n        for(int i = n-1; i >= 0; i--){\\n            if(nums[i] < second)\\n                return true;\\n            while(!st.isEmpty() && nums[i] > st.peek()){\\n                second = st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277353,
                "title": "456-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an empty stack and a variable s3 initialized to negative infinity.\\n2. Traverse the input array nums from right to left using a loop:\\na. If the current element nums[i] is less than s3, return True as the 132 pattern exists.\\nb. While the stack is not empty and the top element of the stack is less than nums[i], pop the top element from the stack and set it as s3.\\nc. Push the current element nums[i] onto the stack.\\n3. If the loop completes without finding a 132 pattern, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        s3 = float(\\'-inf\\')\\n        \\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] < s3:\\n                return True\\n            while stack and stack[-1] < nums[i]:\\n                s3 = stack.pop()\\n            stack.append(nums[i])\\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        s3 = float(\\'-inf\\')\\n        \\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] < s3:\\n                return True\\n            while stack and stack[-1] < nums[i]:\\n                s3 = stack.pop()\\n            stack.append(nums[i])\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445517,
                "title": "javascript-solution-w-explanation-stack",
                "content": "### The idea\\n1. Iterate left to right to find N1 candidates (the smallest #)\\n2. Create a stack for N2 candidates, the top number will be the smallest potential N2\\n3. Iterate the array from the right for N3\\n4. For N2 stack, \\n\\t`pop` candidates that are smaller than N1\\n\\t`push` candidates that greater than N1 & smaller than the smallest N2 candidate\\n5. Notice that the reason we can ensure the N2 stack is sorted such that the top value will always be smallest is because we are only pushing in values that is smaller than the smallest N2 value. A smallest N2 possible gives us the best possibility of forming a 132 pattern. If given the smallest N2, we still can\\'t find a 132 pattern, that means we have another smaller N2 candidate.\\n*Hope my explanation worked out for you, leave comments if not. \\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n    // sanity check\\n    if (nums.length < 3) return false;\\n\\n    let N2 = []; // potential candidates, number 2\\n    let N1 = [nums[0]]; // the smallest number, number 3\\n\\n    for (let i=1;i<nums.length;i++) { \\n        N1.push(Math.min(N1[N1.length-1], nums[i]));\\n    }\\n\\n    for (let i=nums.length-1;i>=0;i--) { // number 3\\n        if (nums[i] > N1[i]) {\\n            // remove useless N2 candidates\\n            while (N2.length!=0 && N2[N2.length-1] <= N1[i]) N2.pop();\\n            // found a pattern\\n            if (N2.length!=0 && N2[N2.length-1] < nums[i]) return true;\\n            N2.push(nums[i]);\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n    // sanity check\\n    if (nums.length < 3) return false;\\n\\n    let N2 = []; // potential candidates, number 2\\n    let N1 = [nums[0]]; // the smallest number, number 3\\n\\n    for (let i=1;i<nums.length;i++) { \\n        N1.push(Math.min(N1[N1.length-1], nums[i]));\\n    }\\n\\n    for (let i=nums.length-1;i>=0;i--) { // number 3\\n        if (nums[i] > N1[i]) {\\n            // remove useless N2 candidates\\n            while (N2.length!=0 && N2[N2.length-1] <= N1[i]) N2.pop();\\n            // found a pattern\\n            if (N2.length!=0 && N2[N2.length-1] < nums[i]) return true;\\n            N2.push(nums[i]);\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94086,
                "title": "python-solution-in-o-nlogn",
                "content": "I tried multiple O(n^2) solutions and it seems only O(nlogn) is accepted for Python.\\n\\nFirst we make the ```left``` list that maintains the min value up to index ```i```. \\nThen we make the ```right``` list backward that maintains the smallest number that is larger than ```left[i]``` up to ```i``` using a heap.\\nFinally we iterate through ```nums``` and check if ```left[i] < right[i] < num```.\\n\\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums:\\n            return False\\n        left = [nums[0]]\\n        for num in nums[1:]:\\n            left.append(min(left[-1], num))\\n        q = []\\n        right = [None] * len(nums)\\n        for i, num in enumerate(nums[::-1]):\\n            heapq.heappush(q, num)\\n            while q and q[0] <= left[len(nums) - i - 1]:\\n                heapq.heappop(q)\\n            if q:\\n                right[len(nums) - i - 1] = q[0]\\n        for i, num in enumerate(nums):\\n            if right and left[i] < right[i] < num:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```left```\n```i```\n```right```\n```left[i]```\n```i```\n```nums```\n```left[i] < right[i] < num```\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums:\\n            return False\\n        left = [nums[0]]\\n        for num in nums[1:]:\\n            left.append(min(left[-1], num))\\n        q = []\\n        right = [None] * len(nums)\\n        for i, num in enumerate(nums[::-1]):\\n            heapq.heappush(q, num)\\n            while q and q[0] <= left[len(nums) - i - 1]:\\n                heapq.heappop(q)\\n            if q:\\n                right[len(nums) - i - 1] = q[0]\\n        for i, num in enumerate(nums):\\n            if right and left[i] < right[i] < num:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016703,
                "title": "c-o-n-time-best-optimized-approach-using-stack",
                "content": "****upvote if you find it helpfull and easy****\\n\\n\\t\\tstack<int> st;\\n        int second = INT_MIN;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if(nums[i]<second) return true; // this will tell if c<a \\n            while(!st.empty() && nums[i]>st.top()){  // this while loop will tell wheater a>b; then about condition will return true;\\n                second = st.top(), st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "****upvote if you find it helpfull and easy****\\n\\n\\t\\tstack<int> st;\\n        int second = INT_MIN;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if(nums[i]<second) return true; // this will tell if c<a \\n            while(!st.empty() && nums[i]>st.top()){  // this while loop will tell wheater a>b; then about condition will return true;\\n                second = st.top(), st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 2016302,
                "title": "c-easy-short-comments-added-daily-leetcoding-challenge-may-day-7",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        // we wre going to use stack here for solving this problem\\n        // basically we need 3 values right ? and all that threes are follwing a order\\n        // so just need to find the 3 values \\n        // in stack we are going to save previous value and the whole stack min value \\n        // and we will compare these values with the current value according to the need of question\\n        // means if our current value is between betweeen the previos and min then return true else false\\n        \\n        // creating the stack\\n        stack<pair<int,int>> st;           // (previos,min)\\n        int mn = INT_MAX;                  // it will storing the mn value\\n        \\n        // iterating over the whole given array\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // just finding the min value if our stack is not empty\\n            if(!st.empty())\\n                mn = min(mn, st.top().first);\\n            \\n            // just popping all the greater value from the current \\n            // because we need mid value between the previous and min\\n            while(!st.empty() && nums[i]>st.top().first) \\n                st.pop();\\n            \\n            // now cheking our condition nums[i] < nums[k] < nums[j] that is there pattern avaliable or not\\n            if((!st.empty()) && (st.top().second < nums[i]) && (nums[i] < st.top().first)) \\n                return true;\\n            \\n            // after each iteration just pushing the values with mn into our stack\\n            st.push({nums[i],mn});\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        // we wre going to use stack here for solving this problem\\n        // basically we need 3 values right ? and all that threes are follwing a order\\n        // so just need to find the 3 values \\n        // in stack we are going to save previous value and the whole stack min value \\n        // and we will compare these values with the current value according to the need of question\\n        // means if our current value is between betweeen the previos and min then return true else false\\n        \\n        // creating the stack\\n        stack<pair<int,int>> st;           // (previos,min)\\n        int mn = INT_MAX;                  // it will storing the mn value\\n        \\n        // iterating over the whole given array\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // just finding the min value if our stack is not empty\\n            if(!st.empty())\\n                mn = min(mn, st.top().first);\\n            \\n            // just popping all the greater value from the current \\n            // because we need mid value between the previous and min\\n            while(!st.empty() && nums[i]>st.top().first) \\n                st.pop();\\n            \\n            // now cheking our condition nums[i] < nums[k] < nums[j] that is there pattern avaliable or not\\n            if((!st.empty()) && (st.top().second < nums[i]) && (nums[i] < st.top().first)) \\n                return true;\\n            \\n            // after each iteration just pushing the values with mn into our stack\\n            st.push({nums[i],mn});\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016063,
                "title": "python-simple-effective",
                "content": "```\\n\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        num = float(\\'-inf\\')\\n        for n in nums[::-1]:\\n            if n < num:\\n                return True\\n            while stack and stack[-1] < n:\\n                num = stack.pop()\\n            stack.append(n)\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        num = float(\\'-inf\\')\\n        for n in nums[::-1]:\\n            if n < num:\\n                return True\\n            while stack and stack[-1] < n:\\n                num = stack.pop()\\n            stack.append(n)\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015991,
                "title": "c-o-n-solution-using-stack-with-line-by-line-explanation",
                "content": "The idea behind this approach is to carefully observe what is being asked in the question.\\n\\nIt is given for i < j < k\\nwe need to check if there exists arr[i] < arr[k] < arr[j]\\nNow for the k index element we need previous element greater than it and minimum element less than it\\nSo all we need to do is just maintain a stack with top element being the greatest and a minimum element\\nRest of the things are explained in the comments\\n\\n```\\nbool find132pattern(vector<int>& nums) {\\n        stack<pair<int , int>> st; //we make a stack to store elements in monotonic decreasing order and also store minimum value\\n        int currMin = nums[0]; // to store the min element \\n        for(int i=1;i<nums.size();i++) // traversing the given vector from index 1 as index 0 is already concidered in currMin \\n        {\\n            while(!st.empty() && nums[i]>=st.top().first) // keep removing all greater and equal elements \\n                st.pop();\\n            if(!st.empty() && nums[i]>st.top().second) // and if the stack still non-empty this means that our current element is less \\n\\t\\t\\t//than the top of the stack , So now we check if this element is greater than the minimum value in the stack\\n                return true; // if condition satisfies return true\\n            st.push({nums[i],currMin}); // push current element and previous minimum\\n            currMin = min(currMin,nums[i]); // update the minimum element\\n        }\\n        return false; // If the condition never became true it means we shall return false\\n    }\\n```\\n\\nIf you liked the explanation please upvote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nbool find132pattern(vector<int>& nums) {\\n        stack<pair<int , int>> st; //we make a stack to store elements in monotonic decreasing order and also store minimum value\\n        int currMin = nums[0]; // to store the min element \\n        for(int i=1;i<nums.size();i++) // traversing the given vector from index 1 as index 0 is already concidered in currMin \\n        {\\n            while(!st.empty() && nums[i]>=st.top().first) // keep removing all greater and equal elements \\n                st.pop();\\n            if(!st.empty() && nums[i]>st.top().second) // and if the stack still non-empty this means that our current element is less \\n\\t\\t\\t//than the top of the stack , So now we check if this element is greater than the minimum value in the stack\\n                return true; // if condition satisfies return true\\n            st.push({nums[i],currMin}); // push current element and previous minimum\\n            currMin = min(currMin,nums[i]); // update the minimum element\\n        }\\n        return false; // If the condition never became true it means we shall return false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505735,
                "title": "easy-c-code-using-stack",
                "content": "```\\nclass Solution {\\n    public:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if (n < 3) \\n            return false;\\n        \\n        int minn[n];\\n        minn[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            minn[i] = min(nums[i], minn[i - 1]);\\n        \\n        stack<int> s;\\n        for (int j = n - 1; j >= 0; j--) \\n        {\\n            while (!s.empty() && s.top() < nums[j]) \\n            {\\n                if (s.top() > minn[j])\\n                    return true;\\n                s.pop();\\n            }\\n            s.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if (n < 3) \\n            return false;\\n        \\n        int minn[n];\\n        minn[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            minn[i] = min(nums[i], minn[i - 1]);\\n        \\n        stack<int> s;\\n        for (int j = n - 1; j >= 0; j--) \\n        {\\n            while (!s.empty() && s.top() < nums[j]) \\n            {\\n                if (s.top() > minn[j])\\n                    return true;\\n                s.pop();\\n            }\\n            s.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418970,
                "title": "c-solution-using-ordered-set-and-binary-search-time-o-nlogn",
                "content": "Left min array is used to find whether an element to the left of nums[i] that is lesser than nums[i] exists and we use binary search to find whether an element that is greater than left_min[i] exists on the right side of nums[i]. We also check whether that element is lesser than nums[i].\\nTime Complexity : O(nlogn) Space Complexity : O(n)\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return false;\\n        set<int> st;\\n        vector<int> left_min(n+1);\\n        left_min[0] = nums[0];\\n            \\n        for(int i = 1 ; i < n ; ++i )\\n            left_min[i] = min(left_min[i-1] , nums[i]);\\n        \\n        st.insert(nums[n-1]);\\n        for(int i = n - 2 ; i >= 1 ; --i)\\n        {\\n            int mn = left_min[i-1];\\n            if(nums[i] > mn)\\n            {\\n                auto it = st.upper_bound(mn);\\n                if(it != st.end())\\n                {\\n                    if(*it < nums[i])\\n                        return true;\\n                }\\n            }\\n            st.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return false;\\n        set<int> st;\\n        vector<int> left_min(n+1);\\n        left_min[0] = nums[0];\\n            \\n        for(int i = 1 ; i < n ; ++i )\\n            left_min[i] = min(left_min[i-1] , nums[i]);\\n        \\n        st.insert(nums[n-1]);\\n        for(int i = n - 2 ; i >= 1 ; --i)\\n        {\\n            int mn = left_min[i-1];\\n            if(nums[i] > mn)\\n            {\\n                auto it = st.upper_bound(mn);\\n                if(it != st.end())\\n                {\\n                    if(*it < nums[i])\\n                        return true;\\n                }\\n            }\\n            st.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215922,
                "title": "easy-to-understand-java-code",
                "content": "This problem is based on next greater element so if you have done next greater element , code is self explanatory \\n\\nMETHOD 1 : \\n\\n```\\n\\n// i<j<k\\n//nums[i]<nums[k]<nums[j]\\n// TC : O(N)  SC : O(N)\\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n         int numsk = Integer.MIN_VALUE;\\n         Stack<Integer> st = new Stack();\\n         for(int idx = nums.length-1;idx>=0;idx--){\\n             if(nums[idx]<numsk) return true;  // nums[i] < nums[k] , and nums[j] (potential) was chosen in previous iteration so given condition reached \\n              while(!st.isEmpty()&&nums[idx]>st.peek()){//nums[idx] = nums[j] (potential) \\n                 numsk = st.pop(); // always bigger than previous numsk \\n             }\\n             st.push(nums[idx]);\\n         }\\n        return false;\\n    }\\n}\\n```\\n\\nEDIT : another easy to understand implementation with stack : \\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min[] = new int[nums.length];\\n        min[0] = nums[0];\\n        for(int i =1;i<nums.length;i++) min[i] = Math.min(min[i-1],nums[i]); // maintain minimum so far \\n        Stack<Integer> st = new Stack();\\n        for(int j = nums.length-1;j>=0;j--){\\n            while(!st.isEmpty()&&st.peek()<=min[j]) st.pop(); // st.peek() --> nums[k] , min[j] -->  possible nums[i] which should be smaller than st.peek();\\n            if(!st.isEmpty()&&st.peek()<nums[j]){ // if stack is not empty and we have exited the while loop above then that means nums[i] < nums [k] so check if nums[k] < nums[j] if yes return true \\n                return true;\\n            }\\n            st.push(nums[j]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nMETHOD 2 : \\n\\n```\\n// same concept as previous solution but use nums[] as stack\\n// TC : O(N) SC : O(1) \\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n         int numsk = Integer.MIN_VALUE;\\n         int stackIdx = nums.length;\\n         for(int idx = nums.length-1;idx>=0;idx--){\\n             if(nums[idx]<numsk) return true;\\n              while(stackIdx<nums.length&&nums[idx]>nums[stackIdx]){\\n                 numsk = nums[stackIdx];\\n                 stackIdx++;\\n             }\\n             stackIdx--;\\n             nums[stackIdx] = nums[idx];\\n         }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n// i<j<k\\n//nums[i]<nums[k]<nums[j]\\n// TC : O(N)  SC : O(N)\\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n         int numsk = Integer.MIN_VALUE;\\n         Stack<Integer> st = new Stack();\\n         for(int idx = nums.length-1;idx>=0;idx--){\\n             if(nums[idx]<numsk) return true;  // nums[i] < nums[k] , and nums[j] (potential) was chosen in previous iteration so given condition reached \\n              while(!st.isEmpty()&&nums[idx]>st.peek()){//nums[idx] = nums[j] (potential) \\n                 numsk = st.pop(); // always bigger than previous numsk \\n             }\\n             st.push(nums[idx]);\\n         }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min[] = new int[nums.length];\\n        min[0] = nums[0];\\n        for(int i =1;i<nums.length;i++) min[i] = Math.min(min[i-1],nums[i]); // maintain minimum so far \\n        Stack<Integer> st = new Stack();\\n        for(int j = nums.length-1;j>=0;j--){\\n            while(!st.isEmpty()&&st.peek()<=min[j]) st.pop(); // st.peek() --> nums[k] , min[j] -->  possible nums[i] which should be smaller than st.peek();\\n            if(!st.isEmpty()&&st.peek()<nums[j]){ // if stack is not empty and we have exited the while loop above then that means nums[i] < nums [k] so check if nums[k] < nums[j] if yes return true \\n                return true;\\n            }\\n            st.push(nums[j]);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n// same concept as previous solution but use nums[] as stack\\n// TC : O(N) SC : O(1) \\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n         int numsk = Integer.MIN_VALUE;\\n         int stackIdx = nums.length;\\n         for(int idx = nums.length-1;idx>=0;idx--){\\n             if(nums[idx]<numsk) return true;\\n              while(stackIdx<nums.length&&nums[idx]>nums[stackIdx]){\\n                 numsk = nums[stackIdx];\\n                 stackIdx++;\\n             }\\n             stackIdx--;\\n             nums[stackIdx] = nums[idx];\\n         }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016132,
                "title": "c-solve-using-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        //storing previous value and mini value available in the stack i.e. {nums[j], nums[i]}\\n        stack<pair<int, int>> st;\\n        int mini = INT_MAX; //store minimum value \\n        \\n        //iterate over nums array\\n        for(int k=0; k<nums.size(); k++)\\n        {\\n            //if stack is not empty then we find mini value present in the stack\\n            if(!st.empty())\\n                mini = min(mini, st.top().first);\\n            \\n            //till nums[k] is greater than top element of stack i.e. nums[j], we pop the element\\n            while(!st.empty() && nums[k]>st.top().first) \\n                st.pop();\\n            \\n            //we check the conditon nums[i]<nums[k]<nums[j] if it exists return true\\n            if(!st.empty())\\n            {\\n                //if top mini value is less than nums[k] and nums[k] is less than top value of stack, returns true\\n                if((st.top().second < nums[k]) && (nums[k] < st.top().first)) return true;\\n            }\\n            \\n            //store current value and minimum value in the stack\\n            st.push({nums[k], mini});\\n        }\\n        //if pattern not exists return false;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        //storing previous value and mini value available in the stack i.e. {nums[j], nums[i]}\\n        stack<pair<int, int>> st;\\n        int mini = INT_MAX; //store minimum value \\n        \\n        //iterate over nums array\\n        for(int k=0; k<nums.size(); k++)\\n        {\\n            //if stack is not empty then we find mini value present in the stack\\n            if(!st.empty())\\n                mini = min(mini, st.top().first);\\n            \\n            //till nums[k] is greater than top element of stack i.e. nums[j], we pop the element\\n            while(!st.empty() && nums[k]>st.top().first) \\n                st.pop();\\n            \\n            //we check the conditon nums[i]<nums[k]<nums[j] if it exists return true\\n            if(!st.empty())\\n            {\\n                //if top mini value is less than nums[k] and nums[k] is less than top value of stack, returns true\\n                if((st.top().second < nums[k]) && (nums[k] < st.top().first)) return true;\\n            }\\n            \\n            //store current value and minimum value in the stack\\n            st.push({nums[k], mini});\\n        }\\n        //if pattern not exists return false;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015560,
                "title": "python3-monotonic-stack-with-detailed-explanation-time-o-n-space-o-n",
                "content": "\\n        s3 = float(\\'-inf\\')\\n        s3_candidates = []\\n        \\n        for i in range(len(nums) - 1, -1, -1):\\n            if nums[i] < s3:\\n                return True\\n            # When s3 is not -inf, meaning we have a valid s2, s3 pair. We first let nums[i]\\n            # act as s1, the smallest number among the three. If nums[i] is smaller than s3, \\n            # we find a 132 pattern and return True.\\n            \\n            while s3_candidates and nums[i] > s3_candidates[-1]:\\n                s3 = s3_candidates.pop()\\n                # Else, we assume that nums[i] now is s2 for the next iteraton. If numbers \\n                # in s3_candidates is smaller than nums[i], we find a valid s2, s3 pair.\\n            s3_candidates.append(nums[i])\\n            # Additionally, this while loop removes all numbers in stack that smaller than \\n            # nums[i], then push nums[i] into the stack, making sure that the stack keeps a \\n            # deceasing order. Therefore, the last popped num from this stack will always be \\n            # the maximun s3 and will not miss possible s1.\\n        return False",
                "solutionTags": [],
                "code": "\\n        s3 = float(\\'-inf\\')\\n        s3_candidates = []\\n        \\n        for i in range(len(nums) - 1, -1, -1):\\n            if nums[i] < s3:\\n                return True\\n            # When s3 is not -inf, meaning we have a valid s2, s3 pair. We first let nums[i]\\n            # act as s1, the smallest number among the three. If nums[i] is smaller than s3, \\n            # we find a 132 pattern and return True.\\n            \\n            while s3_candidates and nums[i] > s3_candidates[-1]:\\n                s3 = s3_candidates.pop()\\n                # Else, we assume that nums[i] now is s2 for the next iteraton. If numbers \\n                # in s3_candidates is smaller than nums[i], we find a valid s2, s3 pair.\\n            s3_candidates.append(nums[i])\\n            # Additionally, this while loop removes all numbers in stack that smaller than \\n            # nums[i], then push nums[i] into the stack, making sure that the stack keeps a \\n            # deceasing order. Therefore, the last popped num from this stack will always be \\n            # the maximun s3 and will not miss possible s1.\\n        return False",
                "codeTag": "Unknown"
            },
            {
                "id": 2015405,
                "title": "c-set-map-short-solution-o-n-ufff-finally-did-it-feeling",
                "content": "Hllo there , so in this we are making 3 data stores :-\\n**1. SET** :-  to store the distinct values  from left to the point where we are currently there\\n**2. MAP** :- to simply store the count of every number \\n**3. MINV** :- to simply store the minimum   number  from the point where we are from starting (i.e. on the left)\\n**UPPER BOUND function is a gift to all of us as it simply returns the just upper value in the given set** .\\nWhile traversing the array we see that if the just above value of the minv in the right hand side is smaller than current value or not : if yes then return true else move to next  and remove the current value of its count is 0 . *(read it again)* \\nFOR EX :- \\n                                       TEST CASE :- 3, 5, 0, 3, 4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   i=1 \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ->we are at 5; minv =3 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ->just above value =4 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ->4<5 return true ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   CASE CLOSED :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        set<int> s;\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            s.insert(nums[i]);\\n            m[nums[i]]++;\\n        }\\n        int minv=nums[0];\\n        m[nums[0]]--;\\n        if(m[nums[0]]==0)\\n        s.erase(minv);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s.upper_bound(minv)!=s.end() && nums[i]>*(s.upper_bound(minv)) && *(s.upper_bound(minv))!=minv)\\n            {\\n                return true;\\n            }\\n             m[nums[i]]--;\\n             if(m[nums[i]]==0)\\n            s.erase(nums[i]);\\n            \\n            if(nums[i]<minv)\\n            {\\n                minv=nums[i];\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\nP.S. :- Did it in 7 submission xd (reason for posting the soln)\\n(Pls upvote kabhi kabhi to soln dalta hun :) )",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        set<int> s;\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            s.insert(nums[i]);\\n            m[nums[i]]++;\\n        }\\n        int minv=nums[0];\\n        m[nums[0]]--;\\n        if(m[nums[0]]==0)\\n        s.erase(minv);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s.upper_bound(minv)!=s.end() && nums[i]>*(s.upper_bound(minv)) && *(s.upper_bound(minv))!=minv)\\n            {\\n                return true;\\n            }\\n             m[nums[i]]--;\\n             if(m[nums[i]]==0)\\n            s.erase(nums[i]);\\n            \\n            if(nums[i]<minv)\\n            {\\n                minv=nums[i];\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982091,
                "title": "132-pattern-problem",
                "content": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int  n=nums.size();\\n        \\n        int mx=INT_MIN,mn=INT_MAX,mxi,mni;\\n        \\n        int arrmin[n] ;\\n        \\n        stack<int>st;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<mn)\\n            {\\n                arrmin[i]=nums[i];\\n                mn=nums[i];\\n            }\\n            else\\n            {\\n                arrmin[i]=mn;\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arrmin[i]<nums[i])\\n            {\\n                \\n                  while(!(st.empty())  &&  st.top()<=arrmin[i] )\\n                {\\n                    \\n                    st.pop();\\n                    \\n                    \\n                }\\n                   \\n                \\n                \\n                 if(!(st.empty()) && st.top()>arrmin[i] && st.top()<nums[i])\\n                    {\\n                        return true;\\n                    }\\n                   \\n                \\n                \\n              \\n                \\n                  st.push(nums[i]);\\n    \\n            }\\n            \\n      }\\n        return false;\\n    }\\n};\\n\\n\\n\\n**please upvote.....................................................** ---------> it is 100% free for you.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int  n=nums.size();\\n        \\n        int mx=INT_MIN,mn=INT_MAX,mxi,mni;\\n        \\n        int arrmin[n] ;\\n        \\n        stack<int>st;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<mn)\\n            {\\n                arrmin[i]=nums[i];\\n                mn=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1849910,
                "title": "c-simple-code-explained-tc-o-n-sc-o-n",
                "content": "##### Upvote if it helps\\u2B06\\uFE0F\\n```\\nbool find132pattern(vector<int>& nums) {\\n        int secondmax = -1e9 , n = nums.size();\\n\\t\\tstack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() and nums[i] > s.top()){\\n                secondmax = max(secondmax,s.top());\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n            if(nums[i] < secondmax and s.empty() == false) return true; \\n            // stack is not empty means we have highest\\n            // element in our stack basically we have 3 in 132 pattern \\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "##### Upvote if it helps\\u2B06\\uFE0F\\n```\\nbool find132pattern(vector<int>& nums) {\\n        int secondmax = -1e9 , n = nums.size();\\n\\t\\tstack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() and nums[i] > s.top()){\\n                secondmax = max(secondmax,s.top());\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n            if(nums[i] < secondmax and s.empty() == false) return true; \\n            // stack is not empty means we have highest\\n            // element in our stack basically we have 3 in 132 pattern \\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1322785,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> minArray(n);\\n        \\n        minArray[0]=nums[0];\\n        for(int i=1;i<n;++i){\\n            minArray[i]=min(minArray[i-1],nums[i]);\\n        }\\n        \\n        stack<int> stk;\\n        for(int i=n-1;i>=0;--i){\\n            if(nums[i]>minArray[i]){\\n                while(!stk.empty() && stk.top()<=minArray[i]) stk.pop();\\n                if(!stk.empty() && stk.top()<nums[i]) return true;\\n                stk.push(nums[i]);\\n            } \\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> minArray(n);\\n        \\n        minArray[0]=nums[0];\\n        for(int i=1;i<n;++i){\\n            minArray[i]=min(minArray[i-1],nums[i]);\\n        }\\n        \\n        stack<int> stk;\\n        for(int i=n-1;i>=0;--i){\\n            if(nums[i]>minArray[i]){\\n                while(!stk.empty() && stk.top()<=minArray[i]) stk.pop();\\n                if(!stk.empty() && stk.top()<nums[i]) return true;\\n                stk.push(nums[i]);\\n            } \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296419,
                "title": "easy-understanding-solution-with-comments-python-stack",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        mi = [nums[0]]\\n        \\n        n=len(nums)\\n        \\n        # making a min stack which store the minimum element till the current index from left\\n        for j in range(1,n):\\n            mi.append( min(mi[-1],nums[j]) )\\n            \\n            \\n        stack=[]\\n        \\n        \\n        for j in range(n-1,-1,-1):\\n            \\n            # makeing stack for the nums[k]\\n            \\n            while stack and stack[-1]<=mi[j]:\\n                stack.pop()\\n            if len(stack)>0:\\n                if mi[j]<stack[-1]<nums[j]:\\n                    return True\\n            stack.append(nums[j])\\n        \\n        return False\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        mi = [nums[0]]\\n        \\n        n=len(nums)\\n        \\n        # making a min stack which store the minimum element till the current index from left\\n        for j in range(1,n):\\n            mi.append( min(mi[-1],nums[j]) )\\n            \\n            \\n        stack=[]\\n        \\n        \\n        for j in range(n-1,-1,-1):\\n            \\n            # makeing stack for the nums[k]\\n            \\n            while stack and stack[-1]<=mi[j]:\\n                stack.pop()\\n            if len(stack)>0:\\n                if mi[j]<stack[-1]<nums[j]:\\n                    return True\\n            stack.append(nums[j])\\n        \\n        return False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 907505,
                "title": "a-few-solutions",
                "content": "Since we are searching for `A[k]` which is in between `A[i]...A[j]` non-inclusive, we can simply track the minimum `A[j]` seen so far in place of `A[i]` to improve upon a naive brute-force search of all `i, j, k` candidates with runtime O(N<sup>3</sup>).  Thus, perform a linear scan of the input array `A` for each candidate index `j` and `k` while simultaneously tracking the minimum value seen so far as the `first` candidate at some arbitrary index `i`, ie. `A[i]`, such that `i < j < k`.  Return `true` if and only if we can find candidate indices `j` and `k` such that `first < A[k] < A[j]`.\\n\\n---\\n\\n**Runtime:** O(N<sup>2</sup>)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun find132pattern(A: IntArray): Boolean {\\n        var N = A.size\\n        var first = A[0]\\n        for (j in 1 until N) {\\n            first = Math.min(first, A[j])  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for (k in j + 1 until N)\\n                if (first < A[k] && A[k] < A[j])\\n                    return true\\n        }\\n        return false\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet find132pattern = A => {\\n    let N = A.length,\\n        first = A[0];\\n    for (let j = 1; j < N; ++j) {\\n        first = Math.min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n        for (let k = j + 1; k < N; ++k)\\n            if (first < A[k] && A[k] < A[j])\\n                return true;\\n    }\\n    return false;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def find132pattern(self, A: List[int]) -> bool:\\n        N = len(A)\\n        first = A[0]\\n        for j in range(1, N):\\n            first = min(first, A[j])  # \\u2B50\\uFE0F minimum A[i] seen so far\\n            for k in range(j + 1, N):\\n                if first < A[k] < A[j]:\\n                    return True\\n        return False\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn find132pattern(A: Vec<i32>) -> bool {\\n        let N = A.len();\\n        let mut first = A[0];\\n        for j in 1..N {\\n            first = min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for k in j + 1..N {\\n                if first < A[k] && A[k] < A[j] {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool find132pattern(VI& A) {\\n        int N = A.size(),\\n            first = A[0];\\n        for (auto j{ 1 }; j < N; ++j) {\\n            first = min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for (auto k{ j + 1 }; k < N; ++k)\\n                if (first < A[k] && A[k] < A[j])\\n                    return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun find132pattern(A: IntArray): Boolean {\\n        var N = A.size\\n        var first = A[0]\\n        for (j in 1 until N) {\\n            first = Math.min(first, A[j])  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for (k in j + 1 until N)\\n                if (first < A[k] && A[k] < A[j])\\n                    return true\\n        }\\n        return false\\n    }\\n}\\n```\n```\\nlet find132pattern = A => {\\n    let N = A.length,\\n        first = A[0];\\n    for (let j = 1; j < N; ++j) {\\n        first = Math.min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n        for (let k = j + 1; k < N; ++k)\\n            if (first < A[k] && A[k] < A[j])\\n                return true;\\n    }\\n    return false;\\n};\\n```\n```\\nclass Solution:\\n    def find132pattern(self, A: List[int]) -> bool:\\n        N = len(A)\\n        first = A[0]\\n        for j in range(1, N):\\n            first = min(first, A[j])  # \\u2B50\\uFE0F minimum A[i] seen so far\\n            for k in range(j + 1, N):\\n                if first < A[k] < A[j]:\\n                    return True\\n        return False\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn find132pattern(A: Vec<i32>) -> bool {\\n        let N = A.len();\\n        let mut first = A[0];\\n        for j in 1..N {\\n            first = min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for k in j + 1..N {\\n                if first < A[k] && A[k] < A[j] {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool find132pattern(VI& A) {\\n        int N = A.size(),\\n            first = A[0];\\n        for (auto j{ 1 }; j < N; ++j) {\\n            first = min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for (auto k{ j + 1 }; k < N; ++k)\\n                if (first < A[k] && A[k] < A[j])\\n                    return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554441,
                "title": "c-8-lines-o-n-stack-solution-with-explanation",
                "content": "```\\n    bool find132pattern(vector<int>& nums) { //O(n) Time & Space -> Stack\\n        if(nums.size() < 3) return false;\\n        stack<int> s3;\\n        int s2 = INT_MIN;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if(nums[i] < s2) return true;\\n            else while(!s3.empty() && nums[i]>s3.top()) {\\n                s2 = s3.top(), s3.pop(); \\n            }\\n            s3.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```\\nIdea : Move from right to left. For every upward moving slope from the end, s2 will be the 2nd highest element of that upward slope and s3 will ofcourse be the top most element of that slope. Thus, S2 gets updates from INT_MIN to its new value, we now know that 3>2 comination exists. Now we need to check if there exists a combination of 1<2. Since 2 is no more INT_MIN, we can easily check for 1<2 by checking if nums[i]<s2. Also, s3 is a stack to find the highest peak i.e s3 and make s2 as 2nd highest peak a.k.a next num after peak. \\n\\n\\nInspired from : https://leetcode.com/problems/132-pattern/discuss/94071/Single-pass-C%2B%2B-O(n)-space-and-time-solution-(8-lines)-with-detailed-explanation.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n    bool find132pattern(vector<int>& nums) { //O(n) Time & Space -> Stack\\n        if(nums.size() < 3) return false;\\n        stack<int> s3;\\n        int s2 = INT_MIN;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if(nums[i] < s2) return true;\\n            else while(!s3.empty() && nums[i]>s3.top()) {\\n                s2 = s3.top(), s3.pop(); \\n            }\\n            s3.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2319644,
                "title": "clean-and-crisp-c-solution-with-explanation",
                "content": "**Step 1:** Let\\'s start by finding the nums[j] first, we know it\\'s the greatest among the other two elements.\\nWe can do that by maintaining the greater elements on the top of the stack. Such that stack\\'s top will be our nums[j].\\n**Step 2:** We\\'ll also keep track of the mininum element found so far that appeared before nums[j].\\nTo do that we\\'ll make a stack of pair, where the pair.first = nums[j] and pair.second = min element before j.\\n**Step 3:** Now let\\'s start looking for nums[k]\\nWe can do that easily because we know stack\\'s top(nums[j]) contains an element that\\'s bigger than nums[k]\\nNow, we only need to make sure that the nums[k] is also greater than any one element that came before nums[j], to find that, we\\'re already keeping track of the minimum element found so far before j.\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<pair<int, int>>st;\\n        int cur_min = nums[0];\\n        st.push({nums[0], cur_min});\\n\\n        for (int k = 1; k < nums.size(); ++k) {\\n//Step 1: We maintain a decreasing monotonic stack.\\n            while (!st.empty() && st.top().first <= nums[k]) st.pop();\\n//Step 3: Looking for nums[k].\\n            if (!st.empty() && nums[k] > st.top().second) return true;\\n//Step 2: Maintaining a minimum so far.\\n            st.push({nums[k], cur_min});\\n            cur_min = min(cur_min, nums[k]);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n\\t\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<pair<int, int>>st;\\n        int cur_min = nums[0];\\n        st.push({nums[0], cur_min});\\n\\n        for (int k = 1; k < nums.size(); ++k) {\\n//Step 1: We maintain a decreasing monotonic stack.\\n            while (!st.empty() && st.top().first <= nums[k]) st.pop();\\n//Step 3: Looking for nums[k].\\n            if (!st.empty() && nums[k] > st.top().second) return true;\\n//Step 2: Maintaining a minimum so far.\\n            st.push({nums[k], cur_min});\\n            cur_min = min(cur_min, nums[k]);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016840,
                "title": "super-simple-c-solution-nlog-n-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        int n=nums.size(),mini=nums[0];\\n        \\n        unordered_map<int,int>h;\\n        set<int>st;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n            h[nums[i]]++;\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            h[nums[i]]--;\\n            if(h[nums[i]]==0)st.erase(nums[i]);\\n            auto it=st.lower_bound(nums[i]);\\n            \\n            if(it!=st.end() || it!=st.begin())it--;\\n            if(it!=st.end() && *it>mini && *it<nums[i])return true;\\n            mini=min(mini,nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        int n=nums.size(),mini=nums[0];\\n        \\n        unordered_map<int,int>h;\\n        set<int>st;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n            h[nums[i]]++;\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            h[nums[i]]--;\\n            if(h[nums[i]]==0)st.erase(nums[i]);\\n            auto it=st.lower_bound(nums[i]);\\n            \\n            if(it!=st.end() || it!=st.begin())it--;\\n            if(it!=st.end() && *it>mini && *it<nums[i])return true;\\n            mini=min(mini,nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015550,
                "title": "c-solution-with-explanation",
                "content": "First, how we start to process this problem?\\n- nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].\\n\\nSo in comparation of value, may like 1 < 3 < 2\\nIf we start from first, we may need to remeber first and second to check is third between them.\\nIf we start from tail, after we confirm any is bigger than 2, then we only need to find another one before that index and lower than two.\\n\\nwe use a stack to save all nums we process, and due to first in last out, we can get the most close number easiler.\\nAs description above, middle value means the nums[j] in the problem, if we find a valid middle value, then we only need to find a value lower than that.(end rule)\\n\\nAnd do we need to update the middle value? yes, when another easiler pair of [num[j], nums[k]] exist, we should.\\nWhat does easiler pair means? We hope middle value(nums[k]) is as big as possiable, so we can find first(nums[i]) easiler -> only when a bigger nums[j], nums[k] can be bigger. \\n```\\n public bool Find132pattern(int[] nums)\\n{\\n\\tvar stack = new Stack<int>();\\n\\tvar middleValue = int.MinValue;\\n\\tfor(int i = nums.Length - 1; i >= 0; i--)\\n\\t{\\n\\t\\tif(middleValue > nums[i])\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\twhile(stack.Count > 0 && nums[i] > stack.Peek())\\n\\t\\t{\\n\\t\\t\\tmiddleValue = Math.Max(middleValue, stack.Pop());\\n\\t\\t}\\n\\n\\t\\tstack.Push(nums[i]);\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n* this solution is refer from https://leetcode.com/problems/132-pattern/discuss/345066/C-increasing-stack , and add what I thought about this problem.",
                "solutionTags": [],
                "code": "```\\n public bool Find132pattern(int[] nums)\\n{\\n\\tvar stack = new Stack<int>();\\n\\tvar middleValue = int.MinValue;\\n\\tfor(int i = nums.Length - 1; i >= 0; i--)\\n\\t{\\n\\t\\tif(middleValue > nums[i])\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\twhile(stack.Count > 0 && nums[i] > stack.Peek())\\n\\t\\t{\\n\\t\\t\\tmiddleValue = Math.Max(middleValue, stack.Pop());\\n\\t\\t}\\n\\n\\t\\tstack.Push(nums[i]);\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015240,
                "title": "simple-c-solution-with-nlog-n-complexity",
                "content": "Idea: We will divide the condition i < j < k & nums[i] < nums[k] < nums[j] into two parts. \\n* Part one: j < k and nums[k] > nums[j]\\n* Part two: i < j and nums[i] < nums[j]\\n\\nFor part one, we\\'ll iterate the array from last to the first position. And for each i (i = n-1 to 0), we\\'ll store the maximum value less than nums[i] in the range (i +1 to n - 1).\\n\\nFor part two, we have to store the minimum values for each prefix of nums. To do this, we\\'ll iterate from the first position of the array to the last position and store the minimum for each prefix and we can solve the part two by nums[i-1] < nums[i] formula.\\n\\nTime Complexity: O(n log n)\\nSpace Complexity: O(n)\\n\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    int dp[200011];\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n<3) return false;\\n        \\n        dp[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i] = min(dp[i-1], nums[i]);\\n        }\\n        \\n        set<int>myset;\\n        myset.insert(nums[n-1]);\\n        for(int i=n-2;i>0;i--){\\n\\n            auto fs = myset.begin();\\n            auto ls = myset.end();\\n            ls--;\\n            if( (*fs) < nums[i] ){\\n                if( (*ls) < nums[i] ){\\n                    if(dp[i-1] < (*ls)){\\n                        return true;\\n                    }\\n                }\\n                else{\\n                    auto it = myset.lower_bound(nums[i]);\\n                    it--;\\n                    if(dp[i-1] < (*it)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            myset.insert(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[200011];\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n<3) return false;\\n        \\n        dp[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i] = min(dp[i-1], nums[i]);\\n        }\\n        \\n        set<int>myset;\\n        myset.insert(nums[n-1]);\\n        for(int i=n-2;i>0;i--){\\n\\n            auto fs = myset.begin();\\n            auto ls = myset.end();\\n            ls--;\\n            if( (*fs) < nums[i] ){\\n                if( (*ls) < nums[i] ){\\n                    if(dp[i-1] < (*ls)){\\n                        return true;\\n                    }\\n                }\\n                else{\\n                    auto it = myset.lower_bound(nums[i]);\\n                    it--;\\n                    if(dp[i-1] < (*it)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            myset.insert(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707505,
                "title": "c-easy",
                "content": "Approach: Using stack\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int k = INT_MIN;\\n        \\n        stack<int> s;\\n        \\n        for(int i = nums.size() - 1; i >= 0; i--) {\\n            \\n            if(nums[i] < k) {\\n                return true;\\n            }\\n            \\n            while(s.empty() == false and nums[i] > s.top()) {\\n                k = s.top();\\n                s.pop();\\n            }\\n            \\n            s.push(nums[i]);\\n        }\\n        \\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int k = INT_MIN;\\n        \\n        stack<int> s;\\n        \\n        for(int i = nums.size() - 1; i >= 0; i--) {\\n            \\n            if(nums[i] < k) {\\n                return true;\\n            }\\n            \\n            while(s.empty() == false and nums[i] > s.top()) {\\n                k = s.top();\\n                s.pop();\\n            }\\n            \\n            s.push(nums[i]);\\n        }\\n        \\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640069,
                "title": "python3-solution-100-faster",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        s2 = float(\\'-inf\\')\\n        for i in nums[::-1]:\\n            if i<s2: return True\\n            while stack and i>stack[-1]: \\n                s2 = stack.pop()\\n            stack.append(i)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        s2 = float(\\'-inf\\')\\n        for i in nums[::-1]:\\n            if i<s2: return True\\n            while stack and i>stack[-1]: \\n                s2 = stack.pop()\\n            stack.append(i)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625924,
                "title": "c-456-132-pattern",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int prev = INT_MIN; \\n        stack<int> stk; \\n        for (int i = nums.size()-1; i >= 0; --i) {\\n            if (nums[i] < prev) return true; \\n            while (stk.size() && stk.top() < nums[i]) {\\n                prev = max(prev, stk.top()); \\n                stk.pop(); \\n            }\\n            stk.push(nums[i]); \\n        }\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int prev = INT_MIN; \\n        stack<int> stk; \\n        for (int i = nums.size()-1; i >= 0; --i) {\\n            if (nums[i] < prev) return true; \\n            while (stk.size() && stk.top() < nums[i]) {\\n                prev = max(prev, stk.top()); \\n                stk.pop(); \\n            }\\n            stk.push(nums[i]); \\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392016,
                "title": "best-beginner-9-lines-approx-fully-explained-solution-only-for-me",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<3) return false; // atleast 3 nums reqd\\n        \\n        vector<int>preMin(n,INT_MAX); // track min value in range 0 to i-1\\n        for(int i=1;i<n;i++)\\n            preMin[i] = min(preMin[i-1],nums[i-1]);// store prefix min values\\n        \\n        stack<int>stk;\\n        \\n        for(int i=n-1;i>=0;i--){// Loop through end to start to store the next greater number\\n            while(!stk.empty() && stk.top()<=preMin[i]) // as we are finding next greater number than preMin[i], pop numbers from stack which are less or equal to preMin[i]\\n                stk.pop();\\n            \\n            if(!stk.empty() && stk.top()< nums[i]) return true;// if stack.top < nums[i] then it is a 132 pattern as stack.top > preMin[i] therefore there exists a num in nums[i] which is smaller than both nums[i] and stk.top()\\n            \\n            stk.push(nums[i]);\\n        }\\n        return false;//if nothing is found\\n    }\\n};\\n//Regarding Time Complexity, we are iterating every element twice, once during findind premin array and second during the main loop, therefore overall O(N)\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<3) return false; // atleast 3 nums reqd\\n        \\n        vector<int>preMin(n,INT_MAX); // track min value in range 0 to i-1\\n        for(int i=1;i<n;i++)\\n            preMin[i] = min(preMin[i-1],nums[i-1]);// store prefix min values\\n        \\n        stack<int>stk;\\n        \\n        for(int i=n-1;i>=0;i--){// Loop through end to start to store the next greater number\\n            while(!stk.empty() && stk.top()<=preMin[i]) // as we are finding next greater number than preMin[i], pop numbers from stack which are less or equal to preMin[i]\\n                stk.pop();\\n            \\n            if(!stk.empty() && stk.top()< nums[i]) return true;// if stack.top < nums[i] then it is a 132 pattern as stack.top > preMin[i] therefore there exists a num in nums[i] which is smaller than both nums[i] and stk.top()\\n            \\n            stk.push(nums[i]);\\n        }\\n        return false;//if nothing is found\\n    }\\n};\\n//Regarding Time Complexity, we are iterating every element twice, once during findind premin array and second during the main loop, therefore overall O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219878,
                "title": "java-easy-stack",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        int minPrefix[] = new int [arr.length];\\n        minPrefix[0] = arr[0];\\n       \\n       for(int i=1;i<arr.length;i++){\\n         minPrefix[i] = Math.min(minPrefix[i-1],arr[i]);\\n       }\\n      \\n       for(int i=arr.length-1;i>=0;i--){\\n         while(stack.size() > 0 && minPrefix[i]>=stack.peek()){\\n           stack.pop();\\n         }\\n         if(stack.size()>0 && stack.peek()<arr[i]) return true;\\n         stack.push(arr[i]);\\n       }\\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        int minPrefix[] = new int [arr.length];\\n        minPrefix[0] = arr[0];\\n       \\n       for(int i=1;i<arr.length;i++){\\n         minPrefix[i] = Math.min(minPrefix[i-1],arr[i]);\\n       }\\n      \\n       for(int i=arr.length-1;i>=0;i--){\\n         while(stack.size() > 0 && minPrefix[i]>=stack.peek()){\\n           stack.pop();\\n         }\\n         if(stack.size()>0 && stack.peek()<arr[i]) return true;\\n         stack.push(arr[i]);\\n       }\\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907488,
                "title": "java-approach-explained-o-n-2-greedy-choose-minimum-in-left-half",
                "content": "**Please upvote if helpful!!**\\n\\nIntuition : Fix a middle element j  i.e. (3 in 132 pattern) in the array. Then try to find the lowest value from start of array to \\nmiddle element - 1; we find the lowest so that we increase our range of finding 132 pattern. \\nif the lowest in left half found is less than middle element; search in middle + 1 to end of array element which lies inbetwen the the range of lowest and highest i.e. i and j as per the question. i.e. nums[i] < nums[k] < nums[j]\\n\\nEg: if middle element is\\n6 , lowest in the left of array is 1 , then we need to find the k element from middle element + 1 to end of array, choosing lowest\\nvalue in left half of middle element gives us more values to choose in the range of [1,6].\\n\\nPS: The stack solution; i have still not understood even after reading various posts. This approach seems intuitive to me.!! \\n\\n```\\npublic boolean find132patternBruteForceCustom(int[] nums) {\\n\\n        if (nums == null || nums.length < 3) return false;\\n\\n        for (int j = 1; j < nums.length; j++) {\\n            int numJ = nums[j];\\n\\n            int lowestInLeft = Integer.MAX_VALUE;\\n            for (int i = 0; i < j; i++) {\\n                lowestInLeft = Math.min(lowestInLeft, nums[i]);\\n            }\\n\\n            if (lowestInLeft < numJ) {\\n\\n                for (int k = j + 1; k < nums.length; k++) {\\n\\n                    if (nums[k] < numJ && lowestInLeft < nums[k]) {\\n                        return true;\\n                    }\\n\\n                }\\n\\n            }\\n\\n        }\\n        return false;\\n\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic boolean find132patternBruteForceCustom(int[] nums) {\\n\\n        if (nums == null || nums.length < 3) return false;\\n\\n        for (int j = 1; j < nums.length; j++) {\\n            int numJ = nums[j];\\n\\n            int lowestInLeft = Integer.MAX_VALUE;\\n            for (int i = 0; i < j; i++) {\\n                lowestInLeft = Math.min(lowestInLeft, nums[i]);\\n            }\\n\\n            if (lowestInLeft < numJ) {\\n\\n                for (int k = j + 1; k < nums.length; k++) {\\n\\n                    if (nums[k] < numJ && lowestInLeft < nums[k]) {\\n                        return true;\\n                    }\\n\\n                }\\n\\n            }\\n\\n        }\\n        return false;\\n\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907065,
                "title": "python3-intuitive-binary-search-nlog-n",
                "content": "Funny thing is, this code beat 97% in time\\n\\nthe idea is say we look at nums[j], \\nthen we need cur_min = min(nums[:j])\\nand tmp = sorted(nums[j+1:]).\\nthen we check position of  nums[j] and cur_min in tmp by\\nidx = bisect_left(tmp,nums[j])\\nidx_min = bisect_right(tmp,cur_min)\\nif(idx>idx_min), then we find 132 pattern\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        cur_min = nums[0]\\n        nums = nums[1:]\\n        tmp = sorted(nums)\\n        nums = deque(nums)\\n        while(tmp):\\n            t = nums.popleft()\\n            idx = bisect_left(tmp,t)\\n            del tmp[idx]\\n            idx_min = bisect_right(tmp,cur_min)\\n            if(idx>idx_min):\\n                return True\\n            cur_min = min(cur_min,t)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        cur_min = nums[0]\\n        nums = nums[1:]\\n        tmp = sorted(nums)\\n        nums = deque(nums)\\n        while(tmp):\\n            t = nums.popleft()\\n            idx = bisect_left(tmp,t)\\n            del tmp[idx]\\n            idx_min = bisect_right(tmp,cur_min)\\n            if(idx>idx_min):\\n                return True\\n            cur_min = min(cur_min,t)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835751,
                "title": "python3-solution",
                "content": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n        stack=[]\\n        k=float(\"-inf\")\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[i]<k:\\n                return True\\n            while stack and stack[-1] < nums[i]:\\n                k=stack.pop()\\n            stack.append(nums[i])\\n        return False",
                "solutionTags": [],
                "code": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n        stack=[]\\n        k=float(\"-inf\")\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[i]<k:\\n                return True\\n            while stack and stack[-1] < nums[i]:\\n                k=stack.pop()\\n            stack.append(nums[i])\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 575712,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        stack<int>stk;\\n        int prev = INT_MIN;\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            if (nums[i] < prev)\\n                return true;\\n            while (!stk.empty() && nums[i] > stk.top()) {\\n                prev = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        stack<int>stk;\\n        int prev = INT_MIN;\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            if (nums[i] < prev)\\n                return true;\\n            while (!stk.empty() && nums[i] > stk.top()) {\\n                prev = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497377,
                "title": "using-stack-o-n-with-explaination",
                "content": "Suppose we have `a`,`b`,`c` and we want to ensure `a < b > c` and `a < c` .\\nThe idea is to keep on checking `a < c` while (we already know for some `b` ,`b > c`);\\n\\nSuppose `b` is the top most element in the stack.\\n\\nNow, for some index, `i` if  we find `nums[i] > stack.top()`, that element (`nums[i]`) is potential candidate for our b. so  `c` becomes `stack.top()` and we pop our stack . (This also mean that stack would contain elements in increasing order from top to bottom).\\n\\nNow traversing towards left, if we find some element in the array such that `nums[i] < c` we are done.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484439,
                "title": "stack-o-n-with-explanation",
                "content": "So after I read a lot of posts about the stack solution and still couldn\\'t understand any of them. \\nI decided to wirte a post on my own and break down every single detials of it. \\n\\nBefore you start reading it, I have to tell you this post is about the stack solution. There exists many other solutions in the solution tab of the problem. However, this post only focus on the stack solution. \\nAnd I am going to use c++ terms like `vector` or `stack<int> ` incase you don\\'t know what I am talking about. \\n\\nOk, let\\'s get started. \\n\\nSo after first observation of the problem one could come up with a O(n^3) solution right?\\nIf there exists a solution `ai, aj, ak` for which `aj > ak > ai`, then `aj` must exists in the nums vector, right?` 1 3 2` `aj `means the biggest one. \\n\\nSo we can go through this vector nums, for every `nums[i] `we check if it is a `aj`. We look to the left of `nums[i]` looking for the smallest one as `ai`, and we look into the right of `aj`looking for a number which is smaller than `aj` and bigger than `ai`, if we succeed in finding such numbers, then `nums[i]` is indeed a `aj`, otherwise, after we go through the entire vector and still could not find any, then there doesn\\'t exists such pattern. \\nThis is a O(n^2) solution. \\n\\nHow can we do better than that?\\n\\none little optimization is to go through the vector from left to right first and store the smallest item so far as a `min_vector`. For every` min_vector[i]` is the smallest number found from `nums[0] `to `nums[i]`\\n\\nSo we don\\'t need to look into the left any more, simply check the `min_vector[i] `to get the smallest number. This will take O(n) space, yet still haven\\'t changed the time complexicity. \\n\\n\\n**Just hear me out. The next bit is very important. \\n**\\n\\nWhen we look to the right and looking for the `ak`, if we search from the end to the start\\nlike `for(j= n-1;j>=0;j--)`every time we check if `nums[j]`is bigger than `min_vector[i]` if so, we print the `nums[j] `to the screen, we are going to see a very interesting pattern. The numbers printed to the screen are in descending order, if there exists a number that destroy the descending pattern, then these two numbers along with the `min_vector[i]` form a solution to the problem, regardless the state of `nums[i]`. \\n\\nPlease allow me to elaborate on that. For the `nums[i]` to become `aj`it must be bigger than `ai`. For `nums[j]`to become `ak`then it must also be bigger than `ai` other wise it is not a 132 pattern. So when we look to the right of `nums[i]`we only care about the ones bigger than `min_vector[i]`. For all the numbers to the right of `nums[i]`that are bigger than `min_vector[i]`we only need to check if these numbers are in ascending order. If they are not in ascending order, then there exists a solution. the function return true. till now, the time complexicity is still not changed. \\n\\nIf we now take a closer look at `nums[i] `and `nums[i+1]`for `nums[i]`we go through all the element on the right to see if there exists a solution by check if the sequence is in ascending order. and for nums[i+1]we went throught all the numbers on the right to see if they are in ascending order. For these two numbers, we don\\'t need to go through the numbers twice. If for` nums[i+1]` the numbers are in ascending order. we only need to check if from `nums[i] `to `nums[i+1]` is in ascending order and all the numbers on the right are automatically in ascending order. Becauese otherwise we have found a solution already and the function has returned. This operation takes O(1) time. \\n\\nHaHa, we now we have reduced the time complexicity from O(n^2) to O(n), right?\\n\\nNot exactly, there is small thing one is likely to overlook that is min_vector[i] min_vector[i+1]. \\nThe `min_vector` is in descending order from left to right. So, for all the number to the right of `nums[i]`that are greater than `min_vector[i]` are a little different from the numbers to the right of `nums[i+1]` that are greater than `min_vector[i+1]`. becase `min_vector[i]` is >= `min_vector[i+1]`\\n\\nThis poses problems, right? Here is where the stack comes in. When we were processing from end all the way to `nums[i+1]`we can push all the numbers to a stack. For this particular stack. The top one is the smallest, all the way to bottom, the numbers are getting bigger. When the `nums[j+1]`failed and we move to the `nums[j]`the stack is basically the same. we only need to pop out all the numbers that are smaller than `min_vector[i]`and check if `nums[i]` is smaller than top of the stack. If so, that means nums[i] is not what we are looking for, we push nums[i] to the stack assuming it is bigger than min_vector[i] then we continue to i-1 . If not, we have found a solution and the function return true. \\n\\nHence, this is how we can reduce the time complexicity from o(n^2) to O(n) with the use of stack. \\n\\nP.S. This is longer than I originally thought. Thank you so much for reading all of it. \\nIf you found any thing not very easy to understand please comment below, I will come back from time to time to update it. Thanks.",
                "solutionTags": [],
                "code": "So after I read a lot of posts about the stack solution and still couldn\\'t understand any of them. \\nI decided to wirte a post on my own and break down every single detials of it. \\n\\nBefore you start reading it, I have to tell you this post is about the stack solution. There exists many other solutions in the solution tab of the problem. However, this post only focus on the stack solution. \\nAnd I am going to use c++ terms like `vector` or `stack<int> ` incase you don\\'t know what I am talking about. \\n\\nOk, let\\'s get started. \\n\\nSo after first observation of the problem one could come up with a O(n^3) solution right?\\nIf there exists a solution `ai, aj, ak` for which `aj > ak > ai`, then `aj` must exists in the nums vector, right?` 1 3 2` `aj `means the biggest one. \\n\\nSo we can go through this vector nums, for every `nums[i] `we check if it is a `aj`. We look to the left of `nums[i]` looking for the smallest one as `ai`, and we look into the right of `aj`looking for a number which is smaller than `aj` and bigger than `ai`, if we succeed in finding such numbers, then `nums[i]` is indeed a `aj`, otherwise, after we go through the entire vector and still could not find any, then there doesn\\'t exists such pattern. \\nThis is a O(n^2) solution. \\n\\nHow can we do better than that?\\n\\none little optimization is to go through the vector from left to right first and store the smallest item so far as a `min_vector`. For every` min_vector[i]` is the smallest number found from `nums[0] `to `nums[i]`\\n\\nSo we don\\'t need to look into the left any more, simply check the `min_vector[i] `to get the smallest number. This will take O(n) space, yet still haven\\'t changed the time complexicity. \\n\\n\\n**Just hear me out. The next bit is very important. \\n**\\n\\nWhen we look to the right and looking for the `ak`, if we search from the end to the start\\nlike `for(j= n-1;j>=0;j--)`every time we check if `nums[j]`is bigger than `min_vector[i]` if so, we print the `nums[j] `to the screen, we are going to see a very interesting pattern. The numbers printed to the screen are in descending order, if there exists a number that destroy the descending pattern, then these two numbers along with the `min_vector[i]` form a solution to the problem, regardless the state of `nums[i]`. \\n\\nPlease allow me to elaborate on that. For the `nums[i]` to become `aj`it must be bigger than `ai`. For `nums[j]`to become `ak`then it must also be bigger than `ai` other wise it is not a 132 pattern. So when we look to the right of `nums[i]`we only care about the ones bigger than `min_vector[i]`. For all the numbers to the right of `nums[i]`that are bigger than `min_vector[i]`we only need to check if these numbers are in ascending order. If they are not in ascending order, then there exists a solution. the function return true. till now, the time complexicity is still not changed. \\n\\nIf we now take a closer look at `nums[i] `and `nums[i+1]`for `nums[i]`we go through all the element on the right to see if there exists a solution by check if the sequence is in ascending order. and for nums[i+1]we went throught all the numbers on the right to see if they are in ascending order. For these two numbers, we don\\'t need to go through the numbers twice. If for` nums[i+1]` the numbers are in ascending order. we only need to check if from `nums[i] `to `nums[i+1]` is in ascending order and all the numbers on the right are automatically in ascending order. Becauese otherwise we have found a solution already and the function has returned. This operation takes O(1) time. \\n\\nHaHa, we now we have reduced the time complexicity from O(n^2) to O(n), right?\\n\\nNot exactly, there is small thing one is likely to overlook that is min_vector[i] min_vector[i+1]. \\nThe `min_vector` is in descending order from left to right. So, for all the number to the right of `nums[i]`that are greater than `min_vector[i]` are a little different from the numbers to the right of `nums[i+1]` that are greater than `min_vector[i+1]`. becase `min_vector[i]` is >= `min_vector[i+1]`\\n\\nThis poses problems, right? Here is where the stack comes in. When we were processing from end all the way to `nums[i+1]`we can push all the numbers to a stack. For this particular stack. The top one is the smallest, all the way to bottom, the numbers are getting bigger. When the `nums[j+1]`failed and we move to the `nums[j]`the stack is basically the same. we only need to pop out all the numbers that are smaller than `min_vector[i]`and check if `nums[i]` is smaller than top of the stack. If so, that means nums[i] is not what we are looking for, we push nums[i] to the stack assuming it is bigger than min_vector[i] then we continue to i-1 . If not, we have found a solution and the function return true. \\n\\nHence, this is how we can reduce the time complexicity from o(n^2) to O(n) with the use of stack. \\n\\nP.S. This is longer than I originally thought. Thank you so much for reading all of it. \\nIf you found any thing not very easy to understand please comment below, I will come back from time to time to update it. Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 345066,
                "title": "c-increasing-stack",
                "content": "```\\npublic class Solution {\\n    public bool Find132pattern(int[] nums) {\\n        var n = nums.Length;\\n\\n        var stack = new Stack<int>();\\n\\n        var middleValue = int.MinValue;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            var curNum = nums[i];\\n\\n            if (curNum < middleValue) return true;\\n            else {\\n                while (stack.Any() && curNum > stack.Peek()) {\\n                    middleValue = Math.Max(middleValue, stack.Pop());\\n                }\\n            }\\n\\n            stack.Push(curNum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool Find132pattern(int[] nums) {\\n        var n = nums.Length;\\n\\n        var stack = new Stack<int>();\\n\\n        var middleValue = int.MinValue;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            var curNum = nums[i];\\n\\n            if (curNum < middleValue) return true;\\n            else {\\n                while (stack.Any() && curNum > stack.Peek()) {\\n                    middleValue = Math.Max(middleValue, stack.Pop());\\n                }\\n            }\\n\\n            stack.Push(curNum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94107,
                "title": "o-n-logn-treemap-explanation",
                "content": "The idea is to try to fix the nums[i] as a maximum value. The next step is to find minimum from our prefix. Then try to find if there exists the value in suffix which is greater than minimum and less than nums[i]. To find that value fast we can use tree map to count each number's occurrences and use it's lower() function.\\n```\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if (nums.length<=2) return false;\\n        TreeMap<Integer, Integer> counts = getCounts(nums);\\n        decrease(counts, nums[0], -1);\\n        int min = nums[0];\\n        \\n        for (int i=1; i<nums.length; i++) {\\n            decrease(counts, nums[i], -1);\\n            Integer lower = counts.lowerKey(nums[i]);\\n            if (lower!=null && lower>min) return true;\\n            min = Math.min(min, nums[i]);\\n        }\\n        return false;\\n    }\\n    \\n    private void decrease(TreeMap<Integer, Integer> counts, int key, int adder) {\\n        if (counts.containsKey(key)) {\\n            counts.put(key, counts.get(key)+adder);\\n            if (counts.get(key)<=0) counts.remove(key);\\n        }\\n    }\\n    \\n    private TreeMap<Integer, Integer> getCounts(int nums[]) {\\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\\n        for (int val: nums) {\\n            counts.put(val, counts.getOrDefault(val,0) + 1);\\n        }\\n        return counts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if (nums.length<=2) return false;\\n        TreeMap<Integer, Integer> counts = getCounts(nums);\\n        decrease(counts, nums[0], -1);\\n        int min = nums[0];\\n        \\n        for (int i=1; i<nums.length; i++) {\\n            decrease(counts, nums[i], -1);\\n            Integer lower = counts.lowerKey(nums[i]);\\n            if (lower!=null && lower>min) return true;\\n            min = Math.min(min, nums[i]);\\n        }\\n        return false;\\n    }\\n    \\n    private void decrease(TreeMap<Integer, Integer> counts, int key, int adder) {\\n        if (counts.containsKey(key)) {\\n            counts.put(key, counts.get(key)+adder);\\n            if (counts.get(key)<=0) counts.remove(key);\\n        }\\n    }\\n    \\n    private TreeMap<Integer, Integer> getCounts(int nums[]) {\\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\\n        for (int val: nums) {\\n            counts.put(val, counts.getOrDefault(val,0) + 1);\\n        }\\n        return counts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538634,
                "title": "456-132-pattern",
                "content": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n       int n = nums.size();\\n        stack<int>s;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(nums[i]<s3)\\n                return true;\\n            else\\n            {\\n                while(!s.empty() && nums[i]>s.top())\\n                {\\n                    s3 = s.top();\\n                    s.pop();\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n       int n = nums.size();\\n        stack<int>s;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(nums[i]<s3)\\n                return true;\\n            else\\n            {\\n                while(!s.empty() && nums[i]>s.top())\\n                {\\n                    s3 = s.top();\\n                    s.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3067815,
                "title": "java-c-100-solution-using-monotonic-stack-132-pattern",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int thirdElement=INT_MIN;\\n        \\n        for(int i = nums.size()-1;i>=0;--i)\\n        {\\n            if(thirdElement>nums[i])\\n                return true;\\n            while(!stk.empty() && stk.top()<nums[i])\\n            {\\n                thirdElement = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        int thirdElement = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] < thirdElement)\\n                return true;\\n            while(!st.isEmpty() && st.peek() < nums[i]) \\n                thirdElement = st.pop();\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int thirdElement=INT_MIN;\\n        \\n        for(int i = nums.size()-1;i>=0;--i)\\n        {\\n            if(thirdElement>nums[i])\\n                return true;\\n            while(!stk.empty() && stk.top()<nums[i])\\n            {\\n                thirdElement = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        int thirdElement = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] < thirdElement)\\n                return true;\\n            while(!st.isEmpty() && st.peek() < nums[i]) \\n                thirdElement = st.pop();\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604990,
                "title": "simplest-fastest-quickest-java-solution-via-stack-all-himself-by-lord-noddy",
                "content": "```\\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int x=Integer.MIN_VALUE;\\n         int largest_num=0;\\n        Stack<Integer> s=new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--)\\n      {\\n            largest_num=nums[i];\\n            if(nums[i]<x)\\n                return true;\\n            while(!s.isEmpty() && nums[i]>s.peek())\\n            {\\n                 x=s.peek();\\n                largest_num=Math.max(largest_num,s.peek());\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int x=Integer.MIN_VALUE;\\n         int largest_num=0;\\n        Stack<Integer> s=new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--)\\n      {\\n            largest_num=nums[i];\\n            if(nums[i]<x)\\n                return true;\\n            while(!s.isEmpty() && nums[i]>s.peek())\\n            {\\n                 x=s.peek();\\n                largest_num=Math.max(largest_num,s.peek());\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597677,
                "title": "c-stack-with-comments",
                "content": "\\nHere is my solution using stack and with comments!\\nIf any doubt ping me!\\n\\n\\n\\nAnd if you like it PLEASE UPVOTE!\\n\\n///\\nclass Solution {\\npublic:\\n\\n    bool find132pattern(vector<int>& nums) {\\n        vector<int> minimum(nums.size());  // to get the minimum value befor that value\\n        minimum[0] = nums[0];            \\n        for(int i = 1 ; i < nums.size() ; i++)\\n            minimum[i] = min(minimum[i-1],nums[i]);\\n        \\n        // Now after getting the minimum value at each index we\\'ll iterate from back side and push/ignore accordingly\\n        \\n        stack<int> st; //To have the potential answer i.e potential candidate for nums[k]\\n        bool flag = false;\\n        for(int j = nums.size() - 1 ; j >= 0 ; --j)\\n        {       \\n            while(st.size() > 0 && st.top() <= minimum[j]) // if the element of stack is smaller than minimum element i.e nums[i] < nums[k]\\n                st.pop();\\n            if(!st.empty() && st.top() < nums[j])  // if element of stack is smaller than nums[j] i.e nums[k] < nums[j] \\n            {\\n                flag = true;\\n                break; // as soon as we get the answer we\\'ll break and stop the further search\\n            }\\n            st.push(nums[j]);\\n        }\\n        return flag;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool find132pattern(vector<int>& nums) {\\n        vector<int> minimum(nums.size());  // to get the minimum value befor that value\\n        minimum[0] = nums[0];            \\n        for(int i = 1 ; i < nums.size() ; i++)\\n            minimum[i] = min(minimum[i-1],nums[i]);\\n        \\n        // Now after getting the minimum value at each index we\\'ll iterate from back side and push/ignore accordingly\\n        \\n        stack<int> st; //To have the potential answer i.e potential candidate for nums[k]\\n        bool flag = false;\\n        for(int j = nums.size() - 1 ; j >= 0 ; --j)\\n        {       \\n            while(st.size() > 0 && st.top() <= minimum[j]) // if the element of stack is smaller than minimum element i.e nums[i] < nums[k]\\n                st.pop();\\n            if(!st.empty() && st.top() < nums[j])  // if element of stack is smaller than nums[j] i.e nums[k] < nums[j] \\n            {\\n                flag = true;\\n                break; // as soon as we get the answer we\\'ll break and stop the further search\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2017677,
                "title": "solution-using-multiset-in-c-nlogn-complexity-209ms",
                "content": "So we have to find i , j , k such that    **(nums[i]<nums[j]>nums[k])     where i<j<k.**\\n\\nThe   approach is to  **fix i and j such that we could find a k which satisfies the above condition,**\\nto fix i and j the approach is  we will loop through the nums array  the current element of the array will be nums[j] now according to the condtion we need to find an element in the prefix of the nums array from current element which is smaller the current element.\\nfor eg - > nums = [ 1,2,3,4,6,5] and we are at 4 so our nums[j] is 4 now we need to find an element in [1,2,3] that is prefix of that array from current position which is smaller than 4.\\nto do this we will just maintan the smallest element till now.\\nso now our i and j are fixed we need to find k .\\nto do this we just put the suffix of nums fromt current position into a multiset and tried to find an element that is larger than nums[i] but smaller the nums[j] using upper bound on the multiset \\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int mn;\\n        int n = nums.size();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        multiset<int> ms(nums.begin() , nums.end());    \\n        mn = nums[0];\\n        ms.erase(ms.find(nums[0]));\\n        for(int i = 1; i+1 < n ; i++)\\n        {\\n            ms.erase(ms.find(nums[i]));\\n            auto  y = ms.upper_bound(mn);\\n            if(y == ms.end())\\n            {\\n                mn = min(mn , nums[i]);\\n                continue;\\n            }\\n            int z = *y;\\n            if(z>mn && z<nums[i])\\n            {\\n                return 1;\\n            }\\n            mn = min(mn , nums[i]);\\n        }\\n        return 0;\\n    }\\n};\\n```\\nI know  it is slower than the best approach that is using stack but this is just another approach that could run in the timelimit and give you an ac.\\n**Any changes or advice will great .\\nthanks ;}**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int mn;\\n        int n = nums.size();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        multiset<int> ms(nums.begin() , nums.end());    \\n        mn = nums[0];\\n        ms.erase(ms.find(nums[0]));\\n        for(int i = 1; i+1 < n ; i++)\\n        {\\n            ms.erase(ms.find(nums[i]));\\n            auto  y = ms.upper_bound(mn);\\n            if(y == ms.end())\\n            {\\n                mn = min(mn , nums[i]);\\n                continue;\\n            }\\n            int z = *y;\\n            if(z>mn && z<nums[i])\\n            {\\n                return 1;\\n            }\\n            mn = min(mn , nums[i]);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017175,
                "title": "all-three-approaches-o-n-3-o-n-2-o-n",
                "content": "Hello If you were able to understand from my explanation please do give a upvote.\\nLets start with the Brute force approach\\nHere we need to find the three subsequence in an array such that  i < j < k and nums[i] < nums[k] < nums[j]. So,  we goona use 3 pointers to find elements.\\nSo we will run three loops our first loop will start form i=0, second from j=i+1 and last loop from k=j+1 and all will run till n and If we goona check this condition nums[i] < nums[k] < nums[j] and if found return true;\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n      int n=nums.size();\\n      for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              for(int k=j+1;k<n;k++)\\n              {\\n                  if(nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n              }\\n          }\\n      }\\n        return false;\\n    }\\n};\\nSince we are running three loops. Hence time Complexity O(n^3) and ofcourse TLE :(\\n```\\n\\nNow we will try to optimize. Here will we choose and first element as first=nums[i] to keeptrack of the minimum element from left to right .We will run two loop First one from i=1 to n and second one from i+1 to n and check the condition first < nums[k] < nums[j] holds true return true else assign first=min(nums[i],first).\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       \\n        int temp=nums[0];\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                      if(nums[j]>temp && nums[j]<nums[i])\\n                          return true;\\n                }\\n                temp=min(temp,nums[i]);\\n            \\n              \\n        }\\n        return false;\\n    }\\n};\\nSince we are running two loops. Hence time Complexity O(n^2) and ofcourse TLE again :(\\n\\n```\\n\\nFinally we will now try to optimize to O(n).\\nNow as we notice we need the middle number as largest than both no and last number is less than largest but greater than the first. \\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack<int> s;\\n        int n=nums.size();\\n        int var2=INT_MIN;\\n        for(int i=n-1;i>=0;i--){\\n            if(var2>nums[i]) return true;\\n            while(!s.empty() && nums[i]>s.top()){\\n                var2=s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n      int n=nums.size();\\n      for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              for(int k=j+1;k<n;k++)\\n              {\\n                  if(nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n              }\\n          }\\n      }\\n        return false;\\n    }\\n};\\nSince we are running three loops. Hence time Complexity O(n^3) and ofcourse TLE :(\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       \\n        int temp=nums[0];\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                      if(nums[j]>temp && nums[j]<nums[i])\\n                          return true;\\n                }\\n                temp=min(temp,nums[i]);\\n            \\n              \\n        }\\n        return false;\\n    }\\n};\\nSince we are running two loops. Hence time Complexity O(n^2) and ofcourse TLE again :(\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack<int> s;\\n        int n=nums.size();\\n        int var2=INT_MIN;\\n        for(int i=n-1;i>=0;i--){\\n            if(var2>nums[i]) return true;\\n            while(!s.empty() && nums[i]>s.top()){\\n                var2=s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016872,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        if( n < 3 ) return false;\\n        \\n        int mins[n];\\n        mins[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            mins[i] = min(mins[i-1], nums[i]);\\n        }\\n        \\n        stack<int> st;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            while( st.empty()==false && st.top() <= mins[i] ) st.pop();\\n\\n            if( st.empty()==false && st.top() < nums[i] ) return true;\\n\\n            st.push(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        if( n < 3 ) return false;\\n        \\n        int mins[n];\\n        mins[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            mins[i] = min(mins[i-1], nums[i]);\\n        }\\n        \\n        stack<int> st;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            while( st.empty()==false && st.top() <= mins[i] ) st.pop();\\n\\n            if( st.empty()==false && st.top() < nums[i] ) return true;\\n\\n            st.push(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016218,
                "title": "easiest-python-solution-with-stack",
                "content": "***Code with approach***\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n\\t\"\"\" Monotonic decreasing stack \"\"\"\\n        st=[] \\n\\t\\t\"\"\" Assume first element as minimum\"\"\"\\n        minn=nums[0]\\n        for i in nums[1:]:\\n\\t\\t\\t\"\"\" We try to maintain the highest value at the top of the stacksuch that it is greater than i too .\"\"\"\\n            while st and i>=st[-1][0]:\\n                st.pop()\\n\\t\\t\\t\"\"\" Below statement defines i>st[-1][1] i.e.,  we have founded a value (i) which is greater than st[-1][1]\\n\\t\\t\\t(minimum) and and smaller than st[-1][0] . Here in this below statement i acts as k (given in question) as it \\n\\t\\t\\tis greater than st[-1][1] and less than st[-1][0] . st[-1][1] acts as i(in question) and st[-1][0] acts as j(in \\n\\t\\t\\tquestion) as it has highest value among all.\"\"\"\\n            if st and i>st[-1][1]:\\n                return True\\n\\t\\t\\t\"\"\" Appending value and minimum value in stack. Here minn acts as i for the given question i.e., i<j<k \"\"\"\\n            st.append([i,minn])\\n\\t\\t\\t\"\"\" Updating minimum value \"\"\"\\n            minn=min(minn,i)\\n        return False\\n```\\n\\n***Full Code Implementation***\\n\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        st=[]\\n        minn=nums[0]\\n        for i in nums[1:]:\\n            while st and i>=st[-1][0]:\\n                st.pop()\\n            if st and i>st[-1][1]:\\n                return True\\n            st.append([i,minn])\\n            minn=min(minn,i)\\n        return False\\n```\\nIf you still have doubt just solve [3,5,0,3,4] test case with pen and paper. It makes easier you to visualise the implementation.\\n**Please Upvote if it helps.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n\\t\"\"\" Monotonic decreasing stack \"\"\"\\n        st=[] \\n\\t\\t\"\"\" Assume first element as minimum\"\"\"\\n        minn=nums[0]\\n        for i in nums[1:]:\\n\\t\\t\\t\"\"\" We try to maintain the highest value at the top of the stacksuch that it is greater than i too .\"\"\"\\n            while st and i>=st[-1][0]:\\n                st.pop()\\n\\t\\t\\t\"\"\" Below statement defines i>st[-1][1] i.e.,  we have founded a value (i) which is greater than st[-1][1]\\n\\t\\t\\t(minimum) and and smaller than st[-1][0] . Here in this below statement i acts as k (given in question) as it \\n\\t\\t\\tis greater than st[-1][1] and less than st[-1][0] . st[-1][1] acts as i(in question) and st[-1][0] acts as j(in \\n\\t\\t\\tquestion) as it has highest value among all.\"\"\"\\n            if st and i>st[-1][1]:\\n                return True\\n\\t\\t\\t\"\"\" Appending value and minimum value in stack. Here minn acts as i for the given question i.e., i<j<k \"\"\"\\n            st.append([i,minn])\\n\\t\\t\\t\"\"\" Updating minimum value \"\"\"\\n            minn=min(minn,i)\\n        return False\\n```\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        st=[]\\n        minn=nums[0]\\n        for i in nums[1:]:\\n            while st and i>=st[-1][0]:\\n                st.pop()\\n            if st and i>st[-1][1]:\\n                return True\\n            st.append([i,minn])\\n            minn=min(minn,i)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016038,
                "title": "c-100-34ms-o-n-optimized-monotonic-stack",
                "content": "From the core logic this is like any other monotonic stack based solution, but I have added two optimizations:\\n\\n  * Use a ```vector<>``` instead of ```stack<>``` so we can call ```reserve()``` on it, to avoid re-allocation. We could have used a something like that to use the stack interface: \\n``` \\n\\t\\tvector<pair<int, int>> st_c;\\n        st_c.reserve(size(nums) + 1);\\n        stack<pair<int, int>, vector<pair<int,int>>> st(std::move(st_c));\\n```\\n  * Insert a sentinel (dummy) value at bottom of the stack to avoid calls to ```empty()```.\\n\\n```\\n  bool find132pattern(vector<int>& nums) {\\n        if (size(nums) < 3) return false;\\n        \\n        int cur_min = numeric_limits<int>::max();\\n        vector<pair<int, int>> st;\\n        st.reserve(size(nums) + 1);  // avoid re-allocations\\n        st.push_back({cur_min, cur_min});  // dummy value, to avoid check for empty(st)\\n        for (int num : nums) {\\n            while (st.back().first <= num) st.pop_back();\\n            \\n            if (st.back().second < num) return true;\\n            \\n            st.push_back({num, cur_min});\\n            cur_min = min(cur_min, num);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```vector<>```\n```stack<>```\n```reserve()```\n``` \\n\\t\\tvector<pair<int, int>> st_c;\\n        st_c.reserve(size(nums) + 1);\\n        stack<pair<int, int>, vector<pair<int,int>>> st(std::move(st_c));\\n```\n```empty()```\n```\\n  bool find132pattern(vector<int>& nums) {\\n        if (size(nums) < 3) return false;\\n        \\n        int cur_min = numeric_limits<int>::max();\\n        vector<pair<int, int>> st;\\n        st.reserve(size(nums) + 1);  // avoid re-allocations\\n        st.push_back({cur_min, cur_min});  // dummy value, to avoid check for empty(st)\\n        for (int num : nums) {\\n            while (st.back().first <= num) st.pop_back();\\n            \\n            if (st.back().second < num) return true;\\n            \\n            st.push_back({num, cur_min});\\n            cur_min = min(cur_min, num);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015987,
                "title": "daily-leetcoding-cahllenge-easy-python-solution",
                "content": "\\n\\t def find132pattern(self, nums: List[int]) -> bool:\\n        stk = []\\n        m = nums[0]\\n\\n        for n in nums[1:]:\\n            while stk and n >= stk[-1][0]:\\n                stk.pop()\\n            \\n            if stk and n > stk[-1][1]:\\n                return True\\n            \\n            stk.append([n,m])\\n            m = min(m,n)\\n            \\n        return False\\n\\t\\t\\n\\t\\t #please up vote \\uD83E\\uDD17\\uD83E\\uDD17",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "\\n\\t def find132pattern(self, nums: List[int]) -> bool:\\n        stk = []\\n        m = nums[0]\\n\\n        for n in nums[1:]:\\n            while stk and n >= stk[-1][0]:\\n                stk.pop()\\n            \\n            if stk and n > stk[-1][1]:\\n                return True\\n            \\n            stk.append([n,m])\\n            m = min(m,n)\\n            \\n        return False\\n\\t\\t\\n\\t\\t #please up vote \\uD83E\\uDD17\\uD83E\\uDD17",
                "codeTag": "Python3"
            },
            {
                "id": 2015332,
                "title": "132-pattern-java-solution-full-explanation",
                "content": "**Second approach is the accepted solution...**\\nApproach 1: Brute Force. Just iterate through the array and generate all triplets of i<j<k and check for the condition.\\n```\\nclass Solution \\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            for(int j=i+1;j<nums.length-1;j++)\\n            {\\n                for(int k=j+1;k<nums.length;k++)\\n                {\\n                    if(nums[i]<nums[k] && nums[i]<nums[j] && nums[k]<nums[j])\\n                    {\\n                        return true;   \\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Approach 2: Using Stack**\\n```\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        if(nums == null || nums.length < 3) \\n            return false;\\n        \\n        \\n         int num = Integer.MIN_VALUE;\\n         Stack<Integer> stk = new Stack();\\n         for(int i = nums.length-1;i>=0;i--)\\n         {\\n             if(nums[i]<num) \\n                 return true;  // nums[i] < nums[k] , and nums[j] was chosen in previous iteration so given condition reached \\n              while(!stk.isEmpty() && nums[i]>stk.peek())\\n              {//nums[i] = nums[j]\\n                 num = stk.pop(); // always bigger than previous num\\n             }\\n             stk.push(nums[i]);\\n         }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            for(int j=i+1;j<nums.length-1;j++)\\n            {\\n                for(int k=j+1;k<nums.length;k++)\\n                {\\n                    if(nums[i]<nums[k] && nums[i]<nums[j] && nums[k]<nums[j])\\n                    {\\n                        return true;   \\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        if(nums == null || nums.length < 3) \\n            return false;\\n        \\n        \\n         int num = Integer.MIN_VALUE;\\n         Stack<Integer> stk = new Stack();\\n         for(int i = nums.length-1;i>=0;i--)\\n         {\\n             if(nums[i]<num) \\n                 return true;  // nums[i] < nums[k] , and nums[j] was chosen in previous iteration so given condition reached \\n              while(!stk.isEmpty() && nums[i]>stk.peek())\\n              {//nums[i] = nums[j]\\n                 num = stk.pop(); // always bigger than previous num\\n             }\\n             stk.push(nums[i]);\\n         }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015200,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& v) {\\n        \\n        multiset<int> s,ss(v.begin(),v.end());\\n        for(int i=0; i<v.size(); ++i)\\n        {\\n            ss.erase(ss.find(v[i]));\\n            auto ix = s.upper_bound(v[i]-1);\\n            auto ixx = ss.upper_bound(v[i]-1);\\n            if(ix!=s.begin() && ixx!=ss.begin()){\\n                ixx--;\\n                if(*s.begin()<*ixx)\\n                    return 1;\\n            }\\n            \\n            s.insert(v[i]);\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& v) {\\n        \\n        multiset<int> s,ss(v.begin(),v.end());\\n        for(int i=0; i<v.size(); ++i)\\n        {\\n            ss.erase(ss.find(v[i]));\\n            auto ix = s.upper_bound(v[i]-1);\\n            auto ixx = ss.upper_bound(v[i]-1);\\n            if(ix!=s.begin() && ixx!=ss.begin()){\\n                ixx--;\\n                if(*s.begin()<*ixx)\\n                    return 1;\\n            }\\n            \\n            s.insert(v[i]);\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015175,
                "title": "c-hashmap-easy-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2) return false;\\n        \\n        int mn = nums[0];\\n        \\n        map<int, int> m;\\n\\t\\t//i starts from 2 as 0 given to mn(i.e nums[i]) and 1 will be given to nums[j] (as prescribed in question)\\n        for(int i=2; i<n; i++) m[nums[i]]++;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n\\t\\t\\t//read this after reading the below two cases\\n\\t\\t\\t//ith element is removed from hashmap as it is used as nums[j] element specified in question (if it is used)\\n            m[nums[i]]--;\\n\\t\\t\\t\\n\\t\\t\\t//remove the element from hashmap inorder to get the right results when finding the upper bound\\n            if(m[nums[i]] == 0) m.erase(nums[i]);\\n\\t\\t\\t\\n\\t\\t\\t//we just have to look in the right side of the array for a number which follow\\'s nums[k] criteria as specified in question\\n            if(nums[i] > mn)\\n            {\\n                auto el = m.upper_bound(mn);\\n                \\n                if(el != m.end() && el->first < nums[i]) return true;\\n            }\\n\\t\\t\\t//store minimum in mn traversed till now\\n            else \\n            {\\n                mn = min(mn, nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2) return false;\\n        \\n        int mn = nums[0];\\n        \\n        map<int, int> m;\\n\\t\\t//i starts from 2 as 0 given to mn(i.e nums[i]) and 1 will be given to nums[j] (as prescribed in question)\\n        for(int i=2; i<n; i++) m[nums[i]]++;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n\\t\\t\\t//read this after reading the below two cases\\n\\t\\t\\t//ith element is removed from hashmap as it is used as nums[j] element specified in question (if it is used)\\n            m[nums[i]]--;\\n\\t\\t\\t\\n\\t\\t\\t//remove the element from hashmap inorder to get the right results when finding the upper bound\\n            if(m[nums[i]] == 0) m.erase(nums[i]);\\n\\t\\t\\t\\n\\t\\t\\t//we just have to look in the right side of the array for a number which follow\\'s nums[k] criteria as specified in question\\n            if(nums[i] > mn)\\n            {\\n                auto el = m.upper_bound(mn);\\n                \\n                if(el != m.end() && el->first < nums[i]) return true;\\n            }\\n\\t\\t\\t//store minimum in mn traversed till now\\n            else \\n            {\\n                mn = min(mn, nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749921,
                "title": "easy-and-different-than-editorial-stack-java-o-n-iterate-from-1st-to-last",
                "content": "Please **upvote** if you find it usefull.\\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        \\n        int len = nums.length;\\n        \\n        // For each element, store the minimum element that exists on left side.\\n        int[] min = new int[len];\\n        min[0] = nums[0];\\n        for (int i = 1; i < len; i++) {\\n            min[i] = Math.min(min[i - 1], nums[i]);\\n        }\\n        \\n        Stack<Integer> stack = new Stack();\\n        for (int k = 0; k < len; ) {\\n            if (stack.size() == 0) {\\n                stack.add(k++);\\n            }\\n            else if (nums[stack.peek()] > nums[k]) { \\n                // Top element is greater than cur element => top = j, cur = k\\n                \\n                // If there exists i for the top element then we found a triplet.\\n                if (min[stack.peek()] < nums[k]) {\\n                    return true;\\n                }\\n                \\n                // Add cur to stack(stack will always have elements in dec order).\\n                stack.add(k++);\\n            }\\n            else {\\n                /* \\n                    If top element is smaller, thus indicating that \\n                    there is no element on left side that is greater \\n                    than cur element.\\n                    \\n                    Now, we will remove all elements from stack\\n                    that are smaller than cur. \\n                    \\n                    As they will not contribute to any future cur element as j.\\n                    Because we just found a new element that is larger than\\n                    all of them and can be used for j for future cur\\'s.\\n                */\\n                while (stack.size() > 0 && nums[stack.peek()] <= nums[k]) {\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        \\n        int len = nums.length;\\n        \\n        // For each element, store the minimum element that exists on left side.\\n        int[] min = new int[len];\\n        min[0] = nums[0];\\n        for (int i = 1; i < len; i++) {\\n            min[i] = Math.min(min[i - 1], nums[i]);\\n        }\\n        \\n        Stack<Integer> stack = new Stack();\\n        for (int k = 0; k < len; ) {\\n            if (stack.size() == 0) {\\n                stack.add(k++);\\n            }\\n            else if (nums[stack.peek()] > nums[k]) { \\n                // Top element is greater than cur element => top = j, cur = k\\n                \\n                // If there exists i for the top element then we found a triplet.\\n                if (min[stack.peek()] < nums[k]) {\\n                    return true;\\n                }\\n                \\n                // Add cur to stack(stack will always have elements in dec order).\\n                stack.add(k++);\\n            }\\n            else {\\n                /* \\n                    If top element is smaller, thus indicating that \\n                    there is no element on left side that is greater \\n                    than cur element.\\n                    \\n                    Now, we will remove all elements from stack\\n                    that are smaller than cur. \\n                    \\n                    As they will not contribute to any future cur element as j.\\n                    Because we just found a new element that is larger than\\n                    all of them and can be used for j for future cur\\'s.\\n                */\\n                while (stack.size() > 0 && nums[stack.peek()] <= nums[k]) {\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156350,
                "title": "c-code-using-stack-in-o-n",
                "content": "```\\nApproach: Put the minimum of all the elemnts from left to right in an array and consider every element of original array as middle of the pattern and then compare it ,\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini[n];\\n        mini[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            mini[i]=min(mini[i-1],nums[i]);\\n        }\\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(nums[i]>mini[i])\\n            {\\n                while(s.empty()==false && s.top()<=mini[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.empty()==false && s.top()<nums[i])\\n                {\\n                    return 1;\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nApproach: Put the minimum of all the elemnts from left to right in an array and consider every element of original array as middle of the pattern and then compare it ,\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini[n];\\n        mini[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            mini[i]=min(mini[i-1],nums[i]);\\n        }\\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(nums[i]>mini[i])\\n            {\\n                while(s.empty()==false && s.top()<=mini[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.empty()==false && s.top()<nums[i])\\n                {\\n                    return 1;\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151665,
                "title": "java-stack-and-left-greatest-approach-o-n",
                "content": "class Solution {\\n    public boolean find132pattern(int[] nums) {\\n\\t\\n        if(nums.length<3)\\n            return false;\\n        \\n        int min=Integer.MAX_VALUE;\\n        int leftSmallest[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            min=Math.min(min,nums[i]);\\n            leftSmallest[i]=min;\\n        }\\n            \\n        Stack<Integer> stk=new Stack<>();\\n        stk.push(nums[nums.length-1]);\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            int val=nums[i];\\n            int leftSmall=leftSmallest[i];\\n            if(val!=leftSmall)\\n            {\\n                while(stk.size()>0 && val>stk.peek())\\n                {\\n                    int v3=stk.pop();\\n                    if(leftSmall<v3 && v3<val)\\n                        return true;\\n                }   \\n            }\\n                stk.push(val);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean find132pattern(int[] nums) {\\n\\t\\n        if(nums.length<3)\\n            return false;\\n        \\n        int min=Integer.MAX_VALUE;\\n        int leftSmallest[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            min=Math.min(min,nums[i]);\\n            leftSmallest[i]=min;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 974226,
                "title": "can-someone-please-explain-to-me-why-my-code-is-failing-for-this-testcase",
                "content": "\\'\\'\\'\\n\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3)return false;\\n        int var1=0,var2=0,var3=0,len=0;\\n        Stack <Integer> st=new Stack<> ();\\n        for(int i=0;i<nums.length;++i)\\n        {\\n            st.push(nums[i]);\\n            var1=var2;\\n            var2=var3;\\n            var3=nums[i];\\n            len++;\\n            st.push(var3);\\n            if((len>=3)&&(var1<var3)&&(var3<var2))return true;\\n        }\\n         return false;\\n    }\\n\\'\\'\\'\\n\\n\\nThe test case number is 84/101\\n and it is as follows\\n nums=[3,5,0,3,4] and output is expected to be true\\n but my code gives answer as false and it should be false since the only 3 sequences for 132 pattern are [3,0,5],[5,3,0],[0,4,3] and all give answers false for nums[i]<nums[k]<nums[j] and so it should be false but it gives true output in expected section of this testcase.**Please Guide Me if I am wrong**",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3)return false;\\n        int var1=0,var2=0,var3=0,len=0;\\n        Stack <Integer> st=new Stack<> ();\\n        for(int i=0;i<nums.length;++i)\\n        {\\n            st.push(nums[i]);\\n            var1=var2;\\n            var2=var3;\\n            var3=nums[i];\\n            len++;\\n            st.push(var3);\\n            if((len>=3)&&(var1<var3)&&(var3<var2))return true;\\n        }\\n         return false;\\n    }\\n\\'\\'\\'\\n\\n\\nThe test case number is 84/101\\n and it is as follows\\n nums=[3,5,0,3,4] and output is expected to be true\\n but my code gives answer as false and it should be false since the only 3 sequences for 132 pattern are [3,0,5],[5,3,0],[0,4,3] and all give answers false for nums[i]<nums[k]<nums[j] and so it should be false but it gives true output in expected section of this testcase.**Please Guide Me if I am wrong**",
                "codeTag": "Unknown"
            },
            {
                "id": 910630,
                "title": "c-132-pattern",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 907508,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=xV-QDXn9Brc)\\nhttps://www.youtube.com/watch?v=xV-QDXn9Brc\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        # i , j, k\\n        # i -> get val from min_list\\n        # j -> iterate through nums for each j val : nums[indx]\\n        # k -> get vals using stack\\n        min_list = []\\n        stack = []\\n        \\n        # Building Min list\\n        min_list.append(nums[0])\\n        \\n        for i in range(1,len(nums)):\\n            min_list.append(min(nums[:i]))\\n        \\n        # checking for valid patterns\\n        for j in range(len(nums) - 1, -1, -1):\\n            if nums[j] > min_list[j]:\\n                \\n                while stack and stack[-1] <= min_list[j]:\\n                    stack.pop()\\n                \\n                if stack and stack[-1] < nums[j]:\\n                    return True\\n                \\n                stack.append(nums[j])\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        # i , j, k\\n        # i -> get val from min_list\\n        # j -> iterate through nums for each j val : nums[indx]\\n        # k -> get vals using stack\\n        min_list = []\\n        stack = []\\n        \\n        # Building Min list\\n        min_list.append(nums[0])\\n        \\n        for i in range(1,len(nums)):\\n            min_list.append(min(nums[:i]))\\n        \\n        # checking for valid patterns\\n        for j in range(len(nums) - 1, -1, -1):\\n            if nums[j] > min_list[j]:\\n                \\n                while stack and stack[-1] <= min_list[j]:\\n                    stack.pop()\\n                \\n                if stack and stack[-1] < nums[j]:\\n                    return True\\n                \\n                stack.append(nums[j])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907407,
                "title": "c-solution-o-n-97-runtime-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& a) {\\n        int n=a.size();\\n        stack<int> s;\\n        vector<int> m(n);\\n        m[0]=a[0];\\n        for(int i=1;i<n;i++){\\n            m[i]=min(m[i-1],a[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]>m[i]){\\n                while(s.size()&&s.top()<=m[i])s.pop();\\n                if(s.size()&&s.top()<a[i])return 1;\\n                s.push(a[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& a) {\\n        int n=a.size();\\n        stack<int> s;\\n        vector<int> m(n);\\n        m[0]=a[0];\\n        for(int i=1;i<n;i++){\\n            m[i]=min(m[i-1],a[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]>m[i]){\\n                while(s.size()&&s.top()<=m[i])s.pop();\\n                if(s.size()&&s.top()<a[i])return 1;\\n                s.push(a[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907323,
                "title": "easy-c-o-nlogn-solution-using-set-and-prefix-array",
                "content": "Since I found most of the solutions using stack so I thought of adding my solution here in which I have used set:\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        \\n        int *prefix = new int[n]();\\n        \\n        prefix[0] = nums[0];\\n        \\n        \\n        for(int i = 1 ;i<n ; i++){\\n            \\n            prefix[i] = min(prefix[i - 1] , nums[i]);\\n        }\\n        \\n        \\n        set<int> s;\\n        \\n        s.insert(nums[n - 1]);\\n        \\n        for(int i = n - 2 ; i >=0  ; i--){\\n            \\n            auto it = s.lower_bound(nums[i]);\\n            \\n            if(it!= s.begin()){\\n                \\n                it--;\\n                if(*it > prefix[i]){\\n                    return true;\\n                }\\n            }\\n            \\n            s.insert(nums[i]);\\n            \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        \\n        int *prefix = new int[n]();\\n        \\n        prefix[0] = nums[0];\\n        \\n        \\n        for(int i = 1 ;i<n ; i++){\\n            \\n            prefix[i] = min(prefix[i - 1] , nums[i]);\\n        }\\n        \\n        \\n        set<int> s;\\n        \\n        s.insert(nums[n - 1]);\\n        \\n        for(int i = n - 2 ; i >=0  ; i--){\\n            \\n            auto it = s.lower_bound(nums[i]);\\n            \\n            if(it!= s.begin()){\\n                \\n                it--;\\n                if(*it > prefix[i]){\\n                    return true;\\n                }\\n            }\\n            \\n            s.insert(nums[i]);\\n            \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767733,
                "title": "java-short-stack-solution",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length < 3) return false;\\n        Stack<Integer> stack = new Stack<>();\\n        int second = -Integer.MAX_VALUE;\\n        \\n        for(int i=nums.length-1; i>-1; i--){\\n            if(nums[i] < second) return true;\\n            while(stack.size() > 0 && nums[i] > stack.peek()){\\n                second = stack.pop();\\n            }\\n            stack.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length < 3) return false;\\n        Stack<Integer> stack = new Stack<>();\\n        int second = -Integer.MAX_VALUE;\\n        \\n        for(int i=nums.length-1; i>-1; i--){\\n            if(nums[i] < second) return true;\\n            while(stack.size() > 0 && nums[i] > stack.peek()){\\n                second = stack.pop();\\n            }\\n            stack.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699373,
                "title": "nlogn-treeset-solution-in-java",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        \\n        //define data structures\\n        int[] left_min = new int[nums.length];\\n        \\n        //expand from center\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++){\\n            left_min[i] = min;\\n            min = Math.min(min, nums[i]);\\n        }\\n        \\n        \\n        //find 132 pattern\\n        TreeSet right_max = new TreeSet();\\n        for (int k = nums.length-1; k >= 0; k--){\\n            Integer max = (Integer)right_max.lower(nums[k]);\\n            if (max != null && max > left_min[k]){\\n                return true;\\n            }\\n            right_max.add(nums[k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        \\n        //define data structures\\n        int[] left_min = new int[nums.length];\\n        \\n        //expand from center\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++){\\n            left_min[i] = min;\\n            min = Math.min(min, nums[i]);\\n        }\\n        \\n        \\n        //find 132 pattern\\n        TreeSet right_max = new TreeSet();\\n        for (int k = nums.length-1; k >= 0; k--){\\n            Integer max = (Integer)right_max.lower(nums[k]);\\n            if (max != null && max > left_min[k]){\\n                return true;\\n            }\\n            right_max.add(nums[k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546136,
                "title": "456-132-pattern-python3",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        if len(set(nums)) < 3:\\n            return False\\n\\n        min_nums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            min_nums.append(min(nums[i], min_nums[-1]))\\n            \\n        stack = []\\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] > min_nums[i]:\\n                while stack and stack[-1] <= min_nums[i]:\\n                    stack.pop()\\n                if stack and stack[-1] < nums[i]:\\n                    return True\\n                else:\\n                    stack.append(nums[i])\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        if len(set(nums)) < 3:\\n            return False\\n\\n        min_nums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            min_nums.append(min(nums[i], min_nums[-1]))\\n            \\n        stack = []\\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] > min_nums[i]:\\n                while stack and stack[-1] <= min_nums[i]:\\n                    stack.pop()\\n                if stack and stack[-1] < nums[i]:\\n                    return True\\n                else:\\n                    stack.append(nums[i])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507036,
                "title": "monotonic-stack",
                "content": "this problem can be solved by monotonic stack\\nalso see the monotonic queue, e.g. sliding window max\\n        \\nwe use a stack \\nthe stack is monotonically decreased from front to end (left to right)\\n        \\nwe visit the nums from right to left\\ngiven nums[i], we assume it is the \"3\" in \"132\" pattern\\n        \\nwhen we push an element, and the element is small than the end, we push it in\\nHowever, if the element is large than the end, we pop the end, and repeat the process until we push the element in the stack\\n        \\nthe last poped out value is the \"2\" in the \"132\" pattern\\nwhen we visit nums[i-1], we compare if it is the \"1\" by comparing it with the last poped out value\\n\\n```python\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t\\n        deq = collections.deque()\\n        num2 = None\\n        \\n        for n in nums[::-1]:\\n            if num2 is not None and n < num2:\\n                return True\\n            while deq and deq[-1] < n:\\n                num2 = deq.pop()\\n            deq.append(n)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t\\n        deq = collections.deque()\\n        num2 = None\\n        \\n        for n in nums[::-1]:\\n            if num2 is not None and n < num2:\\n                return True\\n            while deq and deq[-1] < n:\\n                num2 = deq.pop()\\n            deq.append(n)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431675,
                "title": "c-easy-to-understand-o-n-solution-using-stack",
                "content": "1) Use stack to keep the track of largest element in the array starting from right. At the same time whenever we see a element larger than the top of the stack we pop all the elements in the stack and make a_k (3 element in 132 pattern) equal to maximum of all the popped element. What this basically does is that at any point stack top will have the largest element, a_k will have the second largest element and if we find a number such that a_k > nums[i], we have found the 132 pattern.\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int a_k = INT_MIN;\\n        stack<int> stk;\\n        \\n        for(int i = nums.size()-1; i >= 0; i--) {\\n            while(!stk.empty() && stk.top() < nums[i]) {\\n                a_k = max(a_k,stk.top());\\n                stk.pop();\\n            }\\n            \\n            if(a_k != INT_MIN && a_k > nums[i]) return true;\\n            \\n            stk.push(nums[i]);\\n        }\\n    \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int a_k = INT_MIN;\\n        stack<int> stk;\\n        \\n        for(int i = nums.size()-1; i >= 0; i--) {\\n            while(!stk.empty() && stk.top() < nums[i]) {\\n                a_k = max(a_k,stk.top());\\n                stk.pop();\\n            }\\n            \\n            if(a_k != INT_MIN && a_k > nums[i]) return true;\\n            \\n            stk.push(nums[i]);\\n        }\\n    \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352457,
                "title": "c-maintain-a-stack-and-a3",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int a3 = INT_MIN;\\n        stack<int> stk;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < a3) {\\n                return true;\\n            }\\n            while (!stk.empty() && nums[stk.top()] < nums[i]) {\\n                int cur = stk.top();\\n                stk.pop();\\n                a3 = max(a3, nums[cur]);\\n            }\\n            stk.push(i);\\n        }\\n        return false;\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int a3 = INT_MIN;\\n        stack<int> stk;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < a3) {\\n                return true;\\n            }\\n            while (!stk.empty() && nums[stk.top()] < nums[i]) {\\n                int cur = stk.top();\\n                stk.pop();\\n                a3 = max(a3, nums[cur]);\\n            }\\n            stk.push(i);\\n        }\\n        return false;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229710,
                "title": "python-using-stack",
                "content": "```\\ndef find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        j ,stack  = float(\"-inf\"), []\\n        for num in nums[::-1]:\\n            if num < j: return True\\n            while stack and stack[-1] < num: j = stack.pop()\\n            stack.append(num)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        j ,stack  = float(\"-inf\"), []\\n        for num in nums[::-1]:\\n            if num < j: return True\\n            while stack and stack[-1] < num: j = stack.pop()\\n            stack.append(num)\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3811136,
                "title": "java-solution-very-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n\\n\\t\\t\\t\\tint thirdEle = Integer.MIN_VALUE;\\n\\n\\t\\t\\t\\tfor(int i = nums.length - 1; i >= 0; i--){\\n\\t\\t\\t\\t\\tif(nums[i] < thirdEle) return true;\\n\\n\\t\\t\\t\\t\\twhile(!st.isEmpty() && nums[i] > st.peek()){\\n\\t\\t\\t\\t\\t\\tthirdEle = st.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.push(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n\\n\\t\\t\\t\\tint thirdEle = Integer.MIN_VALUE;\\n\\n\\t\\t\\t\\tfor(int i = nums.length - 1; i >= 0; i--){\\n\\t\\t\\t\\t\\tif(nums[i] < thirdEle) return true;\\n\\n\\t\\t\\t\\t\\twhile(!st.isEmpty() && nums[i] > st.peek()){\\n\\t\\t\\t\\t\\t\\tthirdEle = st.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.push(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046487,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find if there is a subsequence of integers in the given vector that follows the pattern 1-3-2, where the integers in the subsequence are in strictly increasing order. The first integer is referred as 1, the second integer as 3 and the third as 2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in this solution is to first find the minimum element up to each index in the given vector, and store it in a separate vector called min. Then, the solution iterates through the given vector in reverse order, and for each element, checks if it is greater than the minimum element up to that index. If it is, the solution uses a stack to check if there is a number that is smaller than the current element and greater than the minimum element up to that index, which would satisfy the 1-3-2 pattern.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 3) return false;\\n        vector<int> min(n);\\n        min[0] = nums[0];\\n        for (int i = 1; i < n; ++i) {\\n            min[i] = min[i - 1] < nums[i] ? min[i - 1] : nums[i];\\n        }\\n        stack<int> s;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (nums[i] > min[i]) {\\n                while (!s.empty() && s.top() <= min[i]) {\\n                    s.pop();\\n                }\\n                if (!s.empty() && s.top() < nums[i]) {\\n                    return true;\\n                }\\n                s.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 3) return false;\\n        vector<int> min(n);\\n        min[0] = nums[0];\\n        for (int i = 1; i < n; ++i) {\\n            min[i] = min[i - 1] < nums[i] ? min[i - 1] : nums[i];\\n        }\\n        stack<int> s;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (nums[i] > min[i]) {\\n                while (!s.empty() && s.top() <= min[i]) {\\n                    s.pop();\\n                }\\n                if (!s.empty() && s.top() < nums[i]) {\\n                    return true;\\n                }\\n                s.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917552,
                "title": "java-stack-clean-and-simple",
                "content": "# Please Upvote :D\\n\\n``` java []\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int secondMax = Integer.MIN_VALUE;\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < secondMax) {\\n                return true;\\n            }\\n            while (!st.isEmpty() && nums[i] > st.peek()) {\\n                secondMax = Math.max(secondMax, st.pop());\\n            }\\n            st.push(nums[i]);\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)`",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int secondMax = Integer.MIN_VALUE;\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < secondMax) {\\n                return true;\\n            }\\n            while (!st.isEmpty() && nums[i] > st.peek()) {\\n                secondMax = Math.max(secondMax, st.pop());\\n            }\\n            st.push(nums[i]);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673883,
                "title": "stack-easy-simple-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> s;\\n        int x = INT_MIN;\\n        for(int i = nums.size()-1; i>=0; i--){\\n            if(nums[i]<x){\\n                return true;\\n            }\\n            while(!s.empty() && nums[i]>s.top()){\\n                x = s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> s;\\n        int x = INT_MIN;\\n        for(int i = nums.size()-1; i>=0; i--){\\n            if(nums[i]<x){\\n                return true;\\n            }\\n            while(!s.empty() && nums[i]>s.top()){\\n                x = s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529025,
                "title": "single-pass-c-o-n-space-and-time-solution-8-lines-with-detailed-explanation",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int>s;\\n        int n=nums.size();\\n        int second =INT_MIN;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(nums[i]<second)\\n            {\\n                return true;\\n            }\\n            while(!s.empty() && nums[i]>s.top())\\n            {\\n                second=s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267348,
                "title": "c-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        int middle = INT_MIN;\\n        stack<int> st;\\n        for(int i=n-1; i>=0; i--){\\n            if(nums[i] < middle) return true;\\n            else {\\n                while(!st.empty() && st.top()<nums[i]){\\n                    middle = max(middle,st.top());\\n                    st.pop();\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        int middle = INT_MIN;\\n        stack<int> st;\\n        for(int i=n-1; i>=0; i--){\\n            if(nums[i] < middle) return true;\\n            else {\\n                while(!st.empty() && st.top()<nums[i]){\\n                    middle = max(middle,st.top());\\n                    st.pop();\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267347,
                "title": "98-tc-and-60-sc-easy-python-solution-using-stack",
                "content": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n\\tmid = -float(\\'inf\\')\\n\\ts = []\\n\\tfor i in nums[::-1]:\\n\\t\\tif(i < mid):\\n\\t\\t\\treturn 1\\n\\t\\twhile(s and s[-1] < i):\\n\\t\\t\\tmid = s.pop()\\n\\t\\ts.append(i)\\n\\treturn 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n\\tmid = -float(\\'inf\\')\\n\\ts = []\\n\\tfor i in nums[::-1]:\\n\\t\\tif(i < mid):\\n\\t\\t\\treturn 1\\n\\t\\twhile(s and s[-1] < i):\\n\\t\\t\\tmid = s.pop()\\n\\t\\ts.append(i)\\n\\treturn 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2215626,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> s = new Stack<>();\\n        int mid = Integer.MIN_VALUE;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int n = nums[i];\\n            if(mid>n)\\n                return true;\\n            while(!s.isEmpty() && s.peek()<n){\\n                mid = s.pop();\\n            }\\n            s.push(n);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> s = new Stack<>();\\n        int mid = Integer.MIN_VALUE;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int n = nums[i];\\n            if(mid>n)\\n                return true;\\n            while(!s.isEmpty() && s.peek()<n){\\n                mid = s.pop();\\n            }\\n            s.push(n);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029851,
                "title": "132-pattern-all-the-three-solutions-o-n-3-o-n-2-o-n-stack-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // // Method: 1 O(n^3)\\n        // for (int i = 0; i < n - 2; i++)\\n        // {\\n        //     for (int j = i + 1; j < n - 1; j++)\\n        //     {\\n        //         for (int k = j + 1; k < n; k++)\\n        //         {\\n        //             if (nums[i] < nums[k] && nums[k] < nums[j])\\n        //                 return true;\\n        //         }\\n        //     }\\n        // }\\n        // return false;\\n        \\n        // // Method: 2 O(n^2)\\n        // int mini = nums[0];\\n        // for (int j = 1; j < n - 1; j++)\\n        // {\\n        //     for (int k = j + 1; k < n; k++)\\n        //     {\\n        //         if (mini < nums[k] && nums[k] < nums[j])\\n        //             return true;\\n        //         mini = min(mini, nums[j]);\\n        //     }\\n        // }\\n        // return false;\\n        \\n        // Method: 3\\n        int third = INT_MIN;\\n        stack<int> st;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int ce = nums[i]; // First element\\n            if (ce < third)\\n                return true;\\n            else\\n            {\\n                while(!st.empty() && st.top() < ce)\\n                {\\n                    third = st.top(); // Keeping the minimium elem for third\\n                    st.pop();\\n                }\\n                st.push(ce);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // // Method: 1 O(n^3)\\n        // for (int i = 0; i < n - 2; i++)\\n        // {\\n        //     for (int j = i + 1; j < n - 1; j++)\\n        //     {\\n        //         for (int k = j + 1; k < n; k++)\\n        //         {\\n        //             if (nums[i] < nums[k] && nums[k] < nums[j])\\n        //                 return true;\\n        //         }\\n        //     }\\n        // }\\n        // return false;\\n        \\n        // // Method: 2 O(n^2)\\n        // int mini = nums[0];\\n        // for (int j = 1; j < n - 1; j++)\\n        // {\\n        //     for (int k = j + 1; k < n; k++)\\n        //     {\\n        //         if (mini < nums[k] && nums[k] < nums[j])\\n        //             return true;\\n        //         mini = min(mini, nums[j]);\\n        //     }\\n        // }\\n        // return false;\\n        \\n        // Method: 3\\n        int third = INT_MIN;\\n        stack<int> st;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int ce = nums[i]; // First element\\n            if (ce < third)\\n                return true;\\n            else\\n            {\\n                while(!st.empty() && st.top() < ce)\\n                {\\n                    third = st.top(); // Keeping the minimium elem for third\\n                    st.pop();\\n                }\\n                st.push(ce);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021091,
                "title": "java-stack-o-n-small-and-easily-understandable-code-with-explanation",
                "content": "```\\nsee u should find such a point where it is like it greater then 2 nos i & k and [i]<[k] that means u have to find a index nums[i]<nums[j]<nums[k] what that means if u find  a point where nums[j]>nums[k] &&  nums[k]>nums[i] ur work is done \\nhow will u find that it is simple just put every thing into a stack \\nYour questions arises why to use stack?\\nSee here first of all u have to compare the current element from the previous element continuously and also update the those element to see the pattern 132\\n\\nfor example if it is like [3,1,4,2,5] so what u can do is first put 5 into the stack \\nelements in the stack:5\\nthen comes 2 2<5 no need to pop the element becuse u have to find nums[j]>nums[k] not nums[k]<nums[j] so \\nelements in the stack:2 5\\nnow 4 comes in the game \\n4>2 so might be a possibility of getting nums[j]>nums[k] so put second element =4  and third element =4 and pop the 2 and as 4<5 add 4 into the stack\\nthen comes 1 <third element && 1<second element so 1<4<2\\n```\\n```\\nclass Solution \\n{\\n    public boolean find132pattern(int[] nums)\\n    {\\n          Stack<Integer> st=new Stack<Integer>();\\n          int k=Integer.MIN_VALUE;\\n        int n=nums.length;\\n          for(int i=n-1;i>=0;i--)\\n          {\\n              if(nums[i]<k)\\n              {\\n                  return true;\\n              }\\n              while(st.isEmpty()==false && st.peek()<nums[i])\\n              {\\n                  k=st.pop();\\n              }\\n              st.add(nums[i]);\\n          }\\n        return false;\\n \\n    }\\n}\\n```\\n\\n\\n**PLS UPVOTE IF U LIKE THE SOLUTION**",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nsee u should find such a point where it is like it greater then 2 nos i & k and [i]<[k] that means u have to find a index nums[i]<nums[j]<nums[k] what that means if u find  a point where nums[j]>nums[k] &&  nums[k]>nums[i] ur work is done \\nhow will u find that it is simple just put every thing into a stack \\nYour questions arises why to use stack?\\nSee here first of all u have to compare the current element from the previous element continuously and also update the those element to see the pattern 132\\n\\nfor example if it is like [3,1,4,2,5] so what u can do is first put 5 into the stack \\nelements in the stack:5\\nthen comes 2 2<5 no need to pop the element becuse u have to find nums[j]>nums[k] not nums[k]<nums[j] so \\nelements in the stack:2 5\\nnow 4 comes in the game \\n4>2 so might be a possibility of getting nums[j]>nums[k] so put second element =4  and third element =4 and pop the 2 and as 4<5 add 4 into the stack\\nthen comes 1 <third element && 1<second element so 1<4<2\\n```\n```\\nclass Solution \\n{\\n    public boolean find132pattern(int[] nums)\\n    {\\n          Stack<Integer> st=new Stack<Integer>();\\n          int k=Integer.MIN_VALUE;\\n        int n=nums.length;\\n          for(int i=n-1;i>=0;i--)\\n          {\\n              if(nums[i]<k)\\n              {\\n                  return true;\\n              }\\n              while(st.isEmpty()==false && st.peek()<nums[i])\\n              {\\n                  k=st.pop();\\n              }\\n              st.add(nums[i]);\\n          }\\n        return false;\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017102,
                "title": "intuition-explaination-java-solution",
                "content": "Notations:\\n* Let I, J, K represent the numbers that satisfy our condition and are our answer\\n\\t* I = 1\\n\\t* J = 3\\n\\t* K = 2\\n* So condition 132 can be represented as\\n\\t* I < K < J\\n\\n# Brute Force\\nThis is similar to 3-Sum problem. \\n* I --> 0 TO n-1\\n\\t*  J --> I+1 TO n-1\\n\\t\\t*  K  --> J +1 TO n-1\\n\\t\\t\\t*  Test the condition ==> nums[I] < nums[K] < nums[J]\\n\\nTC: O(n cube) because of 3 loops\\nSC: O(1)\\n\\n# Brute Force improved\\nI see that element I could be minimum element encountered till now. Do I need a loop to get minimum element? No, I can just keep it in variable.\\nSo my logic changes to\\n* I = 0\\n* J = 1 to n-1\\n\\t* K = J+1 to n-1\\n\\t\\t* test the condition ==> nums[I] < nums[K] < nums[J]\\n\\t* I = J if nums[J] < nums[I]. This is needed to make sure I hold minimum element until J.\\n\\nTC: O(n squared). We just removed one loop.\\nSC: O(1)\\n\\n# Using a BST\\nIn brute force enhancement, we skipped I loop.\\nCan we somehow skip another loop - either J or K?\\n\\nFor a J, we just need to know if there exists a K satisfying the condition.\\nA BST can help if we have all elements after J in a BST. Search for an element smaller than elementJ, but larger than elementI would take only O(log n) time. Yep, that works.\\nBut for this we need to have all elements in BST that come after J.\\nWe could keep all elements in BST. We could remove element-I and element-J from BST. And then do our search.\\n\\nSo logic looks like this:\\n* dump all elements in BST\\n* elementI = nums[0]. So remove it from BST.\\n* J --> 1 to n-1\\n\\t* remove elementJ from BST\\n\\t* Now find an element in BST that is greater than element-I but less than element-J\\n\\t\\t* If we find, this is answer. Return true.\\n\\nTC: \\n* O(n log n) to populate BST.\\n* O(n) for J loop. And O(log n) to find K in BST. So total O(n log n) in J loop.\\n* Net Tc: O(n log n)\\n\\nSC: O(n) because we are storing the BST\\n\\nJava code:\\nI utilized a TreeMap to keep elements in BST and using a counter - because input has duplicates. Remove each element from TM using counter.\\n```\\n    public boolean find132pattern(int[] nums) {\\n        TreeMap<Integer, Integer> tm = new TreeMap();\\n        for(int num: nums) {\\n            tm.put(num, tm.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int elementI = nums[0];\\n        remove(elementI, tm);\\n        \\n        for(int j = 1; j < nums.length; j++) {\\n            int elementJ = nums[j];\\n            remove(elementJ, tm);\\n            Integer elementK = tm.floorKey(elementJ-1);\\n            if(elementK != null && elementI < elementK) {\\n                return true;\\n            }\\n            elementI = Integer.min(elementI, elementJ);\\n        }\\n        return false;\\n    }\\n\\n\\tprivate void remove(int num, TreeMap<Integer, Integer> tm) {\\n        tm.put(num, tm.get(num)-1);\\n        if(tm.get(num) == 0) {\\n            tm.remove(num);\\n        }\\n    }\\n```\\n\\n# Using monotonic stack\\nWell, I couldn\\'t think of this as an answer. \\nUsing BST my time taken was very high compared to others. So I looked at others code and wow. This answer would never come to me.\\nSo here I try to explain it.\\n\\nTC: amortized O(n). O(n squared) for increasing sequence.\\nWhile BST took 200ms, this solution took just 40ms.\\n\\nWhat is monotonic stack?\\nA stack whose elements are strictly increasing or decreasing.\\n\\nOur monotonic stack implementation keep smallest element on top, largest element on bottom. Like a pyramid.\\n\\nStack top represents J.\\nThe element just smaller than J will be ideal candidate for K - because then it can work for any I.\\nSince stack is monotonic, if we get an element > top, we will pop it. And since this element is less than element, its a good candidate for K. Just make sure that actual K is largest among all the candidates\\n\\nLogic:\\n* element-K = negative infinity\\n* I = n-1 to 0\\n\\t* IF element-I < element-K\\n\\t\\t* then this is the answer. Wait, what about J? Well, K is already less than J.\\n\\t* Pop all elements smaller than element-I from stack, and put element-I on top of stack. This is now our element-J.\\n\\t\\t* popped elements are candidates for element-K. So element-K is max among popped elements and itself.\\n\\nI know its difficult to understand. It was for me too. So lets take an example.\\nInput: 3,5,0,1,4\\n\\nLoop I is from last to first element.\\n\\n* element-K = negative infinity\\n* Loop: I = 4.\\n\\t* element-I = 4\\n\\t* element-I is not less than element-K\\n\\t* stack is empty. So no poping.\\n\\t* dump element-I on stack.\\n\\t* Finally\\n\\t\\t* Stack: 4\\n\\t\\t* element-K = negative infinity\\n* Loop: I = 3.\\n\\t* element-I = 1\\n\\t* element-I is not less than element-K\\n\\t* stack top is not less than element-I. So no poping.\\n\\t* dump element-I on stack.\\n\\t* Finally\\n\\t\\t* Stack: 4, 1\\n\\t\\t* element-K = negative infinity\\n* Loop: I = 2.\\n\\t* element-I = 0\\n\\t* element-I is not less than element-K\\n\\t* stack top is not less than element-I. So no poping.\\n\\t* dump element-I on stack.\\n\\t* Finally\\n\\t\\t* Stack: 4, 1, 0\\n\\t\\t* element-K = negative infinity\\n* Loop: I = 1.\\n\\t* element-I = 5\\n\\t* element-I is not less than element-K\\n\\t* stack top is less than element-I. So pop all elements from stack that are less than 5. All popped elements are candidate to be element-K\\n\\t* element-K is 4 since it was largest one on stack.\\n\\t* dump element-I on stack.\\n\\t* Finally\\n\\t\\t* Stack: 5\\n\\t\\t* element-K = 4\\n* Loop: I = 0.\\n\\t* element-I = 3\\n\\t* element-I is less than element-K\\n\\t\\t* condition is satisfied\\n\\nCode is here:\\n```\\n    public boolean find132pattern_fastest(int[] nums) {\\n        Stack<Integer> stack = new Stack();      // stack to keep elements with biggest on base, smallest on top.\\n                                                    // element on top of stack represents elementJ\\n                                                    // elementJ = stack.peek() at any given time.\\n        int elementK = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--) {\\n            int elementI = nums[i];\\n            \\n            // Test the condition that elementI < elementK < elementJ\\n            if(elementI < elementK) {   // then it is implicit that elementI < elementJ\\n                return true;\\n            }\\n            \\n            // okay, elementI >= elementK. So lets try to put it on stack - may be it is actually elementJ\\n            // since stack is a min stack - smallest element on top, biggest on bottom, lets try to pop all elements less than me. \\n            // Once I pop an elemnet - it means that is less than element. So they are candidate for elementK if they are greater than elementK.\\n            while(!stack.isEmpty() && elementI > stack.peek()) {\\n                int elementKCandidate = stack.pop();\\n                elementK = Integer.max(elementK, elementKCandidate);\\n            }\\n            \\n            stack.push(elementI);\\n        }\\n        return false;\\n    }\\n```\\n\\nI know I could have made code concise. But I made it to be elaborate to explain myself better.",
                "solutionTags": [],
                "code": "```\\n    public boolean find132pattern(int[] nums) {\\n        TreeMap<Integer, Integer> tm = new TreeMap();\\n        for(int num: nums) {\\n            tm.put(num, tm.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int elementI = nums[0];\\n        remove(elementI, tm);\\n        \\n        for(int j = 1; j < nums.length; j++) {\\n            int elementJ = nums[j];\\n            remove(elementJ, tm);\\n            Integer elementK = tm.floorKey(elementJ-1);\\n            if(elementK != null && elementI < elementK) {\\n                return true;\\n            }\\n            elementI = Integer.min(elementI, elementJ);\\n        }\\n        return false;\\n    }\\n\\n\\tprivate void remove(int num, TreeMap<Integer, Integer> tm) {\\n        tm.put(num, tm.get(num)-1);\\n        if(tm.get(num) == 0) {\\n            tm.remove(num);\\n        }\\n    }\\n```\n```\\n    public boolean find132pattern_fastest(int[] nums) {\\n        Stack<Integer> stack = new Stack();      // stack to keep elements with biggest on base, smallest on top.\\n                                                    // element on top of stack represents elementJ\\n                                                    // elementJ = stack.peek() at any given time.\\n        int elementK = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--) {\\n            int elementI = nums[i];\\n            \\n            // Test the condition that elementI < elementK < elementJ\\n            if(elementI < elementK) {   // then it is implicit that elementI < elementJ\\n                return true;\\n            }\\n            \\n            // okay, elementI >= elementK. So lets try to put it on stack - may be it is actually elementJ\\n            // since stack is a min stack - smallest element on top, biggest on bottom, lets try to pop all elements less than me. \\n            // Once I pop an elemnet - it means that is less than element. So they are candidate for elementK if they are greater than elementK.\\n            while(!stack.isEmpty() && elementI > stack.peek()) {\\n                int elementKCandidate = stack.pop();\\n                elementK = Integer.max(elementK, elementKCandidate);\\n            }\\n            \\n            stack.push(elementI);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2016698,
                "title": "time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        int thirdElement = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] < thirdElement) return true;\\n            while(!st.isEmpty() && st.peek() < nums[i]) thirdElement = st.pop();\\n            st.push(nums[i]);\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        int thirdElement = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] < thirdElement) return true;\\n            while(!st.isEmpty() && st.peek() < nums[i]) thirdElement = st.pop();\\n            st.push(nums[i]);\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016581,
                "title": "c-stack-detailed-explanation",
                "content": "# Approach\\n1. We create an increasing order stack (from top to bottom) traversing from back of the array.\\n2. If nums[i] is less than top of stack then we simply push it into the stack maintining its monotonicity. \\n3. If nums[i] is greater than the stack, then this could be our possible contender for J. \\n4. We find out the number just smaller than nums[i] in the stack. This will act as our K. And push nums[i] into the stack.\\n4. Now if at any point if nums[i] < K then we know that, there exist a value greater than K in the stack and now we have a value lesser than K. So we have our triplet. \\n\\n![image](https://assets.leetcode.com/users/images/15922eba-a83a-463c-b416-e2900f49b27c_1651931149.840722.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int i, sk = INT_MIN;\\n        stack<int> st;\\n        int n = nums.size();\\n        \\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(st.empty() || nums[i] < st.top())\\n                st.push(nums[i]);\\n            else if(nums[i] > st.top())\\n            {\\n                while(!st.empty() && nums[i] > st.top())\\n                {\\n                    sk = st.top();\\n                    st.pop();\\n                }\\n                st.push(nums[i]);\\n            }\\n            if(nums[i] < sk)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Please upvote if you liked the explanation.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int i, sk = INT_MIN;\\n        stack<int> st;\\n        int n = nums.size();\\n        \\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(st.empty() || nums[i] < st.top())\\n                st.push(nums[i]);\\n            else if(nums[i] > st.top())\\n            {\\n                while(!st.empty() && nums[i] > st.top())\\n                {\\n                    sk = st.top();\\n                    st.pop();\\n                }\\n                st.push(nums[i]);\\n            }\\n            if(nums[i] < sk)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016518,
                "title": "easy-to-understand-c-stack-solution",
                "content": "##### The biggest num will always stay in the stack and second one will stay on my second int ,if I can find nums[i] smaller than second than I can return true because I am searching from right to left\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> st;\\n        int s3 = INT_MIN;\\n        for(int i= nums.size()-1 ; i>=0; --i){\\n            if(nums[i]< s3) return true;\\n            else while(!st.empty() && nums[i] > st.top()){\\n                s3 = st.top();\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> st;\\n        int s3 = INT_MIN;\\n        for(int i= nums.size()-1 ; i>=0; --i){\\n            if(nums[i]< s3) return true;\\n            else while(!st.empty() && nums[i] > st.top()){\\n                s3 = st.top();\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016426,
                "title": "javascript-very-easy-solution",
                "content": "/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n    let arr = []\\n    \\n    let negative = -Infinity;\\n    \\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] < negative) {\\n            return true\\n        }\\n        \\n        \\n        while(arr.length > 0 && nums[i] > arr[arr.length - 1]) {\\n            negative = arr.pop()\\n        }\\n        \\n        arr.push(nums[i])\\n    }\\n    \\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n    let arr = []\\n    \\n    let negative = -Infinity;\\n    \\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] < negative) {\\n            return true\\n        }\\n        \\n        \\n        while(arr.length > 0 && nums[i] > arr[arr.length - 1]) {\\n            negative = arr.pop()\\n        }\\n        \\n        arr.push(nums[i])\\n    }\\n    \\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2016402,
                "title": "monotonic-stack-java-easy-solution",
                "content": "\\'\\'\\'\\n\\n\\n\\n\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        if(nums == null || nums.length < 3) \\n            return false;\\n        \\n        \\n         int s3 = Integer.MIN_VALUE; // to compare and update everytime we found new max     //after traverasing from back\\n         Stack<Integer> stk = new Stack();\\n         for(int i = nums.length-1;i>=0;i--)\\n         {\\n             if(nums[i]<s3) \\n                 return true;  \\n              while(!stk.isEmpty() && nums[i]>stk.peek())\\n              {\\n                 s3 = stk.pop(); // we have to pop that num and change s3 to that no.\\n             }\\n             stk.push(nums[i]);\\n         }\\n        return false;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "class Solution\\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        if(nums == null || nums.length < 3) \\n            return false;\\n        \\n        \\n         int s3 = Integer.MIN_VALUE; // to compare and update everytime we found new max     //after traverasing from back\\n         Stack<Integer> stk = new Stack();\\n         for(int i = nums.length-1;i>=0;i--)\\n         {\\n             if(nums[i]<s3) \\n                 return true;  \\n              while(!stk.isEmpty() && nums[i]>stk.peek())\\n              {\\n                 s3 = stk.pop(); // we have to pop that num and change s3 to that no.\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2016089,
                "title": "c-an-overkill-solution-using-fenwick-tree",
                "content": "```\\n\\n#include <cassert>\\n#include <vector>\\n\\n\\n#include <cassert>\\n#include <numeric>\\n#include <type_traits>\\n\\nnamespace atcoder {\\n\\nnamespace internal {\\n\\n#ifndef _MSC_VER\\ntemplate <class T>\\nusing is_signed_int128 =\\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\\n                                  std::is_same<T, __int128>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int128 =\\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\\n                                  std::is_same<T, unsigned __int128>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing make_unsigned_int128 =\\n    typename std::conditional<std::is_same<T, __int128_t>::value,\\n                              __uint128_t,\\n                              unsigned __int128>;\\n\\ntemplate <class T>\\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\\n                                                  is_signed_int128<T>::value ||\\n                                                  is_unsigned_int128<T>::value,\\n                                              std::true_type,\\n                                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\\n                                                 std::is_signed<T>::value) ||\\n                                                    is_signed_int128<T>::value,\\n                                                std::true_type,\\n                                                std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int =\\n    typename std::conditional<(is_integral<T>::value &&\\n                               std::is_unsigned<T>::value) ||\\n                                  is_unsigned_int128<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing to_unsigned = typename std::conditional<\\n    is_signed_int128<T>::value,\\n    make_unsigned_int128<T>,\\n    typename std::conditional<std::is_signed<T>::value,\\n                              std::make_unsigned<T>,\\n                              std::common_type<T>>::type>::type;\\n\\n#else\\n\\ntemplate <class T> using is_integral = typename std::is_integral<T>;\\n\\ntemplate <class T>\\nusing is_signed_int =\\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int =\\n    typename std::conditional<is_integral<T>::value &&\\n                                  std::is_unsigned<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\\n                                              std::make_unsigned<T>,\\n                                              std::common_type<T>>::type;\\n\\n#endif\\n\\ntemplate <class T>\\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\\n\\ntemplate <class T>\\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\\n\\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\\n\\n}  // namespace internal\\n\\n}  // namespace atcoder\\n\\n\\nnamespace atcoder {\\n\\ntemplate <class T> struct fenwick_tree {\\n    using U = internal::to_unsigned_t<T>;\\n\\n  public:\\n    fenwick_tree() : _n(0) {}\\n    fenwick_tree(int n) : _n(n), data(n) {}\\n\\n    void add(int p, T x) {\\n        assert(0 <= p && p < _n);\\n        p++;\\n        while (p <= _n) {\\n            data[p - 1] += U(x);\\n            p += p & -p;\\n        }\\n    }\\n\\n    T sum(int l, int r) {\\n        assert(0 <= l && l <= r && r <= _n);\\n        return sum(r) - sum(l);\\n    }\\n\\n  private:\\n    int _n;\\n    std::vector<U> data;\\n\\n    U sum(int r) {\\n        U s = 0;\\n        while (r > 0) {\\n            s += data[r - 1];\\n            r -= r & -r;\\n        }\\n        return s;\\n    }\\n};\\n\\n}  // namespace atcoder\\n\\nusing namespace atcoder;\\n\\nclass Solution {\\npublic:\\n  bool find132pattern(vector<int>& a) {\\n    \\n    int n = a.size();\\n    int idx = 0;\\n    map<int,int> mp;\\n    for (auto x : a) mp[x] = 0;\\n    for (auto &[k,v] : mp) v = idx++;\\n    for (auto &x : a) x = mp[x];\\n    \\n    fenwick_tree<int> fw(idx);\\n    for (auto x : a) fw.add(x,1);\\n    \\n    int lo = 1e9;\\n    int hi = -1;\\n    \\n    bool ret = false;\\n    \\n    for (auto x : a) {\\n      if (x < lo) {\\n        lo = x;\\n        hi = x;\\n      }\\n      else if (x > hi) hi = x;\\n\\n      fw.add(x,-1);\\n      if (lo + 1 < hi) {\\n        if (fw.sum(lo+1,hi) > 0) ret = true;\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n};\\n```\\n\\n```lo``` is the minimum of ```nums``` so far while we iterate through the array ```nums```. ```hi``` is the maximum of ```nums``` since the current ```lo``` is updated. Essentially ```lo``` is ```nums[i]``` and ```hi``` is ```nums[j]```. we\\'re looking for an existence of ```k``` such that ```lo < nums[k] < hi``` (```i<j<k```) using Fenwick tree and coordinate compression. If ```fw.sum(lo+1,hi) > 0``` we know there exists a such ```k```.\\n\\nI know it\\'s an overkill. Just wanted to share.",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\n#include <cassert>\\n#include <vector>\\n\\n\\n#include <cassert>\\n#include <numeric>\\n#include <type_traits>\\n\\nnamespace atcoder {\\n\\nnamespace internal {\\n\\n#ifndef _MSC_VER\\ntemplate <class T>\\nusing is_signed_int128 =\\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\\n                                  std::is_same<T, __int128>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int128 =\\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\\n                                  std::is_same<T, unsigned __int128>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing make_unsigned_int128 =\\n    typename std::conditional<std::is_same<T, __int128_t>::value,\\n                              __uint128_t,\\n                              unsigned __int128>;\\n\\ntemplate <class T>\\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\\n                                                  is_signed_int128<T>::value ||\\n                                                  is_unsigned_int128<T>::value,\\n                                              std::true_type,\\n                                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\\n                                                 std::is_signed<T>::value) ||\\n                                                    is_signed_int128<T>::value,\\n                                                std::true_type,\\n                                                std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int =\\n    typename std::conditional<(is_integral<T>::value &&\\n                               std::is_unsigned<T>::value) ||\\n                                  is_unsigned_int128<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing to_unsigned = typename std::conditional<\\n    is_signed_int128<T>::value,\\n    make_unsigned_int128<T>,\\n    typename std::conditional<std::is_signed<T>::value,\\n                              std::make_unsigned<T>,\\n                              std::common_type<T>>::type>::type;\\n\\n#else\\n\\ntemplate <class T> using is_integral = typename std::is_integral<T>;\\n\\ntemplate <class T>\\nusing is_signed_int =\\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int =\\n    typename std::conditional<is_integral<T>::value &&\\n                                  std::is_unsigned<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\\n                                              std::make_unsigned<T>,\\n                                              std::common_type<T>>::type;\\n\\n#endif\\n\\ntemplate <class T>\\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\\n\\ntemplate <class T>\\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\\n\\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\\n\\n}  // namespace internal\\n\\n}  // namespace atcoder\\n\\n\\nnamespace atcoder {\\n\\ntemplate <class T> struct fenwick_tree {\\n    using U = internal::to_unsigned_t<T>;\\n\\n  public:\\n    fenwick_tree() : _n(0) {}\\n    fenwick_tree(int n) : _n(n), data(n) {}\\n\\n    void add(int p, T x) {\\n        assert(0 <= p && p < _n);\\n        p++;\\n        while (p <= _n) {\\n            data[p - 1] += U(x);\\n            p += p & -p;\\n        }\\n    }\\n\\n    T sum(int l, int r) {\\n        assert(0 <= l && l <= r && r <= _n);\\n        return sum(r) - sum(l);\\n    }\\n\\n  private:\\n    int _n;\\n    std::vector<U> data;\\n\\n    U sum(int r) {\\n        U s = 0;\\n        while (r > 0) {\\n            s += data[r - 1];\\n            r -= r & -r;\\n        }\\n        return s;\\n    }\\n};\\n\\n}  // namespace atcoder\\n\\nusing namespace atcoder;\\n\\nclass Solution {\\npublic:\\n  bool find132pattern(vector<int>& a) {\\n    \\n    int n = a.size();\\n    int idx = 0;\\n    map<int,int> mp;\\n    for (auto x : a) mp[x] = 0;\\n    for (auto &[k,v] : mp) v = idx++;\\n    for (auto &x : a) x = mp[x];\\n    \\n    fenwick_tree<int> fw(idx);\\n    for (auto x : a) fw.add(x,1);\\n    \\n    int lo = 1e9;\\n    int hi = -1;\\n    \\n    bool ret = false;\\n    \\n    for (auto x : a) {\\n      if (x < lo) {\\n        lo = x;\\n        hi = x;\\n      }\\n      else if (x > hi) hi = x;\\n\\n      fw.add(x,-1);\\n      if (lo + 1 < hi) {\\n        if (fw.sum(lo+1,hi) > 0) ret = true;\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n};\\n```\n```lo```\n```nums```\n```nums```\n```hi```\n```nums```\n```lo```\n```lo```\n```nums[i]```\n```hi```\n```nums[j]```\n```k```\n```lo < nums[k] < hi```\n```i<j<k```\n```fw.sum(lo+1,hi) > 0```\n```k```",
                "codeTag": "C++"
            },
            {
                "id": 2016045,
                "title": "all-3-possible-approaches-from-o-n-n-n-to-o-n-easytounderstand",
                "content": "plz upvote if uh like\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& a) {\\n        //O(n*n*n) S(1) TLE(as expected)\\n        // int n=a.size();\\n        // for(int i=0;i<n-2;i++)\\n        //     for(int j=i+1;j<n-1;j++)\\n        //         for(int k=j+1;k<n;k++)\\n        //             if(a[i]<a[j]&&a[k]<a[j] && a[i]<a[k]){\\n        //                 cout<<a[i]<<a[k]<<a[j];\\n        //                 return 1;\\n        //             }\\n        // return 0;\\n        \\n        // O(n*n) S(n) TLE(not expecting that...sad)\\n        // int n=a.size();\\n        // int pre[n];\\n        // pre[0]=a[0];\\n        // for(int i=1;i<a.size();i++)pre[i]=min(pre[i-1],a[i]);\\n        // int j=1;\\n        // while(j<n-1){\\n        //     int k=j;\\n        //     while((++k)<n)\\n        //         if(pre[j-1]<a[j]&&a[k]<a[j] && pre[j-1]<a[k])return 1; \\n        //     j++;\\n        // }\\n        // return 0;\\n        \\n        //O(n) S(n) now we are talking, using stack\\n        stack<pair<int,int> > st;\\n        int n=a.size();\\n        int currMin=a[0];\\n        for(int i=1;i<n;i++){\\n                while(!st.empty() && st.top().first<=a[i])\\n                    st.pop();\\n                if(!st.empty() && st.top().second < a[i] )\\n                    return 1;\\n                st.push( { a[i], currMin} );\\n                currMin=min(a[i],currMin);\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& a) {\\n        //O(n*n*n) S(1) TLE(as expected)\\n        // int n=a.size();\\n        // for(int i=0;i<n-2;i++)\\n        //     for(int j=i+1;j<n-1;j++)\\n        //         for(int k=j+1;k<n;k++)\\n        //             if(a[i]<a[j]&&a[k]<a[j] && a[i]<a[k]){\\n        //                 cout<<a[i]<<a[k]<<a[j];\\n        //                 return 1;\\n        //             }\\n        // return 0;\\n        \\n        // O(n*n) S(n) TLE(not expecting that...sad)\\n        // int n=a.size();\\n        // int pre[n];\\n        // pre[0]=a[0];\\n        // for(int i=1;i<a.size();i++)pre[i]=min(pre[i-1],a[i]);\\n        // int j=1;\\n        // while(j<n-1){\\n        //     int k=j;\\n        //     while((++k)<n)\\n        //         if(pre[j-1]<a[j]&&a[k]<a[j] && pre[j-1]<a[k])return 1; \\n        //     j++;\\n        // }\\n        // return 0;\\n        \\n        //O(n) S(n) now we are talking, using stack\\n        stack<pair<int,int> > st;\\n        int n=a.size();\\n        int currMin=a[0];\\n        for(int i=1;i<n;i++){\\n                while(!st.empty() && st.top().first<=a[i])\\n                    st.pop();\\n                if(!st.empty() && st.top().second < a[i] )\\n                    return 1;\\n                st.push( { a[i], currMin} );\\n                currMin=min(a[i],currMin);\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2015854,
                "title": "132-pattern-o-n-test-case-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        // here i<j<k\\n        //132\\n        // nums[i] < nums[j]< nums[k]\\n        stack<int>st;\\n        \\n        int mini = INT_MIN;\\n        \\n        for(int i = nums.size()-1;i>=0;i--){\\n            \\n            if(nums[i]<mini) return true;\\n            \\n            while(!st.empty() && st.top() < nums[i]){\\n                mini = st.top();\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n            \\n            // TC2: 3 1 4 2\\n            // i= 3\\n            // st = 2\\n            // mini = INT_MIN\\n            \\n            // i=2\\n            // mini = 2\\n            // st = 4\\n            \\n            // i=1\\n            // 4 < 1 return true;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        // here i<j<k\\n        //132\\n        // nums[i] < nums[j]< nums[k]\\n        stack<int>st;\\n        \\n        int mini = INT_MIN;\\n        \\n        for(int i = nums.size()-1;i>=0;i--){\\n            \\n            if(nums[i]<mini) return true;\\n            \\n            while(!st.empty() && st.top() < nums[i]){\\n                mini = st.top();\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n            \\n            // TC2: 3 1 4 2\\n            // i= 3\\n            // st = 2\\n            // mini = INT_MIN\\n            \\n            // i=2\\n            // mini = 2\\n            // st = 4\\n            \\n            // i=1\\n            // 4 < 1 return true;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015779,
                "title": "clean-java-solution-single-pass-beats-99-77",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        int third = Integer.MIN_VALUE;\\n        int top = n;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            // Assumes that third is already smaller than some element nums[j] where j is between i and third\\'s index\\n            // We find a \"132\" pattern if nums[i] < third\\n            if (nums[i] < third) return true;\\n            \\n            // Now we have nums[i] >= third\\n            \\n            // We now view nums[i] as the second element, and increase third as much as possible, but keep third < nums[i].\\n            // We do this because we want to maximize the chance of finding a \"132\" pattern in a future iteration.\\n            // Note that {nums[top], ..., nums[n-1]} is a stack has the following property:\\n            // nums[top] <= nums[top+1] <= ... <= nums[n-1]\\n            while (top < n && nums[i] > nums[top]) third = nums[top++];\\n            \\n            // Now we have nums[i] <= nums[top] (which indicates that the stack is monotonical)\\n            // We push nums[i] to the \"stack\"            \\n            top--;\\n            nums[top] = nums[i];\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nDon\\'t forget to upvote if it helps!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        int third = Integer.MIN_VALUE;\\n        int top = n;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            // Assumes that third is already smaller than some element nums[j] where j is between i and third\\'s index\\n            // We find a \"132\" pattern if nums[i] < third\\n            if (nums[i] < third) return true;\\n            \\n            // Now we have nums[i] >= third\\n            \\n            // We now view nums[i] as the second element, and increase third as much as possible, but keep third < nums[i].\\n            // We do this because we want to maximize the chance of finding a \"132\" pattern in a future iteration.\\n            // Note that {nums[top], ..., nums[n-1]} is a stack has the following property:\\n            // nums[top] <= nums[top+1] <= ... <= nums[n-1]\\n            while (top < n && nums[i] > nums[top]) third = nums[top++];\\n            \\n            // Now we have nums[i] <= nums[top] (which indicates that the stack is monotonical)\\n            // We push nums[i] to the \"stack\"            \\n            top--;\\n            nums[top] = nums[i];\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015648,
                "title": "c-solution-with-detailed-explanation",
                "content": "\\tthe intuitive thing to understand is that for a given j, the best candidate for i would be the minimum one before j\\n    because it opens up maximum number of possibilities for the element k\\n\\n\\n    Min[j] represents the smallest element in the range [0...j] {we will see in a moment what happens when nums[j] == Min[j]}\\n    we are considering all possibilities for the element nums[j] by iterating over the array in reverse direction\\n    in the stack we are maintain an increasing order from top to bottom\\n\\n    as soon as you arrive at the element j, pop out all the elements from the stack which are smaller than or equal to  Min[j] {remember the stack is increasing from top to bottom, so as \\n    we keep on popping, the elements will keep increasing}\\n\\n    while(!stk.empty() && stk.top() <= Min[j]) stk.pop();   ---- (1)\\n\\n    this pops out all the elements from the stack which are smaller than or equal to Min[j] \\n    now after we are done with the popping, the element at the top will be the element which is just greater than Min[j]\\n\\n    Now there are a Few Cases (after we have performed the popping)\\n\\n    Case 1 - the stack is empty\\n             in this case, we have no option but to just push the element j into the stack and continue\\n\\n    Case 2 - The stack is not empty\\n            Case 2.1 - the top  of the stack is smaller than nums[j] (stk.top() < nums[j])\\n                        this is the exact condition we are looking for, so simply return true\\n            \\n            Case 2.2 - the top of the stack is greater than equal to nums[j] (stk.top() >= nums[j])\\n                       Case 2.2.1 - the top of the stack is greater than nums[j]\\n                                    this is not a 132 pattern, so simply push nums[j] and continue (remember this still maintain a non decreasing order from top to bottom)\\n\\n                        Case 2.2.2 - the top of the stack is equal to nums[j]\\n                                     this also means that 132 pattern is not satisfied and we will simply push nums[j] and continue (this still maintain a non decreasing order from top to bottom)\\n        \\n    Now what happens when nums[j] == Min[j]\\n    Remember as soon as we arrived at the element j, we pooped out all the elements which were lesser than or equal to nums[j], so there is no way that Case 2.1 will be satisfied, so there is no problem \\uD83D\\uDE03\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> Min(n, INT_MAX);\\n        Min[0] = nums[0];\\n        for(int i = 1; i < n; i++) {\\n            Min[i] = min(Min[i - 1], nums[i]);\\n        }\\n        \\n        stack<int> stk;\\n        for(int j = n - 1; j >= 0; j--) {\\n            while(!stk.empty() && stk.top() <= Min[j]) stk.pop();\\n            if(!stk.empty() && stk.top() < nums[j]) return true;\\n            stk.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> Min(n, INT_MAX);\\n        Min[0] = nums[0];\\n        for(int i = 1; i < n; i++) {\\n            Min[i] = min(Min[i - 1], nums[i]);\\n        }\\n        \\n        stack<int> stk;\\n        for(int j = n - 1; j >= 0; j--) {\\n            while(!stk.empty() && stk.top() <= Min[j]) stk.pop();\\n            if(!stk.empty() && stk.top() < nums[j]) return true;\\n            stk.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015601,
                "title": "python-monotonic-stack-o-n",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        \\n        stack = []\\n        minVal = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n\\t\\t\\t# stack should be monotonic decreasing\\n            while stack and nums[i]>=stack[-1][0]:\\n                stack.pop()\\n            \\n            if stack and nums[i] > stack[-1][1]:\\n                return True \\n            \\n            stack.append([nums[i],minVal])\\n\\t\\t\\t\\n\\t\\t\\t# get the minimum value before the current index value\\n            minVal = min(minVal,nums[i])\\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        \\n        stack = []\\n        minVal = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n\\t\\t\\t# stack should be monotonic decreasing\\n            while stack and nums[i]>=stack[-1][0]:\\n                stack.pop()\\n            \\n            if stack and nums[i] > stack[-1][1]:\\n                return True \\n            \\n            stack.append([nums[i],minVal])\\n\\t\\t\\t\\n\\t\\t\\t# get the minimum value before the current index value\\n            minVal = min(minVal,nums[i])\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015318,
                "title": "java-o-1-space-o-n-time-solution-keep-track-of-range",
                "content": "**Intution:**\\n* Left element should be smallest element among three\\n* Middle element should be largest element among three\\n* Right element should be in range from left to middle\\n\\n**Approach:**\\nIf we take any element as middle then:\\n1. we need to find if there is smaller element than that to the left of it.\\n\\t\\t-> This we can find by checking the smallest element till now is less than middle or not. (if yes      then present else not)\\n2. we need element in range from left to middle in the right side of middle\\n\\t\\t-> For this we can take two variables (max_of_range) and (min_of_range) and store the current range in these to check if we can find some element within the range in future (i.e. traversing to the right)\\n\\t\\t\\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min_of_range = Integer.MAX_VALUE; \\n        int max_of_range = Integer.MIN_VALUE;\\n        int left = nums[0]; // left of three elements\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            if(i != nums.length -1 && nums[i] >= min_of_range && nums[i] <= max_of_range) \\n                return true;\\n            \\n            int middle = nums[i];\\n            \\n            // we need to find right in range [left+1, right-1] (inclusive) \\n            if(left + 1 <= middle - 1) { // atleast one element is there to be right \\n                if(left+1 < min_of_range) min_of_range = left+1;\\n                if(middle-1 > max_of_range) max_of_range = middle-1;   \\n            }\\n            \\n            left = Math.min(left, nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min_of_range = Integer.MAX_VALUE; \\n        int max_of_range = Integer.MIN_VALUE;\\n        int left = nums[0]; // left of three elements\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            if(i != nums.length -1 && nums[i] >= min_of_range && nums[i] <= max_of_range) \\n                return true;\\n            \\n            int middle = nums[i];\\n            \\n            // we need to find right in range [left+1, right-1] (inclusive) \\n            if(left + 1 <= middle - 1) { // atleast one element is there to be right \\n                if(left+1 < min_of_range) min_of_range = left+1;\\n                if(middle-1 > max_of_range) max_of_range = middle-1;   \\n            }\\n            \\n            left = Math.min(left, nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015269,
                "title": "go-stack-easy-to-understand",
                "content": "```\\nfunc find132pattern(nums []int) bool {\\n\\t// init stack\\n\\tstack := []int{}\\n\\tsecond := math.MinInt // Init the second element\\n\\tfor i := len(nums) - 1; i >= 0; i-- {\\n\\t\\tif nums[i] < second { // In this case, nums[i] is the first element\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tfor len(stack) > 0 && nums[i] > stack[len(stack)-1] {\\n\\t\\t\\tsecond = stack[len(stack)-1] // Override second by Top stack\\n\\t\\t\\tstack = stack[:len(stack)-1] // Pop stack\\n\\t\\t}\\n\\t\\tstack = append(stack, nums[i]) // Push nums[i] to stack\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc find132pattern(nums []int) bool {\\n\\t// init stack\\n\\tstack := []int{}\\n\\tsecond := math.MinInt // Init the second element\\n\\tfor i := len(nums) - 1; i >= 0; i-- {\\n\\t\\tif nums[i] < second { // In this case, nums[i] is the first element\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tfor len(stack) > 0 && nums[i] > stack[len(stack)-1] {\\n\\t\\t\\tsecond = stack[len(stack)-1] // Override second by Top stack\\n\\t\\t\\tstack = stack[:len(stack)-1] // Pop stack\\n\\t\\t}\\n\\t\\tstack = append(stack, nums[i]) // Push nums[i] to stack\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015265,
                "title": "java-easy-to-understand-using-stack-beginner-friendly",
                "content": "```\\nclass Solution {\\n\\n    public boolean find132pattern(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[0] = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)\\n            min[i] = Math.min(min[i-1],nums[i]);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int j=nums.length-1;j>=0;j--)\\n        {\\n            while(st.size()>0 && st.peek() <= min[j])\\n                st.pop();\\n            if(st.size() > 0 && st.peek() < nums[j])\\n                return true;\\n            st.push(nums[j]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean find132pattern(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[0] = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)\\n            min[i] = Math.min(min[i-1],nums[i]);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int j=nums.length-1;j>=0;j--)\\n        {\\n            while(st.size()>0 && st.peek() <= min[j])\\n                st.pop();\\n            if(st.size() > 0 && st.peek() < nums[j])\\n                return true;\\n            st.push(nums[j]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015075,
                "title": "easy-java-solution-beat-100-in-time-and-93-9-in-space",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int second=Integer.MIN_VALUE;\\n        int index=nums.length; //using nums itself as the stack (bottom on the right end)\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]<second) return true;\\n            else while(index<nums.length && nums[i]>nums[index]) second=nums[index++];\\n            nums[--index]=nums[i];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int second=Integer.MIN_VALUE;\\n        int index=nums.length; //using nums itself as the stack (bottom on the right end)\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]<second) return true;\\n            else while(index<nums.length && nums[i]>nums[index]) second=nums[index++];\\n            nums[--index]=nums[i];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011483,
                "title": "easy-c-solution-time-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> minval(n);\\n        minval[0] = nums[0];\\n        for(int i = 1; i<n; i++){\\n           minval[i] = min(nums[i], minval[i-1]);  \\n        }\\n        stack<int> st;\\n        for(int j = n - 1; j>=0; j--){\\n            while(!st.empty() && st.top() <= minval[j]) st.pop();\\n            if(!st.empty() && st.top() < nums[j]){\\n                return true;\\n            }\\n            st.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> minval(n);\\n        minval[0] = nums[0];\\n        for(int i = 1; i<n; i++){\\n           minval[i] = min(nums[i], minval[i-1]);  \\n        }\\n        stack<int> st;\\n        for(int j = n - 1; j>=0; j--){\\n            while(!st.empty() && st.top() <= minval[j]) st.pop();\\n            if(!st.empty() && st.top() < nums[j]){\\n                return true;\\n            }\\n            st.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984301,
                "title": "c-132-pattern-easy-and-simple-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        //prefix min\\n        \\n        vector<int> premn(nums.size());\\n        premn[0]=nums[0];\\n        \\n        \\n        \\n        //finding prefix min\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<premn[i-1]){\\n                premn[i]=nums[i];\\n            }else{\\n                premn[i]=premn[i-1];\\n            }\\n        }\\n        \\n        //stack to hold large value\\n        stack<int> stk;\\n        stk.push(0);\\n        for(int i =1; i<nums.size(); i++) {\\n            while(!stk.empty() && nums[stk.top()] <= nums[i]) {\\n                stk.pop();\\n            }\\n            if(!stk.empty()) { //exist a larger element nums[j]\\n                if(premn[stk.top()] < nums[i]) {\\n                    return true;\\n                }\\n            }\\n            stk.push(i);\\n        }\\n        return false;\\n    }\\n};\\n```\\n### if you like it upvote it",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        //prefix min\\n        \\n        vector<int> premn(nums.size());\\n        premn[0]=nums[0];\\n        \\n        \\n        \\n        //finding prefix min\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<premn[i-1]){\\n                premn[i]=nums[i];\\n            }else{\\n                premn[i]=premn[i-1];\\n            }\\n        }\\n        \\n        //stack to hold large value\\n        stack<int> stk;\\n        stk.push(0);\\n        for(int i =1; i<nums.size(); i++) {\\n            while(!stk.empty() && nums[stk.top()] <= nums[i]) {\\n                stk.pop();\\n            }\\n            if(!stk.empty()) { //exist a larger element nums[j]\\n                if(premn[stk.top()] < nums[i]) {\\n                    return true;\\n                }\\n            }\\n            stk.push(i);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793939,
                "title": "cpp-code-with-o-n-aux-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int> stack;\\n        int mini =  INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums [i] < mini)\\n                return true;\\n            while (stack.size() >0 && nums [i] > stack.top()){\\n                mini = stack.top ();\\n                stack.pop();\\n            }\\n                \\n            stack.push (nums [i]);\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int> stack;\\n        int mini =  INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums [i] < mini)\\n                return true;\\n            while (stack.size() >0 && nums [i] > stack.top()){\\n                mini = stack.top ();\\n                stack.pop();\\n            }\\n                \\n            stack.push (nums [i]);\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427513,
                "title": "easy-c-solution-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& arr) {\\n        \\n        bool flag=false;\\n        \\n        int n=arr.size();\\n        \\n        vector<int>prefixMini(n);\\n        prefixMini[0]=arr[0];\\n        \\n        for(int i=1;i<n;i++) prefixMini[i]=min(prefixMini[i-1],arr[i]);\\n        \\n        stack<int>s;\\n        \\n        for(int j=n-1;j>=0;j--){\\n            \\n            while(s.size() > 0 && s.top() <= prefixMini[j])  // its  basically i\\n                s.pop();\\n            \\n            if(s.size() > 0  && s.top() < arr[j]) flag=true; //this is for k\\n            \\n            s.push(arr[j]);\\n        }\\n        \\n        return flag;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& arr) {\\n        \\n        bool flag=false;\\n        \\n        int n=arr.size();\\n        \\n        vector<int>prefixMini(n);\\n        prefixMini[0]=arr[0];\\n        \\n        for(int i=1;i<n;i++) prefixMini[i]=min(prefixMini[i-1],arr[i]);\\n        \\n        stack<int>s;\\n        \\n        for(int j=n-1;j>=0;j--){\\n            \\n            while(s.size() > 0 && s.top() <= prefixMini[j])  // its  basically i\\n                s.pop();\\n            \\n            if(s.size() > 0  && s.top() < arr[j]) flag=true; //this is for k\\n            \\n            s.push(arr[j]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1426801,
                "title": "stack-java-solution-detail-explanation",
                "content": "Hello,\\nSo , The main idea is that we want to find three elements with `nums[i] < nums[k] < nums[ j] ` the one thing is ith element will be less than the kth and jth elements.\\n\\nSo we create a min array to store minimum untill whatever the current position in our array.\\n\\nWe start from the end of array and we take pointer j (you can take anything) then check if elements present in stack are less than the minimum element upto that jth element then we simply remove them because that element can never statisfy our main condition. Now we compare the element remaining in stack with the jth element and if its less than jth element that means it is greater than the minimum elment upto jth element and less then current jth element so our condition is satisfied as the stack element is the kth element  and we return true otherwise we simply push it in our stack. \\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int length = nums.length;\\n        \\n        // for creating the min array\\n        int[] min_arr = new int[length];\\n        min_arr[0] = nums[0];\\n        for(int i = 1;i<length;i++){\\n            min_arr[i] = Math.min( min_arr[i-1] , nums[i] );\\n        }\\n        \\n        \\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for( int j = length-1; j>=0 ; j--){\\n            int val = nums[j];\\n            \\n            // values in stack smaller than min values till current j pointer are useless as they are never going to become larger.\\n            while( !stack.isEmpty() && stack.peek() <= min_arr[j] ){\\n                stack.pop();\\n            }\\n            \\n            // there are still values larger than the minimum at the current j and now we check if the current value is greater than stacks peek value which are nothing but k and current is j.\\n            if( !stack.isEmpty()  && stack.peek() < val ) return true;\\n            \\n            stack.push( val );\\n            \\n        }\\n        \\n        // at the very end we simply return false;\\n        return false;\\n    }\\n}\\n```\\n\\nHope this helps\\n\\nThank You",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int length = nums.length;\\n        \\n        // for creating the min array\\n        int[] min_arr = new int[length];\\n        min_arr[0] = nums[0];\\n        for(int i = 1;i<length;i++){\\n            min_arr[i] = Math.min( min_arr[i-1] , nums[i] );\\n        }\\n        \\n        \\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for( int j = length-1; j>=0 ; j--){\\n            int val = nums[j];\\n            \\n            // values in stack smaller than min values till current j pointer are useless as they are never going to become larger.\\n            while( !stack.isEmpty() && stack.peek() <= min_arr[j] ){\\n                stack.pop();\\n            }\\n            \\n            // there are still values larger than the minimum at the current j and now we check if the current value is greater than stacks peek value which are nothing but k and current is j.\\n            if( !stack.isEmpty()  && stack.peek() < val ) return true;\\n            \\n            stack.push( val );\\n            \\n        }\\n        \\n        // at the very end we simply return false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226405,
                "title": "stack-js-solution",
                "content": "```\\n/*\\nAt each index i, we want to find if (1) there is a smaller element on the left \\n(2) there is a smaller element on the right (3) the smaller element on the right is greater than the smaller element on the left.\\n\\nHence, for each i, pattern[i] = left[i] !== null && right[i] !== null && left[i] < right[i]\\n\\nleft[i] = the minimum element less than nums[i] on the left \\nright[i] = the maximum element less than nums[i] on the right\\n\\nif there is no element less than nums[i] on the left, left[i] = null\\nif there is no element less than nums[i] on the right, right[i] = null\\n\\nWe can fill left[] easily by keeping track of minimum value from start of array.\\nWe will fill right[] using Stack.\\n*/\\nvar find132pattern = function(nums) {\\n    if (nums === null || nums.length === 0) {\\n        return false;\\n    }\\n    let n = nums.length;\\n    let left = new Array(n).fill(null), min = Infinity;\\n    let right = new Array(n).fill(null);\\n    // fill left[]\\n    for (let i = 0; i < nums.length; i++) {\\n        min = Math.min(min, nums[i]);\\n        if (nums[i] > min) {\\n            left[i] = min;\\n        }\\n    }\\n    // fill right[]\\n    let stack = [];\\n    for (let i = n-1; i >= 0; i--) {\\n        let elem = null;\\n        // we keep a decreasing stack\\n        // this means that this while loop allows us to go through all numbers less than\\n        // current number on the right and hence we can get the maximum less number\\n        while (stack.length > 0 && nums[i] > stack[stack.length-1]) {\\n            if (!elem) elem = stack.pop();\\n            else elem = Math.max(elem, stack.pop());\\n        }\\n        right[i] = elem;\\n        stack.push(nums[i]);\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (left[i] !== null && right[i] !== null && left[i] < right[i]) {\\n            return true;\\n        }\\n    }\\n    return false;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nAt each index i, we want to find if (1) there is a smaller element on the left \\n(2) there is a smaller element on the right (3) the smaller element on the right is greater than the smaller element on the left.\\n\\nHence, for each i, pattern[i] = left[i] !== null && right[i] !== null && left[i] < right[i]\\n\\nleft[i] = the minimum element less than nums[i] on the left \\nright[i] = the maximum element less than nums[i] on the right\\n\\nif there is no element less than nums[i] on the left, left[i] = null\\nif there is no element less than nums[i] on the right, right[i] = null\\n\\nWe can fill left[] easily by keeping track of minimum value from start of array.\\nWe will fill right[] using Stack.\\n*/\\nvar find132pattern = function(nums) {\\n    if (nums === null || nums.length === 0) {\\n        return false;\\n    }\\n    let n = nums.length;\\n    let left = new Array(n).fill(null), min = Infinity;\\n    let right = new Array(n).fill(null);\\n    // fill left[]\\n    for (let i = 0; i < nums.length; i++) {\\n        min = Math.min(min, nums[i]);\\n        if (nums[i] > min) {\\n            left[i] = min;\\n        }\\n    }\\n    // fill right[]\\n    let stack = [];\\n    for (let i = n-1; i >= 0; i--) {\\n        let elem = null;\\n        // we keep a decreasing stack\\n        // this means that this while loop allows us to go through all numbers less than\\n        // current number on the right and hence we can get the maximum less number\\n        while (stack.length > 0 && nums[i] > stack[stack.length-1]) {\\n            if (!elem) elem = stack.pop();\\n            else elem = Math.max(elem, stack.pop());\\n        }\\n        right[i] = elem;\\n        stack.push(nums[i]);\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (left[i] !== null && right[i] !== null && left[i] < right[i]) {\\n            return true;\\n        }\\n    }\\n    return false;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1184090,
                "title": "c-from-n-2-to-nlogn-all-three-solutions-from-1624ms-to-20ms",
                "content": "```\\n// O(NlogN) Solution Using lower_bound 20ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        set<int> s;\\n        set<int>::iterator it;\\n        for (int i = size - 1; i >= 0; i--) {\\n            s.insert(nums[i]);\\n            it = s.lower_bound(nums[i]);\\n            if (it != s.begin()) {\\n                it--;\\n                nextGreatestSmaller[i] = *it;\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right\\n        int minSoFar = nums[0];\\n        for (int i = 0; i < size - 2; i++) {\\n            minSoFar = min(minSoFar, nums[i]);\\n            if (minSoFar < nextGreatestSmaller[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// O(N^2) + O(N) Solution 792ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        for (int i = 0; i < size; i++) {\\n            int upperBound = nums[i], maxElem = INT_MIN;\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[j] < upperBound && nums[j] > maxElem) {\\n                    maxElem = nums[j];\\n                    nextGreatestSmaller[i] = maxElem;\\n                }\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right\\n        int minSoFar = nums[0];\\n        for (int i = 0; i < size - 2; i++) {\\n            minSoFar = min(minSoFar, nums[i]);\\n            if (minSoFar < nextGreatestSmaller[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// 2*O(N^2) Solution by checking 32 pattern 1624ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        for (int i = 0; i < size; i++) {\\n            int upperBound = nums[i], maxElem = INT_MIN;\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[j] < upperBound && nums[j] > maxElem) {\\n                    maxElem = nums[j];\\n                    nextGreatestSmaller[i] = maxElem;\\n                }\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right in O(N^2) time\\n        for (int i = 0; i < size - 2; i++) {\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[i] < nextGreatestSmaller[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n// O(NlogN) Solution Using lower_bound 20ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        set<int> s;\\n        set<int>::iterator it;\\n        for (int i = size - 1; i >= 0; i--) {\\n            s.insert(nums[i]);\\n            it = s.lower_bound(nums[i]);\\n            if (it != s.begin()) {\\n                it--;\\n                nextGreatestSmaller[i] = *it;\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right\\n        int minSoFar = nums[0];\\n        for (int i = 0; i < size - 2; i++) {\\n            minSoFar = min(minSoFar, nums[i]);\\n            if (minSoFar < nextGreatestSmaller[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// O(N^2) + O(N) Solution 792ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        for (int i = 0; i < size; i++) {\\n            int upperBound = nums[i], maxElem = INT_MIN;\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[j] < upperBound && nums[j] > maxElem) {\\n                    maxElem = nums[j];\\n                    nextGreatestSmaller[i] = maxElem;\\n                }\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right\\n        int minSoFar = nums[0];\\n        for (int i = 0; i < size - 2; i++) {\\n            minSoFar = min(minSoFar, nums[i]);\\n            if (minSoFar < nextGreatestSmaller[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// 2*O(N^2) Solution by checking 32 pattern 1624ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        for (int i = 0; i < size; i++) {\\n            int upperBound = nums[i], maxElem = INT_MIN;\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[j] < upperBound && nums[j] > maxElem) {\\n                    maxElem = nums[j];\\n                    nextGreatestSmaller[i] = maxElem;\\n                }\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right in O(N^2) time\\n        for (int i = 0; i < size - 2; i++) {\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[i] < nextGreatestSmaller[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172255,
                "title": "python-o-n-solution-detailed-explanation",
                "content": "**Problem Setup:**\\n\\nLet low index (low_i), mid index (mid_i), top index (top_i) define the indicies in the input array nums where low_i < mid_i < top_i\\n\\nLet low = nums[low_i], top = nums[top_i], mid = nums[mid_i]\\n\\nWe then want to find a condition where, low < top < mid or a 132 sequence\\n\\n**Intution:**\\nIf we first find the condition top < mid.  More specifically, we want to find the place where top is at a maximum given this condition because we need to also satisify the condition low < top.  The maximum top gives us the largest range of candidates for low.\\n\\n**Implementation:**\\nWe start from the end of the array and work backward, to find the condition where top < mid.\\n\\nWe will use a stack to keep track of all of the elements seen.  We look for the condition where the current element is larger than the top element in the stack, which indicates the top < mid condition (since values in the stack contain values with indicies greater than the current element).  \\nTo ensure that we get the element where top < mid AND mid is as big as possible, we will conntinually pop the stack until the top of the stack is no longer less than the current element.  We then set the last value popped to the variable top.\\n\\nWe then append the current value to the stack.  In this way our stack is always in decreasing order (since we\\'ve popped all elements which are less than that put stop short of when the top of the stack is equal to or greater than the current element).\\n\\nWe then continue on comparing this value found to new elements at the beginning of nums.  If we find a value that is lower than top, then the property low < top holds, we also know that top < mid hold as demonstrated above. Therefore we have found the place where low < top < mid. The 132 sequence.\\n\\n\\n```\\nclass Solution:\\n    \\n    def find132pattern(self, nums) -> bool:\\n        stk = []\\n        top = -float(\"inf\")\\n        \\n        for i in range(len(nums) -1, -1, -1):\\n            if top > nums[i]:\\n                return True\\n            \\n            while(len(stk) and nums[i] > stk[len(stk) -1]):\\n                top = stk.pop()\\n            stk.append(nums[i])\\n        return False",
                "solutionTags": [],
                "code": "**Problem Setup:**\\n\\nLet low index (low_i), mid index (mid_i), top index (top_i) define the indicies in the input array nums where low_i < mid_i < top_i\\n\\nLet low = nums[low_i], top = nums[top_i], mid = nums[mid_i]\\n\\nWe then want to find a condition where, low < top < mid or a 132 sequence\\n\\n**Intution:**\\nIf we first find the condition top < mid.  More specifically, we want to find the place where top is at a maximum given this condition because we need to also satisify the condition low < top.  The maximum top gives us the largest range of candidates for low.\\n\\n**Implementation:**\\nWe start from the end of the array and work backward, to find the condition where top < mid.\\n\\nWe will use a stack to keep track of all of the elements seen.  We look for the condition where the current element is larger than the top element in the stack, which indicates the top < mid condition (since values in the stack contain values with indicies greater than the current element).  \\nTo ensure that we get the element where top < mid AND mid is as big as possible, we will conntinually pop the stack until the top of the stack is no longer less than the current element.  We then set the last value popped to the variable top.\\n\\nWe then append the current value to the stack.  In this way our stack is always in decreasing order (since we\\'ve popped all elements which are less than that put stop short of when the top of the stack is equal to or greater than the current element).\\n\\nWe then continue on comparing this value found to new elements at the beginning of nums.  If we find a value that is lower than top, then the property low < top holds, we also know that top < mid hold as demonstrated above. Therefore we have found the place where low < top < mid. The 132 sequence.\\n\\n\\n```\\nclass Solution:\\n    \\n    def find132pattern(self, nums) -> bool:\\n        stk = []\\n        top = -float(\"inf\")\\n        \\n        for i in range(len(nums) -1, -1, -1):\\n            if top > nums[i]:\\n                return True\\n            \\n            while(len(stk) and nums[i] > stk[len(stk) -1]):\\n                top = stk.pop()\\n            stk.append(nums[i])\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1163466,
                "title": "java-using-stack-4ms",
                "content": "```\\nclass Solution {\\n     public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stk = new Stack<>();\\n        int var = Integer.MIN_VALUE;\\n         \\n        for(int i = nums.length-1; i >= 0; i--){\\n            if(nums[i] < var) return true;\\n            \\n            while(!stk.isEmpty() && stk.peek() < nums[i]){\\n                var = stk.pop();\\n            }\\n            \\n            stk.push(nums[i]);\\n        } \\n         \\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stk = new Stack<>();\\n        int var = Integer.MIN_VALUE;\\n         \\n        for(int i = nums.length-1; i >= 0; i--){\\n            if(nums[i] < var) return true;\\n            \\n            while(!stk.isEmpty() && stk.peek() < nums[i]){\\n                var = stk.pop();\\n            }\\n            \\n            stk.push(nums[i]);\\n        } \\n         \\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954237,
                "title": "easy-stack-solution-video-explanation",
                "content": "Link to Video:-\\n\\n\\n\\n```\\n bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> leftMin(n);\\n        leftMin[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            leftMin[i] = min(leftMin[i-1],nums[i]);\\n        }\\n        \\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i] > leftMin[i]){\\n                while(!s.empty() && s.top() <= leftMin[i]) s.pop();\\n                if(!s.empty() && s.top() < nums[i]){\\n                    return true;\\n                }\\n                s.push(nums[i]);\\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> leftMin(n);\\n        leftMin[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            leftMin[i] = min(leftMin[i-1],nums[i]);\\n        }\\n        \\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i] > leftMin[i]){\\n                while(!s.empty() && s.top() <= leftMin[i]) s.pop();\\n                if(!s.empty() && s.top() < nums[i]){\\n                    return true;\\n                }\\n                s.push(nums[i]);\\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908152,
                "title": "c-array-based-solution-100-time-faster-code-submitted-10-space",
                "content": "This is a nice, albeit tricky problem, since it is not super-easy to spot that it boils down to one of those interval-based problems you might have already solved.\\n\\nIn order to have a proper perspective, you need to parse through the vector linearly and gradually build your own interval(s), then return when you find a value that would fit in - it would be the `3` between your `1` (beginning/minimum of the interval) and the `2` (the end/maximum of the interval).\\n\\nNow, the difficult part is to get this information down; you might create another support data structure, like an array of `<value, position>` pairs to be sorted, but that is a bit more complex than just going linearly and storing info as we go; and then more magic later, but one step at a time.\\n\\nFirst of all, recap of the variables we will need, provided the input is long at least `3` elements (otherwise we just return `false`):\\n* `len` will store the aforementioned length of the input vector;\\n* `minValues` and `s`, arrays to store our minimum and on going relative maximum;\\n* `pos` , a variable that will allow us to use `s` as a much more efficient stack.\\n\\nFirst of all we are going to populate `minValues` with all the minimum values encountered so far, proceeding from the left, so that for example, given as an input `[3,4,6,7,8,2,1,3]` your array will be `{3, 3, 3, 3, 3, 2, 1, 1}`. This is going to be our `1` into a `132` pattern.\\n\\nNow, for the hard part: we will start hunting for our `3` and then `2` in the `132` pattern, this time starting from the right and, only if the current number `nums[i]` is greater than the stored minimum `minValues[i]`, we proceed like this:\\n* for each number, we will remove all the previous numbers in our \"stack\" that are smaller than the matching local minimum at index `i`, provided we have any number stored at all - notice that since we use an array for this, we will just have to check if `pos` is `!= 0` (ie: we have numbers in stack) and in case decrease it as a cheap equivalent to popping;\\n* if by then we will still have at least one element in stack, it will mean that we encountered a number bigger than our current one - that implies that the number in the stack is going to be our `2` and the current one is our `3`: if our `3` is also bigger than the minimum to this point, we are set - but we know that from the very beginning, since we checked in our `if` statement that `nums[i] > minValues[i]`;\\n* otherwise, we push the current value in our \"stack\" and move on.\\n\\nIn the previous case, we will have again `[3,4,6,7,8,2,1,3]` as an input and `{3, 3, 3, 3, 3, 2, 1, 1}` in `minValues`.\\n\\nWe start looping and since our \"stack\" is empty, nothing we can remove and we put `3` there.\\n\\nThe following `1` is not greater than the value stored in the matching position in `minValues`, so we do nothing and same for `2`.\\n\\n`8` instead will help us proceed: we remove the previous top of the \"stack\", `3`, and store `8` there.\\n\\nFinally we move to `7`, which is both greater than the matching minimm (`3`) and less than the top of the stack (`8`), so we can return `true` :)\\n\\nIf we reach the end of the loop, clearly no number matched our need and we return `false` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if (nums.size() < 3) return false;\\n        // support variables\\n        int len = nums.size(), minValues[len], s[len], pos = 0;\\n        minValues[0] = nums[0];\\n        // populating minValues\\n        for(int i = 1; i < len; i++) minValues[i] = min(minValues[i - 1], nums[i]);\\n        // parsing the vector again from the left to store values v > minValues[i] and v < nums[i]\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (nums[i] > minValues[i]) {\\n                // clearing the \"stack\" from smaller values\\n                while (pos && s[pos - 1] <= minValues[i]) pos--;\\n                if (pos && s[pos - 1] < nums[i]) return true;\\n                s[pos++] = nums[i];\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if (nums.size() < 3) return false;\\n        // support variables\\n        int len = nums.size(), minValues[len], s[len], pos = 0;\\n        minValues[0] = nums[0];\\n        // populating minValues\\n        for(int i = 1; i < len; i++) minValues[i] = min(minValues[i - 1], nums[i]);\\n        // parsing the vector again from the left to store values v > minValues[i] and v < nums[i]\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (nums[i] > minValues[i]) {\\n                // clearing the \"stack\" from smaller values\\n                while (pos && s[pos - 1] <= minValues[i]) pos--;\\n                if (pos && s[pos - 1] < nums[i]) return true;\\n                s[pos++] = nums[i];\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907447,
                "title": "java-solution-using-stack-easy",
                "content": "```\\npublic boolean find132pattern(int[] nums) {\\n        \\n        if(nums.length < 3)\\n            return false;\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int minValue = Integer.MIN_VALUE;\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i] < minValue)\\n                return true;\\n            while(!stack.isEmpty() && nums[i] > stack.peek())\\n                minValue = stack.pop();\\n            \\n            stack.push(nums[i]);\\n        }\\n\\n        return false;\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean find132pattern(int[] nums) {\\n        \\n        if(nums.length < 3)\\n            return false;\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int minValue = Integer.MIN_VALUE;\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i] < minValue)\\n                return true;\\n            while(!stack.isEmpty() && nums[i] > stack.peek())\\n                minValue = stack.pop();\\n            \\n            stack.push(nums[i]);\\n        }\\n\\n        return false;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907168,
                "title": "need-help-c-my-bad-1500ms-t-o-nlogn-s-o-n-solution-based-on-binary-search",
                "content": "Please give me some advice to boost it.\\nI dont get it why it costs ~1500ms though its complexity is T:O(nlogn) :(\\n```\\n/*\\n    Use a stack to record ascending order and a local min.\\n    See if the incoming num is in the range of [local min, s.top()]\\n    T:O(n)/S:O(n)\\n    FAIL case: [3,5,0,3,4]\\n    -----\\n    AC, record every ascending region and binary search on these regions\\n    T(n) = log1 + ... + log(n/2) = O(nlogn)\\n    S: O(n)\\n*/\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        if (n<=2) return false;\\n        set<vector<int>> regions;\\n        vector<int> region{nums[0],nums[0]};\\n        auto cmp = [](int val, auto r){\\n            return r[0]<val;\\n        };\\n        auto cmp2 = [](auto r, int val){\\n            return r[1]<val;\\n        };\\n        for (int i=1; i<n; ++i) {\\n            if (nums[i]>=region[1]) region[1]=nums[i];\\n            else {\\n                if (region[0]<region[1]) regions.insert(region);\\n                region[0]=region[1]=nums[i];\\n            }\\n            auto it=upper_bound(regions.begin(),regions.end(),nums[i],cmp);\\n            if(it!=regions.end()) it=next(it,1);\\n            it=lower_bound(regions.begin(),it,nums[i],cmp2);\\n            if (it!=regions.end()&&nums[i]<(*it)[1]&&nums[i]>(*it)[0])\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Use a stack to record ascending order and a local min.\\n    See if the incoming num is in the range of [local min, s.top()]\\n    T:O(n)/S:O(n)\\n    FAIL case: [3,5,0,3,4]\\n    -----\\n    AC, record every ascending region and binary search on these regions\\n    T(n) = log1 + ... + log(n/2) = O(nlogn)\\n    S: O(n)\\n*/\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        if (n<=2) return false;\\n        set<vector<int>> regions;\\n        vector<int> region{nums[0],nums[0]};\\n        auto cmp = [](int val, auto r){\\n            return r[0]<val;\\n        };\\n        auto cmp2 = [](auto r, int val){\\n            return r[1]<val;\\n        };\\n        for (int i=1; i<n; ++i) {\\n            if (nums[i]>=region[1]) region[1]=nums[i];\\n            else {\\n                if (region[0]<region[1]) regions.insert(region);\\n                region[0]=region[1]=nums[i];\\n            }\\n            auto it=upper_bound(regions.begin(),regions.end(),nums[i],cmp);\\n            if(it!=regions.end()) it=next(it,1);\\n            it=lower_bound(regions.begin(),it,nums[i],cmp2);\\n            if (it!=regions.end()&&nums[i]<(*it)[1]&&nums[i]>(*it)[0])\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906945,
                "title": "python-stack-of-intervals-o-n-98",
                "content": "The idea is to keep track of non-overlapping intervals, such that each next interval ends before the start of the previous one.\\nEach next value in an array might either add a new interval when the value is smallest seen so far, or update an interval already in stack.\\nWe maintain consistency of a stack, and compress it while also checking if the solution was found:\\n```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n\\tif len(nums) < 3: return False  # impossible\\n\\tranges = [[nums[0], None]]\\n\\n\\tdef compress_and_check():\\n\\t\\t\\'\\'\\'will try to compress the ranges, return True if the pattern is found\\'\\'\\'\\n\\t\\tlast_x, last_y = ranges.pop()\\n\\t\\twhile ranges:\\n\\t\\t\\tprev_x, prev_y = ranges[-1]\\n\\t\\t\\tif prev_x > last_y: break\\n\\t\\t\\tif prev_x == last_y: \\n\\t\\t\\t\\tranges[-1][0] = last_x\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif last_y < prev_y:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tranges.pop()\\n\\n\\t\\tranges.append([last_x, last_y])\\n\\t\\treturn False\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tv = nums[i]\\n\\n\\t\\tif ranges[-1][1] is None:  # last range is open (only min value present)\\n\\t\\t\\tif v > ranges[-1][0]: \\n\\t\\t\\t\\tranges[-1][1] = v\\n\\t\\t\\t\\tif compress_and_check(): return True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tranges[-1][0] = v\\n\\t\\telse:\\n\\t\\t\\tif v in ranges[-1]: continue  # on the border => ignore\\n\\t\\t\\telif v < ranges[-1][0]: ranges.append([v, None])  # new range\\n\\t\\t\\telif v < ranges[-1][1]: return True  # solution found\\n\\t\\t\\telse:  # update the range, compress\\n\\t\\t\\t\\tranges[-1][1] = v\\n\\t\\t\\t\\tif compress_and_check(): return True\\n\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n\\tif len(nums) < 3: return False  # impossible\\n\\tranges = [[nums[0], None]]\\n\\n\\tdef compress_and_check():\\n\\t\\t\\'\\'\\'will try to compress the ranges, return True if the pattern is found\\'\\'\\'\\n\\t\\tlast_x, last_y = ranges.pop()\\n\\t\\twhile ranges:\\n\\t\\t\\tprev_x, prev_y = ranges[-1]\\n\\t\\t\\tif prev_x > last_y: break\\n\\t\\t\\tif prev_x == last_y: \\n\\t\\t\\t\\tranges[-1][0] = last_x\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif last_y < prev_y:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tranges.pop()\\n\\n\\t\\tranges.append([last_x, last_y])\\n\\t\\treturn False\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tv = nums[i]\\n\\n\\t\\tif ranges[-1][1] is None:  # last range is open (only min value present)\\n\\t\\t\\tif v > ranges[-1][0]: \\n\\t\\t\\t\\tranges[-1][1] = v\\n\\t\\t\\t\\tif compress_and_check(): return True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tranges[-1][0] = v\\n\\t\\telse:\\n\\t\\t\\tif v in ranges[-1]: continue  # on the border => ignore\\n\\t\\t\\telif v < ranges[-1][0]: ranges.append([v, None])  # new range\\n\\t\\t\\telif v < ranges[-1][1]: return True  # solution found\\n\\t\\t\\telse:  # update the range, compress\\n\\t\\t\\t\\tranges[-1][1] = v\\n\\t\\t\\t\\tif compress_and_check(): return True\\n\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 747871,
                "title": "c-using-set",
                "content": "Maintaining a prefix array of smallest number so far.\\n```c++\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return false;\\n        vector<int> preSmall(n);\\n        preSmall[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            preSmall[i]=min(preSmall[i-1],nums[i]);\\n        set<int> s;\\n        s.insert(nums[n-1]);\\n        for(int i=n-2;i>=1;i--)\\n        {\\n            auto it=s.upper_bound(preSmall[i-1]);\\n            if(it!=s.end() and *it<nums[i])\\n                return true;\\n            s.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return false;\\n        vector<int> preSmall(n);\\n        preSmall[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            preSmall[i]=min(preSmall[i-1],nums[i]);\\n        set<int> s;\\n        s.insert(nums[n-1]);\\n        for(int i=n-2;i>=1;i--)\\n        {\\n            auto it=s.upper_bound(preSmall[i-1]);\\n            if(it!=s.end() and *it<nums[i])\\n                return true;\\n            s.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739438,
                "title": "js-easy-understand-elegant-solution",
                "content": "### Idea\\n> **\\u601D\\u8DEF\\u6BD4\\u8F83\\u5DE7\\u5999\\u3002\\u7EF4\\u62A4\\u4E00\\u4E2A\\u53D8\\u91CF\\u7528\\u4E8E\\u5B58\\u50A8\\u7B2C\\u4E8C\\u5927\\u7684\\u6570 secondNum\\uFF1Bif\\u62E5\\u6709\\u5224\\u65AD\\u662F\\u5426\\u5F53\\u524Dnums[i]\\u5C0F\\u4E8EsecondNum\\uFF0Celse \\u7528\\u4E8E\\u5224\\u65AD\\u66F4\\u65B0 secondNum**\\n- **\\u4E3E\\u4F8B1**\\uFF1Aconst nums = [3, 1, 4, 2]\\n- \\u4E00\\u5F00\\u59CBsecondNum = -Infinity, stack = []\\n- i = 3, nums[i] = 2, \\u653E\\u8FDBstack => stack = [2]\\n- i = 2, nums[i] = 4, \\u8FDB\\u5165else\\u4E2D, \\u6EE1\\u8DB3stack\\u4E2D\\u5B58\\u5728\\u503C && stack[stack.length - 1] = 2 \\u5C0F\\u4E8E nums[i] = 4\\uFF0C\\u66F4\\u65B0secondNum = 2, stack.pop => stack = []\\n- i = 1, nums[i] = 1, \\u8FDB\\u5165if\\u8BED\\u53E5\\uFF0C\\u6EE1\\u8DB3nums[i] < secondNum\\uFF0C\\u8FD4\\u56DEtrue\\n\\n- **\\u4E3E\\u4F8B2**\\uFF1Aconst nums = [1, 2, 3, 4]\\n- i = 3, nums[i] = 4, \\u653E\\u5165stack => stack = [4]\\n- i = 2, nums[i] = 3, \\u4E0D\\u6EE1\\u8DB3if\\u3001else\\u7684\\u6761\\u4EF6\\uFF0C\\u76F4\\u63A5\\u653E\\u5165stack => stack = [4, 3]\\n- i = 1, nums[i] = 2, \\u4E0D\\u6EE1\\u8DB3if\\u3001else\\u7684\\u6761\\u4EF6\\uFF0C\\u76F4\\u63A5\\u653E\\u5165stack => stack = [4, 3, 2]\\n- i = 0, nums[i] = 1, \\u4E0D\\u6EE1\\u8DB3if\\u3001else\\u7684\\u6761\\u4EF6\\uFF0C\\u76F4\\u63A5\\u653E\\u5165stack => stack = [4, 3, 2, 1]\\n- \\u8FD4\\u56DEfalse\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n  if (nums.length < 3) return false\\n  \\n  let secondNum = -Infinity\\n  let stack = []\\n  const len = nums.length\\n  \\n  for (let i = len - 1; i > -1; i--) {\\n    if (nums[i] < secondNum) return true\\n    else {\\n      while (stack.length && stack[stack.length - 1] < nums[i]) {\\n        secondNum = stack.pop()\\n      }\\n    }\\n    stack.push(nums[i])\\n  }\\n  \\n  return false\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n  if (nums.length < 3) return false\\n  \\n  let secondNum = -Infinity\\n  let stack = []\\n  const len = nums.length\\n  \\n  for (let i = len - 1; i > -1; i--) {\\n    if (nums[i] < secondNum) return true\\n    else {\\n      while (stack.length && stack[stack.length - 1] < nums[i]) {\\n        secondNum = stack.pop()\\n      }\\n    }\\n    stack.push(nums[i])\\n  }\\n  \\n  return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736499,
                "title": "java-solution-using-treeset-o-nlogn-time-o-n-space",
                "content": "After having gone through the different solutions posted I didn\\'t see anyone use this so posting this just in case it is easier for someone to understand this.\\n\\nThe idea I came up with is to use a self balancing tree which stores the elements to the right of the current number `(j)` which is our `(k)`. Also instead of creating a min array we can update it on the fly by using a min variable `valPrev` which serves as `(i)` .\\n```\\n    public boolean find132pattern(int[] nums) {\\n        int n  = nums.length;\\n        if (n < 3) return false;\\n        \\n        TreeSet<Integer> ts = new TreeSet<>();\\n        ts.add(nums[n - 1]);\\n        int[] greatestSmallerNext = new int[n];\\n        for (int i = n - 2; i > 0; i--) {            \\n            Integer lower = ts.lower(nums[i]);\\n            if (lower != null) greatestSmallerNext[i] = lower;\\n            else greatestSmallerNext[i] = nums[i];\\n            ts.add(nums[i]);\\n        }\\n        \\n        int valPrev = nums[0];\\n        for (int i = 1; i < n - 1; i++) {\\n            valPrev = nums[i] < valPrev ? nums[i] : valPrev;\\n            if (valPrev < greatestSmallerNext[i] && nums[i] > greatestSmallerNext[i]) {\\n                return true;\\n            }\\n        }        \\n        return false;\\n    }\\n```\\n\\n**Time complexity:** O(nlogn) since retreival from treeset takes log(n) time.\\n**Space complexity:** O(n). We are only using array of size `n` to store the next greatest smaller element.",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\n    public boolean find132pattern(int[] nums) {\\n        int n  = nums.length;\\n        if (n < 3) return false;\\n        \\n        TreeSet<Integer> ts = new TreeSet<>();\\n        ts.add(nums[n - 1]);\\n        int[] greatestSmallerNext = new int[n];\\n        for (int i = n - 2; i > 0; i--) {            \\n            Integer lower = ts.lower(nums[i]);\\n            if (lower != null) greatestSmallerNext[i] = lower;\\n            else greatestSmallerNext[i] = nums[i];\\n            ts.add(nums[i]);\\n        }\\n        \\n        int valPrev = nums[0];\\n        for (int i = 1; i < n - 1; i++) {\\n            valPrev = nums[i] < valPrev ? nums[i] : valPrev;\\n            if (valPrev < greatestSmallerNext[i] && nums[i] > greatestSmallerNext[i]) {\\n                return true;\\n            }\\n        }        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 715558,
                "title": "simple-c-single-stack-solution",
                "content": "Data Structures Used :\\n-> Stack : to keep the values higher than the present val \\n-> vector(array) : to keep the most min value seen till now \\n\\n```\\nbool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        stack<int> S;\\n        vector<int> Min;\\n        int min_now=INT_MAX;\\n        for(int i=0;i<nums.size();++i){\\n            min_now=min(min_now,nums[i]);              // create the min array/vector\\n            Min.push_back(min_now);\\n        }\\n        for(int i=nums.size()-1;i>=0;--i){\\n            if(nums[i]>Min[i])                  // possible i j pair\\n            {\\n\\t\\t\\t\\twhile(!S.empty()&& S.top()<nums[i])          // if stack is not empty and its top value is smaller than the j val\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(S.top()>Min[i])                           // if top val is also smaller than the min val then this is the perfect i j k triplet hence return \\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\tS.pop();                                       // if not then pop the stack to see the next element \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n             S.push(nums[i]);                      // if top of stack is not smaller than j val then just push the j val onto stack \\n            }\\n        }\\n        return false; \\n    }",
                "solutionTags": [],
                "code": "Data Structures Used :\\n-> Stack : to keep the values higher than the present val \\n-> vector(array) : to keep the most min value seen till now \\n\\n```\\nbool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        stack<int> S;\\n        vector<int> Min;\\n        int min_now=INT_MAX;\\n        for(int i=0;i<nums.size();++i){\\n            min_now=min(min_now,nums[i]);              // create the min array/vector\\n            Min.push_back(min_now);\\n        }\\n        for(int i=nums.size()-1;i>=0;--i){\\n            if(nums[i]>Min[i])                  // possible i j pair\\n            {\\n\\t\\t\\t\\twhile(!S.empty()&& S.top()<nums[i])          // if stack is not empty and its top value is smaller than the j val\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(S.top()>Min[i])                           // if top val is also smaller than the min val then this is the perfect i j k triplet hence return \\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\tS.pop();                                       // if not then pop the stack to see the next element \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n             S.push(nums[i]);                      // if top of stack is not smaller than j val then just push the j val onto stack \\n            }\\n        }\\n        return false; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 654329,
                "title": "easy-to-understand-version-with-readable-variables",
                "content": "Simple logic, readable variables. It\\'s not to compete who writes the less lines of code....also confusing variable naming is very bad, which will waste the reader lots of time to understand the problem.\\n\\nLogic\\n1.  define data structure:   int a2, stack a3 and try to find a1.\\n2.  iterate from the end to start, the stack always has the largest number from the current position. So we only need to find the condition that a1 < a2, and a3 is for storing the largest number.\\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null  || nums.length <= 2) return false;\\n        Stack<Integer> a3Stack = new Stack<>();\\n        \\n        int a2 = Integer.MIN_VALUE;\\n        for(int i = nums.length-1; i >= 0; i--) {\\n\\t    \\t// current nums[i] could be the candidate of (a1,a3), that\\'s depends on the comparation of a2\\n            if(nums[i] > a2) { // nums[i] is a candidate of a3.\\n\\t\\t\\t    // fine the largest possible value of a2.\\n                while(!a3Stack.isEmpty() && nums[i] > a3Stack.peek()) {\\n                    a2 = a3Stack.pop();\\n                }\\n                // push the current largest number in the a3Stack.\\n                a3Stack.push(nums[i]);\\n            } else if(nums[i] == a2) {\\n                continue;\\n            } else {\\n                //nums[i] < a2; nums[i] is a1 at this moment.\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null  || nums.length <= 2) return false;\\n        Stack<Integer> a3Stack = new Stack<>();\\n        \\n        int a2 = Integer.MIN_VALUE;\\n        for(int i = nums.length-1; i >= 0; i--) {\\n\\t    \\t// current nums[i] could be the candidate of (a1,a3), that\\'s depends on the comparation of a2\\n            if(nums[i] > a2) { // nums[i] is a candidate of a3.\\n\\t\\t\\t    // fine the largest possible value of a2.\\n                while(!a3Stack.isEmpty() && nums[i] > a3Stack.peek()) {\\n                    a2 = a3Stack.pop();\\n                }\\n                // push the current largest number in the a3Stack.\\n                a3Stack.push(nums[i]);\\n            } else if(nums[i] == a2) {\\n                continue;\\n            } else {\\n                //nums[i] < a2; nums[i] is a1 at this moment.\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616590,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size(), mn = INT_MAX;\\n        for (int j = 0; j < n; ++j) {\\n            mn = min(mn, nums[j]);\\n            if (mn == nums[j]) continue;\\n            for (int k = n - 1; k > j; --k) {\\n                if (mn < nums[k] && nums[j] > nums[k]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size(), mn = INT_MAX;\\n        for (int j = 0; j < n; ++j) {\\n            mn = min(mn, nums[j]);\\n            if (mn == nums[j]) continue;\\n            for (int k = n - 1; k > j; --k) {\\n                if (mn < nums[k] && nums[j] > nums[k]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613848,
                "title": "o-n-forward-iterating-solution-with-no-stack",
                "content": "Similar idea to stack-based solutions, but noting the fact that we only need to use a \"current\" and \"previous\" max S2 value:\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3) return(false);\\n        int i=nums[0], j=INT_MIN, icand=INT_MAX, jcand=INT_MIN;\\n        \\n        for(int p=1;p<nums.size();p++){\\n            if(nums[p]<i) {\\n                icand=min(icand,i);\\n                jcand=max(jcand,j);\\n                i=nums[p];\\n                j=INT_MIN;\\n            }\\n            else if((nums[p]<j && nums[p]>i) || (nums[p]<jcand && nums[p]>icand)){\\n                return(true);\\n            }\\n            else if(nums[p]>i){                \\n                j=max(j,nums[p]);\\n            }            \\n        }\\n        return(false);        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3) return(false);\\n        int i=nums[0], j=INT_MIN, icand=INT_MAX, jcand=INT_MIN;\\n        \\n        for(int p=1;p<nums.size();p++){\\n            if(nums[p]<i) {\\n                icand=min(icand,i);\\n                jcand=max(jcand,j);\\n                i=nums[p];\\n                j=INT_MIN;\\n            }\\n            else if((nums[p]<j && nums[p]>i) || (nums[p]<jcand && nums[p]>icand)){\\n                return(true);\\n            }\\n            else if(nums[p]>i){                \\n                j=max(j,nums[p]);\\n            }            \\n        }\\n        return(false);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556821,
                "title": "easy-to-understand-javascript-code-with-comments",
                "content": "```\\nvar find132pattern = function(nums) {\\n    /*\\n    nums = [1,3,2,4,5]\\n    Idea is to find a number that has min left and 2nd higest min on right of that number\\n    Iterate numbers from the right\\n    Use stack to find 2nd highest min(compare previous number to number in stack - if the previous num is higher then pop() the last value of stack) Ex: pop 2 as 3 > 2 \\n    Compare that 2nd highest min to the num before it, and if that is less than 2nd highest min return true Ex: compare 2 (2nd highest min) to 1. 1< 2 return truw\\n    If none of above onditions meet return false\\n    */\\n    var stack=[], \\n    min = -Infinity;\\n    for(var i=nums.length-1; i>=0; i--){\\n        //Compare that 2nd highest min to the num before it, and if that is less than 2nd highest min return true\\n        if(nums[i] < min) \\n            return true;\\n        else{\\n            //Use stack to find 2nd highest min(compare previous number to number in stack - if the previous num is higher then pop() the last value of stack)\\n            while(stack.length>0 && nums[i]> stack[stack.length-1]){\\n            min = stack.pop();\\n            }\\n            stack.push(nums[i]);\\n        } \\n    }\\n    return false;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar find132pattern = function(nums) {\\n    /*\\n    nums = [1,3,2,4,5]\\n    Idea is to find a number that has min left and 2nd higest min on right of that number\\n    Iterate numbers from the right\\n    Use stack to find 2nd highest min(compare previous number to number in stack - if the previous num is higher then pop() the last value of stack) Ex: pop 2 as 3 > 2 \\n    Compare that 2nd highest min to the num before it, and if that is less than 2nd highest min return true Ex: compare 2 (2nd highest min) to 1. 1< 2 return truw\\n    If none of above onditions meet return false\\n    */\\n    var stack=[], \\n    min = -Infinity;\\n    for(var i=nums.length-1; i>=0; i--){\\n        //Compare that 2nd highest min to the num before it, and if that is less than 2nd highest min return true\\n        if(nums[i] < min) \\n            return true;\\n        else{\\n            //Use stack to find 2nd highest min(compare previous number to number in stack - if the previous num is higher then pop() the last value of stack)\\n            while(stack.length>0 && nums[i]> stack[stack.length-1]){\\n            min = stack.pop();\\n            }\\n            stack.push(nums[i]);\\n        } \\n    }\\n    return false;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432266,
                "title": "python-different-approach-explained-array-heap-o-n-log-n",
                "content": "In three easy steps:\\n1. Traverse the array starting from the left and for each position of the array store the minimum value seen so far.\\n2. Traverse the array starting from the right storing each seen value in a min_heap. \\n\\t1. While min_heap.top < min[x]: min_heap.pop.\\n\\t2. If at any point min[x] < min_heap.top < nums[x] return True\\n3. Return False if we finished traversing the array\\n\\nLonger explanation:\\nAs the description says we need to find three numbers (i,j,k) on the array that fullfill the next conditions i < j < k and array[i] < array[k] < array[j]. If we focus on the position j we need to find two numbers which have a lower value than the one at position j, being one bigger than the other and, one apearing on before position j and the other one appearing after position j. To compute the lowest value that appears before position j we can use an array to cache the minimum value that appears before position j, that will give us the position i part of the solution. Now, we have to compute another value lower than the one at position j but bigger than the one we set for position i. For that we can use a min heap, if we use use a min_heap traversing the array from right to left we can keep a list of possible candidates of the lowest element bigger than the minimum that appears after position j. \\n\\n```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n            \\n        mins = [float(\\'inf\\')] * len(nums)\\n        mins[0] = nums[0]\\n        for x in range(1, len(nums)):\\n            mins[x] = min(mins[x-1], nums[x])\\n            \\n        min_heap = []\\n        for x in range(len(nums)-1, 0, -1):\\n            heapq.heappush(min_heap, nums[x])\\n            \\n            while min_heap and (min_heap[0] <= mins[x]):\\n                heapq.heappop(min_heap)\\n            \\n            if min_heap and mins[x] < min_heap[0] < nums[x]:\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n            \\n        mins = [float(\\'inf\\')] * len(nums)\\n        mins[0] = nums[0]\\n        for x in range(1, len(nums)):\\n            mins[x] = min(mins[x-1], nums[x])\\n            \\n        min_heap = []\\n        for x in range(len(nums)-1, 0, -1):\\n            heapq.heappush(min_heap, nums[x])\\n            \\n            while min_heap and (min_heap[0] <= mins[x]):\\n                heapq.heappop(min_heap)\\n            \\n            if min_heap and mins[x] < min_heap[0] < nums[x]:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 400774,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Solution1**\\n`minOnLeft[j]` indicates minimum on the left side of `j` (inclusive). [**this will be our a<sub>i</sub>**]\\nWhat we need is some smaller value on left of `j`  (i.e. `minOnLeft[j]`) and some smaller value on right of `j`  but higher than `minOnLeft[j]`.\\n\\nSo we can scan from the back and maintain a stack which just throws away unwanted values i.e. the values that are smaller than even `minOnLeft[j-1]`, then at each `j` [**this will be our a<sub>j</sub>**] we can see if anything remaining on its right in the stack and see if the peek [**this will be our a<sub>k</sub>**] is smaller than `a[j]`\\n\\nTime = `O(n)`\\n\\n```\\npublic boolean find132pattern(int[] a) {\\n        int n = a.length;\\n        if(n < 3) return false;\\n        int[] minOnLeft = new int[n];\\n        minOnLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            minOnLeft[i] = Math.min(a[i], minOnLeft[i-1]);\\n        Stack<Integer> s = new Stack<>();\\n        for(int j=n-1; j > 0; j--){\\n            if(minOnLeft[j-1] < a[j]){\\n                while(!s.isEmpty() && a[s.peek()] <= minOnLeft[j-1])\\n                    s.pop();\\n                if(!s.isEmpty() && a[s.peek()] < a[j])\\n                    return true;\\n                s.push(j);\\n            }\\n        }\\n        return false;\\n    }\\n```\\n**Solution2**\\n`minOnLeft[j]` indicates minimum on the left side of `j` (inclusive).\\nNow, if we mantain a `bst` coming from right, we can search for an element bigger than `minOnLeft[j-1]` in the sorted numbers from bst after `a[j]`.\\n\\nTime = `O(n lgn)`\\n\\n```\\npublic boolean find132pattern(int[] a) {\\n        int n = a.length;\\n        if(n < 3) return false;\\n        int[] minOnLeft = new int[n];\\n        TreeSet<Integer> bst = new TreeSet<>();\\n        minOnLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            minOnLeft[i] = Math.min(a[i], minOnLeft[i-1]);\\n        bst.add(a[n-1]);\\n        for(int j=n-2; j > 0; j--){\\n            TreeSet<Integer> tSet = (TreeSet<Integer>)bst.headSet(a[j]);\\n            if(!tSet.isEmpty() && tSet.higher(minOnLeft[j-1]) != null)\\n                return true;\\n            bst.add(a[j]);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean find132pattern(int[] a) {\\n        int n = a.length;\\n        if(n < 3) return false;\\n        int[] minOnLeft = new int[n];\\n        minOnLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            minOnLeft[i] = Math.min(a[i], minOnLeft[i-1]);\\n        Stack<Integer> s = new Stack<>();\\n        for(int j=n-1; j > 0; j--){\\n            if(minOnLeft[j-1] < a[j]){\\n                while(!s.isEmpty() && a[s.peek()] <= minOnLeft[j-1])\\n                    s.pop();\\n                if(!s.isEmpty() && a[s.peek()] < a[j])\\n                    return true;\\n                s.push(j);\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean find132pattern(int[] a) {\\n        int n = a.length;\\n        if(n < 3) return false;\\n        int[] minOnLeft = new int[n];\\n        TreeSet<Integer> bst = new TreeSet<>();\\n        minOnLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            minOnLeft[i] = Math.min(a[i], minOnLeft[i-1]);\\n        bst.add(a[n-1]);\\n        for(int j=n-2; j > 0; j--){\\n            TreeSet<Integer> tSet = (TreeSet<Integer>)bst.headSet(a[j]);\\n            if(!tSet.isEmpty() && tSet.higher(minOnLeft[j-1]) != null)\\n                return true;\\n            bst.add(a[j]);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565792,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1565780,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1571713,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1566219,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1566573,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1568699,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1771012,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1569170,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1576745,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1576719,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1565792,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1565780,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1571713,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1566219,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1566573,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1568699,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1771012,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1569170,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1576745,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1576719,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1750935,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1735582,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1574515,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1573720,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1571714,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 2028105,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1973111,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1930386,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1831094,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1742918,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            }
        ]
    }
]