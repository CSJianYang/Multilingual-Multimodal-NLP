[
    {
        "title": "Unique Paths II",
        "question_content": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nAn obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.\nReturn the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe testcases are generated so that the answer will be less than or equal to 2 * 109.\n&nbsp;\nExample 1:\n\nInput: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\nExample 2:\n\nInput: obstacleGrid = [[0,1],[0,0]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\tm == obstacleGrid.length\n\tn == obstacleGrid[i].length\n\t1 <= m, n <= 100\n\tobstacleGrid[i][j] is 0 or 1.",
        "solutions": [
            {
                "id": 23250,
                "title": "short-java-solution",
                "content": "    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int width = obstacleGrid[0].length;\\n        int[] dp = new int[width];\\n        dp[0] = 1;\\n        for (int[] row : obstacleGrid) {\\n            for (int j = 0; j < width; j++) {\\n                if (row[j] == 1)\\n                    dp[j] = 0;\\n                else if (j > 0)\\n                    dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[width - 1];\\n    }",
                "solutionTags": [],
                "code": "    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int width = obstacleGrid[0].length;\\n        int[] dp = new int[width];\\n        dp[0] = 1;\\n        for (int[] row : obstacleGrid) {\\n            for (int j = 0; j < width; j++) {\\n                if (row[j] == 1)\\n                    dp[j] = 0;\\n                else if (j > 0)\\n                    dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[width - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23248,
                "title": "my-c-dp-solution-very-simple",
                "content": "just use dp to find the answer , if there is a obstacle at (i,j), then dp[i][j] = 0. \\ntime is O(n*m) , space is O(n*m) . \\nhere is my code:\\n\\n    class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n            int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n            vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n            dp[0][1] = 1;\\n            for(int i = 1 ; i <= m ; ++i)\\n                for(int j = 1 ; j <= n ; ++j)\\n                    if(!obstacleGrid[i-1][j-1])\\n                        dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n            return dp[m][n];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n            int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n            vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n            dp[0][1] = 1;\\n            for(int i = 1 ; i <= m ; ++i)\\n                for(int j = 1 ; j <= n ; ++j)\\n                    if(!obstacleGrid[i-1][j-1])\\n                        dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n            return dp[m][n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 23252,
                "title": "4ms-o-n-dp-solution-in-c-with-explanations",
                "content": "Well, this problem is similar to **Unique Paths**. The introduction of obstacles only changes the boundary conditions and make some points unreachable (simply set to `0`).\\n\\nDenote the number of paths to arrive at point `(i, j)` to be `P[i][j]`, the state equation is `P[i][j] = P[i - 1][j] + P[i][j - 1]` if `obstacleGrid[i][j] != 1` and `0` otherwise. \\n\\nNow let's finish the boundary conditions. In the **Unique Paths** problem, we initialize `P[0][j] = 1, P[i][0] = 1` for all valid `i, j`. Now, due to obstacles, some boundary points are no longer reachable and need to be initialized to `0`. For example, if `obstacleGrid` is like `[0, 0, 1, 0, 0]`, then the last three points are not reachable and need to be initialized to be `0`. The result is `[1, 1, 0, 0, 0]`.\\n\\nNow we can write down the following (unoptimized) code. Note that we pad the `obstacleGrid` by `1` and initialize `dp[0][1] = 1` to unify the boundary cases. \\n\\n    class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n            int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n            vector<vector<int> > dp(m + 1, vector<int> (n + 1, 0));\\n            dp[0][1] = 1;\\n            for (int i = 1; i <= m; i++)\\n                for (int j = 1; j <= n; j++)\\n                    if (!obstacleGrid[i - 1][j - 1])\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            return dp[m][n];\\n        } \\n    };\\n\\nWell, the code is accepted but it has some obvious redundancy. There are two major concerns:\\n\\n 1. Each time when we update `path[i][j]`, we only need `path[i  - 1][j]` (at the same column) and `path[i][j - 1]` (at the left column), so it is unnecessary to maintain the full `m*n` matrix. Maintaining two columns is enough.\\n 2. There are some cases that the loop can be terminated earlier. Suppose `obstacleGrid = [[0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0]]`, then we can see that it is impossible to reach the bottom-right corner after updating the second column since the number of paths to reach each element in the second column is `0`.\\n\\nTaken these into considerations, we write down the following optimized code.\\n    \\n    class Solution {\\n    public: \\n        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n            int m = obstacleGrid.size();\\n            int n = obstacleGrid[0].size();\\n            vector<int> pre(m, 0);\\n            vector<int> cur(m, 0);\\n            for (int i = 0; i < m; i++) {\\n                if (!obstacleGrid[i][0])\\n                    pre[i] = 1;\\n                else break;\\n            }\\n            for (int j = 1; j < n; j++) {\\n                bool flag = false;\\n                if (!obstacleGrid[0][j]) {\\n                    cur[0] = pre[0];\\n                    if (cur[0]) flag = true; \\n                }\\n                else cur[0] = 0;\\n                for (int i = 1; i < m; i++) {\\n                    if (!obstacleGrid[i][j]) {\\n                        cur[i] = cur[i - 1] + pre[i];\\n                        if (cur[i]) flag = true;\\n                    }\\n                    else cur[i] = 0;\\n                }\\n                if (!flag) return 0;\\n                swap(pre, cur);\\n            }\\n            return pre[m - 1];\\n        }\\n    }; \\n\\nFurther inspecting the above code, keeping two vectors only serve for the purpose of recovering `pre[i]`, which is simply `cur[i]` before its update. So we can use only one vector and the space is further optimized.\\n\\n    class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n            int m = obstacleGrid.size();\\n            int n = obstacleGrid[0].size();\\n            vector<int> cur(m, 0);\\n            for (int i = 0; i < m; i++) {\\n                if (!obstacleGrid[i][0])\\n                    cur[i] = 1;\\n                else break;\\n            }\\n            for (int j = 1; j < n; j++) {\\n                bool flag = false;\\n                if (obstacleGrid[0][j])\\n                    cur[0] = 0;\\n                else flag = true;\\n                for (int i = 1; i < m; i++) {\\n                    if (!obstacleGrid[i][j]) {\\n                        cur[i] += cur[i - 1]; \\n                        if (cur[i]) flag = true;\\n                    }\\n                    else cur[i] = 0; \\n                }\\n                if (!flag) return 0;\\n            }\\n            return cur[m - 1];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n            int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n            vector<vector<int> > dp(m + 1, vector<int> (n + 1, 0));\\n            dp[0][1] = 1;\\n            for (int i = 1; i <= m; i++)\\n                for (int j = 1; j <= n; j++)\\n                    if (!obstacleGrid[i - 1][j - 1])\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n            return dp[m][n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1180249,
                "title": "easy-solutions-w-explanation-comments-optimization-from-brute-force-approach",
                "content": "We start at the top-left of the **`obstacleGrid`** and for each cell in the grid, we can either move right or down. We can\\'t land at an obstacle. We need to return the number of unique paths to reach the bottom-right of grid.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force) [Rejected]***\\n\\nLet\\'s build our solution starting from the brute force approach. Let\\'s directly apply what\\'s given in the problem statement.  At each cell, we have two choices -\\n\\n&emsp;&emsp;\\u2726 *Go Right*\\n&emsp;&emsp;\\u2726 *Go Down*\\n\\nSo, we can recursively build up our solution as -.\\n\\n1. At each cell, explore the two choices available to us - go right & go down (**Recursive function**).\\n\\n2. If we reach the bottom-right cell of the grid, we have found a unique path (**Base Condition - I**). \\n\\n3. If at any time, we reach a cell with value 1, it is an **obstacle cell** and we can\\'t move any further. So, we just stop exploring further paths from this cell (**Base Condition - II**).  \\n\\n\\nWe will accumulate all such unique paths.\\n\\n**C++**\\n```\\nint m, n;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        \\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);    \\n\\treturn solve(obstacleGrid, 0, 0);   \\n}\\n// function to recursively explore all unique paths\\nint solve(vector<vector<int> >& grid, int i, int j){\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;          // bounds checking\\n\\tif(grid[i][j]) return 0;   // if there\\'s obstacle, just return 0 and stop further exploration\\n\\tif(i == m - 1 && j == n - 1 && !grid[i][j]) return 1;     // if we have reached end cell, return 1 if there\\'s no obstacle   \\n\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1);     // explore the two choice we have at each cell\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdef solve(grid, i, j):\\n\\t\\tif i >= m or j >= n or i < 0 or j < 0 or grid[i][j]:\\n\\t\\t\\treturn 0\\n\\t\\tif i == m - 1 and j == n - 1: \\n\\t\\t\\treturn 1\\n\\t\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n\\treturn solve(grid, 0, 0)\\n```\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Recursive version) [Accepted]***\\n\\nWe can observe that there are a lot of cells that are revisited in the above appraoch and the whole path is recursed till the bottom-right cell is reached for each cell again and again. We don\\'t need to recalculate this everytime if we just store the previously calculated result for a given cell.\\n\\nWe can do this by maintaining a 2d DP array. Here *`dp[i][j]`* will denote the number of unique paths to reach the bottom-right corner of the grid starting from the cell - *`obstacleGrid[i][j]`*.\\n\\n**C++**\\n```\\nint m, n;\\nvector<vector<int> > dp;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);\\n\\tdp.resize(m, vector<int>(n));\\n\\treturn solve(obstacleGrid, 0, 0);\\n}\\n// function to recursively explore all unique paths and store the results once calculated\\nint solve(vector<vector<int>>& grid, int i, int j) {\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;    // bounds checking\\n\\tif(grid[i][j]) return dp[i][j] = 0;                 // obstacle found at current cell\\n\\tif(i == m - 1 && j == n - 1) return 1;              // reached bottom-right of grid ? return 1\\n\\tif(dp[i][j]) return dp[i][j];                       // if already computed for current cell, just return the stored results\\n\\treturn dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1); // recursively explore the two options available with us\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*len(grid[0]) for _ in range(len(grid))]\\n    def solve(grid, i, j):\\n        if i >= m or j >= n or i < 0 or j < 0 or grid[i][j]: return 0\\n        if i == m - 1 and j == n - 1:  return 1\\n        if dp[i][j]:\\n            return dp[i][j]\\n        dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n        return dp[i][j]\\n    return solve(grid, 0, 0)\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Iterative version) [Accepted]***\\n\\nWe can also solve it iteratively. We have 1 way in which we can start from *`grid[0][0]`* and for rest of the cells, we could have reached here from the top cell or the left cell. So, we can maintain *`dp[i][j]`* and iteratively accumulate unique paths for current cell by adding *`dp[i - 1][j]`* (number of ways we reached top cell) and *`dp[i][j - 1]`* (number of ways we reached left cell).\\n\\nHere, I am using padded row and column in *`dp`* to simplify the code. In this solution, *`dp[i][j]`*, will denote the number of unique paths to reach the cell *`grid[i-1][j-1]`* (since padded row and column used in dp at start) from the start. \\n\\nThus, we can iterate over the whole grid and at last return **`dp[m][n]`** which will be the number of unique paths to reach bottom-right of grid from the start.\\n\\nHere, *`dp[0][1]`* (or *`dp[1][0]`*) needs to be set to 1 at the start, so that *`dp[1][1]`* will become 1 in our loop (denoting we have one way to reach the starting cell `grid[0][0]`).\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (m + 1, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n\\t\\t\\t// dp[i][j] = sum of unique paths for top and left cell (cells from which we reach current one)\\n            dp[i][j] = !grid[i - 1][j - 1] ? dp[i - 1][j] + dp[i][j - 1] : 0;\\n    return dp[m][n];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1) for _ in range(len(grid) + 1)]\\n    dp[0][1] = 1\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if not grid[i - 1][j - 1] else 0\\n    return dp[-1][-1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Space Optimized) [Accepted]***\\n\\nWe can see that in the above solution, we are only ever accessing the current and previous rows of the dp array. So, we don\\'t need to maintain the whole *`M*N`* DP array and the space usage can be optimized by maintaining just 2 rows.\\n\\nA common way of doing this with most dp problems is to declare a two rows dp matrix and just alternate between the rows at each iteration. We can alternate between the rows by doing a parity check while indexing a row of dp. Thus, we can use `dp[0]` at even indices and `dp[1]` and odd indices of iteration.\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (2, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n            dp[i & 1][j] = !grid[i - 1][j - 1] ? dp[(i - 1) & 1][j] + dp[i & 1][j - 1] : 0;\\n    return dp[m & 1][n];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1)] * 2\\n\\tdp[0][1] = 1\\n\\tfor i in range(1, m + 1):\\n\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\tdp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1] if not grid[i - 1][j - 1] else 0\\n\\treturn dp[m & 1][-1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution V - (In-Place) [Accepted]***\\n\\nWe can also choose to modify the given input grid itself (if input modification is allowed). This solution is similar to *`Solution - III`*, with just the change that we are using *`grid`* itself instead of auxillary space for **`dp`**.\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n    grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\\n\\t/* For each cell of first row and column, we can either reach that cell in 1 way\\n\\t * if previous column/row cell are not obstacle respectively, or not reach it at all.\\n\\t * That\\'s what we are doing below */\\n    for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \\n    for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\\n    // same process as in above solutions -\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)            \\n            grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \\n    return grid[m - 1][n - 1];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0] ^= 1\\n\\tfor i in range(1, n):\\n\\t\\tgrid[0][i] = grid[0][i - 1] & (not grid[0][i])\\n\\tfor j in range(1, m):\\n\\t\\tgrid[j][0] = grid[j - 1][0] & (not grid[j][0])\\n\\tfor i in range(1, m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tgrid[i][j] = grid[i - 1][j] + grid[i][j - 1] if not grid[i][j] else 0\\n\\treturn grid[m - 1][n - 1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint m, n;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        \\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);    \\n\\treturn solve(obstacleGrid, 0, 0);   \\n}\\n// function to recursively explore all unique paths\\nint solve(vector<vector<int> >& grid, int i, int j){\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;          // bounds checking\\n\\tif(grid[i][j]) return 0;   // if there\\'s obstacle, just return 0 and stop further exploration\\n\\tif(i == m - 1 && j == n - 1 && !grid[i][j]) return 1;     // if we have reached end cell, return 1 if there\\'s no obstacle   \\n\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1);     // explore the two choice we have at each cell\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdef solve(grid, i, j):\\n\\t\\tif i >= m or j >= n or i < 0 or j < 0 or grid[i][j]:\\n\\t\\t\\treturn 0\\n\\t\\tif i == m - 1 and j == n - 1: \\n\\t\\t\\treturn 1\\n\\t\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n\\treturn solve(grid, 0, 0)\\n```\n```\\nint m, n;\\nvector<vector<int> > dp;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);\\n\\tdp.resize(m, vector<int>(n));\\n\\treturn solve(obstacleGrid, 0, 0);\\n}\\n// function to recursively explore all unique paths and store the results once calculated\\nint solve(vector<vector<int>>& grid, int i, int j) {\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;    // bounds checking\\n\\tif(grid[i][j]) return dp[i][j] = 0;                 // obstacle found at current cell\\n\\tif(i == m - 1 && j == n - 1) return 1;              // reached bottom-right of grid ? return 1\\n\\tif(dp[i][j]) return dp[i][j];                       // if already computed for current cell, just return the stored results\\n\\treturn dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1); // recursively explore the two options available with us\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*len(grid[0]) for _ in range(len(grid))]\\n    def solve(grid, i, j):\\n        if i >= m or j >= n or i < 0 or j < 0 or grid[i][j]: return 0\\n        if i == m - 1 and j == n - 1:  return 1\\n        if dp[i][j]:\\n            return dp[i][j]\\n        dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n        return dp[i][j]\\n    return solve(grid, 0, 0)\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (m + 1, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n\\t\\t\\t// dp[i][j] = sum of unique paths for top and left cell (cells from which we reach current one)\\n            dp[i][j] = !grid[i - 1][j - 1] ? dp[i - 1][j] + dp[i][j - 1] : 0;\\n    return dp[m][n];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1) for _ in range(len(grid) + 1)]\\n    dp[0][1] = 1\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if not grid[i - 1][j - 1] else 0\\n    return dp[-1][-1]\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (2, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n            dp[i & 1][j] = !grid[i - 1][j - 1] ? dp[(i - 1) & 1][j] + dp[i & 1][j - 1] : 0;\\n    return dp[m & 1][n];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1)] * 2\\n\\tdp[0][1] = 1\\n\\tfor i in range(1, m + 1):\\n\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\tdp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1] if not grid[i - 1][j - 1] else 0\\n\\treturn dp[m & 1][-1]\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n    grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\\n\\t/* For each cell of first row and column, we can either reach that cell in 1 way\\n\\t * if previous column/row cell are not obstacle respectively, or not reach it at all.\\n\\t * That\\'s what we are doing below */\\n    for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \\n    for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\\n    // same process as in above solutions -\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)            \\n            grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \\n    return grid[m - 1][n - 1];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0] ^= 1\\n\\tfor i in range(1, n):\\n\\t\\tgrid[0][i] = grid[0][i - 1] & (not grid[0][i])\\n\\tfor j in range(1, m):\\n\\t\\tgrid[j][0] = grid[j - 1][0] & (not grid[j][0])\\n\\tfor i in range(1, m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tgrid[i][j] = grid[i - 1][j] + grid[i][j - 1] if not grid[i][j] else 0\\n\\treturn grid[m - 1][n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 23410,
                "title": "python-different-solutions-o-m-n-o-n-in-place",
                "content": "        \\n    # O(m*n) space\\n    def uniquePathsWithObstacles1(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0 for _ in xrange(c)] for _ in xrange(r)]\\n        dp[0][0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, r):\\n            dp[i][0] = dp[i-1][0] * (1 - obstacleGrid[i][0])\\n        for i in xrange(1, c):\\n            dp[0][i] = dp[0][i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) * (1 - obstacleGrid[i][j])\\n        return dp[-1][-1]\\n        \\n    # O(n) space\\n    def uniquePathsWithObstacles2(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        cur = [0] * c\\n        cur[0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, c):\\n            cur[i] = cur[i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            cur[0] *= (1 - obstacleGrid[i][0])\\n            for j in xrange(1, c):\\n                cur[j] = (cur[j-1] + cur[j]) * (1 - obstacleGrid[i][j])\\n        return cur[-1]\\n    \\n    # in place\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        obstacleGrid[0][0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, r):\\n            obstacleGrid[i][0] = obstacleGrid[i-1][0] * (1 - obstacleGrid[i][0])\\n        for i in xrange(1, c):\\n            obstacleGrid[0][i] = obstacleGrid[0][i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                obstacleGrid[i][j] = (obstacleGrid[i-1][j] + obstacleGrid[i][j-1]) * (1 - obstacleGrid[i][j])\\n        return obstacleGrid[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # O(m*n) space\\n    def uniquePathsWithObstacles1(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0 for _ in xrange(c)] for _ in xrange(r)]\\n        dp[0][0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, r):\\n            dp[i][0] = dp[i-1][0] * (1 - obstacleGrid[i][0])\\n        for i in xrange(1, c):\\n            dp[0][i] = dp[0][i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) * (1 - obstacleGrid[i][j])\\n        return dp[-1][-1]\\n        \\n    # O(n) space\\n    def uniquePathsWithObstacles2(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        cur = [0] * c\\n        cur[0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, c):\\n            cur[i] = cur[i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            cur[0] *= (1 - obstacleGrid[i][0])\\n            for j in xrange(1, c):\\n                cur[j] = (cur[j-1] + cur[j]) * (1 - obstacleGrid[i][j])\\n        return cur[-1]\\n    \\n    # in place\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        if not obstacleGrid:\\n            return \\n        r, c = len(obstacleGrid), len(obstacleGrid[0])\\n        obstacleGrid[0][0] = 1 - obstacleGrid[0][0]\\n        for i in xrange(1, r):\\n            obstacleGrid[i][0] = obstacleGrid[i-1][0] * (1 - obstacleGrid[i][0])\\n        for i in xrange(1, c):\\n            obstacleGrid[0][i] = obstacleGrid[0][i-1] * (1 - obstacleGrid[0][i])\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                obstacleGrid[i][j] = (obstacleGrid[i-1][j] + obstacleGrid[i][j-1]) * (1 - obstacleGrid[i][j])\\n        return obstacleGrid[-1][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23395,
                "title": "java-simple-and-clean-dp-solution-easy-to-understand",
                "content": "   \\n\\tpublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\t\\tint m = obstacleGrid.length, n = obstacleGrid[0].length;\\n\\t\\tint[][] path = new int[m][n];\\n\\t\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tif (obstacleGrid[i][0] == 1)  {\\n\\t\\t\\t\\tpath[i][0] = 0;\\n\\t\\t\\t\\t//on the first column, if there is an obstacle, the rest are blocked. \\n\\t\\t\\t\\t//no need to continue.\\n\\t\\t\\t\\tbreak;  \\n\\t\\t\\t} else\\n\\t\\t\\t\\tpath[i][0] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (obstacleGrid[0][j] == 1)  {\\n\\t\\t\\t\\tpath[0][j] = 0;\\n\\t\\t\\t\\t//First row, once obstacle found, the rest are blocked.\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\t} else\\n\\t\\t\\t\\tpath[0][j] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (obstacleGrid[i][j] == 1) \\n\\t\\t\\t\\t\\tpath[i][j] = 0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tpath[i][j] = path[i-1][j] + path[i][j-1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn path[m-1][n-1];\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "   \\n\\tpublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\t\\tint m = obstacleGrid.length, n = obstacleGrid[0].length;\\n\\t\\tint[][] path = new int[m][n];\\n\\t\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tif (obstacleGrid[i][0] == 1)  {\\n\\t\\t\\t\\tpath[i][0] = 0;\\n\\t\\t\\t\\t//on the first column, if there is an obstacle, the rest are blocked. \\n\\t\\t\\t\\t//no need to continue.\\n\\t\\t\\t\\tbreak;  \\n\\t\\t\\t} else\\n\\t\\t\\t\\tpath[i][0] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (obstacleGrid[0][j] == 1)  {\\n\\t\\t\\t\\tpath[0][j] = 0;\\n\\t\\t\\t\\t//First row, once obstacle found, the rest are blocked.\\n\\t\\t\\t\\tbreak; \\n\\t\\t\\t} else\\n\\t\\t\\t\\tpath[0][j] = 1;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (obstacleGrid[i][j] == 1) \\n\\t\\t\\t\\t\\tpath[i][j] = 0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tpath[i][j] = path[i-1][j] + path[i][j-1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn path[m-1][n-1];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2055409,
                "title": "beginner-friendly-recursion-to-dp-intuition-explained-python",
                "content": "Here, we have an obstacleGrid (say ***obs***) of size m* n. We can traverse through this grid by going down and/or right only.\\n**Idea:** We start travering the array from` start index (0, 0)`.\\n* We consider a `path to be valid`, if it has reached the last index (m-1, n-1).\\n* We consider a `path to be invalid`, if either it exceeds the boundary of the ***obs*** grid or the current position in the ***obs*** grid has an obstacle in it.\\n\\nThe above two conditions serves as the **base condition of our recursion**, \\n* for **valid** cases we `return 1` saying that consider this path, and \\n* for **invalid** cases we `return 0` saying that do not consider this path.\\n\\nNow coming to **the recursive part**: We want to traverse the matrix in both right and down direction. So, we recursively call this function for both the right `(i + 1, j)` and down `(i, j+1)` indices. \\n\\n***How does this work?***\\n\\nSee consider you are currently at any arbitrary index in the matrix `(i, j)` . Your goal is to return the `max number of valid paths from (i, j) to (m-1, n-1)`.\\n\\n`From (m-1, n-1) to (m-1, n-1)`, we have just one valid path so return 1 directly from the base condition.\\n...\\n`From (i, j) to (m-1, n-1)`, let us assume there was **1** possible path to go from the downside and **1** possible path to go from the rightside, so total number of ways to reach (m-1, n-1) from (i, j) becomes 1 + 1 **= 2**. \\n\\nIn general, if there was **x** possible path to go from the downside and **y** possible path to go from the rightside, so total number of ways to reach (m-1, n-1) from (i, j) becomes **x + y**.\\n\\nSimilarly, If we compute it for index (0, 0) to (m-1, n-1), we will get all possible ways to reach from start index to the end index.\\n\\nThe recursive code (***not working, TLE***) is given below:\\n\\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        def solve(i , j):\\n            # base condition for recursion\\n            if i == m - 1 and j == n - 1:\\n                return 1\\n            if i >= m or j >= n or obs[i][j] == 1:\\n                return 0\\n            # the down and right recursive calls respectively\\n            return solve(i + 1, j) + solve(i, j+1)\\n        \\n        return solve(0,0)\\n```\\n\\nNo doubt, the above solution runs perfectly fine. But it doesnot match the expected time complexity, hence results in generating a TLE error. \\n\\n***Why TLE?*** =>Here there are total **m * n** grids and each having **2** possiblities : has obstacles or clear path (does not have a obstacle). We will be recursively traversing through the grid considering both the possibilites. Hence, time complexity = O(2 ^ (m * n)) = O(2 ^ (100 * 100)) = O(2 ^ 10000) = O(10 ^12) nearly.\\n\\nThus, **time complexity > O(10 ^ 8)**. and hence ***Time Limit Exceeded*** as Python generally caps the complexity at O(10^8), meaning you cannot exceed it. \\n\\n**Can we do any better?** \\n\\nSee generally when you have TLE for recursive solutions, you can always memoize it (it\\'s just a random observation). But this is not a good reason to say to the interviewers. xD\\n\\n**How to identify a DP problem?** Analyze the problem and Check for overlapping subproblems, so that we can memoize it.\\n\\nConsider the first example as shown below: (indexes of each element is given in *(i, j)* format).\\n![image](https://assets.leetcode.com/users/images/f366ba68-adf7-4e50-9667-49190b5a86e4_1653007809.711647.png)\\n\\nLet\\'s say we are at (0, 1), so by our recursive apporach we would calculate the value of (1,1) , i.e., down and (0, 2), i.e., right indices.\\nNow, let\\'s say we reached (1, 0), here also we will need to calulate (2, 0) and (1, 1). \\n\\nBut haven\\'t we already calulated the number of paths for (1, 1) earlier? **Yes, we did** right (when we were traversing down from (0, 1) index). \\n\\nSo, why not **store it some where** so that we can use it later without the need of recomputing it.\\nJust store the previously computed value and return it whenever the (already computed) index (1, 0) is called. Similarly, do the same for all indices that requires recomputation.\\n\\nThis process of finding overlapping subproblems, storing the computed value, reusing the previously computed value and reducing the recomputation complexity is called **Memoization** or **Top Down Dynamic Programming Approach** (this is specific to recursion, it\\'s nearly equivalent *Bottom up approach or Tabulation* is achieved using iteration).\\n\\nThe Memoized Code: (**Top Down DP**) => **ACCEPTED**.\\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        # create a dp array of size m * n to store already computed number of paths for index (i, j) to end\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as number of paths can only be a whole number.\\n        dp = [[-1]*n for _ in range(m)]\\n        \\n        def solve(i , j):\\n            if i >= m or j >= n or obs[i][j] == 1:\\n                return 0\\n            \\n            if i == m - 1 and j == n - 1:\\n                return 1\\n            \\n            \\n            # if the value of dp[i][j] is updated then directly return the updated value\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            # else compute the value of dp[i][j] for the first time ever\\n            # and return it saying that the returned number (dp[i][j]) of ways are possible from\\n            # (i, j) to the end index.\\n            dp[i][j] = solve(i + 1, j) + solve(i, j+1)\\n            return dp[i][j]\\n        \\n        return solve(0,0)\\n```\\n\\n**Time and Space Complexity Analysis:** (for Top Down DP)\\nHere, each of the successful recursive calls (whose value will be inserted in the dp matrix) will exactly be called once, because later it will take it directly from the dp array in constant time. And the unsuccessful recursive calls will return from the base condition in constant time. But we are traversing through the matrix of size \\'m * n\\' through nested loops (simultaneously). Thus, **optimized time complexity = O(m * n)** owing to the traversal of matrix.\\n\\nNow, we have used only one variable sized space that is dp array of size \\'m * n\\'. Apart from that all other variables are constant sized like n, m, ans, etc.. are fixed sized 32 - bit integer variables. So, no need to consider that, as their size will always be fixed and will not change with respect to change in input variable. Hence, **Space complexity = O(m * n)** owing to the dp array.\\n\\nNow, we know that, any code that is written in **Top Down DP can be easlily converted to Bottom-up DP**. \\n\\n**Is there any advantage of doing so?** or Is it just a waste of time to convert the recursive code to Iterative code?\\n\\nSee, whenever there is recursion involved we use some extra memory in the stack region of the main memory (RAM) to store the functions that are being called recursively one after another.\\n\\nThis stack space is not considered while calculating the output space complexity. So, **asymptotically, it does not** matter whether you convert recursion into iteration or not. But **practically it does matter**.\\n\\n***Let\\'s see how*** => The max depth of recursion will be O(m + n) as in the worst case **either** we will go fully towards right then fully towards down **or** we will first go fully towards down then move straight fully to the right, till we reach the end index. (It will not be anything more than O(m + n)) as we do not traverse back (i.e., top or left) ever. \\n\\nHence **Stack Space =** max number of recursive functions called at a stretch = max depth of recursion **= O(m + n)**. \\n\\nThus, by coverting the Top Down DP to Bottom Up DP, we can further reduce this practical execution space. Thus, keeping our main memory little bit free for storing other data, hence reduing page faults (ignore it for now, if you don\\'t know).\\n\\nThe Tabulation Method (**Bottom Up Dp**): => Definitely **accepted**..... xD\\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        # create a dp array of size m * n to store already computed number of paths for index (i, j) to end\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as number of paths can only be a whole number.\\n        dp = [[0]*n for _ in range(m)]\\n        \\n        if obs[0][0] == 1 or obs[-1][-1] == 1:\\n            return 0\\n        \\n        # initialize the first row first column of dp\\n        # assign the clear path = 1 and obstacles = 0 value in dp based in obstacle_grid\\n        # we did this because we want to add clear paths and not add obstacles path.\\n        dp[0][0] = 1\\n        for i in range(1,m):\\n            dp[i][0] = 1 if obs[i][0]==0 and dp[i-1][0]==1 else 0\\n            \\n        for j in range(1,n):\\n            dp[0][j] = 1 if obs[0][j]==0  and dp[0][j-1]==1 else 0\\n        \\n        # add clear paths if no obstacles are found.\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if obs[i][j] == 0:\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        print(dp)\\n        return dp[m-1][n-1]\\n```\\n\\nI am leaving the above code for you to understand yourself as it will help you analyze deeper. For hints, I have given a few comments in the code.\\n\\nAlso, **note that** in Top Down DP we returned dp[0][0] but in Bottom Up DP Approach we returned dp[-1][-1]. Why??? - Brainstorm a little first, and do comment down below, your findings regrading this.\\n\\nTime Complexity = Space Complexity = O(m * n)  for Bottom Up DP (in this case).\\n***Can we further reduce the space complexity?*** Yes, we can use the obstacle grid itself inplace of DP array to reduce the space complexity to O(1). But generally, modfying the input itself is not considered a wise choice, until and unless an inplace solution is required, where you do not need to return anything, just modify the input array as per conditions and the main function will access it using reference of the input variable. So, no need to return. Hence, inplace. But when nothing such is mentioned and, in real life scenerio if we modify our input array, there might be a possiblilty that this array may be used further somewhere in the program. But by modifying it, we lost the original array, which may not be a good practice.\\n\\nIf this helps you, then **Please UPVOTE**.\\n\\n***Similar Problems with detailed intuitions explained:***\\n\\n* *Leetcode 329. Longest Increasing Path in a Matrix: https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/2052360/python-beginner-friendly-recursion-to-dp-intuition-explained*\\n\\n* *Leetcode 576. Out of Boundary Paths: https://leetcode.com/problems/out-of-boundary-paths/discuss/1293697/python-easy-to-understand-explanation-recursion-and-memoization-with-time-and-space-complexity*\\n\\n* *Leetcode 792. Number of Matching Subsequences: https://leetcode.com/problems/number-of-matching-subsequences/discuss/1289549/python-explained-all-possible-solutions-with-time-and-space-complexity*",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        def solve(i , j):\\n            # base condition for recursion\\n            if i == m - 1 and j == n - 1:\\n                return 1\\n            if i >= m or j >= n or obs[i][j] == 1:\\n                return 0\\n            # the down and right recursive calls respectively\\n            return solve(i + 1, j) + solve(i, j+1)\\n        \\n        return solve(0,0)\\n```\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        # create a dp array of size m * n to store already computed number of paths for index (i, j) to end\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as number of paths can only be a whole number.\\n        dp = [[-1]*n for _ in range(m)]\\n        \\n        def solve(i , j):\\n            if i >= m or j >= n or obs[i][j] == 1:\\n                return 0\\n            \\n            if i == m - 1 and j == n - 1:\\n                return 1\\n            \\n            \\n            # if the value of dp[i][j] is updated then directly return the updated value\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            \\n            # else compute the value of dp[i][j] for the first time ever\\n            # and return it saying that the returned number (dp[i][j]) of ways are possible from\\n            # (i, j) to the end index.\\n            dp[i][j] = solve(i + 1, j) + solve(i, j+1)\\n            return dp[i][j]\\n        \\n        return solve(0,0)\\n```\n```\\nclass Solution:\\n    \\n    # here I just changed the formal variable name \\n    # from obstacleGrid to obs just for convinience\\n    \\n    def uniquePathsWithObstacles(self, obs: List[List[int]]) -> int:\\n        m, n = len(obs), len(obs[0])\\n        \\n        # create a dp array of size m * n to store already computed number of paths for index (i, j) to end\\n        # where 0 <= i < m and 0 <= j < n\\n        # initialize the dp array by -1 as number of paths can only be a whole number.\\n        dp = [[0]*n for _ in range(m)]\\n        \\n        if obs[0][0] == 1 or obs[-1][-1] == 1:\\n            return 0\\n        \\n        # initialize the first row first column of dp\\n        # assign the clear path = 1 and obstacles = 0 value in dp based in obstacle_grid\\n        # we did this because we want to add clear paths and not add obstacles path.\\n        dp[0][0] = 1\\n        for i in range(1,m):\\n            dp[i][0] = 1 if obs[i][0]==0 and dp[i-1][0]==1 else 0\\n            \\n        for j in range(1,n):\\n            dp[0][j] = 1 if obs[0][j]==0  and dp[0][j-1]==1 else 0\\n        \\n        # add clear paths if no obstacles are found.\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if obs[i][j] == 0:\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        print(dp)\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23291,
                "title": "java-solution-using-dynamic-programming-o-1-space",
                "content": "    public class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            \\n            //Empty case\\n            if(obstacleGrid.length == 0) return 0;\\n            \\n            int rows = obstacleGrid.length;\\n            int cols = obstacleGrid[0].length;\\n            \\n            for(int i = 0; i < rows; i++){\\n                for(int j = 0; j < cols; j++){\\n                    if(obstacleGrid[i][j] == 1)\\n                        obstacleGrid[i][j] = 0;\\n                    else if(i == 0 && j == 0)\\n                        obstacleGrid[i][j] = 1;\\n                    else if(i == 0)\\n                        obstacleGrid[i][j] = obstacleGrid[i][j - 1] * 1;// For row 0, if there are no paths to left cell, then its 0,else 1\\n                    else if(j == 0)\\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] * 1;// For col 0, if there are no paths to upper cell, then its 0,else 1\\n                    else\\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n                }\\n            }\\n            \\n            return obstacleGrid[rows - 1][cols - 1];\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            \\n            //Empty case\\n            if(obstacleGrid.length == 0) return 0;\\n            \\n            int rows = obstacleGrid.length;\\n            int cols = obstacleGrid[0].length;\\n            \\n            for(int i = 0; i < rows; i++){\\n                for(int j = 0; j < cols; j++){\\n                    if(obstacleGrid[i][j] == 1)\\n                        obstacleGrid[i][j] = 0;\\n                    else if(i == 0 && j == 0)\\n                        obstacleGrid[i][j] = 1;\\n                    else if(i == 0)\\n                        obstacleGrid[i][j] = obstacleGrid[i][j - 1] * 1;// For row 0, if there are no paths to left cell, then its 0,else 1\\n                    else if(j == 0)\\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] * 1;// For col 0, if there are no paths to upper cell, then its 0,else 1\\n                    else\\n                        obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 146073,
                "title": "python-dp-beat-100-python-submissions",
                "content": "Thanks to leetcode\\'s new servers :)\\n\\n\\ndp formule is very easy below:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/joezhow777/image_1530876896.png)\\n\\n```\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n\\n        for i in range(len(obstacleGrid)):\\n            for j in range(len(obstacleGrid[0])):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i-1>=0:\\n                        dp[i][j] += dp[i-1][j]\\n                    if j-1>=0:\\n                         dp[i][j] += dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[0]*len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n\\n        for i in range(len(obstacleGrid)):\\n            for j in range(len(obstacleGrid[0])):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i-1>=0:\\n                        dp[i][j] += dp[i-1][j]\\n                    if j-1>=0:\\n                         dp[i][j] += dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1180311,
                "title": "js-python-java-c-easy-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to try every path with a **recursive** **depth first search** (**DFS**) approach. That would involve duplicating the processing used for repeating subpaths, however, which would quickly lead to a **TLE** result. When faced with repeating subproblems, we should be thinking of a **dynamic programming** (**DP**) approach to store completed subproblem and avoid any unnecessary duplication of processing.\\n\\nIn this situation, we can create a DP matrix (**dp**) in the same dimensions as our input matrix (**OG**). (_**Note**: We can choose to use an **in-place** approach here and use **OG** as our DP matrix in order to reduce the **space complexity** of our solution to **O(1)**._) Each cell in **dp** will represent the number of paths that lead to the corresponding cell in **OG**. Since the robot can only move either to the right or down, we can perform a **bottom-up** DP solution, working from the initial cell and iterating downward and rightward through **OG**.\\n\\nEach cell in **OG** (**OG[i][j]**) can potentially reached by only two previously-visited cells (**OG[i-1][j]** & **OG[i][j-1]**), so the number of ways to reach the current cell (**dp[i][j]**) should be the sum of the ways to reach those other two cells (**dp[i-1][j] + dp[i][j-1]**), should they exist.\\n\\nSince any cell representing an obstacle cannot be a part of a path, its value in **dp** should be **0**. We\\'ll also need to seed the initial starting position with a value of **1** to represent the single initial path. Once we\\'re done building **dp**, the value of the bottom-right cell should be our answer.\\n\\n - _**Time Complexity: O(N * M)** where **N** and **M** are the dimensions of the input matrix_\\n - _**Space Complexity: O(N * M)** for the DP matrix_\\n    - _or **O(1)** if we use an **in-place** approach for the DP matrix_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can opt to use @lru_cache instead of a standard DP matrix; the standard approach is shown below.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.6MB** (beats 100% / 96%).\\n```javascript\\nvar uniquePathsWithObstacles = function(OG) {\\n    if (OG[0][0]) return 0\\n    let m = OG.length, n = OG[0].length\\n    let dp = Array.from({length: m}, el => new Uint32Array(n))\\n    dp[0][0] = 1\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++)\\n            if (OG[i][j] || (!i && !j)) continue\\n            else dp[i][j] = (i ? dp[i-1][j] : 0) + (j ? dp[i][j-1] : 0)\\n    return dp[m-1][n-1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **36ms / 14.2MB** (beats 94% / 84%).\\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, OG: List[List[int]]) -> int:\\n        if OG[0][0]: return 0\\n        m, n = len(OG), len(OG[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if OG[i][j] or (i == 0 and j == 0): continue\\n                dp[i][j] = (dp[i-1][j] if i else 0) + (dp[i][j-1] if j else 0)\\n        return dp[m-1][n-1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.0MB** (beats 100% / 67%).\\n```java\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.7MB** (beats 100% / 46%).\\n```c++\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.size(), n = OG[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar uniquePathsWithObstacles = function(OG) {\\n    if (OG[0][0]) return 0\\n    let m = OG.length, n = OG[0].length\\n    let dp = Array.from({length: m}, el => new Uint32Array(n))\\n    dp[0][0] = 1\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++)\\n            if (OG[i][j] || (!i && !j)) continue\\n            else dp[i][j] = (i ? dp[i-1][j] : 0) + (j ? dp[i][j-1] : 0)\\n    return dp[m-1][n-1]\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, OG: List[List[int]]) -> int:\\n        if OG[0][0]: return 0\\n        m, n = len(OG), len(OG[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if OG[i][j] or (i == 0 and j == 0): continue\\n                dp[i][j] = (dp[i-1][j] if i else 0) + (dp[i][j-1] if j else 0)\\n        return dp[m-1][n-1]\\n```\n```java\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.size(), n = OG[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896905,
                "title": "100-dynamic-programming-video-optimal-solution",
                "content": "# Problem Understanding\\n\\nIn the \"Unique Paths II\" problem, we are presented with a grid filled with obstacles and open paths. Starting from the top-left corner, the goal is to find the number of unique paths that lead to the bottom-right corner. We can only move right or down at any point in time. If a cell has an obstacle, we cannot pass through it.\\n\\nFor example, consider the following grid:\\n\\n$$\\n\\\\begin{array}{ccc}\\n0 & 0 & 0 \\\\\\\\\\n0 & 1 & 0 \\\\\\\\\\n0 & 0 & 0 \\\\\\\\\\n\\\\end{array}\\n$$\\n\\n![63_tsa.png](https://assets.leetcode.com/users/images/ec5e79ee-d2e3-47aa-adaf-aa07efa4b36b_1691802199.0146625.png)\\n\\n\\n- The grid cells with obstacles are colored in red.\\n- The two unique paths from the top-left to the bottom-right corner are represented by the blue and green dashed lines.\\n\\nFrom the plot, you can see the two possible routes:\\n\\n- The blue path goes Right -> Right -> Down -> Down.\\n- The green path goes Down -> Down -> Right -> Right.\\n\\n---\\n\\n# Live Coding\\nhttps://youtu.be/pJ40_FmXAfo\\n\\n- [in Python \\uD83D\\uDC0D](https://youtu.be/pJ40_FmXAfo)\\n- [in Rust \\uD83E\\uDD80](https://youtu.be/xt_1OzCH_NA)\\n\\n# Approach\\n\\n## The Basic Idea\\n\\nThe underlying concept is rooted in dynamic programming. Essentially, for any cell `(i, j)`, the number of ways you can reach it is the sum of the ways you can reach the cell directly above it `(i-1, j)` and the cell directly to its left `(i, j-1)`. However, this is only true if the cell `(i, j)` does not have an obstacle. If it does, then the number of ways to reach this cell is 0 because it\\'s inaccessible.\\n\\n### 2D Transition:\\nIn a 2D dynamic programming approach, you would have a `dp` array of size `m x n`, where ` dp[i][j] ` represents the number of ways to reach cell ` (i, j) `.\\n\\nThe transition formula would be:\\n$$ dp[i][j] = \\n\\\\begin{cases} \\n0 & \\\\text{if } obstacleGrid[i][j] = 1 \\\\\\\\\\ndp[i-1][j] + dp[i][j-1] & \\\\text{otherwise}\\n\\\\end{cases}\\n$$\\n\\nSo, for each cell ` (i, j) `, if there\\'s no obstacle, its value would be the sum of the cell above it and the cell to its left.\\n\\n### Translation to 1D:\\n\\nNow, given the 2D transition, notice how for any cell \\\\( (i, j) \\\\), we only need values from the current row and the previous row. This observation allows us to reduce our 2D `dp` array to two 1D arrays, `previous` and `current`.\\n\\nThe transition formula in 1D would be analogous to the 2D version but slightly adjusted:\\n\\nFor the first column (`j = 0`):\\n$$ current[0] = \\n\\\\begin{cases} \\n0 & \\\\text{if } obstacleGrid[i][0] = 1 \\\\\\\\\\nprevious[0] & \\\\text{otherwise}\\n\\\\end{cases}\\n$$\\n\\nFor other columns:\\n$$ current[j] = \\n\\\\begin{cases} \\n0 & \\\\text{if } obstacleGrid[i][j] = 1 \\\\\\\\\\nprevious[j] + current[j-1] & \\\\text{otherwise}\\n\\\\end{cases}\\n$$\\n\\nHere, `previous` is analogous to `dp[i-1]` and `current` is analogous to `dp[i]` from our 2D approach. After processing each row, we\\'ll swap `previous` and `current` to roll over to the next iteration.\\n\\nThe transition remains conceptually the same between the 2D and 1D versions. The 1D optimization simply leverages the observation that for each cell, we only need data from the current and previous rows. This reduces space complexity from $$ O(m \\\\times n) $$ to $$ O(n) $$.\\n\\nThis rolling array technique is a common optimization strategy in dynamic programming problems involving grids.\\n\\n### Step-by-step Breakdown:\\n\\n1. **Initialization**:\\n   - We initialize the `previous` array with zeros. This array represents the number of ways to reach each cell in the previous row.\\n   - We set `previous[0]` to 1 because there\\'s only one way to get to the starting cell (by starting there!).\\n   \\n2. **Iterate through the Grid**:\\n   - For each row, we consider each cell:\\n     - If the cell has an obstacle, it\\'s unreachable, so the number of ways to get there (`current[j]`) is 0.\\n     - Otherwise, the number of ways to reach the cell is the sum of the ways to reach the cell above and the cell to the left. This translates to `current[j-1] + previous[j]`.\\n   - Once we\\'ve processed a row, we set `previous` to `current`, preparing for the next iteration.\\n\\n3. **Result**:\\n   - Once we\\'ve processed all rows, `previous[n-1]` gives us the number of unique paths to the bottom-right corner of the grid.\\n\\n## Example\\n\\nUsing the earlier example:\\n\\n$$\\n\\\\begin{array}{ccc}\\n0 & 0 & 0 \\\\\\\\\\n0 & 1 & 0 \\\\\\\\\\n0 & 0 & 0 \\\\\\\\\\n\\\\end{array}\\n$$\\n\\nHere\\'s how the `previous` and `current` arrays evolve:\\n\\nThe function\\'s output matches the example description:\\n\\n**Initial State**:\\n- `previous`: $$[1, 0, 0]$$\\n- `current`: $$[0, 0, 0]$$\\n\\n**After processing row 0**:\\n- `previous`: $$[1, 0, 0]$$\\n- `current`: $$[1, 1, 1]$$\\n\\n**After processing row 1**:\\n- `previous`: $$[1, 1, 1]$$\\n- `current`: $$[1, 0, 1]$$\\n\\n**After processing row 2**:\\n- `previous`: $$[1, 0, 1]$$\\n- `current`: $$[1, 1, 2]$$\\n\\nFrom the final state of the `previous` array, we can infer that there are 2 unique paths from the top-left to the bottom-right corner, avoiding obstacles. This matches the expected result.\\n\\n# Complexity\\n\\n**Time Complexity:** $$O(m \\\\times n)$$\\n**Space Complexity:** $$O(n)$$\\n\\nThis solution is optimal in terms of both time and space complexity. It efficiently computes the number of unique paths by building upon previous calculations.\\n\\n# Performance\\n\\n| Language    | Runtime (ms) | Runtime Beat (%) | Memory (MB) | Memory Beat (%) |\\n|-------------|--------------|------------------|-------------|-----------------|\\n| Go          | 0            | 100%             | 2.4         | 71.38%          |\\n| C++         | 0            | 100%             | 7.6         | 81.25%          |\\n| Java        | 0            | 100%             | 40.5        | 72.53%          |\\n| Rust        | 1            | 85%              | 2           | 87.50%          |\\n| Python3     | 38           | 99.30%           | 16.3        | 82.98%          |\\n| JavaScript  | 47           | 97.40%           | 41.6        | 97.86%          |\\n| C#          | 81           | 80.72%           | 38.7        | 63.25%          |\\n\\n![perf_518.png](https://assets.leetcode.com/users/images/3cb0ceab-f4d0-4cad-9711-d0e194aad604_1691801587.1220236.png)\\n\\n\\n---\\n\\n# Code\\n\\n``` Python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        previous = [0] * n\\n        current = [0] * n\\n        previous[0] = 1\\n        \\n        for i in range(m):\\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\\n            for j in range(1, n):\\n                current[j] = 0 if obstacleGrid[i][j] == 1 else current[j-1] + previous[j]\\n            previous[:] = current\\n        \\n        return previous[n-1]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(std::vector<std::vector<int>>& obstacleGrid) {\\n        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n        \\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        std::vector<int> previous(n, 0);\\n        std::vector<int> current(n, 0);\\n        previous[0] = 1;\\n        \\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            previous = current;\\n        }\\n        \\n        return previous[n-1];\\n    }\\n};\\n```\\n``` Go []\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    if len(obstacleGrid) == 0 || len(obstacleGrid[0]) == 0 || obstacleGrid[0][0] == 1 {\\n        return 0\\n    }\\n\\n    m := len(obstacleGrid)\\n    n := len(obstacleGrid[0])\\n\\n    previous := make([]int, n)\\n    current := make([]int, n)\\n    previous[0] = 1\\n\\n    for i := 0; i < m; i++ {\\n        if obstacleGrid[i][0] == 1 {\\n            current[0] = 0\\n        } else {\\n            current[0] = previous[0]\\n        }\\n        \\n        for j := 1; j < n; j++ {\\n            if obstacleGrid[i][j] == 1 {\\n                current[j] = 0\\n            } else {\\n                current[j] = current[j-1] + previous[j]\\n            }\\n        }\\n        previous, current = current, previous\\n    }\\n    return previous[n-1]\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths_with_obstacles(obstacleGrid: Vec<Vec<i32>>) -> i32 {\\n        if obstacleGrid.is_empty() || obstacleGrid[0].is_empty() || obstacleGrid[0][0] == 1 {\\n            return 0;\\n        }\\n        \\n        let m = obstacleGrid.len();\\n        let n = obstacleGrid[0].len();\\n        \\n        let mut previous = vec![0; n];\\n        let mut current = vec![0; n];\\n        previous[0] = 1;\\n        \\n        for row in &obstacleGrid {\\n            current[0] = if row[0] == 1 { 0 } else { previous[0] };\\n            for j in 1..n {\\n                if row[j] == 1 {\\n                    current[j] = 0;\\n                } else {\\n                    current[j] = current[j-1] + previous[j];\\n                }\\n            }\\n            std::mem::swap(&mut previous, &mut current);\\n        }\\n        \\n        previous[n-1]\\n    }\\n}\\n```\\n``` Java []\\npublic class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        int[] previous = new int[n];\\n        int[] current = new int[n];\\n        previous[0] = 1;\\n\\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            System.arraycopy(current, 0, previous, 0, n);\\n        }\\n\\n        return previous[n-1];\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid.length || !obstacleGrid[0].length || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    let m = obstacleGrid.length;\\n    let n = obstacleGrid[0].length;\\n\\n    let previous = new Array(n).fill(0);\\n    let current = new Array(n).fill(0);\\n    previous[0] = 1;\\n\\n    for (let i = 0; i < m; i++) {\\n        current[0] = obstacleGrid[i][0] === 1 ? 0 : previous[0];\\n        for (let j = 1; j < n; j++) {\\n            current[j] = obstacleGrid[i][j] === 1 ? 0 : current[j-1] + previous[j];\\n        }\\n        previous = [...current];\\n    }\\n\\n    return previous[n-1];\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.Length == 0 || obstacleGrid[0].Length == 0 || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int m = obstacleGrid.Length;\\n        int n = obstacleGrid[0].Length;\\n\\n        int[] previous = new int[n];\\n        int[] current = new int[n];\\n        previous[0] = 1;\\n\\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            Array.Copy(current, previous, n);\\n        }\\n\\n        return previous[n-1];\\n    }\\n}\\n```\\n\\n# Conclusion\\n\\nThe \"Unique Paths II\" problem showcases how dynamic programming can help find solutions to combinatorial problems in a structured and efficient manner. By understanding the relationship between subproblems, we can incrementally build the solution and avoid redundant computations. \\n\\nAs with any algorithmic challenge, practice and understanding the underlying principles are key. Don\\'t hesitate to tweak, optimize, and experiment with the solution to deepen your understanding!\\n\\n# Live Coding in Rust\\nhttps://youtu.be/xt_1OzCH_NA",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        previous = [0] * n\\n        current = [0] * n\\n        previous[0] = 1\\n        \\n        for i in range(m):\\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\\n            for j in range(1, n):\\n                current[j] = 0 if obstacleGrid[i][j] == 1 else current[j-1] + previous[j]\\n            previous[:] = current\\n        \\n        return previous[n-1]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(std::vector<std::vector<int>>& obstacleGrid) {\\n        if (obstacleGrid.empty() || obstacleGrid[0].empty() || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n        \\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        std::vector<int> previous(n, 0);\\n        std::vector<int> current(n, 0);\\n        previous[0] = 1;\\n        \\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            previous = current;\\n        }\\n        \\n        return previous[n-1];\\n    }\\n};\\n```\n``` Go []\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    if len(obstacleGrid) == 0 || len(obstacleGrid[0]) == 0 || obstacleGrid[0][0] == 1 {\\n        return 0\\n    }\\n\\n    m := len(obstacleGrid)\\n    n := len(obstacleGrid[0])\\n\\n    previous := make([]int, n)\\n    current := make([]int, n)\\n    previous[0] = 1\\n\\n    for i := 0; i < m; i++ {\\n        if obstacleGrid[i][0] == 1 {\\n            current[0] = 0\\n        } else {\\n            current[0] = previous[0]\\n        }\\n        \\n        for j := 1; j < n; j++ {\\n            if obstacleGrid[i][j] == 1 {\\n                current[j] = 0\\n            } else {\\n                current[j] = current[j-1] + previous[j]\\n            }\\n        }\\n        previous, current = current, previous\\n    }\\n    return previous[n-1]\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn unique_paths_with_obstacles(obstacleGrid: Vec<Vec<i32>>) -> i32 {\\n        if obstacleGrid.is_empty() || obstacleGrid[0].is_empty() || obstacleGrid[0][0] == 1 {\\n            return 0;\\n        }\\n        \\n        let m = obstacleGrid.len();\\n        let n = obstacleGrid[0].len();\\n        \\n        let mut previous = vec![0; n];\\n        let mut current = vec![0; n];\\n        previous[0] = 1;\\n        \\n        for row in &obstacleGrid {\\n            current[0] = if row[0] == 1 { 0 } else { previous[0] };\\n            for j in 1..n {\\n                if row[j] == 1 {\\n                    current[j] = 0;\\n                } else {\\n                    current[j] = current[j-1] + previous[j];\\n                }\\n            }\\n            std::mem::swap(&mut previous, &mut current);\\n        }\\n        \\n        previous[n-1]\\n    }\\n}\\n```\n``` Java []\\npublic class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        int[] previous = new int[n];\\n        int[] current = new int[n];\\n        previous[0] = 1;\\n\\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            System.arraycopy(current, 0, previous, 0, n);\\n        }\\n\\n        return previous[n-1];\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid.length || !obstacleGrid[0].length || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    let m = obstacleGrid.length;\\n    let n = obstacleGrid[0].length;\\n\\n    let previous = new Array(n).fill(0);\\n    let current = new Array(n).fill(0);\\n    previous[0] = 1;\\n\\n    for (let i = 0; i < m; i++) {\\n        current[0] = obstacleGrid[i][0] === 1 ? 0 : previous[0];\\n        for (let j = 1; j < n; j++) {\\n            current[j] = obstacleGrid[i][j] === 1 ? 0 : current[j-1] + previous[j];\\n        }\\n        previous = [...current];\\n    }\\n\\n    return previous[n-1];\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.Length == 0 || obstacleGrid[0].Length == 0 || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int m = obstacleGrid.Length;\\n        int n = obstacleGrid[0].Length;\\n\\n        int[] previous = new int[n];\\n        int[] current = new int[n];\\n        previous[0] = 1;\\n\\n        for (int i = 0; i < m; i++) {\\n            current[0] = obstacleGrid[i][0] == 1 ? 0 : previous[0];\\n            for (int j = 1; j < n; j++) {\\n                current[j] = obstacleGrid[i][j] == 1 ? 0 : current[j-1] + previous[j];\\n            }\\n            Array.Copy(current, previous, n);\\n        }\\n\\n        return previous[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180225,
                "title": "python-short-dp-solution-explained",
                "content": "This is a classical **dynamic programming** problem. Let `dp[i][j]` be the number of paths to reach coordinate `(i, j)`.  Then first of all we check if we can reach `(0, 0)` coordinate. Then for each cell we check two neighbours: one above and one to the left and add this number of ways to answer. In the end we return `dp[-1][-1]`\\n\\n#### Complexity\\nTime complexity is `O(mn)`, because we have `mn` states and two transactions from one to another. Space complexity is the same.\\n\\n\\n#### Code\\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, M):\\n        m, n = len(M), len(M[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = int(M[0][0] == 0)\\n        for i, j in product(range(m), range(n)):\\n            if M[i][j] == 1: continue\\n            if i > 0: dp[i][j] += dp[i-1][j]\\n            if j > 0: dp[i][j] += dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, M):\\n        m, n = len(M), len(M[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = int(M[0][0] == 0)\\n        for i, j in product(range(m), range(n)):\\n            if M[i][j] == 1: continue\\n            if i > 0: dp[i][j] += dp[i-1][j]\\n            if j > 0: dp[i][j] += dp[i][j-1]\\n                \\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527282,
                "title": "python-dfs-dp-explained-solution",
                "content": "This solution is just a variation of the standard solution provided by leetcode, but I think it\\'s easier to understand. So basically the map is a acyclic directed graph, and we just need to find the total number of paths from start to end.\\n\\nNormally DFS is sufficient for this kind of problem, however since we only need to report a single number, we can record the number of paths starting from a cell *u* once we completed the DFS starting from *u*. Next time when we hit *u* again, we know exactly the DFS result starting from *u*, so we don\\'t have to do it again.\\n\\nNote: `lru_cache`([doc](https://docs.python.org/3/library/functools.html?highlight=lru_cache#functools.lru_cache)) helps store the returned result of every distinct method call. It functions like a `dict` here, and you can also use a `dict` to do the same thing.\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        M, N = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i, j):\\n            if obstacleGrid[i][j]:      # hit an obstacle\\n                return 0\\n            if i == M-1 and j == N-1:   # reach the end\\n                return 1\\n            count = 0\\n            if i < M-1:\\n                count += dfs(i+1, j)    # go down\\n            if j < N-1:\\n                count += dfs(i, j+1)    # go right\\n            return count\\n        \\n        return dfs(0, 0)\\n```\\nThe time and space complexity are both O(MN).\\n\\nVote up if you find this helpful, thanks!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        M, N = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i, j):\\n            if obstacleGrid[i][j]:      # hit an obstacle\\n                return 0\\n            if i == M-1 and j == N-1:   # reach the end\\n                return 1\\n            count = 0\\n            if i < M-1:\\n                count += dfs(i+1, j)    # go down\\n            if j < N-1:\\n                count += dfs(i, j+1)    # go right\\n            return count\\n        \\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055343,
                "title": "c-8-line-solution",
                "content": "PLEASE UPVOTE IF YOU LIKE\\n```\\n int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n\\t\\t\\t\\t//2 way is possible go right or down\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];",
                "solutionTags": [
                    "C"
                ],
                "code": "PLEASE UPVOTE IF YOU LIKE\\n```\\n int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n\\t\\t\\t\\t//2 way is possible go right or down\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];",
                "codeTag": "Unknown"
            },
            {
                "id": 23411,
                "title": "c-o-mn-time-o-1-space-use-obstaclegrid",
                "content": "use obstacleGrid to save result\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int h = obstacleGrid.size();\\n        if(h == 0) return 0;\\n        int w = obstacleGrid[0].size();\\n        if(w == 0) return 0;\\n        if(obstacleGrid[0][0]) return 0;\\n        \\n        // first cell has 1 path\\n        obstacleGrid[0][0] = 1;\\n        \\n        // first row all are '1' until obstacle (from left only)\\n        for(int i=1; i<w; i++){\\n            obstacleGrid[0][i] = obstacleGrid[0][i] ? 0 : obstacleGrid[0][i-1];\\n        }\\n\\n        for(int j=1; j<h; j++){\\n            // first column is like first row (from top only)\\n            obstacleGrid[j][0] = obstacleGrid[j][0] ? 0 : obstacleGrid[j-1][0];\\n            \\n            // others are up+left\\n            for(int i=1; i<w; i++){\\n                obstacleGrid[j][i] = obstacleGrid[j][i] ? 0 : obstacleGrid[j-1][i] + obstacleGrid[j][i-1];\\n            }\\n        }\\n        \\n        return obstacleGrid[h-1][w-1];\\n    }",
                "solutionTags": [],
                "code": "use obstacleGrid to save result\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int h = obstacleGrid.size();\\n        if(h == 0) return 0;\\n        int w = obstacleGrid[0].size();\\n        if(w == 0) return 0;\\n        if(obstacleGrid[0][0]) return 0;\\n        \\n        // first cell has 1 path\\n        obstacleGrid[0][0] = 1;\\n        \\n        // first row all are '1' until obstacle (from left only)\\n        for(int i=1; i<w; i++){\\n            obstacleGrid[0][i] = obstacleGrid[0][i] ? 0 : obstacleGrid[0][i-1];\\n        }\\n\\n        for(int j=1; j<h; j++){\\n            // first column is like first row (from top only)\\n            obstacleGrid[j][0] = obstacleGrid[j][0] ? 0 : obstacleGrid[j-1][0];\\n            \\n            // others are up+left\\n            for(int i=1; i<w; i++){\\n                obstacleGrid[j][i] = obstacleGrid[j][i] ? 0 : obstacleGrid[j-1][i] + obstacleGrid[j][i-1];\\n            }\\n        }\\n        \\n        return obstacleGrid[h-1][w-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2055375,
                "title": "python-easy-dp-2-approaches-beats-99",
                "content": "The code is using a DP array to solve the problem. The two approaches listed below varies on Space complexity. Both the approaches take **O(m*n)**  time.\\n1. ##### **Space O(m*n)**\\n\\nThe extra space is for the `DP` array.\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:              \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])        \\n        \\n        dp=[[0] * (n+1) for _ in range(m+1)]        \\n        dp[0][1]=1\\n                        \\n        for row in range(1, m+1):\\n            for col in range(1, n+1):\\n                if not obstacleGrid[row-1][col-1]:\\n                    dp[row][col] = dp[row-1][col] + dp[row][col-1]\\n         \\n        return dp[-1][-1]\\n```\\n\\n2.  ##### **Space O(1)**\\n\\nHere the code will be using the input array as the DP array. In most cases, mutating the input is not recommended. It creates [side-effects](https://en.wikipedia.org/wiki/Side_effect_(computer_science)) in your code. But this approach is a fun exercise on exploring other alternative solutions within the given problem constraints.\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:              \\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])        \\n        \\n        obstacleGrid[0][0] = 1\\n        for i in range(1,m):\\n            obstacleGrid[i][0] = 1 if obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1 else 0\\n        \\n        for i in range(1,n):\\n            obstacleGrid[0][i] = 1 if obstacleGrid[0][i] == 0 and obstacleGrid[0][i-1] == 1 else 0\\n            \\n        \\n        for row in range(1, m):\\n            for col in range(1, n):                \\n                obstacleGrid[row][col] = obstacleGrid[row-1][col] + obstacleGrid[row][col-1] if obstacleGrid[row][col] == 0 else 0\\n         \\n        return obstacleGrid[-1][-1]\\n```\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:              \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])        \\n        \\n        dp=[[0] * (n+1) for _ in range(m+1)]        \\n        dp[0][1]=1\\n                        \\n        for row in range(1, m+1):\\n            for col in range(1, n+1):\\n                if not obstacleGrid[row-1][col-1]:\\n                    dp[row][col] = dp[row-1][col] + dp[row][col-1]\\n         \\n        return dp[-1][-1]\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:              \\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])        \\n        \\n        obstacleGrid[0][0] = 1\\n        for i in range(1,m):\\n            obstacleGrid[i][0] = 1 if obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1 else 0\\n        \\n        for i in range(1,n):\\n            obstacleGrid[0][i] = 1 if obstacleGrid[0][i] == 0 and obstacleGrid[0][i-1] == 1 else 0\\n            \\n        \\n        for row in range(1, m):\\n            for col in range(1, n):                \\n                obstacleGrid[row][col] = obstacleGrid[row-1][col] + obstacleGrid[row][col-1] if obstacleGrid[row][col] == 0 else 0\\n         \\n        return obstacleGrid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513891,
                "title": "java-tc-o-r-c-sc-o-min-r-c-space-optimized-dynamic-programming-solution",
                "content": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * current cell = top cell + left cell. If there is an obstacle at current cell,\\n * then current cell = 0;\\n *\\n * Time Complexity: O(R * C).\\n *\\n * Space Complexity = O(min(R, C)). Either one column or one row is used for dp.\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.length;\\n        int cols = obstacleGrid[0].length;\\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[rows - 1][cols - 1] == 1) {\\n            return 0;\\n        }\\n        if (rows == 1 && cols == 1) {\\n            return 1;\\n        }\\n\\n        if (rows >= cols) {\\n            return uniquePathHelper(obstacleGrid, rows, cols, true);\\n        } else {\\n            return uniquePathHelper(obstacleGrid, cols, rows, false);\\n        }\\n    }\\n\\n    private int uniquePathHelper(int[][] obstacleGrid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        dp[0] = 1;\\n        for (int i = 0; i < big; i++) {\\n            if ((isColsSmall && obstacleGrid[i][0] == 1) || (!isColsSmall && obstacleGrid[0][i] == 1)) {\\n                dp[0] = 0;\\n            }\\n            for (int j = 1; j < small; j++) {\\n                if ((isColsSmall && obstacleGrid[i][j] == 1) || (!isColsSmall && obstacleGrid[j][i] == 1)) {\\n                    dp[j] = 0;\\n                    continue;\\n                }\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Unique Path question on LeetCode:\\n- [62. Unique Paths](https://leetcode.com/problems/unique-paths/discuss/1513886/Java-or-TC:-O(M*N)-or-SC:-O(min(MN))-or-Space-optimized-Dynamic-Programming-solution)\\n- [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/discuss/1513899/Java-or-TC:-O(R*C)-or-SC:-O(min(RC))-or-Space-optimized-Dynamic-Programming-solution)\\n- [980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/discuss/1513906/Java-or-TC:-O(3(R*C))-or-SC:-O(R*C)-or-DFS-solution-with-Backtracking)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Space optimized Dynamic Programming solution (Input grid not modified)\\n *\\n * current cell = top cell + left cell. If there is an obstacle at current cell,\\n * then current cell = 0;\\n *\\n * Time Complexity: O(R * C).\\n *\\n * Space Complexity = O(min(R, C)). Either one column or one row is used for dp.\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.length;\\n        int cols = obstacleGrid[0].length;\\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[rows - 1][cols - 1] == 1) {\\n            return 0;\\n        }\\n        if (rows == 1 && cols == 1) {\\n            return 1;\\n        }\\n\\n        if (rows >= cols) {\\n            return uniquePathHelper(obstacleGrid, rows, cols, true);\\n        } else {\\n            return uniquePathHelper(obstacleGrid, cols, rows, false);\\n        }\\n    }\\n\\n    private int uniquePathHelper(int[][] obstacleGrid, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small];\\n        dp[0] = 1;\\n        for (int i = 0; i < big; i++) {\\n            if ((isColsSmall && obstacleGrid[i][0] == 1) || (!isColsSmall && obstacleGrid[0][i] == 1)) {\\n                dp[0] = 0;\\n            }\\n            for (int j = 1; j < small; j++) {\\n                if ((isColsSmall && obstacleGrid[i][j] == 1) || (!isColsSmall && obstacleGrid[j][i] == 1)) {\\n                    dp[j] = 0;\\n                    continue;\\n                }\\n                dp[j] += dp[j - 1];\\n            }\\n        }\\n        return dp[small - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23436,
                "title": "easy-java-solution-in-place-dp",
                "content": "   \\nThe idea is simple, set all obstacles to be 0 while doing the DP. No extra space is used.\\n\\n     public class Solution {\\n            public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n                int m = obstacleGrid.length;\\n                int n = obstacleGrid[0].length;\\n        \\n                obstacleGrid[0][0]^=1;\\n                for(int i = 1;i<m;i++){\\n                    obstacleGrid[i][0]=(obstacleGrid[i][0]==1)? 0:obstacleGrid[i-1][0];\\n                }\\n                \\n                for(int j = 1;j<n;j++){\\n                    obstacleGrid[0][j] =(obstacleGrid[0][j]==1)? 0: obstacleGrid[0][j-1];\\n                }\\n                for(int i = 1;i<m;i++){\\n                    for(int j =1;j<n;j++){\\n                        obstacleGrid[i][j] =(obstacleGrid[i][j]==1)? 0: obstacleGrid[i-1][j]+obstacleGrid[i][j-1];\\n                    }\\n                }\\n                return obstacleGrid[m-1][n-1];\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n                int m = obstacleGrid.length;\\n                int n = obstacleGrid[0].length;\\n        \\n                obstacleGrid[0][0]^=1;\\n                for(int i = 1;i<m;i++){\\n                    obstacleGrid[i][0]=(obstacleGrid[i][0]==1)? 0:obstacleGrid[i-1][0];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1181058,
                "title": "interview-experience-memoized-tabulation",
                "content": "**RECURSIVE + MEMOIZED SOLUTION :**\\n*   let say  you are at (0,0) and somebody ask you number of ways to reach out (0,0) your answer will be 1 not 0 . because there is 1 way to reach (0,0) which is dont make any move . [this is going to help us in thinking base case]\\n*   You can see by making a recursion tree that calls are repeating . [In generall whenever we do make more than one recursion call calls do  repeat in almost every case].\\n*   have a faith on recursion function that it will give me no of unique paths from intermediate to destination.\\n*   I can go down or right . So just paas them on recursion function having faith it will bring answer from themself to destination .\\n*   just add the number of unique ways from down and right this is the total no of unique ways.\\n*   I have used bottom-up in my solution you can use top to bottom also.\\n\\n**CODE:**\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        return paths(0,0,obstacleGrid.length-1,obstacleGrid[0].length-1,obstacleGrid,new int[obstacleGrid.length][obstacleGrid[0].length]);\\n    }\\n\\t\\n\\t //sr:source row , sc: source column\\n     //dr: destination row , dc: destination column \\n\\t //qb: question bank to ask question have we solved this row and col before ? if yes then why to solve again\\n\\t \\n    public static int paths(int sr,int sc,int dr,int dc,int[][] grid,int[][] qb){\\n        if(sr==dr && sc==dc && grid[sr][sc]==0) return 1;\\n        \\n        if(sr>dr || sc>dc || grid[sr][sc]==1) return 0; // if \\n\\t\\t\\n        if(qb[sr][sc]!=0) return qb[sr][sc];\\n\\t\\t\\n        int iv=paths(sr+1,sc,dr,dc,grid,qb); //iv: intermediate vertical\\n        int ih=paths(sr,sc+1,dr,dc,grid,qb); // intermediate horizontal\\n        \\n        int tp=iv+ ih; //tp: total path\\n        qb[sr][sc]=tp;\\n        return tp;\\n    }\\n}\\n```\\n\\n**Complexity:**\\n`Time:O(n^2) and Space:O(n^2)`\\n\\n**Iterative [Tabulation] :**\\n* I am Starting from dr,dc and building the answer. \\n* First solve those (r,c) whom you are going to use to get your answer. \\n**CODE:**\\n```\\n public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n          int[][] dp=new int[obstacleGrid.length][obstacleGrid[0].length];\\n           \\n           int dr=dp.length-1;\\n           int dc=dp[0].length-1;\\n        \\n          for(int r=dr;r>=0;r--){\\n            for(int c=dc;c>=0;c--){\\n                int rp1=r+1;  //rp1: row plus 1\\n                int cp1=c+1; //cp1 : col plus 1\\n                \\n                if(obstacleGrid[r][c]==1){  //if obstacle means block\\n                    dp[r][c]=0;\\n                }else if(r==dr && c==dc){\\n                     dp[r][c]=1;  // if i am at dr,dc number of ways =1 dont make any move\\n                }else if(r==dr){\\n                     dp[r][c]=dp[r][cp1];  // last row means can move only horizontal vertical moves are not valid\\n                }else if(c==dc){\\n                      dp[r][c]=dp[rp1][c];\\n                }else{\\n                    dp[r][c]=dp[rp1][c] + dp[r][cp1];\\n                }\\n            }  \\n          }\\n        return dp[0][0];\\n    }\\n```\\n\\n**Complexity:**\\n`Time:O(n^2) and Space:O(n^2)`\\n\\n\\n\\n**Interview Experience:**\\nI have got this  question at UNDOSTRES final interview. My final interview went for 4 hours but unluckily 0 selection from our college this time maybe because of Covid. This was my 1st International Interview . Those who dont know about undostres its like paytm in MEXICO. They only hire for MEXICO location . \\nwhen interviewer gave me this question dont know why but I smiled then he asked have you solved this question before . I told maybe yes not sure but i have solved similar questions. then I have wrote tabulation code and it got passed in one go. but maybe interviewer got an idea that i have solved this before so he gave another question after this.\\nInterview started at 8:00 pm and  ended at 11:48 PM .\\nBut It was great fun interviewing with them .Interviewer want me to give chance thats why he strecthed interview so much .\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.\\n\\nI would highly recommend to follow **PEPCODING** dp Playlist on youtube if you want a expertie in this kind fo questions.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        return paths(0,0,obstacleGrid.length-1,obstacleGrid[0].length-1,obstacleGrid,new int[obstacleGrid.length][obstacleGrid[0].length]);\\n    }\\n\\t\\n\\t //sr:source row , sc: source column\\n     //dr: destination row , dc: destination column \\n\\t //qb: question bank to ask question have we solved this row and col before ? if yes then why to solve again\\n\\t \\n    public static int paths(int sr,int sc,int dr,int dc,int[][] grid,int[][] qb){\\n        if(sr==dr && sc==dc && grid[sr][sc]==0) return 1;\\n        \\n        if(sr>dr || sc>dc || grid[sr][sc]==1) return 0; // if \\n\\t\\t\\n        if(qb[sr][sc]!=0) return qb[sr][sc];\\n\\t\\t\\n        int iv=paths(sr+1,sc,dr,dc,grid,qb); //iv: intermediate vertical\\n        int ih=paths(sr,sc+1,dr,dc,grid,qb); // intermediate horizontal\\n        \\n        int tp=iv+ ih; //tp: total path\\n        qb[sr][sc]=tp;\\n        return tp;\\n    }\\n}\\n```\n```\\n public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n          int[][] dp=new int[obstacleGrid.length][obstacleGrid[0].length];\\n           \\n           int dr=dp.length-1;\\n           int dc=dp[0].length-1;\\n        \\n          for(int r=dr;r>=0;r--){\\n            for(int c=dc;c>=0;c--){\\n                int rp1=r+1;  //rp1: row plus 1\\n                int cp1=c+1; //cp1 : col plus 1\\n                \\n                if(obstacleGrid[r][c]==1){  //if obstacle means block\\n                    dp[r][c]=0;\\n                }else if(r==dr && c==dc){\\n                     dp[r][c]=1;  // if i am at dr,dc number of ways =1 dont make any move\\n                }else if(r==dr){\\n                     dp[r][c]=dp[r][cp1];  // last row means can move only horizontal vertical moves are not valid\\n                }else if(c==dc){\\n                      dp[r][c]=dp[rp1][c];\\n                }else{\\n                    dp[r][c]=dp[rp1][c] + dp[r][cp1];\\n                }\\n            }  \\n          }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860422,
                "title": "c-dp-solution-almost-same-code-as-unique-paths-i",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(m==0||n==0) return 0;\\n        int dp[m][n];\\n         memset(dp,0,sizeof(dp));\\n        for(int i=0;i<m;i++)\\n        {   if(obstacleGrid[i][0]!=1) dp[i][0]=1;\\n            else break;\\n        }\\n        for(int j=0;j<n;j++)\\n        {   if(obstacleGrid[0][j]!=1) dp[0][j]=1;\\n            else break;\\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=1;j<n;j++)\\n                if(obstacleGrid[i][j]!=1)\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(m==0||n==0) return 0;\\n        int dp[m][n];\\n         memset(dp,0,sizeof(dp));\\n        for(int i=0;i<m;i++)\\n        {   if(obstacleGrid[i][0]!=1) dp[i][0]=1;\\n            else break;\\n        }\\n        for(int j=0;j<n;j++)\\n        {   if(obstacleGrid[0][j]!=1) dp[0][j]=1;\\n            else break;\\n        }\\n        for(int i=1;i<m;i++)\\n            for(int j=1;j<n;j++)\\n                if(obstacleGrid[i][j]!=1)\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500734,
                "title": "java-recursion-memoization-dp-solutions",
                "content": "**Recursion : TLE**\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        return helper(obstacleGrid,0,0,m,n);\\n    }\\n    public int helper(int[][] grid,int r,int c,int m,int n){\\n        if(r == m || c == n || grid[r][c] == 1)return 0;\\n        if(r == m-1 && c == n-1){\\n            if(grid[r][c] == 1)return 0;\\n            return 1;\\n        }\\n        return helper(grid,r+1,c,m,n)+helper(grid,r,c+1,m,n);\\n    }\\n}\\n```\\n**Memoization : \\n41 / 41 test cases passed.\\nStatus: Accepted\\nRuntime: 4 ms\\nMemory Usage: 38.5 MB**\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int dp[][] = new int[m][n];\\n        return helper(obstacleGrid,0,0,m,n,dp);\\n    }\\n    public int helper(int[][] grid,int r,int c,int m,int n,int[][] dp){\\n        if(r == m || c == n || grid[r][c] == 1)return 0;\\n        if(r == m-1 && c == n-1){\\n            if(grid[r][c] == 1)return 0;\\n            return 1;\\n        }\\n        if(dp[r][c] > 0)return dp[r][c];\\n        return dp[r][c] = helper(grid,r+1,c,m,n,dp)+helper(grid,r,c+1,m,n,dp);\\n    }\\n}\\n```\\n**DP :\\n41 / 41 test cases passed.\\nStatus: Accepted\\nRuntime: 0 ms\\nMemory Usage: 38 MB**\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i = m-1;i>=0;i--){\\n            for(int j = n-1;j>=0;j--){\\n                if(i == m-1 && j == n-1){\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else dp[i][j] = 1;\\n                }else if(i == m-1 || j == n-1){\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else if(i == m-1)dp[i][j] = dp[i][j+1];\\n                    else if(j == n-1)dp[i][j] = dp[i+1][j];\\n                }else{\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else dp[i][j] = dp[i][j+1] + dp[i+1][j];\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        return helper(obstacleGrid,0,0,m,n);\\n    }\\n    public int helper(int[][] grid,int r,int c,int m,int n){\\n        if(r == m || c == n || grid[r][c] == 1)return 0;\\n        if(r == m-1 && c == n-1){\\n            if(grid[r][c] == 1)return 0;\\n            return 1;\\n        }\\n        return helper(grid,r+1,c,m,n)+helper(grid,r,c+1,m,n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int dp[][] = new int[m][n];\\n        return helper(obstacleGrid,0,0,m,n,dp);\\n    }\\n    public int helper(int[][] grid,int r,int c,int m,int n,int[][] dp){\\n        if(r == m || c == n || grid[r][c] == 1)return 0;\\n        if(r == m-1 && c == n-1){\\n            if(grid[r][c] == 1)return 0;\\n            return 1;\\n        }\\n        if(dp[r][c] > 0)return dp[r][c];\\n        return dp[r][c] = helper(grid,r+1,c,m,n,dp)+helper(grid,r,c+1,m,n,dp);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int i = m-1;i>=0;i--){\\n            for(int j = n-1;j>=0;j--){\\n                if(i == m-1 && j == n-1){\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else dp[i][j] = 1;\\n                }else if(i == m-1 || j == n-1){\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else if(i == m-1)dp[i][j] = dp[i][j+1];\\n                    else if(j == n-1)dp[i][j] = dp[i+1][j];\\n                }else{\\n                    if(obstacleGrid[i][j] == 1)dp[i][j] = 0;\\n                    else dp[i][j] = dp[i][j+1] + dp[i+1][j];\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23430,
                "title": "bottom-up-iterative-solution-o-mn-no-extra-space",
                "content": "     public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        \\n        for (int r = m - 1; r >= 0; r--) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (obstacleGrid[r][c] == 1) obstacleGrid[r][c] = 0;\\n                else {\\n                    if (r == m - 1 && c == n - 1) obstacleGrid[r][c] = 1;\\n                    else if (r == m - 1) obstacleGrid[r][c] = obstacleGrid[r][c + 1];\\n                    else if (c == n - 1) obstacleGrid[r][c] = obstacleGrid[r + 1][c];\\n                    else obstacleGrid[r][c] = obstacleGrid[r][c + 1] + obstacleGrid[r + 1][c];\\n                }\\n            }\\n        }\\n        \\n        return obstacleGrid[0][0];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        \\n        for (int r = m - 1; r >= 0; r--) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (obstacleGrid[r][c] == 1) obstacleGrid[r][c] = 0;\\n                else {\\n                    if (r == m - 1 && c == n - 1) obstacleGrid[r][c] = 1;\\n                    else if (r == m - 1) obstacleGrid[r][c] = obstacleGrid[r][c + 1];\\n                    else if (c == n - 1) obstacleGrid[r][c] = obstacleGrid[r + 1][c];\\n                    else obstacleGrid[r][c] = obstacleGrid[r][c + 1] + obstacleGrid[r + 1][c];\\n                }\\n            }\\n        }\\n        \\n        return obstacleGrid[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23273,
                "title": "accepted-simple-python-in-place-solution",
                "content": "As below. Any comments on how to make it shorter? Thx!\\n\\n    class Solution:\\n        # @param obstacleGrid, a list of lists of integers\\n        # @return an integer\\n        def uniquePathsWithObstacles(self, obstacleGrid):\\n            m = len(obstacleGrid)\\n            n = len(obstacleGrid[0])\\n            obstacleGrid[0][0] = 1 - obstacleGrid[0][0]\\n            \\n            for i in range(1, n):\\n                if not obstacleGrid[0][i]:\\n                    obstacleGrid[0][i] = obstacleGrid[0][i-1]\\n                else:\\n                    obstacleGrid[0][i] = 0\\n                    \\n            for i in range(1, m):\\n                if not obstacleGrid[i][0]:\\n                    obstacleGrid[i][0] = obstacleGrid[i-1][0]\\n                else:\\n                    obstacleGrid[i][0] = 0\\n                    \\n            for i in range(1, m):\\n                for j in range(1, n):\\n                    if not obstacleGrid[i][j]:\\n                        obstacleGrid[i][j] = obstacleGrid[i][j-1]+obstacleGrid[i-1][j]\\n                    else:\\n                        obstacleGrid[i][j] = 0\\n                        \\n            return obstacleGrid[-1][-1]",
                "solutionTags": [],
                "code": "As below. Any comments on how to make it shorter? Thx!\\n\\n    class Solution:\\n        # @param obstacleGrid, a list of lists of integers\\n        # @return an integer\\n        def uniquePathsWithObstacles(self, obstacleGrid):\\n            m = len(obstacleGrid)\\n            n = len(obstacleGrid[0])\\n            obstacleGrid[0][0] = 1 - obstacleGrid[0][0]\\n            \\n            for i in range(1, n):\\n                if not obstacleGrid[0][i]:\\n                    obstacleGrid[0][i] = obstacleGrid[0][i-1]\\n                else:\\n                    obstacleGrid[0][i] = 0\\n                    \\n            for i in range(1, m):\\n                if not obstacleGrid[i][0]:\\n                    obstacleGrid[i][0] = obstacleGrid[i-1][0]\\n                else:\\n                    obstacleGrid[i][0] = 0\\n                    \\n            for i in range(1, m):\\n                for j in range(1, n):\\n                    if not obstacleGrid[i][j]:\\n                        obstacleGrid[i][j] = obstacleGrid[i][j-1]+obstacleGrid[i-1][j]\\n                    else:\\n                        obstacleGrid[i][j] = 0\\n                        \\n            return obstacleGrid[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 3896989,
                "title": "ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nMain goal is to determine the count of unique paths from the top-left corner to the bottom-right corner of a grid while accounting for obstacles in the grid. It uses dynamic programming to iteratively calculate the paths, avoiding obstacles and utilizing previously computed values to efficiently arrive at the final count.\\n\\nThis python solution beats 96%.\\n![Screen Shot 2023-08-12 at 21.13.22.png](https://assets.leetcode.com/users/images/74f201be-a679-4119-857c-162c270611f0_1691842439.115498.png)\\n\\n\\n---\\n\\n# Solution Video\\n## *** Please upvote for this article. *** \\n# Subscribe to my channel from here. I have 244 videos as of August 12th\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/-nVmLvqo5qc\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Define the class `Solution` which contains the method `uniquePathsWithObstacles` that takes `obstacleGrid` as input and returns the number of unique paths.\\n\\n2. Check if `obstacleGrid` is empty or if the starting cell (0, 0) is an obstacle (marked as 1). If either of these conditions is met, return 0, as there is no way to reach the destination.\\n\\n3. Get the number of rows and columns in the `obstacleGrid` and store them in `rows` and `cols` variables, respectively.\\n\\n4. Create an array `dp` of size `cols` to store the number of unique paths for each column. Initialize all values in `dp` to 0.\\n\\n5. Set `dp[0]` to 1, representing the number of ways to reach the starting cell (0, 0).\\n\\n6. Iterate through each row (`r`) in the `obstacleGrid`:\\n\\n   a. For each row, iterate through each column (`c`) in the `obstacleGrid`:\\n\\n      - If the current cell (`obstacleGrid[r][c]`) contains an obstacle (marked as 1), set `dp[c]` to 0, indicating that there are no paths to reach this obstacle cell.\\n\\n      - Otherwise, if the current cell is not an obstacle:\\n\\n        - Check if `c` is greater than 0 (i.e., not in the leftmost column). If true, update `dp[c]` by adding the value of `dp[c - 1]`. This accounts for the paths coming from the cell above (`dp[c]`) and the cell to the left (`dp[c - 1]`).\\n\\n7. After iterating through all the cells in the grid, return the value of `dp[cols - 1]`, which represents the number of unique paths to reach the bottom-right cell (rows - 1, cols - 1).\\n\\nIn summary, this algorithm uses dynamic programming to calculate the number of unique paths from the top-left corner to the bottom-right corner of the grid while avoiding obstacles. The `dp` array is updated iteratively, taking into account the paths from the cell above and the cell to the left.\\n\\n# How solution code works\\n`[0, 0, 0]`\\n`[0, 1, 0]`\\n`[0, 0, 0]`\\n\\nBefore starting nested loop, `dp` is `[1, 0, 0]`.\\n\\n1. iterating the first row and using `[1, 0, 0]`(previous result). In the end dp should be `[1, 1, 1]`\\n    - check `uniquePathsWithObstacles[0][0]` \\u2192 `dp = [1, 0, 0]`\\n    - check `uniquePathsWithObstacles[0][1]` \\u2192 `dp = [1, 1, 0]`\\n    - check `uniquePathsWithObstacles[0][2]` \\u2192 `dp = [1, 1, 1]`\\n\\n2. iterating the second row and using `[1, 1, 1]`(previous result). In the end dp should be `[1, 0, 1]`\\n    - check `uniquePathsWithObstacles[1][0]` \\u2192 `dp = [1, 1, 1]`\\n    - check `uniquePathsWithObstacles[1][1]` \\u2192 `dp = [1, 0, 1]`\\n    - check `uniquePathsWithObstacles[1][2]` \\u2192 `dp = [1, 0, 1]`\\n\\n3. iterating the thrid row and using `[1, 0, 1]`(previous result). In the end dp should be `[1, 1, 2]`\\n    - check `uniquePathsWithObstacles[2][0]` \\u2192 `dp = [1, 0, 1]`\\n    - check `uniquePathsWithObstacles[2][1]` \\u2192 `dp = [1, 1, 1]`\\n    - check `uniquePathsWithObstacles[2][2]` \\u2192 `dp = [1, 1, 2]` \\n\\nOutput should be `2`.\\n\\n# Complexity\\n- Time complexity: O(rows * cols)\\n\\n- Space complexity: O(cols)\\n\\n```python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid or obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        rows, cols = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [0] * cols\\n        dp[0] = 1\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                if obstacleGrid[r][c] == 1:\\n                    dp[c] = 0\\n                else:\\n                    if c > 0:\\n                        dp[c] += dp[c - 1]\\n\\n        return dp[cols - 1] \\n```\\n```javascript []\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    const rows = obstacleGrid.length;\\n    const cols = obstacleGrid[0].length;\\n    const dp = new Array(cols).fill(0);\\n    dp[0] = 1;\\n\\n    for (let r = 0; r < rows; r++) {\\n        for (let c = 0; c < cols; c++) {\\n            if (obstacleGrid[r][c] === 1) {\\n                dp[c] = 0;\\n            } else {\\n                if (c > 0) {\\n                    dp[c] += dp[c - 1];\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[cols - 1];    \\n};\\n```\\n```java []\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.length;\\n        int cols = obstacleGrid[0].length;\\n        int[] dp = new int[cols];\\n        dp[0] = 1;\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (obstacleGrid[r][c] == 1) {\\n                    dp[c] = 0;\\n                } else {\\n                    if (c > 0) {\\n                        dp[c] += dp[c - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[cols - 1];        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if (obstacleGrid.empty() || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.size();\\n        int cols = obstacleGrid[0].size();\\n        vector<int> dp(cols, 0);\\n        dp[0] = 1;\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (obstacleGrid[r][c] == 1) {\\n                    dp[c] = 0;\\n                } else {\\n                    if (c > 0) {\\n                        dp[c] += dp[c - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[cols - 1];        \\n    }\\n};\\n```\\n\\n# Related video\\nI have an video for Unique Path I. Please check if you like.\\n\\nhttps://youtu.be/6NorAYw7NMU\\n\\nThank you for reading. Please upvote this article and don\\'t forget to subscribe to my youtube channel!\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid or obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        rows, cols = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [0] * cols\\n        dp[0] = 1\\n\\n        for r in range(rows):\\n            for c in range(cols):\\n                if obstacleGrid[r][c] == 1:\\n                    dp[c] = 0\\n                else:\\n                    if c > 0:\\n                        dp[c] += dp[c - 1]\\n\\n        return dp[cols - 1] \\n```\n```javascript []\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (!obstacleGrid || obstacleGrid[0][0] === 1) {\\n        return 0;\\n    }\\n\\n    const rows = obstacleGrid.length;\\n    const cols = obstacleGrid[0].length;\\n    const dp = new Array(cols).fill(0);\\n    dp[0] = 1;\\n\\n    for (let r = 0; r < rows; r++) {\\n        for (let c = 0; c < cols; c++) {\\n            if (obstacleGrid[r][c] === 1) {\\n                dp[c] = 0;\\n            } else {\\n                if (c > 0) {\\n                    dp[c] += dp[c - 1];\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp[cols - 1];    \\n};\\n```\n```java []\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.length;\\n        int cols = obstacleGrid[0].length;\\n        int[] dp = new int[cols];\\n        dp[0] = 1;\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (obstacleGrid[r][c] == 1) {\\n                    dp[c] = 0;\\n                } else {\\n                    if (c > 0) {\\n                        dp[c] += dp[c - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[cols - 1];        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if (obstacleGrid.empty() || obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        int rows = obstacleGrid.size();\\n        int cols = obstacleGrid[0].size();\\n        vector<int> dp(cols, 0);\\n        dp[0] = 1;\\n\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                if (obstacleGrid[r][c] == 1) {\\n                    dp[c] = 0;\\n                } else {\\n                    if (c > 0) {\\n                        dp[c] += dp[c - 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[cols - 1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225310,
                "title": "finding-unique-paths-in-a-grid-with-obstacles-a-dynamic-programming-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the number of unique paths from the top-left corner of a matrix to the bottom-right corner. The matrix contains obstacles which are represented by 1 and free spaces represented by 0. If there is an obstacle at a cell, we cannot go through that cell. Our intuition should be to use Dynamic Programming (DP) to solve this problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a DP matrix `dp` of the same size as the input `obstacleGrid`. The value of `dp[i][j]` represents the number of unique paths to reach the cell at `(i, j)` in `obstacleGrid`.\\n\\nWe can initialize the `dp` matrix with `0`s. For the top-left corner of `obstacleGrid`, if there is an obstacle, then there are no unique paths to reach that cell. Hence, we set `dp[0][0]` to `0`. Otherwise, there is only one unique path to reach that cell, so we set `dp[0][0]` to `1`.\\n\\nNext, we can consider the first row and first column of `obstacleGrid`. If there is an obstacle in any cell in the first row or first column, we cannot move right or down, respectively. Hence, we set the corresponding `dp` value to `0`. Otherwise, we can only move either right or down in these cells, and hence there is only one unique path to reach these cells. We set the corresponding `dp` value to `1`.\\n\\nWe then iterate over the remaining cells in `obstacleGrid`, and for each cell, we check if there is an obstacle in that cell. If there is an obstacle, we set the corresponding dp value to 0, as we cannot go through that cell. Otherwise, the number of unique paths to reach that cell is the sum of the number of unique paths to reach the cell above it and the cell to the left of it. Hence, we set `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.\\n\\nFinally, the number of unique paths to reach the bottom-right corner of `obstacleGrid` is `dp[m-1][n-1]`, where `m` and `n` are the number of rows and columns in `obstacleGrid`, respectively.\\n# Complexity\\n- Time complexity:  The algorithm iterates over each cell in `obstacleGrid` exactly once, and for each cell, it performs a constant number of operations. Hence, the time complexity of this algorithm is $$O(mn)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The algorithm uses a DP matrix `dp` of size `m` x `n`, which requires $$O(mn)$$ space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n        for i in range(1, m):\\n            if obstacleGrid[i][0] == 0:\\n                dp[i][0] = dp[i-1][0]\\n        for j in range(1, n):\\n            if obstacleGrid[0][j] == 0:\\n                dp[0][j] = dp[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if obstacleGrid[i][j] == 0:\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n        for i in range(1, m):\\n            if obstacleGrid[i][0] == 0:\\n                dp[i][0] = dp[i-1][0]\\n        for j in range(1, n):\\n            if obstacleGrid[0][j] == 0:\\n                dp[0][j] = dp[0][j-1]\\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if obstacleGrid[i][j] == 0:\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165962,
                "title": "c-dp-recursion-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>&grid){\\n        if(i<0 || j<0 || grid[i][j]==1) return 0;\\n        if(i==0 && j==0) return 1;\\n        \\n        int up=solve(i-1,j,grid);\\n        int left=solve(i,j-1,grid);\\n        \\n        return up+left;\\n    }\\n    int solveMemo(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i<0 || j<0 || grid[i][j]==1) return 0;\\n        if(i==0 && j==0) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=solveMemo(i-1,j,grid,dp);\\n        int left=solveMemo(i,j-1,grid,dp);\\n        \\n        return dp[i][j]=up+left;\\n    }\\n     int solveTabu(int m,int n,vector<vector<int>>&grid){\\n                vector<vector<int>>dp(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n             for(int j=0;j<n;j++){\\n                 if(grid[i][j]==1) continue;\\n                 if(i==0 && j==0 ) dp[i][j]=1;\\n                 else{\\n                     int up=0,left=0;\\n                     if(i>0) up=dp[i-1][j];\\n                     if(j>0) left=dp[i][j-1];\\n                     \\n                     dp[i][j]=up+left;\\n                 }\\n             }\\n         }\\n         return dp[m-1][n-1];\\n\\n    }\\n    int solveTabuSo(int m,int n,vector<vector<int>>&grid){\\n                vector<int>prev(n,0);\\n        \\n         for(int i=0;i<m;i++){\\n             vector<int>cur(n,0);\\n             for(int j=0;j<n;j++){\\n                 if(grid[i][j]==1) continue;\\n                 if(i==0 && j==0 ) cur[j]=1;\\n                 else{\\n                     int up=0,left=0;\\n                     if(i>0) up=prev[j];\\n                     if(j>0) left=cur[j-1];\\n                     \\n                    cur[j]=up+left;\\n                 }\\n             }\\n             prev=cur;\\n         }\\n         return prev[n-1];\\n\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // return solve(m-1,n-1,grid);\\n        // vector<vector<int>>dp(m,vector<int>(n,-1));\\n        // return solveMemo(m-1,n-1,grid,dp);\\n        // return solveTabu(m,n,grid);\\n        return solveTabuSo(m,n,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,vector<vector<int>>&grid){\\n        if(i<0 || j<0 || grid[i][j]==1) return 0;\\n        if(i==0 && j==0) return 1;\\n        \\n        int up=solve(i-1,j,grid);\\n        int left=solve(i,j-1,grid);\\n        \\n        return up+left;\\n    }\\n    int solveMemo(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n        if(i<0 || j<0 || grid[i][j]==1) return 0;\\n        if(i==0 && j==0) return 1;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=solveMemo(i-1,j,grid,dp);\\n        int left=solveMemo(i,j-1,grid,dp);\\n        \\n        return dp[i][j]=up+left;\\n    }\\n     int solveTabu(int m,int n,vector<vector<int>>&grid){\\n                vector<vector<int>>dp(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n             for(int j=0;j<n;j++){\\n                 if(grid[i][j]==1) continue;\\n                 if(i==0 && j==0 ) dp[i][j]=1;\\n                 else{\\n                     int up=0,left=0;\\n                     if(i>0) up=dp[i-1][j];\\n                     if(j>0) left=dp[i][j-1];\\n                     \\n                     dp[i][j]=up+left;\\n                 }\\n             }\\n         }\\n         return dp[m-1][n-1];\\n\\n    }\\n    int solveTabuSo(int m,int n,vector<vector<int>>&grid){\\n                vector<int>prev(n,0);\\n        \\n         for(int i=0;i<m;i++){\\n             vector<int>cur(n,0);\\n             for(int j=0;j<n;j++){\\n                 if(grid[i][j]==1) continue;\\n                 if(i==0 && j==0 ) cur[j]=1;\\n                 else{\\n                     int up=0,left=0;\\n                     if(i>0) up=prev[j];\\n                     if(j>0) left=cur[j-1];\\n                     \\n                    cur[j]=up+left;\\n                 }\\n             }\\n             prev=cur;\\n         }\\n         return prev[n-1];\\n\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // return solve(m-1,n-1,grid);\\n        // vector<vector<int>>dp(m,vector<int>(n,-1));\\n        // return solveMemo(m-1,n-1,grid,dp);\\n        // return solveTabu(m,n,grid);\\n        return solveTabuSo(m,n,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056525,
                "title": "c-easy-recursion-dp-simple-daily-leetcoding-challenge-may-day-20",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& obstacleGrid,int i,int j,vector<vector<int>> &dp,int m ,int n)\\n    {\\n        // if current cell value is not inside the boundary then we can not proceed further return 0\\n        if(i<0 || j<0 || i>=m || j>=n || obstacleGrid[i][j]==1)\\n            return 0;\\n        \\n        // if we have already computed the value then no need to calvulate it again\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        // if we have on last cell then tsake it as a path and return 1\\n        if(i==m-1 && j==n-1)\\n        {    \\n            return 1;\\n        }\\n        \\n        // now call the same function for right move and down move and add that\\n        // first this function will go for the right move and calculate it paths\\n        // then after backtrack it will go to down and calculate their paths\\n        // and at the end add up both the paths and return\\n        //                      (right move)             (down move)\\n        return dp[i][j]=dfs(obstacleGrid,i,j+1,dp,m,n)+dfs(obstacleGrid,i+1,j,dp,m,n);\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m=obstacleGrid.size();      // no. of rows\\n        int n=obstacleGrid[0].size();   // no. of columns\\n        \\n        // set all values as -1 for dp\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        // return the possible paths\\n        return dfs(obstacleGrid,0,0,dp,m,n);   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& obstacleGrid,int i,int j,vector<vector<int>> &dp,int m ,int n)\\n    {\\n        // if current cell value is not inside the boundary then we can not proceed further return 0\\n        if(i<0 || j<0 || i>=m || j>=n || obstacleGrid[i][j]==1)\\n            return 0;\\n        \\n        // if we have already computed the value then no need to calvulate it again\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        \\n        // if we have on last cell then tsake it as a path and return 1\\n        if(i==m-1 && j==n-1)\\n        {    \\n            return 1;\\n        }\\n        \\n        // now call the same function for right move and down move and add that\\n        // first this function will go for the right move and calculate it paths\\n        // then after backtrack it will go to down and calculate their paths\\n        // and at the end add up both the paths and return\\n        //                      (right move)             (down move)\\n        return dp[i][j]=dfs(obstacleGrid,i,j+1,dp,m,n)+dfs(obstacleGrid,i+1,j,dp,m,n);\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m=obstacleGrid.size();      // no. of rows\\n        int n=obstacleGrid[0].size();   // no. of columns\\n        \\n        // set all values as -1 for dp\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        // return the possible paths\\n        return dfs(obstacleGrid,0,0,dp,m,n);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915667,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: obstacleGrid[0].count), count: obstacleGrid.count)\\n        \\n        matrix[0][0] = 1\\n        for i in 0..<obstacleGrid.count {\\n            for j in 0..<obstacleGrid[0].count {\\n                if i > 0 { matrix[i][j] += matrix[i - 1][j] }\\n                if j > 0 { matrix[i][j] += matrix[i][j - 1] }\\n                if obstacleGrid[i][j] == 1 { matrix[i][j] = 0 }\\n            }\\n        }\\n        \\n        return matrix[obstacleGrid.count - 1][obstacleGrid[0].count - 1]\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        var matrix: [[Int]] = Array(repeating: Array(repeating: 0, count: obstacleGrid[0].count), count: obstacleGrid.count)\\n        \\n        matrix[0][0] = 1\\n        for i in 0..<obstacleGrid.count {\\n            for j in 0..<obstacleGrid[0].count {\\n                if i > 0 { matrix[i][j] += matrix[i - 1][j] }\\n                if j > 0 { matrix[i][j] += matrix[i][j - 1] }\\n                if obstacleGrid[i][j] == 1 { matrix[i][j] = 0 }\\n            }\\n        }\\n        \\n        return matrix[obstacleGrid.count - 1][obstacleGrid[0].count - 1]\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180265,
                "title": "c-super-simple-and-clean-dynamic-programming-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if (obstacleGrid[0][0] == 1) \\n            return 0;\\n        \\n        obstacleGrid[0][0] = 1;\\n        \\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        \\n        for (int i = 1; i < n; i++)\\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i-1][0] == 1) ? 1 : 0;\\n\\n        for (int i = 1; i < m; i++)\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i-1] == 1) ? 1 : 0;\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                obstacleGrid[i][j] = obstacleGrid[i][j] == 1 ? 0 : obstacleGrid[i-1][j] + obstacleGrid[i][j-1];\\n        \\n        return obstacleGrid[n-1][m-1];\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if (obstacleGrid[0][0] == 1) \\n            return 0;\\n        \\n        obstacleGrid[0][0] = 1;\\n        \\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        \\n        for (int i = 1; i < n; i++)\\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i-1][0] == 1) ? 1 : 0;\\n\\n        for (int i = 1; i < m; i++)\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i-1] == 1) ? 1 : 0;\\n\\n        for (int i = 1; i < n; i++)\\n            for (int j = 1; j < m; j++)\\n                obstacleGrid[i][j] = obstacleGrid[i][j] == 1 ? 0 : obstacleGrid[i-1][j] + obstacleGrid[i][j-1];\\n        \\n        return obstacleGrid[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056536,
                "title": "simple-c-code-dp-both-recursive-and-iterative-approach",
                "content": "Recursive Approach\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(grid[x][y]==1) return 0;\\n        if(x==0 && y==0) return 1;\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = 0;\\n        if(x>0) ans += fun(x-1, y, grid);\\n        if(y>0) ans += fun(x, y-1, grid);\\n        return dp[x][y] = ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();   \\n        dp.resize(m, vector<int>(n, -1));\\n        return fun(m-1, n-1, grid);\\n    }\\n};\\n```\\n\\nIterative Approach\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        if(grid[0][0]==1) return 0;\\n        int m = grid.size(), n = grid[0].size();   \\n        vector<vector<int>> dp(m, vector<int>(n));\\n        dp[0][0] = 1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                dp[i][j] = 0;\\n                if(grid[i][j]==1) continue;\\n                if(i>0) dp[i][j] += dp[i-1][j];\\n                if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int fun(int x, int y, vector<vector<int>>& grid){\\n        if(grid[x][y]==1) return 0;\\n        if(x==0 && y==0) return 1;\\n        if(dp[x][y]!=-1) return dp[x][y];\\n        int ans = 0;\\n        if(x>0) ans += fun(x-1, y, grid);\\n        if(y>0) ans += fun(x, y-1, grid);\\n        return dp[x][y] = ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();   \\n        dp.resize(m, vector<int>(n, -1));\\n        return fun(m-1, n-1, grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        if(grid[0][0]==1) return 0;\\n        int m = grid.size(), n = grid[0].size();   \\n        vector<vector<int>> dp(m, vector<int>(n));\\n        dp[0][0] = 1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                dp[i][j] = 0;\\n                if(grid[i][j]==1) continue;\\n                if(i>0) dp[i][j] += dp[i-1][j];\\n                if(j>0) dp[i][j] += dp[i][j-1];\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23434,
                "title": "python-recursive-solution-with-cache-54ms",
                "content": "    class Solution:\\n        # @param {integer[][]} obstacleGrid\\n        # @return {integer}\\n        def uniquePathsWithObstacles(self, obstacleGrid):\\n            if not len(obstacleGrid) or not len(obstacleGrid[0]):\\n                return 0\\n    \\n            cache = {}\\n            m, n = len(obstacleGrid) - 1, len(obstacleGrid[0]) - 1\\n    \\n            return self.findPath(obstacleGrid, m, n, cache)\\n    \\n        def findPath(self, obstacleGrid, m, n, cache):\\n            if (m, n) in cache:\\n                return cache[(m, n)]\\n            elif m < 0 or n < 0 or obstacleGrid[m][n] == 1:\\n                return 0\\n            elif m == 0 and n == 0:\\n                return 1\\n    \\n            cache[(m, n)] = self.findPath(obstacleGrid, m - 1, n, cache) + self.findPath(obstacleGrid, m, n - 1, cache)\\n    \\n            return cache[(m, n)]",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 2975563,
                "title": "c-easy-to-understand-recursion-memoization-tabulation",
                "content": "**1. Recursion**\\n\\n```\\nint solveRec(int m,int n,vector<vector<int>>& obstacleGrid){\\n        if(m>=obstacleGrid.size() || n>=obstacleGrid[0].size() || obstacleGrid[m][n]==1) return 0;    \\n        if(m==obstacleGrid.size()-1 && n==obstacleGrid[0].size()-1) return 1;                                           \\n        int down=solveRec(m+1,n,obstacleGrid);\\n        int right=solveRec(m,n+1,obstacleGrid);\\n        int ans=down+right;\\n        return ans;\\n    }\\n int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        return solveRec(0,0,obstacleGrid);\\n  }\\n```\\n\\n**2. Memoization**\\n\\n```\\nint solveMem(int m,int n,vector<vector<int>>& obstacleGrid,vector<vector<int>>&dp){\\n        if(m>=obstacleGrid.size() || n>=obstacleGrid[0].size() || obstacleGrid[m][n]==1) return 0;\\n        if(m==obstacleGrid.size()-1 && n==obstacleGrid[0].size()-1) return 1;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int down=solveMem(m+1,n,obstacleGrid,dp);\\n        int right=solveMem(m,n+1,obstacleGrid,dp);\\n        int ans=down+right;\\n        return dp[m][n]=ans;  \\n    }\\n  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n         vector<vector<int>>dp(obstacleGrid.size(),vector<int>(obstacleGrid[0].size(),-1));\\n         return solveMem(0,0,obstacleGrid,dp);\\n  }\\n```\\n**3. Tabulation**\\n\\n```\\nint solveTab(vector<vector<int>>& obstacleGrid){\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(obstacleGrid[0][0]==1) return 0;\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        dp[0][0]=1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                \\n                if(obstacleGrid[i][j]==0){ // if there is no obstacle present in the grid\\n                    \\n                    int moveUp=0;\\n                    int moveleft=0;\\n                    \\n                    if(i-1>=0){\\n                        moveUp=dp[i-1][j];\\n                    }\\n                    if(j-1>=0){\\n                        moveleft=dp[i][j-1];\\n                    }\\n                    dp[i][j]=moveUp+moveleft;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        return solveTab(obstacleGrid);\\n  }\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nint solveRec(int m,int n,vector<vector<int>>& obstacleGrid){\\n        if(m>=obstacleGrid.size() || n>=obstacleGrid[0].size() || obstacleGrid[m][n]==1) return 0;    \\n        if(m==obstacleGrid.size()-1 && n==obstacleGrid[0].size()-1) return 1;                                           \\n        int down=solveRec(m+1,n,obstacleGrid);\\n        int right=solveRec(m,n+1,obstacleGrid);\\n        int ans=down+right;\\n        return ans;\\n    }\\n int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        return solveRec(0,0,obstacleGrid);\\n  }\\n```\n```\\nint solveMem(int m,int n,vector<vector<int>>& obstacleGrid,vector<vector<int>>&dp){\\n        if(m>=obstacleGrid.size() || n>=obstacleGrid[0].size() || obstacleGrid[m][n]==1) return 0;\\n        if(m==obstacleGrid.size()-1 && n==obstacleGrid[0].size()-1) return 1;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int down=solveMem(m+1,n,obstacleGrid,dp);\\n        int right=solveMem(m,n+1,obstacleGrid,dp);\\n        int ans=down+right;\\n        return dp[m][n]=ans;  \\n    }\\n  int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n         vector<vector<int>>dp(obstacleGrid.size(),vector<int>(obstacleGrid[0].size(),-1));\\n         return solveMem(0,0,obstacleGrid,dp);\\n  }\\n```\n```\\nint solveTab(vector<vector<int>>& obstacleGrid){\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(obstacleGrid[0][0]==1) return 0;\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        dp[0][0]=1;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 && j==0) continue;\\n                \\n                if(obstacleGrid[i][j]==0){ // if there is no obstacle present in the grid\\n                    \\n                    int moveUp=0;\\n                    int moveleft=0;\\n                    \\n                    if(i-1>=0){\\n                        moveUp=dp[i-1][j];\\n                    }\\n                    if(j-1>=0){\\n                        moveleft=dp[i][j-1];\\n                    }\\n                    dp[i][j]=moveUp+moveleft;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        return solveTab(obstacleGrid);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897008,
                "title": "beats-100-video-java-c-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ra9n-M2OzDM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] A) {\\n        int n = A.length;\\n        int m = A[0].length;\\n        int [][] ans = new int[n][m];\\n        for(int i = 0;i<n;i++){\\n            if(A[i][0] == 0) ans[i][0] = 1;\\n            else break;\\n        }\\n        for(int j = 0;j<m;j++){\\n            if(A[0][j] == 0) ans[0][j] = 1;\\n            else break;\\n        }\\n\\n        for(int i = 1;i<n;i++){\\n            for(int j = 1;j<m;j++){\\n                if(A[i][j]==0) ans[i][j] = ans[i-1][j]+ans[i][j-1];\\n            }\\n        }\\n        return ans[n-1][m-1];\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (A[i][0] == 0)\\n                ans[i][0] = 1;\\n            else\\n                break;\\n        }\\n        \\n        for (int j = 0; j < m; j++) {\\n            if (A[0][j] == 0)\\n                ans[0][j] = 1;\\n            else\\n                break;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                if (A[i][j] == 0)\\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1];\\n            }\\n        }\\n        \\n        return ans[n-1][m-1];\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        m = len(A[0])\\n        ans = [[0] * m for _ in range(n)]\\n        \\n        for i in range(n):\\n            if A[i][0] == 0:\\n                ans[i][0] = 1\\n            else:\\n                break\\n        \\n        for j in range(m):\\n            if A[0][j] == 0:\\n                ans[0][j] = 1\\n            else:\\n                break\\n        \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if A[i][j] == 0:\\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1]\\n        \\n        return ans[n-1][m-1]\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] A) {\\n        int n = A.length;\\n        int m = A[0].length;\\n        int [][] ans = new int[n][m];\\n        for(int i = 0;i<n;i++){\\n            if(A[i][0] == 0) ans[i][0] = 1;\\n            else break;\\n        }\\n        for(int j = 0;j<m;j++){\\n            if(A[0][j] == 0) ans[0][j] = 1;\\n            else break;\\n        }\\n\\n        for(int i = 1;i<n;i++){\\n            for(int j = 1;j<m;j++){\\n                if(A[i][j]==0) ans[i][j] = ans[i-1][j]+ans[i][j-1];\\n            }\\n        }\\n        return ans[n-1][m-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        vector<vector<int>> ans(n, vector<int>(m, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (A[i][0] == 0)\\n                ans[i][0] = 1;\\n            else\\n                break;\\n        }\\n        \\n        for (int j = 0; j < m; j++) {\\n            if (A[0][j] == 0)\\n                ans[0][j] = 1;\\n            else\\n                break;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                if (A[i][j] == 0)\\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1];\\n            }\\n        }\\n        \\n        return ans[n-1][m-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        m = len(A[0])\\n        ans = [[0] * m for _ in range(n)]\\n        \\n        for i in range(n):\\n            if A[i][0] == 0:\\n                ans[i][0] = 1\\n            else:\\n                break\\n        \\n        for j in range(m):\\n            if A[0][j] == 0:\\n                ans[0][j] = 1\\n            else:\\n                break\\n        \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if A[i][j] == 0:\\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1]\\n        \\n        return ans[n-1][m-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386610,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        if(g[0][0])return 0;\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(g[i][0])dp[i][0]=0;\\n            else dp[i][0]=dp[i-1][0];\\n        }\\n        for(int j=1;j<m;j++){\\n            if(g[0][j])dp[0][j]=0;\\n            else dp[0][j]=dp[0][j-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(g[i][j])dp[i][j]=0;\\n                else\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/67f7a904-7321-42be-bd91-a472984d957a_1680787983.9002156.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        if(g[0][0])return 0;\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(g[i][0])dp[i][0]=0;\\n            else dp[i][0]=dp[i-1][0];\\n        }\\n        for(int j=1;j<m;j++){\\n            if(g[0][j])dp[0][j]=0;\\n            else dp[0][j]=dp[0][j-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(g[i][j])dp[i][j]=0;\\n                else\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855384,
                "title": "python-96-09-faster-dp-recursive-memoization",
                "content": "**Recursive Solution but it will give TLE :**\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m,n=len(obstacleGrid),len(obstacleGrid[0])\\n        def countPath(i,j):\\n            if i>=m or j>=n or obstacleGrid[i][j]==1 :\\n                return 0\\n            if i==m-1 and j==n-1:\\n                if obstacleGrid[i][j]==1:\\n                    return 0\\n                return 1\\n            return countPath(i+1,j) + countPath(i,j+1)\\n        return countPath(0,0)\\n```\\n**Recursive + Memoiztion Solution (Top Down Approach) :**\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m,n=len(obstacleGrid),len(obstacleGrid[0])\\n        def countPath(i,j):\\n            if i>=m or j>=n or obstacleGrid[i][j]==1:\\n                dp[i][j]=0\\n            if i==m-1 and j==n-1:\\n                if obstacleGrid[i][j]==1:\\n                    return 0\\n                dp[i][j]=1\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            dp[i][j] = countPath(i+1,j) + countPath(i,j+1)\\n            return dp[i][j]\\n        dp=[[-1 for i in range(n+1)] for j in range(m+1)]\\n        return countPath(0,0)\\n```\\n\\n**An upvote will be encouraging**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m,n=len(obstacleGrid),len(obstacleGrid[0])\\n        def countPath(i,j):\\n            if i>=m or j>=n or obstacleGrid[i][j]==1 :\\n                return 0\\n            if i==m-1 and j==n-1:\\n                if obstacleGrid[i][j]==1:\\n                    return 0\\n                return 1\\n            return countPath(i+1,j) + countPath(i,j+1)\\n        return countPath(0,0)\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m,n=len(obstacleGrid),len(obstacleGrid[0])\\n        def countPath(i,j):\\n            if i>=m or j>=n or obstacleGrid[i][j]==1:\\n                dp[i][j]=0\\n            if i==m-1 and j==n-1:\\n                if obstacleGrid[i][j]==1:\\n                    return 0\\n                dp[i][j]=1\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            dp[i][j] = countPath(i+1,j) + countPath(i,j+1)\\n            return dp[i][j]\\n        dp=[[-1 for i in range(n+1)] for j in range(m+1)]\\n        return countPath(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585191,
                "title": "python-simple-approach-dp-approach-explained-in-a-super-simple-manner",
                "content": "This problem is almost a spitting image of  [62. Unique Paths](https://leetcode.com/problems/unique-paths/).\\n\\nLet\\'s think of this problem in a super simple manner.\\n\\nOne important thing to remember is you can only walk right and down.\\nNotation I am going to use (row, column).\\n\\nFirst, I create a placeholder 2d array, called `arr_path`, with 0s.\\n\\nWe are going to walk over the cells (the two for loops in the code). And each time we step on a cell, we are going to ask a question to ourself, how many unique paths are there to get to this cell? Well, for the first cell (0,0) we would only have 1 unique path. So we will start off with that.\\n\\nNext, think of walking over cell (0,1). How many unique paths are there to get to this cell? Well, it is too simple since we can only have 1 unique path to get to (0,1) from (0,0). This behavior is same for all the cells in the topmost row.\\n\\nNow, we get to the second row, we ask the same qustion for the cell in (1,0). How many unique paths are there to get from (0,0)? This is too simple since there is only one path to get to (1,0) from (0,0). But now, when we get to (1,1), we have to add the unique path to get to (1,0) and unique path to get to (0,1), so there are 2 unique paths to get to (1,1) from (0,0).\\n\\nThat\\'s all you gotta do. And whenever you step on the cell, you just need to sum up the unique path to get to the cell which is above your current cell and the unique path to get to the cell which is left of your current cell (both of which has been computed before). We are accumulating the unique paths of every grid cell as we walk over the grid.\\n\\nSo now, when you see an obstacle, simply skip upading `arr_path` for that cell. When you get to the next cell, you will look for previous cells (up and left) in `arr_path` and you will add up the paths. Since you skipped updating `arr_path` when you saw an obstacle, that value will remain 0 and you are just adding up 0 with whatever number the other previous cell has (it can be 0 too, if both of the previous cells are obstacles).\\n\\nFinally you just return the unique path which you get for the cell which is at the bottom-right corner! This can be 0 too if there is an obstacle there. Since `arr_path` is initialized with all 0s, if there is an obstacle in the final cell, you will just return 0.\\n\\nAnd, this basically is dynamic programming.\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if len(obstacleGrid) == 0 or obstacleGrid is None or obstacleGrid[0][0] == 1: # All the edge cases, including the case where the starting position has obstacle\\n            return 0\\n        \\n        rows = len(obstacleGrid)\\n        cols = len(obstacleGrid[0])\\n        arr_paths = [[0 for _ in range(cols)] for _ in range(rows)]\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r == 0 and c == 0:\\n                    arr_paths[r][c] = 1 # There is one way to get from starting position to starting position\\n                    continue\\n                    \\n                if obstacleGrid[r][c] == 1: # obstacle, don\\'t count\\n                    continue\\n                    \\n                if r-1 < 0:  # For topmost row\\n                    arr_paths[r][c] = arr_paths[r][c-1]\\n                elif c-1 < 0: # For leftmost column\\n                    arr_paths[r][c] = arr_paths[r-1][c] \\n                else:\\n                    arr_paths[r][c] = arr_paths[r][c-1] + arr_paths[r-1][c]\\n                \\n        return arr_paths[r][c] # Even if the ending position has obstacle, it will return 0 since the placeholder array is initialized with all 0s\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if len(obstacleGrid) == 0 or obstacleGrid is None or obstacleGrid[0][0] == 1: # All the edge cases, including the case where the starting position has obstacle\\n            return 0\\n        \\n        rows = len(obstacleGrid)\\n        cols = len(obstacleGrid[0])\\n        arr_paths = [[0 for _ in range(cols)] for _ in range(rows)]\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if r == 0 and c == 0:\\n                    arr_paths[r][c] = 1 # There is one way to get from starting position to starting position\\n                    continue\\n                    \\n                if obstacleGrid[r][c] == 1: # obstacle, don\\'t count\\n                    continue\\n                    \\n                if r-1 < 0:  # For topmost row\\n                    arr_paths[r][c] = arr_paths[r][c-1]\\n                elif c-1 < 0: # For leftmost column\\n                    arr_paths[r][c] = arr_paths[r-1][c] \\n                else:\\n                    arr_paths[r][c] = arr_paths[r][c-1] + arr_paths[r-1][c]\\n                \\n        return arr_paths[r][c] # Even if the ending position has obstacle, it will return 0 since the placeholder array is initialized with all 0s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23373,
                "title": "simple-java-dp-solution",
                "content": "    public class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int[][] s = new int[m][n];\\n        s[0][0] = obstacleGrid[0][0]==0 ? 1:0;\\n        if(s[0][0] == 0) return 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(obstacleGrid[i][j] == 1) s[i][j] = 0;\\n                else if(i==0){\\n                    if(j>0) s[i][j] = s[i][j-1];\\n                }\\n                else if(j==0){\\n                    if(i>0) s[i][j] = s[i-1][j];\\n                }\\n                else s[i][j] = s[i-1][j] + s[i][j-1];\\n            }\\n        }\\n        return s[m-1][n-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int[][] s = new int[m][n];\\n        s[0][0] = obstacleGrid[0][0]==0 ? 1:0;\\n        if(s[0][0] == 0) return 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(obstacleGrid[i][j] == 1) s[i][j] = 0;\\n                else if(i==0){\\n                    if(j>0) s[i][j] = s[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3897357,
                "title": "c-dp-iterative-day-12",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& v) {\\n        int n = v.size(),m =v[0].size();\\n        if(v[0][0] || v[n-1][m-1])return 0;\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(v[i][0])dp[i][0]=0;\\n            else dp[i][0]=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            if(v[0][i])dp[0][i]=0;\\n            else dp[0][i]=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(!v[i][j])dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/c2e14538-66fb-4295-9705-0184793a06e1_1691815281.1305342.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& v) {\\n        int n = v.size(),m =v[0].size();\\n        if(v[0][0] || v[n-1][m-1])return 0;\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<n;i++){\\n            if(v[i][0])dp[i][0]=0;\\n            else dp[i][0]=dp[i-1][0];\\n        }\\n        for(int i=1;i<m;i++){\\n            if(v[0][i])dp[0][i]=0;\\n            else dp[0][i]=dp[0][i-1];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(!v[i][j])dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898972,
                "title": "0-ms-100-faster-java-solution-2-ways-dp-and-no-extra-space",
                "content": "# Approach 1 : Using Dynamic Programming\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every cell that is not an obstacle,\\nThe number of ways to reach it is the sum of\\n`Number of ways to reach the cell to its left`\\nAnd `the number of ways to reach the cell above it`\\n\\n`ways[row][column]` = `ways[row - 1][column]` + `ways[row][column - 1]`\\n\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n![Screenshot (3903).png](https://assets.leetcode.com/users/images/81a61705-4980-4d59-802d-393543a5383d_1691837260.698575.png)\\n```java []\\nclass Solution // 100.00% faster, 0 ms solution\\n{\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) \\n    {\\n        int m = obstacleGrid.length, n = obstacleGrid[0].length;\\n        int dp[][] = new int [m+1][n+1];\\n        if(obstacleGrid[0][0] != 1)\\n        dp[1][1] = 1;\\n        for (int i = 1; i <= m; i++)\\n            for (int j = 1; j <= n; j++)\\n                if (obstacleGrid[i - 1][j - 1] != 1)\\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\\n        return dp[m][n];\\n    }\\n}\\n```\\n```cpp []\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Unique Paths II.\\n// Memory Usage: 7.9 MB, less than 25.25% of C++ online submissions for Unique Paths II.\\nclass Solution\\n{\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\\n    {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        // If the starting point is an obstacle\\n        // there is no way to reach th e bottom- right cell\\n        if (obstacleGrid[0][0] == 1)\\n            dp[1][1] = 1;\\n        // Set the starting point as 1\\n        // Always 1 way to reach this cell, in case its not an obstacle\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++)\\n            for (int j = 1; j <= n; j++)\\n                if (obstacleGrid[i - 1][j - 1] != 1)\\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n# Approach 2 : No extra Space\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```cpp []\\nclass Solution // Runtime: 3 ms, faster than 80.74% of C++ online submissions for Unique Paths II.\\n               // Memory Usage: 7.5 MB, less than 90.13% of C++ online submissions for Unique Paths II.\\n{\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\\n    {\\n        // If the starting cell is an obstacle\\n        // There will be no way to reach the bottom-right cell\\n        // Hence return 0\\n        if (obstacleGrid[0][0])\\n            return 0;\\n        // For any given cell best a robot can do is to\\n        // Go down or go right\\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        obstacleGrid[0][0] = 1;\\n\\n        for (int i = 1; i < m; i++)     // For the top row, cells can only be reached from the left (previous column)\\n            // if at (i,j) obstacle is present, set it to 0 ===> No contribution\\n            // Otherwise Set it equal the cell just left of it\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0) ? obstacleGrid[0][i - 1] : 0;\\n\\n        for (int i = 1; i < n; i++) \\n        // Similarily for the leftmost column, only way to travel is down\\n        // And therefore it can only be reached from the up (previous row)\\n        obstacleGrid[i][0] = (obstacleGrid[i][0] == 0) ? obstacleGrid[i - 1][0] : 0;\\n\\n        for (int i = 1; i < n; i++)     // For any other cell, the number of ways to reach it is equal to the number of ways to\\n            for (int j = 1; j < m; j++) // reach the cell to its left and the cell above it\\n                if (obstacleGrid[i][j]) // if at (i,j) obstacle is present, set it to 0 ===> No contribution\\n                    obstacleGrid[i][j] = 0;\\n                else                                                                      // The number of ways to reach the cell is equal to the number of ways to\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; // reach the cell above it + the number of ways to reach the cell to its left\\n\\n        return obstacleGrid[n - 1][m - 1];\\n    }\\n};\\n```\\n\\n![upvote.png](https://assets.leetcode.com/users/images/d077ccad-9321-4c34-a4a8-b8b79ffd4031_1691838956.8384304.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```java []\\nclass Solution // 100.00% faster, 0 ms solution\\n{\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) \\n    {\\n        int m = obstacleGrid.length, n = obstacleGrid[0].length;\\n        int dp[][] = new int [m+1][n+1];\\n        if(obstacleGrid[0][0] != 1)\\n        dp[1][1] = 1;\\n        for (int i = 1; i <= m; i++)\\n            for (int j = 1; j <= n; j++)\\n                if (obstacleGrid[i - 1][j - 1] != 1)\\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\\n        return dp[m][n];\\n    }\\n}\\n```\n```cpp []\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Unique Paths II.\\n// Memory Usage: 7.9 MB, less than 25.25% of C++ online submissions for Unique Paths II.\\nclass Solution\\n{\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\\n    {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        // If the starting point is an obstacle\\n        // there is no way to reach th e bottom- right cell\\n        if (obstacleGrid[0][0] == 1)\\n            dp[1][1] = 1;\\n        // Set the starting point as 1\\n        // Always 1 way to reach this cell, in case its not an obstacle\\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\\n        for (int i = 1; i <= m; i++)\\n            for (int j = 1; j <= n; j++)\\n                if (obstacleGrid[i - 1][j - 1] != 1)\\n                    dp[i][j] += dp[i - 1][j] + dp[i][j - 1];\\n        return dp[m][n];\\n    }\\n};\\n```\n```cpp []\\nclass Solution // Runtime: 3 ms, faster than 80.74% of C++ online submissions for Unique Paths II.\\n               // Memory Usage: 7.5 MB, less than 90.13% of C++ online submissions for Unique Paths II.\\n{\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>> &obstacleGrid)\\n    {\\n        // If the starting cell is an obstacle\\n        // There will be no way to reach the bottom-right cell\\n        // Hence return 0\\n        if (obstacleGrid[0][0])\\n            return 0;\\n        // For any given cell best a robot can do is to\\n        // Go down or go right\\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        obstacleGrid[0][0] = 1;\\n\\n        for (int i = 1; i < m; i++)     // For the top row, cells can only be reached from the left (previous column)\\n            // if at (i,j) obstacle is present, set it to 0 ===> No contribution\\n            // Otherwise Set it equal the cell just left of it\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0) ? obstacleGrid[0][i - 1] : 0;\\n\\n        for (int i = 1; i < n; i++) \\n        // Similarily for the leftmost column, only way to travel is down\\n        // And therefore it can only be reached from the up (previous row)\\n        obstacleGrid[i][0] = (obstacleGrid[i][0] == 0) ? obstacleGrid[i - 1][0] : 0;\\n\\n        for (int i = 1; i < n; i++)     // For any other cell, the number of ways to reach it is equal to the number of ways to\\n            for (int j = 1; j < m; j++) // reach the cell to its left and the cell above it\\n                if (obstacleGrid[i][j]) // if at (i,j) obstacle is present, set it to 0 ===> No contribution\\n                    obstacleGrid[i][j] = 0;\\n                else                                                                      // The number of ways to reach the cell is equal to the number of ways to\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; // reach the cell above it + the number of ways to reach the cell to its left\\n\\n        return obstacleGrid[n - 1][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056705,
                "title": "c-2-approaches-recusion-and-bottom-up-approach-use-dp-explanation-with-comments",
                "content": "**Please upvote if you find this solution helpful ;)**\\n\\n**Approach-1 : Use recursion and dynamic programming\\nTC- O(MxN), recursion \\nSC- O(MxN), dp/mxn matrix\\nAuxiliary Space - O(M+N), recursion call**\\n\\n```\\n//We can use recursion but it takes too much time and we get TLE\\n//So, we implement dynamic programming with recursion/dp\\nclass Solution {\\npublic:\\n    \\n    int findPath(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        //boudary and obstacle condition\\n        if(r>=grid.size() || c>=grid[0].size() || grid[r][c]==1) return 0;\\n        \\n        //if we reach right bottom, we get 1 path and return it\\n        if(r==grid.size()-1 && c==grid[0].size()-1) return 1;\\n        \\n        //if path is already store in dp we return it\\n        if(dp[r][c]!=-1) return dp[r][c];\\n        \\n        //calculate the no. of path by moving down and right and return it\\n        //and store it into the dp\\n        return dp[r][c]= (findPath(r+1, c, grid, dp) + findPath(r, c+1, grid, dp));\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size(), n=obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int> (n, -1)); //create mxn matrix dp and initialize it with -1\\n        return findPath(0,0, obstacleGrid, dp); calling the function to find no. of unique path\\n    }\\n};\\n```\\n\\n**Approach-2 : Use bottom-up approach and dynamic programming\\nTC- O(MxN), iteration \\nSC- O(MxN), dp/mxn matrix**\\n\\n```\\n//Use bottom-up approach to save the auxiliary space taken by recursion\\nclass Solution {\\npublic:\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        //if top-left corner has value 1 it means there in no path\\n        if(obstacleGrid[0][0]==1) return 0;\\n        \\n        //store no. of rows and columns\\n        int m = obstacleGrid.size(), n=obstacleGrid[0].size();\\n        \\n        //create dp and initialize it with 0\\n        vector<vector<int>> dp(m, vector<int> (n, 0));\\n        \\n        //base condition for bottom-up approach\\n        dp[0][0] = 1;\\n        \\n        //traverse through the matrix\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                //if we are at top-left corner(0,0) we don\\'t have left(0,-1) and up(-1,0,) cell\\n                //so to avoid this condition we continue at 0,0\\n                if(i==0 && j==0) continue;\\n                \\n                //if there is no obstacle\\n                if(obstacleGrid[i][j]==0)\\n                {\\n                    int up=0, left=0;\\n\\n                    //store top cell value\\n                    if(i-1 >=0)\\n                        up = dp[i-1][j];\\n\\n                    //store left cell value\\n                    if(j-1 >=0)\\n                        left = dp[i][j-1];\\n                \\n                    //and add them for current cell to get no. of unique paths \\n                    //to reach at current position\\n                    dp[i][j] = up + left;\\n                }\\n            }\\n        }\\n        //return dp at (m-1, n-1) that will be the no. of unique paths\\n        //to reach at bottom right corner\\n        return dp[m-1][n-1];\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\n//We can use recursion but it takes too much time and we get TLE\\n//So, we implement dynamic programming with recursion/dp\\nclass Solution {\\npublic:\\n    \\n    int findPath(int r, int c, vector<vector<int>>& grid, vector<vector<int>>& dp)\\n    {\\n        //boudary and obstacle condition\\n        if(r>=grid.size() || c>=grid[0].size() || grid[r][c]==1) return 0;\\n        \\n        //if we reach right bottom, we get 1 path and return it\\n        if(r==grid.size()-1 && c==grid[0].size()-1) return 1;\\n        \\n        //if path is already store in dp we return it\\n        if(dp[r][c]!=-1) return dp[r][c];\\n        \\n        //calculate the no. of path by moving down and right and return it\\n        //and store it into the dp\\n        return dp[r][c]= (findPath(r+1, c, grid, dp) + findPath(r, c+1, grid, dp));\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size(), n=obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int> (n, -1)); //create mxn matrix dp and initialize it with -1\\n        return findPath(0,0, obstacleGrid, dp); calling the function to find no. of unique path\\n    }\\n};\\n```\n```\\n//Use bottom-up approach to save the auxiliary space taken by recursion\\nclass Solution {\\npublic:\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        //if top-left corner has value 1 it means there in no path\\n        if(obstacleGrid[0][0]==1) return 0;\\n        \\n        //store no. of rows and columns\\n        int m = obstacleGrid.size(), n=obstacleGrid[0].size();\\n        \\n        //create dp and initialize it with 0\\n        vector<vector<int>> dp(m, vector<int> (n, 0));\\n        \\n        //base condition for bottom-up approach\\n        dp[0][0] = 1;\\n        \\n        //traverse through the matrix\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                //if we are at top-left corner(0,0) we don\\'t have left(0,-1) and up(-1,0,) cell\\n                //so to avoid this condition we continue at 0,0\\n                if(i==0 && j==0) continue;\\n                \\n                //if there is no obstacle\\n                if(obstacleGrid[i][j]==0)\\n                {\\n                    int up=0, left=0;\\n\\n                    //store top cell value\\n                    if(i-1 >=0)\\n                        up = dp[i-1][j];\\n\\n                    //store left cell value\\n                    if(j-1 >=0)\\n                        left = dp[i][j-1];\\n                \\n                    //and add them for current cell to get no. of unique paths \\n                    //to reach at current position\\n                    dp[i][j] = up + left;\\n                }\\n            }\\n        }\\n        //return dp at (m-1, n-1) that will be the no. of unique paths\\n        //to reach at bottom right corner\\n        return dp[m-1][n-1];\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420437,
                "title": "clean-and-easy-o-1-space",
                "content": "```\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    const m = obstacleGrid.length, n = obstacleGrid[0].length \\n    \\n    if(obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) return false\\n    \\n    for(let i = 0; i < m; i++) {\\n        for(let j = 0; j < n; j++) {\\n            if(i === 0 && j === 0) {\\n                obstacleGrid[i][j] = 1\\n                continue\\n            }\\n            \\n            if(obstacleGrid[i][j] === 1) {\\n                obstacleGrid[i][j] = 0\\n                continue\\n            }\\n            \\n            if(i === 0) {\\n                obstacleGrid[i][j] = obstacleGrid[i][j - 1]\\n                continue\\n            }\\n            \\n            if(j === 0) {\\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j]\\n                continue\\n            }\\n            \\n            obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]\\n        }\\n    }\\n    \\n    \\n    return obstacleGrid[m - 1][n - 1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    const m = obstacleGrid.length, n = obstacleGrid[0].length \\n    \\n    if(obstacleGrid[0][0] || obstacleGrid[m - 1][n - 1]) return false\\n    \\n    for(let i = 0; i < m; i++) {\\n        for(let j = 0; j < n; j++) {\\n            if(i === 0 && j === 0) {\\n                obstacleGrid[i][j] = 1\\n                continue\\n            }\\n            \\n            if(obstacleGrid[i][j] === 1) {\\n                obstacleGrid[i][j] = 0\\n                continue\\n            }\\n            \\n            if(i === 0) {\\n                obstacleGrid[i][j] = obstacleGrid[i][j - 1]\\n                continue\\n            }\\n            \\n            if(j === 0) {\\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j]\\n                continue\\n            }\\n            \\n            obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]\\n        }\\n    }\\n    \\n    \\n    return obstacleGrid[m - 1][n - 1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351467,
                "title": "simple-python-recursion-solution",
                "content": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        \\n        def rec(grid, i, j, d):\\n            if i > len(grid)-1 or j > len(grid[0])-1:\\n                return 0\\n            if grid[i][j] == 1:\\n                return 0\\n            if i == len(grid)-1 and j == len(grid[0])-1:\\n                return 1\\n            if (i,j) in d:\\n                return d[(i,j)]\\n            \\n            down = rec(grid, i+1, j, d)\\n            right = rec(grid, i, j+1, d)\\n            \\n            d[(i,j)] = down + right\\n            return d[(i,j)]\\n            \\n        return rec(obstacleGrid, 0, 0, {})\\n```\\n\\nfirst we check for base cases which are:\\n1. out of bounds\\n2. obstacle \\n3. win \\n4. already calculated it \\n\\nthen do recursion on down and right, add them up and get the result :)",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        \\n        def rec(grid, i, j, d):\\n            if i > len(grid)-1 or j > len(grid[0])-1:\\n                return 0\\n            if grid[i][j] == 1:\\n                return 0\\n            if i == len(grid)-1 and j == len(grid[0])-1:\\n                return 1\\n            if (i,j) in d:\\n                return d[(i,j)]\\n            \\n            down = rec(grid, i+1, j, d)\\n            right = rec(grid, i, j+1, d)\\n            \\n            d[(i,j)] = down + right\\n            return d[(i,j)]\\n            \\n        return rec(obstacleGrid, 0, 0, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180316,
                "title": "unique-paths-ii-js-python-java-c-easy-dp-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to try every path with a **recursive** **depth first search** (**DFS**) approach. That would involve duplicating the processing used for repeating subpaths, however, which would quickly lead to a **TLE** result. When faced with repeating subproblems, we should be thinking of a **dynamic programming** (**DP**) approach to store completed subproblem and avoid any unnecessary duplication of processing.\\n\\nIn this situation, we can create a DP matrix (**dp**) in the same dimensions as our input matrix (**OG**). (_**Note**: We can choose to use an **in-place** approach here and use **OG** as our DP matrix in order to reduce the **space complexity** of our solution to **O(1)**._) Each cell in **dp** will represent the number of paths that lead to the corresponding cell in **OG**. Since the robot can only move either to the right or down, we can perform a **bottom-up** DP solution, working from the initial cell and iterating downward and rightward through **OG**.\\n\\nEach cell in **OG** (**OG[i][j]**) can potentially reached by only two previously-visited cells (**OG[i-1][j]** & **OG[i][j-1]**), so the number of ways to reach the current cell (**dp[i][j]**) should be the sum of the ways to reach those other two cells (**dp[i-1][j] + dp[i][j-1]**), should they exist.\\n\\nSince any cell representing an obstacle cannot be a part of a path, its value in **dp** should be **0**. We\\'ll also need to seed the initial starting position with a value of **1** to represent the single initial path. Once we\\'re done building **dp**, the value of the bottom-right cell should be our answer.\\n\\n - _**Time Complexity: O(N * M)** where **N** and **M** are the dimensions of the input matrix_\\n - _**Space Complexity: O(N * M)** for the DP matrix_\\n    - _or **O(1)** if we use an **in-place** approach for the DP matrix_\\n\\n---\\n\\n#### ***Implementation:***\\n\\nPython can opt to use @lru_cache instead of a standard DP matrix; the standard approach is shown below.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **68ms / 38.6MB** (beats 100% / 96%).\\n```javascript\\nvar uniquePathsWithObstacles = function(OG) {\\n    if (OG[0][0]) return 0\\n    let m = OG.length, n = OG[0].length\\n    let dp = Array.from({length: m}, el => new Uint32Array(n))\\n    dp[0][0] = 1\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++)\\n            if (OG[i][j] || (!i && !j)) continue\\n            else dp[i][j] = (i ? dp[i-1][j] : 0) + (j ? dp[i][j-1] : 0)\\n    return dp[m-1][n-1]\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **36ms / 14.2MB** (beats 94% / 84%).\\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, OG: List[List[int]]) -> int:\\n        if OG[0][0]: return 0\\n        m, n = len(OG), len(OG[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if OG[i][j] or (i == 0 and j == 0): continue\\n                dp[i][j] = (dp[i-1][j] if i else 0) + (dp[i][j-1] if j else 0)\\n        return dp[m-1][n-1]\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **0ms / 38.0MB** (beats 100% / 67%).\\n```java\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.7MB** (beats 100% / 46%).\\n```c++\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.size(), n = OG[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar uniquePathsWithObstacles = function(OG) {\\n    if (OG[0][0]) return 0\\n    let m = OG.length, n = OG[0].length\\n    let dp = Array.from({length: m}, el => new Uint32Array(n))\\n    dp[0][0] = 1\\n    for (let i = 0; i < m; i++)\\n        for (let j = 0; j < n; j++)\\n            if (OG[i][j] || (!i && !j)) continue\\n            else dp[i][j] = (i ? dp[i-1][j] : 0) + (j ? dp[i][j-1] : 0)\\n    return dp[m-1][n-1]\\n};\\n```\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, OG: List[List[int]]) -> int:\\n        if OG[0][0]: return 0\\n        m, n = len(OG), len(OG[0])\\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        for i in range(m):\\n            for j in range(n):\\n                if OG[i][j] or (i == 0 and j == 0): continue\\n                dp[i][j] = (dp[i-1][j] if i else 0) + (dp[i][j-1] if j else 0)\\n        return dp[m-1][n-1]\\n```\n```java\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.size(), n = OG[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,0));\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859669,
                "title": "c-dp-bfs-non-overflowing-solution-explained-97-time-80-space",
                "content": "Premise: I love a good challenge. But that is usually properly specced, not just letting people submit until they figure out what is expected.\\n\\nAs it was the case here, since we are not given any information about the maximum size of the map, number of obstacles, etc. All things that in an interview you would not be told initially, since they are also assessing you on how much and how soon you ask about the constraint. While here you will just have to go through a pointless trial and error.\\n\\nSad.\\n\\nOkay, enough with the ranting.\\n\\nI decided to have a DP-BFS hybrid approach to solve it (after my plain DFS solution failed miserably, see the extra goodie at the bottom).\\n\\nSo, first of all I check if I am getting either empty columns or empty rows - because nobody bothered to tell us if we would, but okay, I will cut it now -, and in case return `0`.\\n\\nIf not we set down a few helper variables:\\n* `x` and `y`, matching our destination goal;\\n* `qLen`, that we will use soon after, but can confidently initialise to `1`.\\n\\nOther edge case (last one!), and we exit if either the starting or the finishing point are blocked, again returning `0`.\\n\\nIf we are still in the game, we need to clone `grid` into another container made of `long`s, because reasons and because so some languages get a \"fair\" extra challenge, in order to avoid overflow.\\n\\nAfter all this unrequested chores, we can finally start doing something more substantial, like declaring our queue `nextLayer`, made of pairs of `int`s to store the coordinate of the next points we are going to visit and then push up inside `x` and `y`, our starting point (I decide to take this problem bottom-up, also because I found it nicer to handle with the conditionals later).\\n\\nAlso note that I set the initial value of our starting point to `-1`: this way we do not have to be concerned about the `1`s we will find, as obstacles, otherwise wasting more memory to switch values while filling in `dp`.\\n\\nAnd then the BFS begins: we are going to loop until `qLen` is truthy, which means until we have at least one more cell to visit.\\n\\nWe will then loop `qLen` times, doing this:\\n* getting updated `x` and `y` values from the front of the queue;\\n* popping the used node out of the queue;\\n* then we move left, checking if we did not go off the bonds (`x > 0`) and if it is a valid, unblocked cell (`dp[y][x] < 1`, see note above about using negative values to represent our potential paths); if so, we push the new coordinates into the queue only if the cell was not visited before (ie: still at value `0`), in order to avoid duplicates, and update its value with the value of all the possible paths we inherited from the previous one;\\n* same logic for the `y` coordinate moving up, but this time always inserting the values in the queue (we already checked left, so we cannot put a duplicate just moving up).\\n\\nAfter this is all done, we update `qLen` and are ready for the next loop.\\n\\nIn the end we return `-dp[0][0]` (remember we used the trick to store the results as negative numbers) and are done :)\\n\\nTo help you visualise how the DP part would work, a visual example with this starting situation (remember that `1` are walls, while we keep track of the possible paths up to a specific cells with its negative value):\\n\\n```cpp\\n// initial map\\n0  1  0  0  1  0\\n0  0  0  0  0  0\\n0  0  1  0  0  0\\n```\\n\\nLet\\'s flag our starting point with `-` the amount of paths up to that cell, by definition `1` for the first step:\\n\\n```cpp\\n// we start\\n 0  0  0  0  1  0\\n 1  0  0  0  0  0\\n 0  0  1  0  0 -1\\n```\\n\\nAnd then let\\'s proceed with our BFS approach:\\n\\n```cpp\\n// second step\\n 0  0  0  0  1  0\\n 1  0  0  0  0 -1\\n 0  0  1  0 -1 -1\\n\\n// third step\\n 0  0  0  0  1 -1\\n 1  0  0  0 -2 -1 //note: first cell we can reach from 2 different paths\\n 0  0  1 -1 -1 -1\\n\\n// fourth step\\n 0  0  0  0  1 -1\\n 1  0  0 -3 -2 -1 //note: first cell we can reach from 3 different paths and first paths blocked\\n 0  0  1 -1 -1 -1\\n\\n// fifth step\\n 0  0  0 -3  1 -1\\n 1  0 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// sixth step\\n 0  0 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// seventh step\\n 0 -6 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// eight and last step\\n-6 -6 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// we would then return -dp[0][0] == 6 possible paths!\\n```\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        // edge case - empty columns or rows\\n        if (!grid.size() || !grid[0].size()) return 0;\\n        int x = grid[0].size() - 1, y = grid.size() - 1, qLen = 1;\\n        // edge cases - destination or starting point blocked\\n        if (grid[y][x] || grid[0][0]) return 0;\\n        // annoyingly necessarily cloned grid here\\n        long dp[y + 1][x + 1];\\n        for (int _y = 0; _y <= y; _y++) {\\n            for (int _x = 0; _x <= x; _x++) dp[_y][_x] = grid[_y][_x];\\n        }\\n        queue<pair<int, int>> nextLayer;\\n        nextLayer.push({x, y});\\n        dp[y][x] = -1;\\n        while (qLen) {\\n            for (int i = 0; i < qLen; i++ ) {\\n                x = nextLayer.front().first;\\n                y = nextLayer.front().second;\\n                // removing the used cell\\n                nextLayer.pop();\\n                // checking the cell on left of the current one\\n                if (x > 0 && dp[y][x - 1] < 1) {\\n                    if (dp[y][x - 1] == 0) nextLayer.push({x - 1, y});\\n                    dp[y][x - 1] += dp[y][x];\\n                }\\n                // checking the cell on top of the current one\\n                if (y > 0 && dp[y - 1][x] < 1) {\\n                    nextLayer.push({x, y - 1});\\n                    dp[y - 1][x] += dp[y][x];\\n                }\\n            }\\n            // preparing for the next run\\n            qLen = nextLayer.size();\\n        }\\n        return -dp[0][0];\\n    }\\n};\\n```\\n\\nExtra goodie - my original DFS code, not passing because the author of this problem did not bother putting a single number about the limits we were going to face, but still good for smaller maps:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int xLen, yLen, res = 0;\\n    void dfs(vector<vector<int>> &grid, int x = 0, int y = 0) {\\n        // exit for out of bonds cases or obstacle found\\n        if (x < 0 || y < 0 || x > xLen || y > yLen || grid[y][x]) return;\\n        // goal reached\\n        if (x == xLen && y == yLen) {\\n            res++;\\n            return;\\n        }\\n        // marking the cell as visited\\n        grid[y][x] = 1;\\n        // exploring north, east, south, west\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        // backtracking the cell as visitable\\n        grid[y][x] = 0;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        // edge case\\n        if (!grid.size() || !grid[0].size()) return res;\\n        // updating class variables\\n        xLen = grid[0].size() - 1;\\n        yLen = grid.size() - 1;\\n        dfs(grid);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\n// initial map\\n0  1  0  0  1  0\\n0  0  0  0  0  0\\n0  0  1  0  0  0\\n```\n```cpp\\n// we start\\n 0  0  0  0  1  0\\n 1  0  0  0  0  0\\n 0  0  1  0  0 -1\\n```\n```cpp\\n// second step\\n 0  0  0  0  1  0\\n 1  0  0  0  0 -1\\n 0  0  1  0 -1 -1\\n\\n// third step\\n 0  0  0  0  1 -1\\n 1  0  0  0 -2 -1 //note: first cell we can reach from 2 different paths\\n 0  0  1 -1 -1 -1\\n\\n// fourth step\\n 0  0  0  0  1 -1\\n 1  0  0 -3 -2 -1 //note: first cell we can reach from 3 different paths and first paths blocked\\n 0  0  1 -1 -1 -1\\n\\n// fifth step\\n 0  0  0 -3  1 -1\\n 1  0 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// sixth step\\n 0  0 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// seventh step\\n 0 -6 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// eight and last step\\n-6 -6 -3 -3  1 -1\\n 1 -3 -3 -3 -2 -1\\n 0  0  1 -1 -1 -1\\n\\n// we would then return -dp[0][0] == 6 possible paths!\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        // edge case - empty columns or rows\\n        if (!grid.size() || !grid[0].size()) return 0;\\n        int x = grid[0].size() - 1, y = grid.size() - 1, qLen = 1;\\n        // edge cases - destination or starting point blocked\\n        if (grid[y][x] || grid[0][0]) return 0;\\n        // annoyingly necessarily cloned grid here\\n        long dp[y + 1][x + 1];\\n        for (int _y = 0; _y <= y; _y++) {\\n            for (int _x = 0; _x <= x; _x++) dp[_y][_x] = grid[_y][_x];\\n        }\\n        queue<pair<int, int>> nextLayer;\\n        nextLayer.push({x, y});\\n        dp[y][x] = -1;\\n        while (qLen) {\\n            for (int i = 0; i < qLen; i++ ) {\\n                x = nextLayer.front().first;\\n                y = nextLayer.front().second;\\n                // removing the used cell\\n                nextLayer.pop();\\n                // checking the cell on left of the current one\\n                if (x > 0 && dp[y][x - 1] < 1) {\\n                    if (dp[y][x - 1] == 0) nextLayer.push({x - 1, y});\\n                    dp[y][x - 1] += dp[y][x];\\n                }\\n                // checking the cell on top of the current one\\n                if (y > 0 && dp[y - 1][x] < 1) {\\n                    nextLayer.push({x, y - 1});\\n                    dp[y - 1][x] += dp[y][x];\\n                }\\n            }\\n            // preparing for the next run\\n            qLen = nextLayer.size();\\n        }\\n        return -dp[0][0];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int xLen, yLen, res = 0;\\n    void dfs(vector<vector<int>> &grid, int x = 0, int y = 0) {\\n        // exit for out of bonds cases or obstacle found\\n        if (x < 0 || y < 0 || x > xLen || y > yLen || grid[y][x]) return;\\n        // goal reached\\n        if (x == xLen && y == yLen) {\\n            res++;\\n            return;\\n        }\\n        // marking the cell as visited\\n        grid[y][x] = 1;\\n        // exploring north, east, south, west\\n        dfs(grid, x + 1, y);\\n        dfs(grid, x, y + 1);\\n        // backtracking the cell as visitable\\n        grid[y][x] = 0;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        // edge case\\n        if (!grid.size() || !grid[0].size()) return res;\\n        // updating class variables\\n        xLen = grid[0].size() - 1;\\n        yLen = grid.size() - 1;\\n        dfs(grid);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374664,
                "title": "simple-easy-to-understand-though-process-explanation-4-solutions-uniquepath-i-extension",
                "content": "This question is extension of Unique Path I; \\nUnique path 1 solution [https://leetcode.com/problems/unique-paths/discuss/374561/100-or-5-Solutions-or-Step-by-Step-optimisation-or-Dp-thought-process] \\n\\nI just extends all the solution presented above here with minimal changes\\n\\n**Backtracking**\\n\\n```\\n\\n/**\\n * We can solve this problem through backtracking.\\n * Backtracking\\n * 1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n * 2. Our constraints: a) We can not move outside of boundary b) we can\\'t go through obstacles\\n * 3. Our choices: a) we can move either Down (i+1,j) or right (i, j+1) from any cell\\n * <p>\\n * Complexity:\\n * To reach a cell there are two way and we try all the source cell to reach this cell.\\n * Complexity: O((m*n)^2) /O (m*n)\\n * <p>\\n * TLE\\n */\\nclass UniquePathsIIBacktracking {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(obstacleGrid, m, n, sx, sy, dx, dy);\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n        if (sx == dx && sy == dy)\\n            return 1;\\n\\n        int path = 0;\\n        if (isSafe(sx, sy, m, n, maze)) {\\n\\n            maze[sx][sy] = -1; //not available for next round\\n\\n            path = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n            maze[sx][sy] = 0; // available for next round\\n        }\\n        return path;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, int[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy] == -1 || maze[sx][sy] == 1) //Line change from UniqPathsI\\n            return false;\\n        return true;\\n    }\\n\\n\\n}\\n\\n```\\n\\n**DP: Top Down; cache backtraking solutions**\\n\\n```\\n\\n/**\\n * In above backtracking, we visit same cell[i][j] and try to reach destination[m-1][n-1].\\n * This happen again n again for different source cell [sx][sy] for this cell [i][j].\\n * <p>\\n * Since there are overlapping sub-problems, we can cache them; Hence DP\\n * <p>\\n * dp[i][j] = dp[i+1][j] + dp[i][j+1] ; [i,j] is in range of [m,n]\\n * *        = 0 [i,j] is Not in range of [m,n]\\n * base case:\\n * i==dx, j==dy => dp[i][j] = 1\\n * <p>\\n * dp[sx][sy] is output\\n * <p>\\n * <p>\\n * <p>\\n * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 40.6 MB, less than 30.77% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathIIDPTopDown {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        int dp[][] = new int[m][n];\\n        for (int i = 0; i < m; i++)\\n            Arrays.fill(dp[i], -1);\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(obstacleGrid, dp, m, n, sx, sy, dx, dy);\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int dp[][], int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        if (isSafe(sx, sy, m, n, maze)) {\\n\\n            //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n            if (sx == dx && sy == dy)\\n                return dp[sx][sy] = 1;\\n\\n            if (dp[sx][sy] != -1)\\n                return dp[sx][sy];\\n\\n            return dp[sx][sy] =\\n                    uniquePaths(maze, dp, m, n, sx + 1, sy, dx, dy)  //down\\n                            +\\n                            uniquePaths(maze, dp, m, n, sx, sy + 1, dx, dy);//right\\n        }\\n        return 0;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, int[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy] == 1) //Line change from UniqPathsI\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\\n\\n**DP: Bottom up [2 variation ]**\\n\\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 40.9 MB, less than 16.92% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathsIIDPBottomUp {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[][] = new int[m][n];\\n\\n        if (obstacleGrid[0][0] == 1)\\n            return 0;\\n\\n        for (int i = 0; i < m; i++) {\\n\\n\\n            for (int j = 0; j < n; j++) {\\n\\n                /**\\n                 * If this is obstacle , can\\'t move from here to anywhere\\n                 */\\n                if (obstacleGrid[i][j] == 1)\\n                    dp[i][j] = 0;\\n                else if (i == 0 && j == 0) //if this is a source, then we can definitely reach here by 1 way\\n                    dp[i][j] = 1;\\n                else if (i == 0) //if this is first row, and moving right direction then we can do whatever we did on previous step\\n                    dp[i][j] = dp[i][j - 1];\\n                else if (j == 0) //if this is first col, and moving down direction then we can do whatever we did on previous step\\n                    dp[i][j] = dp[i - 1][j];\\n                else\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; //we can come here either down or right\\n            }\\n\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n\\n\\n    /**\\n     * Build using pre-check base cases\\n     *\\n     * @param obstacleGrid\\n     * @return\\n     */\\n    public int uniquePathsWithObstaclesLong(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[][] = new int[m][n];\\n\\n\\n        for (int i = 0; i < m; i++)\\n            if (obstacleGrid[i][0] != 1)\\n                dp[i][0] = 1;\\n            else\\n                break;\\n\\n\\n        for (int j = 0; j < n; j++)\\n            if (obstacleGrid[0][j] != 1)\\n                dp[0][j] = 1;\\n            else\\n                break;\\n\\n        for (int i = 1; i < m; i++) {\\n\\n            for (int j = 1; j < n; j++) {\\n\\n                if (obstacleGrid[i][j] != 1) {\\n\\n                    if (obstacleGrid[i - 1][j] != 1)\\n                        dp[i][j] = dp[i - 1][j];\\n\\n                    if (obstacleGrid[i][j - 1] != 1)\\n                        dp[i][j] += dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n\\n        return dp[m - 1][n - 1];\\n\\n\\n    }\\n\\n}\\n\\n```\\n\\n**DP: Bottom up; Space optimized**\\n\\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * We can see we are using only two rows at a time. We can optimize the space\\n * dp[i-1][j] => dp[j] old\\n * dp[i][j-1] => dp[j-1] old\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 39.6 MB, less than 58.46% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathsIIDPBottomUpSpaceOptimize {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[] = new int[n];\\n\\n        if (obstacleGrid[0][0] == 1)\\n            return 0;\\n\\n        for (int i = 0; i < m; i++) {\\n\\n\\n            for (int j = 0; j < n; j++) {\\n\\n                /**\\n                 * If this is obstacle , can\\'t move from here to anywhere\\n                 */\\n                if (obstacleGrid[i][j] == 1)\\n                    dp[j] = 0;\\n                else if (i == 0 && j == 0) //if this is a source, then we can definitely reach here by 1 way\\n                    dp[j] = 1;\\n                else if (i == 0) //if this is first row, and moving right direction then we can do whatever we did on previous step\\n                    dp[j] = dp[j - 1];\\n                else if (j == 0) //if this is first col, and moving down direction then we can do whatever we did on previous step\\n                    dp[j] = dp[j];\\n                else\\n                    dp[j] = dp[j] + dp[j - 1]; //we can come here either down or right\\n            }\\n\\n        }\\n\\n        return dp[n - 1];\\n    }\\n\\n\\n}\\n```\\n\\nRef: Unique path 1 solution [https://leetcode.com/problems/unique-paths/discuss/374561/100-or-5-Solutions-or-Step-by-Step-optimisation-or-Dp-thought-process]",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n\\n/**\\n * We can solve this problem through backtracking.\\n * Backtracking\\n * 1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n * 2. Our constraints: a) We can not move outside of boundary b) we can\\'t go through obstacles\\n * 3. Our choices: a) we can move either Down (i+1,j) or right (i, j+1) from any cell\\n * <p>\\n * Complexity:\\n * To reach a cell there are two way and we try all the source cell to reach this cell.\\n * Complexity: O((m*n)^2) /O (m*n)\\n * <p>\\n * TLE\\n */\\nclass UniquePathsIIBacktracking {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(obstacleGrid, m, n, sx, sy, dx, dy);\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n        if (sx == dx && sy == dy)\\n            return 1;\\n\\n        int path = 0;\\n        if (isSafe(sx, sy, m, n, maze)) {\\n\\n            maze[sx][sy] = -1; //not available for next round\\n\\n            path = uniquePaths(maze, m, n, sx + 1, sy, dx, dy)  //down\\n                    +\\n                    uniquePaths(maze, m, n, sx, sy + 1, dx, dy);//right\\n\\n            maze[sx][sy] = 0; // available for next round\\n        }\\n        return path;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, int[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy] == -1 || maze[sx][sy] == 1) //Line change from UniqPathsI\\n            return false;\\n        return true;\\n    }\\n\\n\\n}\\n\\n```\n```\\n\\n/**\\n * In above backtracking, we visit same cell[i][j] and try to reach destination[m-1][n-1].\\n * This happen again n again for different source cell [sx][sy] for this cell [i][j].\\n * <p>\\n * Since there are overlapping sub-problems, we can cache them; Hence DP\\n * <p>\\n * dp[i][j] = dp[i+1][j] + dp[i][j+1] ; [i,j] is in range of [m,n]\\n * *        = 0 [i,j] is Not in range of [m,n]\\n * base case:\\n * i==dx, j==dy => dp[i][j] = 1\\n * <p>\\n * dp[sx][sy] is output\\n * <p>\\n * <p>\\n * <p>\\n * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 40.6 MB, less than 30.77% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathIIDPTopDown {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        int dp[][] = new int[m][n];\\n        for (int i = 0; i < m; i++)\\n            Arrays.fill(dp[i], -1);\\n\\n        final int sx = 0, sy = 0;\\n        final int dx = m - 1, dy = n - 1;\\n\\n        return uniquePaths(obstacleGrid, dp, m, n, sx, sy, dx, dy);\\n\\n    }\\n\\n    private int uniquePaths(int[][] maze, int dp[][], int m, int n, int sx, int sy, int dx, int dy) {\\n\\n        if (isSafe(sx, sy, m, n, maze)) {\\n\\n            //1. Our goal: To reach destination cell (m-1,n-1), once reach it counted as one path\\n            if (sx == dx && sy == dy)\\n                return dp[sx][sy] = 1;\\n\\n            if (dp[sx][sy] != -1)\\n                return dp[sx][sy];\\n\\n            return dp[sx][sy] =\\n                    uniquePaths(maze, dp, m, n, sx + 1, sy, dx, dy)  //down\\n                            +\\n                            uniquePaths(maze, dp, m, n, sx, sy + 1, dx, dy);//right\\n        }\\n        return 0;\\n    }\\n\\n    private boolean isSafe(int sx, int sy, int m, int n, int[][] maze) {\\n        if (sx >= m || sy >= n || sx < 0 || sy < 0 || maze[sx][sy] == 1) //Line change from UniqPathsI\\n            return false;\\n        return true;\\n    }\\n}\\n\\n```\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * * Complexity : To reach a cell there are two way and we try them only once from the source cell to reach this cell.\\n * * O(m*n) / O (m*n)\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 40.9 MB, less than 16.92% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathsIIDPBottomUp {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[][] = new int[m][n];\\n\\n        if (obstacleGrid[0][0] == 1)\\n            return 0;\\n\\n        for (int i = 0; i < m; i++) {\\n\\n\\n            for (int j = 0; j < n; j++) {\\n\\n                /**\\n                 * If this is obstacle , can\\'t move from here to anywhere\\n                 */\\n                if (obstacleGrid[i][j] == 1)\\n                    dp[i][j] = 0;\\n                else if (i == 0 && j == 0) //if this is a source, then we can definitely reach here by 1 way\\n                    dp[i][j] = 1;\\n                else if (i == 0) //if this is first row, and moving right direction then we can do whatever we did on previous step\\n                    dp[i][j] = dp[i][j - 1];\\n                else if (j == 0) //if this is first col, and moving down direction then we can do whatever we did on previous step\\n                    dp[i][j] = dp[i - 1][j];\\n                else\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; //we can come here either down or right\\n            }\\n\\n        }\\n\\n        return dp[m - 1][n - 1];\\n    }\\n\\n\\n    /**\\n     * Build using pre-check base cases\\n     *\\n     * @param obstacleGrid\\n     * @return\\n     */\\n    public int uniquePathsWithObstaclesLong(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[][] = new int[m][n];\\n\\n\\n        for (int i = 0; i < m; i++)\\n            if (obstacleGrid[i][0] != 1)\\n                dp[i][0] = 1;\\n            else\\n                break;\\n\\n\\n        for (int j = 0; j < n; j++)\\n            if (obstacleGrid[0][j] != 1)\\n                dp[0][j] = 1;\\n            else\\n                break;\\n\\n        for (int i = 1; i < m; i++) {\\n\\n            for (int j = 1; j < n; j++) {\\n\\n                if (obstacleGrid[i][j] != 1) {\\n\\n                    if (obstacleGrid[i - 1][j] != 1)\\n                        dp[i][j] = dp[i - 1][j];\\n\\n                    if (obstacleGrid[i][j - 1] != 1)\\n                        dp[i][j] += dp[i][j - 1];\\n                }\\n            }\\n        }\\n\\n\\n        return dp[m - 1][n - 1];\\n\\n\\n    }\\n\\n}\\n\\n```\n```\\n\\n/**\\n * * dp[i][j] = dp[i-1][j] + dp[i][j-1] ; [i,j] is in range of [m,n]\\n * * *        = 0 [i,j] is Not in range of [m,n]\\n * * base case:\\n * * i==0 or j==0 => dp[i][j] = 0\\n * * i==dx, j==dy => dp[i][j] = 1\\n * * <p>\\n * * dp[dx][dy] is output\\n * <p>\\n * We can see we are using only two rows at a time. We can optimize the space\\n * dp[i-1][j] => dp[j] old\\n * dp[i][j-1] => dp[j-1] old\\n * <p>\\n * Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\n * Memory Usage: 39.6 MB, less than 58.46% of Java online submissions for Unique Paths II.\\n */\\nclass UniquePathsIIDPBottomUpSpaceOptimize {\\n\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n\\n        final int dp[] = new int[n];\\n\\n        if (obstacleGrid[0][0] == 1)\\n            return 0;\\n\\n        for (int i = 0; i < m; i++) {\\n\\n\\n            for (int j = 0; j < n; j++) {\\n\\n                /**\\n                 * If this is obstacle , can\\'t move from here to anywhere\\n                 */\\n                if (obstacleGrid[i][j] == 1)\\n                    dp[j] = 0;\\n                else if (i == 0 && j == 0) //if this is a source, then we can definitely reach here by 1 way\\n                    dp[j] = 1;\\n                else if (i == 0) //if this is first row, and moving right direction then we can do whatever we did on previous step\\n                    dp[j] = dp[j - 1];\\n                else if (j == 0) //if this is first col, and moving down direction then we can do whatever we did on previous step\\n                    dp[j] = dp[j];\\n                else\\n                    dp[j] = dp[j] + dp[j - 1]; //we can come here either down or right\\n            }\\n\\n        }\\n\\n        return dp[n - 1];\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896890,
                "title": "c-o-n-m-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        if(grid[0][0]==1) return 0;\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        \\n        // 0th row: movement from left -> right\\n        for(int i=0, j=0;j<m;j++){\\n            if(grid[i][j]==1) break;\\n            dp[i][j]=1;\\n        }\\n        \\n        // 0th col: movement from top -> bottom\\n        for(int j=0, i=0;i<n;i++){\\n            if(grid[i][j]==1) break;\\n            dp[i][j]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(grid[i][j]==1) continue;\\n                dp[i][j]=dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```\\n\\n**Do upvote if it helps :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        \\n        if(grid[0][0]==1) return 0;\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        \\n        // 0th row: movement from left -> right\\n        for(int i=0, j=0;j<m;j++){\\n            if(grid[i][j]==1) break;\\n            dp[i][j]=1;\\n        }\\n        \\n        // 0th col: movement from top -> bottom\\n        for(int j=0, i=0;i<n;i++){\\n            if(grid[i][j]==1) break;\\n            dp[i][j]=1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(grid[i][j]==1) continue;\\n                dp[i][j]=dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867104,
                "title": "c-recursion-memoization-tabulation-space-optimization-striver",
                "content": "**Recursion:**\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        if(m<0 or n<0 or grid[m][n]==1) return 0;\\n\\t\\tif(m==0 && n==0) return 1;\\n        int left=f(m,n-1,grid);\\n        int up=f(m-1,n,grid);\\n        return left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        return f(m-1,n-1,grid);\\n    }\\n};\\n```\\n\\n**memoization:**\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        if(m<0 or n<0 or grid[m][n]==1) return 0;\\n        if(m==0 && n==0) return 1;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int left=f(m,n-1,grid,dp);\\n        int up=f(m-1,n,grid,dp);\\n        return dp[m][n]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return f(m-1,n-1,grid,dp); \\n    }\\n};\\n```\\n\\n**tabulation:**\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) dp[i][j]=0;\\n                else if(i==0 && j==0) dp[i][j]=1;\\n                else{\\n                    int left=0,up=0;\\n                    if(j-1>=0) left=dp[i][j-1];\\n                    if(i-1>=0) up=dp[i-1][j];\\n                    dp[i][j]=left+up;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n\\t\\tint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        return f(m,n,grid); \\n    }\\n};\\n```\\n**space optimization:**\\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        vector<int> dp(n);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) dp[j]=0;\\n                else if(i==0 && j==0) dp[j]=1;\\n                else{\\n                    int left=0,up=0;\\n                    if(j-1>=0) left=dp[j-1];\\n                    if(i-1>=0) up=dp[j];\\n                    dp[j]=left+up;\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        return f(m,n,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        if(m<0 or n<0 or grid[m][n]==1) return 0;\\n\\t\\tif(m==0 && n==0) return 1;\\n        int left=f(m,n-1,grid);\\n        int up=f(m-1,n,grid);\\n        return left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        return f(m-1,n-1,grid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        if(m<0 or n<0 or grid[m][n]==1) return 0;\\n        if(m==0 && n==0) return 1;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int left=f(m,n-1,grid,dp);\\n        int up=f(m-1,n,grid,dp);\\n        return dp[m][n]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,-1));\\n        return f(m-1,n-1,grid,dp); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        vector<vector<int>> dp(m, vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) dp[i][j]=0;\\n                else if(i==0 && j==0) dp[i][j]=1;\\n                else{\\n                    int left=0,up=0;\\n                    if(j-1>=0) left=dp[i][j-1];\\n                    if(i-1>=0) up=dp[i-1][j];\\n                    dp[i][j]=left+up;\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n\\t\\tint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        return f(m,n,grid); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int m, int n, vector<vector<int>>& grid){\\n        vector<int> dp(n);\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1) dp[j]=0;\\n                else if(i==0 && j==0) dp[j]=1;\\n                else{\\n                    int left=0,up=0;\\n                    if(j-1>=0) left=dp[j-1];\\n                    if(i-1>=0) up=dp[j];\\n                    dp[j]=left+up;\\n                }\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(), n=grid[0].size();\\n        return f(m,n,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693697,
                "title": "c-easy-fast-and-short-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<vector<int>> &dp, vector<vector<int>>& grid)\\n    {\\n        if(grid[i][j]==1) return 0;\\n        \\n        if(i==0 and j==0) return 1;\\n        if(i==0) return dp[i][j-1];\\n        if(j==0) return dp[i-1][j]; \\n            \\n        return dp[i-1][j] + dp[i][j-1];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[n-1][m-1]==1) return 0;\\n        \\n        vector<vector<int>> dp(n, vector<int> (m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        dp[i][j] = solve(i,j,dp, obstacleGrid);\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int i, int j, vector<vector<int>> &dp, vector<vector<int>>& grid)\\n    {\\n        if(grid[i][j]==1) return 0;\\n        \\n        if(i==0 and j==0) return 1;\\n        if(i==0) return dp[i][j-1];\\n        if(j==0) return dp[i-1][j]; \\n            \\n        return dp[i-1][j] + dp[i][j-1];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size(), m = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[n-1][m-1]==1) return 0;\\n        \\n        vector<vector<int>> dp(n, vector<int> (m,0));\\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n        dp[i][j] = solve(i,j,dp, obstacleGrid);\\n        \\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180639,
                "title": "python-go-o-mn-by-dp-w-hint",
                "content": "Python/Go O(mn) by DP\\n\\n[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/65114931fd89780001ce87f5)\\n\\n---\\n\\nHint:\\n\\n#1. Remember to **update source point as 1** (one valid path) to start traversal if source point is not blocked by obstacle\\n\\n#2. Here, we use **in-place update** to avoid extra space usage\\n\\n\\n#3-a. If current grid is blocked by obstacle, then path count = 0\\n\\n#3-b. Otherwise, **path count to current position** = **Path count one step from left** + **Path count one step from top**.\\n\\n---\\n\\n**Implementation** by DP in Python:\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        allow_to_visit = lambda x, y: (1 - obstacleGrid[y][x] )\\n        \\n        # height and width of matrix\\n        h, w = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if h * w == 0 or not allow_to_visit(0, 0):\\n            \\n            # Quick response for invalid cases\\n            return 0\\n        \\n        \\n        # update [0][0] as start point with one valid path\\n        obstacleGrid[0][0] = 1\\n        \\n        ## base case: leftmost column\\n        for y in range(1, h):\\n            obstacleGrid[y][0] = obstacleGrid[y-1][0] * allow_to_visit(0, y)\\n        \\n        \\n        ## base case: top row\\n        for x in range(1, w):\\n            obstacleGrid[0][x] = obstacleGrid[0][x-1] * allow_to_visit(x, 0)\\n        \\n        \\n        ## general cases\\n        for y in range(1, h):\\n            for x in range(1, w):\\n                \\n                # update path count from left and top\\n                obstacleGrid[y][x] = (obstacleGrid[y][x-1] + obstacleGrid[y-1][x]) * allow_to_visit(x, y)\\n        \\n        return obstacleGrid[h-1][w-1]\\n```\\n\\n---\\n\\nShare another implementation by top-down DP in Python\\n\\n```\\n                  \\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        can_walk = lambda x, y: (1 - obstacleGrid[y][x] )\\n        \\n        # height and width of matrix\\n        h, w = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        dp = {}\\n\\n        def walk(x, y):\\n            \\n            if (x, y) in dp:\\n                # look-up DP table\\n                return dp[x, y]\\n\\n            if not 0 <= x < w or not 0 <= y < h or not can_walk(x, y) :\\n                # out-of-board, or cannot walk through\\n                dp[x, y] = 0\\n                return 0\\n\\n            if (x, y) == (0, 0):\\n                # Starting point, aka base case\\n                dp[x, y] = 1\\n                return 1\\n\\n            # General cases\\n            dp[x, y] = walk(x-1, y) + walk(x, y-1)\\n            return dp[(x, y)]\\n                    \\n```\\n\\n---\\n\\n**Implementation** by DP in Golang:\\n\\n```\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    \\n    // helper function\\n    var allowToVisit func (x, y int) int\\n    \\n    allowToVisit = func(x, y int) int{\\n        // 1 : allow to visit\\n        // 0 : can not visit due to obstacle\\n        return 1 - obstacleGrid[y][x]\\n    }\\n    \\n    h, w := len(obstacleGrid), len(obstacleGrid[0])\\n    \\n    if h * w == 0 || allowToVisit(0, 0) == 0 {\\n        // Quick response for invalid cases\\n        return 0\\n    }\\n    \\n    // update [0][0] as start point with one valid path\\n    obstacleGrid[0][0] = 1\\n    \\n    // base case: leftmost column\\n    for y := 1 ; y < h ; y++{\\n        obstacleGrid[y][0] = obstacleGrid[y-1][0] * allowToVisit(0, y)\\n    }\\n    \\n    // base case: top row\\n    for x := 1 ; x < w ; x++{\\n        obstacleGrid[0][x] = obstacleGrid[0][x-1] * allowToVisit(x, 0)\\n    }    \\n    \\n    // general cases:\\n    for y := 1 ; y < h ; y++{\\n        for x := 1 ; x < w ; x ++{\\n            \\n            // update path count form left and top\\n            obstacleGrid[y][x] = ( obstacleGrid[y][x-1] + obstacleGrid[y-1][x] ) * allowToVisit(x, y)\\n        }\\n    }\\n    \\n    return obstacleGrid[h-1][w-1]\\n}\\n```\\n\\n---\\n\\n\\nRelated Leetcode challenge:\\n\\n[Leetcode #62 Unique Paths](https://leetcode.com/problems/unique-paths)\\n\\n[Leetcode #63 Unique Paths II](https://leetcode.com/problems/unique-paths-ii)\\n\\n[Leetcode #980 Unique Paths III](https://leetcode.com/problems/unique-paths-iii)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        allow_to_visit = lambda x, y: (1 - obstacleGrid[y][x] )\\n        \\n        # height and width of matrix\\n        h, w = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if h * w == 0 or not allow_to_visit(0, 0):\\n            \\n            # Quick response for invalid cases\\n            return 0\\n        \\n        \\n        # update [0][0] as start point with one valid path\\n        obstacleGrid[0][0] = 1\\n        \\n        ## base case: leftmost column\\n        for y in range(1, h):\\n            obstacleGrid[y][0] = obstacleGrid[y-1][0] * allow_to_visit(0, y)\\n        \\n        \\n        ## base case: top row\\n        for x in range(1, w):\\n            obstacleGrid[0][x] = obstacleGrid[0][x-1] * allow_to_visit(x, 0)\\n        \\n        \\n        ## general cases\\n        for y in range(1, h):\\n            for x in range(1, w):\\n                \\n                # update path count from left and top\\n                obstacleGrid[y][x] = (obstacleGrid[y][x-1] + obstacleGrid[y-1][x]) * allow_to_visit(x, y)\\n        \\n        return obstacleGrid[h-1][w-1]\\n```\n```\\n                  \\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \\n        can_walk = lambda x, y: (1 - obstacleGrid[y][x] )\\n        \\n        # height and width of matrix\\n        h, w = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        dp = {}\\n\\n        def walk(x, y):\\n            \\n            if (x, y) in dp:\\n                # look-up DP table\\n                return dp[x, y]\\n\\n            if not 0 <= x < w or not 0 <= y < h or not can_walk(x, y) :\\n                # out-of-board, or cannot walk through\\n                dp[x, y] = 0\\n                return 0\\n\\n            if (x, y) == (0, 0):\\n                # Starting point, aka base case\\n                dp[x, y] = 1\\n                return 1\\n\\n            # General cases\\n            dp[x, y] = walk(x-1, y) + walk(x, y-1)\\n            return dp[(x, y)]\\n                    \\n```\n```\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    \\n    // helper function\\n    var allowToVisit func (x, y int) int\\n    \\n    allowToVisit = func(x, y int) int{\\n        // 1 : allow to visit\\n        // 0 : can not visit due to obstacle\\n        return 1 - obstacleGrid[y][x]\\n    }\\n    \\n    h, w := len(obstacleGrid), len(obstacleGrid[0])\\n    \\n    if h * w == 0 || allowToVisit(0, 0) == 0 {\\n        // Quick response for invalid cases\\n        return 0\\n    }\\n    \\n    // update [0][0] as start point with one valid path\\n    obstacleGrid[0][0] = 1\\n    \\n    // base case: leftmost column\\n    for y := 1 ; y < h ; y++{\\n        obstacleGrid[y][0] = obstacleGrid[y-1][0] * allowToVisit(0, y)\\n    }\\n    \\n    // base case: top row\\n    for x := 1 ; x < w ; x++{\\n        obstacleGrid[0][x] = obstacleGrid[0][x-1] * allowToVisit(x, 0)\\n    }    \\n    \\n    // general cases:\\n    for y := 1 ; y < h ; y++{\\n        for x := 1 ; x < w ; x ++{\\n            \\n            // update path count form left and top\\n            obstacleGrid[y][x] = ( obstacleGrid[y][x-1] + obstacleGrid[y-1][x] ) * allowToVisit(x, y)\\n        }\\n    }\\n    \\n    return obstacleGrid[h-1][w-1]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115058,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic: int dp[102][102];\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(i>=m || j>=n ) return 0;\\n        if(grid[i][j]==1 ) return 0;\\n        if(i==m-1 && j==n-1 ) return 1;\\n        \\n        \\n        if(dp[i][j]!=-1)  return dp[i][j];\\n        \\n        int temp=solve(grid,i+1,j) +solve(grid,i,j+1);\\n        \\n        return dp[i][j]=temp;\\n        \\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(grid,0,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: int dp[102][102];\\n    int solve(vector<vector<int>>& grid,int i,int j){\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(i>=m || j>=n ) return 0;\\n        if(grid[i][j]==1 ) return 0;\\n        if(i==m-1 && j==n-1 ) return 1;\\n        \\n        \\n        if(dp[i][j]!=-1)  return dp[i][j];\\n        \\n        int temp=solve(grid,i+1,j) +solve(grid,i,j+1);\\n        \\n        return dp[i][j]=temp;\\n        \\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(grid,0,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112600,
                "title": "c-dp-unique-paths-2",
                "content": "```int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size();\\n        int m = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[0][0] == 1 || obstacleGrid[n-1][m-1] == 1){\\n            return 0;\\n        }\\n        \\n        long long dp[n][m];\\n        dp[n-1][m-1] = 1;\\n        bool b = true;\\n        for(int  i=n-2 ; i >= 0 ; i--){\\n            if(obstacleGrid[i][m-1] == 1){\\n                dp[i][m-1] = 0;\\n                b = false;\\n            }\\n            if(b){\\n                dp[i][m-1] = 1;\\n            }\\n            else{\\n                dp[i][m-1] = 0;\\n            }\\n        }\\n        b=true;\\n        for(int  i=m-2 ; i >= 0 ; i--){\\n            if(obstacleGrid[n-1][i] == 1){\\n                dp[n-1][i] = 0;\\n                b = false;\\n            }\\n            if(b){\\n                dp[n-1][i] = 1;\\n            }\\n            else{\\n                dp[n-1][i] = 0;\\n            }\\n        }\\n        for(int  i = n-2 ; i >= 0 ; i--){\\n            for(int  j = m-2 ; j >= 0 ; j--){\\n                if(obstacleGrid[i][j] != 1){\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n                else{\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0][0];\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size();\\n        int m = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[0][0] == 1 || obstacleGrid[n-1][m-1] == 1){\\n            return 0;\\n        }\\n        \\n        long long dp[n][m];\\n        dp[n-1][m-1] = 1;\\n        bool b = true;\\n        for(int  i=n-2 ; i >= 0 ; i--){\\n            if(obstacleGrid[i][m-1] == 1){\\n                dp[i][m-1] = 0;\\n                b = false;\\n            }\\n            if(b){\\n                dp[i][m-1] = 1;\\n            }\\n            else{\\n                dp[i][m-1] = 0;\\n            }\\n        }\\n        b=true;\\n        for(int  i=m-2 ; i >= 0 ; i--){\\n            if(obstacleGrid[n-1][i] == 1){\\n                dp[n-1][i] = 0;\\n                b = false;\\n            }\\n            if(b){\\n                dp[n-1][i] = 1;\\n            }\\n            else{\\n                dp[n-1][i] = 0;\\n            }\\n        }\\n        for(int  i = n-2 ; i >= 0 ; i--){\\n            for(int  j = m-2 ; j >= 0 ; j--){\\n                if(obstacleGrid[i][j] != 1){\\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\\n                }\\n                else{\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        return (int)dp[0][0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 804081,
                "title": "python-easy-simple-dp-solution-time-o-m-n",
                "content": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if obstacleGrid[-1][-1] == 1 or obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        dp = [[0] * len(obstacleGrid[0]) for i in range(len(obstacleGrid))]          # DP Matrix of size m*n intialized to 0\\n        dp[0][0] = 1\\n\\n        for r in range(len(obstacleGrid)):\\n            for c in range(len(obstacleGrid[0])):\\n                if obstacleGrid[r][c] == 0:\\n                    dp[r][c] += dp[r - 1][c] if r - 1 >= 0 else 0\\n                    dp[r][c] += dp[r][c - 1] if c - 1 >= 0 else 0\\n                    \\n        return dp[-1][-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if obstacleGrid[-1][-1] == 1 or obstacleGrid[0][0] == 1:\\n            return 0\\n\\n        dp = [[0] * len(obstacleGrid[0]) for i in range(len(obstacleGrid))]          # DP Matrix of size m*n intialized to 0\\n        dp[0][0] = 1\\n\\n        for r in range(len(obstacleGrid)):\\n            for c in range(len(obstacleGrid[0])):\\n                if obstacleGrid[r][c] == 0:\\n                    dp[r][c] += dp[r - 1][c] if r - 1 >= 0 else 0\\n                    dp[r][c] += dp[r][c - 1] if c - 1 >= 0 else 0\\n                    \\n        return dp[-1][-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898276,
                "title": "python-easy-solution",
                "content": "# Intuition\\nYou can solve this problem using dynamic programming.\\n\\n# Approach\\nYou can solve this problem using dynamic programming. The idea is to create a 2D DP array where each cell `(i, j)` represents the number of unique paths to reach that cell. If the cell contains an obstacle, then the number of paths to that cell is 0. Otherwise, you can calculate the number of paths by adding the number of paths from the cell above `(i-1, j)` and the cell to the left `(i, j-1)`.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n    \\n        # Create a DP array initialized with 0\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the starting point\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n        \\n        # Fill in the DP array\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i > 0:\\n                        dp[i][j] += dp[i - 1][j]\\n                    if j > 0:\\n                        dp[i][j] += dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n    \\n        # Create a DP array initialized with 0\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the starting point\\n        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0\\n        \\n        # Fill in the DP array\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i > 0:\\n                        dp[i][j] += dp[i - 1][j]\\n                    if j > 0:\\n                        dp[i][j] += dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896976,
                "title": "fast-dp-in-rust-go-python",
                "content": "# Intuition \\uD83E\\uDD14\\nWhen faced with the \"Unique Paths II\" problem, the first thought that might come to mind is to navigate through the grid cell by cell. However, with obstacles in our path, a simple traversal won\\'t cut it. We need to remember our past (paths) and make informed decisions as we move. The good news? Dynamic programming is here to save the day (and our robot)!\\n\\n---\\n\\n# Approach \\uD83D\\uDE80\\nUsing dynamic programming, we keep track of the number of ways to reach each cell. The number of paths to a cell is the sum of the paths from the cell above and the cell on the left. However, if there\\'s an obstacle, that cell is a no-go zone (0 paths). \\n\\nTo keep our memory usage in check, we use two 1D arrays, `previous` and `current`, instead of a 2D matrix. As we traverse each row, we update the `current` array and then move on to the next row, making `current` our `previous` and starting fresh.\\n\\nThis rolling array technique is efficient and does the job without hogging memory.\\n\\n---\\n\\n# Complexity \\uD83E\\uDDEE\\n- **Time complexity:** $$O(m \\\\times n)$$ \\n  - We traverse through each cell of the grid once, where \\\\(m\\\\) is the number of rows and \\\\(n\\\\) is the number of columns.\\n\\n- **Space complexity:** $$O(n)$$\\n  - We use two 1D arrays to keep track of our paths, irrespective of the grid\\'s size.\\n\\n---\\n\\n# Code \\uD83E\\uDD80\\n```rust []\\nimpl Solution {\\n    pub fn unique_paths_with_obstacles(obstacleGrid: Vec<Vec<i32>>) -> i32 {\\n        // Basic checks\\n        if obstacleGrid.is_empty() || obstacleGrid[0].is_empty() || obstacleGrid[0][0] == 1 {\\n            return 0;\\n        }\\n        \\n        let m = obstacleGrid.len();\\n        let n = obstacleGrid[0].len();\\n        \\n        // Initialize our trusty path trackers\\n        let mut previous = vec![0; n];\\n        let mut current = vec![0; n];\\n        previous[0] = 1;\\n        \\n        // Traverse each row in the grid\\n        for row in &obstacleGrid {\\n            // Set the starting cell for the row\\n            current[0] = if row[0] == 1 { 0 } else { previous[0] };\\n            for j in 1..n {\\n                // If there\\'s an obstacle, it\\'s a dead end\\n                if row[j] == 1 {\\n                    current[j] = 0;\\n                } else {\\n                    // Otherwise, the paths are the sum from above and left\\n                    current[j] = current[j-1] + previous[j];\\n                }\\n            }\\n            // Roll the arrays for the next row\\n            std::mem::swap(&mut previous, &mut current);\\n        }\\n        \\n        // Our answer lies in the bottom-right corner\\n        previous[n-1]\\n    }\\n}\\n```\\n``` Go []\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    // Handle edge cases: empty grid or start cell has an obstacle\\n    if len(obstacleGrid) == 0 || len(obstacleGrid[0]) == 0 || obstacleGrid[0][0] == 1 {\\n        return 0\\n    }\\n\\n    m := len(obstacleGrid)\\n    n := len(obstacleGrid[0])\\n\\n    // Initialize two 1D arrays to keep track of the number of paths\\n    previous := make([]int, n)\\n    current := make([]int, n)\\n    \\n    // The top-left corner has only one way to be reached (start point)\\n    previous[0] = 1\\n\\n    // Loop through each row of the grid\\n    for i := 0; i < m; i++ {\\n        // If there\\'s an obstacle at the beginning of the row, no way to get there\\n        // Otherwise, it inherits the path count from the previous row\\n        if obstacleGrid[i][0] == 1 {\\n            current[0] = 0\\n        } else {\\n            current[0] = previous[0]\\n        }\\n        \\n        // Loop through the remaining cells in the current row\\n        for j := 1; j < n; j++ {\\n            // If there\\'s an obstacle, no paths to this cell\\n            if obstacleGrid[i][j] == 1 {\\n                current[j] = 0\\n            } else {\\n                // Number of paths is the sum of paths from the top and the left\\n                current[j] = current[j-1] + previous[j]\\n            }\\n        }\\n        \\n        // Swap current and previous arrays for the next iteration\\n        previous, current = current, previous\\n    }\\n    \\n    // Return the number of paths to the bottom-right corner\\n    return previous[n-1]\\n}\\n\\n```\\n``` Python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        # Handle edge cases: empty grid or start cell has an obstacle\\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        # Initialize two 1D arrays to keep track of the number of paths\\n        previous = [0] * n\\n        current = [0] * n\\n        \\n        # The top-left corner has only one way to be reached (start point)\\n        previous[0] = 1\\n        \\n        # Loop through each row of the grid\\n        for i in range(m):\\n            # If there\\'s an obstacle at the beginning of the row, no way to get there\\n            # Otherwise, it inherits the path count from the previous row\\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\\n            \\n            # Loop through the remaining cells in the current row\\n            for j in range(1, n):\\n                # If there\\'s an obstacle, no paths to this cell\\n                if obstacleGrid[i][j] == 1:\\n                    current[j] = 0\\n                else:\\n                    # Number of paths is the sum of paths from the top and the left\\n                    current[j] = current[j-1] + previous[j]\\n            \\n            # Update previous array for the next iteration\\n            previous[:] = current\\n        \\n        # Return the number of paths to the bottom-right corner\\n        return previous[n-1]\\n\\n```\\n---\\n\\n**Final Thoughts:** With dynamic programming and our crabby companion \\uD83E\\uDD80, we\\'ve efficiently solved this intriguing grid problem. Embrace the power of Rust and keep exploring! If you ever feel lost in a grid full of obstacles, just remember: every step you take is building towards the solution. Happy coding! \\uD83D\\uDE80",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Rust",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```rust []\\nimpl Solution {\\n    pub fn unique_paths_with_obstacles(obstacleGrid: Vec<Vec<i32>>) -> i32 {\\n        // Basic checks\\n        if obstacleGrid.is_empty() || obstacleGrid[0].is_empty() || obstacleGrid[0][0] == 1 {\\n            return 0;\\n        }\\n        \\n        let m = obstacleGrid.len();\\n        let n = obstacleGrid[0].len();\\n        \\n        // Initialize our trusty path trackers\\n        let mut previous = vec![0; n];\\n        let mut current = vec![0; n];\\n        previous[0] = 1;\\n        \\n        // Traverse each row in the grid\\n        for row in &obstacleGrid {\\n            // Set the starting cell for the row\\n            current[0] = if row[0] == 1 { 0 } else { previous[0] };\\n            for j in 1..n {\\n                // If there\\'s an obstacle, it\\'s a dead end\\n                if row[j] == 1 {\\n                    current[j] = 0;\\n                } else {\\n                    // Otherwise, the paths are the sum from above and left\\n                    current[j] = current[j-1] + previous[j];\\n                }\\n            }\\n            // Roll the arrays for the next row\\n            std::mem::swap(&mut previous, &mut current);\\n        }\\n        \\n        // Our answer lies in the bottom-right corner\\n        previous[n-1]\\n    }\\n}\\n```\n``` Go []\\nfunc uniquePathsWithObstacles(obstacleGrid [][]int) int {\\n    // Handle edge cases: empty grid or start cell has an obstacle\\n    if len(obstacleGrid) == 0 || len(obstacleGrid[0]) == 0 || obstacleGrid[0][0] == 1 {\\n        return 0\\n    }\\n\\n    m := len(obstacleGrid)\\n    n := len(obstacleGrid[0])\\n\\n    // Initialize two 1D arrays to keep track of the number of paths\\n    previous := make([]int, n)\\n    current := make([]int, n)\\n    \\n    // The top-left corner has only one way to be reached (start point)\\n    previous[0] = 1\\n\\n    // Loop through each row of the grid\\n    for i := 0; i < m; i++ {\\n        // If there\\'s an obstacle at the beginning of the row, no way to get there\\n        // Otherwise, it inherits the path count from the previous row\\n        if obstacleGrid[i][0] == 1 {\\n            current[0] = 0\\n        } else {\\n            current[0] = previous[0]\\n        }\\n        \\n        // Loop through the remaining cells in the current row\\n        for j := 1; j < n; j++ {\\n            // If there\\'s an obstacle, no paths to this cell\\n            if obstacleGrid[i][j] == 1 {\\n                current[j] = 0\\n            } else {\\n                // Number of paths is the sum of paths from the top and the left\\n                current[j] = current[j-1] + previous[j]\\n            }\\n        }\\n        \\n        // Swap current and previous arrays for the next iteration\\n        previous, current = current, previous\\n    }\\n    \\n    // Return the number of paths to the bottom-right corner\\n    return previous[n-1]\\n}\\n\\n```\n``` Python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        # Handle edge cases: empty grid or start cell has an obstacle\\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        # Initialize two 1D arrays to keep track of the number of paths\\n        previous = [0] * n\\n        current = [0] * n\\n        \\n        # The top-left corner has only one way to be reached (start point)\\n        previous[0] = 1\\n        \\n        # Loop through each row of the grid\\n        for i in range(m):\\n            # If there\\'s an obstacle at the beginning of the row, no way to get there\\n            # Otherwise, it inherits the path count from the previous row\\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\\n            \\n            # Loop through the remaining cells in the current row\\n            for j in range(1, n):\\n                # If there\\'s an obstacle, no paths to this cell\\n                if obstacleGrid[i][j] == 1:\\n                    current[j] = 0\\n                else:\\n                    # Number of paths is the sum of paths from the top and the left\\n                    current[j] = current[j-1] + previous[j]\\n            \\n            # Update previous array for the next iteration\\n            previous[:] = current\\n        \\n        # Return the number of paths to the bottom-right corner\\n        return previous[n-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896889,
                "title": "c-recursive-dp-1d-dp-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a DP question. Use DP in a standard way!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere is a similar question which can be solved by using Pascal traingle.\\n[Leetcode 62. Unique Paths](https://leetcode.com/problems/unique-paths/solutions/3602735/python-c-solutions-use-math-pascal-triangle-dp-beats-100/)\\n\\nBut in this question there are so many obstacleGrids, the direct applying of Math trick like Pascal Triangle is is not easy and does not bring benefits( language like python which has packages for computing combinations). It is suggested to use standardard DP to solve.\\n\\nIn fact, it is not difficult to know that\\n```\\nif (obstacleGrid[i][j]==1) return dp[i][j]=0;\\n```\\nIn second approach, optimized 1D iterative DP is implemented which beats 100%.\\n\\nThe space complexity is reduced. Consider the transforms\\n```\\ndp[j]<-dp[i][j]\\nprev[j]<-dp[i-1][j]\\n```\\nBefore the next iteration, don\\'t forget ```prev=dp```! Such tricks are used  in such Pascal-triangle-like problems(Leetcode 118. Pascal\\'s Triangle)\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/paoJGMYEEhA](https://youtu.be/paoJGMYEEhA)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(nm)\\\\to O(m)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<long long>> dp;\\n    long long numsPaths(int i, int j, vector<vector<int>>& obstacleGrid)\\n    {       \\n        if (dp[i][j]!=-1) return dp[i][j];\\n        if (obstacleGrid[i][j]==1) return dp[i][j]=0;\\n        long long ans=0;\\n        if (i>0) ans+=numsPaths(i-1, j, obstacleGrid);\\n        if (j>0) ans+=numsPaths(i, j-1, obstacleGrid);\\n        if (i==0 && j==0) ans=(obstacleGrid[0][0]==0)?1:0;\\n        return dp[i][j]=ans;     \\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        n=obstacleGrid.size();\\n        m=obstacleGrid[0].size();\\n        dp.assign(n, vector<long long>(m, -1));\\n\\n        return numsPaths(n-1, m-1, obstacleGrid);\\n    }\\n};\\n```\\n# Buttom up Approach using 1D arrays beating 100%\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n=obstacleGrid.size();\\n        int m=obstacleGrid[0].size();\\n        vector<int> dp(m, 0), prev(m, 0);\\n        \\n        //Deal with 0th row \\n        for(int j=0; j<m; j++){\\n            if (obstacleGrid[0][j]==1) break;\\n            else dp[j]=1;\\n        }\\n        prev=dp;\\n            \\n        for(int i=1; i<n; i++){\\n            if (obstacleGrid[i][0]==1) dp[0]=0;\\n            else dp[0]=prev[0];\\n            for(int j=1; j<m; j++){\\n                if (obstacleGrid[i][j]==1) dp[j]=0;\\n                else dp[j]=prev[j]+dp[j-1];\\n            }\\n            prev=dp;\\n        }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nif (obstacleGrid[i][j]==1) return dp[i][j]=0;\\n```\n```\\ndp[j]<-dp[i][j]\\nprev[j]<-dp[i-1][j]\\n```\n```prev=dp```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<long long>> dp;\\n    long long numsPaths(int i, int j, vector<vector<int>>& obstacleGrid)\\n    {       \\n        if (dp[i][j]!=-1) return dp[i][j];\\n        if (obstacleGrid[i][j]==1) return dp[i][j]=0;\\n        long long ans=0;\\n        if (i>0) ans+=numsPaths(i-1, j, obstacleGrid);\\n        if (j>0) ans+=numsPaths(i, j-1, obstacleGrid);\\n        if (i==0 && j==0) ans=(obstacleGrid[0][0]==0)?1:0;\\n        return dp[i][j]=ans;     \\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        n=obstacleGrid.size();\\n        m=obstacleGrid[0].size();\\n        dp.assign(n, vector<long long>(m, -1));\\n\\n        return numsPaths(n-1, m-1, obstacleGrid);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n=obstacleGrid.size();\\n        int m=obstacleGrid[0].size();\\n        vector<int> dp(m, 0), prev(m, 0);\\n        \\n        //Deal with 0th row \\n        for(int j=0; j<m; j++){\\n            if (obstacleGrid[0][j]==1) break;\\n            else dp[j]=1;\\n        }\\n        prev=dp;\\n            \\n        for(int i=1; i<n; i++){\\n            if (obstacleGrid[i][0]==1) dp[0]=0;\\n            else dp[0]=prev[0];\\n            for(int j=1; j<m; j++){\\n                if (obstacleGrid[i][j]==1) dp[j]=0;\\n                else dp[j]=prev[j]+dp[j-1];\\n            }\\n            prev=dp;\\n        }\\n        return dp[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847624,
                "title": "c-clean-and-easy-explanation-dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This problem is same as to take that path or not.(take, not take kinda)\\n- We are storing tatal paths of the grid indexes.(by checking one by on in left direction and down).\\n- If there\\'s a obstacle we\\'ll store 0 paths for that.\\n- If we are at destination, simply return.\\n- Otherwise take action in either direction and add both total ways.\\n- Store it in dp table for space optimization.\\n\\n# Complexity\\n- Time complexity: O(2^n) : exponential due to recursive calls\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n\\xB2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& grid, int i, int j, int t[101][101]){\\n        if(i==grid.size() || j==grid[0].size()) return 0; // base case\\n        if(grid[i][j]==1)return 0; // obstacle\\n        if(i==grid.size()-1 && j==grid[0].size()-1)return 1; // destiny\\n        if(t[i][j]!=-1)return t[i][j]; // already calculated\\n        return t[i][j] = helper(grid, i+1, j, t) + helper(grid, i, j+1, t);\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int t[101][101];\\n        memset(t, -1, sizeof t);\\n        return helper(grid, 0, 0, t);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>& grid, int i, int j, int t[101][101]){\\n        if(i==grid.size() || j==grid[0].size()) return 0; // base case\\n        if(grid[i][j]==1)return 0; // obstacle\\n        if(i==grid.size()-1 && j==grid[0].size()-1)return 1; // destiny\\n        if(t[i][j]!=-1)return t[i][j]; // already calculated\\n        return t[i][j] = helper(grid, i+1, j, t) + helper(grid, i, j+1, t);\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int t[101][101];\\n        memset(t, -1, sizeof t);\\n        return helper(grid, 0, 0, t);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050410,
                "title": "beats-100-most-efficient-solution-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        long long mod = 2e9+7;\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                \\n                if(i>=0 && j>=0 && grid[i][j] == 1){\\n                   curr[j] = 0;\\n                    // continue;\\n                } \\n                else if(i==0 && j==0){\\n                    curr[j] = 1;\\n                    // continue;\\n                } \\n                else{\\n                int up=0,left =0;\\n               if(i>0){\\n                   up = prev[j];\\n               }\\n               if(j>0){\\n                   left =curr[j-1];\\n               } \\n                curr[j] = ( up + left) % mod ;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        long long mod = 2e9+7;\\n        vector<int>prev(m,0);\\n        for(int i=0;i<n;i++){\\n            vector<int>curr(m,0);\\n            for(int j=0;j<m;j++){\\n                \\n                if(i>=0 && j>=0 && grid[i][j] == 1){\\n                   curr[j] = 0;\\n                    // continue;\\n                } \\n                else if(i==0 && j==0){\\n                    curr[j] = 1;\\n                    // continue;\\n                } \\n                else{\\n                int up=0,left =0;\\n               if(i>0){\\n                   up = prev[j];\\n               }\\n               if(j>0){\\n                   left =curr[j-1];\\n               } \\n                curr[j] = ( up + left) % mod ;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        \\n        return prev[m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974536,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nl, ml, a[105][105], dp[105][105];\\n\\n    bool valid(int x, int y) {\\n        if(x < nl and y < ml and a[x][y] == 0) return true;\\n        else return false;\\n    }\\n\\n    int solve(int i, int j) {\\n        if(!valid(i, j)) return 0;\\n        if(i >= nl-1 and j >= ml-1) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = solve(i+1, j) + solve(i, j+1);\\n        return dp[i][j] = ans;\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        memset(dp, -1, sizeof(dp));\\n        nl = obstacleGrid.size(), ml = obstacleGrid[0].size();\\n        for(int i=0; i<nl; i++) for(int j=0; j<ml; j++) a[i][j] = obstacleGrid[i][j];\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nl, ml, a[105][105], dp[105][105];\\n\\n    bool valid(int x, int y) {\\n        if(x < nl and y < ml and a[x][y] == 0) return true;\\n        else return false;\\n    }\\n\\n    int solve(int i, int j) {\\n        if(!valid(i, j)) return 0;\\n        if(i >= nl-1 and j >= ml-1) return 1;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int ans = solve(i+1, j) + solve(i, j+1);\\n        return dp[i][j] = ans;\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        memset(dp, -1, sizeof(dp));\\n        nl = obstacleGrid.size(), ml = obstacleGrid[0].size();\\n        for(int i=0; i<nl; i++) for(int j=0; j<ml; j++) a[i][j] = obstacleGrid[i][j];\\n        int ans = solve(0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057572,
                "title": "easy-recursion-optimizing-recursion-using-memoization",
                "content": "\\n#### **RECURSION**\\n*  For every (i, j), there are two possibilites of movement : DOWN (i+1, j) & RIGHT (i, j+1)\\n\\n* **INVALID BASE CASES:**\\n\\t1. \\tIf index i or index j is out of bounds.\\n\\t\\n\\t2. \\tIf (i, j) cell has an obstacle.\\n\\t\\n\\t\\t***In all these cases, the number of unique paths is 0.***\\n\\t\\n*  **VALID BASE CASE:**\\n      \\n\\t1. If (i, j) cell is our destination cell(m-1, n-1), \\n\\t\\n\\t      ***The number of unique path is 1.***\\n\\t\\n\\n\\nUnique paths for Down Move = func(i+1, j) \\nUnique paths for Right Move = func(i, j+1)\\n\\t\\t\\t***Total unique paths = Down Moves + Right Moves = func(i+1, j) + func(i, j+1)***\\n\\n\\n```\\n class Solution {\\n    int m,n;\\n    int[][] grid;\\n    public int recurse(int i, int j) {\\n        if(i==m || j==n || grid[i][j]==1)\\n            return 0; // Invalid case\\n        if(m-1==i && j==n-1)\\n            return 1; //Valid case\\n        return recurse(i, j+1)+recurse(i+1, j);\\n    }\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        m = obstacleGrid.length;\\n        n = obstacleGrid[0].length;\\n        grid = obstacleGrid;\\n        return recurse(0, 0);\\n    }\\n}\\n```\\nThis will have exponential time complexity. \\n\\n#### **Optimization using Memoization (Top-Down)**\\nThere are many cells for which the value is computed more than once.\\n\\nSo, after the value for a certain cell (i, j) is computed, we can store the value and return that value later on.\\n\\n```\\nclass Solution {\\n    Integer dp[][];\\n    int m,n;\\n    int[][] grid;\\n    public int recurse(int i, int j) {\\n        if(i == m || j == n || grid[i][j] == 1)\\n            return 0;\\n\\t\\tif(dp[i][j] != null)\\n            return dp[i][j]; //return the already computed value for cell (i, j)\\n        if(m-1 == i && j == n-1)\\n            return dp[i][j] = 1;\\n        return dp[i][j] = recurse(i, j+1) + recurse(i+1, j); //store value for cell (i, j)\\n    }\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        m = obstacleGrid.length;\\n        n = obstacleGrid[0].length;\\n        grid = obstacleGrid;\\n        dp = new Integer[m][n];\\n        return recurse(0, 0);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n class Solution {\\n    int m,n;\\n    int[][] grid;\\n    public int recurse(int i, int j) {\\n        if(i==m || j==n || grid[i][j]==1)\\n            return 0; // Invalid case\\n        if(m-1==i && j==n-1)\\n            return 1; //Valid case\\n        return recurse(i, j+1)+recurse(i+1, j);\\n    }\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        m = obstacleGrid.length;\\n        n = obstacleGrid[0].length;\\n        grid = obstacleGrid;\\n        return recurse(0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057114,
                "title": "unique-paths-ii-javascript-clean-solution",
                "content": "if you start write your Recursive solution you will get TLE (Time Limit Exceed) \\nso we need to have some way of Cache the result of Every Recursive Call so this technique is called \\nMemomization we will have a Array called **memo** to store our Recursive Result and cache it\\n\\n```javascript\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\n var uniquePathsWithObstacles = function (obstacleGrid) {\\n  const M = obstacleGrid.length;\\n  const N = obstacleGrid[0].length;\\n  const memo = new Array(M).fill(0).map((v) => new Array(N).fill(0)); // 1-memo Array to Cache the Result\\n\\n  const traverse = (x, y) => {\\n    if (obstacleGrid[x] === undefined || obstacleGrid[x][y] === undefined || obstacleGrid[x][y] === 1) return 0; // 2-check is there is Obstacle\\n\\n    if (x === M - 1 && y === N - 1) return 1; // 3-if we reach the Target we need\\n\\n    if (memo[x][y] === 0) { // 4-start to traverse at this point if === 0\\n      memo[x][y] = traverse(x + 1, y) + traverse(x, y + 1);\\n    }\\n    return memo[x][y]; // 5-Return the result\\n  };\\n\\n  return traverse(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} obstacleGrid\\n * @return {number}\\n */\\n var uniquePathsWithObstacles = function (obstacleGrid) {\\n  const M = obstacleGrid.length;\\n  const N = obstacleGrid[0].length;\\n  const memo = new Array(M).fill(0).map((v) => new Array(N).fill(0)); // 1-memo Array to Cache the Result\\n\\n  const traverse = (x, y) => {\\n    if (obstacleGrid[x] === undefined || obstacleGrid[x][y] === undefined || obstacleGrid[x][y] === 1) return 0; // 2-check is there is Obstacle\\n\\n    if (x === M - 1 && y === N - 1) return 1; // 3-if we reach the Target we need\\n\\n    if (memo[x][y] === 0) { // 4-start to traverse at this point if === 0\\n      memo[x][y] = traverse(x + 1, y) + traverse(x, y + 1);\\n    }\\n    return memo[x][y]; // 5-Return the result\\n  };\\n\\n  return traverse(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2055624,
                "title": "c-0ms-runtime-faster-than-100-just-5-line-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];\\n    }\\n    };",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1833335,
                "title": "c-follow-up-question-solution-combination-solving-big-n-m-with-limited-size-obstables",
                "content": "**Follow Up** : \\n\\nGiven the **h * w** matrix where **1 <= h <= 10000, 1 <= w <= 10000**\\nAlso given the positions of the **n** obstacles where **0 <= n <= 1000**\\nFind how many ways **from (0, 0) to (h - 1, w - 1)**\\n<br/><br/>\\n\\n**Part1 : Combination :**\\n* Since the answer for that follow up is very large, we should use a **mod** instead\\n* We know that, if there is 0 obstables, we have **C(h + w - 2, h - 1)** ways from (1, 1) => (h , w). **C** denotes for combinations\\n* Now we want to calculate how many **bad ways** !! The **answer** is **C(h + w - 2, h - 1) - total badways**\\n* Let\\'s choose a starting obstacle, let\\'s say it is **(r1, c1)**\\n* If (r1, c1) is the starting obstcles, we have **(number of ways without touching any obstacle from (1, 1) to (r1, c1)) * C(h - r1 + w - c1, h - r1)** bad ways \\n* Total badways is the sum of if we choose each obstable as a staring obstcle\\n<br/><br/><br/>\\n\\n**Part2 : DP**\\n* But there may be duplication, in this case, we can solve it by using dp. (We first need to sort our obstacles)\\n* Let **dp[i]** denotes number of ways from (1, 1) to obstacle[i] without touching any other obstacles.\\n* **dp[i] = C(r1 + c1 - 2, r1 - c1) - Sum(dp[j])** if *obstacles[j].r <= obstacles[i].r and obstacles[j].c <= obstacles[i].c*\\n* Now, If (r1, c1) is the starting obstcles, we have **(dp[i]) * C(h - r1 + w - c1, h - r1)** bad ways for each choosen starting obstacle\\n\\n**Time : O(max(n ^ 2), log(h + w) (h + w))**\\n**Space : O(max(n ^ 2), log(h + w) (h + w))**\\n\\n```\\nusing ll = long long;\\n#define pb push_back\\n#define f first\\n#define se second\\n#define ve vector\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\n\\n\\n\\nint MOD = 998244353;\\nll mod = 2000000033ll;\\nint INF = INT_MAX;\\n\\nll fact[10000 + 50];\\nll inv[10000 + 50];\\n\\nll C(int n, int r) {\\n    return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\\n}\\n\\nll modInverse(ll a, ll m){\\n    ll m0 = m;\\n    ll y = 0, x = 1;\\n\\n    if (m == 1)\\n        return 0;\\n    \\n    while (a > 1) {\\n        ll q = a / m;\\n        ll t = m;\\n        m = a % m;\\n        a = t;\\n        t = y;\\n        y = x - q * y;\\n        x = t;\\n    }\\n    if (x < 0)\\n        x += m0;\\n    return x;\\n}\\n\\nvoid init() {\\n  fact[0] = fact[1] = 1;\\n  FOR(i, 2, 10000 + 10) {\\n    fact[i] = fact[i - 1] * i;\\n    fact[i] %= mod;\\n  }\\n\\n  inv[0] = inv[1] = 1;\\n  FOR(i, 2, 10000 + 10) {\\n      inv[i] = modInverse(i,mod) * inv[i-1];\\n      inv[i] %=mod;\\n  }\\n}\\n\\nbool com(pair<int, int>& a, pair<int, int>& b) {\\n  if(a.f == b.f) {\\n    return a.se < b.se;\\n  }\\n  return a.f < b.f;\\n}\\n\\n\\nll solve(int h, int w, ve<pair<int, int>>& a) {\\n  init();\\n  ll total = C(h + w - 2, h - 1);\\n  ll res = 0;\\n  sort(a.begin(), a.end(), com);\\n  ve<ll> dp(a.size());\\n  FOR(i, 0, a.size()) {\\n    int r1 = a[i].f, c1 = a[i].se;\\n    ll ways = C(r1 + c1 - 2, r1 - 1);//(1, 1) => (r1, c1)\\n    for(int j =  i - 1; j >= 0; j--) {\\n      int r2 = a[j].f, c2 = a[j].se;\\n      if(r2 <= r1 && c2 <= c1) {//j -> i\\n        ll x = C(r1 + c1 - r2 - c2, r1 - r2);\\n        ll y = dp[j];\\n        x *= y;\\n        x %= mod;\\n        ways -= x;\\n        ways += mod;\\n        ways %= mod;\\n      }\\n    }\\n    dp[i] = ways;\\n    ll x = C(h - r1 + w - c1, h - r1);\\n    ll y = ways;\\n    ll add = x * y;\\n    add %= mod;\\n    res += add;\\n    res %= mod;\\n  }\\n  return (total - res + mod) % mod;\\n}\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(ve<ve<int>>& a) {\\n        int h = a.size(), w = a[0].size();\\n        ve<pair<int, int>> b;\\n        FOR(i, 0, h) {\\n            FOR(j, 0, w) {\\n                if(a[i][j] == 1) {\\n                    b.pb({i + 1, j + 1});\\n                }\\n            }\\n        }\\n        ll res = solve(h, w, b);\\n        return (int)(res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = long long;\\n#define pb push_back\\n#define f first\\n#define se second\\n#define ve vector\\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\\n\\n\\n\\nint MOD = 998244353;\\nll mod = 2000000033ll;\\nint INF = INT_MAX;\\n\\nll fact[10000 + 50];\\nll inv[10000 + 50];\\n\\nll C(int n, int r) {\\n    return ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\\n}\\n\\nll modInverse(ll a, ll m){\\n    ll m0 = m;\\n    ll y = 0, x = 1;\\n\\n    if (m == 1)\\n        return 0;\\n    \\n    while (a > 1) {\\n        ll q = a / m;\\n        ll t = m;\\n        m = a % m;\\n        a = t;\\n        t = y;\\n        y = x - q * y;\\n        x = t;\\n    }\\n    if (x < 0)\\n        x += m0;\\n    return x;\\n}\\n\\nvoid init() {\\n  fact[0] = fact[1] = 1;\\n  FOR(i, 2, 10000 + 10) {\\n    fact[i] = fact[i - 1] * i;\\n    fact[i] %= mod;\\n  }\\n\\n  inv[0] = inv[1] = 1;\\n  FOR(i, 2, 10000 + 10) {\\n      inv[i] = modInverse(i,mod) * inv[i-1];\\n      inv[i] %=mod;\\n  }\\n}\\n\\nbool com(pair<int, int>& a, pair<int, int>& b) {\\n  if(a.f == b.f) {\\n    return a.se < b.se;\\n  }\\n  return a.f < b.f;\\n}\\n\\n\\nll solve(int h, int w, ve<pair<int, int>>& a) {\\n  init();\\n  ll total = C(h + w - 2, h - 1);\\n  ll res = 0;\\n  sort(a.begin(), a.end(), com);\\n  ve<ll> dp(a.size());\\n  FOR(i, 0, a.size()) {\\n    int r1 = a[i].f, c1 = a[i].se;\\n    ll ways = C(r1 + c1 - 2, r1 - 1);//(1, 1) => (r1, c1)\\n    for(int j =  i - 1; j >= 0; j--) {\\n      int r2 = a[j].f, c2 = a[j].se;\\n      if(r2 <= r1 && c2 <= c1) {//j -> i\\n        ll x = C(r1 + c1 - r2 - c2, r1 - r2);\\n        ll y = dp[j];\\n        x *= y;\\n        x %= mod;\\n        ways -= x;\\n        ways += mod;\\n        ways %= mod;\\n      }\\n    }\\n    dp[i] = ways;\\n    ll x = C(h - r1 + w - c1, h - r1);\\n    ll y = ways;\\n    ll add = x * y;\\n    add %= mod;\\n    res += add;\\n    res %= mod;\\n  }\\n  return (total - res + mod) % mod;\\n}\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(ve<ve<int>>& a) {\\n        int h = a.size(), w = a[0].size();\\n        ve<pair<int, int>> b;\\n        FOR(i, 0, h) {\\n            FOR(j, 0, w) {\\n                if(a[i][j] == 1) {\\n                    b.pb({i + 1, j + 1});\\n                }\\n            }\\n        }\\n        ll res = solve(h, w, b);\\n        return (int)(res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398160,
                "title": "simple-c-faster-than-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0]==1){\\n            return 0;\\n        }\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        int** dp = new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        dp[0][0]=1;\\n        //filling m-2 rows and n-2 colm\\n        for(int i=0;i<m-1;i++){\\n            for(int j=0;j<n-1;j++){\\n                int val=dp[i][j];\\n                if(obstacleGrid[i+1][j]!=1)dp[i+1][j]+=val;\\n                if(obstacleGrid[i][j+1]!=1)dp[i][j+1]+=val;\\n            }\\n        }\\n        //filling last row\\n        for(int j=0;j<n-1;j++){\\n            int val=dp[m-1][j];\\n            if(obstacleGrid[m-1][j+1]!=1)dp[m-1][j+1]+=val;\\n        }\\n        //filling last column\\n        for(int i=0;i<m-1;i++){\\n            int val=dp[i][n-1];\\n            if(obstacleGrid[i+1][n-1]!=1)dp[i+1][n-1]+=val;\\n        }\\n        return dp[m-1][n-1];\\n        \\n        \\n        \\n        \\n        \\n      \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0]==1){\\n            return 0;\\n        }\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        int** dp = new int*[m];\\n        for(int i=0;i<m;i++){\\n            dp[i] = new int[n];\\n            for(int j=0;j<n;j++){\\n                dp[i][j] = 0;\\n            }\\n        }\\n        dp[0][0]=1;\\n        //filling m-2 rows and n-2 colm\\n        for(int i=0;i<m-1;i++){\\n            for(int j=0;j<n-1;j++){\\n                int val=dp[i][j];\\n                if(obstacleGrid[i+1][j]!=1)dp[i+1][j]+=val;\\n                if(obstacleGrid[i][j+1]!=1)dp[i][j+1]+=val;\\n            }\\n        }\\n        //filling last row\\n        for(int j=0;j<n-1;j++){\\n            int val=dp[m-1][j];\\n            if(obstacleGrid[m-1][j+1]!=1)dp[m-1][j+1]+=val;\\n        }\\n        //filling last column\\n        for(int i=0;i<m-1;i++){\\n            int val=dp[i][n-1];\\n            if(obstacleGrid[i+1][n-1]!=1)dp[i+1][n-1]+=val;\\n        }\\n        return dp[m-1][n-1];\\n        \\n        \\n        \\n        \\n        \\n      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879300,
                "title": "java-100-fast-dp-solution",
                "content": "```\\nclass Solution \\n{\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) \\n    {\\n        int m=obstacleGrid.length;\\n        int n=obstacleGrid[0].length;\\n        \\n        int dp[][]=new int[m][n];\\n        \\n        if(obstacleGrid[0][0]==1)\\n        {\\n            return 0;\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            if(obstacleGrid[i][0]==0)\\n            {\\n                dp[i][0]=1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(obstacleGrid[0][i]==0)\\n            {\\n                dp[0][i]=1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(obstacleGrid[i][j]==1)\\n                {\\n                    dp[i][j]=0;\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```\\n\\n\\n\\n//  1 1 1 1 1 X 0 0\\n//  1 2 3 4\\n//\\n//\\n//\\n//",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) \\n    {\\n        int m=obstacleGrid.length;\\n        int n=obstacleGrid[0].length;\\n        \\n        int dp[][]=new int[m][n];\\n        \\n        if(obstacleGrid[0][0]==1)\\n        {\\n            return 0;\\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            if(obstacleGrid[i][0]==0)\\n            {\\n                dp[i][0]=1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(obstacleGrid[0][i]==0)\\n            {\\n                dp[0][i]=1;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(obstacleGrid[i][j]==1)\\n                {\\n                    dp[i][j]=0;\\n                }\\n                else\\n                {\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23364,
                "title": "easy-to-understand-java-solution",
                "content": "    public class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = 0;\\n                }\\n                else {\\n                    if(i == 0 && j == 0) obstacleGrid[i][j] = 1;\\n                    else if(i == 0 && j > 0) obstacleGrid[i][j] = obstacleGrid[i][j-1];\\n                    else if(i > 0 && j == 0) obstacleGrid[i][j] = obstacleGrid[i-1][j];\\n                    else obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1];\\n                }\\n            }\\n        }\\n        return obstacleGrid[m-1][n-1];\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 23381,
                "title": "java-dp-solutions-o-n-n-o-n-space",
                "content": "  \\n\\n       \\n    // O(n*n) space\\n    public int uniquePathsWithObstacles1(int[][] obstacleGrid) {\\n        int row = obstacleGrid.length, col = obstacleGrid[0].length;\\n        int dp[][] = new int[row][col];\\n        dp[0][0] = 1-obstacleGrid[0][0];\\n        for (int i=1; i<row; i++)\\n            dp[i][0] = dp[i-1][0]*(1-obstacleGrid[i][0]);\\n        for (int j=1; j<col; j++)\\n            dp[0][j] = dp[0][j-1]*(1-obstacleGrid[0][j]);\\n        for (int i=1; i<row; i++) \\n            for (int j=1; j<col; j++)\\n                dp[i][j] = (dp[i-1][j]+dp[i][j-1])*(1-obstacleGrid[i][j]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int row = obstacleGrid.length, col = obstacleGrid[0].length;\\n        int dp[] = new int[col];\\n        dp[0] = 1-obstacleGrid[0][0];\\n        for (int j=1; j<col; j++)\\n            dp[j] = dp[j-1]*(1-obstacleGrid[0][j]);\\n        for (int i=1; i<row; i++) {\\n            dp[0] *= 1-obstacleGrid[i][0];\\n            for (int j=1; j<col; j++) \\n                dp[j] = (dp[j-1]+dp[j])*(1-obstacleGrid[i][j]);\\n        }\\n        return dp[col-1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "  \\n\\n       \\n    // O(n*n) space\\n    public int uniquePathsWithObstacles1(int[][] obstacleGrid) {\\n        int row = obstacleGrid.length, col = obstacleGrid[0].length;\\n        int dp[][] = new int[row][col];\\n        dp[0][0] = 1-obstacleGrid[0][0];\\n        for (int i=1; i<row; i++)\\n            dp[i][0] = dp[i-1][0]*(1-obstacleGrid[i][0]);\\n        for (int j=1; j<col; j++)\\n            dp[0][j] = dp[0][j-1]*(1-obstacleGrid[0][j]);\\n        for (int i=1; i<row; i++) \\n            for (int j=1; j<col; j++)\\n                dp[i][j] = (dp[i-1][j]+dp[i][j-1])*(1-obstacleGrid[i][j]);\\n        return dp[row-1][col-1];\\n    }\\n    \\n    // O(n) space\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int row = obstacleGrid.length, col = obstacleGrid[0].length;\\n        int dp[] = new int[col];\\n        dp[0] = 1-obstacleGrid[0][0];\\n        for (int j=1; j<col; j++)\\n            dp[j] = dp[j-1]*(1-obstacleGrid[0][j]);\\n        for (int i=1; i<row; i++) {\\n            dp[0] *= 1-obstacleGrid[i][0];\\n            for (int j=1; j<col; j++) \\n                dp[j] = (dp[j-1]+dp[j])*(1-obstacleGrid[i][j]);\\n        }\\n        return dp[col-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23348,
                "title": "i-saw-many-answers-are-using-2-d-vector-which-is-unnecessary-check-my-1-d-vector-solution",
                "content": "\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int width = obstacleGrid[0].size();\\n        vector<int> result(width, 0);\\n        result[0] = 1;\\n\\n        for (int i = 0; i <  obstacleGrid.size(); ++i) {\\n            for (int j = 0; j < width; ++j) {\\n                if (obstacleGrid[i][j] == 1)\\n                    result[j] = 0;\\n                else if (j > 0)\\n                    result[j] += result[j-1];\\n            }\\n        }\\n        return result[width-1];\\n    }",
                "solutionTags": [],
                "code": "\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int width = obstacleGrid[0].size();\\n        vector<int> result(width, 0);\\n        result[0] = 1;\\n\\n        for (int i = 0; i <  obstacleGrid.size(); ++i) {\\n            for (int j = 0; j < width; ++j) {\\n                if (obstacleGrid[i][j] == 1)\\n                    result[j] = 0;\\n                else if (j > 0)\\n                    result[j] += result[j-1];\\n            }\\n        }\\n        return result[width-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 23443,
                "title": "share-my-java-solution-o-m-n-time-complexity-no-extra-space",
                "content": "Obviously, this is a DP problem.\\n\\nLet F(i,j) denotes the paths from top left to cell (i,j).\\n\\n\\nIf cell (i,j) has an obstacle, then F(i,j) = 0.\\nelse \\n\\n\\nfor j>0, F(0,j) = F(0,j-1)\\n   \\n\\nfor i>0, F(i,0) = F(i-1,0)\\n    \\n\\nfor i>0&&j>0, F(i,j) = F(i-1,j)+F(i,j-1)\\n\\nWe can take advantage of the obstacle array without using extra space.         \\n\\n        if(obstacleGrid==null||obstacleGrid.length==0)\\n        \\treturn 0;\\n\\n        for(int i=0;i<obstacleGrid.length;i++)\\n        \\tfor(int j=0;j<obstacleGrid[0].length;j++)\\n        \\t{\\n        \\t\\tif(i==0)\\n        \\t\\t{\\n        \\t\\t\\tif(j==0)\\n        \\t\\t\\t\\tobstacleGrid[0][0] = 1 - obstacleGrid[0][0];\\n        \\t\\t\\telse\\n        \\t\\t\\t\\tobstacleGrid[0][j] = obstacleGrid[0][j]==1?0:obstacleGrid[0][j-1];\\n        \\t\\t}\\n        \\t\\telse \\n        \\t\\t{\\n        \\t\\t\\tif(j==0)\\n        \\t\\t\\t\\tobstacleGrid[i][0] = obstacleGrid[i][0]==1?0:obstacleGrid[i-1][0];\\n        \\t\\t\\telse \\n        \\t\\t\\t\\tobstacleGrid[i][j] = obstacleGrid[i][j]==1?0:(obstacleGrid[i-1][j]+obstacleGrid[i][j-1]);\\n\\t\\t\\t\\t}\\n        \\t}\\n        return obstacleGrid[obstacleGrid.length-1][obstacleGrid[0].length-1];",
                "solutionTags": [],
                "code": "Obviously, this is a DP problem.\\n\\nLet F(i,j) denotes the paths from top left to cell (i,j).\\n\\n\\nIf cell (i,j) has an obstacle, then F(i,j) = 0.\\nelse \\n\\n\\nfor j>0, F(0,j) = F(0,j-1)\\n   \\n\\nfor i>0, F(i,0) = F(i-1,0)\\n    \\n\\nfor i>0&&j>0, F(i,j) = F(i-1,j)+F(i,j-1)\\n\\nWe can take advantage of the obstacle array without using extra space.         \\n\\n        if(obstacleGrid==null||obstacleGrid.length==0)\\n        \\treturn 0;\\n\\n        for(int i=0;i<obstacleGrid.length;i++)\\n        \\tfor(int j=0;j<obstacleGrid[0].length;j++)\\n        \\t{\\n        \\t\\tif(i==0)\\n        \\t\\t{\\n        \\t\\t\\tif(j==0)\\n        \\t\\t\\t\\tobstacleGrid[0][0] = 1 - obstacleGrid[0][0];\\n        \\t\\t\\telse\\n        \\t\\t\\t\\tobstacleGrid[0][j] = obstacleGrid[0][j]==1?0:obstacleGrid[0][j-1];\\n        \\t\\t}\\n        \\t\\telse \\n        \\t\\t{\\n        \\t\\t\\tif(j==0)\\n        \\t\\t\\t\\tobstacleGrid[i][0] = obstacleGrid[i][0]==1?0:obstacleGrid[i-1][0];\\n        \\t\\t\\telse \\n        \\t\\t\\t\\tobstacleGrid[i][j] = obstacleGrid[i][j]==1?0:(obstacleGrid[i-1][j]+obstacleGrid[i][j-1]);\\n\\t\\t\\t\\t}\\n        \\t}\\n        return obstacleGrid[obstacleGrid.length-1][obstacleGrid[0].length-1];",
                "codeTag": "Unknown"
            },
            {
                "id": 23444,
                "title": "java-solution-modified-form-uniquepath-i",
                "content": "modified form uniquePath I;\\nset the upper and left boundary of the answer matrix to 1 until blocked;\\nset any blocks to 0\\n\\n\\n    public class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int width = obstacleGrid[0].length;\\n            int lines = obstacleGrid.length;\\n            int [][] answer = new int[lines][width];\\n            \\n           \\n            \\n            for(int j=0;j<width;j++){\\n                if(obstacleGrid[0][j]==1){if(lines==1) return 0; break;}\\n                else answer[0][j]=1;\\n            }\\n            \\n            for(int i=0;i<lines;i++){\\n                if(obstacleGrid[i][0]==1){if(width==1) return 0; break;}\\n                else answer[i][0]=1;\\n            }\\n            \\n            for(int i=1;i<lines;i++){\\n                for(int j=1;j<width;j++){\\n                    if(obstacleGrid[i][j]!=1){\\n                        answer[i][j]=answer[i-1][j]+answer[i][j-1];\\n                    }\\n                }\\n            }\\n            \\n            return answer[lines-1][width-1];\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int width = obstacleGrid[0].length;\\n            int lines = obstacleGrid.length;\\n            int [][] answer = new int[lines][width];\\n            \\n           \\n            \\n            for(int j=0;j<width;j++){\\n                if(obstacleGrid[0][j]==1){if(lines==1) return 0; break;}",
                "codeTag": "Java"
            },
            {
                "id": 3898076,
                "title": "easy-solution-python3-c-with-image-beats-r-m-96-77-78-09",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\\n            return 0\\n        \\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, m):\\n            dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i - 1][0]\\n        \\n        for j in range(1, n):\\n            dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j - 1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = 0 if obstacleGrid[i][j] == 1 else dp[i - 1][j] + dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\\n            return 0\\n        \\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, m):\\n            dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i - 1][0]\\n        \\n        for j in range(1, n):\\n            dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j - 1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = 0 if obstacleGrid[i][j] == 1 else dp[i - 1][j] + dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "C#"
                ],
                "code": "```python []\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\\n            return 0\\n        \\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, m):\\n            dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i - 1][0]\\n        \\n        for j in range(1, n):\\n            dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j - 1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = 0 if obstacleGrid[i][j] == 1 else dp[i - 1][j] + dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1:\\n            return 0\\n        \\n        dp = [[0] * n for _ in range(m)]\\n        dp[0][0] = 1\\n        \\n        for i in range(1, m):\\n            dp[i][0] = 0 if obstacleGrid[i][0] == 1 else dp[i - 1][0]\\n        \\n        for j in range(1, n):\\n            dp[0][j] = 0 if obstacleGrid[0][j] == 1 else dp[0][j - 1]\\n        \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                dp[i][j] = 0 if obstacleGrid[i][j] == 1 else dp[i - 1][j] + dp[i][j - 1]\\n        \\n        return dp[m - 1][n - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328251,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^S)$$ --> S = m * n\\n\\n- Space complexity:\\n$$O(m + n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& obstacleGrid) {\\n        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1)\\n            return 0;\\n        if (row == 0 && col == 0)\\n            return 1;\\n        if (row < 0 || col < 0)\\n            return 0;     \\n        int left = solve(row, col-1, obstacleGrid);  \\n        int up = solve(row-1, col, obstacleGrid);  \\n        return left + up;     \\n    }    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        return solve(m-1, n-1, obstacleGrid);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp) {\\n        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1)\\n            return 0;\\n        if (row == 0 && col == 0)\\n            return 1;\\n        if (row < 0 || col < 0)\\n            return 0;   \\n        if (dp[row][col] != -1)\\n            return dp[row][col];      \\n        int left = solve(row, col-1, obstacleGrid, dp);  \\n        int up = solve(row-1, col, obstacleGrid, dp);  \\n        return dp[row][col] = left + up;     \\n    }    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, obstacleGrid, dp);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$\\n\\n# Code\\n```\\nclass Solution {    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                int left = 0, up = 0;\\n                if (j > 0)\\n                    left = dp[i][j-1];\\n                if (i > 0)\\n                    up = dp[i-1][j];    \\n                dp[i][j] = left + up;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    cur[j] = 0;\\n                    continue;\\n                }\\n                if (i == 0 && j == 0) {\\n                    cur[j] = 1;\\n                    continue;\\n                }\\n                int left = 0, up = 0;\\n                if (j > 0)\\n                    left = cur[j-1];\\n                if (i > 0)\\n                    up = prev[j];    \\n                cur[j] = left + up;\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& obstacleGrid) {\\n        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1)\\n            return 0;\\n        if (row == 0 && col == 0)\\n            return 1;\\n        if (row < 0 || col < 0)\\n            return 0;     \\n        int left = solve(row, col-1, obstacleGrid);  \\n        int up = solve(row-1, col, obstacleGrid);  \\n        return left + up;     \\n    }    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        return solve(m-1, n-1, obstacleGrid);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int row, int col, vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp) {\\n        if (row >= 0 && col >= 0 && obstacleGrid[row][col] == 1)\\n            return 0;\\n        if (row == 0 && col == 0)\\n            return 1;\\n        if (row < 0 || col < 0)\\n            return 0;   \\n        if (dp[row][col] != -1)\\n            return dp[row][col];      \\n        int left = solve(row, col-1, obstacleGrid, dp);  \\n        int up = solve(row-1, col, obstacleGrid, dp);  \\n        return dp[row][col] = left + up;     \\n    }    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return solve(m-1, n-1, obstacleGrid, dp);\\n    }\\n};\\n```\n```\\nclass Solution {    \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n                if (i == 0 && j == 0) {\\n                    dp[i][j] = 1;\\n                    continue;\\n                }\\n                int left = 0, up = 0;\\n                if (j > 0)\\n                    left = dp[i][j-1];\\n                if (i > 0)\\n                    up = dp[i-1][j];    \\n                dp[i][j] = left + up;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution { \\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector <int> prev(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            vector <int> cur(n, 0);\\n            for (int j = 0; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    cur[j] = 0;\\n                    continue;\\n                }\\n                if (i == 0 && j == 0) {\\n                    cur[j] = 1;\\n                    continue;\\n                }\\n                int left = 0, up = 0;\\n                if (j > 0)\\n                    left = cur[j-1];\\n                if (i > 0)\\n                    up = prev[j];    \\n                cur[j] = left + up;\\n            }\\n            prev = cur;\\n        }\\n        return prev[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163373,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] OG) {\\n        if (OG[0][0] == 1) return 0;\\n        int m = OG.length, n = OG[0].length;\\n        int[][] dp = new int[m][n];\\n        dp[0][0] = 1;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (OG[i][j] == 1 || (i == 0 && j == 0)) continue;\\n                else dp[i][j] = (i > 0 ? dp[i-1][j] : 0) + (j > 0 ? dp[i][j-1] : 0);\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674229,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    # top down dp\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        # memo for dp\\n        memo = [[None for _ in range(n)] for __ in range(m)]\\n        \\n        # edge case\\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        # we want to fill first row and column with 0 if we find an obstacle from that point to the end of the row or column. This way we can return 0 to indicate that a path is not possible because an obstacle blocks it\\n        row_fill = 1\\n        col_fill = 1\\n        for r in range(m):\\n            if obstacleGrid[r][0] == 1:\\n                row_fill = 0\\n            obstacleGrid[r][0] = row_fill\\n            \\n        for c in range(1, n):\\n            if obstacleGrid[0][c] == 1:\\n                col_fill = 0\\n            obstacleGrid[0][c] = col_fill\\n\\n        # recursive function for top down dp\\n        def dp(r, c):\\n            # if we first row or col we return 1 if there is no blocking path\\n            if r == 0 or c == 0:\\n                return obstacleGrid[r][c]\\n            # if we reach an obstacle there is no possible path\\n            elif obstacleGrid[r][c] == 1:\\n                return 0\\n            # update memo if not cached\\n            if memo[r][c] is None:\\n                memo[r][c] = dp(r, c-1) + dp(r-1, c)\\n            return memo[r][c]\\n    \\n        return dp(m - 1, n - 1)\\n```\\n\\nTime: O(m * n) we only need to visit each matrix entry once\\nSpace: O(m * n) for memo array",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    # top down dp\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        # memo for dp\\n        memo = [[None for _ in range(n)] for __ in range(m)]\\n        \\n        # edge case\\n        if obstacleGrid[0][0] == 1:\\n            return 0\\n        \\n        # we want to fill first row and column with 0 if we find an obstacle from that point to the end of the row or column. This way we can return 0 to indicate that a path is not possible because an obstacle blocks it\\n        row_fill = 1\\n        col_fill = 1\\n        for r in range(m):\\n            if obstacleGrid[r][0] == 1:\\n                row_fill = 0\\n            obstacleGrid[r][0] = row_fill\\n            \\n        for c in range(1, n):\\n            if obstacleGrid[0][c] == 1:\\n                col_fill = 0\\n            obstacleGrid[0][c] = col_fill\\n\\n        # recursive function for top down dp\\n        def dp(r, c):\\n            # if we first row or col we return 1 if there is no blocking path\\n            if r == 0 or c == 0:\\n                return obstacleGrid[r][c]\\n            # if we reach an obstacle there is no possible path\\n            elif obstacleGrid[r][c] == 1:\\n                return 0\\n            # update memo if not cached\\n            if memo[r][c] is None:\\n                memo[r][c] = dp(r, c-1) + dp(r-1, c)\\n            return memo[r][c]\\n    \\n        return dp(m - 1, n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058561,
                "title": "simple-recursion-memoization-solution-ii-dp-ii-faster-than-100-00",
                "content": "Same Approach Like [Unique Paths](https://leetcode.com/problems/unique-paths/)\\n[Solution](https://leetcode.com/problems/unique-paths/discuss/2058560/Simple-Recursion-%2B-Memoization-Solution-II-DP-II-Faster-than-100.00)\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<vector<int>>& obstacleGrid,int x,int y,int m,int n)\\n    {\\n        if(x>=m || y>=n || obstacleGrid[x][y]==1)\\n            return 0;\\n        if(x==m-1 && y==n-1)\\n            return 1;\\n        \\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        else\\n            dp[x][y] = solve(obstacleGrid,x+1,y,m,n)+solve(obstacleGrid,x,y+1,m,n);\\n        return dp[x][y];\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacleGrid,0,0,m,n);\\n    }\\n};\\n```\\n\\n**Please Upvote** if you liked the approach.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<vector<int>>& obstacleGrid,int x,int y,int m,int n)\\n    {\\n        if(x>=m || y>=n || obstacleGrid[x][y]==1)\\n            return 0;\\n        if(x==m-1 && y==n-1)\\n            return 1;\\n        \\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        else\\n            dp[x][y] = solve(obstacleGrid,x+1,y,m,n)+solve(obstacleGrid,x,y+1,m,n);\\n        return dp[x][y];\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacleGrid,0,0,m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057813,
                "title": "c-straight-forward-dp-solution",
                "content": "```\\nclass Solution {\\n    \\n    int row;\\n    int col;\\n    \\npublic:\\n    int dfs(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        \\n        //base cases\\n        if(i < 0 || j < 0\\n          || i >= row\\n          || j >= col)\\n            return 0;\\n        \\n        if(grid[i][j]){\\n            dp[i][j] = 0;\\n            return dp[i][j];\\n        }\\n        \\n        if(i == row - 1 && j == col - 1)\\n            return 1;\\n        \\n        if(dp[i][j])\\n            return dp[i][j];\\n        \\n        dp[i][j] = dfs(grid, i + 1, j, dp) + dfs(grid, i, j + 1, dp);\\n        \\n        return dp[i][j];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        row = obstacleGrid.size();\\n        col = obstacleGrid[0].size();\\n        \\n        vector<vector<int>> dp(row, vector<int>(col, 0));\\n        \\n        return dfs(obstacleGrid, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int row;\\n    int col;\\n    \\npublic:\\n    int dfs(vector<vector<int>>& grid, int i, int j, vector<vector<int>>& dp){\\n        \\n        //base cases\\n        if(i < 0 || j < 0\\n          || i >= row\\n          || j >= col)\\n            return 0;\\n        \\n        if(grid[i][j]){\\n            dp[i][j] = 0;\\n            return dp[i][j];\\n        }\\n        \\n        if(i == row - 1 && j == col - 1)\\n            return 1;\\n        \\n        if(dp[i][j])\\n            return dp[i][j];\\n        \\n        dp[i][j] = dfs(grid, i + 1, j, dp) + dfs(grid, i, j + 1, dp);\\n        \\n        return dp[i][j];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        row = obstacleGrid.size();\\n        col = obstacleGrid[0].size();\\n        \\n        vector<vector<int>> dp(row, vector<int>(col, 0));\\n        \\n        return dfs(obstacleGrid, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057478,
                "title": "dp-is-new-love",
                "content": "well simple we have two path to go we use dp array, we choose any one and add it them to the asnwere\\n```class Solution {\\npublic int fun(int x,int y, int[][]g,int [][]dp){\\n   \\n    if(x<0||y<0)return 0;\\n     if(dp[x][y]!=-1)return dp[x][y];\\n    if(g[x][y]==1)return dp[x][y]=0;\\n    if(x==0&&y==0)return dp[x][y]= 1;\\n    return dp[x][y]=fun(x-1,y,g,dp)+fun(x,y-1,g,dp);\\n}\\n    public int uniquePathsWithObstacles(int[][] g) {\\n        int dp[][]=new int[g.length][g[0].length];\\n        for(int i=0;i<g.length;i++){\\n            for(int j=0;j<g[0].length;j++)dp[i][j]=-1;\\n            \\n        }\\n        if(g[0][0]==1||g[g.length-1][g[0].length-1]==1)return 0;\\n        int a= fun(g.length-1,g[0].length-1,g,dp);\\n        return dp[g.length-1][g[0].length-1];\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```class Solution {\\npublic int fun(int x,int y, int[][]g,int [][]dp){\\n   \\n    if(x<0||y<0)return 0;\\n     if(dp[x][y]!=-1)return dp[x][y];\\n    if(g[x][y]==1)return dp[x][y]=0;\\n    if(x==0&&y==0)return dp[x][y]= 1;\\n    return dp[x][y]=fun(x-1,y,g,dp)+fun(x,y-1,g,dp);\\n}\\n    public int uniquePathsWithObstacles(int[][] g) {\\n        int dp[][]=new int[g.length][g[0].length];\\n        for(int i=0;i<g.length;i++){\\n            for(int j=0;j<g[0].length;j++)dp[i][j]=-1;\\n            \\n        }\\n        if(g[0][0]==1||g[g.length-1][g[0].length-1]==1)return 0;\\n        int a= fun(g.length-1,g[0].length-1,g,dp);\\n        return dp[g.length-1][g[0].length-1];\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2056894,
                "title": "are-you-tired-of-getting-tle-using-recursive-solution-c-dp-solution-dlc-may20",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, -1));      //stores no of paths at each point\\n        \\n        //return no. of unique paths\\n        return helper(obstacleGrid, dp, 0, 0);\\n    }\\n    \\n    int helper(vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp, int i, int j){\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        if(i<0 || j<0 || i>=m || j>=n || obstacleGrid[i][j]==1) //out of boundary\\n             return 0;\\n        \\n        if(dp[i][j] != -1)      //if already have the valuem, use that to calc no of paths\\n            return dp[i][j];\\n        \\n        if(i==m-1 && j==n-1)    //if reached to correct pos, got 1 path\\n             return 1;\\n        \\n        //Now we need to calc the no of unique paths, in right and bottom direction\\n        return dp[i][j] = helper(obstacleGrid, dp, i, j+1) + helper(obstacleGrid, dp, i+1, j);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        vector<vector<int>> dp(m, vector<int>(n, -1));      //stores no of paths at each point\\n        \\n        //return no. of unique paths\\n        return helper(obstacleGrid, dp, 0, 0);\\n    }\\n    \\n    int helper(vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp, int i, int j){\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        if(i<0 || j<0 || i>=m || j>=n || obstacleGrid[i][j]==1) //out of boundary\\n             return 0;\\n        \\n        if(dp[i][j] != -1)      //if already have the valuem, use that to calc no of paths\\n            return dp[i][j];\\n        \\n        if(i==m-1 && j==n-1)    //if reached to correct pos, got 1 path\\n             return 1;\\n        \\n        //Now we need to calc the no of unique paths, in right and bottom direction\\n        return dp[i][j] = helper(obstacleGrid, dp, i, j+1) + helper(obstacleGrid, dp, i+1, j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056591,
                "title": "concise-one-pass-in-place-solution-with-no-recursion",
                "content": "With `switch`:\\n```csharp\\npublic int UniquePathsWithObstacles(int[][] g)\\n{\\n\\tfor(int i = 0; i < g.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < g[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tg[i][j] = (g[i][j], i, j) switch\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t(1, _, _) => 0,\\n\\t\\t\\t\\t\\t(_, 0, 0) => 1,\\n\\t\\t\\t\\t\\t(_, 0, _) => g[i][j - 1] * 1,\\n\\t\\t\\t\\t\\t(_, _, 0) => g[i - 1][j] * 1,\\n\\t\\t\\t\\t\\t_         => g[i - 1][j] + g[i][j - 1]\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}\\n\\treturn g[^1][^1];\\n}\\n```\\n\\nSame, rewritten with a classic `if-else`:\\n```csharp\\npublic int UniquePathsWithObstacles(int[][] g)\\n{\\n\\tfor(int i = 0; i < g.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < g[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(g[i][j] == 1)          g[i][j] = 0;\\n\\t\\t\\telse if(i == 0 && j == 0) g[i][j] = 1;\\n\\t\\t\\telse if(i == 0)           g[i][j] = g[i][j - 1] * 1;\\n\\t\\t\\telse if(j == 0)           g[i][j] = g[i - 1][j] * 1;\\n\\t\\t\\telse                      g[i][j] = g[i - 1][j] + g[i][j - 1];\\n\\t\\t}\\n\\t}\\n    return g[^1][^1];\\n}\\n```\\n\\nWhich version do you find more readable/maintainable?",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic int UniquePathsWithObstacles(int[][] g)\\n{\\n\\tfor(int i = 0; i < g.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < g[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tg[i][j] = (g[i][j], i, j) switch\\n\\t\\t\\t{\\n\\t\\t\\t\\t\\t(1, _, _) => 0,\\n\\t\\t\\t\\t\\t(_, 0, 0) => 1,\\n\\t\\t\\t\\t\\t(_, 0, _) => g[i][j - 1] * 1,\\n\\t\\t\\t\\t\\t(_, _, 0) => g[i - 1][j] * 1,\\n\\t\\t\\t\\t\\t_         => g[i - 1][j] + g[i][j - 1]\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}\\n\\treturn g[^1][^1];\\n}\\n```\n```csharp\\npublic int UniquePathsWithObstacles(int[][] g)\\n{\\n\\tfor(int i = 0; i < g.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < g[0].Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(g[i][j] == 1)          g[i][j] = 0;\\n\\t\\t\\telse if(i == 0 && j == 0) g[i][j] = 1;\\n\\t\\t\\telse if(i == 0)           g[i][j] = g[i][j - 1] * 1;\\n\\t\\t\\telse if(j == 0)           g[i][j] = g[i - 1][j] * 1;\\n\\t\\t\\telse                      g[i][j] = g[i - 1][j] + g[i][j - 1];\\n\\t\\t}\\n\\t}\\n    return g[^1][^1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2055463,
                "title": "java-easy-solution-o-m-n-time-and-o-1-space-with-comments-0-ms",
                "content": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int R = obstacleGrid.length;\\n        int C = obstacleGrid[0].length;\\n\\n        // If the starting cell has an obstacle, then simply return as there would be\\n        // no paths to the destination.\\n        if (obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        // Number of ways of reaching the starting cell = 1.\\n        obstacleGrid[0][0] = 1;\\n\\n        // Filling the values for the first column\\n        for (int i = 1; i < R; i++) {\\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;\\n        }\\n\\n        // Filling the values for the first row\\n        for (int i = 1; i < C; i++) {\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;\\n        }\\n\\n        // Starting from cell(1,1) fill up the values\\n        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\\n        // i.e. From above and left.\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                if (obstacleGrid[i][j] == 0) {\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n                } else {\\n                    obstacleGrid[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        // Return value stored in rightmost bottommost cell. That is the destination.\\n        return obstacleGrid[R - 1][C - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int R = obstacleGrid.length;\\n        int C = obstacleGrid[0].length;\\n\\n        // If the starting cell has an obstacle, then simply return as there would be\\n        // no paths to the destination.\\n        if (obstacleGrid[0][0] == 1) {\\n            return 0;\\n        }\\n\\n        // Number of ways of reaching the starting cell = 1.\\n        obstacleGrid[0][0] = 1;\\n\\n        // Filling the values for the first column\\n        for (int i = 1; i < R; i++) {\\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;\\n        }\\n\\n        // Filling the values for the first row\\n        for (int i = 1; i < C; i++) {\\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;\\n        }\\n\\n        // Starting from cell(1,1) fill up the values\\n        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\\n        // i.e. From above and left.\\n        for (int i = 1; i < R; i++) {\\n            for (int j = 1; j < C; j++) {\\n                if (obstacleGrid[i][j] == 0) {\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n                } else {\\n                    obstacleGrid[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        // Return value stored in rightmost bottommost cell. That is the destination.\\n        return obstacleGrid[R - 1][C - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885227,
                "title": "63-unique-paths-ii-100-faster-very-easy-to-understand",
                "content": "\\n### The idea is same as Unique Paths but with checking obstacles...\\n1. First we have to **make an 2d array** .\\n2. then filling the **1st row boundry blocks with checking obstacles** if found then **whole row is 0** ;because there is noy way to reach at that position.\\n3. simlarly for **1st column boundry side blocks** .\\n4. and last filling all the middle elements same checking **obstacles** if **found put 0**\\n \\nThis is the idea if you helpful then please **!!upvote!!**\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        int arr[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            if(obstacleGrid[i][0]==1)\\n                {\\n                    arr[i][0]=0;\\n                    for(int j=i+1;j<m;j++)\\n                    {\\n                        arr[j][0]=0;\\n                    }\\n                break;\\n                }\\n            else\\n            {\\n                    arr[i][0]=1;\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n        {\\n            if(obstacleGrid[0][i]==1)\\n                {\\n                    arr[0][i]=0;\\n                 for(int j=i+1;j<n;j++)\\n                    {\\n                        arr[0][j]=0;\\n                    }\\n                    break;\\n                }\\n            else\\n            {\\n                    arr[0][i]=1;\\n            }\\n        }\\n         for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(obstacleGrid[i][j]==1)\\n                {\\n                    arr[i][j]=0;\\n                }\\n                \\n                else\\n                {\\n                    arr[i][j]=arr[i-1][j]+arr[i][j-1];\\n                }  \\n            }\\n        }\\n        return arr[m-1][n-1];\\n    }\\n};\\n```\\n//------------//---------//----------//-------------//-------------//----------//---------//-------------//----\\n```\\nif ( if you understand )\\n     {\\n          Upvote (this post);\\n     }\\nelse if (just want to know solution)\\n     {\\n    ignore(post);\\n     }\\nelse\\n    {\\n  UPVOTE\\n   }\\n   ```\\n  !! Thanks !!\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        int arr[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            if(obstacleGrid[i][0]==1)\\n                {\\n                    arr[i][0]=0;\\n                    for(int j=i+1;j<m;j++)\\n                    {\\n                        arr[j][0]=0;\\n                    }\\n                break;\\n                }\\n            else\\n            {\\n                    arr[i][0]=1;\\n            }\\n        }\\n         for(int i=0;i<n;i++)\\n        {\\n            if(obstacleGrid[0][i]==1)\\n                {\\n                    arr[0][i]=0;\\n                 for(int j=i+1;j<n;j++)\\n                    {\\n                        arr[0][j]=0;\\n                    }\\n                    break;\\n                }\\n            else\\n            {\\n                    arr[0][i]=1;\\n            }\\n        }\\n         for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(obstacleGrid[i][j]==1)\\n                {\\n                    arr[i][j]=0;\\n                }\\n                \\n                else\\n                {\\n                    arr[i][j]=arr[i-1][j]+arr[i][j-1];\\n                }  \\n            }\\n        }\\n        return arr[m-1][n-1];\\n    }\\n};\\n```\n```\\nif ( if you understand )\\n     {\\n          Upvote (this post);\\n     }\\nelse if (just want to know solution)\\n     {\\n    ignore(post);\\n     }\\nelse\\n    {\\n  UPVOTE\\n   }\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1766264,
                "title": "c-4-solutions-recursive-memoization-tabulation-super-optimised",
                "content": "**1. Recursive**\\n```\\nint path(int row, int col, vector<vector<int>>& obstacleGrid) {\\n    if(row == 0 && col == 0)\\n        return 1;\\n    if(row < 0 || col < 0)\\n        return 0;\\n    if(obstacleGrid[row][col] == 1)\\n        return 0;\\n    int left = path(row, col - 1, obstacleGrid);\\n    int up = path(row - 1, col, obstacleGrid);\\n    return left + up;\\n}\\n\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    return path(row - 1, col - 1, obstacleGrid);\\n}\\n```\\n\\n**2. Memoization**\\n```\\nint path(int row, int col, vector<vector<int>>& obstacleGrid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0)\\n        return 1;\\n    if(row < 0 || col < 0)\\n        return 0;\\n    if(obstacleGrid[row][col] == 1)\\n        return 0;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = path(row, col - 1, obstacleGrid, dp);\\n    int up = path(row - 1, col, obstacleGrid, dp);\\n    return dp[row][col] = left + up;\\n}\\n\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return path(row - 1, col - 1, obstacleGrid, dp);\\n}\\n```\\n\\n**3. Tabulation**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = 1;\\n            else if(obstacleGrid[i][j] == 1) dp[i][j] = 0;\\n            else {\\n                int left = 0, up = 0;\\n                if(i > 0) up = dp[i - 1][j];\\n                if(j > 0) left = dp[i][j - 1];\\n                dp[i][j] = left + up;\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```\\n\\n**4. Tabulation + More Space Optimised**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<int> prevRow(col, 0);\\n    \\n    for(int i = 0; i < row; i++) {\\n        vector<int> temp(col, 0);\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) temp[j] = 1;\\n            else if(obstacleGrid[i][j] == 1) temp[j] = 0;\\n            else {\\n                int left = 0, up = 0;\\n                if(i > 0) up = prevRow[j];\\n                if(j > 0) left = temp[j - 1];\\n                temp[j] = left + up;\\n            }\\n        }\\n        prevRow = temp;\\n    }\\n    return prevRow[col - 1];\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint path(int row, int col, vector<vector<int>>& obstacleGrid) {\\n    if(row == 0 && col == 0)\\n        return 1;\\n    if(row < 0 || col < 0)\\n        return 0;\\n    if(obstacleGrid[row][col] == 1)\\n        return 0;\\n    int left = path(row, col - 1, obstacleGrid);\\n    int up = path(row - 1, col, obstacleGrid);\\n    return left + up;\\n}\\n\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    return path(row - 1, col - 1, obstacleGrid);\\n}\\n```\n```\\nint path(int row, int col, vector<vector<int>>& obstacleGrid, vector<vector<int>> &dp) {\\n    if(row == 0 && col == 0)\\n        return 1;\\n    if(row < 0 || col < 0)\\n        return 0;\\n    if(obstacleGrid[row][col] == 1)\\n        return 0;\\n    if(dp[row][col] != -1)\\n        return dp[row][col];\\n    \\n    int left = path(row, col - 1, obstacleGrid, dp);\\n    int up = path(row - 1, col, obstacleGrid, dp);\\n    return dp[row][col] = left + up;\\n}\\n\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    return path(row - 1, col - 1, obstacleGrid, dp);\\n}\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<vector<int>> dp(row, vector<int> (col, -1));\\n    \\n    for(int i = 0; i < row; i++) {\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) dp[i][j] = 1;\\n            else if(obstacleGrid[i][j] == 1) dp[i][j] = 0;\\n            else {\\n                int left = 0, up = 0;\\n                if(i > 0) up = dp[i - 1][j];\\n                if(j > 0) left = dp[i][j - 1];\\n                dp[i][j] = left + up;\\n            }\\n        }\\n    }\\n    return dp[row - 1][col - 1];\\n}\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n    if(obstacleGrid[0][0] == 1) return 0;\\n    \\n    int row = obstacleGrid.size();\\n    int col = obstacleGrid[0].size();\\n    vector<int> prevRow(col, 0);\\n    \\n    for(int i = 0; i < row; i++) {\\n        vector<int> temp(col, 0);\\n        for(int j = 0; j < col; j++) {\\n            if(i == 0 && j == 0) temp[j] = 1;\\n            else if(obstacleGrid[i][j] == 1) temp[j] = 0;\\n            else {\\n                int left = 0, up = 0;\\n                if(i > 0) up = prevRow[j];\\n                if(j > 0) left = temp[j - 1];\\n                temp[j] = left + up;\\n            }\\n        }\\n        prevRow = temp;\\n    }\\n    return prevRow[col - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444230,
                "title": "c-solution-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        //filling 0th row\\n        for(int i = 0; i < n; i++){\\n            if(obstacleGrid[0][i] == 1) break;\\n            dp[0][i] = 1;\\n        }\\n        \\n        //filling 0th column\\n         for(int i = 0; i < m; i++){\\n            if(obstacleGrid[i][0] == 1) break;\\n            dp[i][0] = 1;\\n        }\\n        \\n        //filling rest of the dp array\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++){\\n                if(obstacleGrid[i][j] == 1) continue;\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>>dp;\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        m = size(obstacleGrid), n = size(obstacleGrid[0]);\\n        dp.resize(m, vector<int>(n));\\n        return helper(obstacleGrid, 0, 0);\\n    }\\n    int helper(vector<vector<int>>& grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= m || j >= n) return 0;\\n        if( grid[i][j]) return dp[i][j] = 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = helper(grid, i, j+1) + helper(grid, i+1, j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>>dp(m, vector<int>(n, 0));\\n        \\n        //filling 0th row\\n        for(int i = 0; i < n; i++){\\n            if(obstacleGrid[0][i] == 1) break;\\n            dp[0][i] = 1;\\n        }\\n        \\n        //filling 0th column\\n         for(int i = 0; i < m; i++){\\n            if(obstacleGrid[i][0] == 1) break;\\n            dp[i][0] = 1;\\n        }\\n        \\n        //filling rest of the dp array\\n        for(int i = 1; i < m; i++)\\n            for(int j = 1; j < n; j++){\\n                if(obstacleGrid[i][j] == 1) continue;\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        return dp[m-1][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>>dp;\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        m = size(obstacleGrid), n = size(obstacleGrid[0]);\\n        dp.resize(m, vector<int>(n));\\n        return helper(obstacleGrid, 0, 0);\\n    }\\n    int helper(vector<vector<int>>& grid, int i, int j){\\n        if(i < 0 || j < 0 || i >= m || j >= n) return 0;\\n        if( grid[i][j]) return dp[i][j] = 0;\\n        if(i == m-1 && j == n-1) return 1;\\n        if(dp[i][j]) return dp[i][j];\\n        return dp[i][j] = helper(grid, i, j+1) + helper(grid, i+1, j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374932,
                "title": "simple-c-solution-using-two-different-approaches",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n//1st Approach\\n//This will give TLE\\n```\\n//DFS+Backtracking\\n    void dfs(int i,int j,int m,int n,int &cnt,vector<vector<int>> &vis,vector<vector<int>> obstacleGrid)\\n    {\\n        if(i>=m||j>=n)\\n            return ;\\n        if(obstacleGrid[i][j]==1||vis[i][j]==1)\\n            return;\\n        if(i==m-1&&j==n-1)\\n            cnt++;\\n        vis[i][j]=1;\\n        dfs(i+1,j,m,n,cnt,vis,obstacleGrid);\\n        dfs(i,j+1,m,n,cnt,vis,obstacleGrid);\\n        vis[i][j]=0;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int cnt=0;\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(obstacleGrid[0][0]==1||obstacleGrid[m-1][n-1]==1)\\n            return 0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        dfs(0,0,m,n,cnt,vis,obstacleGrid);\\n        return cnt;\\n        }\\n\\t\\t\\n\\t\\t//Recursive+Memoization\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp,vector<vector<int>> &obstacleGrid)\\n    {\\n        if(i>=m||j>=n||obstacleGrid[i][j])\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=solve(i+1,j,m,n,dp,obstacleGrid)+solve(i,j+1,m,n,dp,obstacleGrid);\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n     vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return solve(0,0,m,n,dp,obstacleGrid);\\n        }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//DFS+Backtracking\\n    void dfs(int i,int j,int m,int n,int &cnt,vector<vector<int>> &vis,vector<vector<int>> obstacleGrid)\\n    {\\n        if(i>=m||j>=n)\\n            return ;\\n        if(obstacleGrid[i][j]==1||vis[i][j]==1)\\n            return;\\n        if(i==m-1&&j==n-1)\\n            cnt++;\\n        vis[i][j]=1;\\n        dfs(i+1,j,m,n,cnt,vis,obstacleGrid);\\n        dfs(i,j+1,m,n,cnt,vis,obstacleGrid);\\n        vis[i][j]=0;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int cnt=0;\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        if(obstacleGrid[0][0]==1||obstacleGrid[m-1][n-1]==1)\\n            return 0;\\n        vector<vector<int>> vis(m,vector<int>(n,0));\\n        dfs(0,0,m,n,cnt,vis,obstacleGrid);\\n        return cnt;\\n        }\\n\\t\\t\\n\\t\\t//Recursive+Memoization\\n    int solve(int i,int j,int m,int n,vector<vector<int>> &dp,vector<vector<int>> &obstacleGrid)\\n    {\\n        if(i>=m||j>=n||obstacleGrid[i][j])\\n            return 0;\\n        if(i==m-1&&j==n-1)\\n            return 1;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        return dp[i][j]=solve(i+1,j,m,n,dp,obstacleGrid)+solve(i,j+1,m,n,dp,obstacleGrid);\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n     vector<vector<int>> dp(m,vector<int>(n,-1));\\n        return solve(0,0,m,n,dp,obstacleGrid);\\n        }\\n//TC:O(m*n)\\n//SC:O(m*n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1180246,
                "title": "unique-paths-ii-short-easy-w-explanation-commented-code",
                "content": "We start at the top-left of the **`obstacleGrid`** and for each cell in the grid, we can either move right or down. We can\\'t land at an obstacle. We need to return the number of unique paths to reach the bottom-right of grid.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force) [Rejected]***\\n\\nLet\\'s build our solution starting from the brute force approach. Let\\'s directly apply what\\'s given in the problem statement.  At each cell, we have two choices -\\n\\n&emsp;&emsp;\\u2726 *Go Right*\\n&emsp;&emsp;\\u2726 *Go Down*\\n\\nSo, we can recursively build up our solution as -.\\n\\n1. At each cell, explore the two choices available to us - go right & go down (**Recursive function**).\\n\\n2. If we reach the bottom-right cell of the grid, we have found a unique path (**Base Condition - I**). \\n\\n3. If at any time, we reach a cell with value 1, it is an **obstacle cell** and we can\\'t move any further. So, we just stop exploring further paths from this cell (**Base Condition - II**).  \\n\\n\\nWe will accumulate all such unique paths.\\n\\n**C++**\\n```\\nint m, n;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        \\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);    \\n\\treturn solve(obstacleGrid, 0, 0);   \\n}\\n// function to recursively explore all unique paths\\nint solve(vector<vector<int> >& grid, int i, int j){\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;          // bounds checking\\n\\tif(grid[i][j]) return 0;   // if there\\'s obstacle, just return 0 and stop further exploration\\n\\tif(i == m - 1 && j == n - 1 && !grid[i][j]) return 1;     // if we have reached end cell, return 1 if there\\'s no obstacle   \\n\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1);     // explore the two choice we have at each cell\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdef solve(grid, i, j):\\n\\t\\tif i >= m or j >= n or i < 0 or j < 0 or grid[i][j]:\\n\\t\\t\\treturn 0\\n\\t\\tif i == m - 1 and j == n - 1: \\n\\t\\t\\treturn 1\\n\\t\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n\\treturn solve(grid, 0, 0)\\n```\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Recursive version) [Accepted]***\\n\\nWe can observe that there are a lot of cells that are revisited in the above appraoch and the whole path is recursed till the bottom-right cell is reached for each cell again and again. We don\\'t need to recalculate this everytime if we just store the previously calculated result for a given cell.\\n\\nWe can do this by maintaining a 2d DP array. Here *`dp[i][j]`* will denote the number of unique paths to reach the bottom-right corner of the grid starting from the cell - *`obstacleGrid[i][j]`*.\\n\\n**C++**\\n```\\nint m, n;\\nvector<vector<int> > dp;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);\\n\\tdp.resize(m, vector<int>(n));\\n\\treturn solve(obstacleGrid, 0, 0);\\n}\\n// function to recursively explore all unique paths and store the results once calculated\\nint solve(vector<vector<int>>& grid, int i, int j) {\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;    // bounds checking\\n\\tif(grid[i][j]) return dp[i][j] = 0;                 // obstacle found at current cell\\n\\tif(i == m - 1 && j == n - 1) return 1;              // reached bottom-right of grid ? return 1\\n\\tif(dp[i][j]) return dp[i][j];                       // if already computed for current cell, just return the stored results\\n\\treturn dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1); // recursively explore the two options available with us\\n}\\n```\\n\\n---\\n\\n**Python**\\n\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*len(grid[0]) for _ in range(len(grid))]\\n    def solve(grid, i, j):\\n        if i >= m or j >= n or i < 0 or j < 0 or grid[i][j]: return 0\\n        if i == m - 1 and j == n - 1:  return 1\\n        if dp[i][j]:\\n            return dp[i][j]\\n        dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n        return dp[i][j]\\n    return solve(grid, 0, 0)\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Iterative version) [Accepted]***\\n\\nWe can also solve it iteratively. We have 1 way in which we can start from *`grid[0][0]`* and for rest of the cells, we could have reached here from the top cell or the left cell. So, we can maintain *`dp[i][j]`* and iteratively accumulate unique paths for current cell by adding *`dp[i - 1][j]`* (number of ways we reached top cell) and *`dp[i][j - 1]`* (number of ways we reached left cell).\\n\\nHere, I am using padded row and column in *`dp`* to simplify the code. In this solution, *`dp[i][j]`*, will denote the number of unique paths to reach the cell *`grid[i-1][j-1]`* (since padded row and column used in dp at start) from the start. \\n\\nThus, we can iterate over the whole grid and at last return **`dp[m][n]`** which will be the number of unique paths to reach bottom-right of grid from the start.\\n\\nHere, *`dp[0][1]`* (or *`dp[1][0]`*) needs to be set to 1 at the start, so that *`dp[1][1]`* will become 1 in our loop (denoting we have one way to reach the starting cell `grid[0][0]`).\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (m + 1, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n\\t\\t\\t// dp[i][j] = sum of unique paths for top and left cell (cells from which we reach current one)\\n            dp[i][j] = !grid[i - 1][j - 1] ? dp[i - 1][j] + dp[i][j - 1] : 0;\\n    return dp[m][n];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1) for _ in range(len(grid) + 1)]\\n    dp[0][1] = 1\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if not grid[i - 1][j - 1] else 0\\n    return dp[-1][-1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Space Optimized) [Accepted]***\\n\\nWe can see that in the above solution, we are only ever accessing the current and previous rows of the dp array. So, we don\\'t need to maintain the whole *`M*N`* DP array and the space usage can be optimized by maintaining just 2 rows.\\n\\nA common way of doing this with most dp problems is to declare a two rows dp matrix and just alternate between the rows at each iteration. We can alternate between the rows by doing a parity check while indexing a row of dp. Thus, we can use `dp[0]` at even indices and `dp[1]` and odd indices of iteration.\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (2, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n            dp[i & 1][j] = !grid[i - 1][j - 1] ? dp[(i - 1) & 1][j] + dp[i & 1][j - 1] : 0;\\n    return dp[m & 1][n];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1)] * 2\\n\\tdp[0][1] = 1\\n\\tfor i in range(1, m + 1):\\n\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\tdp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1] if not grid[i - 1][j - 1] else 0\\n\\treturn dp[m & 1][-1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(N)`**\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution V - (In-Place) [Accepted]***\\n\\nWe can also choose to modify the given input grid itself (if input modification is allowed). This solution is similar to *`Solution - III`*, with just the change that we are using *`grid`* itself instead of auxillary space for **`dp`**.\\n\\n**C++**\\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n    grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\\n\\t/* For each cell of first row and column, we can either reach that cell in 1 way\\n\\t * if previous column/row cell are not obstacle respectively, or not reach it at all.\\n\\t * That\\'s what we are doing below */\\n    for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \\n    for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\\n    // same process as in above solutions -\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)            \\n            grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \\n    return grid[m - 1][n - 1];\\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0] ^= 1\\n\\tfor i,j in zip(range(1, n), range(1, m)):\\n\\t\\tgrid[0][i] = not grid[0][i] & grid[0][i - 1]\\n\\t\\tgrid[j][0] = not grid[j][0] & grid[j - 1][0]        \\n\\tfor i in range(1, m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tgrid[i][j] = grid[i - 1][j] + grid[i][j - 1] if not grid[i][j] else 0\\n\\treturn grid[m - 1][n - 1]\\n```\\n\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint m, n;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {        \\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);    \\n\\treturn solve(obstacleGrid, 0, 0);   \\n}\\n// function to recursively explore all unique paths\\nint solve(vector<vector<int> >& grid, int i, int j){\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;          // bounds checking\\n\\tif(grid[i][j]) return 0;   // if there\\'s obstacle, just return 0 and stop further exploration\\n\\tif(i == m - 1 && j == n - 1 && !grid[i][j]) return 1;     // if we have reached end cell, return 1 if there\\'s no obstacle   \\n\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1);     // explore the two choice we have at each cell\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tdef solve(grid, i, j):\\n\\t\\tif i >= m or j >= n or i < 0 or j < 0 or grid[i][j]:\\n\\t\\t\\treturn 0\\n\\t\\tif i == m - 1 and j == n - 1: \\n\\t\\t\\treturn 1\\n\\t\\treturn solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n\\treturn solve(grid, 0, 0)\\n```\n```\\nint m, n;\\nvector<vector<int> > dp;\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tm = size(obstacleGrid), n = size(obstacleGrid[0]);\\n\\tdp.resize(m, vector<int>(n));\\n\\treturn solve(obstacleGrid, 0, 0);\\n}\\n// function to recursively explore all unique paths and store the results once calculated\\nint solve(vector<vector<int>>& grid, int i, int j) {\\n\\tif(i < 0 || j < 0 || i >= m || j >= n) return 0;    // bounds checking\\n\\tif(grid[i][j]) return dp[i][j] = 0;                 // obstacle found at current cell\\n\\tif(i == m - 1 && j == n - 1) return 1;              // reached bottom-right of grid ? return 1\\n\\tif(dp[i][j]) return dp[i][j];                       // if already computed for current cell, just return the stored results\\n\\treturn dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1); // recursively explore the two options available with us\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*len(grid[0]) for _ in range(len(grid))]\\n    def solve(grid, i, j):\\n        if i >= m or j >= n or i < 0 or j < 0 or grid[i][j]: return 0\\n        if i == m - 1 and j == n - 1:  return 1\\n        if dp[i][j]:\\n            return dp[i][j]\\n        dp[i][j] = solve(grid, i + 1, j) + solve(grid, i, j + 1)\\n        return dp[i][j]\\n    return solve(grid, 0, 0)\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (m + 1, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n\\t\\t\\t// dp[i][j] = sum of unique paths for top and left cell (cells from which we reach current one)\\n            dp[i][j] = !grid[i - 1][j - 1] ? dp[i - 1][j] + dp[i][j - 1] : 0;\\n    return dp[m][n];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n    m, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1) for _ in range(len(grid) + 1)]\\n    dp[0][1] = 1\\n    for i in range(1, m + 1):\\n        for j in range(1, n + 1):\\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] if not grid[i - 1][j - 1] else 0\\n    return dp[-1][-1]\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n\\tvector<vector<int> > dp (2, vector<int>(n + 1));\\n    dp[0][1] = 1;\\n    for(int i = 1; i <= m; i++)\\n        for(int j = 1; j <= n; j++)            \\n            dp[i & 1][j] = !grid[i - 1][j - 1] ? dp[(i - 1) & 1][j] + dp[i & 1][j - 1] : 0;\\n    return dp[m & 1][n];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n, dp = len(grid), len(grid[0]), [[0]*(len(grid[0]) + 1)] * 2\\n\\tdp[0][1] = 1\\n\\tfor i in range(1, m + 1):\\n\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\tdp[i & 1][j] = dp[(i - 1) & 1][j] + dp[i & 1][j - 1] if not grid[i - 1][j - 1] else 0\\n\\treturn dp[m & 1][-1]\\n```\n```\\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n\\tint m = size(grid), n = size(grid[0]);\\n    grid[0][0] ^= 1;  // if no obstacle at start, we can reach here in 1 way\\n\\t/* For each cell of first row and column, we can either reach that cell in 1 way\\n\\t * if previous column/row cell are not obstacle respectively, or not reach it at all.\\n\\t * That\\'s what we are doing below */\\n    for(int i = 1; i < n; i++) grid[0][i] = !grid[0][i] & grid[0][i - 1]; // we can reach \\n    for(int i = 1; i < m; i++) grid[i][0] = !grid[i][0] & grid[i - 1][0];\\n    // same process as in above solutions -\\n    for(int i = 1; i < m; i++)\\n        for(int j = 1; j < n; j++)            \\n            grid[i][j] = !grid[i][j] ? grid[i - 1][j] + grid[i][j - 1] : 0;                    \\n    return grid[m - 1][n - 1];\\n}\\n```\n```\\ndef uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n\\tm, n = len(grid), len(grid[0])\\n\\tgrid[0][0] ^= 1\\n\\tfor i,j in zip(range(1, n), range(1, m)):\\n\\t\\tgrid[0][i] = not grid[0][i] & grid[0][i - 1]\\n\\t\\tgrid[j][0] = not grid[j][0] & grid[j - 1][0]        \\n\\tfor i in range(1, m):\\n\\t\\tfor j in range(1, n):\\n\\t\\t\\tgrid[i][j] = grid[i - 1][j] + grid[i][j - 1] if not grid[i][j] else 0\\n\\treturn grid[m - 1][n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1043867,
                "title": "java-0ms-beats-100-recursion-top-down-dp",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\nMemory Usage: 38.2 MB, less than 55.04% of Java online submissions for Unique Paths II.\\n\\n```\\nclass Solution {\\n        \\n    private int util(int[][] b, int x, int y, int[][] dp)\\n    {\\n        //base case check - if x or y is invalid or if there is obstacle\\n        if( x < 0 || y < 0 || b[x][y] == 1)\\n            return 0;\\n        \\n        // if we reached the cell (0,0) - return 1 as there is a path\\n        if(x == 0  && y == 0 )\\n            return 1;\\n        \\n\\t// check your cache to avoid repeated check\\n        if(dp[x][y] != Integer.MAX_VALUE)\\n            return dp[x][y];\\n\\n\\t// else go to the top or left cell and store back the result        \\n        dp[x][y] = util(b, x-1, y, dp) + util(b, x, y-1, dp);\\n        \\n        return dp[x][y];\\n        \\n    }\\n    \\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n       //base case\\n        if(obstacleGrid.length == 0)\\n            return 0;\\n        \\n        if(obstacleGrid.length == 1 && obstacleGrid[0].length ==1)\\n            return obstacleGrid[0][0] == 0 ? 1 : 0;\\n        \\n        int[][] dp  = new int[obstacleGrid.length][obstacleGrid[0].length];\\n        \\n\\t// initialize DP array\\n        for(int i=0; i < dp.length; i++)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE );\\n        \\n        //start from the last for this question\\n        int m = obstacleGrid.length -1 ;\\n        int n = obstacleGrid[0].length -1;\\n        \\n       // Start from the bottom right most cell and go till (0,0) cell\\n        util(obstacleGrid, m, n, dp);\\n        \\n        return dp[m][n] != Integer.MAX_VALUE ? dp[m][n] : 0; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        \\n    private int util(int[][] b, int x, int y, int[][] dp)\\n    {\\n        //base case check - if x or y is invalid or if there is obstacle\\n        if( x < 0 || y < 0 || b[x][y] == 1)\\n            return 0;\\n        \\n        // if we reached the cell (0,0) - return 1 as there is a path\\n        if(x == 0  && y == 0 )\\n            return 1;\\n        \\n\\t// check your cache to avoid repeated check\\n        if(dp[x][y] != Integer.MAX_VALUE)\\n            return dp[x][y];\\n\\n\\t// else go to the top or left cell and store back the result        \\n        dp[x][y] = util(b, x-1, y, dp) + util(b, x, y-1, dp);\\n        \\n        return dp[x][y];\\n        \\n    }\\n    \\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n       //base case\\n        if(obstacleGrid.length == 0)\\n            return 0;\\n        \\n        if(obstacleGrid.length == 1 && obstacleGrid[0].length ==1)\\n            return obstacleGrid[0][0] == 0 ? 1 : 0;\\n        \\n        int[][] dp  = new int[obstacleGrid.length][obstacleGrid[0].length];\\n        \\n\\t// initialize DP array\\n        for(int i=0; i < dp.length; i++)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE );\\n        \\n        //start from the last for this question\\n        int m = obstacleGrid.length -1 ;\\n        int n = obstacleGrid[0].length -1;\\n        \\n       // Start from the bottom right most cell and go till (0,0) cell\\n        util(obstacleGrid, m, n, dp);\\n        \\n        return dp[m][n] != Integer.MAX_VALUE ? dp[m][n] : 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763068,
                "title": "python-memo-dp-table-explained",
                "content": "Code is fully commented, if you have any questions feel free.\\n\\n***Memo version (better than 90% submissions)***\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        self.height, self.width = len(obstacleGrid), len(obstacleGrid[0])\\n        self.memo = defaultdict(int)\\n        \\n        def walk(i, j):\\n            # If were on an obstacle\\n            if obstacleGrid[i][j] == 1: return 0\\n            \\n            # If we arrived to the end we know there is a path\\n            if i == self.height - 1 and j == self.width - 1:\\n                return 1\\n            \\n            # Memo\\n            if (i, j) in self.memo:\\n                return self.memo[(i, j)]\\n            \\n            # Travel down\\n            if i < self.height - 1:\\n                self.memo[(i, j)] += walk(i + 1, j)\\n            \\n            # Travel right\\n            if j < self.width - 1:\\n                self.memo[(i, j)] += walk(i, j + 1)\\n            \\n            return self.memo[(i, j)]\\n                \\n        \\n        return walk(0, 0)\\n```\\n\\n\\n***Tabulated version (better than 85%)***\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        height, width = len(obstacleGrid), len(obstacleGrid[0])\\n        if obstacleGrid[height - 1][width - 1] == 1: return 0\\n        \\n        dp = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\\n        dp[height - 1][width - 1] = 1\\n        \\n        for i in range(height)[::-1]:\\n            for j in range(width)[::-1]:\\n                # This if block skips the first iteration only\\n                if i == height - 1 and j == width - 1: continue\\n                if obstacleGrid[i][j] == 1: continue\\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\\n        \\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        self.height, self.width = len(obstacleGrid), len(obstacleGrid[0])\\n        self.memo = defaultdict(int)\\n        \\n        def walk(i, j):\\n            # If were on an obstacle\\n            if obstacleGrid[i][j] == 1: return 0\\n            \\n            # If we arrived to the end we know there is a path\\n            if i == self.height - 1 and j == self.width - 1:\\n                return 1\\n            \\n            # Memo\\n            if (i, j) in self.memo:\\n                return self.memo[(i, j)]\\n            \\n            # Travel down\\n            if i < self.height - 1:\\n                self.memo[(i, j)] += walk(i + 1, j)\\n            \\n            # Travel right\\n            if j < self.width - 1:\\n                self.memo[(i, j)] += walk(i, j + 1)\\n            \\n            return self.memo[(i, j)]\\n                \\n        \\n        return walk(0, 0)\\n```\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        height, width = len(obstacleGrid), len(obstacleGrid[0])\\n        if obstacleGrid[height - 1][width - 1] == 1: return 0\\n        \\n        dp = [[0 for _ in range(width + 1)] for _ in range(height + 1)]\\n        dp[height - 1][width - 1] = 1\\n        \\n        for i in range(height)[::-1]:\\n            for j in range(width)[::-1]:\\n                # This if block skips the first iteration only\\n                if i == height - 1 and j == width - 1: continue\\n                if obstacleGrid[i][j] == 1: continue\\n                dp[i][j] = dp[i + 1][j] + dp[i][j + 1]\\n        \\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649140,
                "title": "simple-java-o-1-space-solution",
                "content": "For cell i,j we just need to sum left cell + top cell.\\nIf any of them is obstacle, then we say it\\'s 0, otherwise take it\\'s value.\\n\\n```\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        if (grid[0][0] == 1 || grid[n - 1][m - 1] == 1) return 0;\\n        grid[0][0] = 1;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) continue;\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                } else {\\n                    int top = i == 0 ? 0 : grid[i - 1][j];\\n                    int left = j == 0 ? 0 : grid[i][j - 1];\\n                    grid[i][j] = top + left;        \\n                }\\n            }\\n        }\\n        return grid[n - 1][m - 1];\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        if (grid[0][0] == 1 || grid[n - 1][m - 1] == 1) return 0;\\n        grid[0][0] = 1;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if (i == 0 && j == 0) continue;\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                } else {\\n                    int top = i == 0 ? 0 : grid[i - 1][j];\\n                    int left = j == 0 ? 0 : grid[i][j - 1];\\n                    grid[i][j] = top + left;        \\n                }\\n            }\\n        }\\n        return grid[n - 1][m - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 587294,
                "title": "java-100-faster-simple-solution",
                "content": "#### Success\\n**Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.\\nMemory Usage: 38.5 MB, less than 90.77% of Java online submissions for Unique Paths II.**\\n\\n```\\n\\nclass Solution{\\n    public int uniquePathsWithObstacles(int[][] arr) \\n\\t{\\n        if(arr == null || arr.length == 0) \\n\\t\\t\\treturn 0;\\n        for(int i = 0 ; i < arr.length; i++){\\n            for(int j = 0; j < arr[0].length; j++){\\n                arr[i][j] ^= 1;\\n                if(arr[i][j] == 1){\\n                    if(i == 0 && j != 0)\\n                        arr[i][j] = arr[i][j-1];\\n                    if(i != 0 && j == 0)\\n                        arr[i][j] = arr[i-1][j];\\n                    if(i != 0 && j != 0)\\n                        arr[i][j] = arr[i-1][j] + arr[i][j-1];\\n                }   \\n            }\\n        } \\n        return arr[arr.length - 1][arr[0].length - 1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution{\\n    public int uniquePathsWithObstacles(int[][] arr) \\n\\t{\\n        if(arr == null || arr.length == 0) \\n\\t\\t\\treturn 0;\\n        for(int i = 0 ; i < arr.length; i++){\\n            for(int j = 0; j < arr[0].length; j++){\\n                arr[i][j] ^= 1;\\n                if(arr[i][j] == 1){\\n                    if(i == 0 && j != 0)\\n                        arr[i][j] = arr[i][j-1];\\n                    if(i != 0 && j == 0)\\n                        arr[i][j] = arr[i-1][j];\\n                    if(i != 0 && j != 0)\\n                        arr[i][j] = arr[i-1][j] + arr[i][j-1];\\n                }   \\n            }\\n        } \\n        return arr[arr.length - 1][arr[0].length - 1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279532,
                "title": "my-simple-and-easy-solution-with-dp-using-c",
                "content": "My idea is inspired by the Unique Paths question, and the dynamic Programming thought. Everytime we want to calculate, just think about last time how we get there, and how many ways to get there.\\n\\nI add a `vector<vector<long> > dp(row, vector<long>(col, 0));` to store the numbers of the way to reach the point. For example, `dp[4][3] = 6;` means we have  6 ways to reach the `obstacleGrid[4][3]`.\\n\\nIn this question, robots only can move down or move right. Each time moves one point. When we are in `obstacleGrid[i - 1][j]`, we can **move down** to reach `obstacleGrid[i][j]`; or if we are in `obstacleGrid[i][j - 1]`, we can **move right** to reach `obstacleGrid[i][j]`. \\n\\nThere\\'s two ways to reach `obstacleGrid[i][j]`, move down or move right. If we want to calculate the number of ways to reach `obstacleGrid[i][j]`, we only need to know the number of the ways to reach `obstacleGrid[i - 1][j]` and `obstacleGrid[i][j - 1]`.\\n\\nSo, easy to find the relationship below:\\n`dp[i][j] = dp[i - 1][j] + ap[i][j - 1];`\\n(Assumed all the i and j above is valid.)\\n\\nHere is my code:\\n```\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        // just because obstacleGrid is too long to type\\n        vector<vector<int> >& t = obstacleGrid;\\n        int row = t.size(), col = t[0].size();\\n        vector<vector<long> > dp(row, vector<long>(col, 0));\\n        dp[0][0] = (t[0][0] == 1 ? 0 : 1);\\n        // 1. calculate the first column\\n        for (int i = 1; i < row; ++i) \\n            dp[i][0] = (t[i][0] == 0 && dp[i - 1][0] > 0 ? 1 : 0);\\n        // 2. calculate the first row\\n        for (int i = 1; i < col; i++) \\n            dp[0][i] = (t[0][i] == 0 && dp[0][i - 1] > 0 ? 1 : 0);\\n        // 3. calculate the rest of the Grid\\n        for (int i = 1; i < row; ++i) \\n            for (int j = 1; j < col; ++j) \\n                dp[i][j] = (t[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1]);            \\n        return dp[row - 1][col - 1];\\n    }    \\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555904198.png)\\n\\nIf we have  a 5 * 5 obstacle grid, the order of the calculation is like the picture above.\\n\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555904508.png)\\n\\nFirst, make sure whether the starting point has a obstacle or not. \\n\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555905008.png)\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555905057.png)\\n\\nThen, calculate the first row and the first column.\\n\\n![image](https://assets.leetcode.com/users/rsonghao/image_1555905218.png)\\n\\nAt last, calculate the rest of the obstacle grid.\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        // just because obstacleGrid is too long to type\\n        vector<vector<int> >& t = obstacleGrid;\\n        int row = t.size(), col = t[0].size();\\n        vector<vector<long> > dp(row, vector<long>(col, 0));\\n        dp[0][0] = (t[0][0] == 1 ? 0 : 1);\\n        // 1. calculate the first column\\n        for (int i = 1; i < row; ++i) \\n            dp[i][0] = (t[i][0] == 0 && dp[i - 1][0] > 0 ? 1 : 0);\\n        // 2. calculate the first row\\n        for (int i = 1; i < col; i++) \\n            dp[0][i] = (t[0][i] == 0 && dp[0][i - 1] > 0 ? 1 : 0);\\n        // 3. calculate the rest of the Grid\\n        for (int i = 1; i < row; ++i) \\n            for (int j = 1; j < col; ++j) \\n                dp[i][j] = (t[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1]);            \\n        return dp[row - 1][col - 1];\\n    }    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193557,
                "title": "java-time-o-n-m-space-o-1-explanation",
                "content": "Let\\'s say we have the following field with obstacles:\\n![image](https://assets.leetcode.com/users/olsh/image_1542205389.png)\\n\\nLet\\'s go through every cell and calculate how many paths are there to this cell.\\nFirst cell: we just stept into it. That\\'s all => only one path.\\n![image](https://assets.leetcode.com/users/olsh/image_1542205778.png)\\nGo to neighbor cells. One of them is obstacle. We mark it as 0 because in future, for calculating numbers or routes to other cells, they won\\'t add anything.\\nAnother cell is 1 because we can get there only from the first cell. \\n![image](https://assets.leetcode.com/users/olsh/image_1542207602.png)\\nEvery other cell (i,j) will be sum of cells above (i-1,j) and left (i,j-1). For border cells (with indices (ai,0) and (0, bi)) we assume that one of neighbor cells is 0, so just copy number from other cell:\\n![image](https://assets.leetcode.com/users/olsh/image_1542208046.png)\\n\\nAfter it, we just get the number in the target cell.\\n\\nHere is the code:\\n```\\nclass Solution {\\n           public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n           for (int i=0;i<obstacleGrid.length;i++){\\n               for (int j=0;j<obstacleGrid[i].length;j++){\\n                   if (obstacleGrid[i][j]==1) obstacleGrid[i][j]=0;\\n                   else if (i==0 && j==0) obstacleGrid[i][j]=1;\\n                   else if (i==0) obstacleGrid[i][j]=obstacleGrid[i][j-1];\\n                   else if (j==0) obstacleGrid[i][j]=obstacleGrid[i-1][j];\\n                   else obstacleGrid[i][j]=obstacleGrid[i-1][j]+obstacleGrid[i][j-1];\\n               }\\n           }\\n        return obstacleGrid[obstacleGrid.length-1][obstacleGrid[obstacleGrid.length-1].length-1];\\n    }\\n\\n}\\n\\n```\\n\\nCurrently, I\\'m searching for the ways to optimize it. For example if you meet an abstacle, you don\\'t calculate all the cells \"behind\" it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n           public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n           for (int i=0;i<obstacleGrid.length;i++){\\n               for (int j=0;j<obstacleGrid[i].length;j++){\\n                   if (obstacleGrid[i][j]==1) obstacleGrid[i][j]=0;\\n                   else if (i==0 && j==0) obstacleGrid[i][j]=1;\\n                   else if (i==0) obstacleGrid[i][j]=obstacleGrid[i][j-1];\\n                   else if (j==0) obstacleGrid[i][j]=obstacleGrid[i-1][j];\\n                   else obstacleGrid[i][j]=obstacleGrid[i-1][j]+obstacleGrid[i][j-1];\\n               }\\n           }\\n        return obstacleGrid[obstacleGrid.length-1][obstacleGrid[obstacleGrid.length-1].length-1];\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179781,
                "title": "dp-and-o-1-short-javascript-solution",
                "content": "```\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    for(var i=0;i<obstacleGrid.length;i++){\\n        for(var j=0;j<obstacleGrid[0].length;j++){\\n            if(obstacleGrid[i][j] == 1)\\n                obstacleGrid[i][j] = 0\\n            else if(i==0&&j==0)\\n                obstacleGrid[0][0] = 1;\\n            else\\n                obstacleGrid[i][j] = (i>0? obstacleGrid[i-1][j] : 0) + (j>0 ? obstacleGrid[i][j-1] :0)\\n        }\\n    }\\n    return obstacleGrid[obstacleGrid.length -1][obstacleGrid[0].length-1]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    for(var i=0;i<obstacleGrid.length;i++){\\n        for(var j=0;j<obstacleGrid[0].length;j++){\\n            if(obstacleGrid[i][j] == 1)\\n                obstacleGrid[i][j] = 0\\n            else if(i==0&&j==0)\\n                obstacleGrid[0][0] = 1;\\n            else\\n                obstacleGrid[i][j] = (i>0? obstacleGrid[i-1][j] : 0) + (j>0 ? obstacleGrid[i][j-1] :0)\\n        }\\n    }\\n    return obstacleGrid[obstacleGrid.length -1][obstacleGrid[0].length-1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 23247,
                "title": "short-and-sweet-python-solution-in-place-dp-ac-62ms",
                "content": "\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if (not obstacleGrid) or obstacleGrid[0][0]:\\n            return 0\\n        \\n        obstacleGrid[0][0] = 1\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        for i in range(1,m):\\n            obstacleGrid[i][0] = obstacleGrid[i-1][0] * (1-obstacleGrid[i][0])\\n            \\n        for j in range(1,n):\\n            obstacleGrid[0][j] = obstacleGrid[0][j-1] * (1-obstacleGrid[0][j])\\n            \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                obstacleGrid[i][j] = (1-obstacleGrid[i][j])*(obstacleGrid[i-1][j]+obstacleGrid[i][j-1])\\n        \\n        return obstacleGrid[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if (not obstacleGrid) or obstacleGrid[0][0]:\\n            return 0\\n        \\n        obstacleGrid[0][0] = 1\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        \\n        for i in range(1,m):\\n            obstacleGrid[i][0] = obstacleGrid[i-1][0] * (1-obstacleGrid[i][0])\\n            \\n        for j in range(1,n):\\n            obstacleGrid[0][j] = obstacleGrid[0][j-1] * (1-obstacleGrid[0][j])\\n            \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                obstacleGrid[i][j] = (1-obstacleGrid[i][j])*(obstacleGrid[i-1][j]+obstacleGrid[i][j-1])\\n        \\n        return obstacleGrid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23275,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        rows = len(obstacleGrid)\\n        cols = len(obstacleGrid[0])\\n        dp = [[0 for i in range(cols)] for j in range(rows)]\\n        for i in range(rows-1, -1, -1):\\n            for j in range(cols-1, -1, -1):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i == rows-1 and j == cols-1:\\n                        dp[i][j] = 1\\n                    elif i == rows - 1:\\n                        dp[i][j] = dp[i][j+1]\\n                    elif j == cols -1:\\n                        dp[i][j] = dp[i+1][j]\\n                    else:\\n                        dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        rows = len(obstacleGrid)\\n        cols = len(obstacleGrid[0])\\n        dp = [[0 for i in range(cols)] for j in range(rows)]\\n        for i in range(rows-1, -1, -1):\\n            for j in range(cols-1, -1, -1):\\n                if obstacleGrid[i][j] == 1:\\n                    dp[i][j] = 0\\n                else:\\n                    if i == rows-1 and j == cols-1:\\n                        dp[i][j] = 1\\n                    elif i == rows - 1:\\n                        dp[i][j] = dp[i][j+1]\\n                    elif j == cols -1:\\n                        dp[i][j] = dp[i+1][j]\\n                    else:\\n                        dp[i][j] = dp[i+1][j] + dp[i][j+1]\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23344,
                "title": "my-easy-understanding-java-solution-with-explanation",
                "content": "Here is my understanding of the code: Array dp stores the number of paths which passing this point. The whole algorithm is to sum up the paths from left grid and up grid. 'if (row[j] == 1) dp[j] = 0; means if there is an obstacle at this point. All the paths passing this point will no longer valid. In other words, the grid right of the obstacle can be reached only by the grid which lies up to it. Hope it helps.\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n    int width = obstacleGrid[0].length;\\n    int[] dp = new int[width];\\n    dp[0] = 1;\\n    for (int[] row : obstacleGrid) {\\n        for (int j = 0; j < width; j++) {\\n            if (row[j] == 1)\\n                dp[j] = 0;\\n            else if (j > 0)\\n                dp[j] += dp[j - 1];\\n        }\\n    }\\n    return dp[width - 1];\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Here is my understanding of the code: Array dp stores the number of paths which passing this point. The whole algorithm is to sum up the paths from left grid and up grid. 'if (row[j] == 1) dp[j] = 0; means if there is an obstacle at this point. All the paths passing this point will no longer valid. In other words, the grid right of the obstacle can be reached only by the grid which lies up to it. Hope it helps.\\n\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n    int width = obstacleGrid[0].length;\\n    int[] dp = new int[width];\\n    dp[0] = 1;\\n    for (int[] row : obstacleGrid) {\\n        for (int j = 0; j < width; j++) {\\n            if (row[j] == 1)\\n                dp[j] = 0;\\n            else if (j > 0)\\n                dp[j] += dp[j - 1];\\n        }\\n    }\\n    return dp[width - 1];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 23377,
                "title": "pyhon-dp-solution",
                "content": "\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        m, n, dp = len(obstacleGrid), len(obstacleGrid[0]), [0, 1]\\n        dp += [0] * (n - 1)\\n        for i in xrange(1, m + 1):\\n            for j in xrange(1, n + 1):\\n                dp[j] = (not obstacleGrid[i-1][j-1]) * (dp[j] + dp[j-1]) \\n        return dp[-1]",
                "solutionTags": [],
                "code": "\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        m, n, dp = len(obstacleGrid), len(obstacleGrid[0]), [0, 1]\\n        dp += [0] * (n - 1)\\n        for i in xrange(1, m + 1):\\n            for j in xrange(1, n + 1):\\n                dp[j] = (not obstacleGrid[i-1][j-1]) * (dp[j] + dp[j-1]) \\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 23389,
                "title": "simple-4ms-dp-c-solution",
                "content": "    class Solution {\\n        public:\\n            int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n                int m = grid.size(), n = ( m == 0 ? 0 : grid[0].size());\\n                if( !m || !n || grid[m-1][n-1] == 1 ) return 0;\\n                vector<vector<int>> dp( m, vector<int>(n, 0));\\n                for( int i = 0; i < m; i++ ) if( grid[i][0] != 1 ) dp[i][0] = 1; else break;\\n                for( int i = 0; i < n; i++ ) if( grid[0][i] != 1 ) dp[0][i] = 1; else break;\\n                for( int i = 1; i < m; i++ )\\n                    for( int j = 1; j < n; j++ ) dp[i][j] = (( grid[i-1][j] == 1 ) ? 0 : dp[i-1][j]) + (( grid[i][j-1] == 1 ) ? 0 : dp[i][j-1]);\\n                return dp[m-1][n-1];\\n            }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n                int m = grid.size(), n = ( m == 0 ? 0 : grid[0].size());\\n                if( !m || !n || grid[m-1][n-1] == 1 ) return 0;\\n                vector<vector<int>> dp( m, vector<int>(n, 0));\\n                for( int i = 0; i < m; i++ ) if( grid[i][0] != 1 ) dp[i][0] = 1; else break;\\n                for( int i = 0; i < n; i++ ) if( grid[0][i] != 1 ) dp[0][i] = 1; else break;\\n                for( int i = 1; i < m; i++ )\\n                    for( int j = 1; j < n; j++ ) dp[i][j] = (( grid[i-1][j] == 1 ) ? 0 : dp[i-1][j]) + (( grid[i][j-1] == 1 ) ? 0 : dp[i][j-1]);\\n                return dp[m-1][n-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3899886,
                "title": "java-dp-beats-100-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n2D array visualization of ways :-\\nInput\\nobstacleGrid =\\n[[0,0,0,0],[0,1,0,0],[0,0,0,0],[0,0,1,0],[0,0,0,0]]\\nStdout\\n1 1 1 1 \\n1 0 1 2 \\n1 1 2 4 \\n1 2 0 4 \\n1 3 3 7\\nTotal unique ways :- 7 ways\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n       \\n        int n=obstacleGrid.length;\\n        int m=obstacleGrid[0].length;\\n   if (n == 0 || m == 0 || obstacleGrid[0][0] == 1)  return 0;\\n\\n        int dp[][] =new int[n][m];\\n        //base case \\n        for(int i=0;i<n;i++){\\n              if(obstacleGrid[i][0]==1)break;\\n              dp[i][0]=1;\\n          }\\n        for(int i=0;i<m;i++){\\n              if(obstacleGrid[0][i]==1)break;\\n              dp[0][i]=1;\\n          }\\n        //bottom up approach\\n       for(int i=1;i<n;i++){\\n           for(int j=1;j<m;j++){\\n               if(obstacleGrid[i][j]==0){\\n               if(dp[i-1][j]!=0 && dp[i][j-1]!=0){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n               }\\n               else if(dp[i-1][j]!=0){\\n                   dp[i][j]=dp[i-1][j];\\n               }\\n               else if(dp[i][j-1]!=0)\\n               dp[i][j]=dp[i][j-1];\\n           }\\n           }\\n       }\\n       return dp[n-1][m-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n       \\n        int n=obstacleGrid.length;\\n        int m=obstacleGrid[0].length;\\n   if (n == 0 || m == 0 || obstacleGrid[0][0] == 1)  return 0;\\n\\n        int dp[][] =new int[n][m];\\n        //base case \\n        for(int i=0;i<n;i++){\\n              if(obstacleGrid[i][0]==1)break;\\n              dp[i][0]=1;\\n          }\\n        for(int i=0;i<m;i++){\\n              if(obstacleGrid[0][i]==1)break;\\n              dp[0][i]=1;\\n          }\\n        //bottom up approach\\n       for(int i=1;i<n;i++){\\n           for(int j=1;j<m;j++){\\n               if(obstacleGrid[i][j]==0){\\n               if(dp[i-1][j]!=0 && dp[i][j-1]!=0){\\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n               }\\n               else if(dp[i-1][j]!=0){\\n                   dp[i][j]=dp[i-1][j];\\n               }\\n               else if(dp[i][j-1]!=0)\\n               dp[i][j]=dp[i][j-1];\\n           }\\n           }\\n       }\\n       return dp[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898742,
                "title": "simple-c-video-solution-recursion-memoization",
                "content": "# Video Solution \\nhttps://youtu.be/t8nABhbPsuQ\\n# Intuition\\nWe will solve this question using recursion and inorder to reduce the time complexity we will use memoization.\\nFor mememoization we will have a 2D DP vector of integers.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n**Please upvote if you liked !!!**\\n\\n# Code\\n```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n// this function will return all possible paths corresponding to row and col....\\n    int paths(int row,int col,vector<vector<int>>&obstacleGrid,vector<vector<int>>&dp,int n,int m){\\n        // base cases:\\n        // 1. if robot goes outside grid or on the cell having obstacle\\n        if(row<0||col<0||row>=n||col>=m||obstacleGrid[row][col]==1){\\n            return 0;\\n        }\\n        // 2. If robot is able to reach the bottom right cell...\\n        if(row==n-1&&col==m-1){\\n            return 1; // as we have found a particular combination..\\n        }\\n        // repetative cases:\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        vector<pair<int,int>>dir={{0,1},{1,0}};\\n        int ans=0; // it is all possible paths...\\n        for(auto ele:dir){\\n            int nr=row+ele.first;\\n            int nc=col+ele.second;\\n            ans+=paths(nr,nc,obstacleGrid,dp,n,m);\\n        }\\n        return dp[row][col]=ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n=obstacleGrid.size(),m=obstacleGrid[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1)); // this vector is used for memoization...\\n        return paths(0,0,obstacleGrid,dp,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint speedup = []{ios::sync_with_stdio(0); cin.tie(0); return 0;}();\\nclass Solution {\\npublic:\\n// this function will return all possible paths corresponding to row and col....\\n    int paths(int row,int col,vector<vector<int>>&obstacleGrid,vector<vector<int>>&dp,int n,int m){\\n        // base cases:\\n        // 1. if robot goes outside grid or on the cell having obstacle\\n        if(row<0||col<0||row>=n||col>=m||obstacleGrid[row][col]==1){\\n            return 0;\\n        }\\n        // 2. If robot is able to reach the bottom right cell...\\n        if(row==n-1&&col==m-1){\\n            return 1; // as we have found a particular combination..\\n        }\\n        // repetative cases:\\n        if(dp[row][col]!=-1){\\n            return dp[row][col];\\n        }\\n        vector<pair<int,int>>dir={{0,1},{1,0}};\\n        int ans=0; // it is all possible paths...\\n        for(auto ele:dir){\\n            int nr=row+ele.first;\\n            int nc=col+ele.second;\\n            ans+=paths(nr,nc,obstacleGrid,dp,n,m);\\n        }\\n        return dp[row][col]=ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n=obstacleGrid.size(),m=obstacleGrid[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1)); // this vector is used for memoization...\\n        return paths(0,0,obstacleGrid,dp,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898003,
                "title": "beats-100-user-solution",
                "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND COMMENT FOR ANY SUPPORT**\\n# SPACE OPTIMIZED SOLUTION\\n# Approach\\nCreate a function uniquePathsWithObstacles that takes a 2D vector obstacleGrid as input.\\n\\nDetermine the number of rows m and columns n in the obstacleGrid.\\n\\nInitialize a 1D vector dp of size n with all values initialized to 0. This vector will be used to store the results of subproblems to avoid redundant calculations.\\n\\nSet dp[0] to 1 as there\\'s only one way to start from the top-left corner.\\n\\nIterate through each row of the obstacleGrid:\\n\\na. For each cell in the current row, check if it\\'s an obstacle. If it is, set dp[j] to 0 since there\\'s no way to reach an obstacle cell.\\n\\nb. Otherwise, update dp[j] with the sum of the previous value dp[j] and the value at dp[j - 1]. This is because you can reach the current cell either from above or from the left.\\n\\nAfter iterating through all rows, the value in dp[n - 1] will represent the total number of unique paths to the bottom-right corner.\\n\\nReturn the value at dp[n - 1].\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<int> dp(n, 0); // Single 1D vector for memoization\\n\\n        dp[0] = 1; // Initial value for the start cell\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[j] = 0; // Reset to 0 if there\\'s an obstacle in the current cell\\n                } else if (j > 0) {\\n                    dp[j] += dp[j - 1]; // Calculate the current cell\\'s value based on left cell\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1]; // The last element contains the result for the destination cell\\n    }\\n};\\n\\n```\\n\\n\\n# MEMOIZATION\\n\\n# Approach\\nCreate a function uniquePathsWithObstacles that takes a 2D vector obstacleGrid as input.\\n\\nDetermine the number of rows m and columns n in the obstacleGrid.\\n\\nInitialize a 2D vector dp of size m x n with all values initialized to -1. This dp vector will be used to store the results of subproblems to avoid redundant calculations.\\n\\nCall the path function to calculate the unique paths while considering obstacles, and return the result.\\n\\nCreate a function path that takes the following parameters: obstacleGrid, current row index i, current column index j, total number of rows m, total number of columns n, and the memoization array dp.\\n\\nIn the path function, implement the following base cases:\\n\\nIf i is greater than or equal to m or j is greater than or equal to n, return 0 since the current cell is out of bounds.\\nIf the current cell contains an obstacle (i.e., obstacleGrid[i][j] is 1), return 0.\\nIf the current cell is the destination cell (i.e., i is m - 1 and j is n - 1), return 1 since there\\'s only one way to reach the destination if there are no obstacles in the way.\\n\\nCheck if the result for the current cell (i, j) is already calculated in the dp array. If it\\'s not -1, return the stored value.\\n\\nRecursively calculate the number of paths moving down and moving right from the current cell. These values are obtained by calling the path function with incremented i for moving down and incremented j for moving right.\\n\\nCalculate the total number of unique paths from the current cell as the sum of the paths moving down and moving right: dp[i][j] = down + right.\\n\\nReturn the calculated value for the current cell.\\n\\nFinally, call the uniquePathsWithObstacles function with the input obstacleGrid to get the total number of unique paths that the robot can take to reach the bottom-right corner.\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(M*N)\\n# CODE\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return path(obstacleGrid, 0, 0, m, n, dp);\\n    }\\n\\n    int path(vector<vector<int>>& obstacleGrid, int i, int j, int m, int n, vector<vector<int>>& dp) {\\n        if (i >= m || j >= n || obstacleGrid[i][j] == 1)\\n            return 0;\\n\\n        if (i == m - 1 && j == n - 1)\\n            return 1;\\n\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int down = path(obstacleGrid, i + 1, j, m, n, dp);\\n        int right = path(obstacleGrid, i, j + 1, m, n, dp);\\n\\n        dp[i][j] = down + right;\\n        return dp[i][j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<int> dp(n, 0); // Single 1D vector for memoization\\n\\n        dp[0] = 1; // Initial value for the start cell\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[j] = 0; // Reset to 0 if there\\'s an obstacle in the current cell\\n                } else if (j > 0) {\\n                    dp[j] += dp[j - 1]; // Calculate the current cell\\'s value based on left cell\\n                }\\n            }\\n        }\\n\\n        return dp[n - 1]; // The last element contains the result for the destination cell\\n    }\\n};\\n\\n```\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return path(obstacleGrid, 0, 0, m, n, dp);\\n    }\\n\\n    int path(vector<vector<int>>& obstacleGrid, int i, int j, int m, int n, vector<vector<int>>& dp) {\\n        if (i >= m || j >= n || obstacleGrid[i][j] == 1)\\n            return 0;\\n\\n        if (i == m - 1 && j == n - 1)\\n            return 1;\\n\\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        int down = path(obstacleGrid, i + 1, j, m, n, dp);\\n        int right = path(obstacleGrid, i, j + 1, m, n, dp);\\n\\n        dp[i][j] = down + right;\\n        return dp[i][j];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3897134,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m=len(obstacleGrid)\\n        n=len(obstacleGrid[0])\\n        dp=[[0 for _ in range(n)] for _ in range(m)]\\n        for col in range(n):\\n            if obstacleGrid[0][col]==1:\\n                break\\n            dp[0][col]=1\\n        for row in range(m):\\n            if obstacleGrid[row][0]==1:\\n                break\\n\\n            dp[row][0]=1\\n\\n        for row in range(1,m):\\n            for col in range(1,n):\\n                if obstacleGrid[row][col]==1:\\n                    continue\\n\\n                dp[row][col]=dp[row-1][col]+dp[row][col-1]\\n\\n        return dp[-1][-1]                            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m=len(obstacleGrid)\\n        n=len(obstacleGrid[0])\\n        dp=[[0 for _ in range(n)] for _ in range(m)]\\n        for col in range(n):\\n            if obstacleGrid[0][col]==1:\\n                break\\n            dp[0][col]=1\\n        for row in range(m):\\n            if obstacleGrid[row][0]==1:\\n                break\\n\\n            dp[row][0]=1\\n\\n        for row in range(1,m):\\n            for col in range(1,n):\\n                if obstacleGrid[row][col]==1:\\n                    continue\\n\\n                dp[row][col]=dp[row-1][col]+dp[row][col-1]\\n\\n        return dp[-1][-1]                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839926,
                "title": "simple-brute-force-memoization-tabulation-easy-to-understand-beat-100",
                "content": "# Intuition\\nThe code aims to find the number of unique paths in a grid from the top-left corner to the bottom-right corner, considering certain obstacles that block the path. The grid is represented by a 2D matrix, where each cell can either be empty (0) or contain an obstacle (1). The problem can be solved using dynamic programming to efficiently compute the number of unique paths.\\nSure, let\\'s split the Approach section into three parts: Brute Force, Memoization, and Tabulation, along with their respective complexities.\\n\\n# Brute Force Approach\\nThe brute force approach is implemented using the `solve` function, which is a recursive function exploring all possible paths from the top-left to the bottom-right corner. The function backtracks and explores the right and down directions to reach the destination while avoiding obstacles.\\n\\n## Complexity\\n- Time complexity: The time complexity for the brute force approach is exponential, i.e., O(2^n), where n is the number of cells in the grid. This is because each cell has two choices (right or down), and the function explores all possible paths.\\n- Space complexity: The space complexity for the brute force approach is O(n) due to the recursive call stack.\\n\\n# Code\\n```\\n    int solve(int i, int j, vector<vector<int>>&oG){\\n        if(i>=oG.size()||j>=oG[0].size()) return 0;\\n        if(oG[i][j]==1) return 0;\\n        if(i==oG.size()-1 && j==oG[0].size()-1) return 1;\\n\\n        int ans=0;\\n        int right=0,down=0;\\n        right = solve(i,j+1,oG);\\n        down = solve(i+1,j,oG);\\n        ans = right + down;\\n        return ans;\\n    }\\n```\\n\\n# Memoization Approach\\nThe memoization approach is implemented using the `solveMEM` function, which is a recursive function with memoization. It avoids redundant computations by storing the results of previously computed subproblems in a 2D memoization table (`dp`).\\n\\n## Complexity\\n- Time complexity: The memoized approach significantly improves the time complexity by avoiding redundant computations. The time complexity becomes linear, i.e., O(m * n), where m is the number of rows and n is the number of columns in the grid.\\n- Space complexity: The memoization approach uses an additional 2D memoization table (`dp`) of size O(m * n) to store results, making the space complexity O(m * n).\\n\\n# Code\\n```\\n    int solveMEM(int i, int j, vector<vector<int>>&oG,vector<vector<int>>&dp){\\n        if(i>=oG.size()||j>=oG[0].size()) return 0;\\n        if(oG[i][j]==1) return 0;\\n        if(i==oG.size()-1 && j==oG[0].size()-1) return 1;\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        int right=0,down=0;\\n        right = solveMEM(i,j+1,oG,dp);\\n        down = solveMEM(i+1,j,oG,dp);\\n        ans = right + down;\\n        return dp[i][j]=ans;\\n    }\\n```\\n\\n# Tabulation Approach\\nThe tabulation approach is implemented using the `solveTAB` function, which solves the problem using dynamic programming with tabulation. It fills a 2D table (`dp`) to store the number of unique paths for each cell in the grid, starting from the destination cell and iterating from bottom to top and from right to left.\\n\\n## Complexity\\n- Time complexity: The tabulation approach also has a linear time complexity of O(m * n), where m is the number of rows and n is the number of columns in the grid. The function fills the table in a bottom-up manner, avoiding redundant computations.\\n- Space complexity: The tabulation approach uses a 2D table (`dp`) of size O(m * n), making the space complexity O(m * n).\\n\\nBy using memoization or tabulation, the solution\\'s time complexity is significantly reduced compared to the brute force approach, making it more efficient for larger grid sizes.\\n\\n# Code\\n```\\n    int solveTAB(vector<vector<int>>&oG){\\n        vector<vector<int>>dp(oG.size()+1,vector<int>(oG[0].size(),0));\\n        if(oG[oG.size()-1][oG[0].size()-1]==1) return 0;\\n        dp[oG.size()-1][oG[0].size()-1]=1;\\n        for(int i=oG.size()-2;i>=0;i--){\\n            if(oG[i][oG[0].size()-1]!=1){\\n                dp[i][oG[0].size()-1]=1;\\n            }\\n            else break;\\n        }\\n        for(int j=oG[0].size()-2;j>=0;j--){\\n            if(oG[oG.size()-1][j]!=1){\\n                dp[oG.size()-1][j]=1;\\n            }\\n            else break;\\n        }\\n\\n        for(int i=oG.size()-2;i>=0;i--){\\n            for(int j=oG[0].size()-2;j>=0;j--){\\n                long long ans=0;\\n                long long right=0,down=0;\\n                right = dp[i][j+1];\\n                down = dp[i+1][j];\\n                ans = right + down;\\n                if(oG[i][j]!=1)\\n                    dp[i][j]=ans;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/08e806e8-0ee1-4252-88ba-4a3b65e30ac3_1690743444.0506742.png)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\n    int solve(int i, int j, vector<vector<int>>&oG){\\n        if(i>=oG.size()||j>=oG[0].size()) return 0;\\n        if(oG[i][j]==1) return 0;\\n        if(i==oG.size()-1 && j==oG[0].size()-1) return 1;\\n\\n        int ans=0;\\n        int right=0,down=0;\\n        right = solve(i,j+1,oG);\\n        down = solve(i+1,j,oG);\\n        ans = right + down;\\n        return ans;\\n    }\\n```\n```\\n    int solveMEM(int i, int j, vector<vector<int>>&oG,vector<vector<int>>&dp){\\n        if(i>=oG.size()||j>=oG[0].size()) return 0;\\n        if(oG[i][j]==1) return 0;\\n        if(i==oG.size()-1 && j==oG[0].size()-1) return 1;\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        int right=0,down=0;\\n        right = solveMEM(i,j+1,oG,dp);\\n        down = solveMEM(i+1,j,oG,dp);\\n        ans = right + down;\\n        return dp[i][j]=ans;\\n    }\\n```\n```\\n    int solveTAB(vector<vector<int>>&oG){\\n        vector<vector<int>>dp(oG.size()+1,vector<int>(oG[0].size(),0));\\n        if(oG[oG.size()-1][oG[0].size()-1]==1) return 0;\\n        dp[oG.size()-1][oG[0].size()-1]=1;\\n        for(int i=oG.size()-2;i>=0;i--){\\n            if(oG[i][oG[0].size()-1]!=1){\\n                dp[i][oG[0].size()-1]=1;\\n            }\\n            else break;\\n        }\\n        for(int j=oG[0].size()-2;j>=0;j--){\\n            if(oG[oG.size()-1][j]!=1){\\n                dp[oG.size()-1][j]=1;\\n            }\\n            else break;\\n        }\\n\\n        for(int i=oG.size()-2;i>=0;i--){\\n            for(int j=oG[0].size()-2;j>=0;j--){\\n                long long ans=0;\\n                long long right=0,down=0;\\n                right = dp[i][j+1];\\n                down = dp[i+1][j];\\n                ans = right + down;\\n                if(oG[i][j]!=1)\\n                    dp[i][j]=ans;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3375664,
                "title": "c-solution-using-memoziation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int ans(int i, int j, vector<vector<int>> &dp, vector<vector<int>>& obstacleGrid){\\n        if(i>=0 && j>=0 && obstacleGrid[i][j]==1) return 0;\\n        if(i==0 && j==0)\\n            return 1;\\n        if(i<0 || j<0)\\n            return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=ans(i-1, j, dp, obstacleGrid);\\n        int left=ans(i, j-1, dp, obstacleGrid);\\n        return dp[i][j]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return ans(m-1, n-1, dp, obstacleGrid);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int ans(int i, int j, vector<vector<int>> &dp, vector<vector<int>>& obstacleGrid){\\n        if(i>=0 && j>=0 && obstacleGrid[i][j]==1) return 0;\\n        if(i==0 && j==0)\\n            return 1;\\n        if(i<0 || j<0)\\n            return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=ans(i-1, j, dp, obstacleGrid);\\n        int left=ans(i, j-1, dp, obstacleGrid);\\n        return dp[i][j]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m=obstacleGrid.size();\\n        int n=obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return ans(m-1, n-1, dp, obstacleGrid);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321276,
                "title": "63-unique-paths-ii",
                "content": "```\\nclass Solution {\\npublic:\\n    int total_ways(vector<vector<int>>& obstacleGrid, int m,int n, int row, int col,vector<vector<int>>& dp){\\n           \\n        if(row >= m || col >= n)\\n            return 0;\\n        \\n        if(obstacleGrid[row][col] == 1)\\n            return 0;\\n        \\n        if(row == m-1 && col == n-1)\\n            return 1;\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        int right = total_ways(obstacleGrid,m,n,row,col+1,dp);\\n        int down = total_ways(obstacleGrid,m,n,row+1,col,dp);\\n        \\n         dp[row][col] = right + down;\\n        return dp[row][col];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n           int  m = obstacleGrid.size();\\n            int n = obstacleGrid[0].size();\\n        vector<vector<int>>dp(101,vector<int>(101,-1));\\n        return total_ways(obstacleGrid,m,n,0,0,dp);\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int total_ways(vector<vector<int>>& obstacleGrid, int m,int n, int row, int col,vector<vector<int>>& dp){\\n           \\n        if(row >= m || col >= n)\\n            return 0;\\n        \\n        if(obstacleGrid[row][col] == 1)\\n            return 0;\\n        \\n        if(row == m-1 && col == n-1)\\n            return 1;\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        int right = total_ways(obstacleGrid,m,n,row,col+1,dp);\\n        int down = total_ways(obstacleGrid,m,n,row+1,col,dp);\\n        \\n         dp[row][col] = right + down;\\n        return dp[row][col];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n           int  m = obstacleGrid.size();\\n            int n = obstacleGrid[0].size();\\n        vector<vector<int>>dp(101,vector<int>(101,-1));\\n        return total_ways(obstacleGrid,m,n,0,0,dp);\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209363,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];\\n    }\\n    };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {\\n        int m = obstacleGrid.size() , n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][1] = 1;\\n        for(int i = 1 ; i <= m ; ++i)\\n            for(int j = 1 ; j <= n ; ++j)\\n                if(!obstacleGrid[i-1][j-1])\\n                    dp[i][j] = dp[i-1][j]+dp[i][j-1];\\n        return dp[m][n];\\n    }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180658,
                "title": "beats-90-79-63-unique-paths-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a 2D dp list with the size of m+1 x n+1, with all elements initialized as 0.\\n2. Set dp[0][1] to 1 as it is the starting point for the robot.\\n3. Loop through the grid, if the current element is not an obstacle (obstacleGrid[i-1][j-1] == 0), calculate the number of possible paths to reach the current cell by adding the number of paths from the cell above and the cell on the left (dp[i][j] = dp[i-1][j] + dp[i][j-1]).\\n4. Return the number of paths to reach the bottom-right corner (dp[m][n]).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp[0][1] = 1\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if obstacleGrid[i - 1][j - 1] == 0:\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp[0][1] = 1\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if obstacleGrid[i - 1][j - 1] == 0:\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050140,
                "title": "c-easy-solution-top-down-approach-beats-85",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>& obs,vector<vector<int>>&dp){\\n        if(i>=0 && j>=0 && obs[i][j]==1)\\n            return 0;\\n        if(i==0 && j==0 ) return 1;\\n        if(i<0 || j<0) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=f(i-1,j,obs,dp);\\n        int left=f(i,j-1,obs,dp);\\n        return dp[i][j]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int n=obs.size();\\n        int m=obs[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return f(n-1,m-1,obs,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>>& obs,vector<vector<int>>&dp){\\n        if(i>=0 && j>=0 && obs[i][j]==1)\\n            return 0;\\n        if(i==0 && j==0 ) return 1;\\n        if(i<0 || j<0) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=f(i-1,j,obs,dp);\\n        int left=f(i,j-1,obs,dp);\\n        return dp[i][j]=left+up;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int n=obs.size();\\n        int m=obs[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return f(n-1,m-1,obs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995680,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& v) {\\n        int m=v.size();\\n        int n=v[0].size();\\n        if(v[0][0]==1)\\n        return 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(v[i][0]==1)\\n            {\\n                for(int j=i;j<m;j++)\\n                v[j][0]=0;\\n                break;\\n            }\\n            v[i][0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[0][i]==1)\\n            {\\n                for(int j=i;j<n;j++)\\n                v[0][j]=0;\\n                break;\\n            }\\n            v[0][i]=1;\\n        }\\n        // for(int i=0;i<m;i++)\\n        // for(int j=0;j<n;j++)\\n        // cout<<v[i][j]<<\" \";\\n        // cout<<\"\\\\n\";\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                v[i][j]=v[i-1][j]+v[i][j-1];\\n                else\\n                v[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        cout<<v[i][j]<<\" \";\\n        return v[m-1][n-1];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& v) {\\n        int m=v.size();\\n        int n=v[0].size();\\n        if(v[0][0]==1)\\n        return 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(v[i][0]==1)\\n            {\\n                for(int j=i;j<m;j++)\\n                v[j][0]=0;\\n                break;\\n            }\\n            v[i][0]=1;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(v[0][i]==1)\\n            {\\n                for(int j=i;j<n;j++)\\n                v[0][j]=0;\\n                break;\\n            }\\n            v[0][i]=1;\\n        }\\n        // for(int i=0;i<m;i++)\\n        // for(int j=0;j<n;j++)\\n        // cout<<v[i][j]<<\" \";\\n        // cout<<\"\\\\n\";\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                v[i][j]=v[i-1][j]+v[i][j-1];\\n                else\\n                v[i][j]=0;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        for(int j=0;j<n;j++)\\n        cout<<v[i][j]<<\" \";\\n        return v[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2979281,
                "title": "tabulation-based-soln-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to unique paths II \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsame as unique paths just one change if mat[i][j]=1 count of ways=0 for that point \\ncorner case: if starting element is obstacle return 0\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\n  \\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] dp=new int[n][m];\\n       \\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                   if(grid[i][j]==1){\\n                     dp[i][j]=0;\\n                     continue;\\n                 }\\n                 if(i==0 && j==0) {\\n                     dp[i][j]=1;\\n                     continue;\\n                 }\\n               \\n                 int up=0;\\n                 int left=0;\\n                 if(i>0) up=dp[i-1][j];\\n                 if(j>0) left=dp[i][j-1];\\n                 dp[i][j]=up+left;\\n             }\\n         }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  \\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        int[][] dp=new int[n][m];\\n       \\n         for(int i=0;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                   if(grid[i][j]==1){\\n                     dp[i][j]=0;\\n                     continue;\\n                 }\\n                 if(i==0 && j==0) {\\n                     dp[i][j]=1;\\n                     continue;\\n                 }\\n               \\n                 int up=0;\\n                 int left=0;\\n                 if(i>0) up=dp[i-1][j];\\n                 if(j>0) left=dp[i][j-1];\\n                 dp[i][j]=up+left;\\n             }\\n         }\\n        return dp[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975056,
                "title": "java-dynamic-programming-easy",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            if (obstacleGrid[i][0] == 1) {\\n                dp[i][0] = 0;\\n                break;\\n            }\\n            dp[i][0] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (obstacleGrid[0][i] == 1) {\\n                dp[0][i] = 0;\\n                break;\\n            }\\n            dp[0][i] = 1;\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n// TC: O(n + n) + O(m * n) ~ O(m * n)\\n// SC: O(m * n)\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.length;\\n        int n = obstacleGrid[0].length;\\n        int[][] dp = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            if (obstacleGrid[i][0] == 1) {\\n                dp[i][0] = 0;\\n                break;\\n            }\\n            dp[i][0] = 1;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (obstacleGrid[0][i] == 1) {\\n                dp[0][i] = 0;\\n                break;\\n            }\\n            dp[0][i] = 1;\\n        }\\n\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    dp[i][j] = 0;\\n                    continue;\\n                }\\n\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n}\\n\\n// TC: O(n + n) + O(m * n) ~ O(m * n)\\n// SC: O(m * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968122,
                "title": "concise-dp-solution-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &obstacleGrid, vector<vector<int>> &dp) {\\n        if(!i && !j) return 1;\\n        if(i < 0 || j < 0 || obstacleGrid[i][j]) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, obstacleGrid, dp);\\n        int l = dfs(i, j - 1, obstacleGrid, dp);\\n\\n        return dp[i][j] = u + l;\\n    }\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0]) return 0;\\n\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return dfs(m - 1, n - 1, obstacleGrid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, vector<vector<int>> &obstacleGrid, vector<vector<int>> &dp) {\\n        if(!i && !j) return 1;\\n        if(i < 0 || j < 0 || obstacleGrid[i][j]) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int u = dfs(i - 1, j, obstacleGrid, dp);\\n        int l = dfs(i, j - 1, obstacleGrid, dp);\\n\\n        return dp[i][j] = u + l;\\n    }\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0]) return 0;\\n\\n        int m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return dfs(m - 1, n - 1, obstacleGrid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535872,
                "title": "5-line-java-solution-using-recursion-and-hashmap",
                "content": "please vote up if find solution simple to code ! \\nfor explanation please reply , i will be more than happy to explain ... \\n\\n\\n\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles (int[][] obstacleGrid) {\\n        return depth(obstacleGrid, 0, 0, new HashMap<>());\\n    }\\n\\n    public int depth (int[][] grid, int i, int j, HashMap< String, Integer > memo) {\\n        if ( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1 ) return 0;\\n        if ( memo.containsKey(\"\" + j + i) ) return memo.get(\"\" + j + i);\\n        if ( j == grid[0].length - 1 && i == grid.length - 1 ) return 1; \\n        memo.put(\"\" + j + i, depth(grid, i, j + 1, memo) + depth(grid, i + 1, j, memo));\\n        return memo.get(\"\" + j + i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles (int[][] obstacleGrid) {\\n        return depth(obstacleGrid, 0, 0, new HashMap<>());\\n    }\\n\\n    public int depth (int[][] grid, int i, int j, HashMap< String, Integer > memo) {\\n        if ( i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1 ) return 0;\\n        if ( memo.containsKey(\"\" + j + i) ) return memo.get(\"\" + j + i);\\n        if ( j == grid[0].length - 1 && i == grid.length - 1 ) return 1; \\n        memo.put(\"\" + j + i, depth(grid, i, j + 1, memo) + depth(grid, i + 1, j, memo));\\n        return memo.get(\"\" + j + i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064647,
                "title": "c-dp-solution",
                "content": "using logic from my previous solution of  [Unique Paths 1](https://leetcode.com/problems/unique-paths/) \\n[https://leetcode.com/problems/unique-paths/discuss/2064527/c-dp-simple-solution](https://leetcode.com/problems/unique-paths/discuss/2064527/c-dp-simple-solution)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n, vector<vector<int>> &arr) {\\n        \\n        if(arr[0][0]==1)\\n            return 0;\\n        \\n        int dp[101][101];\\n        memset(dp, -1, sizeof(dp));\\n        \\n        int c=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[0][i]==1){\\n                dp[0][i]=0;\\n                c=1;\\n            }\\n            else if(c!=1)\\n                dp[0][i]=1;\\n            else dp[0][i]=0;\\n\\n        }\\n        \\n        c=0;\\n        for(int j=0;j<m;j++)\\n            if(arr[j][0]==1){\\n                dp[j][0]=0;\\n                c=1;\\n            }\\n            else if(c!=1)\\n                dp[j][0]=1;\\n            else dp[j][0]=0;\\n        \\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                \\n                if(arr[i][j]==1)\\n                    dp[i][j]=0;\\n                else\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                \\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n        \\n    }\\n\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        return uniquePaths(obstacleGrid.size(), obstacleGrid[0].size(), obstacleGrid);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int uniquePaths(int m, int n, vector<vector<int>> &arr) {\\n        \\n        if(arr[0][0]==1)\\n            return 0;\\n        \\n        int dp[101][101];\\n        memset(dp, -1, sizeof(dp));\\n        \\n        int c=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(arr[0][i]==1){\\n                dp[0][i]=0;\\n                c=1;\\n            }\\n            else if(c!=1)\\n                dp[0][i]=1;\\n            else dp[0][i]=0;\\n\\n        }\\n        \\n        c=0;\\n        for(int j=0;j<m;j++)\\n            if(arr[j][0]==1){\\n                dp[j][0]=0;\\n                c=1;\\n            }\\n            else if(c!=1)\\n                dp[j][0]=1;\\n            else dp[j][0]=0;\\n        \\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                \\n                if(arr[i][j]==1)\\n                    dp[i][j]=0;\\n                else\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                \\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n        \\n    }\\n\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        return uniquePaths(obstacleGrid.size(), obstacleGrid[0].size(), obstacleGrid);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056832,
                "title": "dynamic-programming-detailed-explanation-bottom-up",
                "content": "Hello Leetcoders, Hope you are doing well.\\n\\nLet\\'s solve this problem together.\\n\\n**Problem statement :** \\nWe have a matrix and a robot. Initially robot is located at top-left corner (0,0) of the matrix and robot want\\'s to go to destination bottom-right corner(m-1,n-1) index. Robot can only go right and bottom directions.\\n\\nFind total no. of ways robot can go from source to destination index.\\n\\nFollow-up : Their are some obstacles in the matrix which robot want\\'s to avoid during his journey.\\n\\n**Approach - backtracking :** \\n\\nData we have\\n* Source and destination defined.\\n* Next step is defined -> right or bottom\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // track all visited pos till now\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        // if there are an obstacle at source or destination position\\n        if(grid[0][0] == 1 || grid[m-1][n-1] == 1) return 0;\\n        \\n        \\n        rb(grid, visited, m, n, 0, 0);\\n        \\n        return count;\\n    }\\n    \\n    private void rb(int[][] grid, boolean[][] visited, int m, int n, int i, int j) {\\n        // border conditions\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1 || visited[i][j]) return;\\n        \\n        // is destination position\\n        if(i == m-1 && j == n-1) {\\n            count++;\\n            return;\\n        }\\n        \\n        // mark current pos visited\\n        visited[i][j] = true;\\n        \\n        rb(grid, visited, m, n, i, j+1); // go right\\n        rb(grid, visited, m, n, i+1, j); // go bottom;\\n        \\n        // backtracking\\n        visited[i][j] = false;\\n    }\\n}\\n```\\n\\nThis approach will show you TLE\\n![image](https://assets.leetcode.com/users/images/2c10b5f3-d4fa-4c0a-bb6f-6c7983a61a42_1653043386.22838.png)\\n\\n*Having TLE Means we have so many overlapping subproblem (which is obvious)*\\n\\n**Approach : Recursive + Memoization + Bottom-Up**\\n\\nStore the value for each position toi avoid overlapping-subproblem\\n\\n```\\n\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // track all visited pos till now\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int dp[][] = new int[m][n]; // store values\\n        \\n        // if there are an obstacle at source or destination position\\n        if(grid[0][0] == 1 || grid[m-1][n-1] == 1) return 0;\\n        \\n        dp[m-1][n-1] = 1; // memorize the calculated values\\n        \\n        rb(grid, visited, m, n, 0, 0, dp); // recursive call\\n        \\n        return dp[0][0];\\n    }\\n    \\n    private int rb(int[][] grid, boolean[][] visited, int m, int n, int i, int j, int[][] dp) {\\n        // border conditions\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1 || visited[i][j]) return 0;\\n        \\n            \\n        // is destination position\\n        if(i == m-1 && j == n-1) {\\n            // count++;\\n            return dp[i][j];\\n        }\\n        \\n        // if current position is already processed\\n        if(dp[i][j] != 0) return dp[i][j];\\n        \\n        // mark current pos visited\\n        visited[i][j] = true;\\n        \\n        int right = rb(grid, visited, m, n, i, j+1, dp); // go right\\n        int bottom = rb(grid, visited, m, n, i+1, j, dp); // go bottom;\\n        \\n        // backtracking\\n        visited[i][j] = false;\\n        \\n        dp[i][j] = right + bottom;\\n        return dp[i][j];\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/images/533d44ab-ca94-467a-86d6-c9e2237ca8fd_1653044000.3008218.png)\\n\\n\\nNow Interviewer will say can you optimize it more (currently we are using 2 arrays and stack space for recursive call)\\n\\n**Approach : DP + Iterative**\\n\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] arr) {\\n\\t\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        \\n        if(arr[0][0] == 1 || arr[m-1][n-1] == 1) return 0; // if there are an obstacle at source or destination position\\n        \\n        int dp[][] = new int[m][n]; // Store calculated values \\n        dp[0][0] = 1; // no. of ways we can start from starting positon \\n        \\n\\t\\t// update dp array border positons - first cell in every row\\n        for(int i=1; i<m; i++) {\\n            if(arr[i][0] == 0) dp[i][0] = dp[i-1][0];\\n            else dp[i][0] = 0;\\n        }\\n        \\n\\t\\t// update dp array border positons - first cell in every coloum\\n        for(int i=1; i<n; i++) {\\n            if(arr[0][i] == 0) dp[0][i] = dp[0][i-1];\\n            else dp[0][i] = 0;\\n        }\\n        \\n\\t\\t// Iterative processing \\n        for(int i=1; i<m; i++) {\\n            for(int j=1; j<n; j++) {\\n                if(arr[i][j] == 1) dp[i][j] = 0; // if current cell have an obstacle\\n                else {\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]; // no obstacle - total ways from top & left\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1]; // destination\\n    }\\n}\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8b1f2b0a-4aa8-4e4a-b116-28ac4c5242e4_1653044440.076339.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // track all visited pos till now\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        // if there are an obstacle at source or destination position\\n        if(grid[0][0] == 1 || grid[m-1][n-1] == 1) return 0;\\n        \\n        \\n        rb(grid, visited, m, n, 0, 0);\\n        \\n        return count;\\n    }\\n    \\n    private void rb(int[][] grid, boolean[][] visited, int m, int n, int i, int j) {\\n        // border conditions\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1 || visited[i][j]) return;\\n        \\n        // is destination position\\n        if(i == m-1 && j == n-1) {\\n            count++;\\n            return;\\n        }\\n        \\n        // mark current pos visited\\n        visited[i][j] = true;\\n        \\n        rb(grid, visited, m, n, i, j+1); // go right\\n        rb(grid, visited, m, n, i+1, j); // go bottom;\\n        \\n        // backtracking\\n        visited[i][j] = false;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    int count = 0;\\n    public int uniquePathsWithObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        // track all visited pos till now\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int dp[][] = new int[m][n]; // store values\\n        \\n        // if there are an obstacle at source or destination position\\n        if(grid[0][0] == 1 || grid[m-1][n-1] == 1) return 0;\\n        \\n        dp[m-1][n-1] = 1; // memorize the calculated values\\n        \\n        rb(grid, visited, m, n, 0, 0, dp); // recursive call\\n        \\n        return dp[0][0];\\n    }\\n    \\n    private int rb(int[][] grid, boolean[][] visited, int m, int n, int i, int j, int[][] dp) {\\n        // border conditions\\n        if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1 || visited[i][j]) return 0;\\n        \\n            \\n        // is destination position\\n        if(i == m-1 && j == n-1) {\\n            // count++;\\n            return dp[i][j];\\n        }\\n        \\n        // if current position is already processed\\n        if(dp[i][j] != 0) return dp[i][j];\\n        \\n        // mark current pos visited\\n        visited[i][j] = true;\\n        \\n        int right = rb(grid, visited, m, n, i, j+1, dp); // go right\\n        int bottom = rb(grid, visited, m, n, i+1, j, dp); // go bottom;\\n        \\n        // backtracking\\n        visited[i][j] = false;\\n        \\n        dp[i][j] = right + bottom;\\n        return dp[i][j];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] arr) {\\n\\t\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        \\n        if(arr[0][0] == 1 || arr[m-1][n-1] == 1) return 0; // if there are an obstacle at source or destination position\\n        \\n        int dp[][] = new int[m][n]; // Store calculated values \\n        dp[0][0] = 1; // no. of ways we can start from starting positon \\n        \\n\\t\\t// update dp array border positons - first cell in every row\\n        for(int i=1; i<m; i++) {\\n            if(arr[i][0] == 0) dp[i][0] = dp[i-1][0];\\n            else dp[i][0] = 0;\\n        }\\n        \\n\\t\\t// update dp array border positons - first cell in every coloum\\n        for(int i=1; i<n; i++) {\\n            if(arr[0][i] == 0) dp[0][i] = dp[0][i-1];\\n            else dp[0][i] = 0;\\n        }\\n        \\n\\t\\t// Iterative processing \\n        for(int i=1; i<m; i++) {\\n            for(int j=1; j<n; j++) {\\n                if(arr[i][j] == 1) dp[i][j] = 0; // if current cell have an obstacle\\n                else {\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]; // no obstacle - total ways from top & left\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1]; // destination\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056661,
                "title": "c-memoization-simple-clean-and-concise-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int way = 0;\\n    int dfsTraversal(vector<vector<int>>& matrix,int i, int j,int row, int col, vector<vector<int>>&vec){\\n        \\n        if(i >= row or j >= col)\\n            return 0;\\n        if(matrix[i][j] == 1)\\n            return 0;\\n        if(i == row-1 and j == col-1){\\n            way++;  // finding the total way\\n            return 1;\\n        }\\n        if(vec[i][j] != 0){\\n            way += vec[i][j]; //adding the current state value to the way \\n            return vec[i][j];\\n        }\\n        else{\\n            return vec[i][j] = dfsTraversal(matrix, i+1, j, row, col, vec) + dfsTraversal(matrix, i, j+1, row, col, vec); // check down and right path\\n        }\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = obstacleGrid.size(), col = obstacleGrid[0].size();\\n        vector<vector<int>>vec(row, vector<int>(col,0));\\n        \\n        //best case -> when bottom-right corner is an obstacle\\n        if(obstacleGrid[row-1][col-1] == 1)\\n            return 0;\\n        \\n        dfsTraversal(obstacleGrid, 0, 0, row, col, vec);\\n        \\n        return way;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int way = 0;\\n    int dfsTraversal(vector<vector<int>>& matrix,int i, int j,int row, int col, vector<vector<int>>&vec){\\n        \\n        if(i >= row or j >= col)\\n            return 0;\\n        if(matrix[i][j] == 1)\\n            return 0;\\n        if(i == row-1 and j == col-1){\\n            way++;  // finding the total way\\n            return 1;\\n        }\\n        if(vec[i][j] != 0){\\n            way += vec[i][j]; //adding the current state value to the way \\n            return vec[i][j];\\n        }\\n        else{\\n            return vec[i][j] = dfsTraversal(matrix, i+1, j, row, col, vec) + dfsTraversal(matrix, i, j+1, row, col, vec); // check down and right path\\n        }\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = obstacleGrid.size(), col = obstacleGrid[0].size();\\n        vector<vector<int>>vec(row, vector<int>(col,0));\\n        \\n        //best case -> when bottom-right corner is an obstacle\\n        if(obstacleGrid[row-1][col-1] == 1)\\n            return 0;\\n        \\n        dfsTraversal(obstacleGrid, 0, 0, row, col, vec);\\n        \\n        return way;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2056511,
                "title": "c-unique-path-sol",
                "content": "class Solution {\\npublic:\\n    long long dp[101][101]={0};\\n    \\n    int dfs(int i,int j,vector<vector<int>>&grid)\\n    {\\n       if(i==0 && j==0) return 1;\\n        if(i<0||j<0||grid[i][j]==1) return 0;\\n        if(dp[i][j]!=0)\\n            return dp[i][j];\\n        int val=0;\\n         val+=dfs(i,j-1,grid);\\n         val+= dfs(i-1,j,grid);\\n        return dp[i][j]+=val;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if(grid[0][0]==1|| grid[n-1][m-1]==1) return 0;\\n        if(n==1 && m==1) return 1;\\n        dfs(n-1,m-1,grid);\\n        return dp[n-1][m-1];\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    long long dp[101][101]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2056143,
                "title": "java-easy-unique-paths-ii-dp-solution-using-arraylist-and-matrices",
                "content": "**Solution:**\\n\\n\\tclass Solution {\\n\\tpublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\t\\tint a=obstacleGrid.length;\\n\\t\\tint b=obstacleGrid[0].length;\\n\\t\\tint[][] c=new int[a][b];\\n\\t\\tif(obstacleGrid[a-1][b-1]==1 || obstacleGrid[0][0]==1){\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t//Calling helper function\\n\\t\\thelper(obstacleGrid,0,0,c,a,b);\\n\\t\\tif(c[0][0]==-1){\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\t//Returning count from matrix c and row 0,,column 0\\n\\t\\treturn c[0][0];\\n\\t}\\n\\tpublic List<Integer> helper(int[][] obstacleGrid,int i,int j,int[][] c,int a,int b){\\n\\t\\tList<Integer> a2;\\n\\t\\tList<Integer> a3;\\n\\t\\tint d;\\n\\t\\t//Checking have we reach end position\\n\\t\\tif(i==a-1 && j==b-1){\\n\\t\\t\\tc[i][j]=1;\\n\\t\\t\\ta2=new ArrayList<Integer>();\\n\\t\\t\\ta2.add(1);\\n\\t\\t\\ta2.add(1);\\n\\t\\t\\treturn a2;\\n\\t\\t}\\n\\t\\t//Checking if we are going out of bound or checking if no solution\\n\\t\\tif(i>=a || j>=b || c[i][j]==-1){\\n\\t\\t\\ta2=new ArrayList<Integer>();\\n\\t\\t\\ta2.add(0);\\n\\t\\t\\ta2.add(0);\\n\\t\\t\\treturn a2;\\n\\t\\t}\\n\\t\\t//If obstacle found backtracking marking that position as -1 in matrix c\\n\\t\\tif(obstacleGrid[i][j]==1){\\n\\t\\t\\tc[i][j]=-1;\\n\\t\\t\\ta2=new ArrayList<Integer>();\\n\\t\\t\\ta2.add(0);\\n\\t\\t\\ta2.add(0);\\n\\t\\t\\treturn a2;\\n\\t\\t}\\n\\t\\t//If count already found return count\\n\\t\\tif(c[i][j]!=-1 && c[i][j]!=0){\\n\\t\\t\\ta2=new ArrayList<Integer>();\\n\\t\\t\\ta2.add(1);\\n\\t\\t\\ta2.add(c[i][j]);\\n\\t\\t\\treturn a2;\\n\\t\\t}\\n\\t\\t//Calling helper going to bottom\\n\\t\\ta2=helper(obstacleGrid,i+1,j,c,a,b);\\n\\t\\t//Calling helper going to right\\n\\t\\ta3=helper(obstacleGrid,i,j+1,c,a,b);\\n\\t\\t//Checking if atleast onefunction call leads to solution or not\\n\\t\\tif(a2.get(0)==1 || a3.get(0)==1){\\n\\t\\t\\tList<Integer> a4=new ArrayList<Integer>();\\n\\t\\t\\ta4.add(1);\\n\\t\\t\\t//Doing addition of both the function call count and storing it in matrix \\n\\t\\t\\td=a2.get(1)+a3.get(1);\\n\\t\\t\\ta4.add(d);\\n\\t\\t\\tc[i][j]=d;\\n\\t\\t\\treturn a4;\\n\\t\\t}\\n\\t\\t//If  no solution marking that position in matrix c as -1\\n\\t\\tc[i][j]=-1;\\n\\t\\ta2=new ArrayList<Integer>();\\n\\t\\ta2.add(0);\\n\\t\\ta2.add(0);\\n\\t\\treturn a2;\\n\\t}\\n\\t}",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\tpublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\t\\tint a=obstacleGrid.length;\\n\\t\\tint b=obstacleGrid[0].length;\\n\\t\\tint[][] c=new int[a][b];\\n\\t\\tif(obstacleGrid[a-1][b-1]==1 || obstacleGrid[0][0]==1){\\n\\t\\t\\treturn 0;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2055945,
                "title": "4ms-o-n-m-solution-using-memoization-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<vector<int>>& obstacleGrid , int x , int y)\\n    {\\n        if(x<0 || y<0)\\n        {\\n            return 0;\\n        }\\n        if(obstacleGrid[x][y] == 1)\\n            return 0;\\n        if(x == 0 && y==0)\\n            return 1;\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        int ans = 0;\\n        ans+=solve(obstacleGrid , x - 1 , y);\\n        ans+=solve(obstacleGrid , x , y-1);\\n        return dp[x][y] = ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size();\\n        int m = obstacleGrid[0].size();\\n        if(obstacleGrid[n-1][m-1] == 1 || obstacleGrid[0][0] == 1)\\n            return 0;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacleGrid , n-1 , m-1);\\n    }\\n};\\n```\\n```\\nTime Complexity ---->  O(N*M)\\nSpace Complexity ----> O(N*M)\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<vector<int>>& obstacleGrid , int x , int y)\\n    {\\n        if(x<0 || y<0)\\n        {\\n            return 0;\\n        }\\n        if(obstacleGrid[x][y] == 1)\\n            return 0;\\n        if(x == 0 && y==0)\\n            return 1;\\n        if(dp[x][y]!=-1)\\n            return dp[x][y];\\n        int ans = 0;\\n        ans+=solve(obstacleGrid , x - 1 , y);\\n        ans+=solve(obstacleGrid , x , y-1);\\n        return dp[x][y] = ans;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int n = obstacleGrid.size();\\n        int m = obstacleGrid[0].size();\\n        if(obstacleGrid[n-1][m-1] == 1 || obstacleGrid[0][0] == 1)\\n            return 0;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacleGrid , n-1 , m-1);\\n    }\\n};\\n```\n```\\nTime Complexity ---->  O(N*M)\\nSpace Complexity ----> O(N*M)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722265,
                "title": "c-no-extra-space-used-space-efficient-dp",
                "content": "```\\n// Use dynamic Programming, if the grid at i,j position contains obstacle, turn it to 0\\n// And for the rest grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\\n\\n// You don\\'t even have to make new 2D vector, use the same obstacleGrid vector\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0] == 1)\\n            return 0;\\n        \\n        int i = 0, j = 1;\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        while(i < m && obstacleGrid[i][0] != 1) {\\n            obstacleGrid[i][0] = 1;\\n            i++;\\n        }\\n        while(i < m) {\\n            obstacleGrid[i][0] = 0;\\n            i++;\\n        }\\n        \\n        while(j < n && obstacleGrid[0][j] != 1) {\\n            obstacleGrid[0][j] = 1;\\n            j++;\\n        }\\n        while(j < n) {\\n            obstacleGrid[0][j] = 0;\\n            j++;\\n        }\\n        \\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 1; j < n; ++j) {\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = 0;\\n                else\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n            }\\n        }\\n    \\n        return obstacleGrid[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// Use dynamic Programming, if the grid at i,j position contains obstacle, turn it to 0\\n// And for the rest grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\\n\\n// You don\\'t even have to make new 2D vector, use the same obstacleGrid vector\\n\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        if(obstacleGrid[0][0] == 1)\\n            return 0;\\n        \\n        int i = 0, j = 1;\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        while(i < m && obstacleGrid[i][0] != 1) {\\n            obstacleGrid[i][0] = 1;\\n            i++;\\n        }\\n        while(i < m) {\\n            obstacleGrid[i][0] = 0;\\n            i++;\\n        }\\n        \\n        while(j < n && obstacleGrid[0][j] != 1) {\\n            obstacleGrid[0][j] = 1;\\n            j++;\\n        }\\n        while(j < n) {\\n            obstacleGrid[0][j] = 0;\\n            j++;\\n        }\\n        \\n        for(int i = 1; i < m; ++i) {\\n            for(int j = 1; j < n; ++j) {\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = 0;\\n                else\\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n            }\\n        }\\n    \\n        return obstacleGrid[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719600,
                "title": "best-c-code-using-hashmap-memo-world-best-solution-200-fast",
                "content": "class Solution {\\npublic:\\n         int need ( int  m,int n, int row, int col,unordered_map<string ,int>&mp,vector<vector<int>>& obstacleGrid)\\n     {\\n        \\n          if(row>=m || col >=n)\\n          {\\n               return 0 ; \\n          }\\n                if(obstacleGrid[row][col]==1)\\n             \\n             {\\n                   return 0 ; \\n              }\\n           \\n          if(row==m-1 && col ==n-1)\\n          {\\n               return 1 ; \\n          }\\n             \\n      \\n      string currentKey = to_string(row) + \"_\" + to_string(col);\\n            \\n        if(mp.find(currentKey)!=mp.end()){\\n           return mp[currentKey];\\n        }\\n         \\n          int need1 = need(m,n,row+1,col,mp,obstacleGrid);\\n          int need2 = need(m,n, row,col+1,mp,obstacleGrid);\\n                      mp[currentKey]=need1+need2;\\n            return mp[currentKey];\\n         \\n         \\n     }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n         int m = obstacleGrid.size();\\n         int n= obstacleGrid[0].size();\\n        unordered_map<string ,int>mp;\\n          return need (m,n,0,0,mp,obstacleGrid)  ; \\n\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n         int need ( int  m,int n, int row, int col,unordered_map<string ,int>&mp,vector<vector<int>>& obstacleGrid)\\n     {\\n        \\n          if(row>=m || col >=n)\\n          {\\n               return 0 ; \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1578150,
                "title": "easy-to-understand-in-c-amazing-approach",
                "content": "class Solution \\n{\\npublic:\\n\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a >= m || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        } \\n        if() {\\n            dp[a][b] = path(obstacleGrid, m, n, a+1, b, dp) + path(obstacleGrid, m, n, a, b+1, dp);\\n        }\\n        return dp[a][b];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        return path(obstacleGrid, m, n, 0, 0, dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a >= m || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1535030,
                "title": "python-sc-o-1-concise-dp-with-explanation",
                "content": "### Introduction\\n\\nStarting from the top left corner of the grid, find the number of unique ways one can traverse either down or right to reach the bottom right corner while avoiding any obstacles.\\n\\n---\\n\\n### Intuition\\n\\nAt each coordinate ```(x, y)``` in the grid, we have the following rule:\\n\\n- If ```obstacleGrid[x][y] == 1```, there cannot be any paths to that coordinate since there is an obstacle there. Hence, we immediately know that **the number of paths for that coordinate is 0**.\\n- Otherwise, since we can only move right or down, a path that travels through ```(x, y)``` must come either from ```(x-1, y)``` (if it exists) or ```(x, y-1)``` (if it exists). Hence, the number of paths that travel through ```(x, y)``` must be **the sum of the number of paths that travel through ```(x-1, y)``` and ```(x, y-1)```**.\\n\\nThis recursive calculation of the number of paths is the reason why DP is useful for this problem. Moreover, we can afford to utilise the given ```obstacleGrid``` array and use O(1) auxiliary space. This is because **once we have determined the number of paths to ```(x, y)```, we will use that calculated value instead of the original value in future calculations**.\\n\\n---\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        for i, j in product(range(len(obstacleGrid)), range(len(obstacleGrid[0]))):  # you can split this into two for loops if you want\\n            \"\"\"\\n            If obstacleGrid[i][j] is an obstacle, its number of paths is immediately 0.\\n            Otherwise, the number of paths is:\\n              - The number of paths to (x-1, y), if it exists;\\n              - Plus the number of paths to (x, y-1), if it exists;\\n              - Handling the starting point by setting it to 1\\n            \"\"\"\\n            obstacleGrid[i][j] = 0 if obstacleGrid[i][j] else \\\\\\n                                 (obstacleGrid[i-1][j] if i > 0 else 0) + \\\\\\n                                 (obstacleGrid[i][j-1] if j > 0 else 0) + \\\\\\n                                 (i == 0 and j == 0)                       \\n        return obstacleGrid[-1][-1]\\n```\\n\\n**TC: O(mn)**, where `m` is the length of the grid and `n` is the breadth of the grid, since each element in the grid is accessed once.\\n**SC: O(1)**, since we modify the given array in-place.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```(x, y)```\n```obstacleGrid[x][y] == 1```\n```(x, y)```\n```(x-1, y)```\n```(x, y-1)```\n```(x, y)```\n```(x-1, y)```\n```(x, y-1)```\n```obstacleGrid```\n```(x, y)```\n```python\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        for i, j in product(range(len(obstacleGrid)), range(len(obstacleGrid[0]))):  # you can split this into two for loops if you want\\n            \"\"\"\\n            If obstacleGrid[i][j] is an obstacle, its number of paths is immediately 0.\\n            Otherwise, the number of paths is:\\n              - The number of paths to (x-1, y), if it exists;\\n              - Plus the number of paths to (x, y-1), if it exists;\\n              - Handling the starting point by setting it to 1\\n            \"\"\"\\n            obstacleGrid[i][j] = 0 if obstacleGrid[i][j] else \\\\\\n                                 (obstacleGrid[i-1][j] if i > 0 else 0) + \\\\\\n                                 (obstacleGrid[i][j-1] if j > 0 else 0) + \\\\\\n                                 (i == 0 and j == 0)                       \\n        return obstacleGrid[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331225,
                "title": "c-recursive-bottom-up-dp",
                "content": "**Recursive Solution**\\nthis solution will give you TLE\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& a) {\\n        int ans = 0;\\n        solve(0,0,a,ans);\\n        return ans;\\n    }\\n    \\n    void solve(int i,int j,vector<vector<int>>&a,int &ans)\\n    {\\n        if(i>=a.size()||j>=a[0].size()||a[i][j]==1)\\n        {\\n            return;\\n        }\\n        if(i==a.size()-1&&j==a[0].size()-1)\\n        {\\n            ans++;\\n        }\\n        solve(i+1,j,a,ans);\\n        solve(i,j+1,a,ans);\\n    }\\n};\\n```\\n\\n**Bottom-Up DP**\\n4ms running time on leetcode server\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++)\\n            if(a[i][0]==1)\\n                break;\\n            else\\n                dp[i][0] = 1;\\n        \\n        for(int j=0;j<m;j++)\\n            if(a[0][j]==1)\\n                break;\\n            else\\n                dp[0][j] = 1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                if(a[i][j]!=1)\\n                {\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n```\\n\\n*If find helpful please upvote it* **:)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& a) {\\n        int ans = 0;\\n        solve(0,0,a,ans);\\n        return ans;\\n    }\\n    \\n    void solve(int i,int j,vector<vector<int>>&a,int &ans)\\n    {\\n        if(i>=a.size()||j>=a[0].size()||a[i][j]==1)\\n        {\\n            return;\\n        }\\n        if(i==a.size()-1&&j==a[0].size()-1)\\n        {\\n            ans++;\\n        }\\n        solve(i+1,j,a,ans);\\n        solve(i,j+1,a,ans);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<n;i++)\\n            if(a[i][0]==1)\\n                break;\\n            else\\n                dp[i][0] = 1;\\n        \\n        for(int j=0;j<m;j++)\\n            if(a[0][j]==1)\\n                break;\\n            else\\n                dp[0][j] = 1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                if(a[i][j]!=1)\\n                {\\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318178,
                "title": "c-tle-ac-using-dp-memoization",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a < 0 || a >= m || b < 0 || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            dp[a][b] = 1;\\n        } \\n        else {\\n            dp[a][b] = path(obstacleGrid, m, n, a+1, b, dp) + path(obstacleGrid, m, n, a, b+1, dp);\\n        }\\n        return dp[a][b];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int totalPaths = path(obstacleGrid, m, n, 0, 0, dp);\\n        return totalPaths;\\n    }\\n};\\n```\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b)\\n    {\\n        if (a < 0 || a >= m || b < 0 || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        }\\n        return path(obstacleGrid, m, n, a+1, b) + path(obstacleGrid, m, n, a, b+1);\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        int totalPaths = path(obstacleGrid, m, n, 0, 0);\\n        return totalPaths;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b, vector<vector<int>> &dp)\\n    {\\n        if (a < 0 || a >= m || b < 0 || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (dp[a][b] != -1) {\\n            return dp[a][b];\\n        }\\n        if (a == m-1 && b == n-1) {\\n            dp[a][b] = 1;\\n        } \\n        else {\\n            dp[a][b] = path(obstacleGrid, m, n, a+1, b, dp) + path(obstacleGrid, m, n, a, b+1, dp);\\n        }\\n        return dp[a][b];\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m+1, vector<int>(n+1, -1));\\n        int totalPaths = path(obstacleGrid, m, n, 0, 0, dp);\\n        return totalPaths;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int path(vector<vector<int>> obstacleGrid, int m, int n, int a, int b)\\n    {\\n        if (a < 0 || a >= m || b < 0 || b >= n || obstacleGrid[a][b] == 1) {\\n            return 0;\\n        }\\n        if (a == m-1 && b == n-1) {\\n            return 1;\\n        }\\n        return path(obstacleGrid, m, n, a+1, b) + path(obstacleGrid, m, n, a, b+1);\\n    }\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) \\n    {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        int totalPaths = path(obstacleGrid, m, n, 0, 0);\\n        return totalPaths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232747,
                "title": "dp-o-1-space-js-solution",
                "content": "```\\n/*\\nDP\\n\\nSolution:\\n1. If there is an obstacle at the starting point (0,0) or the target point (m-1,n-1), there is zero path because we\\ncan\\'t either start or reach the target. \\n2. Else,...Let\\'s suppose we have a m x n table, where table[row][col] is the number of possible paths from (row,col) to the\\nbottom-right. table[row][col] = (grid[row][col] === 0) ? table[row][col+1] + table[row+1][col] : 1.\\nIf current entry has an obstacle, there is no path from this entry. Else, the number of paths is that from the right + that from the bottom.\\n3. We certainly know that grid[m-1][n-1] has a path of 1. Hence, this is our base case and therefore we will iterate through grid backwards and record numer of paths to the given table accordingly. We don\\'t need to initalise a new table.\\nWhy? Since we traverse backwards, we don\\'t need the value of traversed entry once it is used. Hence, we will replace its\\nentry with the number of possible paths so that upcoming entries can use it for computation. \\nAt the end of iteration, the answer is obstacleGrid[0][0].\\n\\nImportant note: for entries in the last row or the last column, row+1 or col+1 will be out of bounds. We will consider entries out of bounds zero because it is not possible to reach the bottom-right once we go past its row or column.\\n*/\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (obstacleGrid.length === 0 || obstacleGrid[0].length === 0) {\\n        return 0;\\n    }\\n    let height = obstacleGrid.length, width = obstacleGrid[0].length;\\n    if (obstacleGrid[0][0] === 1 || obstacleGrid[height-1][width-1] === 1) {\\n        return 0;\\n    }\\n    for (let row = height-1; row >= 0; row--) {\\n        for (let col = width-1; col >= 0; col--) {\\n            if (row === height-1 && col === width-1) {\\n                obstacleGrid[row][col] = 1;\\n                continue;\\n            }\\n            let right = col < width-1 ? obstacleGrid[row][col+1] : 0;\\n            let bottom = row < height-1 ? obstacleGrid[row+1][col] : 0;\\n            obstacleGrid[row][col] = (obstacleGrid[row][col] === 0) ? right + bottom : 0;\\n        }\\n    }\\n    return obstacleGrid[0][0];\\n    // T.C: O(M*N)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nDP\\n\\nSolution:\\n1. If there is an obstacle at the starting point (0,0) or the target point (m-1,n-1), there is zero path because we\\ncan\\'t either start or reach the target. \\n2. Else,...Let\\'s suppose we have a m x n table, where table[row][col] is the number of possible paths from (row,col) to the\\nbottom-right. table[row][col] = (grid[row][col] === 0) ? table[row][col+1] + table[row+1][col] : 1.\\nIf current entry has an obstacle, there is no path from this entry. Else, the number of paths is that from the right + that from the bottom.\\n3. We certainly know that grid[m-1][n-1] has a path of 1. Hence, this is our base case and therefore we will iterate through grid backwards and record numer of paths to the given table accordingly. We don\\'t need to initalise a new table.\\nWhy? Since we traverse backwards, we don\\'t need the value of traversed entry once it is used. Hence, we will replace its\\nentry with the number of possible paths so that upcoming entries can use it for computation. \\nAt the end of iteration, the answer is obstacleGrid[0][0].\\n\\nImportant note: for entries in the last row or the last column, row+1 or col+1 will be out of bounds. We will consider entries out of bounds zero because it is not possible to reach the bottom-right once we go past its row or column.\\n*/\\nvar uniquePathsWithObstacles = function(obstacleGrid) {\\n    if (obstacleGrid.length === 0 || obstacleGrid[0].length === 0) {\\n        return 0;\\n    }\\n    let height = obstacleGrid.length, width = obstacleGrid[0].length;\\n    if (obstacleGrid[0][0] === 1 || obstacleGrid[height-1][width-1] === 1) {\\n        return 0;\\n    }\\n    for (let row = height-1; row >= 0; row--) {\\n        for (let col = width-1; col >= 0; col--) {\\n            if (row === height-1 && col === width-1) {\\n                obstacleGrid[row][col] = 1;\\n                continue;\\n            }\\n            let right = col < width-1 ? obstacleGrid[row][col+1] : 0;\\n            let bottom = row < height-1 ? obstacleGrid[row+1][col] : 0;\\n            obstacleGrid[row][col] = (obstacleGrid[row][col] === 0) ? right + bottom : 0;\\n        }\\n    }\\n    return obstacleGrid[0][0];\\n    // T.C: O(M*N)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225230,
                "title": "short-python3-memoization-solution",
                "content": "Clearly in this quesion we can go either one step to the right or one step down so we create two separate recursive calls, where one handles right side movements [paths(i,j+1)]  and the other handles bottom movements [paths(i+1,j)]. This process is repeated until it:\\n1) Exceeds size of the matrix rows or columns\\n2) It encounters an obstacle which is in this case a 1\\n\\nwhen the above two conditions are met we return a : \"0\"\\n\\nOtherwise if we manage to reach the destination i.e (i==row-1 and j==col-1) we return a : \"1\"\\n\\nThe above returned values are summed up in a variable c which hold the total no of ways we can reach the destination without meeting an obstacle.\\n\\nFinally, the solution is memoized by storing the results obtained upto a point say (i,j) in a dictionary.\\n\\nclass Solution:\\n    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        row=len(grid)\\n        col=len(grid[0])\\n        dp={}\\n        \\n        def paths(i,j):\\n            \\n            if(i>=row or j>=col):\\n                return 0\\n            \\n            if(grid[i][j]==1):\\n                return 0\\n            if(i==row-1 and j==col-1):\\n                return 1\\n            \\n            if((i,j) in dp):\\n                return dp[(i,j)]\\n            \\n            c=0\\n            \\n            c+=paths(i,j+1)+paths(i+1,j)\\n            \\n            dp[(i,j)]=c\\n            \\n            return c\\n        \\n        res=paths(0,0)\\n        \\n        return(res)",
                "solutionTags": [],
                "code": "class Solution:\\n    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        row=len(grid)\\n        col=len(grid[0])\\n        dp={}",
                "codeTag": "Java"
            },
            {
                "id": 1151303,
                "title": "c-7-line-dp-explained-o-n-space-not-changing-obstaclegrid",
                "content": "First, we can use an (m+1) \\\\* (n+1) memo grid initialized with zero to solve the problem. This uses O(mn) space.\\n\\n(m+1) \\\\* (n+1) creates an extra row and column as shown below (circled in green). Using DP, we build from i=1,j=1 and stop at i=m,j=n (circled in red). If there is no obstacle, `grid[i][j] = grid[i-1][j] + grid[i][j-1`.\\n\\nNote that we must assign `grid[0][1]` to `1` so that `grid[1][1]` (the robot starting point) is computed as `1` (assuming `obstacleGrid[0][0]` is `0`).\\n\\n![image](https://assets.leetcode.com/users/images/cb4c390a-9487-45d9-b1ac-c5667962f351_1618046825.5591438.jpeg)\\n\\n```cpp\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tint m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n\\tvector<vector<int>> grid(m+1, vector<int>(n+1,0));\\n\\tgrid[0][1] = 1;\\n\\tfor (int i=1; i<m+1;++i)\\n\\t\\tfor (int j=1; j<n+1;++j)\\n\\t\\t\\tif (obstacleGrid[i-1][j-1] != 1)\\n\\t\\t\\t\\tgrid[i][j] = grid[i-1][j] + grid[i][j-1];\\n\\treturn grid[m][n];\\n}\\n```\\n\\nSimilar to problem 62, we can reduce the (m+1) \\\\* (n+1) memo grid to an **n+1** memo vector. This uses O(n) space. Again, we must assign `vec[1]` to `1` .\\n\\n```cpp\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tint m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n\\tvector<int> vec(n+1,0);\\n\\tvec[1]=1;\\n\\tfor (int i=0;i<m;++i)\\n\\t\\tfor (int j=1;j<n+1;++j)\\n\\t\\t\\tvec[j] = obstacleGrid[i][j-1] == 1 ? 0 : vec[j]+vec[j-1];\\n\\treturn vec[n];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tint m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n\\tvector<vector<int>> grid(m+1, vector<int>(n+1,0));\\n\\tgrid[0][1] = 1;\\n\\tfor (int i=1; i<m+1;++i)\\n\\t\\tfor (int j=1; j<n+1;++j)\\n\\t\\t\\tif (obstacleGrid[i-1][j-1] != 1)\\n\\t\\t\\t\\tgrid[i][j] = grid[i-1][j] + grid[i][j-1];\\n\\treturn grid[m][n];\\n}\\n```\n```cpp\\nint uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n\\tint m = obstacleGrid.size(), n = obstacleGrid[0].size();\\n\\tvector<int> vec(n+1,0);\\n\\tvec[1]=1;\\n\\tfor (int i=0;i<m;++i)\\n\\t\\tfor (int j=1;j<n+1;++j)\\n\\t\\t\\tvec[j] = obstacleGrid[i][j-1] == 1 ? 0 : vec[j]+vec[j-1];\\n\\treturn vec[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627199,
                "title": "java-solution-beats-100-with-dfs-memoization",
                "content": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\t\\t// check if there is no block at ent point\\n        if (obstacleGrid[obstacleGrid.length -1][obstacleGrid[0].length - 1] == 1) {\\n            return 0;\\n        }\\n\\t\\t// mem[i][j] is the count of paths from (i, j) to end point\\n        int[][] mem = new int[obstacleGrid.length][obstacleGrid[0].length];   \\n        for (int[] row : mem) {\\n            Arrays.fill(row, -1);            \\n        }\\n        return dfs(obstacleGrid, 0, 0, mem);\\n    }\\n    \\n    private int dfs(int[][] a, int i, int j, int[][] mem) {\\n        if (i == a.length - 1 && j == a[0].length - 1) {\\n            return 1;\\n        }\\n        if (i >= a.length || j >= a[0].length || a[i][j] == 1) {\\n            return 0;\\n        }\\n        \\n        int count = mem[i][j];\\n        if (mem[i][j] == -1) {\\n            count = dfs(a, i + 1, j, mem) + dfs(a, i, j + 1, mem);\\n            mem[i][j] = count;            \\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\nTime: O(m * n) since we will visit some point at most twice(once from the point above it and once from the point on its left)\\n\\nSpace: O(m * n) since we need a 2d array mem, the recursion depth is at most m + n which is less than m * n when m >= 2, n >= 2",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0)\\n            return 0;\\n\\t\\t// check if there is no block at ent point\\n        if (obstacleGrid[obstacleGrid.length -1][obstacleGrid[0].length - 1] == 1) {\\n            return 0;\\n        }\\n\\t\\t// mem[i][j] is the count of paths from (i, j) to end point\\n        int[][] mem = new int[obstacleGrid.length][obstacleGrid[0].length];   \\n        for (int[] row : mem) {\\n            Arrays.fill(row, -1);            \\n        }\\n        return dfs(obstacleGrid, 0, 0, mem);\\n    }\\n    \\n    private int dfs(int[][] a, int i, int j, int[][] mem) {\\n        if (i == a.length - 1 && j == a[0].length - 1) {\\n            return 1;\\n        }\\n        if (i >= a.length || j >= a[0].length || a[i][j] == 1) {\\n            return 0;\\n        }\\n        \\n        int count = mem[i][j];\\n        if (mem[i][j] == -1) {\\n            count = dfs(a, i + 1, j, mem) + dfs(a, i, j + 1, mem);\\n            mem[i][j] = count;            \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562340,
                "title": "python-dfs-memoization",
                "content": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid:\\n            return 0\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1]:\\n            return 0\\n        \\n        mem = dict()\\n        return self.findPaths(0, 0, obstacleGrid, mem)\\n    \\n    \\n    \\n    def findPaths(self, i, j, grid, mem):\\n        if (i,j) in mem:\\n            return mem[(i,j)]\\n        \\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\\n            return 1\\n        \\n        c = 0\\n        for x, y in [(i+1,j), (i, j+1)]:\\n            if x < len(grid) and y < len(grid[0]) and not grid[x][y]:\\n                c += self.findPaths(x, y, grid, mem)\\n        \\n        mem[(i,j)] = c\\n        return c\\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        if not obstacleGrid:\\n            return 0\\n        \\n        if obstacleGrid[0][0] == 1 or obstacleGrid[-1][-1]:\\n            return 0\\n        \\n        mem = dict()\\n        return self.findPaths(0, 0, obstacleGrid, mem)\\n    \\n    \\n    \\n    def findPaths(self, i, j, grid, mem):\\n        if (i,j) in mem:\\n            return mem[(i,j)]\\n        \\n        if i == len(grid) - 1 and j == len(grid[0]) - 1:\\n            return 1\\n        \\n        c = 0\\n        for x, y in [(i+1,j), (i, j+1)]:\\n            if x < len(grid) and y < len(grid[0]) and not grid[x][y]:\\n                c += self.findPaths(x, y, grid, mem)\\n        \\n        mem[(i,j)] = c\\n        return c\\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 488683,
                "title": "javascript-dynamic-programming",
                "content": "```js\\nfunction uniquePathsWithObstacles(obstacleGrid) {\\n  if (obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1] === 1) {\\n    return 0;\\n  }\\n  let dp = new Array(obstacleGrid.length)\\n    .fill()\\n    .map(row => new Array(obstacleGrid[0].length).fill(0));\\n  dp[0][0] = obstacleGrid[0][0] === 0 ? 1 : 0;\\n  for (let i = 0; i < obstacleGrid.length; i++) {\\n    for (let j = 0; j < obstacleGrid[0].length; j++) {\\n      let up = i - 1 >= 0 && obstacleGrid[i - 1][j] !== 1 ? dp[i - 1][j] : 0;\\n      let left = j - 1 >= 0 && obstacleGrid[i][j - 1] !== 1 ? dp[i][j - 1] : 0;\\n      dp[i][j] += +up + left;\\n    }\\n  }\\n  return dp[dp.length - 1][dp[0].length - 1];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```js\\nfunction uniquePathsWithObstacles(obstacleGrid) {\\n  if (obstacleGrid[obstacleGrid.length - 1][obstacleGrid[0].length - 1] === 1) {\\n    return 0;\\n  }\\n  let dp = new Array(obstacleGrid.length)\\n    .fill()\\n    .map(row => new Array(obstacleGrid[0].length).fill(0));\\n  dp[0][0] = obstacleGrid[0][0] === 0 ? 1 : 0;\\n  for (let i = 0; i < obstacleGrid.length; i++) {\\n    for (let j = 0; j < obstacleGrid[0].length; j++) {\\n      let up = i - 1 >= 0 && obstacleGrid[i - 1][j] !== 1 ? dp[i - 1][j] : 0;\\n      let left = j - 1 >= 0 && obstacleGrid[i][j - 1] !== 1 ? dp[i][j - 1] : 0;\\n      dp[i][j] += +up + left;\\n    }\\n  }\\n  return dp[dp.length - 1][dp[0].length - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391947,
                "title": "integer-overflow",
                "content": "Not sure how to avoid integer overflow as I have even tried solution provided by leetcode\\n\\nLeetcode solution is in Java and in C++ when I run below code it genrated run time failure\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void print(vector<vector<int>>& obstacleGrid) {\\n        const int x = obstacleGrid.size();\\n        const int y = obstacleGrid[0].size();\\n        \\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == -1) {\\n                    cout << \"x \";\\n                    continue;\\n                }\\n                cout << obstacleGrid[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        cout << \"========================\" << endl;\\n    }\\n        \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        const int x = obstacleGrid.size();\\n        const int y = obstacleGrid[0].size();\\n        cout << \"x = \" << x << \", y = \" << y << endl;\\n        \\n        if (x == 1 && y == 1 && obstacleGrid[0][0] == 1) return 0;\\n        if (x == 1 && y == 1 && obstacleGrid[0][0] == 0) return 1;        \\n                \\n        if (obstacleGrid[x - 1][y - 1] == 1 ||\\n            obstacleGrid[0][0] == 1) return 0;\\n        \\n        print(obstacleGrid);\\n        \\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = 0;\\n                    continue;\\n                }\\n                \\n                if (i == 0) {\\n                    if (j == 0) {\\n                        obstacleGrid[i][j] = 1;\\n                    } else if (obstacleGrid[i][j] == 1) {\\n                        obstacleGrid[i][j] = 0;\\n                    } else {\\n                        obstacleGrid[i][j] = obstacleGrid[i][j - 1];\\n                    }\\n                    continue;\\n                }\\n                \\n                if (j == 0) {\\n                    if (obstacleGrid[i][j] == 0) {\\n                        obstacleGrid[i][j] = obstacleGrid[i-1][j];    \\n                    } else if (obstacleGrid[i][j] == 1){\\n                        obstacleGrid[i][j] = 0;\\n                    }\\n                    continue;\\n                }                \\n                    \\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n            }\\n            print(obstacleGrid);\\n        }\\n        \\n        \\n        return obstacleGrid[x - 1][y - 1];\\n        \\n        \\n    }\\n};\\n\\n\\n0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 \\n0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 \\n1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 \\n0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 \\n0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 \\n1 0 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \\n0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 \\n0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 \\n0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 \\n1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 1 \\n0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 \\n0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 \\n0 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 \\n1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 \\n0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 1 \\n0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 1 \\n1 1 1 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 \\n0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 \\n0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 \\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void print(vector<vector<int>>& obstacleGrid) {\\n        const int x = obstacleGrid.size();\\n        const int y = obstacleGrid[0].size();\\n        \\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == -1) {\\n                    cout << \"x \";\\n                    continue;\\n                }\\n                cout << obstacleGrid[i][j] << \" \";\\n            }\\n            cout << endl;\\n        }\\n        cout << \"========================\" << endl;\\n    }\\n        \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        const int x = obstacleGrid.size();\\n        const int y = obstacleGrid[0].size();\\n        cout << \"x = \" << x << \", y = \" << y << endl;\\n        \\n        if (x == 1 && y == 1 && obstacleGrid[0][0] == 1) return 0;\\n        if (x == 1 && y == 1 && obstacleGrid[0][0] == 0) return 1;        \\n                \\n        if (obstacleGrid[x - 1][y - 1] == 1 ||\\n            obstacleGrid[0][0] == 1) return 0;\\n        \\n        print(obstacleGrid);\\n        \\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = 0;\\n                    continue;\\n                }\\n                \\n                if (i == 0) {\\n                    if (j == 0) {\\n                        obstacleGrid[i][j] = 1;\\n                    } else if (obstacleGrid[i][j] == 1) {\\n                        obstacleGrid[i][j] = 0;\\n                    } else {\\n                        obstacleGrid[i][j] = obstacleGrid[i][j - 1];\\n                    }\\n                    continue;\\n                }\\n                \\n                if (j == 0) {\\n                    if (obstacleGrid[i][j] == 0) {\\n                        obstacleGrid[i][j] = obstacleGrid[i-1][j];    \\n                    } else if (obstacleGrid[i][j] == 1){\\n                        obstacleGrid[i][j] = 0;\\n                    }\\n                    continue;\\n                }                \\n                    \\n                obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\\n            }\\n            print(obstacleGrid);\\n        }\\n        \\n        \\n        return obstacleGrid[x - 1][y - 1];\\n        \\n        \\n    }\\n};\\n\\n\\n0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 \\n0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 \\n1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 1 \\n0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 \\n0 0 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 \\n1 0 1 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \\n0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 \\n0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 0 0 \\n0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 \\n1 0 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 1 0 0 0 1 0 1 0 0 0 0 1 \\n0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 0 0 0 \\n0 1 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 0 0 \\n0 1 0 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 0 1 \\n1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 \\n0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 1 \\n0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 1 0 1 \\n1 1 1 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0 \\n0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 \\n0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 0 1 0 0 0 \\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 391913,
                "title": "python-two-approaches-dfs-and-dp-with-comments-and-explanation",
                "content": "# Approach 1 - DFS - TLE (27/34) TEST CASES #\\n**Idea:**\\nSince the movement in the grid is restricted only to moving right and down, the grid can be thought of - represented as- a DAG in which each node has at max two childs (or each cell has two neighbouring cells to visit). With this analysis in mind, this problem reduces to something very similar to **Print all paths of binary tree** \\n\\nWe can use an implicit stack to run a basic DFS algorithm on the DAG\\'s root (root = top-left cell in the grid aka matrix[0][0]. A counter is mainatined to keep track of the paths every time we reach the target cell (or the leaf node, if you prefer the BT analogy). We know we have reached the target (leaf node) if the x,y coordinates are equal to m,n. \\n\\n- Note:\\n\\t-  In a basic DFS on a graph, most implementations require a visited set to make sure we\\'re not going around in circles as we traverse the graph. However, this is not necessary in this problem because our graph is:\\n\\t\\t 1) Directed \\n \\t\\t\\t  - because movement is restricted to **(right, down in the grid)** which is **synonmoys to ( traversing once to the left child and then to the right child in a BT)**\\n\\t\\t2) Acyclic:\\n\\t\\t\\t- same reason (links are one-way)\\n\\t\\t3) Binary \\n\\t\\t\\t- Because only two direction out of possible 4 are allowed\\n\\t\\t\\t\\n\\t- In summary, our graph is not a graph, it\\'s a binary tree. And we know that traversal will always moving down the tree. so we don\\'t have to worry about encountring the same node (or cell) again.*\\n\\n\\n**Time Complexity :**\\n- O(num) where num is the number of nodes in the matrix \\n\\t- *in reality O(num*2) --> because for each node, there are 2 neighbours that we need to iterate over but howevevr, asymptotically boils down to O(num)\\n\\n- Or O(N*M) where N and M are the dimesnions of the matrix\\n\\n**Space Complexity:**\\n- O(num) where num is the number of nodes in the matrix because we had to use a stack\\n- Or O(N*M) where N and M are the dimensions of the grid\\n\\n\\n**Code**\\n\\n```\\n        m = obstacleGrid\\n        if not m or len(m) == 0 or m==[[]] or m[0][0] == 1:\\n            return 0\\n        res = []\\n        count = 0\\n        stack = [((0,0), m[0][0], [(0,0)])]\\n        dirs = [(1,0), (0,1)] # only move down the tree\\n        while stack:\\n            print(stack)\\n            coor, node, path = stack.pop()\\n            x, y = coor\\n            \\n            if x == len(m)-1 and y == len(m[0])-1: # leaf - bottom right\\n                count += 1\\n                res.append(path)\\n            \\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                # check if within bounds:\\n                if newX >= 0 and newX <= len(m)-1 and newY >= 0 and newY <= len(m[0])-1:\\n                    # check if no obstacle:\\n                    if m[newX][newY] != 1:\\n                        # append to stack\\n                        stack.append(((newX, newY), m[newX][newY], path+[(newX, newY)]))\\n        # print(res)\\n        return count\\n\\n```\\n\\n# Approach 2 - Dynamic Programming #\\n\\n**Leetcode Solution**\\n\\n**Time complexity**\\n- O(num) where is the num of nodes in the matrix (num of cells)\\n\\t- Each node/cell is visited only once\\n-  Or O(N*M) where N and M are the grid\\'s dimensions\\n              \\n**Space compleixty**\\n- O(1) in=place modification\\n\\n**Code**\\n```\\n\\t\\tm = obstacleGrid\\n        if not m or m == [[]] or len(m)==0 or m[0][0] == 1:\\n            return 0\\n        \\n        # start:\\n        m[0][0] = 1\\n        \\n        # top row:\\n        for i in range(1, len(m[0])):\\n            if m[0][i] == 1: # obstacle\\n                m[0][i] = 0\\n            else:\\n                m[0][i] = m[0][i-1] # previous cell (cell to the left)\\n                \\n        # left most col:\\n        for i in range(1, len(m)):\\n            if m[i][0] == 1: # obstacle\\n                m[i][0] = 0\\n            else:\\n                m[i][0] = m[i-1][0] # previous cell (cell to the top)\\n                \\n        # rest of the grid:\\n        for i in range(1, len(m)):\\n            for j in range(1, len(m[0])):\\n                if m[i][j] == 1:\\n                    m[i][j] = 0\\n                else:\\n                    m[i][j] = m[i-1][j] + m[i][j-1]\\n                    \\n        return m[len(m)-1][len(m[0])-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n        m = obstacleGrid\\n        if not m or len(m) == 0 or m==[[]] or m[0][0] == 1:\\n            return 0\\n        res = []\\n        count = 0\\n        stack = [((0,0), m[0][0], [(0,0)])]\\n        dirs = [(1,0), (0,1)] # only move down the tree\\n        while stack:\\n            print(stack)\\n            coor, node, path = stack.pop()\\n            x, y = coor\\n            \\n            if x == len(m)-1 and y == len(m[0])-1: # leaf - bottom right\\n                count += 1\\n                res.append(path)\\n            \\n            for dir in dirs:\\n                newX, newY = x+dir[0], y+dir[1]\\n                # check if within bounds:\\n                if newX >= 0 and newX <= len(m)-1 and newY >= 0 and newY <= len(m[0])-1:\\n                    # check if no obstacle:\\n                    if m[newX][newY] != 1:\\n                        # append to stack\\n                        stack.append(((newX, newY), m[newX][newY], path+[(newX, newY)]))\\n        # print(res)\\n        return count\\n\\n```\n```\\n\\t\\tm = obstacleGrid\\n        if not m or m == [[]] or len(m)==0 or m[0][0] == 1:\\n            return 0\\n        \\n        # start:\\n        m[0][0] = 1\\n        \\n        # top row:\\n        for i in range(1, len(m[0])):\\n            if m[0][i] == 1: # obstacle\\n                m[0][i] = 0\\n            else:\\n                m[0][i] = m[0][i-1] # previous cell (cell to the left)\\n                \\n        # left most col:\\n        for i in range(1, len(m)):\\n            if m[i][0] == 1: # obstacle\\n                m[i][0] = 0\\n            else:\\n                m[i][0] = m[i-1][0] # previous cell (cell to the top)\\n                \\n        # rest of the grid:\\n        for i in range(1, len(m)):\\n            for j in range(1, len(m[0])):\\n                if m[i][j] == 1:\\n                    m[i][j] = 0\\n                else:\\n                    m[i][j] = m[i-1][j] + m[i][j-1]\\n                    \\n        return m[len(m)-1][len(m[0])-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 370976,
                "title": "c-solution-beats-100-percent-time-and-memory",
                "content": "class Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[0][0] == 1)return 0;\\n        \\n        vector<unsigned int> dp(n);\\n \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(obstacleGrid[i][j]) dp[j] = 0;\\n                else if(i == 0 && j == 0) dp[j] = 1;\\n                else if(i==0) dp[j] = dp[j-1];\\n                else if(j==0) dp[j] = dp[j];\\n                else dp[j] += dp[j-1];\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        \\n        if(obstacleGrid[0][0] == 1)return 0;\\n        \\n        vector<unsigned int> dp(n);\\n \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(obstacleGrid[i][j]) dp[j] = 0;\\n                else if(i == 0 && j == 0) dp[j] = 1;\\n                else if(i==0) dp[j] = dp[j-1];\\n                else if(j==0) dp[j] = dp[j];\\n                else dp[j] += dp[j-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 312569,
                "title": "swift-my-dp-solution-o-n-m-runtime-complexity-save-pricess-from-big-bad-gorilla",
                "content": "```\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        \\n        var width = obstacleGrid.count\\n        if width == 0 { return 0 }\\n        var height = obstacleGrid[0].count\\n        if height == 0 { return 0 }\\n        \\n        if obstacleGrid[0][0] != 0 || obstacleGrid[width-1][height-1] != 0 { return 0 }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: height), count: width)\\n        \\n        grid[width-1][height-1] = 1\\n        \\n        var x = width - 2\\n        while x >= 0 { \\n            if obstacleGrid[x][height-1] == 0 { grid[x][height-1] = grid[x+1][height-1] }\\n            x -= 1\\n        }\\n        \\n        var y = height - 2\\n        while y >= 0 {\\n            if obstacleGrid[width-1][y] == 0 { grid[width-1][y] = grid[width-1][y+1] }\\n            y -= 1\\n        }\\n        \\n        y = height - 2\\n        while y >= 0 {\\n            x = width - 2\\n            while x >= 0 {\\n                if obstacleGrid[x][y] != 0 {\\n                    x -= 1\\n                    continue\\n                }\\n                if obstacleGrid[x+1][y] == 0 { grid[x][y] += grid[x+1][y] }\\n                if obstacleGrid[x][y+1] == 0 { grid[x][y] += grid[x][y+1] }\\n                x -= 1\\n            }\\n            y -= 1\\n        }\\n        \\n        print(grid)\\n        return grid[0][0]\\n    }\\n}\\n```\\n\\nKaboom, Baby",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        \\n        var width = obstacleGrid.count\\n        if width == 0 { return 0 }\\n        var height = obstacleGrid[0].count\\n        if height == 0 { return 0 }\\n        \\n        if obstacleGrid[0][0] != 0 || obstacleGrid[width-1][height-1] != 0 { return 0 }\\n        \\n        var grid = [[Int]](repeating: [Int](repeating: 0, count: height), count: width)\\n        \\n        grid[width-1][height-1] = 1\\n        \\n        var x = width - 2\\n        while x >= 0 { \\n            if obstacleGrid[x][height-1] == 0 { grid[x][height-1] = grid[x+1][height-1] }\\n            x -= 1\\n        }\\n        \\n        var y = height - 2\\n        while y >= 0 {\\n            if obstacleGrid[width-1][y] == 0 { grid[width-1][y] = grid[width-1][y+1] }\\n            y -= 1\\n        }\\n        \\n        y = height - 2\\n        while y >= 0 {\\n            x = width - 2\\n            while x >= 0 {\\n                if obstacleGrid[x][y] != 0 {\\n                    x -= 1\\n                    continue\\n                }\\n                if obstacleGrid[x+1][y] == 0 { grid[x][y] += grid[x+1][y] }\\n                if obstacleGrid[x][y+1] == 0 { grid[x][y] += grid[x][y+1] }\\n                x -= 1\\n            }\\n            y -= 1\\n        }\\n        \\n        print(grid)\\n        return grid[0][0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312520,
                "title": "c-check-out-my-dp-badass-methodology-o-n-m-use-the-force-luke",
                "content": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        int aWidth = obstacleGrid.size();\\n        if (aWidth <= 0) { return 0; }\\n        int aHeight = obstacleGrid[0].size();\\n        if (aHeight <= 0) { return 0; }\\n        if (obstacleGrid[0][0]) { return 0; }\\n        if (obstacleGrid[aWidth-1][aHeight-1]) { return 0; }\\n        \\n        long aWays[aWidth][aHeight];\\n        memset(aWays, 0, sizeof(aWays));\\n        \\n        aWays[aWidth-1][aHeight-1] = 1;\\n        \\n        for (int aX=aWidth-2;aX>=0;aX--) {\\n            if (obstacleGrid[aX][aHeight-1] == 0) { aWays[aX][aHeight-1] = aWays[aX+1][aHeight-1]; }\\n        }\\n        \\n        for (int aY=aHeight-2;aY>=0;aY--) {\\n            if (obstacleGrid[aWidth-1][aY] == 0) { aWays[aWidth-1][aY] = aWays[aWidth-1][aY+1]; }\\n        }\\n        \\n        for (int aY=aHeight-2;aY>=0;aY--) {\\n            for (int aX=aWidth-2;aX>=0;aX--) {\\n                if (obstacleGrid[aX][aY] != 0) { continue; }\\n                if (obstacleGrid[aX+1][aY] == 0) { aWays[aX][aY] += aWays[aX+1][aY]; }\\n                if (obstacleGrid[aX][aY+1] == 0) { aWays[aX][aY] += aWays[aX][aY+1]; }\\n            }\\n        }\\n        \\n        return aWays[0][0];\\n        \\n    }\\n};\\n```\\n\\nKeep an eye out for Lord Vader or you\\'re going up against the cheese grater.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        \\n        int aWidth = obstacleGrid.size();\\n        if (aWidth <= 0) { return 0; }\\n        int aHeight = obstacleGrid[0].size();\\n        if (aHeight <= 0) { return 0; }\\n        if (obstacleGrid[0][0]) { return 0; }\\n        if (obstacleGrid[aWidth-1][aHeight-1]) { return 0; }\\n        \\n        long aWays[aWidth][aHeight];\\n        memset(aWays, 0, sizeof(aWays));\\n        \\n        aWays[aWidth-1][aHeight-1] = 1;\\n        \\n        for (int aX=aWidth-2;aX>=0;aX--) {\\n            if (obstacleGrid[aX][aHeight-1] == 0) { aWays[aX][aHeight-1] = aWays[aX+1][aHeight-1]; }\\n        }\\n        \\n        for (int aY=aHeight-2;aY>=0;aY--) {\\n            if (obstacleGrid[aWidth-1][aY] == 0) { aWays[aWidth-1][aY] = aWays[aWidth-1][aY+1]; }\\n        }\\n        \\n        for (int aY=aHeight-2;aY>=0;aY--) {\\n            for (int aX=aWidth-2;aX>=0;aX--) {\\n                if (obstacleGrid[aX][aY] != 0) { continue; }\\n                if (obstacleGrid[aX+1][aY] == 0) { aWays[aX][aY] += aWays[aX+1][aY]; }\\n                if (obstacleGrid[aX][aY+1] == 0) { aWays[aX][aY] += aWays[aX][aY+1]; }\\n            }\\n        }\\n        \\n        return aWays[0][0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222174,
                "title": "python-solution",
                "content": "Dynamic programming `O(nm)` time, `O(nm)` space.\\n\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not obstacleGrid or not obstacleGrid[0]:\\n            return 0\\n        m = len(obstacleGrid)\\n        n = len(obstacleGrid[0])\\n        dp = [[0]*n for _ in range(m)]\\n        if obstacleGrid[0][0] == 0:\\n            dp[0][0] = 1\\n        else:\\n            return 0\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    continue\\n                if i > 0:\\n                    dp[i][j] += dp[i-1][j]\\n                if j > 0:\\n                    dp[i][j] += dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid):\\n        \"\"\"\\n        :type obstacleGrid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not obstacleGrid or not obstacleGrid[0]:\\n            return 0\\n        m = len(obstacleGrid)\\n        n = len(obstacleGrid[0])\\n        dp = [[0]*n for _ in range(m)]\\n        if obstacleGrid[0][0] == 0:\\n            dp[0][0] = 1\\n        else:\\n            return 0\\n        for i in range(m):\\n            for j in range(n):\\n                if obstacleGrid[i][j] == 1:\\n                    continue\\n                if i > 0:\\n                    dp[i][j] += dp[i-1][j]\\n                if j > 0:\\n                    dp[i][j] += dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168428,
                "title": "swift-solution-12ms",
                "content": "```\\n//for example, input: [[0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0]]\\n\\n//0, 1, 0, 0, 0, 0, 0 \\n//0, 1, 1, 1, 1, 1, 1\\n//0, 1, 2, 0, 1, 2, 3\\n//0, 1, 3, 3, 4, 6, 9\\n\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        var m = obstacleGrid.count\\n        var n = obstacleGrid[0].count\\n        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)\\n        \\n        dp[0][1] = 1 // start point\\n        \\n        for i in 1 ... m {\\n            for j in 1 ... n {\\n                if obstacleGrid[i - 1][j - 1] != 1 {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n                }\\n            }\\n        }\\n        return dp[m][n]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//for example, input: [[0, 0, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0]]\\n\\n//0, 1, 0, 0, 0, 0, 0 \\n//0, 1, 1, 1, 1, 1, 1\\n//0, 1, 2, 0, 1, 2, 3\\n//0, 1, 3, 3, 4, 6, 9\\n\\nclass Solution {\\n    func uniquePathsWithObstacles(_ obstacleGrid: [[Int]]) -> Int {\\n        var m = obstacleGrid.count\\n        var n = obstacleGrid[0].count\\n        var dp = Array(repeating: Array(repeating: 0, count: n + 1), count: m + 1)\\n        \\n        dp[0][1] = 1 // start point\\n        \\n        for i in 1 ... m {\\n            for j in 1 ... n {\\n                if obstacleGrid[i - 1][j - 1] != 1 {\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n                }\\n            }\\n        }\\n        return dp[m][n]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164093,
                "title": "easy-understand-java-solution",
                "content": "```\\nclass Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int rowLen = obstacleGrid.length;\\n            int colLen = obstacleGrid[0].length;\\n            if (obstacleGrid[0][0] == 1 || obstacleGrid[rowLen - 1][colLen - 1] == 1)\\n                return 0;\\n            int[][] dp = new int[rowLen + 1][colLen + 1];\\n            dp[1][1] = 1;\\n            for (int i = 0; i < rowLen; i++) {\\n                for (int j = 0; j < colLen; j++) {\\n                    if (obstacleGrid[i][j] == 1) {\\n                        dp[i + 1][j + 1] = 0;\\n                        continue;\\n                    }\\n                    if (!(i == 0 && j == 0)) {\\n                        dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j];\\n                    }\\n                }\\n            }\\n            return dp[rowLen][colLen];\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int rowLen = obstacleGrid.length;\\n            int colLen = obstacleGrid[0].length;\\n            if (obstacleGrid[0][0] == 1 || obstacleGrid[rowLen - 1][colLen - 1] == 1)\\n                return 0;\\n            int[][] dp = new int[rowLen + 1][colLen + 1];\\n            dp[1][1] = 1;\\n            for (int i = 0; i < rowLen; i++) {\\n                for (int j = 0; j < colLen; j++) {\\n                    if (obstacleGrid[i][j] == 1) {\\n                        dp[i + 1][j + 1] = 0;\\n                        continue;\\n                    }\\n                    if (!(i == 0 && j == 0)) {\\n                        dp[i + 1][j + 1] = dp[i][j + 1] + dp[i + 1][j];\\n                    }\\n                }\\n            }\\n            return dp[rowLen][colLen];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23249,
                "title": "java-3-solutions-recursion-memoization-dp",
                "content": "1. Plain recursion\\n\\n```\\nclass Solution {\\n    int[][] matrix;\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        matrix = obstacleGrid;\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] ==  1) {\\n            return 0;\\n        }\\n        return paths(matrix.length-1, matrix[0].length-1);\\n        \\n    }\\n    \\n    private int paths(int m, int n){\\n        \\n        if(m == 0 && n == 0) return 1;\\n        \\n        if(m<0 || n<0 || matrix[m][n] == 1) return 0;\\n        \\n        return paths(m-1,n)+paths(m,n-1);\\n        \\n    }\\n}\\n\\n```\\n\\n2. Memoization\\n\\n```\\nclass Solution {\\n    int[][] matrix;\\n    Map<String, Integer> cache;\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        matrix = obstacleGrid;\\n        cache = new HashMap<String, Integer>();\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] ==  1) {\\n            return 0;\\n        }\\n        return paths(matrix.length-1, matrix[0].length-1);\\n        \\n    }\\n    \\n    private int paths(int m, int n){\\n        String str = m + \",\" + n;\\n        \\n        if(cache.containsKey(str)){\\n            return cache.get(str);\\n        }\\n        \\n        if(m == 0 && n == 0) return 1;\\n        \\n        if(m<0 || n<0 || matrix[m][n] == 1) return 0;\\n        \\n        cache.put(str, paths(m-1,n)+paths(m,n-1));\\n        \\n        return cache.get(str);\\n    }\\n}\\n\\n```\\n\\n3. DP\\n\\n```\\nclass Solution {\\n   \\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n       if(obstacleGrid.length==0 || obstacleGrid[0].length==0 ) {\\n           return 0;\\n       }\\n       \\n       int m=obstacleGrid.length;\\n       int n=obstacleGrid[0].length;\\n       \\n        int dp[][] = new int[m][n];\\n       \\n        if(obstacleGrid[0][0]==1 || obstacleGrid[m-1][n-1]==1) {\\n            return 0;\\n        }\\n        \\n        dp[0][0]=1;\\n        \\n        for(int i=1; i<m; i++) {\\n            \\n            if (obstacleGrid[i][0]==1) {\\n                dp[i][0]=0;\\n            } else {\\n                dp[i][0]=dp[i-1][0];\\n            }\\n        }\\n        \\n        for(int j=1; j<n; j++){\\n            \\n            if(obstacleGrid[0][j]==1) {\\n                dp[0][j]=0;\\n            }\\n            else {\\n                dp[0][j]=dp[0][j-1];\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++) {\\n            for(int j=1; j<n; j++) {\\n                \\n                if(obstacleGrid[i][j]==1) {\\n                    dp[i][j]=0;\\n                }\\n                else {\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] matrix;\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        matrix = obstacleGrid;\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] ==  1) {\\n            return 0;\\n        }\\n        return paths(matrix.length-1, matrix[0].length-1);\\n        \\n    }\\n    \\n    private int paths(int m, int n){\\n        \\n        if(m == 0 && n == 0) return 1;\\n        \\n        if(m<0 || n<0 || matrix[m][n] == 1) return 0;\\n        \\n        return paths(m-1,n)+paths(m,n-1);\\n        \\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    int[][] matrix;\\n    Map<String, Integer> cache;\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n        matrix = obstacleGrid;\\n        cache = new HashMap<String, Integer>();\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0 || matrix[0][0] ==  1) {\\n            return 0;\\n        }\\n        return paths(matrix.length-1, matrix[0].length-1);\\n        \\n    }\\n    \\n    private int paths(int m, int n){\\n        String str = m + \",\" + n;\\n        \\n        if(cache.containsKey(str)){\\n            return cache.get(str);\\n        }\\n        \\n        if(m == 0 && n == 0) return 1;\\n        \\n        if(m<0 || n<0 || matrix[m][n] == 1) return 0;\\n        \\n        cache.put(str, paths(m-1,n)+paths(m,n-1));\\n        \\n        return cache.get(str);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n   \\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        \\n       if(obstacleGrid.length==0 || obstacleGrid[0].length==0 ) {\\n           return 0;\\n       }\\n       \\n       int m=obstacleGrid.length;\\n       int n=obstacleGrid[0].length;\\n       \\n        int dp[][] = new int[m][n];\\n       \\n        if(obstacleGrid[0][0]==1 || obstacleGrid[m-1][n-1]==1) {\\n            return 0;\\n        }\\n        \\n        dp[0][0]=1;\\n        \\n        for(int i=1; i<m; i++) {\\n            \\n            if (obstacleGrid[i][0]==1) {\\n                dp[i][0]=0;\\n            } else {\\n                dp[i][0]=dp[i-1][0];\\n            }\\n        }\\n        \\n        for(int j=1; j<n; j++){\\n            \\n            if(obstacleGrid[0][j]==1) {\\n                dp[0][j]=0;\\n            }\\n            else {\\n                dp[0][j]=dp[0][j-1];\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++) {\\n            for(int j=1; j<n; j++) {\\n                \\n                if(obstacleGrid[i][j]==1) {\\n                    dp[i][j]=0;\\n                }\\n                else {\\n                    dp[i][j]=dp[i-1][j]+dp[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][n-1];\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 23394,
                "title": "a-little-change-based-on-unique-path-java-solution-using-dp",
                "content": "    public class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int m = obstacleGrid.length;\\n            int n = obstacleGrid[0].length;\\n            int[][] dp = new int[m][n];\\n            for(int i = 0; i < m; i ++) {\\n                if(obstacleGrid[i][0] == 1) {\\n                    dp[i][0] = 0;\\n                    break;\\n                } else {\\n                    dp[i][0] = 1;\\n                }\\n            }\\n            \\n            for(int j = 0; j < n; j ++) {\\n                if(obstacleGrid[0][j] == 1) {\\n                    dp[0][j] = 0;\\n                    break;\\n                } else {\\n                    dp[0][j] = 1;\\n                }\\n            }\\n            \\n            for(int i = 1; i < m; i ++) {\\n                for(int j = 1; j < n; j ++) {\\n                    if(obstacleGrid[i][j] == 1) {\\n                        dp[i][j] = 0;\\n                    } else {\\n                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\\n                    }\\n                }\\n            }\\n            return dp[m - 1][n - 1];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n            int m = obstacleGrid.length;\\n            int n = obstacleGrid[0].length;\\n            int[][] dp = new int[m][n];\\n            for(int i = 0; i < m; i ++) {\\n                if(obstacleGrid[i][0] == 1) {\\n                    dp[i][0] = 0;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3992832,
                "title": "unique-paths-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if (grid[0][0] == 1) return 0;\\n\\n        grid[0][0] = 1;\\n\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = (i ? 0 : 1); j < n; ++j) { \\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    continue;\\n                }\\n                if (i > 0) grid[i][j] += grid[i-1][j];\\n                if (j > 0) grid[i][j] += grid[i][j-1];\\n            }\\n        }\\n\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if (grid[0][0] == 1) return 0;\\n\\n        grid[0][0] = 1;\\n\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = (i ? 0 : 1); j < n; ++j) { \\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    continue;\\n                }\\n                if (i > 0) grid[i][j] += grid[i-1][j];\\n                if (j > 0) grid[i][j] += grid[i][j-1];\\n            }\\n        }\\n\\n        return grid[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904108,
                "title": "c-solution-for-unique-paths-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the number of unique paths a robot can take to reach the bottom-right corner of a grid, while avoiding obstacles placed on certain cells. The robot can only move right or down.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe provided solution uses dynamic programming to solve the problem. It iterates through the grid and fills a 2D array dp where dp[i, j] represents the number of unique paths to reach the cell (i, j) from the top-left corner (0, 0). The dynamic programming recurrence relation is based on the idea that the number of unique paths to reach (i, j) is equal to the sum of the number of paths coming from the cell above (i - 1, j) and the cell on the left (i, j - 1) if the current cell is not an obstacle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe solution iterates through the grid of size m x n exactly once. Inside the nested loops, constant time operations are performed. Therefore, the time complexity of this solution is O(m * n), where m is the number of rows and n is the number of columns in the grid.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses an additional 2D array dp of the same size as the input grid to store the results of subproblems. Therefore, the space complexity of this solution is also O(m * n).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.Length;\\n        int n = obstacleGrid[0].Length;\\n        \\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) {\\n            return 0; // Start or destination is an obstacle\\n        }\\n        \\n        int[,] dp = new int[m, n];\\n        dp[0, 0] = 1;\\n        \\n        for (int i = 1; i < m; i++) {\\n            if (obstacleGrid[i][0] == 0) {\\n                dp[i, 0] = dp[i - 1, 0];\\n            }\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            if (obstacleGrid[0][j] == 0) {\\n                dp[0, j] = dp[0, j - 1];\\n            }\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (obstacleGrid[i][j] == 0) {\\n                    dp[i, j] = dp[i - 1, j] + dp[i, j - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1, n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int UniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int m = obstacleGrid.Length;\\n        int n = obstacleGrid[0].Length;\\n        \\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) {\\n            return 0; // Start or destination is an obstacle\\n        }\\n        \\n        int[,] dp = new int[m, n];\\n        dp[0, 0] = 1;\\n        \\n        for (int i = 1; i < m; i++) {\\n            if (obstacleGrid[i][0] == 0) {\\n                dp[i, 0] = dp[i - 1, 0];\\n            }\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            if (obstacleGrid[0][j] == 0) {\\n                dp[0, j] = dp[0, j - 1];\\n            }\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (obstacleGrid[i][j] == 0) {\\n                    dp[i, j] = dp[i - 1, j] + dp[i, j - 1];\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1, n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897923,
                "title": "simple-solution-with-explanation-from-top-down-to-bottom-up",
                "content": "Recursion Solution:\\n```\\nclass Solution {\\nprivate:\\n    int helper(int i, int j, vector<vector<int>>& A, vector<vector<int> > &Dp) {\\n        if(i >= A.size() || j >= A.front().size() || A[i][j] == 1) return 0;\\n         if(i == A.size()-1 && j == A.front().size()-1) return 1;\\n        if(Dp[i][j] != -1) return Dp[i][j];\\n        int op1 = helper(i+1, j, A, Dp);\\n        int op2 = helper(i, j+1, A, Dp);\\n        return Dp[i][j] = op1 + op2;\\n        }\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<vector<int> > Dp(r, vector<int>(c, -1));\\n        return helper(0, 0, A, Dp);\\n    }\\n};\\n```\\n\\nBottom Up Approach:\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<vector<long long> > Dp(r+1, vector<long long>(c+1, 0));\\n        for(int i=r-1;i>=0;i--)\\n        {\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(A[i][j] == 1)\\n                    Dp[i][j] = 0;\\n                else if(i == r-1 && j == c-1)\\n                    Dp[i][j] = 1;\\n                else {\\n                    Dp[i][j] = Dp[i+1][j] + Dp[i][j+1];\\n                }\\n            }\\n        }\\n        return Dp[0][0];\\n    }\\n};\\n```\\n\\nBottom up with 1D space:\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<long long> prev(c+1, 0);\\n        for(int i=r-1;i>=0;i--)\\n        {\\n            vector<long long> curr(c+1, 0);\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(A[i][j] == 1)\\n                    curr[j] = 0;\\n                else if(i == r-1 && j == c-1)\\n                    curr[j] = 1;\\n                else {\\n                    curr[j] = prev[j] + curr[j+1];\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```\\n\\nLet me know in the comments if you have any doubts!!\\nKeep Rocking!!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int helper(int i, int j, vector<vector<int>>& A, vector<vector<int> > &Dp) {\\n        if(i >= A.size() || j >= A.front().size() || A[i][j] == 1) return 0;\\n         if(i == A.size()-1 && j == A.front().size()-1) return 1;\\n        if(Dp[i][j] != -1) return Dp[i][j];\\n        int op1 = helper(i+1, j, A, Dp);\\n        int op2 = helper(i, j+1, A, Dp);\\n        return Dp[i][j] = op1 + op2;\\n        }\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<vector<int> > Dp(r, vector<int>(c, -1));\\n        return helper(0, 0, A, Dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<vector<long long> > Dp(r+1, vector<long long>(c+1, 0));\\n        for(int i=r-1;i>=0;i--)\\n        {\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(A[i][j] == 1)\\n                    Dp[i][j] = 0;\\n                else if(i == r-1 && j == c-1)\\n                    Dp[i][j] = 1;\\n                else {\\n                    Dp[i][j] = Dp[i+1][j] + Dp[i][j+1];\\n                }\\n            }\\n        }\\n        return Dp[0][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& A) {\\n        int r = A.size();\\n        int c = A.front().size();\\n        vector<long long> prev(c+1, 0);\\n        for(int i=r-1;i>=0;i--)\\n        {\\n            vector<long long> curr(c+1, 0);\\n            for(int j=c-1;j>=0;j--)\\n            {\\n                if(A[i][j] == 1)\\n                    curr[j] = 0;\\n                else if(i == r-1 && j == c-1)\\n                    curr[j] = 1;\\n                else {\\n                    curr[j] = prev[j] + curr[j+1];\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897901,
                "title": "line-by-line-code-explanation-begineer-friendly-code-memoization",
                "content": "We didn\\'t use visited cell concept because Robot can not visit **left or up direction** , in this Question Robot can only visit right and down direction. \\n\\n\\u2705\\u2705**Kindly upvote if you find helpful** \\u2705\\u2705\\n\\n# Complexity\\n- Time complexity:\\n- O(m*n)\\n\\n- Space complexity: \\n- O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m , n ; \\n    int t[101][101];\\n    int solve(vector<vector<int>>&Grid , int i , int j ){\\n        if( i >= m || j >= n || Grid[i][j]==1){//for out of bound and obstacle case \\n            return 0;\\n        }\\n        if(t[i][j] != -1) return t[i][j];\\n        if(i == m-1 && j == n-1){// we arrive goal \\n            return 1; // found 1 ways to reach at goal \\n        }\\n        int right=solve(Grid , i , j+1);//for ways to go right our column is increase by 1(J+1)\\n        int down=solve(Grid, i+1 , j);//for ways to go down our row(i) is inc. by 1(i+1)\\n        return t[i][j] = right+down; // return both ways to acheive goal\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        m = obstacleGrid.size();\\n        n = obstacleGrid[0].size();\\n        memset(t ,-1 , sizeof(t));\\n\\n        return solve( obstacleGrid , 0 , 0 );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m , n ; \\n    int t[101][101];\\n    int solve(vector<vector<int>>&Grid , int i , int j ){\\n        if( i >= m || j >= n || Grid[i][j]==1){//for out of bound and obstacle case \\n            return 0;\\n        }\\n        if(t[i][j] != -1) return t[i][j];\\n        if(i == m-1 && j == n-1){// we arrive goal \\n            return 1; // found 1 ways to reach at goal \\n        }\\n        int right=solve(Grid , i , j+1);//for ways to go right our column is increase by 1(J+1)\\n        int down=solve(Grid, i+1 , j);//for ways to go down our row(i) is inc. by 1(i+1)\\n        return t[i][j] = right+down; // return both ways to acheive goal\\n    }\\n\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        m = obstacleGrid.size();\\n        n = obstacleGrid[0].size();\\n        memset(t ,-1 , sizeof(t));\\n\\n        return solve( obstacleGrid , 0 , 0 );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897858,
                "title": "memoization-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& obstacleGrid, vector<vector<int>> &dp){\\n        if(i >= 0 && j >= 0 && obstacleGrid[i][j] == 1) return 0;\\n        if(i == 0 && j == 0) return 1;\\n        if(i < 0 || j < 0) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int up = f(i-1, j, obstacleGrid, dp);\\n        int left = f(i, j-1, obstacleGrid, dp);\\n\\n        return dp[i][j] = up+left;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return f(m-1, n-1, obstacleGrid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& obstacleGrid, vector<vector<int>> &dp){\\n        if(i >= 0 && j >= 0 && obstacleGrid[i][j] == 1) return 0;\\n        if(i == 0 && j == 0) return 1;\\n        if(i < 0 || j < 0) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int up = f(i-1, j, obstacleGrid, dp);\\n        int left = f(i, j-1, obstacleGrid, dp);\\n\\n        return dp[i][j] = up+left;\\n    }\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int m = obstacleGrid.size();\\n        int n = obstacleGrid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n        return f(m-1, n-1, obstacleGrid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897599,
                "title": "c-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& G) {\\n        int n = (int)G.size();\\n        int m = (int)G[0].size();\\n\\n        vector<vector<int>> dp(n + 4, vector<int> (m + 4, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 and j == 0  and !G[i][j]) {\\n                    dp[i][j] = 1;\\n                }\\n                else if (!G[i][j]) {\\n                    if (i) {\\n                        dp[i][j] += dp[i - 1][j];\\n                    }\\n                    if (j) {\\n                        dp[i][j] += dp[i][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& G) {\\n        int n = (int)G.size();\\n        int m = (int)G[0].size();\\n\\n        vector<vector<int>> dp(n + 4, vector<int> (m + 4, 0));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i == 0 and j == 0  and !G[i][j]) {\\n                    dp[i][j] = 1;\\n                }\\n                else if (!G[i][j]) {\\n                    if (i) {\\n                        dp[i][j] += dp[i - 1][j];\\n                    }\\n                    if (j) {\\n                        dp[i][j] += dp[i][j - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n - 1][m - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897438,
                "title": "easy-and-simple-explaination-recursion-with-2-observations-either-go-left-or-right",
                "content": "# Intuition\\nHere we just have to reach from one corner to another corner and calculate number of ways, you might think of applying some sort of graph algorithm like dfs. For every call of dfs made from a node if we enocunter a 1 then we\\'ve have to backtrack and come to a unvisited cell and then check for a valid position.\\n\\n# ****Here I just saw 2 things:\\n\\n1. Either we move to right \\n2. OR we move down****\\n\\nIf we encounter a 1, that\\'s not a valid path so that part in discarded.\\n\\nApart from if we are able to reach the other right corner grid[m-1][n-1], that\\'s a valid path.\\n\\n# Approach\\n\\nSo If you\\'re familiar with recursion \\nPlease check the code i\\'ll be adding comments there\\n\\n\\n#  Direction arrays for moving down or to the right\\nint dx[2] = {1,0};   \\nint dy[2] = {0,1};\\n\\n# checking bounds\\n\\nbool isok(int nx,int ny). \\n{\\n  return nx>= 0 && ny>=0 && nx<=n-1 && ny<=m-1;\\n}\\n\\n\\n\\n\\n# Current co - ordinates:\\nx,y;\\n\\nnew co-ordinates is given by\\n\\n    int nx = x+dx[0];\\n    int ny = y+dy[0];\\n\\n    int nx1 = x+dx[1];\\n    int ny1 = y+dy[1];\\n\\ncheck are they in bounds and then solve sub-problems for them\\n\\n\\n\\nIf it was helpful please upvote\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint dp[101][101];\\nint n,m;\\n\\nint dx[2] = {1,0};   // Direction arrays for moving down or to the right\\nint dy[2] = {0,1};\\n\\n\\n\\nbool isok(int nx,int ny). \\n{\\n  return nx>= 0 && ny>=0 && nx<=n-1 && ny<=m-1;\\n}\\n\\n\\nint solve(int x,int y,vector<vector<int>>& grid)\\n{\\n  if(grid[x][y] == 1)\\n  {\\n    return 0;\\n  }\\n\\n  if(dp[x][y] != -1) return dp[x][y];\\n  if(x == n-1 && y== m-1) return 1;\\n \\n    int nx = x+dx[0];\\n    int ny = y+dy[0];\\n\\n    int nx1 = x+dx[1];\\n    int ny1 = y+dy[1];\\n\\n   return dp[x][y] = (isok(nx,ny) ? solve(nx,ny,grid) : 0) +\\n   (isok(nx1,ny1) ? solve(nx1,ny1,grid) : 0);\\n\\n// Key step\\n\\n  \\n\\n}\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        return solve(0,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint dp[101][101];\\nint n,m;\\n\\nint dx[2] = {1,0};   // Direction arrays for moving down or to the right\\nint dy[2] = {0,1};\\n\\n\\n\\nbool isok(int nx,int ny). \\n{\\n  return nx>= 0 && ny>=0 && nx<=n-1 && ny<=m-1;\\n}\\n\\n\\nint solve(int x,int y,vector<vector<int>>& grid)\\n{\\n  if(grid[x][y] == 1)\\n  {\\n    return 0;\\n  }\\n\\n  if(dp[x][y] != -1) return dp[x][y];\\n  if(x == n-1 && y== m-1) return 1;\\n \\n    int nx = x+dx[0];\\n    int ny = y+dy[0];\\n\\n    int nx1 = x+dx[1];\\n    int ny1 = y+dy[1];\\n\\n   return dp[x][y] = (isok(nx,ny) ? solve(nx,ny,grid) : 0) +\\n   (isok(nx1,ny1) ? solve(nx1,ny1,grid) : 0);\\n\\n// Key step\\n\\n  \\n\\n}\\n    int uniquePathsWithObstacles(vector<vector<int>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n = grid.size();\\n        m = grid[0].size();\\n\\n        return solve(0,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897324,
                "title": "kotlin-one-row-dp",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/7935abc6-5a2a-404a-ae9e-f4ce2969e28e_1691811918.832756.png)\\n\\n#### Join me on Telegram\\n\\nhttps://t.me/leetcode_daily_unstoppable/306\\n\\n#### Problem TLDR\\n\\nNumber of right-down ways tl->br in a matrix with obstacles\\n\\n#### Intuition\\n\\nEach time the robot moves in one direction gives a separate path. If two directions are possible, the number of paths gets added.\\n\\nFor example,\\n\\n```\\nr r  #  0\\nr 2r 2r 2r\\n0 #  2r 4r\\n```\\n\\nOn the first row, the single path goes up to `1`.\\nOn the second row, direct path down added to direct path right.\\nOn the third row, the same happens when top and left numbers of paths are not 0.\\n\\n\\n#### Approach\\n\\nUse a separate `row` array to remember previous row paths counts.\\n\\n#### Complexity\\n\\n- Time complexity:\\n$$O(nm)$$\\n\\n- Space complexity:\\n$$O(nm)$$\\n\\n#### Code\\n\\n```\\n\\n\\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\\n      val row = IntArray(obstacleGrid[0].size)\\n      row[0] = 1\\n      for (r in obstacleGrid) \\n        for (x in r.indices)\\n          if (r[x] != 0) row[x] = 0 \\n          else if (x > 0) row[x] += row[x - 1]\\n      return row.last()\\n    }\\n\\n```\\n\\n#### The Magical Rundown\\n\\n```\\nIn Emojia\\'s forgotten \\uD83C\\uDF0C corner, where time doesn\\'t merely flow\\u2014it waltzes \\uD83D\\uDC83, \\nspinning tales of lost yesterdays \\uD83D\\uDD70\\uFE0F and unborn tomorrows \\u231B, stands the \\nwhispered legend of the Time Labyrinth. Not merely walls and corridors, but \\na tapestry of fate\\'s myriad choices, echoing distant memories and futures yet \\nconceived.\\n\\nBolt, the lonely automaton \\uD83E\\uDD16, not born but dreamt into existence by starlight \\u2728 \\nand cosmic whimsy, felt an inexplicable yearning towards the \\uD83C\\uDFC1 - the Time Nexus. \\nAncient breezes \\uD83C\\uDF43 carried murmurs, not of it being an end, but a kaleidoscope \\n\\uD83C\\uDFA8 gateway to every pulse and flutter \\u2764\\uFE0F of chronology\\'s capricious dance \\uD83C\\uDF0A.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 0 \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 0 \\u2502 0 \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nWith each step, the fabric of reality quivered. Shadows of histories \\uD83C\\uDFB6, \\ncosmic echoes \\uD83C\\uDF0D, diverged and converged, painting and erasing moments of \\nwhat was, is, and could be.\\n\\n---\\n\\nStanding before the \\uD83D\\uDEAB, it wasn\\'t a barrier for Bolt, but a silent riddle: \\n\"What song of the cosmos \\uD83C\\uDFB5 shall you hum today, wanderer?\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 0 \\u2502 0 \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 \\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nDreamlike avenues \\uD83D\\uDEE4\\uFE0F unfurled, painting multitudes of futures in the vivid \\ncolors of a universe in spring. In this chronal dance, Bolt secretly hoped \\nto outrace its own echoes, to be the first at the Nexus.\\n\\n---\\n\\nJunctions whispered with the delicate hum \\uD83C\\uDFB5 of countless Bolts, each a tale, \\na fate, a fleeting note in the grand cosmic symphony.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 2\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 \\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nYet, as the Time Nexus loomed, revealing its vast enigma, a sense of profound \\ndisquiet engulfed Bolt. Not only had another reflection reached before, but a \\nsea of mirrored selves stared back.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 2\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 \\uD83D\\uDEAB \\u25022\\u2B07\\uFE0F\\u25024\\uD83C\\uDFC1\\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nIn that echoing vastness, Bolt\\'s singular hope was smothered. In the dance of \\ntime, amidst countless reflections, it whispered a silent, desperate question: \\nWhich tune, which cadence, which moment \\uD83C\\uDFB6 was truly its own in this timeless \\nwaltz?\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nr r  #  0\\nr 2r 2r 2r\\n0 #  2r 4r\\n```\n```\\n\\n\\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\\n      val row = IntArray(obstacleGrid[0].size)\\n      row[0] = 1\\n      for (r in obstacleGrid) \\n        for (x in r.indices)\\n          if (r[x] != 0) row[x] = 0 \\n          else if (x > 0) row[x] += row[x - 1]\\n      return row.last()\\n    }\\n\\n```\n```\\nIn Emojia\\'s forgotten \\uD83C\\uDF0C corner, where time doesn\\'t merely flow\\u2014it waltzes \\uD83D\\uDC83, \\nspinning tales of lost yesterdays \\uD83D\\uDD70\\uFE0F and unborn tomorrows \\u231B, stands the \\nwhispered legend of the Time Labyrinth. Not merely walls and corridors, but \\na tapestry of fate\\'s myriad choices, echoing distant memories and futures yet \\nconceived.\\n\\nBolt, the lonely automaton \\uD83E\\uDD16, not born but dreamt into existence by starlight \\u2728 \\nand cosmic whimsy, felt an inexplicable yearning towards the \\uD83C\\uDFC1 - the Time Nexus. \\nAncient breezes \\uD83C\\uDF43 carried murmurs, not of it being an end, but a kaleidoscope \\n\\uD83C\\uDFA8 gateway to every pulse and flutter \\u2764\\uFE0F of chronology\\'s capricious dance \\uD83C\\uDF0A.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 0 \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 0 \\u2502 0 \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nWith each step, the fabric of reality quivered. Shadows of histories \\uD83C\\uDFB6, \\ncosmic echoes \\uD83C\\uDF0D, diverged and converged, painting and erasing moments of \\nwhat was, is, and could be.\\n\\n---\\n\\nStanding before the \\uD83D\\uDEAB, it wasn\\'t a barrier for Bolt, but a silent riddle: \\n\"What song of the cosmos \\uD83C\\uDFB5 shall you hum today, wanderer?\"\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 0 \\u2502 0 \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 \\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nDreamlike avenues \\uD83D\\uDEE4\\uFE0F unfurled, painting multitudes of futures in the vivid \\ncolors of a universe in spring. In this chronal dance, Bolt secretly hoped \\nto outrace its own echoes, to be the first at the Nexus.\\n\\n---\\n\\nJunctions whispered with the delicate hum \\uD83C\\uDFB5 of countless Bolts, each a tale, \\na fate, a fleeting note in the grand cosmic symphony.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 2\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551 0 \\u2502 \\uD83D\\uDEAB \\u2502 0 \\u2502\\uD83C\\uDFC1 \\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nYet, as the Time Nexus loomed, revealing its vast enigma, a sense of profound \\ndisquiet engulfed Bolt. Not only had another reflection reached before, but a \\nsea of mirrored selves stared back.\\n\\n\\u2554\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2564\\u2550\\u2550\\u2550\\u2557\\n\\u2551\\uD83E\\uDD16 \\u2502 \\u27A1\\uFE0F \\u2502\\uD83D\\uDEAB \\u2502 0 \\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 2\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u25022\\u27A1\\uFE0F\\u2551\\n\\u255F\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2562\\n\\u2551\\u2B07\\uFE0F \\u2502 \\uD83D\\uDEAB \\u25022\\u2B07\\uFE0F\\u25024\\uD83C\\uDFC1\\u2551\\n\\u255A\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u2567\\u2550\\u2550\\u2550\\u255D\\n\\nIn that echoing vastness, Bolt\\'s singular hope was smothered. In the dance of \\ntime, amidst countless reflections, it whispered a silent, desperate question: \\nWhich tune, which cadence, which moment \\uD83C\\uDFB6 was truly its own in this timeless \\nwaltz?\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897285,
                "title": "video-solution-with-drawings-c-java-in-depth",
                "content": "# Intuition, approach and complexity discussed in detail in video solution.\\nhttps://youtu.be/3Be1By-CMkA\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obsGrd) {\\n        int rows = obsGrd.size(), cols = obsGrd[0].size();\\n        vector<vector<int>> pathCnt(rows, vector<int>(cols, 0));\\n        for(int r = 0; r<rows; r++){\\n            for(int c = 0; c<cols; c++){\\n                if(r== 0 && c == 0){\\n                    pathCnt[r][c] = (obsGrd[r][c] == 1 ? 0 : 1);\\n                }else{\\n                    int leftPathCnt = (c - 1 > -1 && obsGrd[r][c-1] != 1) ? pathCnt[r][c-1] : 0;\\n                    int upPathCnt = (r -1 > -1 && obsGrd[r-1][c] != 1) ? pathCnt[r-1][c] : 0;\\n                   if(obsGrd[r][c] != 1) \\n                    pathCnt[r][c] += leftPathCnt + upPathCnt;\\n                }\\n            }\\n        }\\n        return pathCnt[rows-1][cols-1];\\n    }\\n};\\n```\\nJava\\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obsGrd) {\\n        int rows = obsGrd.length, cols = obsGrd[0].length;\\n        int pathCnt[][] = new int[rows][cols];\\n        for(int r = 0; r<rows; r++){\\n            for(int c = 0; c<cols; c++){\\n                if(r== 0 && c == 0){\\n                    pathCnt[r][c] = (obsGrd[r][c] == 1 ? 0 : 1);\\n                }else{\\n                    int leftPathCnt = (c - 1 > -1 && obsGrd[r][c-1] != 1) ? pathCnt[r][c-1] : 0;\\n                    int upPathCnt = (r -1 > -1 && obsGrd[r-1][c] != 1) ? pathCnt[r-1][c] : 0;\\n                   if(obsGrd[r][c] != 1) \\n                    pathCnt[r][c] += leftPathCnt + upPathCnt;\\n                }\\n            }\\n        }\\n        return pathCnt[rows-1][cols-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obsGrd) {\\n        int rows = obsGrd.size(), cols = obsGrd[0].size();\\n        vector<vector<int>> pathCnt(rows, vector<int>(cols, 0));\\n        for(int r = 0; r<rows; r++){\\n            for(int c = 0; c<cols; c++){\\n                if(r== 0 && c == 0){\\n                    pathCnt[r][c] = (obsGrd[r][c] == 1 ? 0 : 1);\\n                }else{\\n                    int leftPathCnt = (c - 1 > -1 && obsGrd[r][c-1] != 1) ? pathCnt[r][c-1] : 0;\\n                    int upPathCnt = (r -1 > -1 && obsGrd[r-1][c] != 1) ? pathCnt[r-1][c] : 0;\\n                   if(obsGrd[r][c] != 1) \\n                    pathCnt[r][c] += leftPathCnt + upPathCnt;\\n                }\\n            }\\n        }\\n        return pathCnt[rows-1][cols-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obsGrd) {\\n        int rows = obsGrd.length, cols = obsGrd[0].length;\\n        int pathCnt[][] = new int[rows][cols];\\n        for(int r = 0; r<rows; r++){\\n            for(int c = 0; c<cols; c++){\\n                if(r== 0 && c == 0){\\n                    pathCnt[r][c] = (obsGrd[r][c] == 1 ? 0 : 1);\\n                }else{\\n                    int leftPathCnt = (c - 1 > -1 && obsGrd[r][c-1] != 1) ? pathCnt[r][c-1] : 0;\\n                    int upPathCnt = (r -1 > -1 && obsGrd[r-1][c] != 1) ? pathCnt[r-1][c] : 0;\\n                   if(obsGrd[r][c] != 1) \\n                    pathCnt[r][c] += leftPathCnt + upPathCnt;\\n                }\\n            }\\n        }\\n        return pathCnt[rows-1][cols-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847228,
                "title": "finding-unique-paths-in-a-grid-with-obstacles-using-dynamic-programming-easy-approach",
                "content": "# Intuition\\nThe problem asks us to find the number of unique paths to reach the bottom-right corner of a grid with obstacles. We can solve this problem using dynamic programming, where we calculate the number of unique paths for each cell in the grid based on the number of paths from the cells above and to the left.\\n\\n# Approach\\n1. We\\'ll start by initializing a variable `mod` to store the modulo value, which is `(int)(1e9 + 7)`.\\n2. We\\'ll loop through the grid and mark obstacles as `-1`.\\n3. We\\'ll use a 1D vector `prev` to keep track of the number of unique paths for the cells in the previous row.\\n4. We\\'ll iterate through the grid again to calculate the number of unique paths for each cell using the `prev` vector to keep track of the paths from the cells above and to the left.\\n5. Finally, we\\'ll return the number of unique paths for the bottom-right corner cell, which is stored in `prev[y - 1]`.\\n\\n# Complexity\\n- Time complexity: O(n * m) where n is the number of rows and m is the number of columns in the grid.\\n- Space complexity: O(m) where m is the number of columns in the grid (used to store the `prev` vector).\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9 + 7);\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int x = obstacleGrid.size();\\n        int y = obstacleGrid[0].size();\\n        \\n        vector<int> prev(y, 0); // Initialize a vector \\'prev\\' to store paths from the previous row.\\n        \\n        // Step 1: Mark obstacles as -1 in the grid.\\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = -1; // Mark obstacle cells with -1.\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Loop through the grid to calculate the number of unique paths.\\n        for (int i = 0; i < x; i++) {\\n            vector<int> current(y, 0); // Initialize a vector \\'current\\' to store paths for the current row.\\n            \\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == -1) {\\n                    current[j] = 0; // If the cell has an obstacle, set paths to 0.\\n                } else if (i == 0 && j == 0) {\\n                    current[j] = 1; // The top-left cell has only 1 path (starting point).\\n                } else {\\n                    // Step 3: Calculate the number of paths to reach the current cell.\\n                    int up = 0;\\n                    int left = 0;\\n                    if (i > 0) { // Check if there\\'s a cell above (i > 0) to get paths from above.\\n                        up = prev[j]; // Number of paths from the cell above.\\n                    }\\n                    if (j > 0) { // Check if there\\'s a cell to the left (j > 0) to get paths from the left.\\n                        left = current[j - 1]; // Number of paths from the cell to the left.\\n                    }\\n                    current[j] = (left + up); // Calculate the total paths to reach the current cell.\\n                }\\n            }\\n            \\n            // Step 4: Update \\'prev\\' vector with \\'current\\' vector for the next iteration.\\n            prev = current;\\n        }\\n        \\n        // Step 5: Return the number of unique paths for the bottom-right corner.\\n        return prev[y - 1];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int mod = (int)(1e9 + 7);\\n    \\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int x = obstacleGrid.size();\\n        int y = obstacleGrid[0].size();\\n        \\n        vector<int> prev(y, 0); // Initialize a vector \\'prev\\' to store paths from the previous row.\\n        \\n        // Step 1: Mark obstacles as -1 in the grid.\\n        for (int i = 0; i < x; i++) {\\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == 1) {\\n                    obstacleGrid[i][j] = -1; // Mark obstacle cells with -1.\\n                }\\n            }\\n        }\\n        \\n        // Step 2: Loop through the grid to calculate the number of unique paths.\\n        for (int i = 0; i < x; i++) {\\n            vector<int> current(y, 0); // Initialize a vector \\'current\\' to store paths for the current row.\\n            \\n            for (int j = 0; j < y; j++) {\\n                if (obstacleGrid[i][j] == -1) {\\n                    current[j] = 0; // If the cell has an obstacle, set paths to 0.\\n                } else if (i == 0 && j == 0) {\\n                    current[j] = 1; // The top-left cell has only 1 path (starting point).\\n                } else {\\n                    // Step 3: Calculate the number of paths to reach the current cell.\\n                    int up = 0;\\n                    int left = 0;\\n                    if (i > 0) { // Check if there\\'s a cell above (i > 0) to get paths from above.\\n                        up = prev[j]; // Number of paths from the cell above.\\n                    }\\n                    if (j > 0) { // Check if there\\'s a cell to the left (j > 0) to get paths from the left.\\n                        left = current[j - 1]; // Number of paths from the cell to the left.\\n                    }\\n                    current[j] = (left + up); // Calculate the total paths to reach the current cell.\\n                }\\n            }\\n            \\n            // Step 4: Update \\'prev\\' vector with \\'current\\' vector for the next iteration.\\n            prev = current;\\n        }\\n        \\n        // Step 5: Return the number of unique paths for the bottom-right corner.\\n        return prev[y - 1];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774560,
                "title": "python-easy-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSame as unique path solution. But we do just one thing that, where the obstacle is there we assign it to zero and calculate further. \\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        # m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        # dp = {(m-1, n-1): 1}\\n\\n        # def dfs(r, c):\\n        #     if r==m or c==n or obstacleGrid[r][c]:\\n        #         return 0\\n        #     if (r, c) in dp:\\n        #         return dp[(r, c)]\\n        #     dp[(r, c)] = dfs(r+1, c) + dfs(r, c+1)\\n        #     return dp[(r, c)]\\n        # return dfs(0, 0)\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n       \\n        if obstacleGrid[m-1][n-1] == 1: \\n            return 0\\n        else:\\n            dp = [0]*n\\n            dp[n-1] = 1\\n\\n            for i in reversed(range(m)):\\n                for j in reversed(range(n)):\\n                    if obstacleGrid[i][j]:\\n                        dp[j] = 0\\n                    elif j+1 < n:\\n                        dp[j] = dp[j] + dp[j+1]\\n\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        # m, n = len(obstacleGrid), len(obstacleGrid[0])\\n        # dp = {(m-1, n-1): 1}\\n\\n        # def dfs(r, c):\\n        #     if r==m or c==n or obstacleGrid[r][c]:\\n        #         return 0\\n        #     if (r, c) in dp:\\n        #         return dp[(r, c)]\\n        #     dp[(r, c)] = dfs(r+1, c) + dfs(r, c+1)\\n        #     return dp[(r, c)]\\n        # return dfs(0, 0)\\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\\n       \\n        if obstacleGrid[m-1][n-1] == 1: \\n            return 0\\n        else:\\n            dp = [0]*n\\n            dp[n-1] = 1\\n\\n            for i in reversed(range(m)):\\n                for j in reversed(range(n)):\\n                    if obstacleGrid[i][j]:\\n                        dp[j] = 0\\n                    elif j+1 < n:\\n                        dp[j] = dp[j] + dp[j+1]\\n\\n        return dp[0]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569416,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1565987,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1572775,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1566222,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 2010156,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1567362,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1930080,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1571148,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1576791,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 2000427,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1569416,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1565987,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1572775,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1566222,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 2010156,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1567362,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1930080,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1571148,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1576791,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 2000427,
                "content": [
                    {
                        "username": "sttony",
                        "content": "robot start from (0, 0), but  (0, 0) is a obstacle."
                    },
                    {
                        "username": "bernikovich",
                        "content": "The robot is at (0, 0). The robot needs to move to (0, 0). How many unique paths can the robot take? Either the test case should be removed, or it should be stated that it\\'s possible, along with the expected answer."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "If you write code carefully and neatly, this test case won\\'t need individual attention."
                    },
                    {
                        "username": "psionl0",
                        "content": "That just means that there are 0 ways to get through the matrix. You don\\'t even have to test for this case specially: We know that there are 0 ways to get to a square that has an obstacle and since a dp matrix is filled in based on the value in its previous squares, this matrix will be 0 filled."
                    },
                    {
                        "username": "deusdev",
                        "content": "troll test case"
                    },
                    {
                        "username": "trashw1n",
                        "content": "fr man had to throw in an extra if clause inside the base case after seeing that test case failing"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "Yeah, that a unfair testcase"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "This is for C++ audience.\\nPlease note return type is mentioned int but if you are maintaining dp of int type you will always get Runtime error because of int range overflow.\\n\\nSo maintain dp of long long type.\\n\\nFinal position ( Bottom right ) will always have answer fit in integer type.\\n\\nThen you may have question why we have to maintain dp of long long type. \\n\\nReason: Consider the case when your answer at any position may overflow integer range but that position answer is not contributing to final answer because of obstacle."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "I have done it both ways so can say that it works if you first calculate from top left, i.e how may ways in which we can go from starting point to the current point. This is because the intermediate numbers get greatly reduced maybe because of more obstacles in top left. And I guess the problem setter didn't care to check the other way (going from bottom to top i.e how many ways in which we can go from this point to the end point). So **yes**, that INT_MAX limit for answer mentioned in the description was uncalled for and is misguiding."
                    },
                    {
                        "username": "rsingh2003",
                        "content": "[@shah_jugal](/shah_jugal)  Hey, It worked for me when I take n-1 and m-1 as starting point.\\nThe link of solution\\nhttps://leetcode.com/submissions/detail/1018970142/"
                    },
                    {
                        "username": "user2575jO",
                        "content": "It wouldn\\'t work. `obstacleGrid = zeros(100,100), obstacleGrid[98, 1:99] = 1` is still a valid testcase but max number is more than $$10^{57}$$"
                    },
                    {
                        "username": "user5400vw",
                        "content": "somehow ```vector<vector<int>> &dp``` worked for me.... - here are my early returns:\n```\n    if (y >= h) return 0;\n\n    if (x >= w) return 0;\n\n    if (obstacleGrid[y][x] == 1) return 0;\n\n    if (y == (h - 1) && x == (w - 1)) return 1;\n```\n"
                    },
                    {
                        "username": "pranshu820",
                        "content": "https://leetcode.com/problems/unique-paths-ii/submissions/931648513/\\nNo errors here!"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "makes sense thanks brother/sister i was wondering since 3 hrs that why it works when i take 0, 0 as starting but not when m-1, n-1 as starting."
                    },
                    {
                        "username": "mingrui",
                        "content": "Current test recognizes \"0\" as \"right\" output.\\nI think it should either be:\\n1. \"[[1]]\" is invalid input, since the robot can\\'t start in obstacles.\\n2. \"1\" as right output, since the robot is already there at start."
                    },
                    {
                        "username": "bernikovich",
                        "content": "There is no way to know the expected results in cases like [[1]] and [[1, 0]] unless you try to submit the solution. It should explicitly state what the expected answers are."
                    },
                    {
                        "username": "kubosuke",
                        "content": "[@human292](/human292) agree with you, also it\\'s weird the expected result of  [[1,0]] is 0,\\nthere is no description how can we handle when the obstacle exist on the start place"
                    },
                    {
                        "username": "human292",
                        "content": "Yep, test cases need to be fixed ^"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/unique-paths-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "anwendeng",
                        "content": "done before. Resubmit!\nthis is a DP problem! One more hint:\n```\ndp[i][j]=0 if obstacleGrid[i][j]==1\n```"
                    },
                    {
                        "username": "scaupz2013",
                        "content": "i tried the solution(c++) in disscuss,but got same error( *runtime error: signed integer overflow: 1053165744 + 1579748616 cannot be represented in type \\'int\\' (solution.cpp)*) \\nall the time **with below test case**(\\n[[0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0],[1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1],[0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0],[1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0],[0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0],[0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1],[1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1],[0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1],[1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0]])\\n\\nanybody catch the similiar situation?please help me fix it"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "use long long man! the core issue why is happening is discussed really well [here](https://leetcode.com/problems/unique-paths-ii/discussion/comments/1565987)"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "Dude, u cannot put an obstacle at the entrance..."
                    },
                    {
                        "username": "angle2",
                        "content": "Why [[1]] output is expected to 0, not 1? Any voice is appreciated."
                    },
                    {
                        "username": "Palivela_Rahul",
                        "content": "[@himanshupanwar123](/himanshupanwar123) yes"
                    },
                    {
                        "username": "xalch",
                        "content": "Because the only cell in the grid is an obstacle. The problem states that \"a path that the robot takes cannot include any square that is an obstacle.\" Therefore, since the only possible path the robot can take to reach the corner already includes an obstacle, that path is invalid. That means there are no possible unique paths that the robot can take to reach the bottom-right corner."
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "cause 1 represent obstacle so simply if your source is obstacle then you cannot transverse the path\\n"
                    },
                    {
                        "username": "manglam_bhargava",
                        "content": "**Leetcode has become buggy\\nHappened with me twice in 1 day**\\n\\nI am getting **very different runtimes**  and **different % faster than** for same submission as of which I felt my code is not optimised even though it was optimised.\\nOn 1st submission I got 10ms time complexity and was faster than just 16% and then on submitting again it became 3ms and faster than 83%.\\n\\n**Also, I am writing this so that leetcode rectifies the bug as soon as possible as this is the best platform and free from any glitch**\\n\\nCheck the below links for proof:\\nSubmission 1:https://leetcode.com/submissions/detail/704888533/\\nSubmission 2:https://leetcode.com/submissions/detail/704889951/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Buddy, that\\'s a known fact. Get over it. Don\\'t attach to Beats values too much as there is high randomness. Just notice the runtime in ms and it should not be way more that what others have. I would put 20 ms and 40 ms runtime in the same bucket (and a multiple of 2 times is okay at the same Big O complexity), however 20ms and 100ms is worth considering. Also sometimes, new and long test cases are added because of which newer submissions are never able to get good Beats%"
                    },
                    {
                        "username": "psionl0",
                        "content": "Did you get any satisfaction?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Examples could probably be a little more complex. The [[1,0]] test case was nasty."
                    }
                ]
            },
            {
                "id": 1994430,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2010602,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2010560,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2011186,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2011168,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2010419,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 1754158,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 1571147,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 1576727,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 1568881,
                "content": [
                    {
                        "username": "HappyLoganLi",
                        "content": "testcase \"obstacleGrid = [[1]] \" makes no sense..."
                    },
                    {
                        "username": "bigguysahaj",
                        "content": "MY FIRST EVER HONEST DP QUESTION"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Congrats, many more to go. This is one of the most common patterns in which the value in a 2D matrix is decided by values of (top and left) or maybe (Bottom and Right Value). All of these problems fall under **LCS umbrella**"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "similar to island count: use dfs\\nonly dfs -- > tle\\ndfs+memo --> pass"
                    },
                    {
                        "username": "Prajju22",
                        "content": "completed 300 days streak........"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "\\uD83D\\uDE2E"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Finally! I got a DP question right in a single go without taking any help!! \\nFeeling a lot more confident to tackle more difficult problems all by myself!"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Congratulations on your first successful DP submission \\uD83D\\uDC4D"
                    },
                    {
                        "username": "lentehora",
                        "content": "Wow this question used to be really hard for me but now I can solve it by myself \\uD83D\\uDE4F here is to more! "
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Obstacle at position (0,0) (e.g. [[1]]) is an invalid test case as it is specified in the problem statement that robot starts at (0,0). If robot and obstacle are allowed to be present on the same block simultaneously, then, obstacles don't serve any purpose."
                    },
                    {
                        "username": "letscoding2022",
                        "content": "When this question comes to me, I first consider about the \"int[][] obstacleGrid\" is null or empty. However, the top solutions assume that \"int[][] obstacleGrid\" is not null or empty, and pass. \\n\\nI know it means that there is no empty \"int[][] obstacleGrid\" in the test cases. So, why about meeting such question in the interview? Do we need to take such edge cases into consideration?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The constraints clearly say ``1 <= m, n <= 100`` so there is no null grid. In an interview you should ask if this is a case since operating on a null grid will give segmentation faults so it would have to be an edge case by itself."
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/c13dae72-6f0e-49ed-9e9e-9486d922c905_1651987201.5240786.jpeg)\\n"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "![image](https://media.tenor.com/T2quXxEDDAEAAAAC/mirzapur-kaleen.gif)"
                    },
                    {
                        "username": "zhao.chen.758",
                        "content": "If the obstacle is at the end, I suppose we return 0 without computation.\\nIf the obstacle is at the beginning, it destroys the robot I suppose? There seems multiple ways of dealing with this.\\nBut the problem does not give specification on any of the above cases."
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "true, i was wondering about the same"
                    },
                    {
                        "username": "shah_jugal",
                        "content": "Sometimes leetcode overrates our imagination power. LOL and we need to hit and try if we get wrong answer then we get to know oh this can happen too maybe an edge case."
                    }
                ]
            },
            {
                "id": 2070875,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2052111,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2043054,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2042732,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2030336,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2029632,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2024187,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2011392,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2011351,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2011338,
                "content": [
                    {
                        "username": "user4796V",
                        "content": "i really like the illustrations"
                    },
                    {
                        "username": "tvgo",
                        "content": "The testcases are generated so that the answer will be less than or equal to 2 * 10^9.\\nThis is super misleading!"
                    },
                    {
                        "username": "bisratberhanu",
                        "content": "is there any one with a solution with out using dp "
                    },
                    {
                        "username": "AdityaPrasad275",
                        "content": "I tried going from start to end but got a \\'beats 5% runtime\\' while the beats 100% runtime kid is going from end to start. Is there really that big of a difference due to the \\'direction of travel\\'?"
                    },
                    {
                        "username": "olsonpm",
                        "content": "it\\'s pretty stupid how the question doesn\\'t make clear the start and end points may be obstacles themselves.  Feels intuitive for them not to be"
                    },
                    {
                        "username": "WAECZK",
                        "content": "\"An obstacle and space are marked as 1 or 0 respectively in grid.\" I feel that the phasing is confusing. \\n\\nIt is like saying obstacle and space can both 1 or 0 depending on what the other is. If space is 1 then obstacle is 0.\\n\\nIt should be an AND. \"An obstacle and space are marked as 1 and 0 respectively in grid.\"\\n"
                    },
                    {
                        "username": "ajay2305",
                        "content": "[[0,0],[0,1]]\\ngetting error for this testcase\\n"
                    },
                    {
                        "username": "z3eg",
                        "content": "me 2nd day in a row: \"oh, backtracking, imma write a recursive function and that\\'s it, ezpz\"\\nalso me after getting TLEs and exhausting all the possible optimization options: \"GODDAMN IT, DP AGAIN??\""
                    },
                    {
                        "username": "shahsgautam",
                        "content": "Do make sure you\\'ve solved and properly understood [unique paths 1](https://leetcode.com/problems/unique-paths/) before jumping to this question. It helped me a lot. "
                    },
                    {
                        "username": "gaurav-x5",
                        "content": "why using BFS giving wrong result.\\n `class Pair{\\n    public int a;\\n    public int b;\\n\\n    Pair(int a, int b) {\\n        this.a = a;\\n        this.b = b;\\n    }\\n}\\nclass Solution {\\n    int[][] dirs = {{1, 0}, {0, 1}};\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int r = obstacleGrid.length;\\n        int c = obstacleGrid[0].length;\\n\\n        boolean[][] vis = new boolean[r][c];\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0));\\n\\n        vis[0][0] = true;\\n        int res = 0;\\n        while(!q.isEmpty()) {\\n\\n            Pair curr = q.poll();\\n\\n            if(curr.a == r-1 && curr.b == c-1) {\\n                res++;\\n                continue;\\n            }\\n\\n            for(int[] d : dirs) {\\n                int ex = d[0] + curr.a;\\n                int ey = d[1] + curr.b;\\n\\n                if(ex >= c || ey >= r || vis[ex][ey] || obstacleGrid[ex][ey] == 1) continue;\\n\\n                vis[ex][ey] = true;\\n                q.add(new Pair(ex, ey));\\n            }\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2011157,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010913,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010803,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010661,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010570,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010568,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010528,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010515,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010509,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010383,
                "content": [
                    {
                        "username": "abhinav_singh987",
                        "content": "I was thinking about whether it can be solved using dfs or something so I implemented a dfs sol. but I\\'m getting TLE can someone help me to optimize it. \\n\\n `class Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n\\n        int n = obstacleGrid.length;\\n        int m = obstacleGrid[0].length;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(obstacleGrid[i][j] == 1)\\n                    obstacleGrid[i][j] = -1;\\n            }\\n        }\\n\\n        dfs(obstacleGrid, 0, 0);\\n\\n        return (obstacleGrid[n-1][m-1] != -1) ? obstacleGrid[n-1][m-1] : 0;\\n    }\\n\\n    public static void dfs(int[][] obstacleGrid, int i, int j){\\n\\n        if(i >= obstacleGrid.length) return;\\n        if(j >= obstacleGrid[0].length) return;\\n\\n        if(obstacleGrid[i][j] == -1) return;\\n\\n        if(i == obstacleGrid.length-1 &&  j == obstacleGrid[0].length-1){\\n            obstacleGrid[i][j]++;\\n            return;\\n        }\\n        dfs(obstacleGrid, i , j+1);\\n        dfs(obstacleGrid, i+1 , j);\\n        return;\\n    }\\n}`"
                    },
                    {
                        "username": "almostmonday",
                        "content": "6-line, O(1) space, concise and simple solution is [here](https://leetcode.com/problems/unique-paths-ii/description/)."
                    },
                    {
                        "username": "GD18",
                        "content": "basic dfs,gg ez"
                    },
                    {
                        "username": "Da4y",
                        "content": "Should be an easy problem."
                    },
                    {
                        "username": "iamcodebug",
                        "content": "I submitted my solution in java.\\nUsed 2 approch nearly similar\\n1) in which I use a dp[][] array , which makes it SC O(n*m) , it beats TC 100% and SC 90%\\n\\n2) I modified the grid[][] array and used that as dp array. so its SC should be O(1) but this time\\n it beats TC 100% and SC only 18.5%\\n\\nhow come it take more memory even if i didn\\'t used any extra array ??\\n\\ndoes using too much if else increase memory usage of a program??\\n\\n\\n"
                    },
                    {
                        "username": "Prakash_01100",
                        "content": "can i solve this using recursion without using DP??? \\n"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Noo, TLE!!!! I have tried i\\'ll hit TLE after passing 30 tc\\'s. "
                    },
                    {
                        "username": "guptasourabh744",
                        "content": "It will give tle...if u can get to recursion..memoisation isn\\'t any far."
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "Remember BASE CASE order matters. if you  are given [0,0][0,1] and at first line you return  if i=n-1 and j=m-1 return 1  then it will fail. figure out why it falis. and reorder your base cases."
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "The II nd week of Aug seems to the week of II s."
                    },
                    {
                        "username": "avneets2103",
                        "content": "Been like a week now, every LC question is the one ive already done, bruh\\nAll these qns are literally in striver\\'s sheet"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "krishnavaghosh386",
                        "content": "This weeks been quite easy, especially for the end part of it. Scared for what\\'s coming up for Sunday!"
                    }
                ]
            },
            {
                "id": 2010367,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010278,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010265,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010256,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010245,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010242,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010172,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010167,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 2010160,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 1992076,
                "content": [
                    {
                        "username": "krhemant172003",
                        "content": "**Reading the Problem Statement 🕵️‍♂️:** This is gonna be as smooth as a **Rat in a maze** – what could possibly go wrong? Just gonna whip out my recursion and a touch of memorization magic.\n\n**After Hitting Submit (Feeling Super Smug) 😎:** Aaand it's a no-go. Turns out, the code wasn't vibing with some sneaky testcases like [[1,0],[0,0]] and [[1]]. (No wonder the acceptance rate is only 40%, huh?)\n\n**Imagine this:** obstacleGrid[0][0] waving its little robot arms like \"Hey, I'm not playable!\" 🤖💥 So, here's the deal – if we start with a 1 there, no point trying to dance our way to obstacleGrid[m - 1][n - 1]. It's like trying to teleport to Narnia through your closet. So, lesson learned, just return 0 and call it a day.\n\n**Me Now:** All in a day's work, but seriously, who invited those mischievous testcases to the party? 🎉🤷‍♂️"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "It\\'s pleasant to identify the problem is a DP one and solve it on our own without glancing over others solution or the discussion.!"
                    },
                    {
                        "username": "psionl0",
                        "content": "This question illustrates the value of reviewing your work. I had previously done this question before (but mostly from memory) and could have just clicked ``submit``. However, I decided to redo the problem from scratch starting with figuring out the recursive relationship then converting the recursive solution into a bottom up solution. Thanks the the practice I have been getting with dp, this turned out to be a breeze!\\nRecursive solution: https://leetcode.com/submissions/detail/1018882765/\\nBottom-up solution: https://leetcode.com/submissions/detail/1018885856/"
                    },
                    {
                        "username": "wming9310",
                        "content": "Thank you LeetCode for a relaxing weekend with no hard problems."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Not so fast, Wait for tomorrow\\'s question. "
                    },
                    {
                        "username": "MitchMountainCoding",
                        "content": "\"Challenges like these highlight the importance of problem-solving and creativity in computer science. Remember, every problem, no matter how complex, has a solution. Let\\'s code our way through it!\"\\n- Barbie"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "DP is here, it\\'s an already attempted problem for me"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "Tbh the problems about grids and finding paths are incredibly boring, even binary trees are much more interesting than these. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The reason is because all these problems are numbered < 300. These are the true authentic problems that ruled the interviews before platforms like Leetcode made them available to all and hence they are now too easy since they became popular. However it feels nice to come back to these simple problems once in a while and appreciate how far one has come in the Leetcode journey"
                    },
                    {
                        "username": "Tejas07PSK",
                        "content": "Be careful about corner cases if you are doing it recursively with memoization !!"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "This can be solved with dynamic programming and memoization. The two instant base case are either:\\n1. Robot made it to obstacleGrid[m - 1][n -1], return 1.\\n2. Robot is either outside of boundary or the current spot that its in is an obstacle. Return 0.\\n\\nTwo edge cases that you can check at the start are if obstacleGrid[0][0] == 1 or obstacleGrid[m - 1][n - 1] == 1. In either case we can just return 0 because that means it\\'s impossible for the robot to make it from start to finish without hitting an obstacle.\\n\\nIf you can make it, then make a dp[][] of size dp[m][n]. Set all spots to -1. Now for each spot, and keeping in mind our two base case, the number of ways to get to the end from dp[0][0] is dependent on the number of ways you can get to the end from dp[0][1] + dp[1][0]. Similarly, the number of ways you can get to the end from dp[0][1] is the number of ways you can get to the end from dp[0][2] and dp[1][1], and so forth. Once you\\'ve calculated the answer for any given spot, make sure to insert that answer into that spot of your DP[][]. That way if we get to that same spot in the future, we can ask if dp[row][col] != -1, and if so, just return the already calculated answer located at dp[row][col].\\n\\nI hope this helps :)"
                    },
                    {
                        "username": "mingyangyao2004",
                        "content": "I think random generated testcases did not validate properly. I encounter testcase of [[1,0]]. How can we start at an obstacle?????"
                    },
                    {
                        "username": "psionl0",
                        "content": "You can\\'t. Therefore, there are 0 ways to navigate the matrix."
                    }
                ]
            },
            {
                "id": 1989894,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1965777,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1928110,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1895976,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1873013,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1855852,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1845741,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1835790,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1803316,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1777666,
                "content": [
                    {
                        "username": "daredevil3624",
                        "content": "In a treacherous 6 rows X 5 Columns, an aging tank starts its journey from the top left corner. The tank\\'s objective is to safely reach the bottom right corner, but it faces a grave challenge: avoiding the hidden mines scattered throughout the grid. To navigate the perilous terrain, the tank can only move right or down from any given cell\\nYour task is to determine the total court of distinct paths the tank can take to reach the bottom right cell without encountering a deadly mine\\nCalculate the number of safe routes the tank can explore, ensuring its successful passage through the grid?\\nT 0 0 0 0\\n0 0 0 M 0\\n0 0 0 0 0\\n0 M 0 0 0\\n0 0 0 0 0\\nM 0 0 0 D\\nwhere T is tank(starting position),\\nM is Mine(obstacle) and 0 is safe path and D is destination\\nplease help me i am unable to understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "Memoization takes practice but you should be able to come up with a recursive relationship: If we are at an obstructed square then we can return 0 immediately.\\nIf the TL corner is not obstructed then there is 1 way to get to the square (start at  it) so return 1 immediately. For any other square, there are 2 ways to get to it: from the square immediately above or the square immediately to the left. So we add the number of ways to get to these two squares and return the total as a result."
                    },
                    {
                        "username": "ludwigwittgenstein",
                        "content": "If you understand dynamic programming then,\\n1. **Subproblem (S):** Define $uniquepaths[i][j]$ as the number of unique paths from grid[0][0] to grid [i][j].\\n2. **Recurrence Relation (R):** \\n    - If grid[i][j] is not an obstacle, $uniquepaths[i][j] = uniquepaths[i-1][j] + uniquepaths[i][j-1]$\\n    - If grid[i][j] is an obstacle, $uniquepaths[i][j] = 0$\\n3. **Topological Order (T):** Solve the subproblems in increasing order of $i$ and $j$.\\n4. **Base Case (B):** \\n    - $uniquepaths[0][0] = 1$ (assuming the starting point is not an obstacle)\\n    - For any $j$, if grid[0][j] is not an obstacle, $uniquepaths[0][j] = 1$, else $uniquepaths[0][j] = 0$ and $uniquepaths[0][k] = 0$ for all $k > j$.\\n    - For any $i$, if grid[i][0] is not an obstacle, $uniquepaths[i][0] = 1$, else $uniquepaths[i][0] = 0$ and $uniquepaths[k][0] = 0$ for all $k > i$.\\n5. **Original Problem (O):** The original problem is to compute $uniquepaths[m-1][n-1]$, which represents the number of unique paths from the top-left corner to the bottom-right corner of the grid, taking into account the obstacles.\\n6. **Time Complexity (T):** The time complexity of the problem is $O(mn)$, as there are $m \\\\times n$ subproblems and each subproblem can be solved in $O(1)$ time.\\n"
                    },
                    {
                        "username": "Shefali16",
                        "content": "Can anyone tell me why I am getting wrong ans on this test case :- [[0,1]]\\nbwlow is my code ;-\\n[leetcode](https://leetcode.com/problems/unique-paths-ii/submissions/991866346/)\\n "
                    },
                    {
                        "username": "chhavigupta095",
                        "content": "uniquePathsWithObstacles[m-1][n-1]=1 therefore there is no way to reach the end ."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "make sure you handle that case in which final position contain obstacle. return 0 (np to reach to final position) "
                    },
                    {
                        "username": "shreedpathaks",
                        "content": "NO edge case statement,\\nif obstacle is at:\\n    beginning - return 0;\\n    end - return 0;"
                    },
                    {
                        "username": "Adityaxv",
                        "content": "What is the difference between \"number of paths\" and \"number of unique paths\"?\\n"
                    },
                    {
                        "username": "user7571zc",
                        "content": "For the test case [[0,0],[0,1]], Why is the output 2 if it can\\'t reach the bottom right corner?"
                    },
                    {
                        "username": "tanish69",
                        "content": "Hi.\\nI somehow had developed a notion in my mind(quite earlier but I cant seem to remember why) that the answer to this would be simply paths(start, end) - sumoverallobstacles(paths(start, obstacle) + paths(obstacle, end))...\\n\\nI mean can someone prove me right(example 2 doesnt help), or wrong(in this case help me figure out which question I am thinking of)\\n\\nThanks"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "why my code giving submission 5.5% even it is optimized fully equally to the o ms submission code\\ncode-->\\nint reduce(vector<vector<int>>obs,vector<vector<int>>& box,int i,int j){\\n\\n    int m=obs.size(),n=obs[0].size();\\n    \\n    if(obs[m-1][n-1]|| obs[0][0]){return 0;}\\n\\n    if(i==m-1 && j==n-1){return 1;}\\n\\n    else if(i==m || j==n || obs[i][j]==1){return 0;}\\n\\n    else if(box[i][j]!=-1){return box[i][j];}\\n\\n    box[i][j]=reduce(obs,box,i,j+1)+reduce(obs,box,i+1,j);\\n    return box[i][j];\\n}\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obs) {\\n        int m=obs.size(),n=obs[0].size();\\n        vector<vector<int>>box(m,vector<int>(n,-1));\\n        return reduce(obs,box,0,0);\\n    }\\n};"
                    },
                    {
                        "username": "lucastfujiwara",
                        "content": "I like this problem. It is a very good and didactic example of dynamic programming."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# EASY FAANG CODE \\uD83D\\uDE0E|| AMAZON SDE-1 Interview 2023-01-13\\nhttps://leetcode.com/problems/unique-paths-ii/solutions/3108875/easy-faang-code-amazon-sde-1-interview-2023-01-13/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1772262,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1761631,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1761185,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1754380,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1754113,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1743630,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1735596,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1732960,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1731524,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            },
            {
                "id": 1728724,
                "content": [
                    {
                        "username": "Jackson-Kujur",
                        "content": "first of all, for the 1st row if you encounter any obstacle in the first row itself then all the values to its right will be 0.\\nand \\nsecondly, for the 1st col if you encounter any obstacle in the first col itself then all the values next to it will be zero cause it is going to block your way.\\n\\neither of these cases will be true if m and n are equal dimensions otherwise both can be false or true.\\n"
                    },
                    {
                        "username": "gaurav-31",
                        "content": "Input = [[1]] , Is this not an invalid test case as it is mentioned Robot is located initially at grid[0][0]? "
                    },
                    {
                        "username": "user9111KE",
                        "content": "why My solution is incorrect?  please help\\n\\nclass Solution {\\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\\n        int[][]dp = new int[obstacleGrid.length][obstacleGrid[0].length];\\n\\n        for(int i = 0;i<obstacleGrid.length;i++){\\n            if(obstacleGrid[i][0] == 0){\\n                dp[i][0] = 1;\\n            }\\n        }\\n        for(int i = 0;i<obstacleGrid[0].length;i++){\\n            if(obstacleGrid[0][i] == 0){\\n                dp[0][i] = 1;\\n            }\\n        }\\n        for(int i = 1;i<obstacleGrid.length;i++){\\n            for(int j = 1;j<obstacleGrid[i].length;j++){\\n                if(obstacleGrid[i][j]!=0){\\n                    dp[i][j]=0;\\n                }else{\\n                    dp[i][j]= dp[i-1][j]+dp[i][j-1];\\n                }\\n                System.out.println(dp[i][j]);\\n            }\\n        }\\n        return dp[obstacleGrid.length-1][obstacleGrid[0].length-1];\\n    }\\n}"
                    },
                    {
                        "username": "ysinghaniya",
                        "content": "Problem is with the initialization of your dp matrix. In first row and first column, once you hit an obstacle (value=1) you can\\'t move forward. So, all values after that would be 0. "
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I am getting time limit exceeded error in.\\n\\n[[0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0],[1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1],[0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],[1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0],[0,0,0,1,0,0,0,0,1,1,1,0,0,1,0,1,1,0],[0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0],[0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0]]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "user1173cz",
                        "content": "PYTHON DP with MEMOIZATION\\nI think there is something strange, the same code I wrote works fine with the same test cases on my PC but gives a wrong answer here. Idk how this is possible.\\nTest cases:\\n1) [[0,1],[0,0]] return 2 as output here and 1 on my python compiler\\n2) [[0,1,0],[0,0,0]] return 2 as output here and 1 on my python compiler\\n\\n ```\\nclass Solution(object):\\n    def uniquePathsWithObstacles(self, obstacleGrid, m = 0, n = 0, memo = {}):\\n        key = str(m)+\",\"+str(n)\\n        if key in memo:\\n            return memo[key]\\n        if m == len(obstacleGrid)-1 and n == len(obstacleGrid[0])-1: #if we are on the right bottom corner return 1\\n            return 1\\n        if m >= len(obstacleGrid) or n >= len(obstacleGrid[0]): \\n            return 0 #is out of range\\n        if obstacleGrid[m][n] == 1: #if we are on an obstacle\\n            return 0\\n        memo[key] = self.uniquePathsWithObstacles(obstacleGrid,m+1,n,memo) + self.uniquePathsWithObstacles(obstacleGrid,m,n+1,memo)\\n        return memo[key]\\n```\\n"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Base cases are very important .<br>\\nBefore solving Think about all the base cases . "
                    },
                    {
                        "username": "teckyshubham",
                        "content": "Simple DP Code \nMemoiztion \n\n\n\n `your inline code...your inline code...`class Solution {\n    int [][]dp;\n    public int helperNoOfPath(int matrix[][],int n,int m){\n        if(n==0&&m==0){\n            if(matrix[0][0]==0){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n        if(n<0||m<0){\n            return 0;\n        }\n        if(dp[n][m]!=-1){\n            return dp[n][m];\n        }\n        if(matrix[n][m]==0){\n            // return matrix[n][m];\n            int counti=helperNoOfPath(matrix,n-1,m);\n            int countj=helperNoOfPath(matrix,n,m-1);\n            return dp[n][m]=counti+countj;\n        }else{\n            return 0;\n        }\n    }\n    public int uniquePathsWithObstacles(int[][] grid) {\n        int N=grid.length;\n        int M=grid[0].length;\n        if(N==1&&M==1&&grid[0][0]==1){\n            return 0;\n        }\n        dp=new int[N][M];\n        for(int []auto:dp){\n            Arrays.fill(auto,-1);\n        }\n        return helperNoOfPath(grid,N-1,M-1);\n    }\n}\n"
                    },
                    {
                        "username": "Abdulmajeed",
                        "content": "Iterative solution using stack is giving time limit error even though it takes same amount of time as recursive."
                    },
                    {
                        "username": "darshit4777",
                        "content": "Test case 30/41 will fail if you choose int as your dp table datatype. The question mentions that all test cases are generated to keep the answer upper bounded at 2*10e9, however that is not the case for test-case 30/41. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Human Traffic of Stadium",
        "question_content": "<p>Table: <code>Stadium</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| visit_date    | date    |\n| people        | int     |\n+---------------+---------+\nvisit_date is the column with unique values for this table.\nEach row of this table contains the visit date and visit id to the stadium with the number of people during the visit.\nAs the id increases, the date increases as well.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to display the records with three or more rows with <strong>consecutive</strong> <code>id</code>&#39;s, and the number of people is greater than or equal to 100 for each.</p>\n\n<p>Return the result table ordered by <code>visit_date</code> in <strong>ascending order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nStadium table:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>Output:</strong> \n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\n<strong>Explanation:</strong> \nThe four rows with ids 5, 6, 7, and 8 have consecutive ids and each of them has &gt;= 100 people attended. Note that row 8 was included even though the visit_date was not the next day after row 7.\nThe rows with ids 2 and 3 are not included because we need at least three consecutive ids.\n</pre>\n",
        "solutions": [
            {
                "id": 911779,
                "title": "mysql-use-window-function-for-big-data",
                "content": "## Idea\\nI\\'ve seen pretty many solutions using `join` of three tables or creating temporary tables with `n^3` rows. With my 5-years\\' working experience on data analysis, I can guarantee you this method will cause you \"out of spool space\" issue when you deal with a large table in big data field.\\n\\nI recommend you to learn and master window functions like `lead`, `lag` and use them as often as you can in your codes. These functions are very fast, and whenever you find yourself creating duplicate temp tables, you should ask yourself: can I solve this with window functions.\\n\\n## MySQL \\n```mysql\\nSELECT ID\\n    , visit_date\\n    , people\\nFROM (\\n    SELECT ID\\n        , visit_date\\n        , people\\n        , LEAD(people, 1) OVER (ORDER BY id) nxt\\n        , LEAD(people, 2) OVER (ORDER BY id) nxt2\\n        , LAG(people, 1) OVER (ORDER BY id) pre\\n        , LAG(people, 2) OVER (ORDER BY id) pre2\\n    FROM Stadium\\n) cte \\nWHERE (cte.people >= 100 AND cte.nxt >= 100 AND cte.nxt2 >= 100) \\n    OR (cte.people >= 100 AND cte.nxt >= 100 AND cte.pre >= 100)  \\n    OR (cte.people >= 100 AND cte.pre >= 100 AND cte.pre2 >= 100) \\n```",
                "solutionTags": [],
                "code": "```mysql\\nSELECT ID\\n    , visit_date\\n    , people\\nFROM (\\n    SELECT ID\\n        , visit_date\\n        , people\\n        , LEAD(people, 1) OVER (ORDER BY id) nxt\\n        , LEAD(people, 2) OVER (ORDER BY id) nxt2\\n        , LAG(people, 1) OVER (ORDER BY id) pre\\n        , LAG(people, 2) OVER (ORDER BY id) pre2\\n    FROM Stadium\\n) cte \\nWHERE (cte.people >= 100 AND cte.nxt >= 100 AND cte.nxt2 >= 100) \\n    OR (cte.people >= 100 AND cte.nxt >= 100 AND cte.pre >= 100)  \\n    OR (cte.people >= 100 AND cte.pre >= 100 AND cte.pre2 >= 100) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 700476,
                "title": "mysql-solution",
                "content": "missing records ( due to people >= 100 )  makes ids inconsecutive, which allows you to create a virtual group. \\n```\\nwith t as ( select t1.id , t1.visit_date , t1.people , \\n            id - row_number() OVER(ORDER BY id) as grp\\n       from stadium t1\\n       where people >= 100 \\n          )\\nselect t.id, t.visit_date ,t.people\\nfrom t \\nwhere grp in ( select grp from t group by grp having count(*) >=3  )\\n```",
                "solutionTags": [],
                "code": "```\\nwith t as ( select t1.id , t1.visit_date , t1.people , \\n            id - row_number() OVER(ORDER BY id) as grp\\n       from stadium t1\\n       where people >= 100 \\n          )\\nselect t.id, t.visit_date ,t.people\\nfrom t \\nwhere grp in ( select grp from t group by grp having count(*) >=3  )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483315,
                "title": "mysql-3-solutions-no-join-only-windows-function",
                "content": "### \\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F Hello, here are my solutions to the problem.\\n### Please upvote to motivate me post future solutions. HAPPY CODING \\u2764\\uFE0F\\n##### Any suggestions and improvements are always welcome.\\n##### Solution 1: Preceding, following, very long \\uD83E\\uDD26\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### \\u2705 Runtime: 608 ms, faster than 26.31% of MySQL.\\n\\n```\\nwith q1 as (\\nselect *, \\n     count(*) over( order by id range between current row and 2 following ) following_cnt,\\n     count(*) over( order by id range between 2 preceding and current row ) preceding_cnt,\\n     count(*) over( order by id range between 1 preceding and 1 following ) current_cnt\\nfrom stadium\\nwhere people > 99\\n)\\nselect id, visit_date, people\\nfrom q1\\nwhere following_cnt = 3 or preceding_cnt = 3 or current_cnt = 3\\norder by visit_date\\n```\\n##### Solution 2: Windows function, long, not good, but easy to understand \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### \\u2705 Runtime: 347 ms, faster than 70.12% of MySQL.\\n\\n```\\nwith q1 as (\\nselect id, id - row_number() over() as id_diff\\nfrom stadium\\nwhere people > 99\\n),\\nq2 as (\\nselect *, row_number() over(partition by id_diff) as id_diff_order\\nfrom q1\\n),\\nq3 as (\\nselect id\\nfrom q2\\nwhere id_diff in (select id_diff from q2 where id_diff_order > 2 group by id_diff)\\n)\\nselect *\\nfrom stadium\\nwhere id in (select id from q3)\\norder by visit_date\\n```\\n##### Solution 3: Windows function, shorter and faster \\uD83C\\uDFAF\\n##### \\u2705 Runtime: 290 ms, faster than 91.39% of MySQL.\\n\\n```\\nwith q1 as (\\nselect *, id - row_number() over() as id_diff\\nfrom stadium\\nwhere people > 99\\n)\\nselect id, visit_date, people\\nfrom q1\\nwhere id_diff in (select id_diff from q1 group by id_diff having count(*) > 2)\\norder by visit_date\\n```\\n##### If you like the solutions, please upvote \\uD83D\\uDD3C\\n##### For any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith q1 as (\\nselect *, \\n     count(*) over( order by id range between current row and 2 following ) following_cnt,\\n     count(*) over( order by id range between 2 preceding and current row ) preceding_cnt,\\n     count(*) over( order by id range between 1 preceding and 1 following ) current_cnt\\nfrom stadium\\nwhere people > 99\\n)\\nselect id, visit_date, people\\nfrom q1\\nwhere following_cnt = 3 or preceding_cnt = 3 or current_cnt = 3\\norder by visit_date\\n```\n```\\nwith q1 as (\\nselect id, id - row_number() over() as id_diff\\nfrom stadium\\nwhere people > 99\\n),\\nq2 as (\\nselect *, row_number() over(partition by id_diff) as id_diff_order\\nfrom q1\\n),\\nq3 as (\\nselect id\\nfrom q2\\nwhere id_diff in (select id_diff from q2 where id_diff_order > 2 group by id_diff)\\n)\\nselect *\\nfrom stadium\\nwhere id in (select id from q3)\\norder by visit_date\\n```\n```\\nwith q1 as (\\nselect *, id - row_number() over() as id_diff\\nfrom stadium\\nwhere people > 99\\n)\\nselect id, visit_date, people\\nfrom q1\\nwhere id_diff in (select id_diff from q1 group by id_diff having count(*) > 2)\\norder by visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103781,
                "title": "a-simple-solution",
                "content": "```\\nSELECT s1.* FROM stadium AS s1, stadium AS s2, stadium as s3\\n    WHERE \\n    ((s1.id + 1 = s2.id\\n    AND s1.id + 2 = s3.id)\\n    OR \\n    (s1.id - 1 = s2.id\\n    AND s1.id + 1 = s3.id)\\n    OR\\n    (s1.id - 2 = s2.id\\n    AND s1.id - 1 = s3.id)\\n    )\\n    AND s1.people>=100 \\n    AND s2.people>=100\\n    AND s3.people>=100\\n\\n    GROUP BY s1.id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s1.* FROM stadium AS s1, stadium AS s2, stadium as s3\\n    WHERE \\n    ((s1.id + 1 = s2.id\\n    AND s1.id + 2 = s3.id)\\n    OR \\n    (s1.id - 1 = s2.id\\n    AND s1.id + 1 = s3.id)\\n    OR\\n    (s1.id - 2 = s2.id\\n    AND s1.id - 1 = s3.id)\\n    )\\n    AND s1.people>=100 \\n    AND s2.people>=100\\n    AND s3.people>=100\\n\\n    GROUP BY s1.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488757,
                "title": "ms-sql-solution-95-faster-than-other-ms-sql-submissions",
                "content": "/* Write your T-SQL query statement below */\\nwith cte as\\n(\\n    SELECT id, visit_date, people,\\n    row_number() over(order by id) as rn\\n    FROM stadium\\n    where people >= 100\\n), cte2 as\\n(\\n    SELECT id, visit_date, people, id-rn as diff\\n    from cte\\n)\\nselect id, visit_date, people\\nfrom cte2\\nWHERE diff in (select diff from cte2\\n              group by diff\\n              having count(diff) >= 3)",
                "solutionTags": [],
                "code": "/* Write your T-SQL query statement below */\\nwith cte as\\n(\\n    SELECT id, visit_date, people,\\n    row_number() over(order by id) as rn\\n    FROM stadium\\n    where people >= 100\\n), cte2 as\\n(\\n    SELECT id, visit_date, people, id-rn as diff\\n    from cte\\n)\\nselect id, visit_date, people\\nfrom cte2\\nWHERE diff in (select diff from cte2\\n              group by diff\\n              having count(diff) >= 3)",
                "codeTag": "Unknown"
            },
            {
                "id": 103792,
                "title": "solution-using-join",
                "content": "```\\nSELECT t.* FROM stadium t\\n    LEFT JOIN stadium p1 ON t.id - 1 = p1.id\\n    LEFT JOIN stadium p2 ON t.id - 2 = p2.id\\n    LEFT JOIN stadium n1 ON t.id + 1 = n1.id\\n    LEFT JOIN stadium n2 ON t.id + 2 = n2.id\\nWHERE (t.people >= 100 AND p1.people >= 100 AND p2.people >= 100)\\n     OR (t.people >= 100 AND n1.people >= 100 AND n2.people >= 100)\\n     OR (t.people >= 100 AND n1.people >= 100 AND p1.people >= 100)\\nORDER BY id;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT t.* FROM stadium t\\n    LEFT JOIN stadium p1 ON t.id - 1 = p1.id\\n    LEFT JOIN stadium p2 ON t.id - 2 = p2.id\\n    LEFT JOIN stadium n1 ON t.id + 1 = n1.id\\n    LEFT JOIN stadium n2 ON t.id + 2 = n2.id\\nWHERE (t.people >= 100 AND p1.people >= 100 AND p2.people >= 100)\\n     OR (t.people >= 100 AND n1.people >= 100 AND n2.people >= 100)\\n     OR (t.people >= 100 AND n1.people >= 100 AND p1.people >= 100)\\nORDER BY id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672850,
                "title": "mysql-solutions-easy-to-understand-explanation-cte",
                "content": "Related Questions: \\n1454. Active Users\\n1285. Find the Start and End Number of Continuous Ranges\\n*******************************************\\n# CHOICE 1: easy to understand\\n```\\nSELECT DISTINCT t1.* -- remove duplicate rows\\nFROM stadium t1, stadium t2, stadium t3\\nWHERE t1.people >= 100 AND t2.people >= 100 AND t3.people >= 100\\nAND(\\n\\t(t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) -- return id: 7,8\\n\\tOR (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1) -- return id: 6,7\\n\\tOR (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2) -- return id: 5,6\\n)\\nORDER BY t1.id\\n```\\n\\n**Explanation:**\\nFirst, join 3 tables and get 6x6x6 = 216 possible matches.\\n```\\nSELECT *\\nFROM stadium t1, stadium t2, stadium t3\\nWHERE t1.people >= 100 AND t2.people >= 100 AND t3.people >= 100\\n```\\n![image](https://assets.leetcode.com/users/120668385/image_1591422690.png)\\n\\nThen add one more condition `(t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1)`:\\n![image](https://assets.leetcode.com/users/120668385/image_1591423833.png)\\n\\n```\\nSELECT t1.*\\nFROM stadium t1, stadium t2, stadium t3\\nWHERE t1.people >= 100 AND t2.people >= 100 AND t3.people >= 100\\nAND (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) \\nORDER BY t1.id\\n```\\nYou will get the following result:\\n+------+------------+-----------+ \\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\nt1.id - t2.id = 1 makes sure t1.id is greater than t2.id, which is consecutive.\\nt1.id - t3.id = 2 makes sure t1.id is greater than t2.id, and t2.id is greater than t3.id, which is consecutive.\\n\\nFor t1.Id 2-3-5-6-7-8, t1.id = 2 doesn\\u2019t meet both of the above requirements because id= 2 is the first one\\n![image](https://assets.leetcode.com/users/120668385/image_1591469413.png)\\nFor t1.id = 3, it doesn\\u2019t meet requirement of t1.id - t3.id = 2 because t3.id cannot be 1\\n![image](https://assets.leetcode.com/users/120668385/image_1591469942.png)\\nFor t1.id = 5, it doesn\\u2019t meet requirement of t1.id - t2.id = 1 because t2.id cannot be 4\\n![image](https://assets.leetcode.com/users/120668385/image_1591469873.png)\\nFor t1.id = 6, it doesn\\u2019t meet requirement of t1.id - t3.id = 2 because t3.id cannot be 4\\n![image](https://assets.leetcode.com/users/120668385/image_1591469474.png)\\nFor t1.id = 7, it meets both requirements when t2.id = 6 and t3.id = 5\\n![image](https://assets.leetcode.com/users/120668385/image_1591469484.png)\\nFor t1.id = 8, it meets both requirements when t2.id = 7 and t3.id = 6\\n![image](https://assets.leetcode.com/users/120668385/image_1591469493.png)\\n**********************\\n ![image](https://assets.leetcode.com/users/120668385/image_1591423870.png)\\n  If you use this clause ` (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1)`, you will get the following result:\\n+------+------------+-----------+ \\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n+------+------------+-----------+\\n**********************\\n![image](https://assets.leetcode.com/users/120668385/image_1591423921.png)\\nIf you use this clause `(t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2)`, you will get the following result:\\n+------+------------+-----------+ \\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n+------+------------+-----------+\\n\\nFinally, you just need to combine all the results using OR, and don\\u2019t forget to distinguish the result to remove duplicate results. \\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n**********************\\n# CHOICE 2: using CTE (another kind of solution I made for fun)\\n# \\n```\\nwith cte as(\\n    select *, row_number() over(order by visit_date) as row_id\\n\\tfrom (select * from stadium where people >= 100) t\\n)\\n\\nselect id, visit_date, people \\nfrom stadium, (select min(id) m, max(id) n from cte group by id-row_id having count(id-row_id) >= 3) t\\nwhere id between m and n\\n```\\n\\nThis is a general solution that you can change 3 to any number. \\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT t1.* -- remove duplicate rows\\nFROM stadium t1, stadium t2, stadium t3\\nWHERE t1.people >= 100 AND t2.people >= 100 AND t3.people >= 100\\nAND(\\n\\t(t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) -- return id: 7,8\\n\\tOR (t2.id - t1.id = 1 and t2.id - t3.id = 2 and t1.id - t3.id =1) -- return id: 6,7\\n\\tOR (t3.id - t2.id = 1 and t2.id - t1.id =1 and t3.id - t1.id = 2) -- return id: 5,6\\n)\\nORDER BY t1.id\\n```\n```\\nSELECT *\\nFROM stadium t1, stadium t2, stadium t3\\nWHERE t1.people >= 100 AND t2.people >= 100 AND t3.people >= 100\\n```\n```\\nSELECT t1.*\\nFROM stadium t1, stadium t2, stadium t3\\nWHERE t1.people >= 100 AND t2.people >= 100 AND t3.people >= 100\\nAND (t1.id - t2.id = 1 and t1.id - t3.id = 2 and t2.id - t3.id =1) \\nORDER BY t1.id\\n```\n```\\nwith cte as(\\n    select *, row_number() over(order by visit_date) as row_id\\n\\tfrom (select * from stadium where people >= 100) t\\n)\\n\\nselect id, visit_date, people \\nfrom stadium, (select min(id) m, max(id) n from cte group by id-row_id having count(id-row_id) >= 3) t\\nwhere id between m and n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306278,
                "title": "601-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT id, visit_date, people\\nFROM (\\n  SELECT *, COUNT(*) OVER (PARTITION BY island) AS cnt\\n  FROM (\\n    SELECT *, id - ROW_NUMBER() OVER (ORDER BY id) AS island\\n    FROM Stadium\\n    WHERE people >= 100\\n  ) AS subquery\\n) AS subquery2\\nWHERE cnt >= 3\\nORDER BY visit_date;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT id, visit_date, people\\nFROM (\\n  SELECT *, COUNT(*) OVER (PARTITION BY island) AS cnt\\n  FROM (\\n    SELECT *, id - ROW_NUMBER() OVER (ORDER BY id) AS island\\n    FROM Stadium\\n    WHERE people >= 100\\n  ) AS subquery\\n) AS subquery2\\nWHERE cnt >= 3\\nORDER BY visit_date;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036582,
                "title": "mysql-pretty-solution-easy-to-understand-no-join",
                "content": "**My Approach**\\r\\n\\r\\n```please upvote, if you find it useful```\\r\\n# Code\\r\\n```\\r\\nselect \\r\\n   distinct s1.id ,s1.visit_date, s1.people \\r\\nfrom \\r\\n   Stadium s1,Stadium s2 \\r\\nwhere \\r\\n   (s1.people>=100 \\r\\n        and s1.id+1=s2.id \\r\\n            and s2.people>=100 \\r\\n                and exists(select * from Stadium s3 where s1.id+2=s3.id and s3.people>=100)\\r\\n                )\\r\\nor\\r\\n   (s1.people>=100 \\r\\n        and s1.id-1=s2.id \\r\\n            and s2.people>=100 \\r\\n                and exists(select * from Stadium s3 where s1.id-2=s3.id and s3.people>=100))\\r\\nor\\r\\n    s1.people>=100 \\r\\n       and s1.id+1=s2.id \\r\\n           and s2.people>=100 \\r\\n               and exists(select * from Stadium s3 where s1.id-1=s3.id and s3.people>=100)\\r\\norder by s1.visit_date;\\r\\n```\\r\\n\\r\\n\\r\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```please upvote, if you find it useful```\n```\\r\\nselect \\r\\n   distinct s1.id ,s1.visit_date, s1.people \\r\\nfrom \\r\\n   Stadium s1,Stadium s2 \\r\\nwhere \\r\\n   (s1.people>=100 \\r\\n        and s1.id+1=s2.id \\r\\n            and s2.people>=100 \\r\\n                and exists(select * from Stadium s3 where s1.id+2=s3.id and s3.people>=100)\\r\\n                )\\r\\nor\\r\\n   (s1.people>=100 \\r\\n        and s1.id-1=s2.id \\r\\n            and s2.people>=100 \\r\\n                and exists(select * from Stadium s3 where s1.id-2=s3.id and s3.people>=100))\\r\\nor\\r\\n    s1.people>=100 \\r\\n       and s1.id+1=s2.id \\r\\n           and s2.people>=100 \\r\\n               and exists(select * from Stadium s3 where s1.id-1=s3.id and s3.people>=100)\\r\\norder by s1.visit_date;\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597036,
                "title": "solution-for-mssql-using-row-number-cte-760ms-yah",
                "content": "**How to find consective numbers:**\\nThe difference between id and ROW_Number will be same for consective numbers.\\nFor Example:\\nRow_Number: 1,2,3,4,5,6\\nId: 3,4,5,8,9,10\\nDiff: 2,2,2,4,4,4\\n\\n```\\nwith s1 as(\\nselect id, visit_date, people, (id - ROW_NUMBER() over (ORDER by id)) as Group1\\nfrom stadium\\nwhere people >=100),\\n\\ns2 as(\\nselect group1, count(id) as number\\nfrom s1\\ngroup by group1\\nhaving count(id)>=3)\\n\\nselect a.id, a.visit_date, a.people\\nfrom s1 a\\nwhere a.Group1 in (select group1 from s2)\\n```",
                "solutionTags": [],
                "code": "```\\nwith s1 as(\\nselect id, visit_date, people, (id - ROW_NUMBER() over (ORDER by id)) as Group1\\nfrom stadium\\nwhere people >=100),\\n\\ns2 as(\\nselect group1, count(id) as number\\nfrom s1\\ngroup by group1\\nhaving count(id)>=3)\\n\\nselect a.id, a.visit_date, a.people\\nfrom s1 a\\nwhere a.Group1 in (select group1 from s2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1178211,
                "title": "simple-and-easy-using-row-number",
                "content": "```\\nWITH T AS (\\n    SELECT ID, VISIT_DATE, PEOPLE, ID - ROW_NUMBER() OVER(ORDER BY ID) R\\n    FROM STADIUM\\n    WHERE PEOPLE >= 100\\n)\\n\\nSELECT ID, VISIT_DATE, PEOPLE\\nFROM T\\nWHERE R IN (SELECT R FROM T GROUP BY R HAVING COUNT(R) >= 3)\\n```",
                "solutionTags": [],
                "code": "```\\nWITH T AS (\\n    SELECT ID, VISIT_DATE, PEOPLE, ID - ROW_NUMBER() OVER(ORDER BY ID) R\\n    FROM STADIUM\\n    WHERE PEOPLE >= 100\\n)\\n\\nSELECT ID, VISIT_DATE, PEOPLE\\nFROM T\\nWHERE R IN (SELECT R FROM T GROUP BY R HAVING COUNT(R) >= 3)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296009,
                "title": "easy-mysql-solution-without-any-built-in-sql-functions",
                "content": "```\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere s1.people>=100 and s2.people>=100 and s3.people>=100 and ((s2.id=s1.id+1 and s3.id=s1.id+2)\\n                                                                or (s2.id=s1.id-1 and s3.id=s1.id+1)\\n                                                                or (s2.id=s1.id-1 and s3.id=s1.id-2))\\norder by id asc\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere s1.people>=100 and s2.people>=100 and s3.people>=100 and ((s2.id=s1.id+1 and s3.id=s1.id+2)\\n                                                                or (s2.id=s1.id-1 and s3.id=s1.id+1)\\n                                                                or (s2.id=s1.id-1 and s3.id=s1.id-2))\\norder by id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1527033,
                "title": "simple-mysql-solution-without-3-self-join-easy-transfer-to-n",
                "content": "```\\nWITH diff_group AS (\\n    SELECT id\\n            ,visit_date\\n            ,people\\n            ,id - row_number() OVER(ORDER BY id) AS diff\\n    FROM Stadium\\n    WHERE people >= 100\\n)\\n```\\n![image](https://assets.leetcode.com/users/images/33f8d05f-01ab-450e-a8b4-a1f8f39cfb2a_1634511060.7611206.png)\\n- Some records are removed because people < 100, for example, id = 1, 4\\n\\tbut remaining  records with id = 2, 3 as well as id =  5, 6, 7, 8 are still consective \\n\\n- It\\'s obvious that consective ids would belong to the same diff group\\n- Filter out all records when the number of items in the same diff group >= 3, and then we got the answer:\\n```\\nSELECT id\\n        ,visit_date\\n        ,people \\nFROM diff_group\\nWHERE diff IN \\n            (SELECT diff\\n            FROM diff_group \\n            GROUP BY diff\\n            HAVING count(id) >= 3)\\n;\\n```\\n[Refernce] Idea was borrow from this post: https://leetcode.com/problems/human-traffic-of-stadium/discuss/700476/MySQL-solution",
                "solutionTags": [],
                "code": "```\\nWITH diff_group AS (\\n    SELECT id\\n            ,visit_date\\n            ,people\\n            ,id - row_number() OVER(ORDER BY id) AS diff\\n    FROM Stadium\\n    WHERE people >= 100\\n)\\n```\n```\\nSELECT id\\n        ,visit_date\\n        ,people \\nFROM diff_group\\nWHERE diff IN \\n            (SELECT diff\\n            FROM diff_group \\n            GROUP BY diff\\n            HAVING count(id) >= 3)\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1414957,
                "title": "explained-solution-with-ranking-window-function-easy-solve",
                "content": "```\\n# Write your MySQL query statement below\\nwith rank_ids as \\n(\\n    select \\n        id, \\n        visit_date, \\n        people,\\n        id - row_number() over(order by id) rnk \\n    from \\n        stadium \\n    where \\n        people>=100\\n),\\nconsec_ids as (\\n    select \\n        rnk\\n    from \\n        rank_ids \\n    group by \\n        rnk\\n    having\\n        count(rnk) >= 3\\n)\\nselect\\n    id, \\n    visit_date, \\n    people\\nfrom\\n    rank_ids\\nwhere \\n    rnk in (select rnk from consec_ids)\\norder by \\n    visit_date\\n```\\nExplanation - \\nIf we use a `row_number` window ordered by `id` where `people` >= 100 assuming `id\\'s` are gonna be unique we will get a unique incremental `row_num` (think of it as id for a new table which consist only of ids with people over 100). \\nNow if we observe the logic below `id - row_num` increments for every break of consecutive chain of 100+ days. `count` of the `id - row_num` will result more than 3 incase where our window ***size is >=3***\\n\\n```\\n# +------+------------+-----------+------------+------------+\\n# | id   | visit_date | people    | row_num    |id - row_num|\\n# +------+------------+-----------+------------+------------+\\n# | 1    | 2017-01-01 | 10        |-           |-           |\\n# | 2    | 2017-01-02 | 109       |1           |1           |\\n# | 3    | 2017-01-03 | 150       |2           |1           | window of 1 has size -> (2)\\n# | 4    | 2017-01-04 | 99        |-           |-           |\\n# | 5    | 2017-01-05 | 145       |3           |2           |\\n# | 6    | 2017-01-06 | 1455      |4           |2           |\\n# | 7    | 2017-01-07 | 199       |5           |2           |\\n# | 8    | 2017-01-09 | 188       |6           |2           | window of 2 has size -> (4)\\n# +------+------------+-----------+------------+------------+\\n```\\n\\n> Remember we are counting the instances of difference between `id` and `row_num` which will always be of same magnitude for a given consecutive group. 1 and 2 for groups in the example above.",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith rank_ids as \\n(\\n    select \\n        id, \\n        visit_date, \\n        people,\\n        id - row_number() over(order by id) rnk \\n    from \\n        stadium \\n    where \\n        people>=100\\n),\\nconsec_ids as (\\n    select \\n        rnk\\n    from \\n        rank_ids \\n    group by \\n        rnk\\n    having\\n        count(rnk) >= 3\\n)\\nselect\\n    id, \\n    visit_date, \\n    people\\nfrom\\n    rank_ids\\nwhere \\n    rnk in (select rnk from consec_ids)\\norder by \\n    visit_date\\n```\n```\\n# +------+------------+-----------+------------+------------+\\n# | id   | visit_date | people    | row_num    |id - row_num|\\n# +------+------------+-----------+------------+------------+\\n# | 1    | 2017-01-01 | 10        |-           |-           |\\n# | 2    | 2017-01-02 | 109       |1           |1           |\\n# | 3    | 2017-01-03 | 150       |2           |1           | window of 1 has size -> (2)\\n# | 4    | 2017-01-04 | 99        |-           |-           |\\n# | 5    | 2017-01-05 | 145       |3           |2           |\\n# | 6    | 2017-01-06 | 1455      |4           |2           |\\n# | 7    | 2017-01-07 | 199       |5           |2           |\\n# | 8    | 2017-01-09 | 188       |6           |2           | window of 2 has size -> (4)\\n# +------+------------+-----------+------------+------------+\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237295,
                "title": "ms-sql-simple-lead-and-lag",
                "content": "Mysql sucks because it is so old fashioned it does not support window functions. Without them, you cant survive in real world.\\n\\nI have tested this on my local machine:\\n\\nSELECT id, date, people\\nFROM\\n   (SELECT id, date, people, lead(people) OVER (ORDER BY id ASC) as next1,\\n\\t\\t\\t\\t       lead(people,2) OVER (ORDER BY id ASC ) as next2,\\n\\t\\t\\t\\t\\t   lag(people) OVER (ORDER BY id ASC) as prev1,\\n\\t\\t\\t\\t       lag(people,2) OVER (ORDER BY id ASC ) as prev2\\n\\t\\t\\t\\t\\n\\tFROM stadium\\n   ) AS cons_sal\\t\\t\\nWHERE (people>100 and next1>100 and next2>100) or (people>100 and prev1>100 and prev2>100);",
                "solutionTags": [],
                "code": "Mysql sucks because it is so old fashioned it does not support window functions. Without them, you cant survive in real world.\\n\\nI have tested this on my local machine:\\n\\nSELECT id, date, people\\nFROM\\n   (SELECT id, date, people, lead(people) OVER (ORDER BY id ASC) as next1,\\n\\t\\t\\t\\t       lead(people,2) OVER (ORDER BY id ASC ) as next2,\\n\\t\\t\\t\\t\\t   lag(people) OVER (ORDER BY id ASC) as prev1,\\n\\t\\t\\t\\t       lag(people,2) OVER (ORDER BY id ASC ) as prev2\\n\\t\\t\\t\\t\\n\\tFROM stadium\\n   ) AS cons_sal\\t\\t\\nWHERE (people>100 and next1>100 and next2>100) or (people>100 and prev1>100 and prev2>100);",
                "codeTag": "Unknown"
            },
            {
                "id": 2914407,
                "title": "simplest-solution-ever",
                "content": "# Please upvote if you find it helpful, thank you.\\r\\n# Intuition\\r\\n**Using window functions and WHERE clause [Accepted]**\\r\\n\\r\\n# Approach:\\r\\n**it required only two sub queries to solve the problem**\\r\\n# first sub query: \\r\\nSelect the days with more than 100 people attending the stadium\\r\\n# second sub query:\\r\\nget the first lead , second lead , first lag and second lag\\r\\n# outer query\\r\\n**filter the records with the following conditions :**\\r\\n(people > 100 and first lead people > 100 and second lead people > 100)\\r\\n**or**\\r\\n**\"to handle case that there is an id before the last record with people more than 100\"**\\r\\n(people > 100 and first lead people > 100 and first lag people > 100)\\r\\n**or**\\r\\n**\"to handle case that there is an id second to last record with people more than 100\"**\\r\\n(people > 100 and first lag people > 100 and second lag people > 100)\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nselect id  , visit_date  , people \\r\\nfrom\\r\\n(\\r\\n    select * , \\r\\n           lead(PeopleMoreThan100) over (order by id) lead1,\\r\\n           lead(PeopleMoreThan100,2) over(order by id) lead2,\\r\\n           lag(PeopleMoreThan100) over(order by id) lag1,\\r\\n           lag(PeopleMoreThan100,2) over(order by id) lag2\\r\\n    from\\r\\n    (\\r\\n        select id , visit_date  , people ,\\r\\n               case when people>= 100\\r\\n                    then 1\\r\\n                    else 0\\r\\n                    end as PeopleMoreThan100\\r\\n        from stadium\\r\\n    ) temp\\r\\n)temp1\\r\\nwhere (PeopleMoreThan100 = 1 and lead1 = 1 and lead2 = 1)\\r\\n      or\\r\\n      (PeopleMoreThan100 = 1 and lead1 = 1 and lag1 =1)\\r\\n      or\\r\\n      (PeopleMoreThan100 = 1 and lag1 = 1 and lag2 = 1)\\r\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Sliding Window"
                ],
                "code": "```\\r\\nselect id  , visit_date  , people \\r\\nfrom\\r\\n(\\r\\n    select * , \\r\\n           lead(PeopleMoreThan100) over (order by id) lead1,\\r\\n           lead(PeopleMoreThan100,2) over(order by id) lead2,\\r\\n           lag(PeopleMoreThan100) over(order by id) lag1,\\r\\n           lag(PeopleMoreThan100,2) over(order by id) lag2\\r\\n    from\\r\\n    (\\r\\n        select id , visit_date  , people ,\\r\\n               case when people>= 100\\r\\n                    then 1\\r\\n                    else 0\\r\\n                    end as PeopleMoreThan100\\r\\n        from stadium\\r\\n    ) temp\\r\\n)temp1\\r\\nwhere (PeopleMoreThan100 = 1 and lead1 = 1 and lead2 = 1)\\r\\n      or\\r\\n      (PeopleMoreThan100 = 1 and lead1 = 1 and lag1 =1)\\r\\n      or\\r\\n      (PeopleMoreThan100 = 1 and lag1 = 1 and lag2 = 1)\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868271,
                "title": "row-number-no-join-or-union",
                "content": "The idea is to use island to find consecutive entries. Very easy to use. \\n```\\nwith c1 as (select *, id - row_number() over (order by id) as island\\nfrom stadium where people >= 100 )\\nselect id, visit_date, people from c1\\nwhere island in (select island from c1 group by 1 having count(*) > 2)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith c1 as (select *, id - row_number() over (order by id) as island\\nfrom stadium where people >= 100 )\\nselect id, visit_date, people from c1\\nwhere island in (select island from c1 group by 1 having count(*) > 2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113053,
                "title": "a-general-idea-to-solve-all-consecutive-number-questions",
                "content": "the idae here is using id-row_number() to tag group of consecutive numbers\\n\\nwith cte as \\n(\\nselect id,visit_date,people,id-row_number() over (order by id) as n\\nfrom \\n(select *from stadium where people>=100) t\\n),\\ncte2 as \\n(\\nselect n\\nfrom cte \\ngroup by n\\nhaving count(*) >=3\\n    )\\n    \\n    select id,visit_date,people\\n    from cte\\n    where n in (select n from cte2)\\n    order by 2",
                "solutionTags": [],
                "code": "the idae here is using id-row_number() to tag group of consecutive numbers\\n\\nwith cte as \\n(\\nselect id,visit_date,people,id-row_number() over (order by id) as n\\nfrom \\n(select *from stadium where people>=100) t\\n),\\ncte2 as \\n(\\nselect n\\nfrom cte \\ngroup by n\\nhaving count(*) >=3\\n    )\\n    \\n    select id,visit_date,people\\n    from cte\\n    where n in (select n from cte2)\\n    order by 2",
                "codeTag": "Unknown"
            },
            {
                "id": 3710876,
                "title": "mysql-solution-for-human-traffic-of-stadium-problem",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThe intuition behind the provided solution is to find consecutive rows with three or more consecutive ids and people count greater than or equal to 100.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n- In this query, we join the Stadium table with itself three times (as t1, t2, and t3). We apply the condition that the people column should be greater than or equal to 100 for all three rows.\\r\\n\\r\\n- The conditions inside the AND statement check for three possible combinations of consecutive rows: (t1, t2, t3), (t2, t1, t3), and (t3, t2, t1). For each combination, we compare the differences between the id values to ensure they are consecutive.\\r\\n\\r\\n- Finally, we select distinct rows from t1 to avoid duplicate entries and order the result by visit_date in ascending order.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nThe time complexity of this solution is O(n^3), where n is the number of rows in the Stadium table. This is because we are joining the table with itself three times, resulting in cubic time complexity\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nIn terms of space complexity, the solution requires O(1) additional space as we are not using any additional data structures.\\r\\n\\r\\n# Code\\r\\n```\\r\\nSELECT DISTINCT t1.*\\r\\nFROM Stadium t1, Stadium t2, Stadium t3\\r\\nWHERE t1.people >= 100 AND t2.people >= 100 AND t3.people >= 100\\r\\n  AND (\\r\\n    (t1.id - t2.id = 1 AND t1.id - t3.id = 2 AND t2.id - t3.id = 1) OR\\r\\n    (t2.id - t1.id = 1 AND t2.id - t3.id = 2 AND t1.id - t3.id = 1) OR\\r\\n    (t3.id - t2.id = 1 AND t2.id - t1.id = 1 AND t3.id - t1.id = 2)\\r\\n  )\\r\\nORDER BY t1.visit_date;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\nSELECT DISTINCT t1.*\\r\\nFROM Stadium t1, Stadium t2, Stadium t3\\r\\nWHERE t1.people >= 100 AND t2.people >= 100 AND t3.people >= 100\\r\\n  AND (\\r\\n    (t1.id - t2.id = 1 AND t1.id - t3.id = 2 AND t2.id - t3.id = 1) OR\\r\\n    (t2.id - t1.id = 1 AND t2.id - t3.id = 2 AND t1.id - t3.id = 1) OR\\r\\n    (t3.id - t2.id = 1 AND t2.id - t1.id = 1 AND t3.id - t1.id = 2)\\r\\n  )\\r\\nORDER BY t1.visit_date;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195027,
                "title": "mysql-faster-than-99",
                "content": "```\\nselect * from \\n(select * from Stadium where people>=100) S\\nwhere \\n(S.id+1 in (select id from Stadium where people>=100) and S.id+2 in (select id from Stadium where people>=100))\\nor \\n(S.id+1 in (select id from Stadium where people>=100) and S.id-1 in (select id from Stadium where people>=100))\\nor\\n(S.id-1 in (select id from Stadium where people>=100) and S.id-2 in (select id from Stadium where people>=100))",
                "solutionTags": [],
                "code": "```\\nselect * from \\n(select * from Stadium where people>=100) S\\nwhere \\n(S.id+1 in (select id from Stadium where people>=100) and S.id+2 in (select id from Stadium where people>=100))\\nor \\n(S.id+1 in (select id from Stadium where people>=100) and S.id-1 in (select id from Stadium where people>=100))\\nor\\n(S.id-1 in (select id from Stadium where people>=100) and S.id-2 in (select id from Stadium where people>=100))",
                "codeTag": "Unknown"
            },
            {
                "id": 2718151,
                "title": "easy-mysql-solution-left-joins",
                "content": "```\\nselect s.id, s.visit_date, s.people\\nfrom Stadium s\\nleft join Stadium ls on ls.people >= 100 and ls.id = s.id - 1\\nleft join Stadium rs on rs.people >= 100 and rs.id = s.id + 1\\nleft join Stadium lls on lls.people >= 100 and lls.id = s.id - 2\\nleft join Stadium rrs on rrs.people >= 100 and rrs.id = s.id + 2\\nwhere s.people >= 100 and (\\n    (ls.id is not null and rs.id is not null) \\n    or\\n    (ls.id is not null and lls.id is not null)\\n    or\\n    (rs.id is not null and rrs.id is not null)\\n)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s.id, s.visit_date, s.people\\nfrom Stadium s\\nleft join Stadium ls on ls.people >= 100 and ls.id = s.id - 1\\nleft join Stadium rs on rs.people >= 100 and rs.id = s.id + 1\\nleft join Stadium lls on lls.people >= 100 and lls.id = s.id - 2\\nleft join Stadium rrs on rrs.people >= 100 and rrs.id = s.id + 2\\nwhere s.people >= 100 and (\\n    (ls.id is not null and rs.id is not null) \\n    or\\n    (ls.id is not null and lls.id is not null)\\n    or\\n    (rs.id is not null and rrs.id is not null)\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2431333,
                "title": "mysql-3-line-solution-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n```\\nWITH cte1 AS (SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2 AS (SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;\\n```\\n**Runtime:** 417 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte1 AS (SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2 AS (SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 679774,
                "title": "select-distinct-consecutive-ids-first-human-traffic-of-stadium",
                "content": "```\\nSELECT id, visit_date, people\\nFROM stadium\\nWHERE id IN (\\n    SELECT DISTINCT s1.id\\n    FROM\\n        stadium s1,\\n        stadium s2,\\n        stadium s3\\n    WHERE\\n        ((s1.id + 1 = s2.id AND s2.id + 1 = s3.id) OR\\n         (s3.id + 1 = s1.id AND s1.id + 1 = s2.id) OR\\n         (s2.id + 1 = s3.id AND s3.id + 1 = s1.id)) AND\\n        s1.people >= 100 AND\\n        s2.people >= 100 AND\\n        s3.people >= 100\\n) ORDER BY id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT id, visit_date, people\\nFROM stadium\\nWHERE id IN (\\n    SELECT DISTINCT s1.id\\n    FROM\\n        stadium s1,\\n        stadium s2,\\n        stadium s3\\n    WHERE\\n        ((s1.id + 1 = s2.id AND s2.id + 1 = s3.id) OR\\n         (s3.id + 1 = s1.id AND s1.id + 1 = s2.id) OR\\n         (s2.id + 1 = s3.id AND s3.id + 1 = s1.id)) AND\\n        s1.people >= 100 AND\\n        s2.people >= 100 AND\\n        s3.people >= 100\\n) ORDER BY id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290805,
                "title": "simple-easy-to-read-solution-beats-100-of-cases",
                "content": "```\\nWITH cte1 AS (\\n    SELECT  id,\\n            visit_date,\\n            people,\\n            CASE WHEN people >= 100 THEN 1 ELSE 0 END AS over_100_people_flag\\n    FROM    Stadium\\n),\\n\\ncte2 AS (\\n    SELECT  id,\\n            visit_date,\\n            people,\\n            SUM(over_100_people_flag) OVER(ORDER BY visit_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS preceding_count,\\n            SUM(over_100_people_flag) OVER(ORDER BY visit_date ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS following_count,\\n            SUM(over_100_people_flag) OVER(ORDER BY visit_date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS middle_count\\n    FROM cte1\\n)\\n\\nSELECT  id, visit_date, people\\nFROM    cte2\\nWHERE   preceding_count = 3\\nOR      following_count = 3\\nOR      middle_count    = 3\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte1 AS (\\n    SELECT  id,\\n            visit_date,\\n            people,\\n            CASE WHEN people >= 100 THEN 1 ELSE 0 END AS over_100_people_flag\\n    FROM    Stadium\\n),\\n\\ncte2 AS (\\n    SELECT  id,\\n            visit_date,\\n            people,\\n            SUM(over_100_people_flag) OVER(ORDER BY visit_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS preceding_count,\\n            SUM(over_100_people_flag) OVER(ORDER BY visit_date ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS following_count,\\n            SUM(over_100_people_flag) OVER(ORDER BY visit_date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS middle_count\\n    FROM cte1\\n)\\n\\nSELECT  id, visit_date, people\\nFROM    cte2\\nWHERE   preceding_count = 3\\nOR      following_count = 3\\nOR      middle_count    = 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 275148,
                "title": "how-to-understand-consecutive-3-rows",
                "content": "(1) It seems that 3 consecutive rows means that the ids is consecutive not the visit_date based on the test cases.\\nSo if the ids is consecutive, the  following solution works:\\n# the id is consecutive \\nSELECT DISTINCT stadium.id, stadium.visit_date, stadium.people\\nFROM stadium, (\\n    SELECT DISTINCT s1.id, s1.visit_date, s1.people\\nFROM stadium s1, stadium s2\\nWHERE s1.people >= 100 \\n      AND s2.people >= 100\\n      AND (s1.id - s2.id) BETWEEN 0 AND 2\\nGROUP BY s1.visit_date\\nHAVING COUNT(DISTINCT s2.id) = 3) A\\nWHERE (A.id - stadium.id) BETWEEN 0 AND 2\\n\\n(2) IF it means the visit_date is consecutive, we should tailor the above solution to the following one:\\n# the visit_date is consecutive\\n SELECT DISTINCT stadium.id, stadium.visit_date, stadium.people\\n FROM stadium, (\\n     SELECT DISTINCT s1.id, s1.visit_date, s1.people\\n FROM stadium s1, stadium s2\\n WHERE s1.people >= 100 \\n       AND s2.people >= 100\\n       AND DATEDIFF(s1.visit_date, s2.visit_date) BETWEEN 0 AND 2\\nGROUP BY s1.visit_date\\nHAVING COUNT(DISTINCT s2.visit_date) = 3) A\\nWHERE DATEDIFF(A.visit_date, stadium.visit_date) BETWEEN 0 AND 2\\n\\n        \\n",
                "solutionTags": [],
                "code": "(1) It seems that 3 consecutive rows means that the ids is consecutive not the visit_date based on the test cases.\\nSo if the ids is consecutive, the  following solution works:\\n# the id is consecutive \\nSELECT DISTINCT stadium.id, stadium.visit_date, stadium.people\\nFROM stadium, (\\n    SELECT DISTINCT s1.id, s1.visit_date, s1.people\\nFROM stadium s1, stadium s2\\nWHERE s1.people >= 100 \\n      AND s2.people >= 100\\n      AND (s1.id - s2.id) BETWEEN 0 AND 2\\nGROUP BY s1.visit_date\\nHAVING COUNT(DISTINCT s2.id) = 3) A\\nWHERE (A.id - stadium.id) BETWEEN 0 AND 2\\n\\n(2) IF it means the visit_date is consecutive, we should tailor the above solution to the following one:\\n# the visit_date is consecutive\\n SELECT DISTINCT stadium.id, stadium.visit_date, stadium.people\\n FROM stadium, (\\n     SELECT DISTINCT s1.id, s1.visit_date, s1.people\\n FROM stadium s1, stadium s2\\n WHERE s1.people >= 100 \\n       AND s2.people >= 100\\n       AND DATEDIFF(s1.visit_date, s2.visit_date) BETWEEN 0 AND 2\\nGROUP BY s1.visit_date\\nHAVING COUNT(DISTINCT s2.visit_date) = 3) A\\nWHERE DATEDIFF(A.visit_date, stadium.visit_date) BETWEEN 0 AND 2\\n\\n        \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3914213,
                "title": "solution-with-only-1-cte-and-3-where-clauses",
                "content": "# Intuition\\nIt\\'s easy because IDs are consecutive INTEGER.\\n\\n# Approach\\n \\nFirst step : we create the CTE selecting IDs with at least 100 people.\\n\\nLast step : we select all the rows in the Stadium table and we apply 3 filters in the WHERE CLAUSE :\\n - First filter : a row can be selected only if the 2 preceding IDs are in the CTE\\n - Second filter : a row can be selected only if the 2 following IDs are in the CTE \\n - Third filter : a row can be selected only if the 1 preceding and 1 following IDs are in the CTE.\\n\\nNo need to order because the table Stadium is already ordered.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH cte AS (\\n  SELECT id\\n  FROM Stadium\\n  WHERE people > 99\\n)\\nSELECT *\\nFROM Stadium\\nWHERE (id-1 IN (TABLE cte) AND id-2 IN (TABLE cte) AND people > 99)\\nOR (id+1 IN (TABLE cte) AND id+2 IN (TABLE cte) AND people > 99)\\nOR (id+1 IN (TABLE cte) AND id-1 IN (TABLE cte) AND people > 99)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH cte AS (\\n  SELECT id\\n  FROM Stadium\\n  WHERE people > 99\\n)\\nSELECT *\\nFROM Stadium\\nWHERE (id-1 IN (TABLE cte) AND id-2 IN (TABLE cte) AND people > 99)\\nOR (id+1 IN (TABLE cte) AND id+2 IN (TABLE cte) AND people > 99)\\nOR (id+1 IN (TABLE cte) AND id-1 IN (TABLE cte) AND people > 99)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650104,
                "title": "best-sql-solution-no-hard-coding",
                "content": "# No Hard Coding \\n- *Number of consecutive rows can be changed to any desired number.*\\n- *Just replace \\'3\\' based on question.* \\n\\n# Code\\n```\\nWITH CTE AS \\n(\\n    SELECT *, ROW_NUMBER() OVER(ORDER BY visit_date) as row_num\\n    FROM (SELECT * FROM Stadium WHERE people >=100) sub\\n)\\nSELECT id, visit_date, people\\nFROM \\n    Stadium,\\n    (SELECT MIN(ID) m, MAX(id) n FROM CTE GROUP BY id-row_num HAVING COUNT(id-row_num) >= 3) sub\\nWHERE id BETWEEN m AND n;\\n```\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH CTE AS \\n(\\n    SELECT *, ROW_NUMBER() OVER(ORDER BY visit_date) as row_num\\n    FROM (SELECT * FROM Stadium WHERE people >=100) sub\\n)\\nSELECT id, visit_date, people\\nFROM \\n    Stadium,\\n    (SELECT MIN(ID) m, MAX(id) n FROM CTE GROUP BY id-row_num HAVING COUNT(id-row_num) >= 3) sub\\nWHERE id BETWEEN m AND n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3614550,
                "title": "step-by-step-explanation",
                "content": "# Approach\\r\\n1. ```ge100``` - records with people >= 100.\\r\\n2. ```range_edges_all``` - starts and ends of all consecutive ranges.\\r\\n3. ```range_edges``` - starts and ends of consecutive ranges with length >= 3.\\r\\n4. Finally we find records wich match our ranges.\\r\\n\\r\\n# Code\\r\\n```\\r\\nwith \\r\\nge100 as (\\r\\n    select *\\r\\n    from stadium\\r\\n    where people >= 100\\r\\n),\\r\\nrange_edges_all as (\\r\\n    select *, row_number() over(order by id) n\\r\\n    from ge100 g\\r\\n    where not exists(select id from ge100 gg where g.id = gg.id-1)\\r\\n\\r\\n    union\\r\\n\\r\\n    select *, row_number() over(order by id)\\r\\n    from ge100 g\\r\\n    where not exists(select id from ge100 gg where g.id = gg.id+1)\\r\\n),\\r\\nrange_edges as (\\r\\n    select min(id) minn, max(id) maxx\\r\\n    from range_edges_all\\r\\n    group by n\\r\\n    having max(id) - min(id) >= 2\\r\\n)\\r\\n\\r\\nselect s.id, visit_date, people\\r\\nfrom stadium s\\r\\njoin range_edges re\\r\\n    on s.id between re.minn and re.maxx\\r\\norder by visit_date\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```ge100```\n```range_edges_all```\n```range_edges```\n```\\r\\nwith \\r\\nge100 as (\\r\\n    select *\\r\\n    from stadium\\r\\n    where people >= 100\\r\\n),\\r\\nrange_edges_all as (\\r\\n    select *, row_number() over(order by id) n\\r\\n    from ge100 g\\r\\n    where not exists(select id from ge100 gg where g.id = gg.id-1)\\r\\n\\r\\n    union\\r\\n\\r\\n    select *, row_number() over(order by id)\\r\\n    from ge100 g\\r\\n    where not exists(select id from ge100 gg where g.id = gg.id+1)\\r\\n),\\r\\nrange_edges as (\\r\\n    select min(id) minn, max(id) maxx\\r\\n    from range_edges_all\\r\\n    group by n\\r\\n    having max(id) - min(id) >= 2\\r\\n)\\r\\n\\r\\nselect s.id, visit_date, people\\r\\nfrom stadium s\\r\\njoin range_edges re\\r\\n    on s.id between re.minn and re.maxx\\r\\norder by visit_date\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455274,
                "title": "simple-short-querry",
                "content": "with group_num as (select * ,\\nrow_number () over(order by visit_date) as \\'row\\',\\nid - row_number () over(order by visit_date) as \\'grp\\'\\nfrom stadium where people >=100 )\\n\\nselect id,visit_date,people from group_num \\nwhere grp in (select grp from group_num group by grp having count(1) >=3)",
                "solutionTags": [],
                "code": "with group_num as (select * ,\\nrow_number () over(order by visit_date) as \\'row\\',\\nid - row_number () over(order by visit_date) as \\'grp\\'\\nfrom stadium where people >=100 )\\n\\nselect id,visit_date,people from group_num \\nwhere grp in (select grp from group_num group by grp having count(1) >=3)",
                "codeTag": "Unknown"
            },
            {
                "id": 2314549,
                "title": "generic-solution-for-n-consecutive-rows-with-window-function-dense-rank",
                "content": "with cte as\\n(\\nSELECT id, visit_date, people,\\ndense_rank() over(order by id) as rn\\nFROM stadium\\nwhere people >= 100\\n), cte2 as\\n(\\nSELECT id, visit_date, people, id-rn as diff\\nfrom cte\\n)\\nselect id, visit_date, people\\nfrom cte2\\nWHERE diff in (select diff from cte2\\ngroup by diff\\nhaving count(diff) >= 3)\\n\\nref :- https://learnsql.com/cookbook/whats-the-difference-between-rank-and-dense_rank-in-sql/",
                "solutionTags": [],
                "code": "with cte as\\n(\\nSELECT id, visit_date, people,\\ndense_rank() over(order by id) as rn\\nFROM stadium\\nwhere people >= 100\\n), cte2 as\\n(\\nSELECT id, visit_date, people, id-rn as diff\\nfrom cte\\n)\\nselect id, visit_date, people\\nfrom cte2\\nWHERE diff in (select diff from cte2\\ngroup by diff\\nhaving count(diff) >= 3)\\n\\nref :- https://learnsql.com/cookbook/whats-the-difference-between-rank-and-dense_rank-in-sql/",
                "codeTag": "Unknown"
            },
            {
                "id": 2273838,
                "title": "no-hard-coding-easy-to-understand-mysql-solution-with-window-function-and-cte",
                "content": "```\\nWITH cte AS(SELECT *, id - RANK() OVER(ORDER BY id) AS diff\\n            FROM Stadium\\n            WHERE people >= 100),\\n\\nfinal AS(SELECT id, visit_date, people, COUNT(1) OVER(PARTITION BY diff) AS consec_nums\\n        FROM cte)\\n\\nSELECT id, visit_date, people\\nFROM final\\nWHERE consec_nums >= 3;\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte AS(SELECT *, id - RANK() OVER(ORDER BY id) AS diff\\n            FROM Stadium\\n            WHERE people >= 100),\\n\\nfinal AS(SELECT id, visit_date, people, COUNT(1) OVER(PARTITION BY diff) AS consec_nums\\n        FROM cte)\\n\\nSELECT id, visit_date, people\\nFROM final\\nWHERE consec_nums >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2203838,
                "title": "ms-sql-straightforward-solution-with-lag-and-lead",
                "content": "```\\n/* Write your T-SQL query statement below */\\n\\n\\n;with tmp as\\n(\\n    select  id,\\n            visit_date,\\n            people,\\n            Lag(people,1) OVER (ORDER BY id) as prev,\\n            Lead(people,1) OVER (ORDER BY id) as next\\n    from Stadium\\n)\\n\\nselect  distinct\\n        a.id,\\n        a.visit_date,\\n        a.people\\nfrom Stadium a\\njoin tmp t on Abs(a.id-t.id)<2 and t.prev>=100 and t.next>=100 and t.people>=100\\nwhere a.people>=100\\norder by a.visit_date\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\n;with tmp as\\n(\\n    select  id,\\n            visit_date,\\n            people,\\n            Lag(people,1) OVER (ORDER BY id) as prev,\\n            Lead(people,1) OVER (ORDER BY id) as next\\n    from Stadium\\n)\\n\\nselect  distinct\\n        a.id,\\n        a.visit_date,\\n        a.people\\nfrom Stadium a\\njoin tmp t on Abs(a.id-t.id)<2 and t.prev>=100 and t.next>=100 and t.people>=100\\nwhere a.people>=100\\norder by a.visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805541,
                "title": "ms-sql-use-dense-rank-to-flag-contiguous-ids",
                "content": "```\\n-- Use DENSE_RANK to build a flag for groups of contiguous IDs\\nWITH grouped_visit AS\\n(\\n    SELECT\\n        *,\\n        (id - DENSE_RANK() OVER(ORDER BY id ASC)) as grouping_flag\\n    FROM Stadium\\n    WHERE people >= 100\\n)\\n-- Subquery: For every group flag, select only the ones with more than 3 members (consecutive IDs)\\n-- Query: select the ids of the people belonging to the groups listed by Subquery\\nSELECT\\n    id, visit_date, people\\nFROM grouped_visit\\nWHERE grouping_flag IN (SELECT grouping_flag FROM grouped_visit GROUP BY grouping_flag HAVING COUNT(*) >=3)\\n```",
                "solutionTags": [],
                "code": "```\\n-- Use DENSE_RANK to build a flag for groups of contiguous IDs\\nWITH grouped_visit AS\\n(\\n    SELECT\\n        *,\\n        (id - DENSE_RANK() OVER(ORDER BY id ASC)) as grouping_flag\\n    FROM Stadium\\n    WHERE people >= 100\\n)\\n-- Subquery: For every group flag, select only the ones with more than 3 members (consecutive IDs)\\n-- Query: select the ids of the people belonging to the groups listed by Subquery\\nSELECT\\n    id, visit_date, people\\nFROM grouped_visit\\nWHERE grouping_flag IN (SELECT grouping_flag FROM grouped_visit GROUP BY grouping_flag HAVING COUNT(*) >=3)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1664832,
                "title": "mysql-row-number",
                "content": "```\\nWITH temp AS\\n(SELECT\\n    id,\\n    visit_date,\\n    people,\\n    ROW_NUMBER() OVER (ORDER BY id) AS my_rank\\nFROM \\n    Stadium\\nWHERE \\n    people >= 100)\\n    \\nSELECT\\n    id,\\n    visit_date,\\n    people\\nFROM \\n    temp\\nWHERE id-my_rank IN (SELECT id-my_rank FROM temp\\nGROUP BY id-my_rank\\nHAVING COUNT(*) >=3)\\n```",
                "solutionTags": [],
                "code": "```\\nWITH temp AS\\n(SELECT\\n    id,\\n    visit_date,\\n    people,\\n    ROW_NUMBER() OVER (ORDER BY id) AS my_rank\\nFROM \\n    Stadium\\nWHERE \\n    people >= 100)\\n    \\nSELECT\\n    id,\\n    visit_date,\\n    people\\nFROM \\n    temp\\nWHERE id-my_rank IN (SELECT id-my_rank FROM temp\\nGROUP BY id-my_rank\\nHAVING COUNT(*) >=3)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1477034,
                "title": "very-easy-mysql-solution",
                "content": "```\\nwith t1 as (select min(id) as min,max(id)as max from (select id,row_number() over (order by id) as rn from Stadium where people >=100)a  group by id-rn having count(*)>=3)\\n\\nselect id,visit_date,people from Stadium s,t1 where s.id between t1.min and t1.max",
                "solutionTags": [],
                "code": "```\\nwith t1 as (select min(id) as min,max(id)as max from (select id,row_number() over (order by id) as rn from Stadium where people >=100)a  group by id-rn having count(*)>=3)\\n\\nselect id,visit_date,people from Stadium s,t1 where s.id between t1.min and t1.max",
                "codeTag": "Unknown"
            },
            {
                "id": 1062850,
                "title": "simple-neat-window-solution",
                "content": "```\\nwith filter_people as (\\n    select * \\n    from stadium \\n    where people >=100\\n),\\nrank_diff as (\\nselect *,id-row_number() over(order by id) as diff\\nfrom filter_people\\n)\\nselect id,visit_date, people \\nfrom rank_diff\\nwhere diff in (select diff from rank_diff group by 1 having count(id)>=3);\\n```",
                "solutionTags": [],
                "code": "```\\nwith filter_people as (\\n    select * \\n    from stadium \\n    where people >=100\\n),\\nrank_diff as (\\nselect *,id-row_number() over(order by id) as diff\\nfrom filter_people\\n)\\nselect id,visit_date, people \\nfrom rank_diff\\nwhere diff in (select diff from rank_diff group by 1 having count(id)>=3);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1006122,
                "title": "mssql-faster-than-99-5-submissions",
                "content": "\\nwith  dd as (\\n    select *,id-row_number() over(order by id) seq_group\\nfrom stadium\\nwhere people>=100)\\n, tbl as  (select id,visit_Date,people,count(*) over (partition by seq_group) count_group from dd\\n)\\nselect id,visit_Date,people\\nfrom tbl\\nwhere count_group>=3\\n",
                "solutionTags": [],
                "code": "\\nwith  dd as (\\n    select *,id-row_number() over(order by id) seq_group\\nfrom stadium\\nwhere people>=100)\\n, tbl as  (select id,visit_Date,people,count(*) over (partition by seq_group) count_group from dd\\n)\\nselect id,visit_Date,people\\nfrom tbl\\nwhere count_group>=3\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 990063,
                "title": "intuitive-solution-using-window-function",
                "content": "```\\nSELECT q2.id, q2.visit_date, q2.people\\nFROM\\n(\\n    SELECT  q1.*,\\n            COUNT(*) OVER(PARTITION BY (q1.id - q1.rnk)) AS cnt\\n    FROM\\n    (\\n        SELECT  CAST(id AS UNSIGNED) AS id,\\n                visit_date, people,\\n                ROW_NUMBER() OVER(ORDER BY id) rnk\\n        FROM Stadium\\n        WHERE people >= 100\\n    ) AS q1\\n) AS q2\\nWHERE q2.cnt >= 3\\nORDER BY q2.visit_date\\n;\\n```\\n\\nThe solution used here is very similar to my submission for Active Users:\\nhttps://leetcode.com/problems/active-users/discuss/983777/Intuitive-solution-to-solve-this-problem",
                "solutionTags": [],
                "code": "```\\nSELECT q2.id, q2.visit_date, q2.people\\nFROM\\n(\\n    SELECT  q1.*,\\n            COUNT(*) OVER(PARTITION BY (q1.id - q1.rnk)) AS cnt\\n    FROM\\n    (\\n        SELECT  CAST(id AS UNSIGNED) AS id,\\n                visit_date, people,\\n                ROW_NUMBER() OVER(ORDER BY id) rnk\\n        FROM Stadium\\n        WHERE people >= 100\\n    ) AS q1\\n) AS q2\\nWHERE q2.cnt >= 3\\nORDER BY q2.visit_date\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970206,
                "title": "solution-for-n-rows-with-consecutive-id",
                "content": "```\\nwith tempTable as(\\nselect\\n    *,\\n    id - ( (rank() over(order by id)) ) rk\\nfrom stadium\\nwhere people >= 100\\n)\\n\\nselect id, visit_date, people\\nfrom tempTable\\nwhere rk in\\n(select rk from tempTable group by rk having count(*)>=3);\\n```",
                "solutionTags": [],
                "code": "```\\nwith tempTable as(\\nselect\\n    *,\\n    id - ( (rank() over(order by id)) ) rk\\nfrom stadium\\nwhere people >= 100\\n)\\n\\nselect id, visit_date, people\\nfrom tempTable\\nwhere rk in\\n(select rk from tempTable group by rk having count(*)>=3);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 954364,
                "title": "gaps-and-islands-analytical-solution",
                "content": "The top 2 solutions are literally the opposite way of how you should think of this problem. This is a gaps and islands problem common to SQL for analytics questions especially around things like churn. The approach you SHOULD use is to find the \"islands\" of consecutive days and filter for the islands with 3 or more count.\\n```\\nSELECT id, visit_date, people\\nFROM (\\n    SELECT id, visit_date, people, island,\\n           COUNT(id) over(partition by island) AS island_ct\\n    FROM (\\n        SELECT id, visit_date, people, id - CAST(rn as signed)  AS island\\n        FROM (\\n\\t\\t    # The trick here is to know that if ids were consecutive, the difference between the id\\n\\t\\t\\t#and expected next number would be the same. If it\\'s not, then the current number is a new island\\n            SELECT *, ROW_NUMBER() OVER (ORDER BY id) AS rn\\n            FROM Stadium\\n            WHERE people >= 100\\n        ) t1\\n    ) t2\\n) t3\\nWHERE island_ct >= 3\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT id, visit_date, people\\nFROM (\\n    SELECT id, visit_date, people, island,\\n           COUNT(id) over(partition by island) AS island_ct\\n    FROM (\\n        SELECT id, visit_date, people, id - CAST(rn as signed)  AS island\\n        FROM (\\n\\t\\t    # The trick here is to know that if ids were consecutive, the difference between the id\\n\\t\\t\\t#and expected next number would be the same. If it\\'s not, then the current number is a new island\\n            SELECT *, ROW_NUMBER() OVER (ORDER BY id) AS rn\\n            FROM Stadium\\n            WHERE people >= 100\\n        ) t1\\n    ) t2\\n) t3\\nWHERE island_ct >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908919,
                "title": "using-gap-bwteen-id-and-row-number-to-find-consecutive-rows",
                "content": "select id,visit_date,people from \\n(select id,visit_date,people,gap,\\ncount(id) over(partition by gap) as cnt \\nfrom \\n    (select id,visit_date,people,id - row_number() over(order by id)  as gap\\n    from stadium\\n    where people>=100\\n     ) a \\n ) b \\n where cnt>=3 \\n order by id,visit_date desc",
                "solutionTags": [],
                "code": "select id,visit_date,people from \\n(select id,visit_date,people,gap,\\ncount(id) over(partition by gap) as cnt \\nfrom \\n    (select id,visit_date,people,id - row_number() over(order by id)  as gap\\n    from stadium\\n    where people>=100\\n     ) a \\n ) b \\n where cnt>=3 \\n order by id,visit_date desc",
                "codeTag": "Unknown"
            },
            {
                "id": 650305,
                "title": "mssql-without-lead-lag-only-cte-and-window-function",
                "content": "```\\n\\n;with cte as(\\nselect * from stadium s where people >= 100 )\\nselect tb2.id, tb2.visit_date, tb2.people from (\\nselect tb1.id, tb1.visit_date, tb1.people , tb1.grp,  count(*) over(partition by grp) \\'cnt\\' from (\\nselect id,visit_date,people, id-ROW_NUMBER() over(order by id) \\'grp\\' from cte) tb1 ) tb2 where tb2.cnt >= 3\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n;with cte as(\\nselect * from stadium s where people >= 100 )\\nselect tb2.id, tb2.visit_date, tb2.people from (\\nselect tb1.id, tb1.visit_date, tb1.people , tb1.grp,  count(*) over(partition by grp) \\'cnt\\' from (\\nselect id,visit_date,people, id-ROW_NUMBER() over(order by id) \\'grp\\' from cte) tb1 ) tb2 where tb2.cnt >= 3\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405348,
                "title": "flexible-answer-can-change-the-number-of-days",
                "content": "In other solution, if the number of days changes requires a lot of code modification\\nThis solution only needs to modify the variables(@day)\\n```\\ndeclare @day int\\nset @day=3\\nselect distinct id,visit_date,people from stadium \\nleft join \\n(select distinct a.id as x from stadium a,stadium b \\nwhere a.id>=b.id+(@day-1) and a.people >=100 and b.people >=100 \\nand (select count(1) from stadium c where c.visit_date between b.visit_date and a.visit_date and people < 100)=0) a \\non id > x-@day and id<=x\\nwhere x is not null\\n```",
                "solutionTags": [],
                "code": "```\\ndeclare @day int\\nset @day=3\\nselect distinct id,visit_date,people from stadium \\nleft join \\n(select distinct a.id as x from stadium a,stadium b \\nwhere a.id>=b.id+(@day-1) and a.people >=100 and b.people >=100 \\nand (select count(1) from stadium c where c.visit_date between b.visit_date and a.visit_date and people < 100)=0) a \\non id > x-@day and id<=x\\nwhere x is not null\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 394649,
                "title": "faster-than-95-submissions-easy-to-understand",
                "content": "select id\\n, visit_date\\n, currentPeople as people\\nfrom \\n(select id\\n, visit_date\\n, people as currentPeople\\n, lead(people,1) over(order by visit_date) as next_1\\n, lead(people,2) over(order by visit_date) as next_2\\n, lag(people,1) over(order by visit_date) as prev_1\\n, lag(people,2) over(order by visit_date) as prev_2\\nfrom stadium)a\\nwhere (prev_1>=100 and prev_2>=100 and currentPeople>=100)\\nor (prev_1>=100 and next_1>=100 and currentPeople>=100)\\nor (next_2>=100 and next_1>=100 and currentPeople>=100)\\n",
                "solutionTags": [],
                "code": "select id\\n, visit_date\\n, currentPeople as people\\nfrom \\n(select id\\n, visit_date\\n, people as currentPeople\\n, lead(people,1) over(order by visit_date) as next_1\\n, lead(people,2) over(order by visit_date) as next_2\\n, lag(people,1) over(order by visit_date) as prev_1\\n, lag(people,2) over(order by visit_date) as prev_2\\nfrom stadium)a\\nwhere (prev_1>=100 and prev_2>=100 and currentPeople>=100)\\nor (prev_1>=100 and next_1>=100 and currentPeople>=100)\\nor (next_2>=100 and next_1>=100 and currentPeople>=100)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 257668,
                "title": "solution-with-lag-lead",
                "content": "\\'\\'\\'\\nselect id, TO_CHAR(visit_date,\\'YYYY-MM-DD\\') visit_date ,people from (\\n  select id, visit_date,people,cou,\\n         case when lag(cou,1,0) over (order by id) +lag(cou,2,0)  over (order by id) +cou =3 or\\n                   lead(cou,1,0)  over (order by id)+lead(cou,2,0) over (order by id)  +cou=3 or\\n                   lead(cou,1,0)  over (order by id)+LAG(cou,1,0) over (order by id)  +cou=3 \\n         then  \\'Y\\' \\n         else \\'N\\' end flag\\n\\n  from (\\n        select id, visit_date,people,(case when people>=100 then 1 else 0 end) cou from stadium\\n       )\\n) where FLAG=\\'Y\\';\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nselect id, TO_CHAR(visit_date,\\'YYYY-MM-DD\\') visit_date ,people from (\\n  select id, visit_date,people,cou,\\n         case when lag(cou,1,0) over (order by id) +lag(cou,2,0)  over (order by id) +cou =3 or\\n                   lead(cou,1,0)  over (order by id)+lead(cou,2,0) over (order by id)  +cou=3 or\\n                   lead(cou,1,0)  over (order by id)+LAG(cou,1,0) over (order by id)  +cou=3 \\n         then  \\'Y\\' \\n         else \\'N\\' end flag\\n\\n  from (\\n        select id, visit_date,people,(case when people>=100 then 1 else 0 end) cou from stadium\\n       )\\n) where FLAG=\\'Y\\';\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 218685,
                "title": "a-simpler-version-than-the-solution",
                "content": "t2-t1=1 and t2-t3= 2 will be sufficient to determine the order of t1, t2, t3. \\nt2-t1=1 --> t1=t2-1\\nt2-t3=2 --> t3=t2-2 \\nt1-t3= t2-1-(t2-2) = 1 \\n```\\nselect distinct t1.*\\nfrom stadium t1, stadium t2, stadium t3\\nwhere t1.people >= 100 and t2.people >= 100 and t3.people >= 100\\nand\\n(\\n\\t  (t1.id - t2.id = 1 and t1.id - t3.id = 2 )\\n    or\\n    (t2.id - t1.id = 1 and t2.id - t3.id = 2 )\\n    or\\n    (t3.id - t2.id = 1 and t2.id - t1.id =1 )\\n)\\norder by t1.id\\n;",
                "solutionTags": [],
                "code": "t2-t1=1 and t2-t3= 2 will be sufficient to determine the order of t1, t2, t3. \\nt2-t1=1 --> t1=t2-1\\nt2-t3=2 --> t3=t2-2 \\nt1-t3= t2-1-(t2-2) = 1 \\n```\\nselect distinct t1.*\\nfrom stadium t1, stadium t2, stadium t3\\nwhere t1.people >= 100 and t2.people >= 100 and t3.people >= 100\\nand\\n(\\n\\t  (t1.id - t2.id = 1 and t1.id - t3.id = 2 )\\n    or\\n    (t2.id - t1.id = 1 and t2.id - t3.id = 2 )\\n    or\\n    (t3.id - t2.id = 1 and t2.id - t1.id =1 )\\n)\\norder by t1.id\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 103787,
                "title": "a-solution-with-union-join-and-where",
                "content": "```\\nselect s.* from stadium s inner join\\n(select distinct s1.id as id from stadium s1,stadium s2, stadium s3\\nwhere  s1.id+1=s2.id and s2.id+1=s3.id and s1.people > 99 and s2.people > 99 and s3.people > 99 \\nunion \\nselect distinct s2.id as id from stadium s1,stadium s2, stadium s3\\nwhere  s1.id+1=s2.id and s2.id+1=s3.id and s1.people > 99 and s2.people > 99 and s3.people > 99 \\nunion\\nselect distinct s3.id as id from stadium s1,stadium s2, stadium s3\\nwhere  s1.id+1=s2.id and s2.id+1=s3.id and s1.people > 99 and s2.people > 99 and s3.people > 99 ) a\\non a.id=s.id; \\n```",
                "solutionTags": [],
                "code": "```\\nselect s.* from stadium s inner join\\n(select distinct s1.id as id from stadium s1,stadium s2, stadium s3\\nwhere  s1.id+1=s2.id and s2.id+1=s3.id and s1.people > 99 and s2.people > 99 and s3.people > 99 \\nunion \\nselect distinct s2.id as id from stadium s1,stadium s2, stadium s3\\nwhere  s1.id+1=s2.id and s2.id+1=s3.id and s1.people > 99 and s2.people > 99 and s3.people > 99 \\nunion\\nselect distinct s3.id as id from stadium s1,stadium s2, stadium s3\\nwhere  s1.id+1=s2.id and s2.id+1=s3.id and s1.people > 99 and s2.people > 99 and s3.people > 99 ) a\\non a.id=s.id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3740654,
                "title": "simple-logic-clean-code",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n#For better understanding apply given example in question manually to this code \\n\\nwith cte as(select *,\\nid - row_number() over(order by id) as  diff\\nfrom Stadium\\nwhere people > 99)\\n\\nselect id, visit_date, people\\nfrom cte\\nwhere id in (select id from cte \\n                where diff in (select diff \\n                                from cte \\n                                group by diff\\n                                having count(diff)>2))\\norder by visit_date\\n\\n##### Upvote it if you understood it without an explanation :)\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n#For better understanding apply given example in question manually to this code \\n\\nwith cte as(select *,\\nid - row_number() over(order by id) as  diff\\nfrom Stadium\\nwhere people > 99)\\n\\nselect id, visit_date, people\\nfrom cte\\nwhere id in (select id from cte \\n                where diff in (select diff \\n                                from cte \\n                                group by diff\\n                                having count(diff)>2))\\norder by visit_date\\n\\n##### Upvote it if you understood it without an explanation :)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478258,
                "title": "michelle-s-solution-two-kind-correct-methods",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your PL/SQL query statement below */\\r\\n/*\\r\\nselect t1.id,to_char(t1.visit_date) as visit_date,t1.people\\r\\nfrom Stadium t1\\r\\nwhere t1.people>=100\\r\\nand (\\r\\n  ((t1.id+1) in (select t2.id from Stadium t2 where  t2.people>=100)\\r\\nand (t1.id+2) in (select t3.id from Stadium t3 where  t3.people>=100))\\r\\nor\\r\\n ((t1.id+1) in (select t22.id from Stadium t22 where  t22.people>=100)\\r\\nand (t1.id-1) in (select t32.id from Stadium t32 where  t32.people>=100))\\r\\nor\\r\\n ((t1.id-1) in (select t23.id from Stadium t23 where  t23.people>=100)\\r\\nand (t1.id-2) in (select t33.id from Stadium t33 where  t33.people>=100))\\r\\n)\\r\\norder by t1.visit_date \\r\\n*/\\r\\n\\r\\nselect *\\r\\nfrom \\r\\n(\\r\\nselect t1.id,to_char(t1.visit_date) as visit_date,t1.people\\r\\nfrom Stadium t1\\r\\nwhere t1.people>=100\\r\\nand (t1.id+1) in (select t2.id from Stadium t2 where  t2.people>=100)\\r\\nand (t1.id+2) in (select t3.id from Stadium t3 where  t3.people>=100)\\r\\nunion\\r\\nselect t1.id,to_char(t1.visit_date) as visit_date,t1.people\\r\\nfrom Stadium t1\\r\\nwhere t1.people>=100\\r\\nand (t1.id-1) in (select t2.id from Stadium t2 where  t2.people>=100)\\r\\nand (t1.id-2) in (select t3.id from Stadium t3 where  t3.people>=100)\\r\\nunion\\r\\nselect t1.id,to_char(t1.visit_date) as visit_date,t1.people\\r\\nfrom Stadium t1\\r\\nwhere t1.people>=100\\r\\nand (t1.id-1) in (select t2.id from Stadium t2 where  t2.people>=100)\\r\\nand (t1.id+1) in (select t3.id from Stadium t3 where  t3.people>=100)\\r\\n)\\r\\norder by visit_date \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\r\\n/* Write your PL/SQL query statement below */\\r\\n/*\\r\\nselect t1.id,to_char(t1.visit_date) as visit_date,t1.people\\r\\nfrom Stadium t1\\r\\nwhere t1.people>=100\\r\\nand (\\r\\n  ((t1.id+1) in (select t2.id from Stadium t2 where  t2.people>=100)\\r\\nand (t1.id+2) in (select t3.id from Stadium t3 where  t3.people>=100))\\r\\nor\\r\\n ((t1.id+1) in (select t22.id from Stadium t22 where  t22.people>=100)\\r\\nand (t1.id-1) in (select t32.id from Stadium t32 where  t32.people>=100))\\r\\nor\\r\\n ((t1.id-1) in (select t23.id from Stadium t23 where  t23.people>=100)\\r\\nand (t1.id-2) in (select t33.id from Stadium t33 where  t33.people>=100))\\r\\n)\\r\\norder by t1.visit_date \\r\\n*/\\r\\n\\r\\nselect *\\r\\nfrom \\r\\n(\\r\\nselect t1.id,to_char(t1.visit_date) as visit_date,t1.people\\r\\nfrom Stadium t1\\r\\nwhere t1.people>=100\\r\\nand (t1.id+1) in (select t2.id from Stadium t2 where  t2.people>=100)\\r\\nand (t1.id+2) in (select t3.id from Stadium t3 where  t3.people>=100)\\r\\nunion\\r\\nselect t1.id,to_char(t1.visit_date) as visit_date,t1.people\\r\\nfrom Stadium t1\\r\\nwhere t1.people>=100\\r\\nand (t1.id-1) in (select t2.id from Stadium t2 where  t2.people>=100)\\r\\nand (t1.id-2) in (select t3.id from Stadium t3 where  t3.people>=100)\\r\\nunion\\r\\nselect t1.id,to_char(t1.visit_date) as visit_date,t1.people\\r\\nfrom Stadium t1\\r\\nwhere t1.people>=100\\r\\nand (t1.id-1) in (select t2.id from Stadium t2 where  t2.people>=100)\\r\\nand (t1.id+1) in (select t3.id from Stadium t3 where  t3.people>=100)\\r\\n)\\r\\norder by visit_date \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3457410,
                "title": "mysql-lead-window-function-beats-98-9-easy",
                "content": "# Intuition\\nGet first id where its number of people and its next and second next dates with number of people is greather than 100.\\n\\nthen get every id which is in [found_id,found_id+1,found_id+2]\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT DISTINCT s.*\\nFROM Stadium s\\nINNER JOIN\\n(\\nSELECT id\\nFROM (\\nSELECT id , people ,\\n      LEAD(people,1) OVER (ORDER BY id) AS \"next_people\",\\n      LEAD(people,2) OVER (ORDER BY id) AS \"second_next_people\"\\nFROM Stadium )_\\nWHERE people>=100 AND next_people>=100 AND second_next_people>=100\\n)ids \\nON s.id BETWEEN ids.id AND ids.id+2\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT DISTINCT s.*\\nFROM Stadium s\\nINNER JOIN\\n(\\nSELECT id\\nFROM (\\nSELECT id , people ,\\n      LEAD(people,1) OVER (ORDER BY id) AS \"next_people\",\\n      LEAD(people,2) OVER (ORDER BY id) AS \"second_next_people\"\\nFROM Stadium )_\\nWHERE people>=100 AND next_people>=100 AND second_next_people>=100\\n)ids \\nON s.id BETWEEN ids.id AND ids.id+2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3294162,
                "title": "oracle-lag-lead",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT id\\n     , TO_CHAR(visit_date,\\'yyyy-mm-dd\\') AS visit_date\\n     , people\\n  FROM\\n    (\\n        SELECT id\\n            , visit_date\\n            , people\\n            , lag(people) over(order by id) prv_people\\n            , lag(people,2) over(order by id) prv_prv_people\\n            , lead(people) over(order by id) next_people\\n            , lead(people, 2) over(order by id) next_next_people\\n            FROM Stadium\\n    )\\n WHERE (people >=100 AND next_people >= 100 AND (next_next_people >=100 OR prv_people >=100))\\n    OR (prv_people >=100 AND prv_prv_people >= 100 AND people >=100)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT id\\n     , TO_CHAR(visit_date,\\'yyyy-mm-dd\\') AS visit_date\\n     , people\\n  FROM\\n    (\\n        SELECT id\\n            , visit_date\\n            , people\\n            , lag(people) over(order by id) prv_people\\n            , lag(people,2) over(order by id) prv_prv_people\\n            , lead(people) over(order by id) next_people\\n            , lead(people, 2) over(order by id) next_next_people\\n            FROM Stadium\\n    )\\n WHERE (people >=100 AND next_people >= 100 AND (next_next_people >=100 OR prv_people >=100))\\n    OR (prv_people >=100 AND prv_prv_people >= 100 AND people >=100)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3248003,
                "title": "solution-with-cte-and-cross-apply-sql-server-or-simple-count-mysql-beats-92",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n-- -- /* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n-- DECLARE @TBL_TMP TABLE (\\r\\n-- \\t\\t\\t\\t\\tid int,\\r\\n-- \\t\\t\\t\\t\\tvisit_date date,\\r\\n-- \\t\\t\\t\\t\\tpeople int,\\r\\n-- \\t\\t\\t\\t\\tKeyC int\\r\\n-- \\t\\t\\t)\\r\\n-- \\t\\t\\t;WITH CTE AS (SELECT\\r\\n-- \\t\\t\\t\\t*,\\r\\n-- \\t\\t\\t\\tIIF(ID + 1 = LEAD(id) OVER(ORDER BY id),1,0) KeyC\\r\\n-- \\t\\t\\tFROM\\r\\n-- \\t\\t\\t\\t Stadium\\r\\n-- \\t\\t\\tWHERE\\r\\n-- \\t\\t\\t\\tpeople >= 100\\r\\n-- \\t\\t\\t)\\r\\n-- \\t\\t\\tINSERT INTO @TBL_TMP SELECT * FROM CTE\\r\\n\\r\\n-- \\t\\t\\tDECLARE @TML_CONTAIN TABLE ( id int )\\r\\n-- \\t\\t\\tDECLARE @TML_RESULT TABLE ( id int )\\r\\n-- \\t\\t\\tDECLARE @id int = 0, @KeyC int = 0\\r\\n-- \\t\\t\\tDECLARE CUR_V CURSOR FOR SELECT id,KeyC FROM @TBL_TMP\\r\\n-- \\t\\t\\tOPEN CUR_V\\r\\n-- \\t\\t\\tFETCH NEXT FROM CUR_V INTO @id, @KeyC\\r\\n-- \\t\\t\\tWHILE @@FETCH_STATUS = 0\\r\\n-- \\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\tIF(@KeyC = 1)\\r\\n-- \\t\\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\t\\tINSERT INTO @TML_CONTAIN SELECT @id\\r\\n-- \\t\\t\\t\\tEND\\r\\n-- \\t\\t\\t\\tELSE\\r\\n-- \\t\\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\t\\tINSERT INTO @TML_CONTAIN SELECT @id\\r\\n-- \\t\\t\\t\\t\\tIF( (SELECT COUNT(1) FROM @TML_CONTAIN) < 3 )\\r\\n-- \\t\\t\\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\t\\t\\tDELETE FROM @TML_CONTAIN\\r\\n-- \\t\\t\\t\\t\\tEND\\r\\n-- \\t\\t\\t\\t\\tELSE\\r\\n-- \\t\\t\\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\t\\tINSERT INTO @TML_RESULT SELECT id FROM @TML_CONTAIN\\r\\n-- \\t\\t\\t\\t\\tDELETE FROM @TML_CONTAIN\\r\\n-- \\t\\t\\t\\t\\tEND\\r\\n-- \\t\\t\\t\\tEND\\r\\n\\r\\n-- \\t\\t\\t\\tFETCH NEXT FROM CUR_V INTO @id, @KeyC\\r\\n-- \\t\\t\\tEND\\r\\n-- \\t\\t\\tCLOSE CUR_V\\r\\n-- \\t\\t\\tDEALLOCATE CUR_V\\r\\n\\r\\n-- \\t\\t\\tSELECT \\r\\n-- \\t\\t\\t\\tT2.* \\r\\n-- \\t\\t\\tFROM \\r\\n-- \\t\\t\\t\\t@TML_RESULT T1\\r\\n-- \\t\\t\\tINNER JOIN\\r\\n-- \\t\\t\\t\\tStadium T2 ON T1.id = T2.id\\r\\n\\r\\n\\r\\n;WITH CTE AS(SELECT\\r\\n\\t*,\\r\\n\\tNEXT1 = IIF(ID + 1 = LEAD(ID) OVER(ORDER BY ID) ,1 , 0),\\r\\n\\tNEXT2 = IIF(ID + 2 = LEAD(ID,2) OVER(ORDER BY ID) , 1, 0)\\r\\nFROM\\t\\r\\n\\tStadium T1\\r\\nWHERE\\r\\n\\tPEOPLE >= 100\\r\\n\\t)\\r\\n,CTE2 AS (SELECT\\r\\n\\t*\\r\\nFROM\\r\\n\\tCTE\\r\\nWHERE\\r\\n\\tNEXT1 = 1\\r\\nAND \\r\\n\\tNEXT2 = 1\\r\\n\\t)\\r\\n,CTE3 AS (SELECT\\r\\n\\tT1.ID,\\r\\n\\tT1.VISIT_DATE,\\r\\n\\tT1.PEOPLE,\\r\\n\\tSub.ID ID2,\\r\\n\\tSub.VISIT_DATE VISIT_DATE2,\\r\\n\\tSub.PEOPLE PEOPLE2\\r\\nFROM\\r\\n\\tCTE2 T1\\r\\nCROSS APPLY  (\\r\\n\\tSELECT\\r\\n\\t\\t*\\r\\n\\tFROM\\r\\n\\t\\tStadium T2\\r\\n\\tWHERE\\r\\n\\t\\t(ID = T1.ID + ISNULL(T1.NEXT1,0)\\r\\n\\tOR\\r\\n\\t\\tID = T1.ID + ISNULL(T1.NEXT1,0) + ISNULL(T1.NEXT2,0))\\r\\n\\tAND\\r\\n\\t\\tT2.PEOPLE >= 100\\r\\n\\t)Sub\\r\\n)\\r\\nSELECT\\r\\n\\tID,\\r\\n\\tVISIT_DATE,\\r\\n\\tPEOPLE\\r\\nFROM\\r\\n\\tCTE3\\r\\nUNION \\r\\nSELECT\\r\\n\\tID2,\\r\\n\\tVISIT_DATE2,\\r\\n\\tPEOPLE2\\r\\nFROM\\r\\n\\tCTE3\\r\\nORDER BY\\r\\n    visit_date\\r\\n\\r\\n\\r\\n```\\r\\n\\r\\n\\r\\n\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n\\t\\tSELECT\\r\\n\\t\\t\\t*,\\r\\n\\t\\t\\t id - ROW_NUMBER() OVER(ORDER BY visit_date) Diff\\r\\n\\t\\tFROM\\r\\n\\t\\t\\tStadium\\r\\n\\t\\tWHERE\\r\\n\\t\\t\\tpeople >= 100\\r\\n    )\\r\\n,CTE2 AS (\\r\\n\\tSELECT\\r\\n\\t\\tDiff,\\r\\n\\t\\tCOUNT(Diff) AS DiffCounted\\r\\n\\tFROM\\r\\n\\t\\tCTE\\r\\n\\tGROUP BY \\r\\n\\t\\tDiff\\r\\n\\tHAVING COUNT(Diff) > 2\\r\\n    )\\r\\nSELECT\\r\\n\\tid,\\r\\n    visit_date,\\r\\n    people\\r\\nFROM\\r\\n\\tCTE \\r\\nWHERE\\r\\n\\tDiff IN (\\r\\n\\t\\tSELECT Diff FROM CTE2\\r\\n    )\\r\\nORDER BY\\r\\n\\tvisit_date ASC\\r\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\r\\n-- -- /* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n-- DECLARE @TBL_TMP TABLE (\\r\\n-- \\t\\t\\t\\t\\tid int,\\r\\n-- \\t\\t\\t\\t\\tvisit_date date,\\r\\n-- \\t\\t\\t\\t\\tpeople int,\\r\\n-- \\t\\t\\t\\t\\tKeyC int\\r\\n-- \\t\\t\\t)\\r\\n-- \\t\\t\\t;WITH CTE AS (SELECT\\r\\n-- \\t\\t\\t\\t*,\\r\\n-- \\t\\t\\t\\tIIF(ID + 1 = LEAD(id) OVER(ORDER BY id),1,0) KeyC\\r\\n-- \\t\\t\\tFROM\\r\\n-- \\t\\t\\t\\t Stadium\\r\\n-- \\t\\t\\tWHERE\\r\\n-- \\t\\t\\t\\tpeople >= 100\\r\\n-- \\t\\t\\t)\\r\\n-- \\t\\t\\tINSERT INTO @TBL_TMP SELECT * FROM CTE\\r\\n\\r\\n-- \\t\\t\\tDECLARE @TML_CONTAIN TABLE ( id int )\\r\\n-- \\t\\t\\tDECLARE @TML_RESULT TABLE ( id int )\\r\\n-- \\t\\t\\tDECLARE @id int = 0, @KeyC int = 0\\r\\n-- \\t\\t\\tDECLARE CUR_V CURSOR FOR SELECT id,KeyC FROM @TBL_TMP\\r\\n-- \\t\\t\\tOPEN CUR_V\\r\\n-- \\t\\t\\tFETCH NEXT FROM CUR_V INTO @id, @KeyC\\r\\n-- \\t\\t\\tWHILE @@FETCH_STATUS = 0\\r\\n-- \\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\tIF(@KeyC = 1)\\r\\n-- \\t\\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\t\\tINSERT INTO @TML_CONTAIN SELECT @id\\r\\n-- \\t\\t\\t\\tEND\\r\\n-- \\t\\t\\t\\tELSE\\r\\n-- \\t\\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\t\\tINSERT INTO @TML_CONTAIN SELECT @id\\r\\n-- \\t\\t\\t\\t\\tIF( (SELECT COUNT(1) FROM @TML_CONTAIN) < 3 )\\r\\n-- \\t\\t\\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\t\\t\\tDELETE FROM @TML_CONTAIN\\r\\n-- \\t\\t\\t\\t\\tEND\\r\\n-- \\t\\t\\t\\t\\tELSE\\r\\n-- \\t\\t\\t\\t\\tBEGIN\\r\\n-- \\t\\t\\t\\t\\tINSERT INTO @TML_RESULT SELECT id FROM @TML_CONTAIN\\r\\n-- \\t\\t\\t\\t\\tDELETE FROM @TML_CONTAIN\\r\\n-- \\t\\t\\t\\t\\tEND\\r\\n-- \\t\\t\\t\\tEND\\r\\n\\r\\n-- \\t\\t\\t\\tFETCH NEXT FROM CUR_V INTO @id, @KeyC\\r\\n-- \\t\\t\\tEND\\r\\n-- \\t\\t\\tCLOSE CUR_V\\r\\n-- \\t\\t\\tDEALLOCATE CUR_V\\r\\n\\r\\n-- \\t\\t\\tSELECT \\r\\n-- \\t\\t\\t\\tT2.* \\r\\n-- \\t\\t\\tFROM \\r\\n-- \\t\\t\\t\\t@TML_RESULT T1\\r\\n-- \\t\\t\\tINNER JOIN\\r\\n-- \\t\\t\\t\\tStadium T2 ON T1.id = T2.id\\r\\n\\r\\n\\r\\n;WITH CTE AS(SELECT\\r\\n\\t*,\\r\\n\\tNEXT1 = IIF(ID + 1 = LEAD(ID) OVER(ORDER BY ID) ,1 , 0),\\r\\n\\tNEXT2 = IIF(ID + 2 = LEAD(ID,2) OVER(ORDER BY ID) , 1, 0)\\r\\nFROM\\t\\r\\n\\tStadium T1\\r\\nWHERE\\r\\n\\tPEOPLE >= 100\\r\\n\\t)\\r\\n,CTE2 AS (SELECT\\r\\n\\t*\\r\\nFROM\\r\\n\\tCTE\\r\\nWHERE\\r\\n\\tNEXT1 = 1\\r\\nAND \\r\\n\\tNEXT2 = 1\\r\\n\\t)\\r\\n,CTE3 AS (SELECT\\r\\n\\tT1.ID,\\r\\n\\tT1.VISIT_DATE,\\r\\n\\tT1.PEOPLE,\\r\\n\\tSub.ID ID2,\\r\\n\\tSub.VISIT_DATE VISIT_DATE2,\\r\\n\\tSub.PEOPLE PEOPLE2\\r\\nFROM\\r\\n\\tCTE2 T1\\r\\nCROSS APPLY  (\\r\\n\\tSELECT\\r\\n\\t\\t*\\r\\n\\tFROM\\r\\n\\t\\tStadium T2\\r\\n\\tWHERE\\r\\n\\t\\t(ID = T1.ID + ISNULL(T1.NEXT1,0)\\r\\n\\tOR\\r\\n\\t\\tID = T1.ID + ISNULL(T1.NEXT1,0) + ISNULL(T1.NEXT2,0))\\r\\n\\tAND\\r\\n\\t\\tT2.PEOPLE >= 100\\r\\n\\t)Sub\\r\\n)\\r\\nSELECT\\r\\n\\tID,\\r\\n\\tVISIT_DATE,\\r\\n\\tPEOPLE\\r\\nFROM\\r\\n\\tCTE3\\r\\nUNION \\r\\nSELECT\\r\\n\\tID2,\\r\\n\\tVISIT_DATE2,\\r\\n\\tPEOPLE2\\r\\nFROM\\r\\n\\tCTE3\\r\\nORDER BY\\r\\n    visit_date\\r\\n\\r\\n\\r\\n```\n```\\r\\n# Write your MySQL query statement below\\r\\n\\r\\n\\r\\nWITH CTE AS (\\r\\n\\t\\tSELECT\\r\\n\\t\\t\\t*,\\r\\n\\t\\t\\t id - ROW_NUMBER() OVER(ORDER BY visit_date) Diff\\r\\n\\t\\tFROM\\r\\n\\t\\t\\tStadium\\r\\n\\t\\tWHERE\\r\\n\\t\\t\\tpeople >= 100\\r\\n    )\\r\\n,CTE2 AS (\\r\\n\\tSELECT\\r\\n\\t\\tDiff,\\r\\n\\t\\tCOUNT(Diff) AS DiffCounted\\r\\n\\tFROM\\r\\n\\t\\tCTE\\r\\n\\tGROUP BY \\r\\n\\t\\tDiff\\r\\n\\tHAVING COUNT(Diff) > 2\\r\\n    )\\r\\nSELECT\\r\\n\\tid,\\r\\n    visit_date,\\r\\n    people\\r\\nFROM\\r\\n\\tCTE \\r\\nWHERE\\r\\n\\tDiff IN (\\r\\n\\t\\tSELECT Diff FROM CTE2\\r\\n    )\\r\\nORDER BY\\r\\n\\tvisit_date ASC\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3154395,
                "title": "easy-logic-for-everyone-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBecause the output table does not include data with people<100, we can just filter them out. Then, the rest of the work is to check whether id exist in 3-day sliding windows.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, filter out data in Stadium table if people<100 and name the filtered table as t (this makes your code succinct and easier to understand). Then, check whether id exist in three sliding windows above and below. Last, union then together and ordey by date.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith t as (select * from Stadium where people>=100)\\nselect * from t where id in(select id-1 from t) and id in(select id-2 from t) \\nunion\\nselect * from t where id in(select id-1 from t) and id in(select id+1 from t) \\nunion\\nselect * from t where id in(select id+1 from t) and id in(select id+2 from t) \\norder by visit_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith t as (select * from Stadium where people>=100)\\nselect * from t where id in(select id-1 from t) and id in(select id-2 from t) \\nunion\\nselect * from t where id in(select id-1 from t) and id in(select id+1 from t) \\nunion\\nselect * from t where id in(select id+1 from t) and id in(select id+2 from t) \\norder by visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2781751,
                "title": "solution-without-any-joins",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nThis Question is Similar as Consecutive numbers pattern, Where we aim to find the numbers that are repeated continuously. But the trickiest part is how to get the difference at first.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\na) To achieve this, i first filtered the data where the stadium has greater than or equal to 100.\\r\\nb) Now, i will create an auxilary index (i.e tid) which is used to find the difference between the existing id and tid.\\r\\nc) In the Second step we are creating groups, which are used to find the solution.\\r\\nd) Finally once the values are filtered by the condition, we use in operator to find the original rows.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nThere are No Joins in this Solution, Where when i perform a filter condition, on huge data it just scans the table. And will create an auxilary table which is CTE.\\r\\n  \\r\\nSo overall the solution, is optimized as it does not have any joins\\r\\n\\r\\n# Code\\r\\n```\\r\\nWITH CTE AS \\r\\n(\\r\\n    SELECT ID, VISIT_DATE, PEOPLE, (ID - ROW_NUMBER() OVER()) AS TID\\r\\n    FROM STADIUM\\r\\n    WHERE PEOPLE >= 100\\r\\n)\\r\\n\\r\\n\\r\\nSELECT \\r\\nID, \\r\\nVISIT_DATE,\\r\\nPEOPLE\\r\\nFROM CTE  \\r\\nWHERE TID IN (\\r\\n            SELECT \\r\\n            TID\\r\\n            FROM CTE\\r\\n            GROUP BY TID\\r\\n            HAVING COUNT(*) >= 3\\r\\n)\\r\\n            \\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\nWITH CTE AS \\r\\n(\\r\\n    SELECT ID, VISIT_DATE, PEOPLE, (ID - ROW_NUMBER() OVER()) AS TID\\r\\n    FROM STADIUM\\r\\n    WHERE PEOPLE >= 100\\r\\n)\\r\\n\\r\\n\\r\\nSELECT \\r\\nID, \\r\\nVISIT_DATE,\\r\\nPEOPLE\\r\\nFROM CTE  \\r\\nWHERE TID IN (\\r\\n            SELECT \\r\\n            TID\\r\\n            FROM CTE\\r\\n            GROUP BY TID\\r\\n            HAVING COUNT(*) >= 3\\r\\n)\\r\\n            \\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2749950,
                "title": "clean-window-function-solution",
                "content": "```\\nWITH cte1 AS (\\nSELECT\\n\\t*,\\n\\tid - ROW_NUMBER() OVER(ORDER BY visit_date ASC) AS \\'group_diff\\'\\nFROM\\n\\tStadium\\nWHERE\\n\\tpeople >= 100\\n)\\n\\n\\nSELECT\\n\\tt.id,\\n\\tt.visit_date,\\n\\tt.people\\nFROM\\n\\t(\\n\\tSELECT\\n\\t\\t*,\\n\\t\\tCOUNT(*) OVER(PARTITION BY group_diff) AS \\'counts\\'\\n\\tFROM\\n\\t\\tcte1) t\\nWHERE\\n\\tt.counts >= 3\\nORDER BY\\n\\tt.visit_date;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte1 AS (\\nSELECT\\n\\t*,\\n\\tid - ROW_NUMBER() OVER(ORDER BY visit_date ASC) AS \\'group_diff\\'\\nFROM\\n\\tStadium\\nWHERE\\n\\tpeople >= 100\\n)\\n\\n\\nSELECT\\n\\tt.id,\\n\\tt.visit_date,\\n\\tt.people\\nFROM\\n\\t(\\n\\tSELECT\\n\\t\\t*,\\n\\t\\tCOUNT(*) OVER(PARTITION BY group_diff) AS \\'counts\\'\\n\\tFROM\\n\\t\\tcte1) t\\nWHERE\\n\\tt.counts >= 3\\nORDER BY\\n\\tt.visit_date;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639644,
                "title": "using-window-functions-lead-and-lag",
                "content": "\\'\\'\\'\\nwith cte as\\n(\\n    select id,visit_date,people,\\n    LAG(people) over(order by id) as previous,\\n    LAG(people,2) over (order by id) as previous2,\\n    LEAD(people) over (order by id) as \"next\",\\n    Lead(people,2) over (order by id) as \"next2\"\\n    from Stadium\\n)\\n\\nselect cte.id,cte.visit_date,cte.people\\nfrom cte\\nwhere\\n(cte.people>=100 AND cte.next>=100 AND cte.next2>=100)\\nOR\\n(cte.people>=100 AND cte.previous>=100 AND cte.next>=100)\\nOR\\n(cte.people>=100 AND cte.previous>=100 AND cte.previous2>=100)\\n\\norder by visit_date\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nwith cte as\\n(\\n    select id,visit_date,people,\\n    LAG(people) over(order by id) as previous,\\n    LAG(people,2) over (order by id) as previous2,\\n    LEAD(people) over (order by id) as \"next\",\\n    Lead(people,2) over (order by id) as \"next2\"\\n    from Stadium\\n)\\n\\nselect cte.id,cte.visit_date,cte.people\\nfrom cte\\nwhere\\n(cte.people>=100 AND cte.next>=100 AND cte.next2>=100)\\nOR\\n(cte.people>=100 AND cte.previous>=100 AND cte.next>=100)\\nOR\\n(cte.people>=100 AND cte.previous>=100 AND cte.previous2>=100)\\n\\norder by visit_date\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2608260,
                "title": "i-feel-this-is-creative-but-i-am-not-sure",
                "content": "```\\n# I queried the \"difference\" between the row number (resulted from\\n# filtering out people >= 100) and id (from original table).\\n\\n# Because the \"difference\" increases whenever the increasing id becomes non-consecutive,\\n# By categorizing the \"differences\" and calculate the count for each categorization,\\n# We can filter out the rows that has number of consecutive ids satisfying the question (3 or more)\\n\\nselect id, visit_date, people\\nfrom (\\n      select *, count(diff) over(partition by diff) as count_diff\\n      from (\\n            select row_number()over(), id, id - row_number()over() as diff, visit_date, people\\n            from Stadium\\n            where people >= 100\\n           ) as sub_in\\n      ) as sub_out\\nwhere count_diff >= 3\\norder by visit_date\\n```\\n\\nTo better understand, for example if id is like 2,3,4,5,7,8,9,10,12,13, then \"difference\" would be 1,1,1,1,2,2,2,2,3,3, then class of \"1 difference\" have 4 count, class of \"2 differennce\" have 4 count, class of \"3 difference\" have 2 count, so classes of \"1 difference\" and \"2 difference\" would be chosen, corresponding to the ids 2,3,4,5,7,8,9,10.",
                "solutionTags": [],
                "code": "```\\n# I queried the \"difference\" between the row number (resulted from\\n# filtering out people >= 100) and id (from original table).\\n\\n# Because the \"difference\" increases whenever the increasing id becomes non-consecutive,\\n# By categorizing the \"differences\" and calculate the count for each categorization,\\n# We can filter out the rows that has number of consecutive ids satisfying the question (3 or more)\\n\\nselect id, visit_date, people\\nfrom (\\n      select *, count(diff) over(partition by diff) as count_diff\\n      from (\\n            select row_number()over(), id, id - row_number()over() as diff, visit_date, people\\n            from Stadium\\n            where people >= 100\\n           ) as sub_in\\n      ) as sub_out\\nwhere count_diff >= 3\\norder by visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2300948,
                "title": "mysql-two-great-solution-cte-lag-lead",
                "content": "```\\n# Write your MySQL query statement below\\n\\n/**\\nONE TABLE\\nvisit_date is the primary key of this table\\nStadium table contains visit date and visit id to the stadium with the number of people during the visit\\nAs id increases, the dates increase\\n\\n\\nPROBLEM:: display the records with three or more rows with consecutive id\\'s, and the number of people is greater than or equal to 100 for each\\nordered by visit_date in ascending order.\\n\\n*/\\n/**\\n\\nSTEPS: 1st Solution\\nBuild a CTE with Lag,lead of past 2 days and next two days || Lag/lead(id) over(order by visit_date)\\nWhere condition where people >=10\\norder by the id\\n\\nSELECT the required field with  concecutive 3 days are equal\\ndaybeforeyesterday +1 = yesterday and yesterday+1 = today OR\\nyesterday+1 = today and today+ 1 = tommorow OR\\ntoday+ 1 = tommorow and tommorow+1 = day_after_tommorow\\n*/\\n\\n\\nWITH CTE AS\\n    (\\n        SELECT \\n            id,\\n            visit_date,\\n            people,\\n            LAG(id,2) OVER(ORDER BY visit_date) AS  day_before_yesterday,\\n            LAG(id,1) OVER(ORDER BY visit_date) AS  day_yesterday,\\n            LEAD(id,2) OVER(ORDER BY visit_date) AS day_after_tommorow,\\n            LEAD(id,1) OVER(ORDER BY visit_date) AS day_tommorow\\n        FROM Stadium\\n        WHERE people >= 100\\n        ORDER BY id\\n    )\\nSELECT \\n    id,\\n    visit_date,\\n    people\\nFROM CTE \\nWHERE\\n        (id+1 = day_tommorow AND id+2 = day_after_tommorow) OR\\n        (id-1 = day_yesterday AND id-2 = day_before_yesterday) OR \\n        (id+1 = day_tommorow AND id-1 = day_yesterday) \\n  \\n /** \\n SECOND SOLUTION\\n \\nHow to find consective numbers:\\nThe difference between id and ROW_Number will be same for consective numbers.\\nFor Example:\\nRow_Number: 1,2,3,4,5,6\\nId: 3,4,5,8,9,10\\nDiff: 2,2,2,4,4,4\\n\\n SOLUTION:\\n Build First CTE to determine the concecutive numbers with the conditon\\n SECOND CTE: Consecutive numbers have similar (id - rowNumber). Group them and make sure the count >=3\\n SELECT requried field from 1st CTE \\n Conditon the similar consecutive field(id - rowNumber) in the Second CTE\\n \\n */\\n        \\nwith CTE_withRowNum as \\n(\\n        select \\n            id, \\n            visit_date, \\n            people, \\n            (id - ROW_NUMBER() over (ORDER by id)) as rw\\n        from stadium\\n        where people >=100\\n),\\nCTE_withGroup as \\n(\\n        select \\n            rw, \\n            count(id) as number\\n        from CTE_withRowNum\\n        group by rw\\n        having count(id)>=3\\n)\\n\\nselect a.id, a.visit_date, a.people\\nfrom CTE_withRowNum a\\nwhere a.rw in (select rw from CTE_withGroup)\\n\\n\\n\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\n/**\\nONE TABLE\\nvisit_date is the primary key of this table\\nStadium table contains visit date and visit id to the stadium with the number of people during the visit\\nAs id increases, the dates increase\\n\\n\\nPROBLEM:: display the records with three or more rows with consecutive id\\'s, and the number of people is greater than or equal to 100 for each\\nordered by visit_date in ascending order.\\n\\n*/\\n/**\\n\\nSTEPS: 1st Solution\\nBuild a CTE with Lag,lead of past 2 days and next two days || Lag/lead(id) over(order by visit_date)\\nWhere condition where people >=10\\norder by the id\\n\\nSELECT the required field with  concecutive 3 days are equal\\ndaybeforeyesterday +1 = yesterday and yesterday+1 = today OR\\nyesterday+1 = today and today+ 1 = tommorow OR\\ntoday+ 1 = tommorow and tommorow+1 = day_after_tommorow\\n*/\\n\\n\\nWITH CTE AS\\n    (\\n        SELECT \\n            id,\\n            visit_date,\\n            people,\\n            LAG(id,2) OVER(ORDER BY visit_date) AS  day_before_yesterday,\\n            LAG(id,1) OVER(ORDER BY visit_date) AS  day_yesterday,\\n            LEAD(id,2) OVER(ORDER BY visit_date) AS day_after_tommorow,\\n            LEAD(id,1) OVER(ORDER BY visit_date) AS day_tommorow\\n        FROM Stadium\\n        WHERE people >= 100\\n        ORDER BY id\\n    )\\nSELECT \\n    id,\\n    visit_date,\\n    people\\nFROM CTE \\nWHERE\\n        (id+1 = day_tommorow AND id+2 = day_after_tommorow) OR\\n        (id-1 = day_yesterday AND id-2 = day_before_yesterday) OR \\n        (id+1 = day_tommorow AND id-1 = day_yesterday) \\n  \\n /** \\n SECOND SOLUTION\\n \\nHow to find consective numbers:\\nThe difference between id and ROW_Number will be same for consective numbers.\\nFor Example:\\nRow_Number: 1,2,3,4,5,6\\nId: 3,4,5,8,9,10\\nDiff: 2,2,2,4,4,4\\n\\n SOLUTION:\\n Build First CTE to determine the concecutive numbers with the conditon\\n SECOND CTE: Consecutive numbers have similar (id - rowNumber). Group them and make sure the count >=3\\n SELECT requried field from 1st CTE \\n Conditon the similar consecutive field(id - rowNumber) in the Second CTE\\n \\n */\\n        \\nwith CTE_withRowNum as \\n(\\n        select \\n            id, \\n            visit_date, \\n            people, \\n            (id - ROW_NUMBER() over (ORDER by id)) as rw\\n        from stadium\\n        where people >=100\\n),\\nCTE_withGroup as \\n(\\n        select \\n            rw, \\n            count(id) as number\\n        from CTE_withRowNum\\n        group by rw\\n        having count(id)>=3\\n)\\n\\nselect a.id, a.visit_date, a.people\\nfrom CTE_withRowNum a\\nwhere a.rw in (select rw from CTE_withGroup)\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2210622,
                "title": "mysql-simple-solution",
                "content": "```\\n# created separate table\\nwith t1 as \\n        (SELECT *,\\n        id-(row_number() over (order by id)) as \"Diff\"\\n        FROM stadium\\n        WHERE people >=100)\\n\\t\\t\\n\\n# Useing that table find ans. \\nselect id, visit_date, people from t1 \\nwhere diff in (select diff from t1 group by diff having count(id)>=3)\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# created separate table\\nwith t1 as \\n        (SELECT *,\\n        id-(row_number() over (order by id)) as \"Diff\"\\n        FROM stadium\\n        WHERE people >=100)\\n\\t\\t\\n\\n# Useing that table find ans. \\nselect id, visit_date, people from t1 \\nwhere diff in (select diff from t1 group by diff having count(id)>=3)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043957,
                "title": "ms-sql-mysql-query-statement-step-by-step",
                "content": "Step:\\n1. Use row_number() to find out match conditions to generate a new column.\\n2. Use new column to find out with three or more rows with consecutive id\\'s.\\n3. Query grouping by TotalCount is greater than or equal 3.\\n\\n```\\n# Write your MySQL query statement below\\nwith cc as\\n(\\n\\tselect s.*,(id - row_number() over (order by id asc)) as id_row_diff\\n\\tfrom stadium s\\n\\twhere people >= 100 \\n )\\nselect id, visit_date, people\\nfrom (\\n\\tselect id,visit_date,people,count(*) over (partition by id_row_diff) as TotalCount \\n\\tfrom cc\\n) itm\\nwhere TotalCount >=3 \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cc as\\n(\\n\\tselect s.*,(id - row_number() over (order by id asc)) as id_row_diff\\n\\tfrom stadium s\\n\\twhere people >= 100 \\n )\\nselect id, visit_date, people\\nfrom (\\n\\tselect id,visit_date,people,count(*) over (partition by id_row_diff) as TotalCount \\n\\tfrom cc\\n) itm\\nwhere TotalCount >=3 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008275,
                "title": "windows-function",
                "content": "It seemed my solution is different from the existing ones\\n\\n```\\nwith cte as (\\n\\tselect *, \\n\\t\\tlag(id, 2) over(order by id) as lag2, \\n\\t\\tlag(id, 1) over(order by id) as lag1, \\n\\t\\tlead(id, 1) over(order by id) as lead1,\\n\\t\\tlead(id, 2) over(order by id) as lead2\\n\\tfrom Stadium\\n\\twhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom x\\nwhere (lead1 - id = 1 and lead2 - id = 2) -- the first row of the group\\n\\t or (id - lag1 = 1 and id - lag2 = 2) -- the last row of the group\\n\\t or (lead1 - id = 1 and id - lag1 = 1) -- middle rows\\n ```",
                "solutionTags": [],
                "code": "```\\nwith cte as (\\n\\tselect *, \\n\\t\\tlag(id, 2) over(order by id) as lag2, \\n\\t\\tlag(id, 1) over(order by id) as lag1, \\n\\t\\tlead(id, 1) over(order by id) as lead1,\\n\\t\\tlead(id, 2) over(order by id) as lead2\\n\\tfrom Stadium\\n\\twhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom x\\nwhere (lead1 - id = 1 and lead2 - id = 2) -- the first row of the group\\n\\t or (id - lag1 = 1 and id - lag2 = 2) -- the last row of the group\\n\\t or (lead1 - id = 1 and id - lag1 = 1) -- middle rows\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1972557,
                "title": "mysql-solution-fast-and-easy-join-with-lag-and-lead",
                "content": "# Solution\\nFaster then 90%\\n```\\nWITH ids as (SELECT *, \\n       LAG(id,1,null) OVER(ORDER BY visit_date) as lag1, \\n       LAG(id,2,null) OVER(ORDER BY visit_date) as lag2,\\n       LEAD(id,1,null) OVER(ORDER BY visit_date) as lead1, \\n       LEAD(id,2,null) OVER(ORDER BY visit_date) as lead2\\nFROM Stadium)\\nSELECT ids.id, ids.visit_date, ids.people\\nFROM ids\\nLEFT JOIN ids as ids1 ON ids1.id = ids.lag1\\nLEFT JOIN ids as ids2 ON ids2.id = ids.lag2\\nLEFT JOIN ids as ids3 ON ids3.id = ids.lead1\\nLEFT JOIN ids as ids4 ON ids4.id = ids.lead2\\nWHERE \\n(ids.people >= 100 and ids1.people >= 100 and ids2.people >=100)\\nOR\\n(ids.people >= 100 and ids3.people >= 100 and ids4.people >=100)\\nOR \\n(ids.people >= 100 and ids1.people >= 100 and ids3.people >=100)\\n```\\nSQL **LAG()** is a window function  that provides access to a row at a specified physical offset which comes **before** the current row.\\nSQL **LEAD()** is a window function  that provides access to a row at a specified physical offset which comes **after** the current row.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH ids as (SELECT *, \\n       LAG(id,1,null) OVER(ORDER BY visit_date) as lag1, \\n       LAG(id,2,null) OVER(ORDER BY visit_date) as lag2,\\n       LEAD(id,1,null) OVER(ORDER BY visit_date) as lead1, \\n       LEAD(id,2,null) OVER(ORDER BY visit_date) as lead2\\nFROM Stadium)\\nSELECT ids.id, ids.visit_date, ids.people\\nFROM ids\\nLEFT JOIN ids as ids1 ON ids1.id = ids.lag1\\nLEFT JOIN ids as ids2 ON ids2.id = ids.lag2\\nLEFT JOIN ids as ids3 ON ids3.id = ids.lead1\\nLEFT JOIN ids as ids4 ON ids4.id = ids.lead2\\nWHERE \\n(ids.people >= 100 and ids1.people >= 100 and ids2.people >=100)\\nOR\\n(ids.people >= 100 and ids3.people >= 100 and ids4.people >=100)\\nOR \\n(ids.people >= 100 and ids1.people >= 100 and ids3.people >=100)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940705,
                "title": "mysql-simple-solution-using-window-functions",
                "content": "First we create a table with only those rows wihch have >= 100 people. We also add 4 new columns. LAG2, LAG1, LEAD1, LEAD2. These columns have the id of adjacent seats with >= 100 people. \\n```\\nWITH tb1 as (\\n    SELECT *,\\n    LAG(id,2) OVER() as lag2,\\n    LAG(id,1) OVER() as lag1,\\n    LEAD(id,1) OVER() as lead1,\\n    LEAD(id,2) OVER() as lead2\\n    FROM Stadium \\n    WHERE people >= 100\\n)\\n```\\n\\nOnce we have the table above we select only those rows which :\\n1. is the last row in a series of 3 consecutive => lag2 = id-2 and lag1 = id-1 \\n2. is the middle row in a series of 3 consecutive => lag1 = id-1 and lead1 = id+1\\n3. is the first row in a series of 3 consecutive => lead1 = id+1 and lead2 = id+2  \\n\\n```\\nSELECT id, visit_date, people\\nFROM tb1 \\nWHERE \\n(lag2 = id-2 and lag1 = id-1) \\nOR (lag1 = id-1 and lead1 = id+1)\\nOR (lead1 = id+1 and lead2 = id+2)\\n;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```\\nWITH tb1 as (\\n    SELECT *,\\n    LAG(id,2) OVER() as lag2,\\n    LAG(id,1) OVER() as lag1,\\n    LEAD(id,1) OVER() as lead1,\\n    LEAD(id,2) OVER() as lead2\\n    FROM Stadium \\n    WHERE people >= 100\\n)\\n```\n```\\nSELECT id, visit_date, people\\nFROM tb1 \\nWHERE \\n(lag2 = id-2 and lag1 = id-1) \\nOR (lag1 = id-1 and lead1 = id+1)\\nOR (lead1 = id+1 and lead2 = id+2)\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1892361,
                "title": "simple-mysql-solution-using-self-join",
                "content": "```\\n# Using self join\\nselect distinct s1.* from stadium s1 join stadium s2 join stadium s3\\non (s1.id = s2.id - 1 and s1.id = s3.id - 2) OR\\n(s1.id = s2.id + 1 and s1.id = s3.id - 1) OR\\n(s1.id = s2.id + 1 and s1.id = s3.id + 2)\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\norder by visit_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Using self join\\nselect distinct s1.* from stadium s1 join stadium s2 join stadium s3\\non (s1.id = s2.id - 1 and s1.id = s3.id - 2) OR\\n(s1.id = s2.id + 1 and s1.id = s3.id - 1) OR\\n(s1.id = s2.id + 1 and s1.id = s3.id + 2)\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\norder by visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1829138,
                "title": "rank-and-partition",
                "content": "\\n\\n\\n```\\nselect c.id, c.visit_date, c.people\\n\\nfrom \\n\\n( # 3. Get count of each group using partition \\nselect b.*, count(*) over (partition by b.grp) as Count\\nfrom\\n    (# 2. Second subquery - group consecutive ids in filtered table using \\n     # id- dense rank - row number or rank works too \\n    select a.*,\\n    id-dense_rank() over (order by id) grp\\n    from \\n        (# 1. Inner-most subquery - subset pop >= 100\\n        select * \\n        from Stadium \\n        where people >= 100) a) b) c\\n\\nwhere c.Count >= 3;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\n\\n\\n```\\nselect c.id, c.visit_date, c.people\\n\\nfrom \\n\\n( # 3. Get count of each group using partition \\nselect b.*, count(*) over (partition by b.grp) as Count\\nfrom\\n    (# 2. Second subquery - group consecutive ids in filtered table using \\n     # id- dense rank - row number or rank works too \\n    select a.*,\\n    id-dense_rank() over (order by id) grp\\n    from \\n        (# 1. Inner-most subquery - subset pop >= 100\\n        select * \\n        from Stadium \\n        where people >= 100) a) b) c\\n\\nwhere c.Count >= 3;",
                "codeTag": "Unknown"
            },
            {
                "id": 1761947,
                "title": "mysql-join",
                "content": "#### My Solution:\\n\\n```sql\\nSELECT DISTINCT S1.id, S1.visit_date, S1.people FROM Stadium S1, Stadium S2, Stadium S3\\nWHERE S1.people >= 100 AND S2.people >= 100 AND S3.people >= 100 AND (\\n    #t1 as first day\\n    (S1.id = S2.id - 1 AND S1.id = S3.id - 2 AND S2.id = S3.id - 1 ) OR\\n    #t1 as 2nd day\\n    (S1.id = S2.id + 1 AND S1.id = S3.id - 1 AND S2.id = S3.id - 2 ) OR\\n    #t1 as 3nd day\\n    (S1.id = S2.id + 2 AND S1.id = S3.id + 1 AND S2.id = S3.id - 1 ) \\n)\\nORDER BY S1.visit_date\\n\\n```\\n\\n\\n\\n##### Note:\\n\\n1. The tricky part for this problem is need to think of the day `t1` into 3 cases:\\n   - `t1` is as of the first day : ` t1 - t2 - t3`\\n   - `t1` is as of the second day : `   t2 - t1- t3`\\n   - `t1` is as of the first day : ` t2 - t3 - t1`\\n\\nIn the begining I only thought of the first case, and only got the results of the first few days of the consecutive days,  rather than all of the consecutive days. \\n\\n2. `JOIN` is a way to deal with consecutive things. \\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT DISTINCT S1.id, S1.visit_date, S1.people FROM Stadium S1, Stadium S2, Stadium S3\\nWHERE S1.people >= 100 AND S2.people >= 100 AND S3.people >= 100 AND (\\n    #t1 as first day\\n    (S1.id = S2.id - 1 AND S1.id = S3.id - 2 AND S2.id = S3.id - 1 ) OR\\n    #t1 as 2nd day\\n    (S1.id = S2.id + 1 AND S1.id = S3.id - 1 AND S2.id = S3.id - 2 ) OR\\n    #t1 as 3nd day\\n    (S1.id = S2.id + 2 AND S1.id = S3.id + 1 AND S2.id = S3.id - 1 ) \\n)\\nORDER BY S1.visit_date\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1743152,
                "title": "sql-server-solution-value-windows-function",
                "content": "The thinking process is as following\\n1) Get all the ids with people greater or equal to 100\\n2) Use value window function LEAD() to get 3 concecutive id ranges\\n3) Show all the id within those id ranges \\n\\n```\\n/* Write your T-SQL query statement below */\\nWith id_update as (\\n    select *\\n    from Stadium\\n    where people >= 100\\n), id_valid as (\\n    select *\\n    from (\\n    select id\\n    , id_2 = LEAD(id, 2) over(order by id)\\n    from id_update\\n        ) a\\n    where id+2 = id_2\\n)\\n\\nselect distinct a.*\\nfrom stadium a\\ninner join id_valid b\\n    on a.id >= b.id\\n    and a.id <= b.id_2\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWith id_update as (\\n    select *\\n    from Stadium\\n    where people >= 100\\n), id_valid as (\\n    select *\\n    from (\\n    select id\\n    , id_2 = LEAD(id, 2) over(order by id)\\n    from id_update\\n        ) a\\n    where id+2 = id_2\\n)\\n\\nselect distinct a.*\\nfrom stadium a\\ninner join id_valid b\\n    on a.id >= b.id\\n    and a.id <= b.id_2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729859,
                "title": "using-cte-s-and-windows-function",
                "content": "\\'\\'\\'with cte1 as (\\n    select * \\n    from stadium \\n    where people >= 100 ),\\ncte2 as (   \\n    select *\\n        , row_number() over (order by id) as rn\\n        , id - (row_number() over (order by id)) as row_diff\\n    from cte1 ), \\ncte3 as (    \\n    select * \\n    , count(*) over ( partition by row_diff) as cons_cnt \\n    from cte2 )\\n   \\nselect id, visit_date, people\\nfrom cte3\\nwhere cons_cnt >= 3\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'with cte1 as (\\n    select * \\n    from stadium \\n    where people >= 100 ),\\ncte2 as (   \\n    select *\\n        , row_number() over (order by id) as rn\\n        , id - (row_number() over (order by id)) as row_diff\\n    from cte1 ), \\ncte3 as (    \\n    select * \\n    , count(*) over ( partition by row_diff) as cons_cnt \\n    from cte2 )\\n   \\nselect id, visit_date, people\\nfrom cte3\\nwhere cons_cnt >= 3\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1578476,
                "title": "faster-than-98-and-easy-to-understand-query",
                "content": "We need to check if the current row and the next 2 rows have >= 100 **OR** the current row, row before and one row after has >= 100 **OR** the current and previous 2 rows have >=100 people\\n```\\nselect id, visit_date, people\\nfrom \\n(select \\n\\nid, visit_date, people, \\n lead(people, 1) over ( order by id) as 1_next, \\n lead(people, 2) over ( order by id) as 2_next,\\n lag(people, 1) over ( order by id) as 1_prev,\\n lag(people, 2) over ( order by id) as 2_prev\\n\\nfrom Stadium\\n) a\\n\\nwhere (people >= 100) and\\n\\n(\\n    (1_next >= 100 and 2_next >=100) or\\n    (1_prev >= 100 and 2_prev >=100) or\\n    (1_prev >= 100 and 1_next >=100)\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, visit_date, people\\nfrom \\n(select \\n\\nid, visit_date, people, \\n lead(people, 1) over ( order by id) as 1_next, \\n lead(people, 2) over ( order by id) as 2_next,\\n lag(people, 1) over ( order by id) as 1_prev,\\n lag(people, 2) over ( order by id) as 2_prev\\n\\nfrom Stadium\\n) a\\n\\nwhere (people >= 100) and\\n\\n(\\n    (1_next >= 100 and 2_next >=100) or\\n    (1_prev >= 100 and 2_prev >=100) or\\n    (1_prev >= 100 and 1_next >=100)\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1393169,
                "title": "super-simple-5-lines-code-beginner-friendly",
                "content": "```\\nWITH cte AS\\n(SELECT id,visit_date,people,id-ROW_NUMBER() OVER(ORDER BY id) AS grp FROM Stadium WHERE people>=100)\\n\\nSELECT id, visit_date, people\\nFROM cte \\nWHERE grp IN (SELECT grp FROM cte GROUP BY grp HAVING COUNT(id) >= 3) \\n\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte AS\\n(SELECT id,visit_date,people,id-ROW_NUMBER() OVER(ORDER BY id) AS grp FROM Stadium WHERE people>=100)\\n\\nSELECT id, visit_date, people\\nFROM cte \\nWHERE grp IN (SELECT grp FROM cte GROUP BY grp HAVING COUNT(id) >= 3) \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351762,
                "title": "super-simple-solution-4-lines-code",
                "content": "```\\nWITH cte AS (SELECT id,visit_date,people,id-ROW_NUMBER() OVER(ORDER BY id) AS grp FROM Stadium WHERE people>=100)\\n\\nSELECT id,visit_date,people\\nFROM cte WHERE grp in (SELECT grp FROM cte GROUP BY grp HAVING COUNT(id)>=3)\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte AS (SELECT id,visit_date,people,id-ROW_NUMBER() OVER(ORDER BY id) AS grp FROM Stadium WHERE people>=100)\\n\\nSELECT id,visit_date,people\\nFROM cte WHERE grp in (SELECT grp FROM cte GROUP BY grp HAVING COUNT(id)>=3)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331529,
                "title": "mysql-solution-using-cte-and-window-function",
                "content": "```\\nWITH base\\n     AS (SELECT *,\\n                id - Row_number()\\n                       OVER(\\n                         ORDER BY visit_date) AS grp\\n         FROM   stadium\\n         WHERE  people >= 100)\\nSELECT id,\\n       visit_date,\\n       people\\nFROM   (SELECT *,\\n               Count(*)\\n                 OVER (\\n                   partition BY grp) cnt\\n        FROM   base) a\\nWHERE  cnt >= 3 \\n```",
                "solutionTags": [],
                "code": "```\\nWITH base\\n     AS (SELECT *,\\n                id - Row_number()\\n                       OVER(\\n                         ORDER BY visit_date) AS grp\\n         FROM   stadium\\n         WHERE  people >= 100)\\nSELECT id,\\n       visit_date,\\n       people\\nFROM   (SELECT *,\\n               Count(*)\\n                 OVER (\\n                   partition BY grp) cnt\\n        FROM   base) a\\nWHERE  cnt >= 3 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1304096,
                "title": "windows-function-lag-lead",
                "content": "The idea is simple - look at the 3 possible combination of rows to mark them as \"valid\". \\n\\n```\\nSELECT d.id, d.visit_Date, d.people\\nFROM\\n(select id, visit_date, people,\\n    CASE\\n        WHEN IFNULL(lag(people, 2) over() >= 100,FALSE) AND IFNULL(lag(people, 1) over() >= 100,FALSE) and people >=100 THEN 1\\n        WHEN IFNULL(lag(people, 1) over() >= 100,FALSE) AND IFNULL(LEAD(people, 1) over() >= 100,FALSE) and people >=100 THEN 1\\n        WHEN IFNULL(LEAD(people, 2) over() >= 100,FALSE) AND IFNULL(LEAD(people, 1) over() >= 100,FALSE) and people >=100 THEN 1\\n        ELSE 0\\n    END as th\\nFROM Stadium\\n)as d\\nWHERE th = 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT d.id, d.visit_Date, d.people\\nFROM\\n(select id, visit_date, people,\\n    CASE\\n        WHEN IFNULL(lag(people, 2) over() >= 100,FALSE) AND IFNULL(lag(people, 1) over() >= 100,FALSE) and people >=100 THEN 1\\n        WHEN IFNULL(lag(people, 1) over() >= 100,FALSE) AND IFNULL(LEAD(people, 1) over() >= 100,FALSE) and people >=100 THEN 1\\n        WHEN IFNULL(LEAD(people, 2) over() >= 100,FALSE) AND IFNULL(LEAD(people, 1) over() >= 100,FALSE) and people >=100 THEN 1\\n        ELSE 0\\n    END as th\\nFROM Stadium\\n)as d\\nWHERE th = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103225,
                "title": "mysql-this-problem-turns-easy-if-you-know-window-function",
                "content": "```\\n# Write your MySQL query statement below\\nWITH lag12 AS (\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        LEAD(people, 1) OVER(w) AS people_bwd1,\\n        LEAD(people, 2) OVER(w) AS people_bwd2,\\n        LAG(people, 1) OVER(w) AS people_fwd1,\\n        LAG(people, 2) OVER(w) AS people_fwd2\\n    FROM stadium\\n    WINDOW w AS (ORDER BY id)\\n)\\nSELECT\\n    id,\\n    visit_date,\\n    people\\nFROM lag12 \\nWHERE people >= 100 AND (LEAST(people_fwd1, people_fwd2) >= 100 OR LEAST(people_bwd1, people_bwd2) >= 100 \\nOR LEAST(people_fwd1, people_bwd1) >= 100)\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nWITH lag12 AS (\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        LEAD(people, 1) OVER(w) AS people_bwd1,\\n        LEAD(people, 2) OVER(w) AS people_bwd2,\\n        LAG(people, 1) OVER(w) AS people_fwd1,\\n        LAG(people, 2) OVER(w) AS people_fwd2\\n    FROM stadium\\n    WINDOW w AS (ORDER BY id)\\n)\\nSELECT\\n    id,\\n    visit_date,\\n    people\\nFROM lag12 \\nWHERE people >= 100 AND (LEAST(people_fwd1, people_fwd2) >= 100 OR LEAST(people_bwd1, people_bwd2) >= 100 \\nOR LEAST(people_fwd1, people_bwd1) >= 100)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1083500,
                "title": "very-eay-solution-using-lead-and-left-join",
                "content": "\\n```\\n\\nselect  \\ndistinct \\nb.id, b.visit_date,b.people\\nfrom\\n(\\nselect \\n    id as id1,\\n    lead(id,1) over (order by id) as id2,\\n    lead(id,2) over (order by id) as id3\\nfrom stadium\\nwhere people>=100\\n) a\\nleft join stadium b on (b.id =id1 or b.id = id2 or b.id = id3)\\nwhere id1+1 = id2 and id2+1 = id3\\norder by id",
                "solutionTags": [],
                "code": "\\n```\\n\\nselect  \\ndistinct \\nb.id, b.visit_date,b.people\\nfrom\\n(\\nselect \\n    id as id1,\\n    lead(id,1) over (order by id) as id2,\\n    lead(id,2) over (order by id) as id3\\nfrom stadium\\nwhere people>=100\\n) a\\nleft join stadium b on (b.id =id1 or b.id = id2 or b.id = id3)\\nwhere id1+1 = id2 and id2+1 = id3\\norder by id",
                "codeTag": "Unknown"
            },
            {
                "id": 1018835,
                "title": "mysql-window-function-join",
                "content": "Solution 1: Window function\\n\\n```\\nSELECT id, visit_date, people\\n  FROM \\n       (SELECT *, \\n               LAG(people, 2) OVER (ORDER BY id) AS lag2,\\n               LAG(people, 1) OVER (ORDER BY id) AS lag1,\\n               LEAD(people, 2) OVER (ORDER BY id) AS lead2,\\n               LEAD(people, 1) OVER (ORDER BY id) AS lead1\\n          FROM Stadium) t\\n WHERE (t.people >= 100 AND t.lag2 >= 100 AND t.lag1 >= 100)\\n    OR (t.people >= 100 AND t.lag1 >=100 AND t.lead1 >= 100)\\n    OR (t.people >= 100 AND t.lead2 >= 100 AND t.lead1 >= 100)\\nORDER BY id ASC\\n```\\n\\nSolution 2: self join\\n```\\nSELECT DISTINCT s1.*\\n  FROM Stadium s1, Stadium s2, Stadium s3\\n WHERE s1.people >= 100\\n   AND s2.people >= 100\\n   AND s3.people >= 100\\n   AND (\\n          (s1.id - s2.id = 1 AND s1.id - s3.id = 2 AND s2.id - s3.id = 1)  #1,2,3\\n       OR (s3.id - s2.id = 1 AND s3.id - s1.id = 2 AND s2.id - s1.id = 1)  #3,2,1\\n       OR (s2.id - s1.id = 1 AND s2.id - s3.id = 2 AND s1.id - s3.id = 1)  #2,1,3     \\n   )\\nORDER BY s1.visit_date ASC\\n```\\n\\nSolution 3: inner join\\n```\\nSELECT DISTINCT s1.*\\n  FROM Stadium s1\\n  JOIN Stadium s2\\n  JOIN Stadium s3\\n    ON (s1.id + 1 = s2.id AND s1.id + 2 = s3.id)  #1,2,3\\n    OR (s3.id + 1 = s2.id AND s3.id + 2 = s1.id)  #3,2,1\\n    OR (s2.id + 1 = s1.id AND s2.id + 2 = s3.id)  #2,1,3\\n WHERE s1.people >= 100\\n   AND s2.people >= 100\\n   AND s3.people >= 100\\nORDER BY s1.id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id, visit_date, people\\n  FROM \\n       (SELECT *, \\n               LAG(people, 2) OVER (ORDER BY id) AS lag2,\\n               LAG(people, 1) OVER (ORDER BY id) AS lag1,\\n               LEAD(people, 2) OVER (ORDER BY id) AS lead2,\\n               LEAD(people, 1) OVER (ORDER BY id) AS lead1\\n          FROM Stadium) t\\n WHERE (t.people >= 100 AND t.lag2 >= 100 AND t.lag1 >= 100)\\n    OR (t.people >= 100 AND t.lag1 >=100 AND t.lead1 >= 100)\\n    OR (t.people >= 100 AND t.lead2 >= 100 AND t.lead1 >= 100)\\nORDER BY id ASC\\n```\n```\\nSELECT DISTINCT s1.*\\n  FROM Stadium s1, Stadium s2, Stadium s3\\n WHERE s1.people >= 100\\n   AND s2.people >= 100\\n   AND s3.people >= 100\\n   AND (\\n          (s1.id - s2.id = 1 AND s1.id - s3.id = 2 AND s2.id - s3.id = 1)  #1,2,3\\n       OR (s3.id - s2.id = 1 AND s3.id - s1.id = 2 AND s2.id - s1.id = 1)  #3,2,1\\n       OR (s2.id - s1.id = 1 AND s2.id - s3.id = 2 AND s1.id - s3.id = 1)  #2,1,3     \\n   )\\nORDER BY s1.visit_date ASC\\n```\n```\\nSELECT DISTINCT s1.*\\n  FROM Stadium s1\\n  JOIN Stadium s2\\n  JOIN Stadium s3\\n    ON (s1.id + 1 = s2.id AND s1.id + 2 = s3.id)  #1,2,3\\n    OR (s3.id + 1 = s2.id AND s3.id + 2 = s1.id)  #3,2,1\\n    OR (s2.id + 1 = s1.id AND s2.id + 2 = s3.id)  #2,1,3\\n WHERE s1.people >= 100\\n   AND s2.people >= 100\\n   AND s3.people >= 100\\nORDER BY s1.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929871,
                "title": "mysql-easy-to-understand-concise-fast-solution",
                "content": "```\\n# Write your MySQL query statement below\\n/* there would be a gap when there are rows removed because of people < 100 */\\nwith cte as (select *, (id - ROW_NUMBER() OVER (ORDER BY id ASC)) \\'group_id\\' from Stadium where people >= 100)\\n\\nselect cte.id, cte.visit_date, cte.people from cte join\\n(select group_id from cte\\ngroup by group_id\\nhaving count(*) >= 3) as tbl\\non (cte.group_id = tbl.group_id)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c197945e-d602-4655-aaef-f4eb94418df7_1604954572.5559208.png)\\n",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n/* there would be a gap when there are rows removed because of people < 100 */\\nwith cte as (select *, (id - ROW_NUMBER() OVER (ORDER BY id ASC)) \\'group_id\\' from Stadium where people >= 100)\\n\\nselect cte.id, cte.visit_date, cte.people from cte join\\n(select group_id from cte\\ngroup by group_id\\nhaving count(*) >= 3) as tbl\\non (cte.group_id = tbl.group_id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 842170,
                "title": "oracle-93-faster-using-lead-and-lag",
                "content": "```\\nwith t1 as (\\n\\tselect id, to_char(visit_date, \\'yyyy-mm-dd\\') visit_date, people p1, \\n\\tlead(people, 1)over(order by id) p2, \\n\\tlead(people, 2)over(order by id) p3, \\n\\tlag(people, 1)over(order by id) p4, \\n\\tlag(people, 2)over(order by id) p5\\n from stadium\\n )\\nselect id, visit_date, p1 people\\nfrom t1\\nwhere (p1 >= 100 and p2 >=100 and p3>=100) \\nor (p1>=100 and p4>=100 and p5>=100)\\nor (p1>=100 and p2>=100 and p4>=100)\\n```\\n\\n\\nBasically the 3 conditions, just check if the adjacent dates have people visited more equal to 100\\n",
                "solutionTags": [],
                "code": "```\\nwith t1 as (\\n\\tselect id, to_char(visit_date, \\'yyyy-mm-dd\\') visit_date, people p1, \\n\\tlead(people, 1)over(order by id) p2, \\n\\tlead(people, 2)over(order by id) p3, \\n\\tlag(people, 1)over(order by id) p4, \\n\\tlag(people, 2)over(order by id) p5\\n from stadium\\n )\\nselect id, visit_date, p1 people\\nfrom t1\\nwhere (p1 >= 100 and p2 >=100 and p3>=100) \\nor (p1>=100 and p4>=100 and p5>=100)\\nor (p1>=100 and p2>=100 and p4>=100)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788321,
                "title": "mysql-faster-than-65-easy-to-follow",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT s1.*\\nFROM stadium s1,\\n    stadium s2,\\n    stadium s3\\nWHERE ((s1.id = s2.id -1\\n    AND s1.id = s3.id - 2)\\n    OR (s3.id = s1.id -1\\n    AND s3.id = s2.id - 2)\\n    OR (s3.id = s2.id -1\\n    AND s3.id = s1.id - 2))\\n    AND s1.people >= 100\\n    AND s2.people >= 100\\n    AND s3.people >= 100\\nORDER BY s1.id;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT s1.*\\nFROM stadium s1,\\n    stadium s2,\\n    stadium s3\\nWHERE ((s1.id = s2.id -1\\n    AND s1.id = s3.id - 2)\\n    OR (s3.id = s1.id -1\\n    AND s3.id = s2.id - 2)\\n    OR (s3.id = s2.id -1\\n    AND s3.id = s1.id - 2))\\n    AND s1.people >= 100\\n    AND s2.people >= 100\\n    AND s3.people >= 100\\nORDER BY s1.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753463,
                "title": "faster-than-97-23-of-submissions-ms-sql-server",
                "content": "\\nHeavy on subqueries but simple subqueries \\n1, 2, 3, 4  are the queries from the innermost to outermost\\n\\n1 - filter the dates with >= 100 people\\n2 - Get a new column to group the ids based on subtracting new row number from the current id\\n3 - Count the entries in each group created in the query 2\\n4 - Filter the entries with  greater than count 2 calculated in 3\\n \\n```\\nSELECT id, visit_date, people\\nFROM (\\nSELECT *, COUNT(*) OVER(PARTITION BY grp) numEntries\\nFROM (\\nSELECT *, id - ROW_NUMBER() OVER (ORDER BY id) grp\\nFROM (\\nSELECT *\\nFROM stadium\\nWHERE people >= 100\\n) moreThan100\\n) grouped\\n) numPerSequence\\nWHERE numEntries > 2;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id, visit_date, people\\nFROM (\\nSELECT *, COUNT(*) OVER(PARTITION BY grp) numEntries\\nFROM (\\nSELECT *, id - ROW_NUMBER() OVER (ORDER BY id) grp\\nFROM (\\nSELECT *\\nFROM stadium\\nWHERE people >= 100\\n) moreThan100\\n) grouped\\n) numPerSequence\\nWHERE numEntries > 2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 677699,
                "title": "mysql-solution-easy-to-understand",
                "content": "```\\nselect id,\\n       visit_date,\\n       people\\nfrom(\\n     select *,\\n            sum(if_100) over(rows between 2 preceding and current row) as cnt1,\\n            sum(if_100) over(rows between current row and 2 following) as cnt2,\\n            sum(if_100) over(rows between 1 preceding and 1 following) as cnt3\\n     from(\\n          select *, \\n                 case when people >= 100 then 1 else 0 end as if_100\\n          from stadium) s\\n     ) t\\nwhere cnt1 = 3\\n   or cnt2 = 3\\n   or cnt3 = 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\n       visit_date,\\n       people\\nfrom(\\n     select *,\\n            sum(if_100) over(rows between 2 preceding and current row) as cnt1,\\n            sum(if_100) over(rows between current row and 2 following) as cnt2,\\n            sum(if_100) over(rows between 1 preceding and 1 following) as cnt3\\n     from(\\n          select *, \\n                 case when people >= 100 then 1 else 0 end as if_100\\n          from stadium) s\\n     ) t\\nwhere cnt1 = 3\\n   or cnt2 = 3\\n   or cnt3 = 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 662872,
                "title": "simple-mssql-solution-using-lead-lag",
                "content": "```\\nselect id, visit_date, people from (\\n    select *,\\n            lag(people,1) over(order by visit_date) as lag_1,\\n            lag(people,2) over(order by visit_date) as lag_2,    \\n            lead(people,1) over(order by visit_date) as lead_1,\\n            lead(people,2) over(order by visit_date) as lead_2\\n    from stadium\\n) as a\\n    where people>=100 and ((lag_1>=100 and lag_2>=100) or\\n                           (lead_1>=100 and lead_2>=100) or\\n                           (lead_1>=100 and lag_1>=100) \\n                          )\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, visit_date, people from (\\n    select *,\\n            lag(people,1) over(order by visit_date) as lag_1,\\n            lag(people,2) over(order by visit_date) as lag_2,    \\n            lead(people,1) over(order by visit_date) as lead_1,\\n            lead(people,2) over(order by visit_date) as lead_2\\n    from stadium\\n) as a\\n    where people>=100 and ((lag_1>=100 and lag_2>=100) or\\n                           (lead_1>=100 and lead_2>=100) or\\n                           (lead_1>=100 and lag_1>=100) \\n                          )\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 659558,
                "title": "oracle-74-5-solution",
                "content": "```\\nSELECT ID, VISIT_DATE, PEOPLE\\nFROM (\\n        SELECT\\n                ID, TO_CHAR(VISIT_DATE, \\'YYYY-MM-DD\\') AS VISIT_DATE , PEOPLE,\\n                CASE \\n                    WHEN PEOPLE>=100 AND LEAD(PEOPLE) OVER (ORDER BY ID) >= 100 AND LEAD(PEOPLE,2) OVER (ORDER BY ID) >= 100 THEN 1\\n                    WHEN PEOPLE>=100 AND LEAD(PEOPLE) OVER (ORDER BY ID) >= 100 AND LAG(PEOPLE) OVER (ORDER BY ID) >= 100 THEN 1\\n                    WHEN PEOPLE>=100 AND LAG(PEOPLE) OVER (ORDER BY ID) >= 100 AND LAG(PEOPLE,2) OVER (ORDER BY ID) >= 100 THEN 1\\n                    ELSE 0 END AS CHECK_CONDITION\\n        FROM\\n                STADIUM\\n)\\nWHERE CHECK_CONDITION = 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT ID, VISIT_DATE, PEOPLE\\nFROM (\\n        SELECT\\n                ID, TO_CHAR(VISIT_DATE, \\'YYYY-MM-DD\\') AS VISIT_DATE , PEOPLE,\\n                CASE \\n                    WHEN PEOPLE>=100 AND LEAD(PEOPLE) OVER (ORDER BY ID) >= 100 AND LEAD(PEOPLE,2) OVER (ORDER BY ID) >= 100 THEN 1\\n                    WHEN PEOPLE>=100 AND LEAD(PEOPLE) OVER (ORDER BY ID) >= 100 AND LAG(PEOPLE) OVER (ORDER BY ID) >= 100 THEN 1\\n                    WHEN PEOPLE>=100 AND LAG(PEOPLE) OVER (ORDER BY ID) >= 100 AND LAG(PEOPLE,2) OVER (ORDER BY ID) >= 100 THEN 1\\n                    ELSE 0 END AS CHECK_CONDITION\\n        FROM\\n                STADIUM\\n)\\nWHERE CHECK_CONDITION = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 544119,
                "title": "simple-simple-subquery-in-where",
                "content": "Unlike other solution that joins together tables.\\nThe sub query is just querying a certain row, should be fast, at most log n ...\\n\\n```\\nselect s.id, visit_date, people\\nfrom stadium as s\\nwhere (\\n    s.people >= 100 and \\n    (\\n       (select people from stadium where id = s.id-1) >= 100 and  \\n       (select people from stadium where id = s.id+1) >= 100  \\n        or \\n       (select people from stadium where id = s.id-1) >= 100 and  \\n       (select people from stadium where id = s.id-2) >= 100 \\n        or \\n       (select people from stadium where id = s.id+1) >= 100 and  \\n       (select people from stadium where id = s.id+2) >= 100  \\n    )\\n)\\n```\\ntotal run time should be at most n(6logn) O(nlogn)",
                "solutionTags": [],
                "code": "```\\nselect s.id, visit_date, people\\nfrom stadium as s\\nwhere (\\n    s.people >= 100 and \\n    (\\n       (select people from stadium where id = s.id-1) >= 100 and  \\n       (select people from stadium where id = s.id+1) >= 100  \\n        or \\n       (select people from stadium where id = s.id-1) >= 100 and  \\n       (select people from stadium where id = s.id-2) >= 100 \\n        or \\n       (select people from stadium where id = s.id+1) >= 100 and  \\n       (select people from stadium where id = s.id+2) >= 100  \\n    )\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 489747,
                "title": "guarantee-understood-mysql-join-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT a.id, a.visit_date, a.people\\nFROM stadium as a\\nLEFT JOIN stadium as b\\nON a.id = b.id - 1\\nLEFT JOIN stadium as c\\nON a.id = c.id - 2\\nLEFT JOIN stadium as d\\nON a.id = d.id + 1\\nLEFT JOIN stadium as e\\nON a.id = e.id + 2\\nWHERE a.people >= 100\\nAND ((b.people >= 100 and c.people >= 100)\\nOR (b.people >= 100 and d.people >= 100)\\nOR (e.people >= 100 and d.people >= 100))\\nORDER BY a.id\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a.id, a.visit_date, a.people\\nFROM stadium as a\\nLEFT JOIN stadium as b\\nON a.id = b.id - 1\\nLEFT JOIN stadium as c\\nON a.id = c.id - 2\\nLEFT JOIN stadium as d\\nON a.id = d.id + 1\\nLEFT JOIN stadium as e\\nON a.id = e.id + 2\\nWHERE a.people >= 100\\nAND ((b.people >= 100 and c.people >= 100)\\nOR (b.people >= 100 and d.people >= 100)\\nOR (e.people >= 100 and d.people >= 100))\\nORDER BY a.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387734,
                "title": "lead-lag-gets-this-done-in-a-jiffy-ya-heard",
                "content": "Hello Codes and Coders:\\n\\nLet\\'s let the Lead() n\\' the Lag() do the work for us:\\n\\n```\\nwith laggers_n_leaders as (\\nselect\\nid,\\nvisit_date,\\npeople,\\nlag(people, 1) over(order by id) as lag_1,\\nlag(people, 2) over(order by id) as lag_2,\\nlead(people,1) over(order by id) as next_1,\\nlead(people,2) over(order by id) as next_2\\nfrom stadium\\n)\\n\\nselect\\nid,\\nvisit_date,\\npeople\\nfrom laggers_n_leaders\\nwhere  -- where it\\'s the *end* of the 3 consecutive \\n(people >= 100\\nand lag_1 >= 100\\nand lag_2 >= 100)\\nor -- where it\\'s the *beginning* of the 3 consecutive  \\n(people >= 100\\nand next_1 >= 100 \\nand next_2 >= 100)\\nor -- where it\\'s the *middle* of the 3 consecutive \\n(people >= 100\\nand lag_1 >= 100\\nand next_1 >= 100\\n);\\n```\\n\\nCheers,<br>\\nGeorge John Jordan Thomas Aquinas Hayward, Optimist <br>\\nhttps://ghayward.github.io\\n\\n[![GJJTAHO](https://i.ibb.co/wBjBb4G/gjjtah.jpg)](https://ghayward.github.io)\\n\\n## The Lord Always Delivers",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nwith laggers_n_leaders as (\\nselect\\nid,\\nvisit_date,\\npeople,\\nlag(people, 1) over(order by id) as lag_1,\\nlag(people, 2) over(order by id) as lag_2,\\nlead(people,1) over(order by id) as next_1,\\nlead(people,2) over(order by id) as next_2\\nfrom stadium\\n)\\n\\nselect\\nid,\\nvisit_date,\\npeople\\nfrom laggers_n_leaders\\nwhere  -- where it\\'s the *end* of the 3 consecutive \\n(people >= 100\\nand lag_1 >= 100\\nand lag_2 >= 100)\\nor -- where it\\'s the *beginning* of the 3 consecutive  \\n(people >= 100\\nand next_1 >= 100 \\nand next_2 >= 100)\\nor -- where it\\'s the *middle* of the 3 consecutive \\n(people >= 100\\nand lag_1 >= 100\\nand next_1 >= 100\\n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246530,
                "title": "mysql-solution-183ms-faster-than-100",
                "content": "I didn\\'t come up with anything similar to the solution but made this up and it worked!\\n\\n```\\n# Write your MySQL query statement below\\nSELECT s.id, s.visit_date, s.people\\nFROM stadium AS s,\\n     (SELECT min(a.id-b.id-1) AS ct, a.id AS ed\\n      FROM ((SELECT id FROM stadium WHERE people < 100) \\n            UNION \\n            (SELECT COUNT(*)+1 FROM stadium)\\n           ) AS a,\\n           ((SELECT id FROM stadium WHERE people < 100) \\n            UNION \\n            (SELECT COUNT(*)-COUNT(*) FROM stadium)\\n           ) AS b\\n      WHERE a.id > b.id\\n      GROUP BY a.id\\n      HAVING MIN(a.id-b.id-1) >= 3) AS c\\nWHERE s.id >= ed-ct AND s.id < ed\\n;\\n```\\n\\nTake an example:\\n* Table Stadium: there are 8 rows in total.\\n* Table a: contains the rows that set the upper boundary of consecutive rows (4 is the upper bound of 1~3 rows).\\n* Table b: contains the rows that set the lower boundary of consecutive rows (0 is the lower bound of 1~3 rows).\\n* Table c: calculate the distance between 2 boundaries and check whether between them, they are at least 3 rows.\\n* Once we know the upper boundary and the count of consecutive rows below this boundary, we can find the first through the last consecutive rows.\\n![image](https://assets.leetcode.com/users/meijinw/image_1551433657.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s.id, s.visit_date, s.people\\nFROM stadium AS s,\\n     (SELECT min(a.id-b.id-1) AS ct, a.id AS ed\\n      FROM ((SELECT id FROM stadium WHERE people < 100) \\n            UNION \\n            (SELECT COUNT(*)+1 FROM stadium)\\n           ) AS a,\\n           ((SELECT id FROM stadium WHERE people < 100) \\n            UNION \\n            (SELECT COUNT(*)-COUNT(*) FROM stadium)\\n           ) AS b\\n      WHERE a.id > b.id\\n      GROUP BY a.id\\n      HAVING MIN(a.id-b.id-1) >= 3) AS c\\nWHERE s.id >= ed-ct AND s.id < ed\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 183452,
                "title": "stupid-straight-forward-solution",
                "content": "```\\nselect c.id, c.date, c.people\\nfrom stadium c \\nleft join stadium a\\non a.id = c.id-2\\nleft join stadium b\\non b.id = c.id-1\\nleft join stadium d\\non d.id = c.id+1\\nleft join stadium e\\non e.id = c.id+2\\nwhere\\n(a.people>=100 and b.people>=100 and c.people>=100) or\\n(d.people>=100 and b.people>=100 and c.people>=100) or\\n(c.people>=100 and d.people>=100 and e.people>=100)\\norder by c.date;\\n```",
                "solutionTags": [],
                "code": "```\\nselect c.id, c.date, c.people\\nfrom stadium c \\nleft join stadium a\\non a.id = c.id-2\\nleft join stadium b\\non b.id = c.id-1\\nleft join stadium d\\non d.id = c.id+1\\nleft join stadium e\\non e.id = c.id+2\\nwhere\\n(a.people>=100 and b.people>=100 and c.people>=100) or\\n(d.people>=100 and b.people>=100 and c.people>=100) or\\n(c.people>=100 and d.people>=100 and e.people>=100)\\norder by c.date;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173295,
                "title": "mysql-solution-using-variable",
                "content": "```\\nSelect id, date, people\\nFrom (\\nSelect id, date, people,\\n    @rank:= If(people>=100, @rank+1, 0) AS Rank,\\n    @group:= If(@rank=0 or @rank=1, @group+1, @group) AS GroupNum\\nFrom stadium, (Select @rank:=0, @group:=0) var\\n) tmp\\n    \\nJOIN\\n(\\n    Select GroupNum\\n    From\\n        (\\n        Select id, date, people,\\n            @rank_:= If(people>=100, @rank_+1, 0) AS Rank,\\n            @group_:= If(@rank_=0 or @rank_=1, @group_+1, @group_) AS GroupNum\\n        From stadium, (Select @rank_:=0, @group_:=0) var\\n        ) tmp2\\n    Group By GroupNum\\n    Having count(*) >=3\\n) filter\\nON tmp.GroupNum = filter.GroupNum;\\n```\\n\\nSince MySQL 5.7 doesn\\'t support CTE `WITH` clause, I can only repeat the subquery. Also note because the subquery with variable was used twice in the query, the variable name in the second subquery need change, otherwise looks like two subquery will interfere each other and the result is empty.",
                "solutionTags": [],
                "code": "```\\nSelect id, date, people\\nFrom (\\nSelect id, date, people,\\n    @rank:= If(people>=100, @rank+1, 0) AS Rank,\\n    @group:= If(@rank=0 or @rank=1, @group+1, @group) AS GroupNum\\nFrom stadium, (Select @rank:=0, @group:=0) var\\n) tmp\\n    \\nJOIN\\n(\\n    Select GroupNum\\n    From\\n        (\\n        Select id, date, people,\\n            @rank_:= If(people>=100, @rank_+1, 0) AS Rank,\\n            @group_:= If(@rank_=0 or @rank_=1, @group_+1, @group_) AS GroupNum\\n        From stadium, (Select @rank_:=0, @group_:=0) var\\n        ) tmp2\\n    Group By GroupNum\\n    Having count(*) >=3\\n) filter\\nON tmp.GroupNum = filter.GroupNum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103775,
                "title": "i-use-variable-to-do-it",
                "content": "```\\nSELECT \\n  * \\nFROM\\n  stadium \\nWHERE INSTR(\\n    (SELECT CONCAT(',',GROUP_CONCAT(tmpaa.ids),',') AS ids FROM (SELECT \\n      GROUP_CONCAT(id) AS ids\\n    FROM\\n      (SELECT \\n        id,\\n        CASE\\n          WHEN (\\n            (@prevone := people) < 100 \\n            OR (@prevone >= 100 \\n              AND @prevtwo < 100)\\n          ) \\n          THEN @group := @group + 1 \\n          ELSE @group := @group \\n        END AS groupno,\\n        (@prevtwo := people) AS bb \\n      FROM\\n        stadium,\\n        (SELECT \\n          @group := 0,\\n          @prevone := - 1,\\n          @prevtwo := - 1) init) AS tmp \\n    GROUP BY tmp.groupno \\n    HAVING COUNT(1) >= 3 ) AS tmpaa),\\n    CONCAT(',', id, ',')\\n  ) > 0\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n  * \\nFROM\\n  stadium \\nWHERE INSTR(\\n    (SELECT CONCAT(',',GROUP_CONCAT(tmpaa.ids),',') AS ids FROM (SELECT \\n      GROUP_CONCAT(id) AS ids\\n    FROM\\n      (SELECT \\n        id,\\n        CASE\\n          WHEN (\\n            (@prevone := people) < 100 \\n            OR (@prevone >= 100 \\n              AND @prevtwo < 100)\\n          ) \\n          THEN @group := @group + 1 \\n          ELSE @group := @group \\n        END AS groupno,\\n        (@prevtwo := people) AS bb \\n      FROM\\n        stadium,\\n        (SELECT \\n          @group := 0,\\n          @prevone := - 1,\\n          @prevtwo := - 1) init) AS tmp \\n    GROUP BY tmp.groupno \\n    HAVING COUNT(1) >= 3 ) AS tmpaa),\\n    CONCAT(',', id, ',')\\n  ) > 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4069252,
                "title": "pandas-very-interesting-short-and-flexible-solution-no-joins-no-shifts",
                "content": "# Intuition\\nWe have to find 3+ consecutive days with more than 100 people. (ordered by id! not date). So right of the bat we dont need rows with less than 100 people. Now we want to find groups with 3+ consecutive days(id\\'s). But how to group it? The trick is to use difference between id(or any ordering row) and newly created row number.\\n# Approach\\nFirst we have to drop days with less than 100 people.  \\nThen we have to create new row_number column.  \\nCalculate difference between id and new row_nb.\\nTransform to get the size of group in each row. \\n\\n```\\nstadium = stadium.sort_values(\"id\").query(\"people >= 100\")\\nstadium[\"row_nb\"] = range(len(stadium))\\nstadium[\"id_rownb_diff\"] = stadium.id - stadium.row_nb\\nstadium[\"size_of_consecutive_group\"] = stadium.groupby(\"id_rownb_diff\")[\"id\"].transform(\"count\")\\n```\\nNow, notice that if id\\'s are consecutive, difference between id and newly created row_nb stays the same. \\n```\\n5-2 = 3\\n6-3 = 3\\n7-4 = 3 \\netc...\\n```\\nnow if we group the same difference of id-row_nb and get the size of this group, we will get number of consecutive days. If this number is >= than 3, that\\'s our answer.\\n```\\n| id | visit_date | people | row_nb | id_rownb_diff | size_of_consecutive_group |\\n| -- | ---------- | ------ | ------ | ------------- | ------------------------- |\\n| 2  | 2017-01-02 | 109    | 0      | 2             | 2                         |\\n| 3  | 2017-01-03 | 150    | 1      | 2             | 2                         |\\n| 5  | 2017-01-05 | 145    | 2      | 3             | 4                         |\\n| 6  | 2017-01-06 | 1455   | 3      | 3             | 4                         |\\n| 7  | 2017-01-10 | 199    | 4      | 3             | 4                         |\\n| 8  | 2017-01-09 | 188    | 5      | 3             | 4                         |\\n```\\nFinally just filter out rows with size of consecutive gropus >=3 and keep only relevant columns. That\\'s it.\\n\\n# Conclusion\\nNotice, that this approach is way more flexible than shifting or joining with difference of 1 and 2. Imagine if we had to find 100 consecutive days. Approach different than this would be ridiculous, becouse you would have to make 100 joins or 100 shifts. Here, we simply count group sizes.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef human_traffic(stadium: pd.DataFrame) -> pd.DataFrame:\\n    stadium = stadium.sort_values(\"id\").query(\"people >= 100\")\\n    stadium[\"row_nb\"] = range(len(stadium))\\n    stadium[\"id_rownb_diff\"] = stadium.id - stadium.row_nb\\n    stadium[\"size_of_consecutive_group\"] = stadium.groupby(\"id_rownb_diff\")[\"id\"].transform(\"count\")\\n    return stadium[stadium.size_of_consecutive_group >= 3][[\"id\",\"visit_date\",\"people\"]]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nstadium = stadium.sort_values(\"id\").query(\"people >= 100\")\\nstadium[\"row_nb\"] = range(len(stadium))\\nstadium[\"id_rownb_diff\"] = stadium.id - stadium.row_nb\\nstadium[\"size_of_consecutive_group\"] = stadium.groupby(\"id_rownb_diff\")[\"id\"].transform(\"count\")\\n```\n```\\n5-2 = 3\\n6-3 = 3\\n7-4 = 3 \\netc...\\n```\n```\\n| id | visit_date | people | row_nb | id_rownb_diff | size_of_consecutive_group |\\n| -- | ---------- | ------ | ------ | ------------- | ------------------------- |\\n| 2  | 2017-01-02 | 109    | 0      | 2             | 2                         |\\n| 3  | 2017-01-03 | 150    | 1      | 2             | 2                         |\\n| 5  | 2017-01-05 | 145    | 2      | 3             | 4                         |\\n| 6  | 2017-01-06 | 1455   | 3      | 3             | 4                         |\\n| 7  | 2017-01-10 | 199    | 4      | 3             | 4                         |\\n| 8  | 2017-01-09 | 188    | 5      | 3             | 4                         |\\n```\n```\\nimport pandas as pd\\n\\ndef human_traffic(stadium: pd.DataFrame) -> pd.DataFrame:\\n    stadium = stadium.sort_values(\"id\").query(\"people >= 100\")\\n    stadium[\"row_nb\"] = range(len(stadium))\\n    stadium[\"id_rownb_diff\"] = stadium.id - stadium.row_nb\\n    stadium[\"size_of_consecutive_group\"] = stadium.groupby(\"id_rownb_diff\")[\"id\"].transform(\"count\")\\n    return stadium[stadium.size_of_consecutive_group >= 3][[\"id\",\"visit_date\",\"people\"]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4059330,
                "title": "solution-with-lead-and-lag-on-the-id-column",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy getting a subset with people greater than or equal to 100 people, I can look at the next two id or previous two id to see if they are consecutive. The 1st and 3rd records are straight forward, I only have to look at the previous or next 2 id and see if it is consecutive. The middle record is to check the previous 1 id and next 1 id to see if it is consecutive.\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nwith over100_visit as (\\n    select \\n        a.*,\\n        lag(a.id,1) over (order by a.id) lag_id_1,\\n        lag(a.id,2) over (order by a.id) lag_id_2,\\n        lead(a.id,1) over (order by a.id) lead_id_1,\\n        lead(a.id,2) over (order by a.id) lead_id_2\\n    from stadium a\\n    where people >= 100)\\n\\nselect \\n    id \"id\", \\n    to_char(visit_date, \\'yyyy-mm-dd\\') \"visit_date\", \\n    people \"people\"\\nfrom over100_visit\\nwhere \\n    -- 1st\\n    2 * id - lag_id_1 - lag_id_2 = 3 or \\n    -- 2nd \\n    lead_id_1 - lag_id_1 = 2 or \\n    -- 3rd\\n    lead_id_1 + lead_id_2 - 2 * id = 3\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith over100_visit as (\\n    select \\n        a.*,\\n        lag(a.id,1) over (order by a.id) lag_id_1,\\n        lag(a.id,2) over (order by a.id) lag_id_2,\\n        lead(a.id,1) over (order by a.id) lead_id_1,\\n        lead(a.id,2) over (order by a.id) lead_id_2\\n    from stadium a\\n    where people >= 100)\\n\\nselect \\n    id \"id\", \\n    to_char(visit_date, \\'yyyy-mm-dd\\') \"visit_date\", \\n    people \"people\"\\nfrom over100_visit\\nwhere \\n    -- 1st\\n    2 * id - lag_id_1 - lag_id_2 = 3 or \\n    -- 2nd \\n    lead_id_1 - lag_id_1 = 2 or \\n    -- 3rd\\n    lead_id_1 + lead_id_2 - 2 * id = 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910025,
                "title": "pandas-100-three-lines-using-diff-and-shift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvents with less than $100$ people can be dropped immediately. consecutive triples can be detected using `diff` and `shift`\\n\\n# Approach\\nFirst we remove all events with less than $100$ people and sort by `id`. Next we construct the filter `third` which selects events which are preceded by two consecutive ids. Finally, we have to pick those events that are, indeed, third in a row as well as those that come just before them, and one earlier. The latter two types of events are selected by a shifted filter: `third.shift(-1)` and `third.shift(-2)` respectively.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n \\\\log n)$ due to sorting\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef human_traffic(stadium: pd.DataFrame) -> pd.DataFrame:\\n    stadium = stadium[stadium.people >= 100].sort_values(by=\\'id\\')\\n    third = (stadium.id.diff() == 1)\\\\\\n          & (stadium.id.diff().shift(1) == 1)\\n    return stadium[third | third.shift(-1) | third.shift(-2)]\\n\\n\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef human_traffic(stadium: pd.DataFrame) -> pd.DataFrame:\\n    stadium = stadium[stadium.people >= 100].sort_values(by=\\'id\\')\\n    third = (stadium.id.diff() == 1)\\\\\\n          & (stadium.id.diff().shift(1) == 1)\\n    return stadium[third | third.shift(-1) | third.shift(-2)]\\n\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3095260,
                "title": "mysql-easy-to-understand-solution",
                "content": "```\\nwith new_group as(\\n    select id,visit_date,people,id - row_number() over(order by id) as new\\n    from Stadium\\n    where people >= 100\\n    )\\n    select id,visit_date,people \\n    from new_group\\n    where new in(\\n        select new\\n        from new_group\\n        group by new\\n        having count(id) >= 3\\n        );\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith new_group as(\\n    select id,visit_date,people,id - row_number() over(order by id) as new\\n    from Stadium\\n    where people >= 100\\n    )\\n    select id,visit_date,people \\n    from new_group\\n    where new in(\\n        select new\\n        from new_group\\n        group by new\\n        having count(id) >= 3\\n        );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2892805,
                "title": "using-row-number-and-group-by",
                "content": "```\\r\\nwith filtered as(\\r\\n    select\\r\\n        *\\r\\n        , grp = id - row_number() over(order by visit_date)\\r\\n        -- continuous dates will have same grp\\r\\n    from stadium\\r\\n    where people >= 100\\r\\n)\\r\\n\\r\\nselect id\\r\\n    , visit_date\\r\\n    , people\\r\\nfrom filtered\\r\\nwhere grp in(\\r\\n    select \\r\\n        grp\\r\\n    from filtered\\r\\n    group by grp\\r\\n    having count(1) >= 3\\r\\n)\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\nwith filtered as(\\r\\n    select\\r\\n        *\\r\\n        , grp = id - row_number() over(order by visit_date)\\r\\n        -- continuous dates will have same grp\\r\\n    from stadium\\r\\n    where people >= 100\\r\\n)\\r\\n\\r\\nselect id\\r\\n    , visit_date\\r\\n    , people\\r\\nfrom filtered\\r\\nwhere grp in(\\r\\n    select \\r\\n        grp\\r\\n    from filtered\\r\\n    group by grp\\r\\n    having count(1) >= 3\\r\\n)\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2536077,
                "title": "mssql-using-dense-rank",
                "content": "```\\n;with populationgroups as (\\nselect \\n\\t   min(a.id) as sequencestart,\\n\\t   max(a.id) as sequenceend\\nfrom (\\nselect \\n\\tpeople,\\n\\tid,\\n    id - dense_rank() over(order by visit_date) as ident\\nfrom stadium\\nwhere people >= 100\\n)  a\\ngroup by ident\\nhaving count(1) >= 3\\n)\\n\\nselect id, \\n\\t   visit_date,\\n\\t   people\\nfrom stadium s\\ninner join populationgroups pg on\\n\\ts.id between pg.sequencestart and pg.sequenceend\\n\\n```",
                "solutionTags": [],
                "code": "```\\n;with populationgroups as (\\nselect \\n\\t   min(a.id) as sequencestart,\\n\\t   max(a.id) as sequenceend\\nfrom (\\nselect \\n\\tpeople,\\n\\tid,\\n    id - dense_rank() over(order by visit_date) as ident\\nfrom stadium\\nwhere people >= 100\\n)  a\\ngroup by ident\\nhaving count(1) >= 3\\n)\\n\\nselect id, \\n\\t   visit_date,\\n\\t   people\\nfrom stadium s\\ninner join populationgroups pg on\\n\\ts.id between pg.sequencestart and pg.sequenceend\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489645,
                "title": "solution-with-detail-explanation",
                "content": "Simple to Understand\\n```\\nSELECT DISTINCT a.*  FROM Stadium a JOIN Stadium b JOIN Stadium c \\nON (a.id=b.id-1 AND a.id=c.id-2)  # condition for lowest number\\nOR (a.id=b.id-1 AND a.id=c.id+1)  # condition for middle number\\nOR (a.id=b.id+1 AND a.id=c.id+2)  # condition for largest number\\nWHERE a.people>=100 AND b.people>=100 AND c.people>=100 # condition \\nORDER BY visit_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT a.*  FROM Stadium a JOIN Stadium b JOIN Stadium c \\nON (a.id=b.id-1 AND a.id=c.id-2)  # condition for lowest number\\nOR (a.id=b.id-1 AND a.id=c.id+1)  # condition for middle number\\nOR (a.id=b.id+1 AND a.id=c.id+2)  # condition for largest number\\nWHERE a.people>=100 AND b.people>=100 AND c.people>=100 # condition \\nORDER BY visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2469807,
                "title": "simple-solution-no-joins-only-lead-and-lag-perfectly-works-with-spark-and-databricks",
                "content": "select \\nid,\\nvisit_date,\\npeople\\nfrom\\n(select\\n id,\\nvisit_date,\\n \\n-- Check for previous two rows\\nif(lead(people,1) over(order by visit_date) >= 100 and lead(people,2) over(order by visit_date) >= 100 and people>=100, True, False) as is_valid_1,\\n \\n-- Check for Next two rows\\nif(lag(people,1) over(order by visit_date) >= 100 and lag(people,2) over(order by visit_date) >= 100 and people>=100, True, False) as is_valid_2,\\n \\n-- Check for Previows row and next row\\nif(lag(people,1) over(order by visit_date) >= 100 and lead(people,1) over(order by visit_date) >= 100 and people>=100, True, False) as is_valid_3,\\n \\npeople\\nfrom \\nstadium) as tbl\\nwhere is_valid_1 = True or is_valid_2 = True or is_valid_3 = True",
                "solutionTags": [],
                "code": "select \\nid,\\nvisit_date,\\npeople\\nfrom\\n(select\\n id,\\nvisit_date,\\n \\n-- Check for previous two rows\\nif(lead(people,1) over(order by visit_date) >= 100 and lead(people,2) over(order by visit_date) >= 100 and people>=100, True, False) as is_valid_1,\\n \\n-- Check for Next two rows\\nif(lag(people,1) over(order by visit_date) >= 100 and lag(people,2) over(order by visit_date) >= 100 and people>=100, True, False) as is_valid_2,\\n \\n-- Check for Previows row and next row\\nif(lag(people,1) over(order by visit_date) >= 100 and lead(people,1) over(order by visit_date) >= 100 and people>=100, True, False) as is_valid_3,\\n \\npeople\\nfrom \\nstadium) as tbl\\nwhere is_valid_1 = True or is_valid_2 = True or is_valid_3 = True",
                "codeTag": "Unknown"
            },
            {
                "id": 2365108,
                "title": "95-faster-and-smallest-query",
                "content": "select a.id,a.visit_date,a.people from  (select *,count(b.rn) over (partition by b.rn ) rn2  from (select id , visit_date,people , id-row_number() over(order by id) rn from stadium where people >= 100)b) a where a.rn2 >=3",
                "solutionTags": [],
                "code": "select a.id,a.visit_date,a.people from  (select *,count(b.rn) over (partition by b.rn ) rn2  from (select id , visit_date,people , id-row_number() over(order by id) rn from stadium where people >= 100)b) a where a.rn2 >=3",
                "codeTag": "Unknown"
            },
            {
                "id": 2340157,
                "title": "lag-lead-90-faster-without-join",
                "content": "```\\nselect id, visit_date, people \\nfrom (select id, visit_date, people,\\n     (lead(id,1) over(order by id)) as \\'after1\\',\\n     (lead(id,2) over(order by id)) as \\'after2\\',\\n     (lag(id,1) over(order by id)) as \\'before1\\',\\n     (lag(id,2) over(order by id)) as \\'before2\\'\\n     from stadium where people>=100) p\\nwhere (after1-id=1 and id-before1=1) or\\n    (after2-id=2 and after1-id=1) or \\n    (id-before2=2 and id-before1=1)\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, visit_date, people \\nfrom (select id, visit_date, people,\\n     (lead(id,1) over(order by id)) as \\'after1\\',\\n     (lead(id,2) over(order by id)) as \\'after2\\',\\n     (lag(id,1) over(order by id)) as \\'before1\\',\\n     (lag(id,2) over(order by id)) as \\'before2\\'\\n     from stadium where people>=100) p\\nwhere (after1-id=1 and id-before1=1) or\\n    (after2-id=2 and after1-id=1) or \\n    (id-before2=2 and id-before1=1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329379,
                "title": "simple-mysql-solution-easy-to-understand",
                "content": "```\\nWITH cte1 AS (\\n    SELECT\\n        *,\\n        (\\n            id - ROW_NUMBER() over (\\n                ORDER BY\\n                    visit_date\\n            )\\n        ) AS rnk\\n    FROM\\n        stadium\\n    WHERE\\n        people >= 100\\n),\\ncte2 AS (\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        count(rnk) over(PARTITION by rnk) AS cnt\\n    FROM\\n        cte1\\n)\\nSELECT\\n    id,\\n    visit_date,\\n    people\\nFROM\\n    cte2\\nWHERE\\n    cnt > 2\\nORDER BY\\n    visit_date\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH cte1 AS (\\n    SELECT\\n        *,\\n        (\\n            id - ROW_NUMBER() over (\\n                ORDER BY\\n                    visit_date\\n            )\\n        ) AS rnk\\n    FROM\\n        stadium\\n    WHERE\\n        people >= 100\\n),\\ncte2 AS (\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        count(rnk) over(PARTITION by rnk) AS cnt\\n    FROM\\n        cte1\\n)\\nSELECT\\n    id,\\n    visit_date,\\n    people\\nFROM\\n    cte2\\nWHERE\\n    cnt > 2\\nORDER BY\\n    visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2288540,
                "title": "using-cte-and-lag-and-lead-function-with-explanation",
                "content": "**LAG** and **LEAD** function takes Three arguments:\\n* The element you want to return \\n* **Offset value** which is just an integer that decides from which row the lag and lead functions should work. Default value is 1\\n* A default value if there is no element at the specified offset. You can leave out this argument and it will default to **NULL**\\n\\n**Example:** lead(column_name, 2, 100) -> Starts from 2nd row and if there is null, it will replace it with value 100 . offset and default_value arguments are optional \\n\\n```\\nwith temp as\\n(\\n    select id, visit_date, people, \\n    lead(people) over(order by id) as next1,\\n    lead(people, 2) over(order by id) as next2,\\n    lag(people) over(order by id) as prev1,\\n    lag(people, 2) over(order by id) as prev2\\n    FROM Stadium\\n)\\n\\nselect id, visit_date, people\\nfrom temp\\nwhere (people >= 100 and next1 >= 100 and next2 >= 100) or \\n(people >= 100 and prev1 >= 100 and prev2 >= 100) or\\n(people >= 100 and prev1 >= 100 and next1 >= 100)\\norder by visit_date\\n```\\n\\n* **Condition 1:** To check next 3 consecutive values > 100\\n* **Condition 2:** To check previous 3 consecutive values > 100 [ if we encounter the case of null] \\n* **Condition 3:** To check immediate next and immediate prev values > 100 [ if there are not sufficient columns for our condition 1 and condition 2 ] \\n\\n",
                "solutionTags": [],
                "code": "```\\nwith temp as\\n(\\n    select id, visit_date, people, \\n    lead(people) over(order by id) as next1,\\n    lead(people, 2) over(order by id) as next2,\\n    lag(people) over(order by id) as prev1,\\n    lag(people, 2) over(order by id) as prev2\\n    FROM Stadium\\n)\\n\\nselect id, visit_date, people\\nfrom temp\\nwhere (people >= 100 and next1 >= 100 and next2 >= 100) or \\n(people >= 100 and prev1 >= 100 and prev2 >= 100) or\\n(people >= 100 and prev1 >= 100 and next1 >= 100)\\norder by visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2237875,
                "title": "mysql-faster-than-98-window-function",
                "content": "```\\nwith tab1 as (\\nselect *, id - rank() over(order by id asc) as diff\\nfrom Stadium\\nwhere people >=100\\n), tab2 as (\\nselect *, count(*) over (partition by diff) as cnt from tab1 \\n)\\n\\nselect id, visit_date, people\\nfrom tab2\\nwhere cnt >=3\\n```",
                "solutionTags": [],
                "code": "```\\nwith tab1 as (\\nselect *, id - rank() over(order by id asc) as diff\\nfrom Stadium\\nwhere people >=100\\n), tab2 as (\\nselect *, count(*) over (partition by diff) as cnt from tab1 \\n)\\n\\nselect id, visit_date, people\\nfrom tab2\\nwhere cnt >=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128146,
                "title": "no-window-function-just-union",
                "content": "Select distinct s.id,\\ns.visit_date, s.people\\nfrom Stadium s\\ninner join Stadium s1 on (s.id -1 = S1.id ) and s1.people >=100\\ninner join Stadium s2 on (s.id - 2 = S2.id ) and s2.people >=100\\nwhere s.people>=100\\nUNION\\nSelect distinct s.id,\\ns.visit_date, s.people\\nfrom Stadium s\\ninner join Stadium s1 on (s.id +1 = S1.id ) and s1.people >=100\\ninner join Stadium s2 on (s.id - 1 = S2.id ) and s2.people >=100\\nwhere s.people>=100\\nUNION\\nSelect distinct s.id,\\ns.visit_date, s.people\\nfrom Stadium s\\ninner join Stadium s1 on (s.id +1 = S1.id ) and s1.people >=100\\ninner join Stadium s2 on (s.id + 2 = S2.id ) and s2.people >=100\\nwhere s.people>=100\\norder by visit_date",
                "solutionTags": [],
                "code": "Select distinct s.id,\\ns.visit_date, s.people\\nfrom Stadium s\\ninner join Stadium s1 on (s.id -1 = S1.id ) and s1.people >=100\\ninner join Stadium s2 on (s.id - 2 = S2.id ) and s2.people >=100\\nwhere s.people>=100\\nUNION\\nSelect distinct s.id,\\ns.visit_date, s.people\\nfrom Stadium s\\ninner join Stadium s1 on (s.id +1 = S1.id ) and s1.people >=100\\ninner join Stadium s2 on (s.id - 1 = S2.id ) and s2.people >=100\\nwhere s.people>=100\\nUNION\\nSelect distinct s.id,\\ns.visit_date, s.people\\nfrom Stadium s\\ninner join Stadium s1 on (s.id +1 = S1.id ) and s1.people >=100\\ninner join Stadium s2 on (s.id + 2 = S2.id ) and s2.people >=100\\nwhere s.people>=100\\norder by visit_date",
                "codeTag": "Unknown"
            },
            {
                "id": 2052323,
                "title": "simple-to-understand-solution",
                "content": "select id,visit_date,people from (\\nselect *,lead(id,1) over (order by id) next_1,\\nlead(id,2) over (order by id) next_2,\\nlag(id,1) over (order by id) prev_1,\\nlag(id,2) over (order by id) prev_2 \\nfrom Stadium where people>=100) a \\nwhere (id-1=prev_1 and id+1=next_1) or (id+1=next_1 and id+2=next_2) or (id-2=prev_2 and id-1=prev_1)",
                "solutionTags": [],
                "code": "select id,visit_date,people from (\\nselect *,lead(id,1) over (order by id) next_1,\\nlead(id,2) over (order by id) next_2,\\nlag(id,1) over (order by id) prev_1,\\nlag(id,2) over (order by id) prev_2 \\nfrom Stadium where people>=100) a \\nwhere (id-1=prev_1 and id+1=next_1) or (id+1=next_1 and id+2=next_2) or (id-2=prev_2 and id-1=prev_1)",
                "codeTag": "Unknown"
            },
            {
                "id": 1999160,
                "title": "clear-window-function",
                "content": "```\\nwith temp as (\\n                select\\n                    *,\\n                    id - row_number() over() as ind\\n                from Stadium\\n                where people >= 100),\\n\\ncte as (\\n                select *,\\n                    count(*) over(partition by ind) as total\\n                from temp)\\n\\nselect id, visit_date, people from cte where total >= 3\\n```",
                "solutionTags": [],
                "code": "```\\nwith temp as (\\n                select\\n                    *,\\n                    id - row_number() over() as ind\\n                from Stadium\\n                where people >= 100),\\n\\ncte as (\\n                select *,\\n                    count(*) over(partition by ind) as total\\n                from temp)\\n\\nselect id, visit_date, people from cte where total >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795205,
                "title": "mysql-cte-rank",
                "content": "WITH g100 AS(\\n       SELECT *,\\n                   (id - RANK() OVER (ORDER BY id ASC)) AS diff_\\n      FROM Stadium\\n      WHERE people >= 100\\n)\\n\\nSELECT id, \\nvisit_date, \\npeople\\nFROM g100\\nWHERE diff_ IN (SELECT diff_ FROM g100 GROUP BY diff_ HAVING COUNT(*) >= 3)\\nORDER BY visit_date\\n\\nAlmost all the consecutive problem can be soloved by using RANK()/ROW_NUMBER().\\nThen calculate the differences between it and a column of static(changing) number.",
                "solutionTags": [],
                "code": "WITH g100 AS(\\n       SELECT *,\\n                   (id - RANK() OVER (ORDER BY id ASC)) AS diff_\\n      FROM Stadium\\n      WHERE people >= 100\\n)\\n\\nSELECT id, \\nvisit_date, \\npeople\\nFROM g100\\nWHERE diff_ IN (SELECT diff_ FROM g100 GROUP BY diff_ HAVING COUNT(*) >= 3)\\nORDER BY visit_date\\n\\nAlmost all the consecutive problem can be soloved by using RANK()/ROW_NUMBER().\\nThen calculate the differences between it and a column of static(changing) number.",
                "codeTag": "Unknown"
            },
            {
                "id": 1779434,
                "title": "mysql-window-function-lag-and-lead-easy-to-understand",
                "content": "\\n select x.id,x.visit_date,x.people from (\\n    select \\n    s.id,s.visit_date,s.people,\\n    LEAD(s.id,2)over() as l2_id,\\n    LEAD(s.id,1)over() as l1_id,\\n    LAG(s.id,2)over() as p2_id,\\n    LAG(s.id,1)over() as p1_id\\n    from Stadium as s where s.people>= 100 \\n ) x where (x.l2_id -x.id =2)\\n or (x.id-x.p2_id =2) \\n or(x.l1_id-x.p1_id =2)``",
                "solutionTags": [],
                "code": "\\n select x.id,x.visit_date,x.people from (\\n    select \\n    s.id,s.visit_date,s.people,\\n    LEAD(s.id,2)over() as l2_id,\\n    LEAD(s.id,1)over() as l1_id,\\n    LAG(s.id,2)over() as p2_id,\\n    LAG(s.id,1)over() as p1_id\\n    from Stadium as s where s.people>= 100 \\n ) x where (x.l2_id -x.id =2)\\n or (x.id-x.p2_id =2) \\n or(x.l1_id-x.p1_id =2)``",
                "codeTag": "Unknown"
            },
            {
                "id": 1758724,
                "title": "mysql-easy-understand-window-function",
                "content": "```\\nWITH cte AS\\n    (SELECT *, id - ROW_NUMBER() OVER() AS diff\\n    FROM Stadium\\n    WHERE people >= 100)\\n    \\nSELECT id, visit_date, people\\nFROM cte\\nWHERE diff IN (SELECT diff FROM cte \\n               GROUP BY diff\\n              HAVING COUNT(diff) >= 3)\\nORDER BY visit_date ASC;\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte AS\\n    (SELECT *, id - ROW_NUMBER() OVER() AS diff\\n    FROM Stadium\\n    WHERE people >= 100)\\n    \\nSELECT id, visit_date, people\\nFROM cte\\nWHERE diff IN (SELECT diff FROM cte \\n               GROUP BY diff\\n              HAVING COUNT(diff) >= 3)\\nORDER BY visit_date ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1740148,
                "title": "simple-and-easy-to-understand-mysql-solution-with-union",
                "content": "```\\nwith cte1 as(\\nselect * from stadium\\n    where people >= 100\\n    order by id\\n)\\n\\nselect *  from stadium \\nwhere id in (select id from cte1) and id+1 in (select id from cte1) and id+2 in  (select id from cte1)\\nunion\\nselect * from stadium \\nwhere id in (select id from cte1) and id+1 in (select id from cte1) and id-1 in  (select id from cte1)\\nunion\\nselect *  from stadium \\nwhere id in (select id from cte1) and id-2 in (select id from cte1) and id-1 in  (select id from cte1)\\norder by visit_date\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nwith cte1 as(\\nselect * from stadium\\n    where people >= 100\\n    order by id\\n)\\n\\nselect *  from stadium \\nwhere id in (select id from cte1) and id+1 in (select id from cte1) and id+2 in  (select id from cte1)\\nunion\\nselect * from stadium \\nwhere id in (select id from cte1) and id+1 in (select id from cte1) and id-1 in  (select id from cte1)\\nunion\\nselect *  from stadium \\nwhere id in (select id from cte1) and id-2 in (select id from cte1) and id-1 in  (select id from cte1)\\norder by visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658552,
                "title": "another-general-intuitive-method-without-rank-or-join",
                "content": "```sql\\nwith Stadium_following_big_days as (\\n  select *, \\n    sum(people>=100) over (ROWS between current row and 2 following) s\\n  from Stadium\\n), Stadium_sum_following_big_days as (\\n  select *,\\n    case when sum(s >= 3) over (ROWS 2 preceding) then 1\\n    else 0 end flag\\n  from Stadium_following_big_days\\n)\\n\\nselect id, visit_date, people \\nfrom Stadium_sum_following_big_days\\nwhere flag = 1\\n```\\n\\ntable **Stadium_following_big_days**\\n\\n![image](https://assets.leetcode.com/users/images/94e917eb-f369-420a-8465-6328ab136870_1640964881.1786258.png)\\n\\ntable **Stadium_following_big_days**\\n\\n![image](https://assets.leetcode.com/users/images/65132745-c23b-4508-bb22-bdf1b83ff759_1640964724.9027796.png)\\n",
                "solutionTags": [],
                "code": "```sql\\nwith Stadium_following_big_days as (\\n  select *, \\n    sum(people>=100) over (ROWS between current row and 2 following) s\\n  from Stadium\\n), Stadium_sum_following_big_days as (\\n  select *,\\n    case when sum(s >= 3) over (ROWS 2 preceding) then 1\\n    else 0 end flag\\n  from Stadium_following_big_days\\n)\\n\\nselect id, visit_date, people \\nfrom Stadium_sum_following_big_days\\nwhere flag = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632481,
                "title": "3-simple-steps-general-solution-for-any-number-of-group",
                "content": "```\\nwith data as(\\n    select id, visit_date, id - row_number() over (order by visit_date) rn, people\\n    from stadium\\n    where people >= 100\\n),\\nfilter_tbl as (\\n    select rn \\n    from data\\n    group by rn\\n    having count(*) >=3\\n)\\n\\nselect id, visit_date, people\\nfrom data\\nwhere rn in (select distinct rn from filter_tbl)\\n```",
                "solutionTags": [],
                "code": "```\\nwith data as(\\n    select id, visit_date, id - row_number() over (order by visit_date) rn, people\\n    from stadium\\n    where people >= 100\\n),\\nfilter_tbl as (\\n    select rn \\n    from data\\n    group by rn\\n    having count(*) >=3\\n)\\n\\nselect id, visit_date, people\\nfrom data\\nwhere rn in (select distinct rn from filter_tbl)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1630991,
                "title": "oracle-707-ms",
                "content": "\\'\\'\\'\\nselect id, to_char(visit_date, \\'yyyy-mm-dd\\') as visit_date, people \\nfrom\\n(select id, visit_date, people, lagone, lag(lagone) over (order by id) as lagtwo, leadone, lead(leadone) over (order by id) as leadtwo\\nfrom\\n(select id, visit_date, people, lag(id) over (order by id) as lagone, lead(id) over (order by id) as leadone\\nfrom Stadium\\nwhere people >=100))\\nwhere ((id - lagone) = 1 and (id -lagtwo) = 2) or ((leadone - id = 1) and (leadtwo - id = 2)) or ((id-lagone =1) and (leadone-id = 1))\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "\\'\\'\\'\\nselect id, to_char(visit_date, \\'yyyy-mm-dd\\') as visit_date, people \\nfrom\\n(select id, visit_date, people, lagone, lag(lagone) over (order by id) as lagtwo, leadone, lead(leadone) over (order by id) as leadtwo\\nfrom\\n(select id, visit_date, people, lag(id) over (order by id) as lagone, lead(id) over (order by id) as leadone\\nfrom Stadium\\nwhere people >=100))\\nwhere ((id - lagone) = 1 and (id -lagtwo) = 2) or ((leadone - id = 1) and (leadtwo - id = 2)) or ((id-lagone =1) and (leadone-id = 1))\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1587978,
                "title": "select-from-select-with-lag-and-lead-faster-then-67",
                "content": "SELECT id, visit_date, people\\nFROM \\n(\\n    SELECT id, visit_date, people, \\n    (LAG(people) OVER(ORDER BY id)) AS prev_people, \\n    (LAG(people, 2) OVER(ORDER BY id)) AS prev_prev_people, \\n    (LEAD(people) OVER(ORDER BY id)) AS next_people, \\n    (LEAD(people, 2) OVER(ORDER BY id)) AS next_next_people\\n    FROM Stadium AS s1\\n) s\\nWHERE s.people >= 100 AND ((s.prev_people >= 100 AND s.prev_prev_people >= 100) OR (s.prev_people >= 100 AND s.next_people >= 100) OR (s.next_people >= 100 AND s.next_next_people >= 100))",
                "solutionTags": [],
                "code": "SELECT id, visit_date, people\\nFROM \\n(\\n    SELECT id, visit_date, people, \\n    (LAG(people) OVER(ORDER BY id)) AS prev_people, \\n    (LAG(people, 2) OVER(ORDER BY id)) AS prev_prev_people, \\n    (LEAD(people) OVER(ORDER BY id)) AS next_people, \\n    (LEAD(people, 2) OVER(ORDER BY id)) AS next_next_people\\n    FROM Stadium AS s1\\n) s\\nWHERE s.people >= 100 AND ((s.prev_people >= 100 AND s.prev_prev_people >= 100) OR (s.prev_people >= 100 AND s.next_people >= 100) OR (s.next_people >= 100 AND s.next_next_people >= 100))",
                "codeTag": "Unknown"
            },
            {
                "id": 1529223,
                "title": "mysql-multiple-ctes",
                "content": "`with cte1 as (\\n    select *, row_number() over (order by Id) as \\'row_number\\',\\n    (id - row_number() over (order by Id)) as \\'difference\\'\\n    from Stadium\\n    where people>=100\\n), cte2 as (\\n    select difference, count(difference) as \\'count\\'\\n    from cte1\\n    group by difference\\n), cte3 as (\\n    select distinct difference from cte2\\n    where count >=3\\n)\\n\\nselect id, visit_date, people from cte1\\nwhere difference in (select * from cte3)\\n`",
                "solutionTags": [],
                "code": "`with cte1 as (\\n    select *, row_number() over (order by Id) as \\'row_number\\',\\n    (id - row_number() over (order by Id)) as \\'difference\\'\\n    from Stadium\\n    where people>=100\\n), cte2 as (\\n    select difference, count(difference) as \\'count\\'\\n    from cte1\\n    group by difference\\n), cte3 as (\\n    select distinct difference from cte2\\n    where count >=3\\n)\\n\\nselect id, visit_date, people from cte1\\nwhere difference in (select * from cte3)\\n`",
                "codeTag": "Unknown"
            },
            {
                "id": 1514026,
                "title": "simple-mysql-solution",
                "content": "```\\nwith cte as(\\nselect id, visit_date, people,\\nid-row_number()over(order by visit_date) as diff\\nfrom stadium\\nwhere people>=100\\n)\\n\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by 1 having count(*)>=3)\\ngroup by 1,2,3\\norder by id\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte as(\\nselect id, visit_date, people,\\nid-row_number()over(order by visit_date) as diff\\nfrom stadium\\nwhere people>=100\\n)\\n\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by 1 having count(*)>=3)\\ngroup by 1,2,3\\norder by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1498641,
                "title": "mysql-solution-using-exists",
                "content": "```\\nwith gt100 as (\\n    select * from Stadium \\n    where people >= 100\\n)\\nselect * from gt100 s\\nwhere \\n    (exists(select 1 from gt100 s1 where s1.id = s.id + 1) and exists(select 1 from gt100 s2 where s2.id = s.id + 2))\\n    or\\n    (exists(select 1 from gt100 s1 where s1.id = s.id - 1) and exists(select 1 from gt100 s2 where s2.id = s.id + 1))\\n    or\\n    (exists(select 1 from gt100 s1 where s1.id = s.id - 1) and exists(select 1 from gt100 s2 where s2.id = s.id - 2))\\norder by id\\n```",
                "solutionTags": [],
                "code": "```\\nwith gt100 as (\\n    select * from Stadium \\n    where people >= 100\\n)\\nselect * from gt100 s\\nwhere \\n    (exists(select 1 from gt100 s1 where s1.id = s.id + 1) and exists(select 1 from gt100 s2 where s2.id = s.id + 2))\\n    or\\n    (exists(select 1 from gt100 s1 where s1.id = s.id - 1) and exists(select 1 from gt100 s2 where s2.id = s.id + 1))\\n    or\\n    (exists(select 1 from gt100 s1 where s1.id = s.id - 1) and exists(select 1 from gt100 s2 where s2.id = s.id - 2))\\norder by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459571,
                "title": "simple-oracle-solution",
                "content": "This Oracle SQL solution takes 650ms to execute.\\n```\\nSELECT\\n    s.id as \"id\",\\n    to_char(s.visit_date,\\'YYYY-MM-DD\\') AS \"visit_date\",\\n    s.people as \"people\"\\nFROM Stadium s\\nWHERE s.people >=100 AND\\n     ( CASE \\n            WHEN \\n                (select people from stadium where id = s.id-1) >=100\\n                and (select people from stadium where id = s.id+1) >=100\\n            THEN 1\\n      \\n            WHEN (select people from stadium where id = s.id+1)>=100\\n                and (select people from stadium where id = s.id+2)>=100\\n            THEN 1\\n      \\n            WHEN (select people from stadium where id = s.id-1) >=100\\n                and (select people from stadium where id = s.id-2)>=100\\n            THEN 1\\n            ELSE 0\\n        END) = 1\\n            \\n;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    s.id as \"id\",\\n    to_char(s.visit_date,\\'YYYY-MM-DD\\') AS \"visit_date\",\\n    s.people as \"people\"\\nFROM Stadium s\\nWHERE s.people >=100 AND\\n     ( CASE \\n            WHEN \\n                (select people from stadium where id = s.id-1) >=100\\n                and (select people from stadium where id = s.id+1) >=100\\n            THEN 1\\n      \\n            WHEN (select people from stadium where id = s.id+1)>=100\\n                and (select people from stadium where id = s.id+2)>=100\\n            THEN 1\\n      \\n            WHEN (select people from stadium where id = s.id-1) >=100\\n                and (select people from stadium where id = s.id-2)>=100\\n            THEN 1\\n            ELSE 0\\n        END) = 1\\n            \\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401639,
                "title": "simple-window-func",
                "content": "```\\nselect id, visit_date, people\\nfrom\\n    (select id, visit_date, people,\\n            count(id) over(partition by diff) num\\n    from\\n        (select id, visit_date, people,\\n                id - row_number() over(order by id) diff\\n        from Stadium\\n        where people >= 100) a \\n    ) a \\nwhere num>=3 \\norder by visit_date\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, visit_date, people\\nfrom\\n    (select id, visit_date, people,\\n            count(id) over(partition by diff) num\\n    from\\n        (select id, visit_date, people,\\n                id - row_number() over(order by id) diff\\n        from Stadium\\n        where people >= 100) a \\n    ) a \\nwhere num>=3 \\norder by visit_date\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1371139,
                "title": "fast-than-78-in-mysql",
                "content": "Key points:\\n1. use LEAD(), LAG() to check if a id is continuous;\\n2. use IFNULL to sovle the null bool value problem. if  expression contain null, the boll value is null. \\nFor example: \\n\\t\\t\\t\\t\\tINPUT: SELECT (1+1 = NULL); OUTPUT: NULL\\n\\t\\t\\t\\t\\tINPUT: SELECT (1+NULL = 1); OUTPUT: NULL\\n\\nWITH tem AS(\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        LEAD(id, 1) OVER(ORDER BY id) AS N1,\\n        LEAD(id, 2) OVER(ORDER BY id) AS N2,\\n        LAG(id, 1) OVER(ORDER BY id) AS P1,\\n        LAG(id, 2) OVER(ORDER BY id) AS P2\\n    FROM\\n        Stadium\\n    WHERE\\n        people >= 100\\n)\\n    SELECT \\n        id,\\n        visit_date,\\n        people\\n    FROM\\n        tem\\n    WHERE\\n        IFNULL((id + 1 = N1),0) + IFNULL((id + 2 = N2),0) + \\n        IFNULL((id - 1 = P1),0) + IFNULL((id - 2 = P2),0) >= 2\\n    ORDER BY\\n        visit_date",
                "solutionTags": [],
                "code": "Key points:\\n1. use LEAD(), LAG() to check if a id is continuous;\\n2. use IFNULL to sovle the null bool value problem. if  expression contain null, the boll value is null. \\nFor example: \\n\\t\\t\\t\\t\\tINPUT: SELECT (1+1 = NULL); OUTPUT: NULL\\n\\t\\t\\t\\t\\tINPUT: SELECT (1+NULL = 1); OUTPUT: NULL\\n\\nWITH tem AS(\\n    SELECT\\n        id,\\n        visit_date,\\n        people,\\n        LEAD(id, 1) OVER(ORDER BY id) AS N1,\\n        LEAD(id, 2) OVER(ORDER BY id) AS N2,\\n        LAG(id, 1) OVER(ORDER BY id) AS P1,\\n        LAG(id, 2) OVER(ORDER BY id) AS P2\\n    FROM\\n        Stadium\\n    WHERE\\n        people >= 100\\n)\\n    SELECT \\n        id,\\n        visit_date,\\n        people\\n    FROM\\n        tem\\n    WHERE\\n        IFNULL((id + 1 = N1),0) + IFNULL((id + 2 = N2),0) + \\n        IFNULL((id - 1 = P1),0) + IFNULL((id - 2 = P2),0) >= 2\\n    ORDER BY\\n        visit_date",
                "codeTag": "Unknown"
            },
            {
                "id": 1365113,
                "title": "using-cte-and-row-number",
                "content": "```\\nWITH A AS (\\n        SELECT ID, VISIT_DATE, PEOPLE, ID-ROW_NUMBER() OVER (ORDER BY ID) AS NUM \\n        FROM STADIUM \\n        WHERE PEOPLE>=100 ) \\n        \\nSELECT \\n\\tID, VISIT_DATE, PEOPLE \\nFROM \\n\\tA \\nINNER JOIN (\\n\\t\\t\\tSELECT NUM FROM A \\n\\t\\t\\tGROUP BY NUM\\n\\t\\t\\tHAVING COUNT(NUM) >=3 ) B ON A.NUM=B.NUM\\nORDER BY \\n\\tVISIT_DATE\\n",
                "solutionTags": [],
                "code": "```\\nWITH A AS (\\n        SELECT ID, VISIT_DATE, PEOPLE, ID-ROW_NUMBER() OVER (ORDER BY ID) AS NUM \\n        FROM STADIUM \\n        WHERE PEOPLE>=100 ) \\n        \\nSELECT \\n\\tID, VISIT_DATE, PEOPLE \\nFROM \\n\\tA \\nINNER JOIN (\\n\\t\\t\\tSELECT NUM FROM A \\n\\t\\t\\tGROUP BY NUM\\n\\t\\t\\tHAVING COUNT(NUM) >=3 ) B ON A.NUM=B.NUM\\nORDER BY \\n\\tVISIT_DATE\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1344337,
                "title": "simple-ms-sql-solution-faster-than-100",
                "content": "```\\nselect id, visit_date, people from\\n(select *, COUNT(*) OVER (Partition by group_num) group_count from\\n(select *, id-rank as group_num from \\n(select *, rank() OVER (order by visit_date) as rank\\n    from Stadium\\n    where people >= 100) x) y) z\\n    where group_count >= 3\\n    order by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, visit_date, people from\\n(select *, COUNT(*) OVER (Partition by group_num) group_count from\\n(select *, id-rank as group_num from \\n(select *, rank() OVER (order by visit_date) as rank\\n    from Stadium\\n    where people >= 100) x) y) z\\n    where group_count >= 3\\n    order by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1334262,
                "title": "lead-lag-where-clause",
                "content": "select id,visit_date,people from (\\nselect id,to_char(visit_date,\\'YYYY-MM-DD\\') as visit_date ,\\npeople ,\\nlead(people,1,0) over (order by id) as lead_1,\\nlead(people,2,0) over (order by id) as lead_2,\\nlag(people,1,0) over (order by id) as lag_1,\\nlag(people,2,0) over (order by id) as lag_2\\nfrom Stadium ) \\nwhere \\n(people>=100  and lead_2>=100 and lead_1>=100) or \\n(people>=100  and lag_2>=100 and lag_1>=100) or \\n(people>=100  and lead_1>=100 and lag_1>=100) \\norder by visit_date asc",
                "solutionTags": [],
                "code": "select id,visit_date,people from (\\nselect id,to_char(visit_date,\\'YYYY-MM-DD\\') as visit_date ,\\npeople ,\\nlead(people,1,0) over (order by id) as lead_1,\\nlead(people,2,0) over (order by id) as lead_2,\\nlag(people,1,0) over (order by id) as lag_1,\\nlag(people,2,0) over (order by id) as lag_2\\nfrom Stadium ) \\nwhere \\n(people>=100  and lead_2>=100 and lead_1>=100) or \\n(people>=100  and lag_2>=100 and lag_1>=100) or \\n(people>=100  and lead_1>=100 and lag_1>=100) \\norder by visit_date asc",
                "codeTag": "Unknown"
            },
            {
                "id": 1326814,
                "title": "mysql-simple-window-function",
                "content": "select id , visit_date , people  from \\n(select * , \\nlead(people) over(order by id) sec,\\nlead(people,2) over(order by id) third,\\nlag(people,2) over(order by id) up_third ,\\nlag(people) over(order by id) up_sec from Stadium ) a\\nwhere \\n(people>=100 and sec >=100 and third >=100 ) or \\n(people>=100 and up_third >=100 and up_sec >=100) or \\n(people>=100 and sec >=100 and up_sec >=100)\\norder by 2",
                "solutionTags": [],
                "code": "select id , visit_date , people  from \\n(select * , \\nlead(people) over(order by id) sec,\\nlead(people,2) over(order by id) third,\\nlag(people,2) over(order by id) up_third ,\\nlag(people) over(order by id) up_sec from Stadium ) a\\nwhere \\n(people>=100 and sec >=100 and third >=100 ) or \\n(people>=100 and up_third >=100 and up_sec >=100) or \\n(people>=100 and sec >=100 and up_sec >=100)\\norder by 2",
                "codeTag": "Unknown"
            },
            {
                "id": 1317940,
                "title": "deriving-the-most-optimal-method-98-percentile-speed",
                "content": "I was looking at all the interesting solutions posted in this thread and I wanted to see what the optimal one would be, so I ran some speed tests on the various options posted and attempted to derive a minimalized function. \\n\\nMost of the options actually performed relatively similarly, and I would need to do a lot more testing to be able to determine anything conclusively (I ran 5-10 tests per option).\\n\\nHere are the  takeaways:\\n\\n- CTE method seems to be the most common and has decent performance\\n- Using ```id-row_number() over(order by id asc) grp``` to create group IDs which can be counted\\n- Using an INNER JOIN on the CTE instead of an IN statement to select the final result\\n\\nHere is the minimal version with CTE. This performs relatively well and is easy to understand.\\n\\n```\\nWITH mydata as (\\nSELECT *, id-row_number() over(order by id asc) grp\\n    FROM stadium\\n    WHERE people>=100\\n)\\n\\nSELECT s.id, s.visit_date, s.people from mydata s\\n    INNER JOIN (\\n    SELECT grp FROM mydata GROUP BY grp HAVING COUNT(*) >= 3\\n    ) m ON s.grp=m.grp\\n    \\n```\\n\\nThe other methods posted, which ended up being slower than the recommended solution, but are interesting non the less:\\n\\n- Using LEFT JOINs to explicitly connect to the previous and following consecutive elemements. This is nice but not scalable to a wider range of days. It is also rather slow performing.\\n- Using UNIONs to join several SELECT statements, one for each day in a consecutive serises (first day, middle day, last day). This was  he second fastest performing method. However, as the first one, it is hard to scale this for larger ranges of data (more than 3 consecutive days)\\n\\n**AND THE WINNER IS:**\\nThe best performing method was using LAG and LEAD functions (see @haotong comment from 6/22/21)\\n```\\nwith a as (\\n    select *, \\n            lag(people,1) over () as people_lag_1, \\n            lag(people,2) over () as people_lag_2,\\n            lead(people,1) over () as people_lead_1,\\n            lead(people,2) over () as people_lead_2\\n    from stadium\\n)\\nselect id, visit_date, people\\nfrom a \\nwhere (people >= 100 and people_lag_1 >= 100 and people_lag_2 >= 100)\\n   or (people >= 100 and people_lag_1 >= 100 and people_lead_1 >= 100)\\n   or (people >= 100 and people_lead_1 >= 100 and people_lead_2 >= 100)\\norder by 2\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```id-row_number() over(order by id asc) grp```\n```\\nWITH mydata as (\\nSELECT *, id-row_number() over(order by id asc) grp\\n    FROM stadium\\n    WHERE people>=100\\n)\\n\\nSELECT s.id, s.visit_date, s.people from mydata s\\n    INNER JOIN (\\n    SELECT grp FROM mydata GROUP BY grp HAVING COUNT(*) >= 3\\n    ) m ON s.grp=m.grp\\n    \\n```\n```\\nwith a as (\\n    select *, \\n            lag(people,1) over () as people_lag_1, \\n            lag(people,2) over () as people_lag_2,\\n            lead(people,1) over () as people_lead_1,\\n            lead(people,2) over () as people_lead_2\\n    from stadium\\n)\\nselect id, visit_date, people\\nfrom a \\nwhere (people >= 100 and people_lag_1 >= 100 and people_lag_2 >= 100)\\n   or (people >= 100 and people_lag_1 >= 100 and people_lead_1 >= 100)\\n   or (people >= 100 and people_lead_1 >= 100 and people_lead_2 >= 100)\\norder by 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1290662,
                "title": "253-ms-faster-than-95-68-of-mysql-cte-window-function-group-by",
                "content": "```\\nwith cte as (\\n    select\\n        id,\\n        visit_date,\\n        people,\\n\\t\\t-- create a grouping for consecutive ids\\n        id - row_number() over(order by id) grp\\n    from\\n        stadium \\n    -- where condition is evaluated before window function, thus separate groups of consecutive ids\\n\\twhere\\n        people >= 100\\n    )\\n\\nselect\\n    id,\\n    visit_date,\\n    people\\nfrom\\n cte\\n -- we select only ids from groups with more than 3 counts\\nwhere grp in (\\n    select \\n        grp\\n    from \\n        cte\\n    group by\\n        grp\\n    having\\n        count(*) >=3\\n    )\\norder by \\n    visit_date\\n```\\n",
                "solutionTags": [],
                "code": "```\\nwith cte as (\\n    select\\n        id,\\n        visit_date,\\n        people,\\n\\t\\t-- create a grouping for consecutive ids\\n        id - row_number() over(order by id) grp\\n    from\\n        stadium \\n    -- where condition is evaluated before window function, thus separate groups of consecutive ids\\n\\twhere\\n        people >= 100\\n    )\\n\\nselect\\n    id,\\n    visit_date,\\n    people\\nfrom\\n cte\\n -- we select only ids from groups with more than 3 counts\\nwhere grp in (\\n    select \\n        grp\\n    from \\n        cte\\n    group by\\n        grp\\n    having\\n        count(*) >=3\\n    )\\norder by \\n    visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1288537,
                "title": "mysql-lag-lead",
                "content": "```\\nwith a as (\\n    select *, \\n            lag(people,1) over () as people_lag_1, \\n            lag(people,2) over () as people_lag_2,\\n            lead(people,1) over () as people_lead_1,\\n            lead(people,2) over () as people_lead_2\\n    from stadium\\n)\\nselect id, visit_date, people\\nfrom a \\nwhere (people >= 100 and people_lag_1 >= 100 and people_lag_2 >= 100)\\n   or (people >= 100 and people_lag_1 >= 100 and people_lead_1 >= 100)\\n   or (people >= 100 and people_lead_1 >= 100 and people_lead_2 >= 100)\\norder by 2\\n```",
                "solutionTags": [],
                "code": "```\\nwith a as (\\n    select *, \\n            lag(people,1) over () as people_lag_1, \\n            lag(people,2) over () as people_lag_2,\\n            lead(people,1) over () as people_lead_1,\\n            lead(people,2) over () as people_lead_2\\n    from stadium\\n)\\nselect id, visit_date, people\\nfrom a \\nwhere (people >= 100 and people_lag_1 >= 100 and people_lag_2 >= 100)\\n   or (people >= 100 and people_lag_1 >= 100 and people_lead_1 >= 100)\\n   or (people >= 100 and people_lead_1 >= 100 and people_lead_2 >= 100)\\norder by 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275318,
                "title": "lag-and-lead",
                "content": "```\\n# Write your MySQL query statement below\\nwith temp as (\\n    select\\n        id\\n        , visit_date\\n        , people\\n        , lag (id) over() as previous_id\\n        , lag (id, 2) over() as two_prev_id\\n        , lead (id, 1) over() as next_id\\n        , lead (id, 2) over() as two_next_id\\n\\n    from\\n        Stadium\\n    where\\n        people>=100\\n)\\n\\nselect \\n    id\\n    , visit_date\\n    , people \\nfrom \\n    temp\\nwhere \\n    id = (next_id + previous_id)/2\\n    or id= 2*previous_id - two_prev_id\\n    or id= 2*next_id - two_next_id\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith temp as (\\n    select\\n        id\\n        , visit_date\\n        , people\\n        , lag (id) over() as previous_id\\n        , lag (id, 2) over() as two_prev_id\\n        , lead (id, 1) over() as next_id\\n        , lead (id, 2) over() as two_next_id\\n\\n    from\\n        Stadium\\n    where\\n        people>=100\\n)\\n\\nselect \\n    id\\n    , visit_date\\n    , people \\nfrom \\n    temp\\nwhere \\n    id = (next_id + previous_id)/2\\n    or id= 2*previous_id - two_prev_id\\n    or id= 2*next_id - two_next_id\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1263911,
                "title": "mysql-using-simple-lead-and-lag-with-window-function",
                "content": "```\\nselect id,visit_date,people from\\n(select id,visit_date,people,\\nlead(people,1,0) over(order by visit_date) as two,\\nlead(people,2,0 ) over(order by visit_date) as three,\\nlag(people,1,0) over(order by visit_date) as four,\\nlag(people,2,0 ) over(order by visit_date) as five\\nfrom stadium)a \\nwhere (a.people>=100 AND a.two>=100 AND a.three>=100) \\nOR \\n(a.people>=100 AND a.four>=100 AND a.five>=100) \\nOR \\n(a.people>=100 AND a.two>=100 AND a.four>=100) ;\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,visit_date,people from\\n(select id,visit_date,people,\\nlead(people,1,0) over(order by visit_date) as two,\\nlead(people,2,0 ) over(order by visit_date) as three,\\nlag(people,1,0) over(order by visit_date) as four,\\nlag(people,2,0 ) over(order by visit_date) as five\\nfrom stadium)a \\nwhere (a.people>=100 AND a.two>=100 AND a.three>=100) \\nOR \\n(a.people>=100 AND a.four>=100 AND a.five>=100) \\nOR \\n(a.people>=100 AND a.two>=100 AND a.four>=100) ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1262121,
                "title": "mssql-solution-without-using-cartesian-product",
                "content": "```\\nselect distinct\\n\\ta.id, a.visit_date, a.people\\nfrom stadium a\\njoin (\\n\\t\\tselect id as start, ld as ed\\n\\t\\tfrom (\\n\\t\\t\\t\\tselect id, visit_date, lead(id,2) over(order by id) as ld\\n\\t\\t\\t\\tfrom stadium\\n\\t\\t\\t\\twhere people >= 100\\n\\t\\t\\t\\t) a\\n\\t\\twhere ld - id = 2 ) b\\n on\\n\\t a.id >= b.start and a.id <= b.ed\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct\\n\\ta.id, a.visit_date, a.people\\nfrom stadium a\\njoin (\\n\\t\\tselect id as start, ld as ed\\n\\t\\tfrom (\\n\\t\\t\\t\\tselect id, visit_date, lead(id,2) over(order by id) as ld\\n\\t\\t\\t\\tfrom stadium\\n\\t\\t\\t\\twhere people >= 100\\n\\t\\t\\t\\t) a\\n\\t\\twhere ld - id = 2 ) b\\n on\\n\\t a.id >= b.start and a.id <= b.ed\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1257429,
                "title": "ms-sql-with-explanation",
                "content": "```\\n/* create a new column id_row_diff to record the difference of row number and id for further selecting out consecutive ids. The rationale behind this\\uFF1B if ids are concecutive, the parewise difference between the id and its conresponding row number(rankded based on id) will be the same among these ids. */\\nwith cte as\\n(\\nselect s.*,(id - row_number()over(order by id asc) )as id_row_diff\\nfrom stadium s\\nwhere people >= 100 \\n )\\n\\n\\nselect id,visit_date,people\\nfrom(\\nselect id,visit_date,people,count(*)over(partition by id_row_diff) as con_c \\nfrom cte\\n    ) itm\\nwhere con_c >=3 \\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* create a new column id_row_diff to record the difference of row number and id for further selecting out consecutive ids. The rationale behind this\\uFF1B if ids are concecutive, the parewise difference between the id and its conresponding row number(rankded based on id) will be the same among these ids. */\\nwith cte as\\n(\\nselect s.*,(id - row_number()over(order by id asc) )as id_row_diff\\nfrom stadium s\\nwhere people >= 100 \\n )\\n\\n\\nselect id,visit_date,people\\nfrom(\\nselect id,visit_date,people,count(*)over(partition by id_row_diff) as con_c \\nfrom cte\\n    ) itm\\nwhere con_c >=3 \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240936,
                "title": "mysql-very-simple-solution-with-window-function-island-and-gap-question",
                "content": "```\\nwith T as (\\n    select \\n        *,\\n        id - row_number() over(order by id asc) as id_group\\n    from Stadium \\n    where people >=100\\n)\\nselect \\n    id,\\n    visit_date,\\n    people\\nfrom T \\nwhere id_group in (select id_group from T group by id_group having count(*) >=3 )\\n\\n```",
                "solutionTags": [],
                "code": "```\\nwith T as (\\n    select \\n        *,\\n        id - row_number() over(order by id asc) as id_group\\n    from Stadium \\n    where people >=100\\n)\\nselect \\n    id,\\n    visit_date,\\n    people\\nfrom T \\nwhere id_group in (select id_group from T group by id_group having count(*) >=3 )\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222317,
                "title": "mysql-window-function-1-table-call-no-subqueries-no-distinct-clause",
                "content": "```\\nselect id, visit_date, people\\nfrom (select *,\\n        lag(people, 1)  over (order by id) as past1,\\n        lag(people, 2)  over (order by id) as past2,\\n        lead(people, 1) over (order by id) as next1,\\n        lead(people, 2) over (order by id) as next2\\n      from Stadium) as lag_lead\\nwhere (past2 >= 100  and past1 >= 100  and people >= 100) or \\n      (past1 >= 100  and people >= 100 and next1 >= 100)  or \\n      (people >= 100 and next1 >= 100  and next2 >= 100)\\norder by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, visit_date, people\\nfrom (select *,\\n        lag(people, 1)  over (order by id) as past1,\\n        lag(people, 2)  over (order by id) as past2,\\n        lead(people, 1) over (order by id) as next1,\\n        lead(people, 2) over (order by id) as next2\\n      from Stadium) as lag_lead\\nwhere (past2 >= 100  and past1 >= 100  and people >= 100) or \\n      (past1 >= 100  and people >= 100 and next1 >= 100)  or \\n      (people >= 100 and next1 >= 100  and next2 >= 100)\\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1217281,
                "title": "super-intuitive-and-simple-solution-using-ranking",
                "content": "```\\n# Idea is that the difference will be the same within groups of consecutive dates\\n# and different between groups of consecutive/non-consecutive dates.\\n# First filter out records with too few people, then rank the remaining rows.\\n# Difference = id - rank\\n# id  rank    difference\\n# 2   1       1\\n# 3   2       1\\n# 5   3       2\\n# 6   4       2\\n# 7   5       2\\n# 8   6       2\\n\\nwith rank_diff as (\\n    select\\n        *,\\n        rank() over (order by id asc) as `rank`,\\n        id - rank() over (order by id asc) as difference\\n    from\\n        stadium\\n    where\\n        people >= 100\\n),\\n\\ndiff_counts as (\\n    select\\n        difference,\\n        count(*) as count\\n    from\\n        rank_diff\\n    group by\\n        difference\\n)\\n\\nselect\\n    id,\\n    visit_date,\\n    people\\nfrom\\n    rank_diff\\nwhere\\n    difference in (select difference from diff_counts where count >= 3)\\norder by\\n    visit_date asc\\n```",
                "solutionTags": [],
                "code": "```\\n# Idea is that the difference will be the same within groups of consecutive dates\\n# and different between groups of consecutive/non-consecutive dates.\\n# First filter out records with too few people, then rank the remaining rows.\\n# Difference = id - rank\\n# id  rank    difference\\n# 2   1       1\\n# 3   2       1\\n# 5   3       2\\n# 6   4       2\\n# 7   5       2\\n# 8   6       2\\n\\nwith rank_diff as (\\n    select\\n        *,\\n        rank() over (order by id asc) as `rank`,\\n        id - rank() over (order by id asc) as difference\\n    from\\n        stadium\\n    where\\n        people >= 100\\n),\\n\\ndiff_counts as (\\n    select\\n        difference,\\n        count(*) as count\\n    from\\n        rank_diff\\n    group by\\n        difference\\n)\\n\\nselect\\n    id,\\n    visit_date,\\n    people\\nfrom\\n    rank_diff\\nwhere\\n    difference in (select difference from diff_counts where count >= 3)\\norder by\\n    visit_date asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1199579,
                "title": "window-function-lead-lag",
                "content": "STEP 1. use lag() to get no.  of visitors for yesterday and the day before yesterday;\\nSTEP 2. use lead() to derive no. of visitors for tomorrow and the day after tomorrow.\\nSTEP 3. screening criteria in WHERE clause: any three consecutive days satisfy the condition that no. of visitors >= 100. That could be (the day before yesterday, yesterday, today) OR (yesterday, today, tmr) OR (today, tmr, the day after tomorrow)\\n\\n```\\nSELECT id, visit_date, people FROM\\n(SELECT id, visit_date, \\nlag(people, 2, 0) over(order by visit_date) as yday2, \\nlag(people, 1, 0) over(order by visit_date) as yday, \\npeople,\\nlead(people, 1, 0) over(order by visit_date) as tmr,\\nlead(people, 2, 0) over(order by visit_date) as tmr2\\nFROM Stadium) v\\nWHERE (v.yday2>=100 AND v.yday>=100 AND people>=100) OR\\n(yday>=100 AND v.people>=100 AND v.tmr>=100) OR\\n(v.people>=100 AND v.tmr>=100 AND v.tmr2>=100)\\nORDER BY visit_date\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id, visit_date, people FROM\\n(SELECT id, visit_date, \\nlag(people, 2, 0) over(order by visit_date) as yday2, \\nlag(people, 1, 0) over(order by visit_date) as yday, \\npeople,\\nlead(people, 1, 0) over(order by visit_date) as tmr,\\nlead(people, 2, 0) over(order by visit_date) as tmr2\\nFROM Stadium) v\\nWHERE (v.yday2>=100 AND v.yday>=100 AND people>=100) OR\\n(yday>=100 AND v.people>=100 AND v.tmr>=100) OR\\n(v.people>=100 AND v.tmr>=100 AND v.tmr2>=100)\\nORDER BY visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181152,
                "title": "very-simple-solution-only-use-union",
                "content": "```\\n\\nselect s1.id,s1.visit_date, s1.people from Stadium s1, Stadium s2,Stadium s3\\nwhere \\ns1.people >=100 \\nand s2.people >=100 \\nand s3.people >=100\\nand  s1.id-s2.id=1\\nand s1.id-s3.id=2\\nunion\\nselect s1.id,s1.visit_date, s1.people from Stadium s1, Stadium s2,Stadium s3\\nwhere \\ns1.people >=100 \\nand s2.people >=100 \\nand s3.people >=100\\nand  s2.id-s1.id=1\\nand s1.id-s3.id=1\\nunion\\nselect s1.id,s1.visit_date, s1.people from Stadium s1, Stadium s2,Stadium s3\\nwhere \\ns1.people >=100 \\nand s2.people >=100 \\nand s3.people >=100\\nand  s2.id-s1.id=2\\nand s3.id-s1.id=1\\n```",
                "solutionTags": [],
                "code": "```\\n\\nselect s1.id,s1.visit_date, s1.people from Stadium s1, Stadium s2,Stadium s3\\nwhere \\ns1.people >=100 \\nand s2.people >=100 \\nand s3.people >=100\\nand  s1.id-s2.id=1\\nand s1.id-s3.id=2\\nunion\\nselect s1.id,s1.visit_date, s1.people from Stadium s1, Stadium s2,Stadium s3\\nwhere \\ns1.people >=100 \\nand s2.people >=100 \\nand s3.people >=100\\nand  s2.id-s1.id=1\\nand s1.id-s3.id=1\\nunion\\nselect s1.id,s1.visit_date, s1.people from Stadium s1, Stadium s2,Stadium s3\\nwhere \\ns1.people >=100 \\nand s2.people >=100 \\nand s3.people >=100\\nand  s2.id-s1.id=2\\nand s3.id-s1.id=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1170438,
                "title": "one-pass-with-lead-and-lag",
                "content": "```\\nselect id ,visit_date,people from (\\nselect id ,visit_date,people,lead(id,1) over (order by id )  id1, lead( id,2) over(order by id ) id2 ,lag(id,1) over (order by id )  idb1, lag( id,2) over(order by id ) idb2  from \\n(\\nselect id ,visit_date , people from Stadium where people>=100\\n) St_flt \\n    \\n    ) std_rst where \\'y\\' = case when (id1 = id+1 and id2= id+2) then \\'y\\'\\n                               when (  idb1= id-1 and id1 = id+1  ) then \\'y\\'\\n                               when ( idb2=id-2 and idb1=id-1 ) then  \\'y\\'\\n                               else \\'n\\' end\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nselect id ,visit_date,people from (\\nselect id ,visit_date,people,lead(id,1) over (order by id )  id1, lead( id,2) over(order by id ) id2 ,lag(id,1) over (order by id )  idb1, lag( id,2) over(order by id ) idb2  from \\n(\\nselect id ,visit_date , people from Stadium where people>=100\\n) St_flt \\n    \\n    ) std_rst where \\'y\\' = case when (id1 = id+1 and id2= id+2) then \\'y\\'\\n                               when (  idb1= id-1 and id1 = id+1  ) then \\'y\\'\\n                               when ( idb2=id-2 and idb1=id-1 ) then  \\'y\\'\\n                               else \\'n\\' end\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165610,
                "title": "easy-to-understand-mysql-solution",
                "content": "```\\nwith cte1  as (\\nselect id, visit_date, people,\\nid - row_number() over(order by id) rk from stadium where people>=100)\\n\\nselect id, visit_date, people  from cte1 where rk in (select rk from cte1 group by rk having count(1)>=3) order by id \\n```\\nCte1 creates a rank group that is unique for each consecutive >=100 row in the table.\\ne.g.\\n\\n```\\nId        People   rk\\n 1         120      0\\n 2         130      0\\n 3          90      ignored\\n 4         250      1\\n 5         100      1\\n 6         150      1  ==> this rank group has >=3 rows with the same rk \\n 7          39      ignored\\n 8         101      2\\n \\n```\\nWhenever the rank\\u2019s count is greater than or equal to 3, we know that the partition has more than three >=100 rows consecutively.",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```\\nwith cte1  as (\\nselect id, visit_date, people,\\nid - row_number() over(order by id) rk from stadium where people>=100)\\n\\nselect id, visit_date, people  from cte1 where rk in (select rk from cte1 group by rk having count(1)>=3) order by id \\n```\n```\\nId        People   rk\\n 1         120      0\\n 2         130      0\\n 3          90      ignored\\n 4         250      1\\n 5         100      1\\n 6         150      1  ==> this rank group has >=3 rows with the same rk \\n 7          39      ignored\\n 8         101      2\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163486,
                "title": "short-cte-and-subquery-with-explanation",
                "content": "\\n\\t# Table 1 is all the visits with >= 100 people\\n\\twith t1 as (select * from stadium where people >= 100)\\n           \\n           select * from t1 where \\n\\t\\t   (id + 1 in (select id from t1) and id+2 in (select id from t1))\\n           or\\n           (id - 1 in (select id from t1) and id - 2 in (select id from t1))\\n           or\\n\\t\\t   # This condition searches for the visits in the middle of the consecutive visits\\n           (id + 1 in (select id from t1) and id - 1 in (select id from t1))\\n           order by visit_date;",
                "solutionTags": [],
                "code": "\\n\\t# Table 1 is all the visits with >= 100 people\\n\\twith t1 as (select * from stadium where people >= 100)\\n           \\n           select * from t1 where \\n\\t\\t   (id + 1 in (select id from t1) and id+2 in (select id from t1))\\n           or\\n           (id - 1 in (select id from t1) and id - 2 in (select id from t1))\\n           or\\n\\t\\t   # This condition searches for the visits in the middle of the consecutive visits\\n           (id + 1 in (select id from t1) and id - 1 in (select id from t1))\\n           order by visit_date;",
                "codeTag": "Unknown"
            },
            {
                "id": 1080292,
                "title": "mssql-solution-for-n-consecutive-days-faster-than-70",
                "content": "The following solution can scale to N consecutive elements.\\n\\nWe start identifying the registers that fulfill the condition:\\n\\n``\\nselect id, visit_date, people, case when people >= 100 then 1 else 0 end as applies \\nfrom stadium\\n``\\n\\nThen we identify the inflection point so we can group the consecutive rows\\n``\\nselect id, visit_date, people, applies, \\n        coalesce(lag(applies,1) over(order by visit_date),0) as previous\\n        from(\\n            select id, visit_date, people, case when people >= 100 then 1 else 0 end as applies\\n            from stadium\\n        )a\\n``\\n\\nLater, we group the consecutives so we will know when a record belongs to a group with N or more consecutive registers that fullfill the constraint.\\n``\\nwith aux(id, visit_date, people,grp) as(\\n    select id, visit_date, people, \\n    sum(case when applies != previous then 1 else 0 end) over(order by visit_date) as grp\\n    from(\\n        select id, visit_date, people, applies, \\n        coalesce(lag(applies,1) over(order by visit_date),0) as previous\\n        from(\\n            select id, visit_date, people, case when people >= 100 then 1 else 0 end as applies\\n            from stadium\\n        )a\\n    )b \\n)\\n``\\n\\nWith the previous information we can identify those groups and join with itself to select the records belonging to those.\\n\\n``\\nwith aux(id, visit_date, people,grp) as(\\n    select id, visit_date, people, \\n    sum(case when applies != previous then 1 else 0 end) over(order by visit_date) as grp\\n    from(\\n        select id, visit_date, people, applies, \\n        coalesce(lag(applies,1) over(order by visit_date),0) as previous\\n        from(\\n            select id, visit_date, people, case when people >= 100 then 1 else 0 end as applies\\n            from stadium\\n        )a\\n    )b \\n)\\nselect a.id,a.visit_date,a.people \\nfrom (\\n    select grp, count(grp) as countGroup \\n    from aux \\n    group by grp\\n)x\\njoin aux a on a.grp=x.grp and x.countGroup >= 3\\norder by a.visit_date\\n``",
                "solutionTags": [],
                "code": "The following solution can scale to N consecutive elements.\\n\\nWe start identifying the registers that fulfill the condition:\\n\\n``\\nselect id, visit_date, people, case when people >= 100 then 1 else 0 end as applies \\nfrom stadium\\n``\\n\\nThen we identify the inflection point so we can group the consecutive rows\\n``\\nselect id, visit_date, people, applies, \\n        coalesce(lag(applies,1) over(order by visit_date),0) as previous\\n        from(\\n            select id, visit_date, people, case when people >= 100 then 1 else 0 end as applies\\n            from stadium\\n        )a\\n``\\n\\nLater, we group the consecutives so we will know when a record belongs to a group with N or more consecutive registers that fullfill the constraint.\\n``\\nwith aux(id, visit_date, people,grp) as(\\n    select id, visit_date, people, \\n    sum(case when applies != previous then 1 else 0 end) over(order by visit_date) as grp\\n    from(\\n        select id, visit_date, people, applies, \\n        coalesce(lag(applies,1) over(order by visit_date),0) as previous\\n        from(\\n            select id, visit_date, people, case when people >= 100 then 1 else 0 end as applies\\n            from stadium\\n        )a\\n    )b \\n)\\n``\\n\\nWith the previous information we can identify those groups and join with itself to select the records belonging to those.\\n\\n``\\nwith aux(id, visit_date, people,grp) as(\\n    select id, visit_date, people, \\n    sum(case when applies != previous then 1 else 0 end) over(order by visit_date) as grp\\n    from(\\n        select id, visit_date, people, applies, \\n        coalesce(lag(applies,1) over(order by visit_date),0) as previous\\n        from(\\n            select id, visit_date, people, case when people >= 100 then 1 else 0 end as applies\\n            from stadium\\n        )a\\n    )b \\n)\\nselect a.id,a.visit_date,a.people \\nfrom (\\n    select grp, count(grp) as countGroup \\n    from aux \\n    group by grp\\n)x\\njoin aux a on a.grp=x.grp and x.countGroup >= 3\\norder by a.visit_date\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1075926,
                "title": "very-simple-and-easy-solution-using-windows-functions",
                "content": "```\\nWITH tmp as (\\n# Have to pass 2 dummy values at the end to work on edge cases of having valid rows at the end to ensure proper working of WINDOWS functions\\nselect id, visit_date, people from stadium \\nUNION \\nselect max(id) + 1, \\'9999-12-30\\', 0 from stadium \\nUNION \\nselect max(id) + 2, \\'9999-12-31\\', 0 from stadium     \\n)\\n#Compare each row with there preceding or following rows and verify if min(people) among these groups are greater than 100\\nselect id, visit_date, people \\nfrom (\\nselect id, visit_date, people,\\n       CASE WHEN min(people) OVER(ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) >= 100 THEN \\'YES\\'   #If current row + 2 following rows have all >100\\n\\t\\t\\tWHEN min(people) OVER(ORDER BY id ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) >= 100 THEN \\'YES\\'   #If current row, 1 previous & following rows have all >100\\n\\t\\t\\tWHEN min(people) OVER(ORDER BY id ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) >= 100 THEN \\'YES\\'   #If current row + 2 previous rows have all >100\\n            ELSE \\'NO\\'\\n       END as condition_check\\nfrom tmp        \\n    ) t \\nwhere condition_check = \\'YES\\'\\nORDER BY 2\\n```",
                "solutionTags": [],
                "code": "```\\nWITH tmp as (\\n# Have to pass 2 dummy values at the end to work on edge cases of having valid rows at the end to ensure proper working of WINDOWS functions\\nselect id, visit_date, people from stadium \\nUNION \\nselect max(id) + 1, \\'9999-12-30\\', 0 from stadium \\nUNION \\nselect max(id) + 2, \\'9999-12-31\\', 0 from stadium     \\n)\\n#Compare each row with there preceding or following rows and verify if min(people) among these groups are greater than 100\\nselect id, visit_date, people \\nfrom (\\nselect id, visit_date, people,\\n       CASE WHEN min(people) OVER(ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) >= 100 THEN \\'YES\\'   #If current row + 2 following rows have all >100\\n\\t\\t\\tWHEN min(people) OVER(ORDER BY id ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) >= 100 THEN \\'YES\\'   #If current row, 1 previous & following rows have all >100\\n\\t\\t\\tWHEN min(people) OVER(ORDER BY id ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) >= 100 THEN \\'YES\\'   #If current row + 2 previous rows have all >100\\n            ELSE \\'NO\\'\\n       END as condition_check\\nfrom tmp        \\n    ) t \\nwhere condition_check = \\'YES\\'\\nORDER BY 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1066168,
                "title": "mysql-cte-row-number-explanation-understandable-reference",
                "content": "Reference article link:\\nhttps://www.mssqltips.com/sqlservertip/4207/sql-server-tsql-code-to-return-consecutive-values-over-a-certain-value/\\n\\n **1st step**, filter the table with number of people equal or more than 100, order the new table by *id* in ascending way, then put the *gaps bw old ID and the new ID* into new column - \"gaps\". \\nBasically, ROW_NUMBER function adds unique incrementing order to the table based on the *order by* content. \\n\\n**2nd step**, count the times that same gaps appeared consecutively, *partition by* the gaps. Illustration with picture is more clear:\\n\\n##### ![image](https://assets.leetcode.com/users/images/8c20a592-78c1-47da-8711-85468d9dab64_1613359910.333453.png)\\n\\n\\n**3rd step**, so the last puzzle here is to find within those groups that share the same value of \"gaps\", how many are more than 3.\\n\\nThe complete coding is below:\\n```\\nwith cons_dates as \\n( select *, id - ROW_NUMBER() over (order by id) as gaps\\n  from  Stadium s1\\n  where people >= \\'100\\'\\n),\\ncnt_new as \\n(select *, count(*) over (partition by gaps) as cnt_same_ids\\n  from cons_dates\\n)\\n\\nselect id, visit_date, people\\nfrom cnt_new\\nwhere cnt_same_ids >= 3\\n```",
                "solutionTags": [],
                "code": "```\\nwith cons_dates as \\n( select *, id - ROW_NUMBER() over (order by id) as gaps\\n  from  Stadium s1\\n  where people >= \\'100\\'\\n),\\ncnt_new as \\n(select *, count(*) over (partition by gaps) as cnt_same_ids\\n  from cons_dates\\n)\\n\\nselect id, visit_date, people\\nfrom cnt_new\\nwhere cnt_same_ids >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045887,
                "title": "using-lead-lag-functions-mysql",
                "content": "\\n```\\nselect id, visit_date, people\\nFrom\\n(select \\n    *\\n    ,lead(id,1) over (order by id asc) as next_id\\n    ,lead(id,2) over (order by id asc) as next_id2\\n    ,lag(id,1) over (order by id asc) as prev_id\\n    ,lag(id,2) over (order by id asc) as prev_id2\\nfrom\\n    stadium where people >= 100\\norder by id asc) as a\\nwhere \\n    (next_id = id + 1 and next_id2 = id + 2)\\n    or (next_id = id + 1 and prev_id = id - 1)\\n    or (prev_id = id - 1 and prev_id2 = id -2)\\n```\\n\\nfirst filter out every record where visiters < 100\\nthen with everything from table plus the next 2 ids and prev 2 ids, write logic to only pull in records that are part of a 3-sequential id series.",
                "solutionTags": [],
                "code": "```\\nselect id, visit_date, people\\nFrom\\n(select \\n    *\\n    ,lead(id,1) over (order by id asc) as next_id\\n    ,lead(id,2) over (order by id asc) as next_id2\\n    ,lag(id,1) over (order by id asc) as prev_id\\n    ,lag(id,2) over (order by id asc) as prev_id2\\nfrom\\n    stadium where people >= 100\\norder by id asc) as a\\nwhere \\n    (next_id = id + 1 and next_id2 = id + 2)\\n    or (next_id = id + 1 and prev_id = id - 1)\\n    or (prev_id = id - 1 and prev_id2 = id -2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1030401,
                "title": "mysql-case-lag-and-lead",
                "content": "```\\n WITH flag as\\n(select id,visit_date,people,\\ncase \\n when people >=100 \\n \\n and \\n (\\n (LEAD(people,1) over(order by id) >=100 \\n and LEAD(people,2) over(order by id) >=100)\\n  or\\n  (LAG(people,1) over(order by id) >=100 \\n  and LAG(people,2) over(order by id) >=100)\\n  or\\n\\n  (LAG(people,1) over(order by id) >=100 \\n  and LEAD(people,1) over(order by id) >=100)\\n  )\\n then 1\\n else 0\\n end gt100_flag\\n \\n from Stadium\\n)\\n\\nselect id,visit_date,people\\nfrom flag\\nwhere gt100_flag=1 \\n```",
                "solutionTags": [],
                "code": "```\\n WITH flag as\\n(select id,visit_date,people,\\ncase \\n when people >=100 \\n \\n and \\n (\\n (LEAD(people,1) over(order by id) >=100 \\n and LEAD(people,2) over(order by id) >=100)\\n  or\\n  (LAG(people,1) over(order by id) >=100 \\n  and LAG(people,2) over(order by id) >=100)\\n  or\\n\\n  (LAG(people,1) over(order by id) >=100 \\n  and LEAD(people,1) over(order by id) >=100)\\n  )\\n then 1\\n else 0\\n end gt100_flag\\n \\n from Stadium\\n)\\n\\nselect id,visit_date,people\\nfrom flag\\nwhere gt100_flag=1 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022408,
                "title": "faster-than-73-88-of-oracle-online-submissions-for-human-traffic-of-stadium",
                "content": "select id, to_char(visit_date, \\'YYYY-MM-DD\\') as visit_date, people from \\n(\\nselect \\nid , \\nvisit_date,\\npeople , \\nlag(people) over (order by id) as one_behind,\\nlag(people,2) over (order by id) as two_behind,\\nlead(people) over (order by id) as one_after,\\nlead(people,2) over (order by id) as two_after\\nfrom Stadium\\n) test \\nwhere\\npeople >= 100 and \\n(\\n(one_behind >= 100 and two_behind >= 100)\\nOR\\n(one_after >= 100 and two_after >= 100)\\nOR\\n(one_behind >= 100 and one_after >= 100)\\n)\\n\\norder by visit_date",
                "solutionTags": [],
                "code": "select id, to_char(visit_date, \\'YYYY-MM-DD\\') as visit_date, people from \\n(\\nselect \\nid , \\nvisit_date,\\npeople , \\nlag(people) over (order by id) as one_behind,\\nlag(people,2) over (order by id) as two_behind,\\nlead(people) over (order by id) as one_after,\\nlead(people,2) over (order by id) as two_after\\nfrom Stadium\\n) test \\nwhere\\npeople >= 100 and \\n(\\n(one_behind >= 100 and two_behind >= 100)\\nOR\\n(one_after >= 100 and two_after >= 100)\\nOR\\n(one_behind >= 100 and one_after >= 100)\\n)\\n\\norder by visit_date",
                "codeTag": "Unknown"
            },
            {
                "id": 988429,
                "title": "simple-and-easy",
                "content": "```\\nSelect id, visit_date, people\\nFrom Stadium\\nWhere people > 99 And ((id-1 in (Select id\\n                                    From stadium\\n                                    Where people > 99)\\n                         And id+1 in (Select id\\n                                    From stadium\\n                                    Where people > 99))\\n                        Or (id+1 in (Select id\\n                                    From stadium\\n                                    Where people > 99)\\n                         And id+2 in (Select id\\n                                    From stadium\\n                                    Where people > 99))\\n                        Or (id-1 in (Select id\\n                                    From stadium\\n                                    Where people > 99)\\n                         And id-2 in (Select id\\n                                    From stadium\\n                                    Where people > 99)))\\nOrder By visit_date ASC\\n```",
                "solutionTags": [],
                "code": "```\\nSelect id, visit_date, people\\nFrom Stadium\\nWhere people > 99 And ((id-1 in (Select id\\n                                    From stadium\\n                                    Where people > 99)\\n                         And id+1 in (Select id\\n                                    From stadium\\n                                    Where people > 99))\\n                        Or (id+1 in (Select id\\n                                    From stadium\\n                                    Where people > 99)\\n                         And id+2 in (Select id\\n                                    From stadium\\n                                    Where people > 99))\\n                        Or (id-1 in (Select id\\n                                    From stadium\\n                                    Where people > 99)\\n                         And id-2 in (Select id\\n                                    From stadium\\n                                    Where people > 99)))\\nOrder By visit_date ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 987713,
                "title": "using-lead-and-lag",
                "content": "select id, to_char(visit_date,\\'YYYY-MM-DD\\') as  visit_date ,people from ( select id,people, lag(people,1)over(order by visit_date ) data, lag(people,2)over(order by visit_date ) data1,visit_date  ,lead(people,1)over(order by visit_date ) data2, lead(people,2)over(order by visit_date ) data3 from Stadium)  where (people >=100 and data>=100 and data1 >=100) or (people>=100 and data2>=100 and data3 >=100) or (people>=100 and data>=100 and data2 >=100);",
                "solutionTags": [],
                "code": "select id, to_char(visit_date,\\'YYYY-MM-DD\\') as  visit_date ,people from ( select id,people, lag(people,1)over(order by visit_date ) data, lag(people,2)over(order by visit_date ) data1,visit_date  ,lead(people,1)over(order by visit_date ) data2, lead(people,2)over(order by visit_date ) data3 from Stadium)  where (people >=100 and data>=100 and data1 >=100) or (people>=100 and data2>=100 and data3 >=100) or (people>=100 and data>=100 and data2 >=100);",
                "codeTag": "Unknown"
            },
            {
                "id": 972641,
                "title": "95-faster-and-100-memory-simple-using-window-functions",
                "content": "Algorithm:\\nConsecutive 3 rows can be formed in any of the below 3 scenarios. So, Lets check if a row meets any of the below 3 scenarios:\\n1. Current_row followed by 2 rows are consecutive.\\n2. Current_row precedid by 2 rows are consecutive.\\n3. Current row precedid by 1 row and followed by 1 row.\\n\\n```\\nselect id,visit_date,people\\nfrom\\n(\\n Select \\n     ID,\\n     Visit_Date,\\n     People,\\n     count(*) over( order by id range between current row and 2 following ) Following_cnt,\\n     count(*) over( order by id range between 2 preceding and current row ) Preceding_cnt,\\n     count(*) over( order by id range between 1 preceding and 1 following ) Current_Count\\n From \\n     (\\n         Select ID,Visit_Date,People \\n         from Stadium  \\n         where People >= 100\\n     ) z\\n)ZZ   where Following_cnt =3 or Preceding_cnt =3 or Current_Count = 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,visit_date,people\\nfrom\\n(\\n Select \\n     ID,\\n     Visit_Date,\\n     People,\\n     count(*) over( order by id range between current row and 2 following ) Following_cnt,\\n     count(*) over( order by id range between 2 preceding and current row ) Preceding_cnt,\\n     count(*) over( order by id range between 1 preceding and 1 following ) Current_Count\\n From \\n     (\\n         Select ID,Visit_Date,People \\n         from Stadium  \\n         where People >= 100\\n     ) z\\n)ZZ   where Following_cnt =3 or Preceding_cnt =3 or Current_Count = 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 949683,
                "title": "video-explanation",
                "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/N-j5nu7cyPg](https://youtu.be/N-j5nu7cyPg)\\n\\nHere\\u2019s the code I\\u2019m going through for this problem:\\n\\n```\\nSELECT DISTINCT s1.*\\nFROM Stadium s1 JOIN Stadium s2 JOIN Stadium s3\\nON (s1.id = s2.id-1 AND s1.id = s3.id-2) OR\\n(s1.id = s2.id+1 AND s1.id = s3.id-1) OR\\n(s1.id = s2.id+1 AND s1.id = s3.id+2)\\nWHERE s1.people >= 100 AND s2.people >= 100 AND s3.people >= 100\\nORDER BY visit_date\\n```\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT s1.*\\nFROM Stadium s1 JOIN Stadium s2 JOIN Stadium s3\\nON (s1.id = s2.id-1 AND s1.id = s3.id-2) OR\\n(s1.id = s2.id+1 AND s1.id = s3.id-1) OR\\n(s1.id = s2.id+1 AND s1.id = s3.id+2)\\nWHERE s1.people >= 100 AND s2.people >= 100 AND s3.people >= 100\\nORDER BY visit_date\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945308,
                "title": "solution-without-join",
                "content": "```\\nselect distinct s.*\\nfrom Stadium s, \\n(select ss.id \\n from Stadium ss, Stadium s1, Stadium s2\\n where ss.id = s1.id - 1 and s1.id = s2.id - 1\\nand ss.people >= 100 and s1.people >= 100 and s2.people >= 100)t\\nwhere s.id between t.id and t.id + 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct s.*\\nfrom Stadium s, \\n(select ss.id \\n from Stadium ss, Stadium s1, Stadium s2\\n where ss.id = s1.id - 1 and s1.id = s2.id - 1\\nand ss.people >= 100 and s1.people >= 100 and s2.people >= 100)t\\nwhere s.id between t.id and t.id + 2\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565356,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570541,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1566094,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1567597,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1568378,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570923,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570496,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570378,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570233,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1662938,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1565356,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570541,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1566094,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1567597,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1568378,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570923,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570496,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570378,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1570233,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1662938,
                "content": [
                    {
                        "username": "mariachi",
                        "content": "I want to avoid looking at anyone\\'s solution before trying it myself, but I don\\'t understand the problem as written. What is meant by 3 consecutive rows? All rows are distinct as far as I can see."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "most basic solution: \\n# Write your MySQL query statement below\\n\\nselect distinct s1.id, s1.visit_date, s1.people\\nfrom stadium s1, stadium s2, stadium s3\\nwhere ((s1.id = s2.id - 1 and s1.id = s3.id -2) or (s1.id = s2.id - 1 and s1.id = s3.id + 1) or (s1.id = s2.id +1 and s1.id = s3.id +2)) and s1.people >= 100 and s2.people >= 100 and s3.people >=100\\norder by id asc"
                    },
                    {
                        "username": "anastasiia-in-bi",
                        "content": "first you need to exclude all the rows if there are less than 100 people --> some of the ids will be missing and now you need to display the records with three or more rows with consecutive id\\'s"
                    },
                    {
                        "username": "ZwShenNo1rich",
                        "content": "\\twith t as\\n\\t(select *,  id - row_number()over(order by id asc) as rnk\\n\\tfrom stadium\\n\\twhere people >= 100)\\n\\tselect id, visit_date, people\\n\\tfrom t\\n\\twhere rnk in(select rnk from t group by rnk having count(*)>=3) -- replace 3 with any n\\n\\t"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Thank you your solution is good"
                    },
                    {
                        "username": "owenljn",
                        "content": "There's a bug in testcase, one of your testcase has wrong answer as follows:\\n\\n![0_1517868173845_testcase.png](/assets/uploads/files/1517868175512-testcase.png) \\n\\nas you can see in this picture, id from 28 to 30 are not consecutive dates so they should not be included or the date for id 30 should be changed to \"2017-05-30\""
                    },
                    {
                        "username": "musaalamdarali429",
                        "content": "not required date consecutive its required only ID consecutive as mention in question \"Write an SQL query to display the records with three or more rows with consecutive id\\'s\""
                    },
                    {
                        "username": "tanliangwei",
                        "content": "\\nWITH check_consecutive AS \\n(SELECT ROW_NUMBER() OVER(ORDER BY id) AS rownumber, id, visit_date, people \\nFROM Stadium\\nWHERE people >= 100)\\n\\nSELECT id, visit_date, people \\nFROM check_consecutive\\nWHERE id-rownumber IN\\n(SELECT (id - rownumber)\\nFROM check_consecutive\\nGROUP BY (id - rownumber)\\nHAVING COUNT(*) >= 3);"
                    },
                    {
                        "username": "hero4future",
                        "content": "[@moushmidas](/moushmidas) in a table of more than 100 attendance, difference between id and row number that have the occurrence more than 3 points to consecutive days\\nconsecutive rows means days following each other (not 2 days or more apart)"
                    },
                    {
                        "username": "moushmidas",
                        "content": "Why   we are doing  -->  id-rownumber ? and what is means by consecutive rows ?"
                    },
                    {
                        "username": "Vamshidharreddy532",
                        "content": "with cte as (\\nselect id,visit_date,\\nlag(people, 2) over (order by id) as previousday2,\\nlag(people, 1) over (order by id) as previousday1,\\npeople,\\nlead(people, 1) over (order by id) as nextday1,\\nlead(people, 2) over (order by id) as nextday2\\nfrom stadium\\n)\\n\\nselect id, visit_date, people \\nfrom cte\\nwhere people >=100\\nand ((nextday1>=100 and nextday2 >=100) or (previousday1>=100 and previousday2 >=100) or (previousday1>=100 and nextday1 >=100) )"
                    },
                    {
                        "username": "sourabhch-98",
                        "content": "WITH cte1\\nAS\\n(SELECT *, id - row_number() over(ORDER BY id) AS grp FROM Stadium WHERE people >= 100),\\ncte2\\nAS\\n(SELECT *, COUNT(grp) over(partition by grp) AS cnt FROM cte1\\n)\\nSELECT id, visit_date, people FROM cte2 WHERE cnt>=3 ORDER BY visit_date;"
                    },
                    {
                        "username": "zkxzyx",
                        "content": "...\\nwith cte as (\\nselect * ,id-row_number() over(order by id asc) grp\\n    from Stadium\\n    where people>=100\\n)\\nselect id   , visit_date , people  from cte where grp in (select grp from cte group by grp having count(*)>=3)\\n..."
                    },
                    {
                        "username": "user1264hn",
                        "content": "\\nwith cte as(select *, id - (row_number() over (order by id)) as diff from Stadium where people >= 100)\\nselect id, visit_date, people\\nfrom cte\\nwhere diff in (select diff from cte group by diff having count(diff) >=3)\\norder by id\\n"
                    },
                    {
                        "username": "ah-sadek",
                        "content": "# Write your MySQL query statement below\\nSELECT a.id, a.visit_date,a.people\\nFROM\\n(SELECT *, \\n LAG(id) OVER (ORDER BY id ASC) AS prev_id,\\n  LAG(id,2) OVER (ORDER BY id ASC) AS prev_id_2,\\n LEAD(id) OVER (ORDER BY id ASC) AS next_id,\\n  LEAD(id,2) OVER (ORDER BY id ASC) AS next_id_2\\nFROM Stadium\\nWHERE people >= 100) a \\nWHERE \\n(a.id - prev_id = 1 AND id - prev_id_2 =2)\\nOR\\n(id - prev_id = 1 AND next_id - id =1)\\nOR \\n(next_id - id =1 AND next_id_2 - id = 2 )\\n\\n\\n"
                    },
                    {
                        "username": "Ankit_Deswal",
                        "content": "WITH CTE \\nAS\\n(SELECT *,\\nid-ROW_NUMBER() OVER (ORDER BY id) AS DIFF\\nFROM Stadium\\nWHERE people >= 100)\\nSELECT \\nid, visit_date, people\\nFROM CTE\\nWHERE DIFF IN (SELECT DIFF FROM CTE GROUP BY DIFF HAVING COUNT(1) >= 3)"
                    }
                ]
            },
            {
                "id": 1576830,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1576359,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1575954,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1575726,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1575064,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1574971,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1574378,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1574099,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1573808,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1573779,
                "content": [
                    {
                        "username": "HermanChenTaiwan",
                        "content": "\\'\\'\\'\\nwith cte as\\n\\n(select id, visit_date, people,\\n\\nid - row_number() over(ORDER BY id) as diff\\n \\nFROM Stadium\\n\\nwhere people >= 100),\\n\\ncte2 as\\n\\n(select id, visit_date, people,\\n\\ncount(*) over(partition by diff) as ans\\n\\nFROM cte)\\n\\nselect id, visit_date, people\\n\\nfrom cte2\\n\\nwhere ans >= 3\\n\\'\\'\\'"
                    },
                    {
                        "username": "apoorvagupta",
                        "content": "# todays date and next day is more than 100 and and two days after is more than 100\\n# if todayS and previous day and todays and next day more than 100\\n# if today and previous day and today and two days previous more than 100\\nselect id,\\nvisit_date,\\npeople from(\\nselect\\nid,\\nvisit_date,\\npeople,\\n(case when people>=100 and lead(people,1) over(order by id)>=100 and lead(people,2) over(order by id)>=100 then 1\\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lead(people,1) over(order by id)>=100 then 1 \\nwhen people>=100 and lag(people,1) over(order by id)>=100 and lag(people,2) over(order by id)>=100 then 1 \\nelse 0 end)flag\\nfrom stadium) x\\nwhere x.flag=1 order by visit_date"
                    },
                    {
                        "username": "whats_up_eric",
                        "content": "with t1 as\\n(select id, visit_date, people, \\nrow_number() over(order by id) as rownumber\\nfrom stadium\\nwhere people >= 100),\\nt2 as(\\nselect id, visit_date, people, count(id) over(partition by id-rownumber) as count\\nfrom t1)\\nselect id, visit_date, people\\nfrom t2\\nwhere count >=3;"
                    },
                    {
                        "username": "xukaiwen95",
                        "content": "with calvin as\\n(select *, id - row_number() over (order by visit_date) as ind\\nfrom Stadium \\nwhere people >= 100)\\n\\n\\nselect b.id, b.visit_date, b.people\\nfrom calvin b\\nwhere b.ind in\\n(select a.ind\\nfrom calvin a\\ngroup by 1\\nhaving count(1) >= 3)"
                    },
                    {
                        "username": "techiechintan",
                        "content": "I used row_num function to order the records by visit_date in order to ensure consecutiveness, while also filtering for people>=100. Subtracting this row_num from corresponding id gave me a constant, which I used to count rows using partition by (in this case >=3). \\nHere\\'s the query :\\n\\nSELECT id, visit_date, people FROM (\\nSELECT id, visit_date, people, count(*) OVER (PARTITION BY DIFF) as ct from\\n    (SELECT id, visit_date, people, (id-row_number() over (order by visit_date)) as diff\\n    from stadium\\n    where people>=100) x) y where ct>=3"
                    },
                    {
                        "username": "ssingh24",
                        "content": "One of the things I see in almost all the solutions is that they cater particularly to this problem i.e. 3 or more consecutive ids. \\nIn case one needs to change this condition(*which btw is a very common industry requirement*), it requires major change in query and hence is not easily scaleable. \\nBelow solution takes care of the scalability issue :\\n\\'\\'\\'\\nwith c1 as (\\n\\tSelect *, row_number() over (order by id)rn  from stadium where people >= 100\\n\\t),\\n\\tc2 as (\\n\\tselect *, id - rn rnk from c1 \\n\\t),\\n\\tc3 as (\\n\\tSelect rnk, count(1) cnt from c2 group by rnk having count(1) > 2\\n\\t)\\n\\tselect b.id, b.visit_date, b.people from c3 a join c2 b on a.rnk = b.rnk order by b.id\\n\\'\\'\\'\\n\\nWould love if someone can help me refine this in performance terms.\\n\\nThanks!"
                    },
                    {
                        "username": "user5011Bw",
                        "content": "with tmp as(\\nselect *, row_number() over(order by id) as rn\\nfrom stadium where people >= 100\\n), tmp2 as(\\nselect *, count( *) over(partition by (id - rn)) as ct\\nfrom tmp\\n)\\nselect id, visit_date, people\\nfrom tmp2 where ct >= 3"
                    },
                    {
                        "username": "sravanan",
                        "content": "with tmp_count_100 as(\\nselect *\\n, lag(people) over(order by id) lag_\\n, lead(people) over(order by id) lead_ from stadium)\\n\\nselect distinct s.* from tmp_count_100 t \\njoin stadium s on t.id >= s.id -1 and t.id <= s.id +1\\nwhere t.people >= 100 and lag_ >= 100 and lead_ >=100;\\n"
                    },
                    {
                        "username": "asusundevilmsba2020",
                        "content": "\\'\\'\\'\\nselect a.id,a.visit_date, a.people from \\n(select id,visit_date,people,lead(people,1) over (order by visit_date) lead_num1,lead(people,2) over (order by visit_date) lead_num2,lag(people,1) over (order by visit_date) lag_num1, lag(people,2) over (order by visit_date) lag_num2   from stadium) a\\nwhere (a.people >= 100 and a.lead_num1 >= 100 and a.lead_num2 >= 100) or (a.people>= 100 and a.lead_num1 >= 100 and a.lag_num1 >= 100) or (a.people >= 100 and a.lag_num1 >= 100 and a.lag_num2 >= 100)\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "chauhansumit",
                        "content": "Same value of id-Row_Number means consecutive rows. Now if we do rownumber again partitoned by this diff  in increasing and decreasing order of id and add the two we will get count of cosecutive rows +1 for each row without aggregation\\n\\n\\nSELECT id,visit_date,people FROM (\\nSELECT ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id desc) + ROW_NUMBER() OVER(PARTITION BY RowID ORDER BY id) -1 AS CNT, * FROM (\\nselect id - ROW_NUMBER() OVER (ORDER BY ID) RowId, * from stadium where people >=100)T)T1 WHERE CNT>=3"
                    }
                ]
            },
            {
                "id": 1573551,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 1573545,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 1573529,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 1572703,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 1572398,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 1572366,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 2063647,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 2021886,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 1964923,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            },
            {
                "id": 1945265,
                "content": [
                    {
                        "username": "bababava",
                        "content": "The final goal is to find consecutive dates which meet the condition of people>100.\\nI got an interesting idea inspired by Mathematical Difference Method\\uFF1A\\n\\nFor example, the table stadium:\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\n1. We can find all the dates which does not meet the condition  We get\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 4    | 2017-01-04 | 99        |\\n\\n2. All the ID(less than 100) combine  a sequence .For the sake of computing ,add zero row and an additional last row \\u3002\\nid   |\\n+------\\n| 0    | we add\\n| 1    | \\n| 4    | \\n| 9    | we add\\n+------+------------+-----------+\\n\\n3. Caculate the difference value between the each sequence\\n+------\\n| 1    | 1-0\\n| 3    | 4-1\\n| 5    | 9-4\\n+------+------------+-----------+ \\n4. Find the difference value which is more than 3\\n+------\\n| 5    | 9-4\\n+------+------------+-----------+ \\n5. Now we have found the boundary\\n\\n id between 4 and 9(inclusive) also known as (5,6,7,8)\\n \\n6. Got all the data between the boundaries job done.\\n\\n+------+------------+-----------+\\n| id   | visit_date | people    |\\n+------+------------+-----------+\\n| 1    | 2017-01-01 | 10        |\\n| 2    | 2017-01-02 | 109       |\\n| 3    | 2017-01-03 | 150       |\\n| 4    | 2017-01-04 | 99        |\\n(5,6,7,8) is the right answser\\n| 5    | 2017-01-05 | 145       |\\n| 6    | 2017-01-06 | 1455      |\\n| 7    | 2017-01-07 | 199       |\\n| 8    | 2017-01-08 | 188       |\\n+------+------------+-----------+\\n\\npotential bugs\\uFF1AIf the dates is not consecutive the method of step 2 need to be optimized\\u3002"
                    },
                    {
                        "username": "DannnnnyZhu",
                        "content": "/* Write your T-SQL query statement below */\\nWITH TABLE1 AS(\\nSELECT *, \\nLAG(people, 2) OVER(ORDER BY visit_date ASC) AS P1, \\nLAG(people, 1) OVER(ORDER BY visit_date ASC) AS P2,\\nLEAD(people, 1) OVER(ORDER BY visit_date ASC) AS P3,\\nLEAD(people, 2) OVER(ORDER BY visit_date ASC) AS P4\\nFROM stadium\\n)\\nSELECT id, visit_date, people\\nFROM TABLE1\\nWHERE people >= 100 AND ((P1 >= 100 AND P2 >= 100) \\n                         OR (P3 >= 100 AND P4 >= 100) \\n                         OR (P2 >= 100 AND P3 >= 100))\\n;\\n"
                    },
                    {
                        "username": "Aditi3001",
                        "content": "with cte as\\n(\\nselect id, visit_date, people,\\nrow_number() over(order by visit_date) as rn\\nfrom stadium\\nwhere people >= 100\\n)\\nselect id, visit_date, people\\nfrom cte\\nwhere id-rn in \\n(select id-rn from cte group by id-rn having count(id-rn) >= 3)"
                    },
                    {
                        "username": "python_experts",
                        "content": "![image](https://assets.leetcode.com/users/python_experts/image_1558918164.png)\\n"
                    },
                    {
                        "username": "flashwolves",
                        "content": "FROM stadium s1, stadium s2, stadium s3\\nWHERE s1.people>=100 AND s2.people>=100 AND s3.people>=100\\nAND((s1.date = s2.date-1 AND s2.date = s3.date-1)\\n    OR(s1.date = s2.date+1 AND s2.date = s3.date+1)\\n    OR(s1.date = s2.date+1 AND s1.date = s3.date-1))    \\nORDER BY s1.ID ASC\\n"
                    },
                    {
                        "username": "ododyppah",
                        "content": "This answer to this question is not correct.\\nFirst of all, the dates are not consecutive days. If you look at the expected output after submission, the last few dates are not consecutive. Secondly, we are not sure if the ids are consecutive. \\nThe question says \"each day many people visit the stadium\", so the dates are supposed to be consecutive and my code theoretically should work.\\n\\nselect * from stadium where date in (\\n\\nselect distinct s1.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s2.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n\\nunion \\n\\nselect distinct s3.date from stadium s1\\njoin stadium s2 on subdate(s1.date, 1) = s2.date\\njoin stadium s3 on subdate(s2.date, 1) = s3.date\\nwhere s1.people >= 100 and s2.people >= 100 and s3.people >= 100\\n)"
                    },
                    {
                        "username": "yaitme",
                        "content": "Why do ppl keep posting answers, even when others explicitly request that they don\\'t want to see them? There\\'s an answer board for that but every time I try to get more info on a question in the discussion it\\'s just a bunch of answers and it ruins the problem for me. "
                    },
                    {
                        "username": "yxiaoaz",
                        "content": "I thought it\\'s a protocol that solutions should only be posted in SOLUTIONS sections instead of here..."
                    },
                    {
                        "username": "user8205on",
                        "content": "Which part of now answer you assholes don\\'t understand?\\nAsshole is to make sure you guys are checking the content!"
                    },
                    {
                        "username": "Puneet72",
                        "content": "with cte as (select id,lead(id,1) over (order by visit_date asc) as rnk \\n,lead(id,2) over (order by visit_date asc) rnk2 from stadium where people >=100)\\n\\nselect distinct b.id,b.visit_date,b.people from cte a \\nleft join stadium b on \\nb.id=a.id or b.id=rnk or b.id =rnk2\\nwhere a.id=rnk-1 and rnk+1=rnk2\\norder by 2 asc"
                    }
                ]
            }
        ]
    }
]