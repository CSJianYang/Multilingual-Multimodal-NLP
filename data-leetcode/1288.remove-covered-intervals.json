[
    {
        "title": "Remove Covered Intervals",
        "question_content": "Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.\nThe interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.\nReturn the number of remaining intervals.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,4],[3,6],[2,8]]\nOutput: 2\nExplanation: Interval [3,6] is covered by [2,8], therefore it is removed.\n\nExample 2:\n\nInput: intervals = [[1,4],[2,3]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= intervals.length <= 1000\n\tintervals[i].length == 2\n\t0 <= li < ri <= 105\n\tAll the given intervals are unique.",
        "solutions": [
            {
                "id": 451277,
                "title": "java-c-python-sort-solution",
                "content": "# Intuition\\nImagine that, after removing all covered intervals,\\nall intervals must have different bounds,\\nAfter sorting, their left and right bound are increasing at the same time.\\n<br>\\n\\n# Test Case\\nHere are some useful small test cases for debugging.\\n`[[1,2],[1,3]]`\\n`[[1,3],[1,8],[5,8]]`\\n`[[1,6],[4,6],[4,8]]`\\n<br>\\n\\n# Solution 1, sort\\nSort the array, and note the previous `left` and `right` bound.\\nFor evert interval `v`,\\nif `v[0] > left && v[1] > right`,\\nIt\\'s a new uncovered interval,\\nso we increment `++res`.\\n\\nComplexity: time `O(sort)`, space `O(sort)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int removeCoveredIntervals(int[][] A) {\\n        int res = 0, left = -1, right = -1;\\n        Arrays.sort(A, (a, b) -> a[0] - b[0]);\\n        for (int[] v : A) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++res;\\n            }\\n            right = Math.max(right, v[1]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int removeCoveredIntervals(vector<vector<int>>& A) {\\n        int res = 0, left = -1, right = -1;\\n        sort(A.begin(), A.end());\\n        for (auto& v: A) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++res;\\n            }\\n            right = max(right, v[1]);\\n        }\\n        return res;\\n    }\\n```\\n\\n\\n# Solution 2, sort left ascending and right decending\\nIn this solution, we sort on left first.\\nWhen left are same, we sort right in decending order.\\n\\nFor example: [[1,5],[1,4],[1,3],[1,2]]\\n\\nComplexity: time `O(sort)`, space `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int removeCoveredIntervals2(int[][] A) {\\n        int res = 0, right = 0;\\n        Arrays.sort(A, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int[] v : A) {\\n            if (v[1] > right) {\\n                ++res;\\n                right = v[1];\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```python\\n    def removeCoveredIntervals(self, A):\\n        res = right = 0\\n        A.sort(key=lambda a: (a[0], -a[1]))\\n        for i, j in A:\\n            res += j > right\\n            right = max(right, j)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int removeCoveredIntervals(int[][] A) {\\n        int res = 0, left = -1, right = -1;\\n        Arrays.sort(A, (a, b) -> a[0] - b[0]);\\n        for (int[] v : A) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++res;\\n            }\\n            right = Math.max(right, v[1]);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int removeCoveredIntervals(vector<vector<int>>& A) {\\n        int res = 0, left = -1, right = -1;\\n        sort(A.begin(), A.end());\\n        for (auto& v: A) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++res;\\n            }\\n            right = max(right, v[1]);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int removeCoveredIntervals2(int[][] A) {\\n        int res = 0, right = 0;\\n        Arrays.sort(A, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int[] v : A) {\\n            if (v[1] > right) {\\n                ++res;\\n                right = v[1];\\n            }\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def removeCoveredIntervals(self, A):\\n        res = right = 0\\n        A.sort(key=lambda a: (a[0], -a[1]))\\n        for i, j in A:\\n            res += j > right\\n            right = max(right, j)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 451284,
                "title": "java-python-3-simple-codes-w-explanation-and-analysis",
                "content": "**Sort intervals in such an order that only previous ones are possible to cover current one.**\\n1. Sort by the left bound, and when left bounds are equal, sort right bounds by reverse order; Therefore, **no interval can cover previous ones**;\\n2. Loop through the `intervals`, whenever current right most bound <  next interval\\'s right bound, it means current interval can NOT cover next interval, update right most bound and increase counter by 1.\\n \\n```java\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (i, j) -> (i[0] == j[0] ? j[1] - i[1] : i[0] - j[0]));\\n        int count = 0, cur = 0;\\n        for (int[] a : intervals) {\\n            if (cur < a[1]) {\\n                cur = a[1];\\n                ++count;\\n            }\\n        }\\n        return count;        \\n    }\\n```\\n```python\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        count = cur = 0\\n        for _, r in sorted(intervals, key=lambda i: (i[0], -i[1])):\\n            if cur < r:\\n                cur = r\\n                count += 1\\n        return count\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(1)` - excluding sorting space, where `n` = `intervals.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (i, j) -> (i[0] == j[0] ? j[1] - i[1] : i[0] - j[0]));\\n        int count = 0, cur = 0;\\n        for (int[] a : intervals) {\\n            if (cur < a[1]) {\\n                cur = a[1];\\n                ++count;\\n            }\\n        }\\n        return count;        \\n    }\\n```\n```python\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        count = cur = 0\\n        for _, r in sorted(intervals, key=lambda i: (i[0], -i[1])):\\n            if cur < r:\\n                cur = r\\n                count += 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1784527,
                "title": "c-easy-to-understand-sorting-short-simple",
                "content": "# 1288. Remove Covered Intervals\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Approach using simple sorting & comparison with previous element\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star the repository\\uD83D\\uDE09 \\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n\\n```\\n1.The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.\\n\\teg Interval [3,6] is covered by [2,8], therefore it should be removed.\\n\\t\\n\\tLet see the Number line :)\\n\\t\\n\\t                                           1  2  3  4  5  6  7  8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1-------4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         3--------6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  2-----------------8\\n\\tclearly we can see that [3 6] is covered by [2,8] and therefore it should be removed.\\n\\n2. We will Sort the vector in ascending order to get this type of arrangement.\\n\\t\\t//e.g. (1,5), (1,8), (2,9), (3,5), (4,7), (4,9)\\n\\t\\t\\n3. For finding the remaining interaval, ifa[1][0] && a[1][1] both greater than a[0][0] && a[0][1],\\nthis means the previous interval is not covered by the next one, therefore we will increase the count.\\n\\t\\t\\tconsider the case [[1,3],[2,4],[4,8]]\\n\\t\\t\\t\\t\\t\\t\\t\\t1   2  3  4  5  6  7  8\\n\\t\\t\\t\\t\\t\\t\\t\\t1------3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t2-----4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      4-----------8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\tNo interval is completely overlaped by other therefore remainig interaval are 3.\\n\\t\\t\\t\\n\\t\\t\\thow answer is 3 , at first cnt is initialised to 1\\n\\t\\t\\tnow a[0,0] i.e 1 and a[1,0] i.e 2   1 < 2 also,\\n\\t\\t\\t    a[0,1] i.e 3 and a[1,1] i.e 4   3 < 4    , therefore cnt is incremented by 2 now,\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\talso a[2,0] and a[2,1] satisy same condition with a[1,0] and a[1,1] , cnt becomes 3\\n```\\n\\n**Time Complexity: O(n logn)\\nSpace Complexity: O(1)**\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        // sorting the intervals(vector)\\n        sort(intervals.begin(),intervals.end());        \\n           \\n        int x1 = intervals[0][0];\\n        int x2 = intervals[0][1];\\n        \\n\\t\\t int res = 1;  //one for x1 and x2;\\n\\t\\t\\n\\t\\t// ifa[i][0] && a[i][1] both greater than a[i-1][0] && a[i-1][1]\\n\\t\\t// increase the cnt.\\n        for(int i= 1; i<intervals.size(); ++i)\\n        {\\n            if(intervals[i][0] > x1 && intervals[i][1] > x2)\\n                ++res;\\n            \\n\\t\\t\\t// updating x1 & x2 with next intervals\\n\\t\\t\\tas we are comparing from upcoming ones.\\n            if(intervals[i][1] > x2)\\n            {\\n                x1 = intervals[i][0];\\n                x2 = intervals [i][1];\\n            }\\n        }\\n        \\n        return res;       // return cnt\\n    }\\n\\n}; \\n   \\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Approach using simple sorting & comparison with previous element\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star the repository\\uD83D\\uDE09 \\n```\n```\\n1.The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.\\n\\teg Interval [3,6] is covered by [2,8], therefore it should be removed.\\n\\t\\n\\tLet see the Number line :)\\n\\t\\n\\t                                           1  2  3  4  5  6  7  8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1-------4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         3--------6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  2-----------------8\\n\\tclearly we can see that [3 6] is covered by [2,8] and therefore it should be removed.\\n\\n2. We will Sort the vector in ascending order to get this type of arrangement.\\n\\t\\t//e.g. (1,5), (1,8), (2,9), (3,5), (4,7), (4,9)\\n\\t\\t\\n3. For finding the remaining interaval, ifa[1][0] && a[1][1] both greater than a[0][0] && a[0][1],\\nthis means the previous interval is not covered by the next one, therefore we will increase the count.\\n\\t\\t\\tconsider the case [[1,3],[2,4],[4,8]]\\n\\t\\t\\t\\t\\t\\t\\t\\t1   2  3  4  5  6  7  8\\n\\t\\t\\t\\t\\t\\t\\t\\t1------3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t2-----4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      4-----------8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\tNo interval is completely overlaped by other therefore remainig interaval are 3.\\n\\t\\t\\t\\n\\t\\t\\thow answer is 3 , at first cnt is initialised to 1\\n\\t\\t\\tnow a[0,0] i.e 1 and a[1,0] i.e 2   1 < 2 also,\\n\\t\\t\\t    a[0,1] i.e 3 and a[1,1] i.e 4   3 < 4    , therefore cnt is incremented by 2 now,\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\talso a[2,0] and a[2,1] satisy same condition with a[1,0] and a[1,1] , cnt becomes 3\\n```\n```\\n\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        // sorting the intervals(vector)\\n        sort(intervals.begin(),intervals.end());        \\n           \\n        int x1 = intervals[0][0];\\n        int x2 = intervals[0][1];\\n        \\n\\t\\t int res = 1;  //one for x1 and x2;\\n\\t\\t\\n\\t\\t// ifa[i][0] && a[i][1] both greater than a[i-1][0] && a[i-1][1]\\n\\t\\t// increase the cnt.\\n        for(int i= 1; i<intervals.size(); ++i)\\n        {\\n            if(intervals[i][0] > x1 && intervals[i][1] > x2)\\n                ++res;\\n            \\n\\t\\t\\t// updating x1 & x2 with next intervals\\n\\t\\t\\tas we are comparing from upcoming ones.\\n            if(intervals[i][1] > x2)\\n            {\\n                x1 = intervals[i][0];\\n                x2 = intervals [i][1];\\n            }\\n        }\\n        \\n        return res;       // return cnt\\n    }\\n\\n}; \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784520,
                "title": "python3-sorting-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nAs for almost all problems related to intervals, we have to sort them first by the starting position. The next problem is how to define whether an interval is covered? After the sorting, we know that the start of every subsequent interval is greater or equal to all previous interval starts but we can\\'t say the same about ends. \\nFirst of all, we don\\'t need to remember the end positions of all previous intervals, and only keep track of the longest interval seen before. If the end of the current interval lies in the range of some long previous interval that means it is covered. Second of all, we need to handle an edge case when the starts of some intervals are the same and the trick with the longest interval won\\'t work. For example, there are might be a case like this `[[1,2],[1,4],[3,4]]`:\\n```\\n__\\n____\\n   ____\\n```\\nFor that we can make sure that in case of a tie, the sorting function puts a longer interval in the first place:\\n```\\n____\\n__\\n   ____\\n```\\n\\n*For reference: https://www.programiz.com/python-programming/methods/built-in/sorted*\\n\\nTime: **O(Nlog(N))** - sorting\\nSpace: **O(N)** - sorting\\n\\nRuntime: 100 ms, faster than **78.70%** of Python3 online submissions for Remove Covered Intervals.\\nMemory Usage: 14.5 MB, less than **86.23%** of Python3 online submissions for Remove Covered Intervals.\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        res, longest = len(intervals), 0\\n        srtd = sorted(intervals, key = lambda i: (i[0], -i[1]))\\n        \\n        for _, end in srtd:\\n            if end <= longest:\\n                res -= 1\\n            else:\\n                longest = end\\n                \\n        return res\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n__\\n____\\n   ____\\n```\n```\\n____\\n__\\n   ____\\n```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        res, longest = len(intervals), 0\\n        srtd = sorted(intervals, key = lambda i: (i[0], -i[1]))\\n        \\n        for _, end in srtd:\\n            if end <= longest:\\n                res -= 1\\n            else:\\n                longest = end\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878251,
                "title": "java-python-sorting-clean-concise-o-nlogn",
                "content": "**Idea**\\n- Sort `intervals` by increasing of `startTime` and decreasing of `endTime`\\n- `last = -1`: `last` is the farest end time of browsed `intervals`\\n- For each `interval` in `intervals`\\n\\t- If `interval.endTime <= last`, means `interval` is overlapped then we count `removed`\\n\\t- else `last = interval.endTime`\\n- `Result` = `number of intervals` - `removed`\\n\\n**Complexity**\\n- Time: `O(NlogN)`\\n- Space: `O(1)`\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort(key = lambda x:(x[0], -x[1]))\\n        last = -1\\n        removed = 0\\n        for i in intervals:\\n            if i[1] <= last:\\n                removed += 1\\n            else:\\n                last = i[1]\\n        return len(intervals) - removed\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int removed = 0, last = -1;\\n        Arrays.sort(intervals, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int[] i : intervals) {\\n            if (i[1] <= last) {\\n                removed += 1;\\n            } else {\\n                last = i[1];\\n            }\\n        }\\n        return intervals.length - removed;\\n    }\\n}\\n```\\n\\nFeel free to ask your question in the comments, help to **vote** if this post is useful to you.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort(key = lambda x:(x[0], -x[1]))\\n        last = -1\\n        removed = 0\\n        for i in intervals:\\n            if i[1] <= last:\\n                removed += 1\\n            else:\\n                last = i[1]\\n        return len(intervals) - removed\\n```\n```java\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int removed = 0, last = -1;\\n        Arrays.sort(intervals, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int[] i : intervals) {\\n            if (i[1] <= last) {\\n                removed += 1;\\n            } else {\\n                last = i[1];\\n            }\\n        }\\n        return intervals.length - removed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878505,
                "title": "python-sort-starts-in-o-n-log-n-explained",
                "content": "Let us sort our intervals by their starts and traverse them one by one (if we have the same ends, we first choose intervals with smaller ends, so they will be traversed first) Also let us keep `right` variable, which will be the biggest right end of interval so far. So, what does it mean that one interval is covered by some other? It means that `end <= right`: we have some previous interval with end more than current end and start which is less than current interval.\\n\\n**Complexity**: for time complexity we sort intervals in `O(n log n)` and then traverse them in `O(n)`. Space complexity is `O(n)` if we are not allowed to change `intervals` and `O(log n)` we are allowed to modify `intervals`.\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        right, rem, n = -1, 0, len(intervals)\\n        for _, end in intervals:\\n            if end <= right:\\n                rem += 1\\n            else:\\n                right = end\\n        return n - rem\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        right, rem, n = -1, 0, len(intervals)\\n        for _, end in intervals:\\n            if end <= right:\\n                rem += 1\\n            else:\\n                right = end\\n        return n - rem\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878981,
                "title": "c-sort-with-brief-explanation-o-nlogn-runtime-o-1-memory",
                "content": "**Brief Explanation**\\n* Sort intervals in the following manner:\\n  1. If start times are different, then interval having lesser start time will come first.\\n  2. If start times are same, then interval having higher end time will come first.\\n  \\n  *e.g.* [[3,5], [1,2], [9,11], [4,6], [4,8]] is *sorted* as [[1,2], [3,5], [4,8], [4,6], [9,11]]\\n  **2nd** condition ensures that the ***covered interval always comes after covering interval***.\\n\\n* Simply iterate over sorted intervals and keep track of maximum end time seen.\\n* While iterating, if some interval has end time less than or equal to maximum end time seen, then that is a covered interval.\\n**Why?** Because, we already know that start time of previous interval will be either before or equal to the start time of current interval.\\n* Exclude all the **covered intervals** and return the number of remaining intervals.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const auto& x, const auto& y){\\n            return x[0] != y[0] ? x[0] < y[0] : x[1] > y[1];\\n        });\\n        int covered_intervals = 0, maximum_end = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][1] <= maximum_end) {\\n                covered_intervals++;\\n            }\\n            maximum_end = max(maximum_end, intervals[i][1]);\\n        }\\n        return intervals.size() - covered_intervals;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const auto& x, const auto& y){\\n            return x[0] != y[0] ? x[0] < y[0] : x[1] > y[1];\\n        });\\n        int covered_intervals = 0, maximum_end = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][1] <= maximum_end) {\\n                covered_intervals++;\\n            }\\n            maximum_end = max(maximum_end, intervals[i][1]);\\n        }\\n        return intervals.size() - covered_intervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785080,
                "title": "c-detailed-explanation-w-image-dry-run-sorting",
                "content": "***Brief note about Question-***\\n* We have to *remove all intervals that are covered by another interval in the array.*\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is arr[]: [[1,3],[2,5],[3,4]]\\n\\nSo, the answer should be 2.\\nBecause interval [3,4] is the interval which is covered by interval [2,5], so that interval is neglected and\\nremaining two interval are included in our answer.\\n```\\n_______________\\n***Why Sorting ?***\\n* I am not going to say it always happen, but till now whenever i have solved problems based on interval, then **problem becomes more easy to solve if we will sort it**.\\n* You may ask, **why sorting?** Mabybe their is a way to solve problem without sorting, but after doing sorting, we are gonna confirm from either one side, that yess, now I arranged intervals either in ascending or desecnding order.\\n* **Sorting also helps us in traversing the array**.\\n___________\\n***How we will Implement-***\\n* Firstly, we have to **sort the array in ascending order**.\\n* After sorting, we know that **all intervals are arranged according to their start time**.\\n* Now, we maintain two variables, named as `maximum_left` and `maximum_right`.\\n* Intially, both the variables are intiliazed with value as `-1`.\\n* We start traversing the array and if we find a condition `arr[i][0] > maximum_left && arr[i][1] > maximum_right`, we will increment our answer saying that this could never be a part of anthor interval.\\n* If this so happen, then at that point we will update our maximum_left variable.\\n* Also, maximum right variable will be updated with `max(maximum_right, arr[i][1])` where `arr[i][1`] is the ending time of the interval.\\n* And lastly, we will simply return our answer.\\n* See below example for more clarification.\\n___________________\\n***Taking an example-***\\n* Suppose an array is given to us as arr[]: [[5,9],[2,5],[3,4],[1,3],[6,8]]\\n* So, after sorting it array looks like  arr[]: **[[1,3],[2,5],[3,4],[5,9],[6,8]]**\\n* ![image](https://assets.leetcode.com/users/images/5dca59a2-cc85-49ee-b073-2730bef2faa3_1645331383.9049485.jpeg)\\n\\n* I will dry run an example, hope that u got it.\\n__________________________\\n***Solution - I (Accepted)-***\\n```\\nTime Complexity --> O(n * log(n)) // as we are using sorting, and n is the size of the array \\nSpace Complexity --> O(1) \\n\\nIt paases [ 34 /  34] in built test cases\\n```\\n_______\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        sort(arr.begin(), arr.end()); // sort the array\\n        \\n        int maximum_left = -1, maximum_right = -1; // declaring variables\\n        \\n        int ans = 0; // conatains our answer\\n        \\n        for(int i = 0; i < n; i++) // start traversing the array\\n        {\\n            // check condition\\n            if(arr[i][0] > maximum_left && arr[i][1] > maximum_right)\\n            {\\n                ans++; // increment answer\\n                maximum_left = arr[i][0];  // update maximum left\\n            }\\n            maximum_right = max(maximum_right, arr[i][1]); // update maximum right\\n        }\\n        \\n        return ans; // lastly return answer\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is arr[]: [[1,3],[2,5],[3,4]]\\n\\nSo, the answer should be 2.\\nBecause interval [3,4] is the interval which is covered by interval [2,5], so that interval is neglected and\\nremaining two interval are included in our answer.\\n```\n```\\nTime Complexity --> O(n * log(n)) // as we are using sorting, and n is the size of the array \\nSpace Complexity --> O(1) \\n\\nIt paases [ 34 /  34] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        sort(arr.begin(), arr.end()); // sort the array\\n        \\n        int maximum_left = -1, maximum_right = -1; // declaring variables\\n        \\n        int ans = 0; // conatains our answer\\n        \\n        for(int i = 0; i < n; i++) // start traversing the array\\n        {\\n            // check condition\\n            if(arr[i][0] > maximum_left && arr[i][1] > maximum_right)\\n            {\\n                ans++; // increment answer\\n                maximum_left = arr[i][0];  // update maximum left\\n            }\\n            maximum_right = max(maximum_right, arr[i][1]); // update maximum right\\n        }\\n        \\n        return ans; // lastly return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878152,
                "title": "remove-covered-intervals-with-explanation-c-beats-100",
                "content": "We simply count the overlapping intervals and thus the answer is `intervals.size()` - `number of overlapping intervals`\\n\\n##### Crux:\\n* We need to sort intervals by their start time, **ascending**. The first starting interval needs to be checked previously.\\n* If two intervals\\' start times are equal, then the interval with the **greater** finishing time needs to be placed before the other one.\\n\\n#####  Solution:\\n* Sort intervals\\n* Declare a variable `end`  to hold the latest covered interval.\\n* If any interval i\\'s finish time is less than `end` then i is overlapping, thus it needs to be removed.\\n\\n#### C++\\n\\n```\\n\\tint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), \\n             [] (const vector<int>& v1, const vector<int>& v2) { \\n                 if(v1[0] != v2[0]) return v1[0] < v2[0];\\n                 else return v1[1] > v2[1];\\n        });\\n        \\n        int ans = intervals.size(), end = INT_MIN;\\n        \\n        for(int i = 0; i < intervals.size(); i++) {\\n\\t\\t\\t// If the current intervals end previously than the latest checkpoint\\n\\t\\t\\t// Then it\\'s overlapping, so decrease answer.\\n            if(intervals[i][1] <= end) --ans; \\n\\t\\t\\t\\n\\t\\t\\t// Otherwise, make this intervals finishing time the latest.\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n\\n##### Time Complexity: `O(n logn)` \\n##### Space Complexity: `O(1)`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), \\n             [] (const vector<int>& v1, const vector<int>& v2) { \\n                 if(v1[0] != v2[0]) return v1[0] < v2[0];\\n                 else return v1[1] > v2[1];\\n        });\\n        \\n        int ans = intervals.size(), end = INT_MIN;\\n        \\n        for(int i = 0; i < intervals.size(); i++) {\\n\\t\\t\\t// If the current intervals end previously than the latest checkpoint\\n\\t\\t\\t// Then it\\'s overlapping, so decrease answer.\\n            if(intervals[i][1] <= end) --ans; \\n\\t\\t\\t\\n\\t\\t\\t// Otherwise, make this intervals finishing time the latest.\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878478,
                "title": "python-simple-solution-explained-video-code-fastest",
                "content": "[](https://www.youtube.com/watch?v=emPnw5m2nN0)\\nhttps://www.youtube.com/watch?v=emPnw5m2nN0\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x : (x[0], -x[1]))\\n        \\n        res = 0\\n        ending = 0\\n        \\n        for _, end in intervals:\\n            if end > ending:\\n                res += 1\\n                ending = end\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x : (x[0], -x[1]))\\n        \\n        res = 0\\n        ending = 0\\n        \\n        for _, end in intervals:\\n            if end > ending:\\n                res += 1\\n                ending = end\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878287,
                "title": "c-simple-solution-using-sort-beats-96-in-time-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b){\\n        if (a[0] != b[0]){\\n            return a[0] < b[0];\\n        }else{\\n            return a[1] > b[1];\\n        }\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // - Sort the intervals in increasing order of starting point\\n        // - If starting points are same, in decreasing order of ending point\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int _max = INT_MIN;\\n        int count = 0;\\n        \\n        // - Compare the ending points in the sorted intervals\\n\\t\\t\\n        // - If at any index the ending point is less than the current maximum ending point\\n        //   that interval is the included one \\n\\t\\t//   (remember the starting point of the current is already greater than that\\n\\t\\t//   of all the previous intervals, so now when the ending point is lesser than the current max ending point\\n\\t\\t//   it means that interval is included in atleast one of the previous intervals)\\n\\t\\t\\n        // - Count the included ones and return size()-count\\n\\t\\t\\n\\t\\t// Note: If the starting index are equal, we sorted according to decreasing ending index so that it can be\\n\\t\\t// counted too as an included one\\n\\t\\t\\n        for (int i = 0; i<intervals.size(); i++){\\n            if (intervals[i][1] <= _max){\\n                count ++;\\n            }else{\\n                _max = intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b){\\n        if (a[0] != b[0]){\\n            return a[0] < b[0];\\n        }else{\\n            return a[1] > b[1];\\n        }\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // - Sort the intervals in increasing order of starting point\\n        // - If starting points are same, in decreasing order of ending point\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int _max = INT_MIN;\\n        int count = 0;\\n        \\n        // - Compare the ending points in the sorted intervals\\n\\t\\t\\n        // - If at any index the ending point is less than the current maximum ending point\\n        //   that interval is the included one \\n\\t\\t//   (remember the starting point of the current is already greater than that\\n\\t\\t//   of all the previous intervals, so now when the ending point is lesser than the current max ending point\\n\\t\\t//   it means that interval is included in atleast one of the previous intervals)\\n\\t\\t\\n        // - Count the included ones and return size()-count\\n\\t\\t\\n\\t\\t// Note: If the starting index are equal, we sorted according to decreasing ending index so that it can be\\n\\t\\t// counted too as an included one\\n\\t\\t\\n        for (int i = 0; i<intervals.size(); i++){\\n            if (intervals[i][1] <= _max){\\n                count ++;\\n            }else{\\n                _max = intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784874,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n*logn*)**\\n**Java**\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]));\\n        int count = 0, cur = 0;\\n        for(int interval[] : intervals){\\n            if(cur < interval[1]){\\n                cur = interval[1];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]))\\n    let count = 0, cur = 0\\n    for(let interval of intervals){\\n        if(cur < interval[1]){\\n            cur = interval[1]\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        count = cur = 0\\n        for _, i in sorted(intervals, key = lambda a: (a[0], -a[1])):\\n            if(cur < i):\\n                cur = i\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]));\\n        int count = 0, cur = 0;\\n        for(int interval[] : intervals){\\n            if(cur < interval[1]){\\n                cur = interval[1];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]))\\n    let count = 0, cur = 0\\n    for(let interval of intervals){\\n        if(cur < interval[1]){\\n            cur = interval[1]\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```\n```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        count = cur = 0\\n        for _, i in sorted(intervals, key = lambda a: (a[0], -a[1])):\\n            if(cur < i):\\n                cur = i\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785636,
                "title": "c-greedy-algorithm-easy-short-simple-clean",
                "content": "Use greedy approach to sort and then merge the intervals, compare the previous interval with the next interval and overlap.\\nSimilar to **Merge intervals** question.\\n\\n```class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        pair<int,int> curr;\\n        int c=1;\\n        curr.first=intervals[0][0];\\n        curr.second=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if((curr.first<=intervals[i][0] && curr.second>=intervals[i][1]) || (curr.first>=intervals[i][0] && curr.second<=intervals[i][1])){\\n           curr.first=min(curr.first,intervals[i][0]);\\n             curr.second=max(curr.second,intervals[i][1]);   \\n            }else{\\n                c++;\\n                curr.first=intervals[i][0];\\n                curr.second=intervals[i][1];\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        pair<int,int> curr;\\n        int c=1;\\n        curr.first=intervals[0][0];\\n        curr.second=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if((curr.first<=intervals[i][0] && curr.second>=intervals[i][1]) || (curr.first>=intervals[i][0] && curr.second<=intervals[i][1])){\\n           curr.first=min(curr.first,intervals[i][0]);\\n             curr.second=max(curr.second,intervals[i][1]);   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 878605,
                "title": "java-nothing-fancy",
                "content": "```\\n\\t\\tArrays.sort(intervals,(a,b)->{\\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\\n        });\\n        \\n        int max = intervals[0][1];\\n        int ans = 1;\\n        \\n        for(int[] interval : intervals){\\n            if(interval[1] > max){\\n                ans++;\\n                max = interval[1];\\n            }\\n        }\\n        \\n        return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tArrays.sort(intervals,(a,b)->{\\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\\n        });\\n        \\n        int max = intervals[0][1];\\n        int ans = 1;\\n        \\n        for(int[] interval : intervals){\\n            if(interval[1] > max){\\n                ans++;\\n                max = interval[1];\\n            }\\n        }\\n        \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451420,
                "title": "c-o-nlogn-n-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n   //[[1,2],[3,4],[5,9],[5,7],[5,6],[6,9]]\\n   //[[1,6], [1,4]]\\n    \\n\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        auto thisway = [&](vector<int> a , vector<int> b){\\n            return (a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\\n        };\\n        sort(intervals.begin() , intervals.end(), thisway);\\n        vector<int> cur = intervals[0];\\n        int total = n;\\n        for(int i = 1; i < n; ++i){             // first we are sorting by left of the each interval in increasing order and \\n            if(cur[1] >= intervals[i][1]){      // if equal lefts are there then by right in decreasing order\\n                --total;                        // then we are basically initially choosing a interval and then checking how many further\\n            }                                   // interval are its subsets otherwise take this new interval as we have already sorted \\n            else{                               // by first element so it means either this interval that we are checking is\\n                cur = intervals[i];             // has range outside our tillnow choosen interval \\n            }                                   // so we decide to update our choosen interval to this one.\\n        }                                       // then same goes on... \\n        return total;                           // [[2,4],[2,3],[3,6],[3,4],[3,3][4,9],[4,3]]   \\n    }                                           // [[6,9],[6,8],[6,7],[7,8],[9,14],[9,13],[10,12],[12,15]]\\n\\n};                                              \\n                                                \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   //[[1,2],[3,4],[5,9],[5,7],[5,6],[6,9]]\\n   //[[1,6], [1,4]]\\n    \\n\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        auto thisway = [&](vector<int> a , vector<int> b){\\n            return (a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\\n        };\\n        sort(intervals.begin() , intervals.end(), thisway);\\n        vector<int> cur = intervals[0];\\n        int total = n;\\n        for(int i = 1; i < n; ++i){             // first we are sorting by left of the each interval in increasing order and \\n            if(cur[1] >= intervals[i][1]){      // if equal lefts are there then by right in decreasing order\\n                --total;                        // then we are basically initially choosing a interval and then checking how many further\\n            }                                   // interval are its subsets otherwise take this new interval as we have already sorted \\n            else{                               // by first element so it means either this interval that we are checking is\\n                cur = intervals[i];             // has range outside our tillnow choosen interval \\n            }                                   // so we decide to update our choosen interval to this one.\\n        }                                       // then same goes on... \\n        return total;                           // [[2,4],[2,3],[3,6],[3,4],[3,3][4,9],[4,3]]   \\n    }                                           // [[6,9],[6,8],[6,7],[7,8],[9,14],[9,13],[10,12],[12,15]]\\n\\n};                                              \\n                                                \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785047,
                "title": "python-simple-python-solution-by-sorting-the-list",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n\\n\\t\\t\\tintervals=sorted(intervals)\\n\\n\\t\\t\\ti=0\\n\\t\\t\\twhile i<len(intervals)-1:\\n\\n\\t\\t\\t\\t\\ta,b = intervals[i]\\n\\t\\t\\t\\t\\tp,q = intervals[i+1]\\n\\n\\t\\t\\t\\t\\tif a <= p and q <= b:\\n\\t\\t\\t\\t\\t\\tintervals.remove(intervals[i+1])\\n\\t\\t\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\t\\t\\telif p <= a and b <= q:\\n\\t\\t\\t\\t\\t\\tintervals.remove(intervals[i])\\n\\t\\t\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\t\\t\\ti=i+1\\n\\t\\t\\treturn len(intervals)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n\\n\\t\\t\\tintervals=sorted(intervals)\\n\\n\\t\\t\\ti=0\\n\\t\\t\\twhile i<len(intervals)-1:\\n\\n\\t\\t\\t\\t\\ta,b = intervals[i]\\n\\t\\t\\t\\t\\tp,q = intervals[i+1]\\n\\n\\t\\t\\t\\t\\tif a <= p and q <= b:\\n\\t\\t\\t\\t\\t\\tintervals.remove(intervals[i+1])\\n\\t\\t\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\t\\t\\telif p <= a and b <= q:\\n\\t\\t\\t\\t\\t\\tintervals.remove(intervals[i])\\n\\t\\t\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\t\\t\\ti=i+1\\n\\t\\t\\treturn len(intervals)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1786515,
                "title": "easy-c-sol-sorting-o-nlogn",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        int res = 0,left = -1, right = -1;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        for(auto v: intervals){\\n            if(v[0] > left && v[1] > right){\\n                left = v[0];\\n                res++;\\n            }\\n            right = max(right, v[1]);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        int res = 0,left = -1, right = -1;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        for(auto v: intervals){\\n            if(v[0] > left && v[1] > right){\\n                left = v[0];\\n                res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786421,
                "title": "javascript-simple-solution-with-explanation",
                "content": "It helps to boil this problem down to essencials.\\n\\nFirst, you have an array of elements with could have overlapping sub-elements.\\n\\nIf a sub-element is completely contained by another, it can be skipped.\\n\\nThe key to this problem is to begin sorting the elements, first by left index, and if the same, by right index.\\n\\nIf they are sorted in this way, u know that you can iterate though every element, and the next will have to have the same or greater than start array value, and so you simply want to check if its end index is less than the prev.  If so, u can add it to the overlap count, if not, update the prev index to current for the next interation.\\n\\nCredit to Deadication for helping to simplify my understanding of the problem.\\n\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n  intervals.sort((a,b)=> a[0]-b[0] || b[1]-a[1]);\\n  let overlap=0;\\n  for (i=1,prev=0; i<intervals.length; i++)\\n//    if ((intervals[prev][0] <= intervals[i][0]) //no need to check, already done in sort\\n//      && (intervals[prev][1] >= intervals[i][1]))\\n\\tif (intervals[prev][1] >= intervals[i][1]) // just look at 2nd index\\n      overlap++  // add to skipped elements\\n    else\\n      prev=i; // didn\\'t overlap, so we can advance our previous element\\n  return intervals.length-overlap;\\n};\\n```\\n\\nIf this explanation helped you, please upvote so others might notice it as well.  Thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n  intervals.sort((a,b)=> a[0]-b[0] || b[1]-a[1]);\\n  let overlap=0;\\n  for (i=1,prev=0; i<intervals.length; i++)\\n//    if ((intervals[prev][0] <= intervals[i][0]) //no need to check, already done in sort\\n//      && (intervals[prev][1] >= intervals[i][1]))\\n\\tif (intervals[prev][1] >= intervals[i][1]) // just look at 2nd index\\n      overlap++  // add to skipped elements\\n    else\\n      prev=i; // didn\\'t overlap, so we can advance our previous element\\n  return intervals.length-overlap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878391,
                "title": "java-clean-code-no-sort-fast-than-100",
                "content": "* **Please upvote if helpful!!**\\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\n        int count = 0;\\n        for (int i = 0; i < intervals.length; i++) {\\n\\n            int a = intervals[i][0];\\n            int b = intervals[i][1];\\n\\n            for (int j = 0; j < intervals.length; j++) {\\n\\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n\\n                if (i != j && c <= a && b <= d) {\\n                    count++;\\n                    break;  // important step.!!\\n                    //interval[c,d) is the inner loop. as we found out Interval [a,b) (outer loop)\\n                    // is covered by interval [c,d).\\n                    //we need to break the inner loop and check the next [a,b).\\n                }\\n\\n            }\\n        }\\n\\n        return intervals.length - count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\n        int count = 0;\\n        for (int i = 0; i < intervals.length; i++) {\\n\\n            int a = intervals[i][0];\\n            int b = intervals[i][1];\\n\\n            for (int j = 0; j < intervals.length; j++) {\\n\\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n\\n                if (i != j && c <= a && b <= d) {\\n                    count++;\\n                    break;  // important step.!!\\n                    //interval[c,d) is the inner loop. as we found out Interval [a,b) (outer loop)\\n                    // is covered by interval [c,d).\\n                    //we need to break the inner loop and check the next [a,b).\\n                }\\n\\n            }\\n        }\\n\\n        return intervals.length - count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451250,
                "title": "java-simple-sort",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        Arrays.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[] e1, int[] e2){\\n                if(e1[0] < e2[0]) return -1;\\n                if(e2[0] < e1[0]) return 1;\\n                if(e1[1] > e2[1]) return -1;\\n                return 1;\\n            }\\n        });\\n        \\n        int count = 1;\\n        int[] prev = intervals[0];\\n        for(int i = 1; i < n; i++){\\n            if(intervals[i][0] >= prev[0] && intervals[i][1] <= prev[1]) continue;\\n            prev = intervals[i];\\n            count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        Arrays.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[] e1, int[] e2){\\n                if(e1[0] < e2[0]) return -1;\\n                if(e2[0] < e1[0]) return 1;\\n                if(e1[1] > e2[1]) return -1;\\n                return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786713,
                "title": "easy-c-solution-using-sorting-and-constant-extra-space",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019ll sort the array first.\\n- Take 2 variables to keep the current interval as *l & r*. Initialize them with -1.\\n- Now iterate over all the elements and we have to find the intervals, for every interval we\\u2019ll increase the count as we\\u2019re adding one interval.\\n- Check this 2 conditions **`intervals[i][0] > l` & `intervals[i][1] > r`,** if both satisfied then replace the l with first element of the current vector as it indicates the starting index.\\n- Increase the count & after every loop update r as the ending point can be change in every iteration.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size(), count=0, l=-1, r=-1;\\n        sort(intervals.begin(), intervals.end());\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(intervals[i][0] > l && intervals[i][1] > r){\\n                l = intervals[i][0];\\n                count++;\\n            }\\n            r = max(r, intervals[i][1]);\\n        }\\n        return count;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size(), count=0, l=-1, r=-1;\\n        sort(intervals.begin(), intervals.end());\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(intervals[i][0] > l && intervals[i][1] > r){\\n                l = intervals[i][0];\\n                count++;\\n            }\\n            r = max(r, intervals[i][1]);\\n        }\\n        return count;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879665,
                "title": "python-faster-than-99-using-dict",
                "content": "The idea is to keep a track of the highest ending time for every starting time and storing it as a key.\\nEx - [[1,2],[1,4],[2,6]]\\nwe would store : {1:4 , 2:6}\\nWe only need the max ones becuase the ones lesser than that will be included in the highest one anyway.\\n\\nLike in our example, [1,2] is in [1,4] that\\'s why we don\\'t need it.\\n\\nthen we just use the dictionary to find out any other matching intervals and return ans.\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        d=dict()   \\n        high=-1\\n        ans=0\\n        totalIntervals = len(intervals)\\n\\t\\t\\n        for i in range(len(intervals)):\\n            if intervals[i][0] in d.keys():\\n                if d[intervals[i][0]]< intervals[i][1]:\\n                    d[intervals[i][0]] = intervals[i][1]\\n            else:\\n                d[intervals[i][0]]  = intervals[i][1]\\n        for i in sorted(d):\\n            if d[i] > high:\\n                high = d[i]\\n                ans+=1\\n        return ans\\n            \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        d=dict()   \\n        high=-1\\n        ans=0\\n        totalIntervals = len(intervals)\\n\\t\\t\\n        for i in range(len(intervals)):\\n            if intervals[i][0] in d.keys():\\n                if d[intervals[i][0]]< intervals[i][1]:\\n                    d[intervals[i][0]] = intervals[i][1]\\n            else:\\n                d[intervals[i][0]]  = intervals[i][1]\\n        for i in sorted(d):\\n            if d[i] > high:\\n                high = d[i]\\n                ans+=1\\n        return ans\\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 878528,
                "title": "c-sort-by-ascending-start-and-descending-end-and-count-intervals-that-are-not-covered",
                "content": "```csharp\\npublic int RemoveCoveredIntervals(int[][] intervals) \\n{\\n\\tArray.Sort(intervals, (x, y) => x[0] == y[0] ? y[1] - x[1] : x[0] - y[0]);\\n\\tint count = 0;\\n\\tint right = 0;\\n\\n\\tfor(int i = 0; i < intervals.Length; i++)\\n\\t{\\n\\t\\tif (intervals[i][1] > right) \\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tright = intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int RemoveCoveredIntervals(int[][] intervals) \\n{\\n\\tArray.Sort(intervals, (x, y) => x[0] == y[0] ? y[1] - x[1] : x[0] - y[0]);\\n\\tint count = 0;\\n\\tint right = 0;\\n\\n\\tfor(int i = 0; i < intervals.Length; i++)\\n\\t{\\n\\t\\tif (intervals[i][1] > right) \\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tright = intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878162,
                "title": "java-1-sort-and-count-2-heap-comments-added",
                "content": "If you liked this solution, **please upvote my post**\\n\\n**1 Solution** - using sorting and no additional space\\n*Time - O(n\\u2022logn)*\\n*Spase - O(1)*\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int size = intervals.length;\\n        if (size <= 1) return size;\\n\\t\\t// sort in ASC order by start of interval. and in DESC by end of interval\\n\\t\\t// in this case biggest interval will be in the beginning\\n        Arrays.sort(intervals, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\t// at least one intervall will be\\n        int counter = 1;\\n        int[] prev = intervals[0];\\n        \\n        for (int r = 1; r < size; r++) {\\n            int[] next = intervals[r];\\n\\t\\t\\t// if prev coverst next - just continue\\n            if (prev[0] <= next[0] && prev[1] >= next[1]) {\\n                continue;\\n            }\\n            // in other case shift reference and inc counter\\n            prev = next;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```\\n\\n**2 Solution** - using Priority queue.\\n*Time - O(n\\u2022logn)*\\nQueue Create - about O(n) time\\nQueue poll 1 item - will be logn. So in sum - O(n\\u2022logn) - correct me if I am wrong\\n*Spase - O(n)* - however it is just a reference to a Queue. which works with references. So we could assume it O(1)\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int size = intervals.length;\\n        if (size <= 1) return size;\\n\\t\\t// sort in ASC order by start of interval. and in DESC by end of interval\\n\\t\\t// in this case biggest interval will be in the beginning\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        for (int r = 0; r < size; r++) {\\n            queue.add(intervals[r]);\\n        }\\n        \\n\\t\\t// at least one intervall will be\\n        int counter = 1;\\n        int[] prev = queue.poll();\\n        while(!queue.isEmpty()) {\\n            int[] next = queue.poll();\\n\\t\\t\\t// if prev coverst next - just continue\\n            if (prev[0] <= next[0] && prev[1] >= next[1]) {\\n                continue;\\n            }\\n            // in other case shift reference and inc counter\\n            prev = next;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int size = intervals.length;\\n        if (size <= 1) return size;\\n\\t\\t// sort in ASC order by start of interval. and in DESC by end of interval\\n\\t\\t// in this case biggest interval will be in the beginning\\n        Arrays.sort(intervals, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\t// at least one intervall will be\\n        int counter = 1;\\n        int[] prev = intervals[0];\\n        \\n        for (int r = 1; r < size; r++) {\\n            int[] next = intervals[r];\\n\\t\\t\\t// if prev coverst next - just continue\\n            if (prev[0] <= next[0] && prev[1] >= next[1]) {\\n                continue;\\n            }\\n            // in other case shift reference and inc counter\\n            prev = next;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int size = intervals.length;\\n        if (size <= 1) return size;\\n\\t\\t// sort in ASC order by start of interval. and in DESC by end of interval\\n\\t\\t// in this case biggest interval will be in the beginning\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        for (int r = 0; r < size; r++) {\\n            queue.add(intervals[r]);\\n        }\\n        \\n\\t\\t// at least one intervall will be\\n        int counter = 1;\\n        int[] prev = queue.poll();\\n        while(!queue.isEmpty()) {\\n            int[] next = queue.poll();\\n\\t\\t\\t// if prev coverst next - just continue\\n            if (prev[0] <= next[0] && prev[1] >= next[1]) {\\n                continue;\\n            }\\n            // in other case shift reference and inc counter\\n            prev = next;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878617,
                "title": "python-simple-sort",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/e7a7a92e-574f-450f-8e40-86c7f363454d_1601818491.404752.png)\\n\\nSort the array in reverse order according to the finished time. But if the finished time is same, then sort in -starting time. \\nSay you got, [[1,2],[1,4],[3,4]]...\\nSorting will give you [[1,4],[3,4],[1,2]] (As finished time is same for the first two, it is sorted according to - starting time.. (-1 > -3))\\n\\nNow al you have to do is check if interval in index (i) covers the interval in index (i+1), if so, then we put the bigger interval forward to check for the next. \\nfor instance, [1,4] covers [3,4].. so we don\\'t really need [3,4] to compare with others, so, we replace that with [1,4] and then compare following intervals with [1,4]\\n\\nps: I am really bad at making people understand things. But if it helped any one of you, it is worth it. Thank you <3\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(reverse=True,key=lambda x:(x[1],-x[0]))\\n        slen = len(intervals)\\n        count = slen\\n        for i in range(slen-1):\\n            if intervals[i][0]<=intervals[i+1][0] and intervals[i][1]>=intervals[i+1][1]:\\n                intervals[i+1] = intervals[i]\\n                count-=1\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(reverse=True,key=lambda x:(x[1],-x[0]))\\n        slen = len(intervals)\\n        count = slen\\n        for i in range(slen-1):\\n            if intervals[i][0]<=intervals[i+1][0] and intervals[i][1]>=intervals[i+1][1]:\\n                intervals[i+1] = intervals[i]\\n                count-=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653762,
                "title": "javascript-solution",
                "content": "**Use of Stack:**\\n\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => b[0] - a[0] || a[1] - b[1]);\\n\\n    const stack = [];\\n    stack.push(intervals.pop());\\n    \\n    while (intervals.length > 0) {\\n        const [currStart, currEnd] = intervals.pop();\\n        const [prevStart, prevEnd] = stack[stack.length - 1];\\n        \\n        if (currStart >= prevStart && currEnd <= prevEnd) {\\n            continue;\\n        } else {\\n            stack.push([currStart, currEnd]);\\n        }\\n    }\\n    \\n    return stack.length;\\n};\\n```\\n\\n<br>\\n\\n----\\n\\n<br>\\n\\n**Without the Use of Stack:**\\n\\n\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n    \\n    let count = 0;\\n    let curr = 0;\\n    let prev = 0;\\n    \\n    for (let prev = 0, curr = 1; curr < intervals.length; curr++) {\\n        const [prevStart, prevEnd] = intervals[prev];\\n        const [currStart, currEnd] = intervals[curr];\\n            \\n        if (prevStart <= currStart && prevEnd >= currEnd) {\\n            // there is a consumption\\n            count++;\\n        } else {\\n            prev = curr;\\n        }\\n    }\\n    \\n    return intervals.length - count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => b[0] - a[0] || a[1] - b[1]);\\n\\n    const stack = [];\\n    stack.push(intervals.pop());\\n    \\n    while (intervals.length > 0) {\\n        const [currStart, currEnd] = intervals.pop();\\n        const [prevStart, prevEnd] = stack[stack.length - 1];\\n        \\n        if (currStart >= prevStart && currEnd <= prevEnd) {\\n            continue;\\n        } else {\\n            stack.push([currStart, currEnd]);\\n        }\\n    }\\n    \\n    return stack.length;\\n};\\n```\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n    \\n    let count = 0;\\n    let curr = 0;\\n    let prev = 0;\\n    \\n    for (let prev = 0, curr = 1; curr < intervals.length; curr++) {\\n        const [prevStart, prevEnd] = intervals[prev];\\n        const [currStart, currEnd] = intervals[curr];\\n            \\n        if (prevStart <= currStart && prevEnd >= currEnd) {\\n            // there is a consumption\\n            count++;\\n        } else {\\n            prev = curr;\\n        }\\n    }\\n    \\n    return intervals.length - count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786706,
                "title": "c-sorting-stack-easy-understanding-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        //Sorting intervals \\n        sort(intervals.begin(), intervals.end());\\n\\t\\t\\n\\t\\tstack<vector<int>> st;\\n        \\n        for(auto x: intervals){\\n            //This is case where the *upcoming interval covers our stored intervals*\\n            while(!st.empty() && st.top()[0] >= x[0] && st.top()[1] <= x[1]){\\n                st.pop();\\n            }\\n            \\n            //This is case where *upcoming interval is smaller and gets covered by \\n            //already stored top interval*\\n            if(!st.empty() && st.top()[0] <= x[0] && st.top()[1] >= x[1]) continue;\\n            \\n            //If the upcoming interval is non-intersecting hence,\\n            st.push(x);\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        //Sorting intervals \\n        sort(intervals.begin(), intervals.end());\\n\\t\\t\\n\\t\\tstack<vector<int>> st;\\n        \\n        for(auto x: intervals){\\n            //This is case where the *upcoming interval covers our stored intervals*\\n            while(!st.empty() && st.top()[0] >= x[0] && st.top()[1] <= x[1]){\\n                st.pop();\\n            }\\n            \\n            //This is case where *upcoming interval is smaller and gets covered by \\n            //already stored top interval*\\n            if(!st.empty() && st.top()[0] <= x[0] && st.top()[1] >= x[1]) continue;\\n            \\n            //If the upcoming interval is non-intersecting hence,\\n            st.push(x);\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786299,
                "title": "c-sorting-with-comparator-function-o-nlogn-runtime-o-1-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a , vector<int>& b){\\n        if(a[0] != b[0]) return a[0]<b[0];\\n        return a[1]>b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int count = 0; \\n        int curMax = -1;\\n        for(int i=0; i<intervals.size(); i++){\\n            if( intervals[i][1]<=curMax ) count++;\\n            curMax = max(curMax,intervals[i][1]);\\n        } \\n        return intervals.size() - count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a , vector<int>& b){\\n        if(a[0] != b[0]) return a[0]<b[0];\\n        return a[1]>b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int count = 0; \\n        int curMax = -1;\\n        for(int i=0; i<intervals.size(); i++){\\n            if( intervals[i][1]<=curMax ) count++;\\n            curMax = max(curMax,intervals[i][1]);\\n        } \\n        return intervals.size() - count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785768,
                "title": "java-custom-sorting-easy-sol-explained",
                "content": "```\\nclass intervalsComparator implements Comparator<int[]> {\\n    @Override\\n    public int compare(int[] entry1, int[] entry2) {\\n\\t\\t// sort acc to ascending start of interval\\n\\t\\t//if start is same then sort acc to descending end of interval\\n        if (entry1[0] > entry2[0]) {\\n            return 1;\\n        } else if(entry1[0] < entry2[0]) {\\n            return -1;\\n        } else if(entry1[1] > entry2[1]) {\\n            return -1;\\n        } else if(entry1[1] < entry2[1]) {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n\\n        Arrays.sort(intervals, new intervalsComparator());\\n\\t\\t//max ending yet\\n        int maxEnd = intervals[0][1];\\n\\t\\t//max case, all intervals are individual and included\\n        int res = intervals.length;\\n        for(int i = 1; i < intervals.length; i++) {\\n\\t\\t\\n\\t\\t\\t//this interval\\'s start is higher than prev(since, ascending order)\\n\\t\\t\\t\\n            if(intervals[i][1] <= maxEnd) { \\n\\t\\t\\t//this interval\\'s end time is lesser than max end time encountered yet\\n\\t\\t\\t// this will be absorbed, so reduce total individual intervals\\n                res--; \\n            }\\n\\t\\t\\t// keep a track on max end time encountered for future intervals\\n            maxEnd = Math.max(maxEnd, intervals[i][1]); \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass intervalsComparator implements Comparator<int[]> {\\n    @Override\\n    public int compare(int[] entry1, int[] entry2) {\\n\\t\\t// sort acc to ascending start of interval\\n\\t\\t//if start is same then sort acc to descending end of interval\\n        if (entry1[0] > entry2[0]) {\\n            return 1;\\n        } else if(entry1[0] < entry2[0]) {\\n            return -1;\\n        } else if(entry1[1] > entry2[1]) {\\n            return -1;\\n        } else if(entry1[1] < entry2[1]) {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n\\n        Arrays.sort(intervals, new intervalsComparator());\\n\\t\\t//max ending yet\\n        int maxEnd = intervals[0][1];\\n\\t\\t//max case, all intervals are individual and included\\n        int res = intervals.length;\\n        for(int i = 1; i < intervals.length; i++) {\\n\\t\\t\\n\\t\\t\\t//this interval\\'s start is higher than prev(since, ascending order)\\n\\t\\t\\t\\n            if(intervals[i][1] <= maxEnd) { \\n\\t\\t\\t//this interval\\'s end time is lesser than max end time encountered yet\\n\\t\\t\\t// this will be absorbed, so reduce total individual intervals\\n                res--; \\n            }\\n\\t\\t\\t// keep a track on max end time encountered for future intervals\\n            maxEnd = Math.max(maxEnd, intervals[i][1]); \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784556,
                "title": "c-brute-force-accepted-solution-with-explanation",
                "content": "# Daily Challenge:-20/02/2022.\\n**Approach:-** This is very simple Brute force approach.\\nBecause the constrains are very Less that\\'s why brute force works.\\n\\n**What I\\'m Doing:-**\\n*Itrate from 0 to length of given interval array.*\\n-->For every ith Interval we check ,how many interval it is covering.\\n-->If any jth interval is covered by any ith interval,then we are doing two things.\\n    -->increment the count of covered interval.\\n   **-->To mark it covered ,we change its 1st value of covered interval(i.e jth) to -1.\\n   -->And during next itration we skip those intervals,which are already covered by some other intervals.**\\n   \\n-->At the end the variable count will indicate how many intervals we have covered.\\n-->So left uncovered interval are n-count. So return n-count.\\n\\n\\n**Time Complexity= O(n^2);\\nAuxiliary Space= O(1);**\\n\\nNote:-Approach By Sorting is Another  Optimized Approach, But I\\'m Not Covering it here.\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n       int count=0; \\n        int n=intervals.size();\\n        for(int i=0;i<n;i++) \\n        {\\n            if(intervals[i][0]==-1) //If that Interval is Already Covered,Skip that.\\n                continue;\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j||intervals[j][0]==-1) //i==j means same interval and intervals[j][0]==-1 means already covered.\\n                    continue;\\n                else if((intervals[i][0]<=intervals[j][0])&&(intervals[j][1]<=intervals[i][1]))\\n                {\\n                    /*Otherwise if jth interval is covered by ith.\\n                    Mark jth as Covered by Changing it\\'s first value to -1;\\n                    And Increment the Count of Covered Interval.*/\\n                    intervals[j][0]=-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        int left_uncovered=n-count; //Left uncovered Intervals.\\n        return left_uncovered; //return it.\\n    }\\n};\\n```\\n*If you find it helpful, Please Upvote.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n       int count=0; \\n        int n=intervals.size();\\n        for(int i=0;i<n;i++) \\n        {\\n            if(intervals[i][0]==-1) //If that Interval is Already Covered,Skip that.\\n                continue;\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j||intervals[j][0]==-1) //i==j means same interval and intervals[j][0]==-1 means already covered.\\n                    continue;\\n                else if((intervals[i][0]<=intervals[j][0])&&(intervals[j][1]<=intervals[i][1]))\\n                {\\n                    /*Otherwise if jth interval is covered by ith.\\n                    Mark jth as Covered by Changing it\\'s first value to -1;\\n                    And Increment the Count of Covered Interval.*/\\n                    intervals[j][0]=-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        int left_uncovered=n-count; //Left uncovered Intervals.\\n        return left_uncovered; //return it.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878296,
                "title": "remove-covered-intervals-java-explained",
                "content": "The problem states :` Interval [a,b) is covered by interval [c,d) if and only if c <= a and b <= d.`\\nSolution is from the hints provied in problem: `Compare each interval to all others and check if it is covered by any interval.`\\n\\n**Outer Loop:**\\n* \\t The Interval that\\'s being checked (let\\'s say `X [a,b)`)\\n* \\t If it\\'s `null` means already covered by other interval\\n\\n**Inner Loop:**\\n* Check If we are comparing `X` with itself. Let\\'s call the new Interval `Y [c,d)` and it shouldn\\'t be null.\\n* now if the `c <=a and b<=d` condition is satisfied then make `X` as `null` and break this loop.\\n\\n**Count Loop:** Count all the Intervals that are not null and return the same.\\n\\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\tif (intervals[i] != null)\\n\\t\\t\\tfor (int j = 0; j < intervals.length; j++) {\\n\\t\\t\\t\\tif (i != j && intervals[j] != null) {\\n\\t\\t\\t\\t\\tif (intervals[j][0] <= intervals[i][0] && intervals[i][1] <= intervals[j][1]) {\\n\\t\\t\\t\\t\\t\\tintervals[i] = null;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n\\tfor (int[] interval : intervals) {\\n\\t\\tif (interval != null) count++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\tif (intervals[i] != null)\\n\\t\\t\\tfor (int j = 0; j < intervals.length; j++) {\\n\\t\\t\\t\\tif (i != j && intervals[j] != null) {\\n\\t\\t\\t\\t\\tif (intervals[j][0] <= intervals[i][0] && intervals[i][1] <= intervals[j][1]) {\\n\\t\\t\\t\\t\\t\\tintervals[i] = null;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n\\tfor (int[] interval : intervals) {\\n\\t\\tif (interval != null) count++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689094,
                "title": "java-simple-sort",
                "content": "1, sort\\n2, loop every interval, comparing end of interval,  with the highest end:\\nsince the current start is always >= than all prev start, \\nif the curr end is <= the highest end, it will make sure to be included with another one;\\n```\\n    public int removeCoveredIntervals(int[][] is) {\\n        Arrays.sort(is, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int n = is.length, res = 0, end = Integer.MIN_VALUE;  \\n        for (int[] i : is) {\\n            if (i[1] > end) end = i[1];\\n            else res++;\\n        }\\n        return n - res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int removeCoveredIntervals(int[][] is) {\\n        Arrays.sort(is, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int n = is.length, res = 0, end = Integer.MIN_VALUE;  \\n        for (int[] i : is) {\\n            if (i[1] > end) end = i[1];\\n            else res++;\\n        }\\n        return n - res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494727,
                "title": "easy-java-solution-beats-95-runtime",
                "content": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (i1, i2) -> i1[0] - i2[0]);\\n        int count = 1;\\n        for (int i = 0, j = 1; j < intervals.length; j++) {\\n            if (intervals[i][1] < intervals[j][1]) {\\n                i = j;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (i1, i2) -> i1[0] - i2[0]);\\n        int count = 1;\\n        for (int i = 0, j = 1; j < intervals.length; j++) {\\n            if (intervals[i][1] < intervals[j][1]) {\\n                i = j;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786906,
                "title": "python3-brute-force-40-faster",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, new: List[List[int]]) -> int:\\n        arr=[]\\n        for i in range(len(new)):\\n            for j in range(len(new)):\\n                if i!=j and new[j][0] <= new[i][0] and new[i][1] <= new[j][1]:\\n                    arr.append(new[i])\\n                    break\\n        return len(new)-len(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, new: List[List[int]]) -> int:\\n        arr=[]\\n        for i in range(len(new)):\\n            for j in range(len(new)):\\n                if i!=j and new[j][0] <= new[i][0] and new[i][1] <= new[j][1]:\\n                    arr.append(new[i])\\n                    break\\n        return len(new)-len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786721,
                "title": "python-sorting-faster-than-85",
                "content": "```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n\\t    n = allIntervals = len(intervals)\\n\\t\\tl = 0\\n\\t\\tr = 1\\n\\t\\t\\n\\t\\t# this built in function can sort by first element as well as second\\n\\t\\t# so given sorted [l1,u1],[l2,u2] it can also satisfy l1 = l2 AND u1 < u2\\n\\t\\tintervals.sort()\\n\\t\\t\\n\\t\\t# we have a left and right pointer\\n\\t\\twhile r < n:\\n\\t\\t    # we check for equal lower bound\\n\\t\\t\\t# we will shift both left and right if equal since we only really need the interval with greatest upper bound among equal lower bounds\\n\\t\\t\\t# the greater upper bound the larger the interval\\n\\t\\t\\t# the interval with same lower bound but lower upper bound is also covered, hence the allIntervals decrement\\n\\t\\t    while r<n and intervals[l][0] == intervals[r][0]:\\n\\t\\t\\t    l += 1\\n\\t\\t\\t\\tr += 1\\n\\t\\t\\t\\tallIntervals -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# we scan through the upper bounds\\n\\t\\t\\t# we only shift right - left will serve as the basis for maximum upper bound\\n\\t\\t\\t# if current max upper bound is greater than interval[r], this also makes interval[r] covered, hence the allIntervals decrement\\n\\t\\t\\twhile r<n and intervals[l][1] >= intervals[r][1]:\\n\\t\\t\\t    r += 1\\n\\t\\t\\t\\tallIntervals -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\tl = r\\n\\t\\t\\tr += 1\\n\\t\\t\\t\\n\\t\\treturn allIntervals\\n\\t\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n\\t    n = allIntervals = len(intervals)\\n\\t\\tl = 0\\n\\t\\tr = 1\\n\\t\\t\\n\\t\\t# this built in function can sort by first element as well as second\\n\\t\\t# so given sorted [l1,u1],[l2,u2] it can also satisfy l1 = l2 AND u1 < u2\\n\\t\\tintervals.sort()\\n\\t\\t\\n\\t\\t# we have a left and right pointer\\n\\t\\twhile r < n:\\n\\t\\t    # we check for equal lower bound\\n\\t\\t\\t# we will shift both left and right if equal since we only really need the interval with greatest upper bound among equal lower bounds\\n\\t\\t\\t# the greater upper bound the larger the interval\\n\\t\\t\\t# the interval with same lower bound but lower upper bound is also covered, hence the allIntervals decrement\\n\\t\\t    while r<n and intervals[l][0] == intervals[r][0]:\\n\\t\\t\\t    l += 1\\n\\t\\t\\t\\tr += 1\\n\\t\\t\\t\\tallIntervals -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# we scan through the upper bounds\\n\\t\\t\\t# we only shift right - left will serve as the basis for maximum upper bound\\n\\t\\t\\t# if current max upper bound is greater than interval[r], this also makes interval[r] covered, hence the allIntervals decrement\\n\\t\\t\\twhile r<n and intervals[l][1] >= intervals[r][1]:\\n\\t\\t\\t    r += 1\\n\\t\\t\\t\\tallIntervals -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\tl = r\\n\\t\\t\\tr += 1\\n\\t\\t\\t\\n\\t\\treturn allIntervals\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786656,
                "title": "python-simple-code",
                "content": "```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(intervals)\\n        c = n\\n        for i in range(n):\\n            for j in intervals[:i] + intervals[i+1:]:\\n                if intervals[i][0] >= j[0] and intervals[i][1] <= j[1]:\\n                    c-=1\\n                    break\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(intervals)\\n        c = n\\n        for i in range(n):\\n            for j in intervals[:i] + intervals[i+1:]:\\n                if intervals[i][0] >= j[0] and intervals[i][1] <= j[1]:\\n                    c-=1\\n                    break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786623,
                "title": "js-100-ms-better-than-58",
                "content": "```\\n\\nconst removeCoveredIntervals = function(its) {\\n    let r = 0;\\n    its.sort((a, b) => a[0] - b[0]);\\n    const c = [-1, -1]\\n    for (let it of its) {\\n        if (it[0] > c[0] && it[1] > c[1]) {\\n            c[0] = it[0];\\n            r++;\\n        }\\n        c[1] = Math.max(c[1], it[1]);\\n    }\\n    return r;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst removeCoveredIntervals = function(its) {\\n    let r = 0;\\n    its.sort((a, b) => a[0] - b[0]);\\n    const c = [-1, -1]\\n    for (let it of its) {\\n        if (it[0] > c[0] && it[1] > c[1]) {\\n            c[0] = it[0];\\n            r++;\\n        }\\n        c[1] = Math.max(c[1], it[1]);\\n    }\\n    return r;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786525,
                "title": "python-3-greedy-solution-and-explanation",
                "content": "\\n# \\uD83C\\uDF1F[Python 3] Greedy Sort Solution and Explanation\\n\\n## 1\\uFE0F\\u20E3 Greedy Naive Approach:\\n* Step 1. Sort intervals by first index\\n* Setp 2. Compare with current interval and last interval, so we can check whether current interval and last interval overlaps and covered by intervals[i][1] <= lastInterval[1].\\n> **(Edge Case)** : Since we compare two intervals ending point, once current interval\\'s ending point is **smaller** than last interval\\'s, in most of time it works.\\n> But there is a edge case that these two interval\\'s starting point are equal. So we could add another **if statement** to update last interval to a larger interval\\n## Dry run\\n```\\nIntervals = [[1,4],[3,6],[2,8],[1,5],[2,3]]\\n#sorted\\n[[1, 4], [1, 5], [2, 8], [2, 3], [3, 6]]\\n# [1,4] and [1,5] is one of our edge cases\\nInit => count = 1, lastInterval = [1, 4]\\n# In for loop\\ni = 1 => count = 1, lastInterval = [1, 5] #Edge case swap lastInterval\\ni = 2 => count = 2, lastInterval = [2, 8]\\ni = 3 => count = 2, lastInterval = [2, 8] # [2, 3]\\'s ending point is smaller than [2, 8]\\ni = 4 => count = 2, lastInterval = [2, 8] # [3, 6]\\'s ending point is smaller than [2, 8]\\n\\nFinal => return 2\\n```\\n\\n## Complexity Analysis\\n* Time: O(Nlog(N)) : Let N be length of intervals\\n* Space: O(N) :  Sorting in Python\\n\\n\\n## Code\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:    \\n        intervals.sort(key = lambda x: x[0])        \\n        lastInterval = intervals[0]\\n        count = 1\\n        for i in range(1, len(intervals)):\\n            # Basic logic\\n            if intervals[i][1] <= lastInterval[1]:\\n                continue\\n            # In case both inverval share same start point, we update lastInterval\\n            elif intervals[i][0] == lastInterval[0] and lastInterval[1] <= intervals[i][1]:\\n                lastInterval = intervals[i]\\n                continue\\n            # Update last interval and increase count\\n            lastInterval = intervals[i]\\n            count += 1\\n        return count\\n```\\n\\n## 2\\uFE0F\\u20E3 Greedy Improved Approach:\\n\\n**In order two deal with the edge case this time we sort intervals not only by first index of interval and both second index with large number first**\\n* Step 1. Sort intervals by first index (Smaller first index, and larger second index)\\n* Setp 2. Compare with current interval and last interval, so we can check whether current interval and last interval overlaps and covered by intervals[i][1] <= lastInterval[1].\\n## Exapmle\\n\\n```\\nIntervals = [[1,4],[3,6],[2,8],[1,5],[2,3]]\\nintervals.sort(key = lambda x: x[0])\\n> [[1, 4], [1, 5], [2, 8], [2, 3], [3, 6]]\\n\\nintervals.sort(key = lambda x: (x[0], -x[1]))\\n> [[1, 5], [1, 4], [2, 8], [2, 3], [3, 6]]\\n```\\n\\n## Complexity Analysis\\n* Time: O(Nlog(N)) : Let N be length of intervals\\n* Space: O(N) :  Sorting in Python\\n\\n\\n## Code\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        # To deal with edge case, we sort both (x[0] and -x[1])\\n        intervals.sort(key = lambda x: (x[0], -x[1]))        \\n        lastInterval = intervals[0]\\n        count = 1\\n        print(intervals)\\n        for i in range(1, len(intervals)):\\n            # Basic logic\\n            if intervals[i][1] <= lastInterval[1]:\\n                continue\\n            # Update last interval and increase count\\n            lastInterval = intervals[i]\\n            count += 1\\n        return count\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nIntervals = [[1,4],[3,6],[2,8],[1,5],[2,3]]\\n#sorted\\n[[1, 4], [1, 5], [2, 8], [2, 3], [3, 6]]\\n# [1,4] and [1,5] is one of our edge cases\\nInit => count = 1, lastInterval = [1, 4]\\n# In for loop\\ni = 1 => count = 1, lastInterval = [1, 5] #Edge case swap lastInterval\\ni = 2 => count = 2, lastInterval = [2, 8]\\ni = 3 => count = 2, lastInterval = [2, 8] # [2, 3]\\'s ending point is smaller than [2, 8]\\ni = 4 => count = 2, lastInterval = [2, 8] # [3, 6]\\'s ending point is smaller than [2, 8]\\n\\nFinal => return 2\\n```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:    \\n        intervals.sort(key = lambda x: x[0])        \\n        lastInterval = intervals[0]\\n        count = 1\\n        for i in range(1, len(intervals)):\\n            # Basic logic\\n            if intervals[i][1] <= lastInterval[1]:\\n                continue\\n            # In case both inverval share same start point, we update lastInterval\\n            elif intervals[i][0] == lastInterval[0] and lastInterval[1] <= intervals[i][1]:\\n                lastInterval = intervals[i]\\n                continue\\n            # Update last interval and increase count\\n            lastInterval = intervals[i]\\n            count += 1\\n        return count\\n```\n```\\nIntervals = [[1,4],[3,6],[2,8],[1,5],[2,3]]\\nintervals.sort(key = lambda x: x[0])\\n> [[1, 4], [1, 5], [2, 8], [2, 3], [3, 6]]\\n\\nintervals.sort(key = lambda x: (x[0], -x[1]))\\n> [[1, 5], [1, 4], [2, 8], [2, 3], [3, 6]]\\n```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        # To deal with edge case, we sort both (x[0] and -x[1])\\n        intervals.sort(key = lambda x: (x[0], -x[1]))        \\n        lastInterval = intervals[0]\\n        count = 1\\n        print(intervals)\\n        for i in range(1, len(intervals)):\\n            # Basic logic\\n            if intervals[i][1] <= lastInterval[1]:\\n                continue\\n            # Update last interval and increase count\\n            lastInterval = intervals[i]\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786131,
                "title": "clean-and-concise-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NlogN)\\n    // Space Complexity:- O(1)\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // sort intervals on the basis of l, and if l is same, then decreasing r\\n        sort(intervals.begin(),intervals.end(),[&](const vector<int>& p1,const vector<int>& p2){\\n            if(p1[0]==p2[0]){\\n                return p1[1]>p2[1];\\n            }\\n            return p1[0]<p2[0];\\n        });\\n        \\n        int n = intervals.size();\\n        int ans = n,rmax = intervals[0][1];\\n        for(int i=1;i<n;i++){\\n            // track rmax, if rmax>=curr r of interval, this interval is covered\\n            if(rmax>=intervals[i][1]){\\n                ans--;\\n            }\\n            else{\\n                rmax = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NlogN)\\n    // Space Complexity:- O(1)\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // sort intervals on the basis of l, and if l is same, then decreasing r\\n        sort(intervals.begin(),intervals.end(),[&](const vector<int>& p1,const vector<int>& p2){\\n            if(p1[0]==p2[0]){\\n                return p1[1]>p2[1];\\n            }\\n            return p1[0]<p2[0];\\n        });\\n        \\n        int n = intervals.size();\\n        int ans = n,rmax = intervals[0][1];\\n        for(int i=1;i<n;i++){\\n            // track rmax, if rmax>=curr r of interval, this interval is covered\\n            if(rmax>=intervals[i][1]){\\n                ans--;\\n            }\\n            else{\\n                rmax = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786026,
                "title": "python-3-90ms-sorted-matrix-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x : (x[0], -x[1]))\\n        res = 0\\n        ending = 0\\n        for _, end in intervals:\\n            if end > ending:\\n                res += 1\\n                ending = end\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x : (x[0], -x[1]))\\n        res = 0\\n        ending = 0\\n        for _, end in intervals:\\n            if end > ending:\\n                res += 1\\n                ending = end\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786009,
                "title": "c-simple-solution-o-nlogn",
                "content": "* Multiply each **r** by **-1** to make it negative.\\n* Sort the intervals.\\n* Now we do care only for our right pointer **r**, because **L** will be in increasing order.\\n* Keep checking **r** one by one and track the only last uncovered right pointer.\\n* Save answer as the difference between total intervals and covered intervals.\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        for(int i = 0; i < n; i++) {\\n            intervals[i][1] *= -1;\\n        }\\n        \\n        sort(intervals.begin(), intervals.end());\\n        int prevR = intervals[0][1] * -1;\\n        int cnt = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int currR = intervals[i][1] * -1;\\n            if(currR <= prevR) ++cnt;\\n            else prevR = currR;\\n        }\\n        \\n        return n - cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        for(int i = 0; i < n; i++) {\\n            intervals[i][1] *= -1;\\n        }\\n        \\n        sort(intervals.begin(), intervals.end());\\n        int prevR = intervals[0][1] * -1;\\n        int cnt = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int currR = intervals[i][1] * -1;\\n            if(currR <= prevR) ++cnt;\\n            else prevR = currR;\\n        }\\n        \\n        return n - cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785734,
                "title": "simple-c-solution-easy-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) \\n    {\\n        \\n        int n = intervals.size();\\n        int ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            int s = intervals[i].front();       //start point of a interval\\n            int e = intervals[i].back();        //end point\\n            int c = 0;\\n            for(int  j = 0;j<n;++j)\\n            {\\n                int a = intervals[j].front();       //start \\n                int b = intervals[j].back();        //end\\n                \\n                if(s>=a && b>=e)\\n                    ++c;\\n            }\\n            if(c>1)                 //greater than one because c=1 will count the same iterval also\\n                ++ans;              //count extra interval present\\n        }\\n        return n-ans;               //return remaining no of interval\\n        \\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF FOUND HELPFUL.**\\n**HAPPY LEARNING. HAPPY CODING.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) \\n    {\\n        \\n        int n = intervals.size();\\n        int ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            int s = intervals[i].front();       //start point of a interval\\n            int e = intervals[i].back();        //end point\\n            int c = 0;\\n            for(int  j = 0;j<n;++j)\\n            {\\n                int a = intervals[j].front();       //start \\n                int b = intervals[j].back();        //end\\n                \\n                if(s>=a && b>=e)\\n                    ++c;\\n            }\\n            if(c>1)                 //greater than one because c=1 will count the same iterval also\\n                ++ans;              //count extra interval present\\n        }\\n        return n-ans;               //return remaining no of interval\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785700,
                "title": "sort-solution-java",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b) -> a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int count=1;\\n        int ind=0;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[ind][1]<intervals[i][1]){\\n                count++;\\n                ind=i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b) -> a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int count=1;\\n        int ind=0;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[ind][1]<intervals[i][1]){\\n                count++;\\n                ind=i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785633,
                "title": "best-java-solution",
                "content": "```\\n public int removeCoveredIntervals(int[][] intervals) {\\n \\n    Arrays.sort(intervals, (a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));\\n       \\n\\tint max=intervals[0][1];\\n    int count=1;\\n        \\n        for(int i=1;i<intervals.length;i++){\\n            if(max<intervals[i][1] ){\\n                count++;\\n                max=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n public int removeCoveredIntervals(int[][] intervals) {\\n \\n    Arrays.sort(intervals, (a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));\\n       \\n\\tint max=intervals[0][1];\\n    int count=1;\\n        \\n        for(int i=1;i<intervals.length;i++){\\n            if(max<intervals[i][1] ){\\n                count++;\\n                max=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1785581,
                "title": "c-o-nlogn-solution-using-comparator-function",
                "content": "Sort the intervals in non-decreasing order of their starting time.\\nThen calculate the number of intervals that completely overlap.\\nReturn total number of intervals-number of intervals that completely overlap.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(vector <int> &a, vector <int> &b)\\n    {\\n        if(a[0]<b[0])\\n            return true;\\n        else if(a[0]==b[0])\\n        {\\n            if(a[1]>b[1])\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end(),cmp);\\n        \\n        int st=v[0][0],en=v[0][1],i,c=0;\\n        \\n        for(i=1;i<v.size();i++)\\n        {\\n            if(v[i][0]>=st and v[i][1]<=en)\\n                ++c;\\n            else\\n            {\\n                st=v[i][0];\\n                en=v[i][1];\\n            }\\n        }\\n        \\n        return v.size()-c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(vector <int> &a, vector <int> &b)\\n    {\\n        if(a[0]<b[0])\\n            return true;\\n        else if(a[0]==b[0])\\n        {\\n            if(a[1]>b[1])\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end(),cmp);\\n        \\n        int st=v[0][0],en=v[0][1],i,c=0;\\n        \\n        for(i=1;i<v.size();i++)\\n        {\\n            if(v[i][0]>=st and v[i][1]<=en)\\n                ++c;\\n            else\\n            {\\n                st=v[i][0];\\n                en=v[i][1];\\n            }\\n        }\\n        \\n        return v.size()-c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785555,
                "title": "c-sort-solution-with-explanation",
                "content": "##### **Solution:- Using sorting**\\nSort the array, and note the previous left and right bound.\\nFor evert interval v,\\nif v[0] > left && v[1] > right,\\nIt\\'s a new uncovered interval,\\nso we increment ++result.\\n\\nComplexity: time O(sort), space O(sort)\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = 0, left = -1, right = -1;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& v: intervals) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++result;\\n            }\\n            right = max(right, v[1]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Don\\'t be selfish, do upvote, if somewhere it helped you :)**\\n*Happy Coding.*",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = 0, left = -1, right = -1;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& v: intervals) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++result;\\n            }\\n            right = max(right, v[1]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785343,
                "title": "java-easy-solution-2ms",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int pairs = intervals.length;\\n        boolean[] check = new boolean[pairs];\\n        for(int i = 0; i< pairs ;i++){\\n            if(!check[i]){\\n                for(int j = i+1;j<pairs;j++){\\n                    if(!check[j]){\\n                        if(intervals[i][0]<=intervals[j][0] && intervals[j][1]<=intervals[i][1]){\\n                            check[j] = true;\\n                        }\\n                        else if(intervals[i][0]>=intervals[j][0] && intervals[j][1]>=intervals[i][1]){\\n                            check[i] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(boolean b : check){\\n            if(!b){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int pairs = intervals.length;\\n        boolean[] check = new boolean[pairs];\\n        for(int i = 0; i< pairs ;i++){\\n            if(!check[i]){\\n                for(int j = i+1;j<pairs;j++){\\n                    if(!check[j]){\\n                        if(intervals[i][0]<=intervals[j][0] && intervals[j][1]<=intervals[i][1]){\\n                            check[j] = true;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 879763,
                "title": "c-simple-sorting-solution-explained-100-time-60-space",
                "content": "This solution requires sorting and I have to admit it took me a bit to notice I was massively underperforming with it, since my sorting function was not getting parameters as references - my bad and lesson learnt: do not focus just on the algorithm, but also consider the basics \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\n\\nAnyway, without further ado, let\\'s indeed focus on what matters - our function will have just 2 support variables:\\n* `len` to store of the length of the input;\\n* `res` to keep track of our result and initially set to the value of `len`.\\n\\nWe then proceed to sort by our helper function `cmp`, sorting by starting period first (increasing order) and, when they match, ending period second (decreasing).\\n\\nThere is a reason for that: we are then going to loop throug the sorted array, storing the highest ending value found so far in `ed`, then we can have 2 scenarios for each new interval parsed:\\n* the current ending period is `<= ed` and this means, since by definition we know that the starting periods are increasing, that with the previous starting period being `>=` the current one, this current interval is covered and thus we decrease `res` (marking a removal);\\n* the current ending period is `> ed` , then we just update `ed` to this value, ready for another loop.\\n\\nAs you might infer, having the finishing periods in decreasing order is the invariant that allows us to keep looping like this when the starting periods are identical; also note that an alternative approach might be to keep parsing a series sorted by only one criteria, but then updating both starting and finishing stored values at each step with a more complex logic, for no gain (and some more computation, but on linear instead of linearithmic time).\\n\\nOnce we are done, we just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[0] != b[0] ? a[0] < b[0] : a[1] > b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // support variables\\n        int len = intervals.size(), res = len;\\n        // sorting by beginning, then ending time\\n        sort(begin(intervals), end(intervals), cmp);\\n        for (int i = 1, ed = intervals[0][1]; i < len; i++){\\n            if (intervals[i][1] <= ed) res--;\\n            else ed = intervals[i][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[0] != b[0] ? a[0] < b[0] : a[1] > b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // support variables\\n        int len = intervals.size(), res = len;\\n        // sorting by beginning, then ending time\\n        sort(begin(intervals), end(intervals), cmp);\\n        for (int i = 1, ed = intervals[0][1]; i < len; i++){\\n            if (intervals[i][1] <= ed) res--;\\n            else ed = intervals[i][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879677,
                "title": "c-sorting-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = 1;\\n        sort(intervals.begin(), intervals.end());\\n        int x1 = intervals[0][0], x2 = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++) {\\n            if(intervals[i][0] > x1 && intervals[i][1] > x2) result++;\\n            if(intervals[i][1] > x2) {\\n                x1 = intervals[i][0];\\n                x2 = intervals[i][1];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = 1;\\n        sort(intervals.begin(), intervals.end());\\n        int x1 = intervals[0][0], x2 = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++) {\\n            if(intervals[i][0] > x1 && intervals[i][1] > x2) result++;\\n            if(intervals[i][1] > x2) {\\n                x1 = intervals[i][0];\\n                x2 = intervals[i][1];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878461,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic int RemoveCoveredIntervals(int[][] intervals) =>\\n\\tintervals.OrderBy(i => i[0]).ThenByDescending(i => i[1])\\n\\t\\t.Aggregate((Result: 0, Right: 0), (t, i) => i[1] > t.Right ? (t.Result + 1, i[1]) : t).Result;\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int RemoveCoveredIntervals(int[][] intervals) =>\\n\\tintervals.OrderBy(i => i[0]).ThenByDescending(i => i[1])\\n\\t\\t.Aggregate((Result: 0, Right: 0), (t, i) => i[1] > t.Right ? (t.Result + 1, i[1]) : t).Result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878418,
                "title": "python-super-simple-clean-solution-faster-than-99-3",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        total = len(intervals)\\n        intervals.sort(key = lambda a: a[0])\\n        curr = [-1, -1]\\n        count = 0\\n        for inter in intervals:\\n            \\n            if inter[0]>=curr[0] and inter[1]<=curr[1]:\\n                count+=1\\n                continue\\n                \\n            elif inter[0]<=curr[0] and inter[1]>=curr[1]:\\n                count+=1\\n                \\n            curr = inter\\n            \\n        return total-count\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        total = len(intervals)\\n        intervals.sort(key = lambda a: a[0])\\n        curr = [-1, -1]\\n        count = 0\\n        for inter in intervals:\\n            \\n            if inter[0]>=curr[0] and inter[1]<=curr[1]:\\n                count+=1\\n                continue\\n                \\n            elif inter[0]<=curr[0] and inter[1]>=curr[1]:\\n                count+=1\\n                \\n            curr = inter\\n            \\n        return total-count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853816,
                "title": "python-o-nlogn-o-n-beats-100",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        end = intervals[0][1]\\n        count = 1\\n        \\n        for i in intervals:\\n            if i[1]>end:\\n                end = i[1]\\n                count += 1\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        end = intervals[0][1]\\n        count = 1\\n        \\n        for i in intervals:\\n            if i[1]>end:\\n                end = i[1]\\n                count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828159,
                "title": "sorting-c-easy-with-explanation-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very Simple **Sort the Intervals** on the basis of their **starting Time** and Try to find out the Number of Overlapping Intervals and finally Return-`Total_intervals-overlapping intervals`\\n\\n**In order to find out the Overlapping intervals we have 3 cases as Below:-**\\n```\\nCase 1:- [1,4],[2,3] completely Overlapped. here increment the number of overlapping\\nintervals by 1, and don\\'t update the start and end pointer.\\n\\nCase 2:- [1,2],[1,4] completely Overlapped. here increment the number of overlapping\\nintervals by 1 and update the end pointer.\\nCase 3:- [1,4],[3,5] Partially Overlapped. Here Intervals are Partially Overlapped so\\n don\\'t increment the number of Intervals but Update the start and End Pointers.\\n```\\n\\n# Complexity\\n- Time complexity:O(N * Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& inter) {\\n        sort(inter.begin(),inter.end());\\n        int st = inter[0][0],end = inter[0][1],ans = 0;\\n        for(int i = 1;i<inter.size();i++)\\n        {\\n            if(inter[i][0]>=st && inter[i][1]<=end) ans++;\\n            else if(inter[i][0]==st && inter[i][1]>=end)\\n            {\\n                ans++;\\n                end = inter[i][1];\\n            }\\n            else if(inter[i][0]>=end || inter[i][1]>=end)\\n            {\\n                st = inter[i][0];\\n                end = max(end,inter[i][1]);\\n            }\\n        }\\n        return inter.size()-ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/12d8a5ec-5f24-4267-80b3-e9881846a5e9_1690537589.6755645.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nCase 1:- [1,4],[2,3] completely Overlapped. here increment the number of overlapping\\nintervals by 1, and don\\'t update the start and end pointer.\\n\\nCase 2:- [1,2],[1,4] completely Overlapped. here increment the number of overlapping\\nintervals by 1 and update the end pointer.\\nCase 3:- [1,4],[3,5] Partially Overlapped. Here Intervals are Partially Overlapped so\\n don\\'t increment the number of Intervals but Update the start and End Pointers.\\n```\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& inter) {\\n        sort(inter.begin(),inter.end());\\n        int st = inter[0][0],end = inter[0][1],ans = 0;\\n        for(int i = 1;i<inter.size();i++)\\n        {\\n            if(inter[i][0]>=st && inter[i][1]<=end) ans++;\\n            else if(inter[i][0]==st && inter[i][1]>=end)\\n            {\\n                ans++;\\n                end = inter[i][1];\\n            }\\n            else if(inter[i][0]>=end || inter[i][1]>=end)\\n            {\\n                st = inter[i][0];\\n                end = max(end,inter[i][1]);\\n            }\\n        }\\n        return inter.size()-ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561311,
                "title": "c-clean-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = intervals.size();\\n\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        for (int i = 0; i < intervals.size()-1; i++) {\\n            // ex: (1, 2) & (1, 4) -> remove (1, 2)\\n            if (intervals[i][0] == intervals[i+1][0]) {\\n                if (intervals[i][1] < intervals[i+1][1]) {\\n                    result--;\\n                    continue;\\n                }\\n            }\\n\\n            // ex: (1, 4) & (2, 8) -> seperate intervals\\n            if (intervals[i][1] < intervals[i+1][1]) continue;\\n\\n            // ex: (2, 8) & (3, 6) -> remove (3, 6)\\n            intervals[i+1] = intervals[i];\\n            result--;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = intervals.size();\\n\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        for (int i = 0; i < intervals.size()-1; i++) {\\n            // ex: (1, 2) & (1, 4) -> remove (1, 2)\\n            if (intervals[i][0] == intervals[i+1][0]) {\\n                if (intervals[i][1] < intervals[i+1][1]) {\\n                    result--;\\n                    continue;\\n                }\\n            }\\n\\n            // ex: (1, 4) & (2, 8) -> seperate intervals\\n            if (intervals[i][1] < intervals[i+1][1]) continue;\\n\\n            // ex: (2, 8) & (3, 6) -> remove (3, 6)\\n            intervals[i+1] = intervals[i];\\n            result--;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174581,
                "title": "java-code-with-comments",
                "content": "```\\n\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n        // Sort the intervals (l, r) based on \\'l\\' value. \\n        // If two intervals have same \\'l\\' value sort them based on highest \\'r\\' value.\\n        Arrays.sort(intervals, (interval1, interval2) -> {\\n            if (interval1[0] != interval2[0]) {\\n               return interval1[0] - interval2[0]; \\n            } else {\\n                return interval2[1] - interval1[1]; \\n            }\\n            \\n        });\\n        \\n        int removed = 0;\\n        \\n        // Start with reference interval.\\n        int[] referenceInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            // Check if each interval is mergable by comparing it with our reference interval.\\n            // If the current interval is with in our reference interval merge the current interval\\n            // to reference interval.\\n            if (intervals[i][0] >= referenceInterval[0] && intervals[i][1] <= referenceInterval[1]) {\\n                // note that as part of merging there is no need to update the right value into our \\n                // reference interval as right value in reference interval is already the highest value.\\n                referenceInterval[0] =  intervals[i][0];\\n                removed++;\\n                continue;\\n            }\\n            // If not make current interval as our reference interval.\\n            referenceInterval = intervals[i];\\n        }\\n        \\n        // Return remaining intervals.\\n        return intervals.length - removed;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n        // Sort the intervals (l, r) based on \\'l\\' value. \\n        // If two intervals have same \\'l\\' value sort them based on highest \\'r\\' value.\\n        Arrays.sort(intervals, (interval1, interval2) -> {\\n            if (interval1[0] != interval2[0]) {\\n               return interval1[0] - interval2[0]; \\n            } else {\\n                return interval2[1] - interval1[1]; \\n            }\\n            \\n        });\\n        \\n        int removed = 0;\\n        \\n        // Start with reference interval.\\n        int[] referenceInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            // Check if each interval is mergable by comparing it with our reference interval.\\n            // If the current interval is with in our reference interval merge the current interval\\n            // to reference interval.\\n            if (intervals[i][0] >= referenceInterval[0] && intervals[i][1] <= referenceInterval[1]) {\\n                // note that as part of merging there is no need to update the right value into our \\n                // reference interval as right value in reference interval is already the highest value.\\n                referenceInterval[0] =  intervals[i][0];\\n                removed++;\\n                continue;\\n            }\\n            // If not make current interval as our reference interval.\\n            referenceInterval = intervals[i];\\n        }\\n        \\n        // Return remaining intervals.\\n        return intervals.length - removed;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797740,
                "title": "sort-left-in-ascending-and-right-in-descending-by-using-custom-comparator-function-c",
                "content": "sort left ascending and right decending\\nIn this solution, we sort on left first.\\nWhen left are same, we sort right in decending order.\\n\\nFor example: [[1,5],[1,4],[1,3],[1,2]]\\n\\nComplexity: time O(sort), space O(sort)\\n\\n```\\n#define all(x) (x).begin(),(x).end()\\nclass Solution {\\npublic:\\n    // here is custom comparator function to sort left in ascending and right in descending\\n    \\n    static bool cmp(vector<int>&v1,vector<int>&v2){\\n          if (v1[0] != v2[0]) {\\n        return v1[0] < v2[0];\\n    }\\n    return v1[1] > v2[1];\\n    }\\n\\t\\npublic:\\n   \\n    int removeCoveredIntervals(vector<vector<int>>&v) {\\n             \\n         int n=v.size();\\n         sort(all(v),cmp);\\n         int cnt=1;\\n         int l=v[0][0],r=v[0][1];\\n        for(int i=1;i<n;i++){\\n            // here no need to check for left value as we have sorted left value in ascending order\\n            // so it will always less than current one\\n            if(v[i][1]>r){\\n                // when we get right greater than previous one we increment count by 1\\n                // and set right value to current one\\n                cnt++;\\n                r=v[i][1];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n#define all(x) (x).begin(),(x).end()\\nclass Solution {\\npublic:\\n    // here is custom comparator function to sort left in ascending and right in descending\\n    \\n    static bool cmp(vector<int>&v1,vector<int>&v2){\\n          if (v1[0] != v2[0]) {\\n        return v1[0] < v2[0];\\n    }\\n    return v1[1] > v2[1];\\n    }\\n\\t\\npublic:\\n   \\n    int removeCoveredIntervals(vector<vector<int>>&v) {\\n             \\n         int n=v.size();\\n         sort(all(v),cmp);\\n         int cnt=1;\\n         int l=v[0][0],r=v[0][1];\\n        for(int i=1;i<n;i++){\\n            // here no need to check for left value as we have sorted left value in ascending order\\n            // so it will always less than current one\\n            if(v[i][1]>r){\\n                // when we get right greater than previous one we increment count by 1\\n                // and set right value to current one\\n                cnt++;\\n                r=v[i][1];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786948,
                "title": "python-solution-sort-simple-2-approaches",
                "content": "**Approach 1:**\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        each = 0\\n        while each < len(intervals)-1:\\n            first, second = intervals[each], intervals[each+1]\\n            if first[0]>=second[0] and first[1]<=second[1]:\\n                intervals.pop(each)\\n            elif first[0]<=second[0] and first[1]>=second[1]:\\n                intervals.pop(each+1)\\n            else:\\n                each+=1\\n        return len(intervals)\\n```\\n\\n**Approach 2:**\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda i:(i[0], -i[1]))\\n        result = [intervals[0]]\\n        for l, r in intervals[1:]:\\n            prevL, prevR = result[-1]\\n            if prevL <= l and prevR >= r:\\n                continue\\n            result.append([l, r])\\n        return len(result)\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        each = 0\\n        while each < len(intervals)-1:\\n            first, second = intervals[each], intervals[each+1]\\n            if first[0]>=second[0] and first[1]<=second[1]:\\n                intervals.pop(each)\\n            elif first[0]<=second[0] and first[1]>=second[1]:\\n                intervals.pop(each+1)\\n            else:\\n                each+=1\\n        return len(intervals)\\n```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda i:(i[0], -i[1]))\\n        result = [intervals[0]]\\n        for l, r in intervals[1:]:\\n            prevL, prevR = result[-1]\\n            if prevL <= l and prevR >= r:\\n                continue\\n            result.append([l, r])\\n        return len(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786160,
                "title": "c-o-nlogn-custom-2d-vector-sort",
                "content": "Approach: \\n* Sort the given list where left is ascending order and right is descending order\\n* Traverse the sorted list and compare with previous position of the list. \\n* If the right interval of previous position is smaller than the current position, save the previous position and increase the result by 1.\\n```\\nbool cmp (const vector<int>& left, const vector<int>& right)\\n    {\\n        if(left[0] != right[0])\\n            return left[0] < right[0];\\n        return left[1] > right[1];\\n    }\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int intervalCount = intervals.size();\\n        int result = 1, prevPos = 0;\\n        for(int i = 1; i<intervalCount; i++){\\n            if(intervals[i][1] > intervals[prevPos][1]){\\n                prevPos = i, result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool cmp (const vector<int>& left, const vector<int>& right)\\n    {\\n        if(left[0] != right[0])\\n            return left[0] < right[0];\\n        return left[1] > right[1];\\n    }\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int intervalCount = intervals.size();\\n        int result = 1, prevPos = 0;\\n        for(int i = 1; i<intervalCount; i++){\\n            if(intervals[i][1] > intervals[prevPos][1]){\\n                prevPos = i, result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785828,
                "title": "simple-solution",
                "content": "Simple solution using for loop.\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    let count = intervals.length\\n    for (var [index1, i1] of intervals.entries()) {\\n        for (var [index2, i2] of intervals.entries()) {\\n            if (index2 !== index1) {\\n                if (i2[0] <= i1[0] && i1[1] <= i2[1]) {\\n                    count--\\n                    break\\n                }   \\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    let count = intervals.length\\n    for (var [index1, i1] of intervals.entries()) {\\n        for (var [index2, i2] of intervals.entries()) {\\n            if (index2 !== index1) {\\n                if (i2[0] <= i1[0] && i1[1] <= i2[1]) {\\n                    count--\\n                    break\\n                }   \\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785721,
                "title": "simple-java-solution-with-explaination-nlogn",
                "content": "Idea is sort the array according to start interval in increasing order. if start is same then use end interval to sort in decreasing order. \\n```\\n\\tprivate int compare(int[] a, int[] b) {\\n\\t\\tif (a[0] == b[0]) {\\n\\t\\t\\treturn b[1] - a[1];\\n\\t\\t}\\n\\t\\treturn a[0] - b[0];\\n\\t}\\n```\\n\\ne.g. ->\\ni/p -> [[1, 2],[1, 4],[3, 4]]\\nsort -> [[1, 4],[1, 2],[3, 4]]\\n\\ni/p->[[1, 4],[3, 6],[2, 8]]\\nsort -> [[1, 4],[2, 8],[3, 6]]\\n\\ni/p -> [[3, 11],[5, 12],[4, 10]]\\nsort-> [[3, 11],[4, 10],[5, 12]]\\n\\nso by this we can see if current element start<=next element start and current element end>= next element end, consume it and increment counter to indicate one element is deleted. as soon as above condition met try to consume as many as we can.\\nbasically check how many elements we can consume with in current element start and end boundary.\\nnow after first iteration we have consumed what max possible. now again repeat same step for next current element start and end.\\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tArrays.sort(intervals, this::compare);\\n\\t\\tint i = 0;\\n\\t\\t//counter to store deleted elements count.\\n\\t\\tint c = 0;\\n\\t\\t//iterate every element\\n\\t\\twhile (i < intervals.length) {\\n\\t\\t//set current element as min and max\\n\\t\\t\\tint min = intervals[i][0];\\n\\t\\t\\tint max = intervals[i][1];\\n\\t\\t\\t//check how many elements we can consume with in current min and max\\n\\t\\t\\twhile (i < intervals.length - 1 && min <= intervals[i + 1][0] && max >= intervals[i + 1][1]) {\\n\\t\\t\\t\\tc++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\t//return length of new array after deletion.\\n\\t\\treturn intervals.length - c;\\n\\t}\\n\\t//sort\\n\\tprivate int compare(int[] a, int[] b) {\\n\\t\\tif (a[0] == b[0]) {\\n\\t\\t\\treturn b[1] - a[1];\\n\\t\\t}\\n\\t\\treturn a[0] - b[0];\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\tprivate int compare(int[] a, int[] b) {\\n\\t\\tif (a[0] == b[0]) {\\n\\t\\t\\treturn b[1] - a[1];\\n\\t\\t}\\n\\t\\treturn a[0] - b[0];\\n\\t}\\n```\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tArrays.sort(intervals, this::compare);\\n\\t\\tint i = 0;\\n\\t\\t//counter to store deleted elements count.\\n\\t\\tint c = 0;\\n\\t\\t//iterate every element\\n\\t\\twhile (i < intervals.length) {\\n\\t\\t//set current element as min and max\\n\\t\\t\\tint min = intervals[i][0];\\n\\t\\t\\tint max = intervals[i][1];\\n\\t\\t\\t//check how many elements we can consume with in current min and max\\n\\t\\t\\twhile (i < intervals.length - 1 && min <= intervals[i + 1][0] && max >= intervals[i + 1][1]) {\\n\\t\\t\\t\\tc++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\t//return length of new array after deletion.\\n\\t\\treturn intervals.length - c;\\n\\t}\\n\\t//sort\\n\\tprivate int compare(int[] a, int[] b) {\\n\\t\\tif (a[0] == b[0]) {\\n\\t\\t\\treturn b[1] - a[1];\\n\\t\\t}\\n\\t\\treturn a[0] - b[0];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785524,
                "title": "c-solution-using-vector-of-pair",
                "content": "The intuition is that first we need first element as small as possible and second element as large as possible .\\nSo we make a pair and sort it by first element in ascending order and second element in descending order using a comparator.\\nThen simply iterate through all elements and whenever we get second element greater than previous greater we update mx and increase ans.\\n\\nTime complexity: time to sort the pair ```O(sort)```.\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Comparator to sort pair by first element in ascending order  and then by second element in descending order\\n    \\n    template<typename P> struct Cmp \\n{ \\n    bool operator()(const P &p1, const P &p2) \\n    { \\n        if(p1.first < p2.first) return true; \\n        if(p1.first == p2.first) return p1.second > p2.second; \\n        return false; \\n    } \\n};\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<pair<int,int>>p;\\n        for(int i=0;i<n;i++){\\n            p.push_back({intervals[i][0],intervals[i][1]});\\n        }\\n        sort(p.begin(),p.end(),Cmp<pair<int,int>>());\\n        int mx=p[0].second;\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(p[i].second>mx){\\n                mx=p[i].second;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nfurther the question can be dveloped to return the intervals which remains after removing covered elements.\\nIn this case we can modify pair and comparator accordingly ,here we use pair of pair to store index of intervals so that we can obtain original sequence.\\nAnd store ans in another vector.\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    template<typename P> struct Cmp \\n{ \\n    bool operator()(const P &p1, const P &p2) \\n    { \\n        if(p1.first < p2.first) return true; \\n        if(p1.first == p2.first) return p1.second.first > p2.second.first; \\n        return false; \\n    } \\n};\\n    vector<vector<int>> removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        int temp[n];\\n        vector<pair<int,pair<int,int>>>p;\\n        for(int i=0;i<n;i++){\\n            temp[i]=1;\\n            p.push_back({intervals[i][0],{intervals[i][1],i}});\\n        }\\n        sort(p.begin(),p.end(),Cmp<pair<int,pair<int,int>>>());\\n        int mx=p[0].second.first;\\n        for(int i=1;i<n;i++){\\n            if(p[i].second.first>mx){\\n                mx=p[i].second.first;\\n            }else{\\n                temp[p[i].second.second]=0;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++){\\n            if(temp[i]!=0)\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease do upvote if helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```O(sort)```\n```\\nclass Solution {\\npublic:\\n    \\n    // Comparator to sort pair by first element in ascending order  and then by second element in descending order\\n    \\n    template<typename P> struct Cmp \\n{ \\n    bool operator()(const P &p1, const P &p2) \\n    { \\n        if(p1.first < p2.first) return true; \\n        if(p1.first == p2.first) return p1.second > p2.second; \\n        return false; \\n    } \\n};\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<pair<int,int>>p;\\n        for(int i=0;i<n;i++){\\n            p.push_back({intervals[i][0],intervals[i][1]});\\n        }\\n        sort(p.begin(),p.end(),Cmp<pair<int,int>>());\\n        int mx=p[0].second;\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(p[i].second>mx){\\n                mx=p[i].second;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    template<typename P> struct Cmp \\n{ \\n    bool operator()(const P &p1, const P &p2) \\n    { \\n        if(p1.first < p2.first) return true; \\n        if(p1.first == p2.first) return p1.second.first > p2.second.first; \\n        return false; \\n    } \\n};\\n    vector<vector<int>> removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        int temp[n];\\n        vector<pair<int,pair<int,int>>>p;\\n        for(int i=0;i<n;i++){\\n            temp[i]=1;\\n            p.push_back({intervals[i][0],{intervals[i][1],i}});\\n        }\\n        sort(p.begin(),p.end(),Cmp<pair<int,pair<int,int>>>());\\n        int mx=p[0].second.first;\\n        for(int i=1;i<n;i++){\\n            if(p[i].second.first>mx){\\n                mx=p[i].second.first;\\n            }else{\\n                temp[p[i].second.second]=0;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++){\\n            if(temp[i]!=0)\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785482,
                "title": "c-80-faster-2-pointers-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static com(vector<int>&a,vector<int>&b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& box) \\n    {\\n        //diamond notes\\n        //sort as mentioned above \\n        //and then make 2 pointers i=1,j=1,and check if condtions satisfy then do i++ until it is satisfied and then do c++ and put some conditons for edge cases.\\n        sort(box.begin(),box.end(),com);\\n        int c=0;\\n        int i=1;\\n        int j=0;\\n        bool ch=true;\\n        while(i<box.size() && j<box.size())\\n        {\\n            while(i<box.size() && box[j][0]<=box[i][0] && box[j][1]>=box[i][1])\\n            {\\n                ch=false;\\n                i++;\\n            }\\n            c++;\\n            j=i;\\n            i++;\\n        }\\n        if(j<box.size())c++;\\n        if(c==0)return 1;\\n        if(ch)return box.size();\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static com(vector<int>&a,vector<int>&b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& box) \\n    {\\n        //diamond notes\\n        //sort as mentioned above \\n        //and then make 2 pointers i=1,j=1,and check if condtions satisfy then do i++ until it is satisfied and then do c++ and put some conditons for edge cases.\\n        sort(box.begin(),box.end(),com);\\n        int c=0;\\n        int i=1;\\n        int j=0;\\n        bool ch=true;\\n        while(i<box.size() && j<box.size())\\n        {\\n            while(i<box.size() && box[j][0]<=box[i][0] && box[j][1]>=box[i][1])\\n            {\\n                ch=false;\\n                i++;\\n            }\\n            c++;\\n            j=i;\\n            i++;\\n        }\\n        if(j<box.size())c++;\\n        if(c==0)return 1;\\n        if(ch)return box.size();\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785129,
                "title": "memory-100-00-time-24-ms-in-c-very-simple-solution-inline-sort",
                "content": "If first value is equal then we will check second value.\\n\\n\\u2B06\\uFE0F **Please Upvote**\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& v) {\\n        \\n        \\n        sort( v.begin( ), v.end( ), [ ]( const auto& lhs, const auto& rhs )\\n            {\\n                if(lhs[0] == rhs[0]) return lhs[1] > rhs[1];\\n                return lhs[0] < rhs[0];\\n            });\\n        \\n        \\n        int n = v.size(), ans = 1, pos = 0;\\n        for(int i = 1; i<n; i++) {\\n            if(v[i][1] <= v[pos][1]) continue;\\n            ++ans;\\n            pos = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& v) {\\n        \\n        \\n        sort( v.begin( ), v.end( ), [ ]( const auto& lhs, const auto& rhs )\\n            {\\n                if(lhs[0] == rhs[0]) return lhs[1] > rhs[1];\\n                return lhs[0] < rhs[0];\\n            });\\n        \\n        \\n        int n = v.size(), ans = 1, pos = 0;\\n        for(int i = 1; i<n; i++) {\\n            if(v[i][1] <= v[pos][1]) continue;\\n            ++ans;\\n            pos = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780969,
                "title": "python-simple-solution-easy-90-fast-and-space",
                "content": "```\\n\\t    inte.sort(key=lambda x:x[0])\\n        count=0\\n        for i in range(1,len(inte)):\\n            if inte[i-1][0]<=inte[i][0] and inte[i-1][1]>=inte[i][1]:\\n                inte[i]=inte[i-1]\\n                count+=1\\n            elif inte[i-1][0]==inte[i][0] and inte[i-1][1]<=inte[i][1]:\\n                count+=1\\n        return len(inte)-count\\n```",
                "solutionTags": [],
                "code": "```\\n\\t    inte.sort(key=lambda x:x[0])\\n        count=0\\n        for i in range(1,len(inte)):\\n            if inte[i-1][0]<=inte[i][0] and inte[i-1][1]>=inte[i][1]:\\n                inte[i]=inte[i-1]\\n                count+=1\\n            elif inte[i-1][0]==inte[i][0] and inte[i-1][1]<=inte[i][1]:\\n                count+=1\\n        return len(inte)-count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429212,
                "title": "two-golang-solutions-with-images-for-explanation",
                "content": "In both of these solutions we sort `intervals` by the following:\\n\\n* If `intervals[i][0]` equals `intervals[j][0]` we can return the decending order of `intervals[i][1]` and `intervals[j][1]`.\\n* else, we can return the increasing order of `intervals[i][0]`, and `intervals[j][0]`.\\n\\nSince we sort `intervals` by their start values. For example, we don\\'t have to worry about `c <= a` if we have the intervals `[a, b)`, and `[c, d)`.\\n\\nAnd since we have sorted `intervals` by their end values if their start values are equal. All we have to do is check whether `d >= b` if we have the intervals `[a, b)`, and `[c, d)`. \\n\\n**Solution One:**\\n---\\n\\nIn this solution, we remove intervals from `intervals`.\\n\\n![](https://i.imgur.com/gqLasto.png)\\n\\n``` go\\nfunc removeCoveredIntervals(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] > intervals[j][1]\\n        }\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    for i := 0; i < len(intervals) - 1; i++ {\\n        if intervals[i][1] >= intervals[i + 1][1] {\\n            intervals = append(intervals[:i + 1], intervals[i + 2:]...)\\n            i--\\n        }\\n    }\\n    return len(intervals)\\n}\\n```\\n\\n**Solution 2:**\\n---\\n\\nIn this solution, we just count the remaining intervals.\\n\\n![image](https://assets.leetcode.com/users/images/cc8fcb19-0d9b-4763-8dbd-193c6d0f08aa_1630075203.7147284.png)\\n\\n``` go\\nfunc removeCoveredIntervals(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] > intervals[j][1]\\n        }\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    end, res := 0, 0\\n    \\n    for _, interval := range intervals {\\n        if interval[1] > end {\\n            end = interval[1]\\n            res++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc removeCoveredIntervals(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] > intervals[j][1]\\n        }\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    for i := 0; i < len(intervals) - 1; i++ {\\n        if intervals[i][1] >= intervals[i + 1][1] {\\n            intervals = append(intervals[:i + 1], intervals[i + 2:]...)\\n            i--\\n        }\\n    }\\n    return len(intervals)\\n}\\n```\n``` go\\nfunc removeCoveredIntervals(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] > intervals[j][1]\\n        }\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    end, res := 0, 0\\n    \\n    for _, interval := range intervals {\\n        if interval[1] > end {\\n            end = interval[1]\\n            res++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127260,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-log-n-time-o-1-space",
                "content": "**Explanation**\\nThe idea is to sort the array in ascending order in regards to the start value of each interval. This guarantees that each interval to the right of a given interval has a start value which is either equal to or greater than the given start value.\\nIntervals with the same start value are sorted in descending order in regards to the end value within their bucket (a subarray consisting of intervals with the same start value). If we examine the first interval of a bucket, we will achieve a maximum converage within the bucket.\\n\\nAfter sorting, we loop through the intervals from left to right and check if the end value of each interval is greater than the currently highest one. If this is the case, the interval with the previously highest end value does not cover the given interval so it does not need to be removed. The highest end value will then be replaced by the given one, again guaranteeing a maximum coverage because the higher the end value, the more candidates might be covered by the given interval.\\nIn any other case, a coverage is given and a deletion will be required.\\n________________________\\n**Definitions**\\n`n`: Size of the input list.\\n________________________\\n**Runtime Complexity**\\n`O(n * log(n))` (sort).\\n_______________________\\n**Space Complexity**\\n`O(1)`\\n_______________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[0], -x[1],))\\n        output = len(intervals)\\n        end = intervals[0][1]\\n        \\n        for i in range(1, len(intervals)):\\n            if intervals[i][1] <= end:\\n                output -= 1\\n            else:\\n                end = intervals[i][1]\\n                \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[0], -x[1],))\\n        output = len(intervals)\\n        end = intervals[0][1]\\n        \\n        for i in range(1, len(intervals)):\\n            if intervals[i][1] <= end:\\n                output -= 1\\n            else:\\n                end = intervals[i][1]\\n                \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879224,
                "title": "python-3-solution-with-a-detailed-walk-through",
                "content": "While the solution has more lines of codes than the official, this one feels more natural in case of a real interview.\\n\\n**Idea**:\\nWe will count intervals ```cnt``` that are overlapped. Then the result with be ```len(intervals) - cnt```.\\nWe sort ```intervals``` by the first element and by the negative value of the last element. Thus, we ensure that the first interval in sorted ```intervals``` will be an interval that starts the earliest but goes as far right as possible. \\n\\n*Example: between [8, 21] and [8, 23], the element [8, 23] will go first because it\\'s wider.*\\n\\nThen we initialize ```curr_st``` and ```curr_end```: current start and current end. They\\'re equal to the borders of the first element.\\nIn a loop, let\\'s compare consecutive elements\\' borders with ```curr_st``` and ```curr_end```. If we see that the whole element lays between ```curr_st``` and ```curr_end```, then we will increment ```cnt```.\\nThe trickly part is how to move ```curr_st``` and ```curr_end``` along the list. Apparently, we will move ```curr_st``` in any case but will move ```curr_end``` iff the right border of the list\\'s element is larger than the current value of ```curr_end``` (because we want to have ```curr_end``` as far right as possible in order to capture next elements that potentially will start and end before ```curr_end```). \\n\\n```\\ndef removeCoveredIntervals(intervals):\\n    cnt = 0\\n    intervals.sort(key = lambda x: (x[0], -x[1]))\\n    curr_st, curr_end = intervals[0][0], intervals[0][1]\\n    for interval in intervals[1:]:\\n        if curr_st <= interval[0] < curr_end and curr_st < interval[1] <= curr_end:\\n            cnt += 1\\n        curr_st = interval[0]\\n        curr_end = max(curr_end, interval[1])\\n    return len(intervals) - cnt\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```cnt```\n```len(intervals) - cnt```\n```intervals```\n```intervals```\n```curr_st```\n```curr_end```\n```curr_st```\n```curr_end```\n```curr_st```\n```curr_end```\n```cnt```\n```curr_st```\n```curr_end```\n```curr_st```\n```curr_end```\n```curr_end```\n```curr_end```\n```curr_end```\n```\\ndef removeCoveredIntervals(intervals):\\n    cnt = 0\\n    intervals.sort(key = lambda x: (x[0], -x[1]))\\n    curr_st, curr_end = intervals[0][0], intervals[0][1]\\n    for interval in intervals[1:]:\\n        if curr_st <= interval[0] < curr_end and curr_st < interval[1] <= curr_end:\\n            cnt += 1\\n        curr_st = interval[0]\\n        curr_end = max(curr_end, interval[1])\\n    return len(intervals) - cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 878686,
                "title": "100-faster-c-36ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& a) {\\n        \\n        sort(a.begin(),a.end(),[](const vector<int>& x,const vector<int>& y){\\n            return x[0] < y[0]; \\n        });\\n        \\n        int s = a[0][0];\\n        int e = a[0][1];\\n        \\n        int c = a.size();\\n        \\n        for(int i=1;i<a.size();i++){\\n            if(s == a[i][0]){\\n                c--;\\n                e = max(e,a[i][1]);\\n            }\\n            else if(e == a[i][1]){\\n                c--;\\n                s = min(s,a[i][0]);\\n            }\\n            else if(s < a[i][0] && e > a[i][1]){\\n                c--;\\n                s = min(s,a[i][0]);\\n                e = max(e,a[i][1]);\\n            }\\n            else {\\n                s = a[i][0];\\n                e = a[i][1];\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& a) {\\n        \\n        sort(a.begin(),a.end(),[](const vector<int>& x,const vector<int>& y){\\n            return x[0] < y[0]; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 878216,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        totalIntervals = len(intervals)\\n        for i in range(len(intervals)):\\n            for j in range(len(intervals)):\\n                if j!=i:\\n                    if intervals[j][0]<=intervals[i][0] and intervals[j][1]>=intervals[i][1]:\\n                        totalIntervals-=1\\n                        break\\n        return totalIntervals\\n                    \\n            \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        totalIntervals = len(intervals)\\n        for i in range(len(intervals)):\\n            for j in range(len(intervals)):\\n                if j!=i:\\n                    if intervals[j][0]<=intervals[i][0] and intervals[j][1]>=intervals[i][1]:\\n                        totalIntervals-=1\\n                        break\\n        return totalIntervals\\n                    \\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 878123,
                "title": "java-heap-4-ms",
                "content": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        public int x, y;\\n        \\n        public Pair(int a, int b){\\n            this.x = a;\\n            this.y = b;\\n        }\\n        \\n        public int compareTo(Pair p){\\n            if(this.x == p.x)\\n                return p.y - this.y;   // if x matches then sort in descending order of y\\n            else\\n                return this.x - p.x;   // else sort in ascending order of x\\n        }\\n    }\\n    \\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int N = intervals.length;\\n        int i;\\n        PriorityQueue<Pair> queue = new PriorityQueue<Pair>();\\n        \\n        for(i = 0; i < N; i++){\\n            queue.offer(new Pair(intervals[i][0], intervals[i][1]));\\n        }\\n        \\n        Pair latest = new Pair(Integer.MIN_VALUE, Integer.MIN_VALUE);\\n        int count = 0;\\n        Pair p = null;\\n        \\n        while(!queue.isEmpty()){\\n            p = queue.poll();\\n            // check if p is NOT inside latest\\n            if(count == 0 || !(latest.x <= p.x && latest.y >= p.y)){\\n                latest = p;\\n                ++count;\\n            }\\n        }\\n    \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        public int x, y;\\n        \\n        public Pair(int a, int b){\\n            this.x = a;\\n            this.y = b;\\n        }\\n        \\n        public int compareTo(Pair p){\\n            if(this.x == p.x)\\n                return p.y - this.y;   // if x matches then sort in descending order of y\\n            else\\n                return this.x - p.x;   // else sort in ascending order of x\\n        }\\n    }\\n    \\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int N = intervals.length;\\n        int i;\\n        PriorityQueue<Pair> queue = new PriorityQueue<Pair>();\\n        \\n        for(i = 0; i < N; i++){\\n            queue.offer(new Pair(intervals[i][0], intervals[i][1]));\\n        }\\n        \\n        Pair latest = new Pair(Integer.MIN_VALUE, Integer.MIN_VALUE);\\n        int count = 0;\\n        Pair p = null;\\n        \\n        while(!queue.isEmpty()){\\n            p = queue.poll();\\n            // check if p is NOT inside latest\\n            if(count == 0 || !(latest.x <= p.x && latest.y >= p.y)){\\n                latest = p;\\n                ++count;\\n            }\\n        }\\n    \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645755,
                "title": "sort-and-stack",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[0])\\n        remaining = []\\n        for interval in intervals:\\n            if not remaining:\\n                remaining.append(interval)\\n            else:\\n                prev = remaining[-1]\\n                if prev[0] == interval[0] and prev[1] < interval[1]:\\n                    remaining.pop()\\n                if prev[1] < interval[1]:\\n                    remaining.append(interval)\\n                \\n        return len(remaining)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[0])\\n        remaining = []\\n        for interval in intervals:\\n            if not remaining:\\n                remaining.append(interval)\\n            else:\\n                prev = remaining[-1]\\n                if prev[0] == interval[0] and prev[1] < interval[1]:\\n                    remaining.pop()\\n                if prev[1] < interval[1]:\\n                    remaining.append(interval)\\n                \\n        return len(remaining)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558963,
                "title": "c-its-more-like-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int count=0;\\n        int len=intervals.size();\\n        int flag=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            flag=0;\\n            for(int j=i-1;j>=0 && flag==0;j--)\\n            {\\n                if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<=intervals[j][1] )\\n                {\\n                    count++;\\n                    flag=1;\\n                }\\n            }\\n            for(int j=i+1;j<len && flag==0;j++)\\n            {\\n                if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<=intervals[j][1] )\\n                {\\n                    count++;\\n                    flag=1;\\n                }\\n            }\\n        }\\n        return len-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int count=0;\\n        int len=intervals.size();\\n        int flag=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            flag=0;\\n            for(int j=i-1;j>=0 && flag==0;j--)\\n            {\\n                if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<=intervals[j][1] )\\n                {\\n                    count++;\\n                    flag=1;\\n                }\\n            }\\n            for(int j=i+1;j<len && flag==0;j++)\\n            {\\n                if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<=intervals[j][1] )\\n                {\\n                    count++;\\n                    flag=1;\\n                }\\n            }\\n        }\\n        return len-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505856,
                "title": "easy-cpp-solution-sort-runtime-99-memory-usage-100",
                "content": "```\\nint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b) {\\n            if (a[0] != b[0]) return a[0] < b[0];\\n            return a[1] - a[0] >= b[1] - b[0];\\n        });\\n        int cnt = 1, left = intervals[0][0], right = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] == left && intervals[i][1] > right) {\\n                right = intervals[i][1];\\n            } else if (intervals[i][0] > left  && intervals[i][1] > right) {\\n                cnt++;\\n                left = intervals[i][0];\\n                right = intervals[i][1];\\n            }\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [],
                "code": "```\\nint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b) {\\n            if (a[0] != b[0]) return a[0] < b[0];\\n            return a[1] - a[0] >= b[1] - b[0];\\n        });\\n        int cnt = 1, left = intervals[0][0], right = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] == left && intervals[i][1] > right) {\\n                right = intervals[i][1];\\n            } else if (intervals[i][0] > left  && intervals[i][1] > right) {\\n                cnt++;\\n                left = intervals[i][0];\\n                right = intervals[i][1];\\n            }\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 505817,
                "title": "simple-java-solution-with-priority-queue",
                "content": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> a[0] - b[0]);\\n        \\n        for(int[] interval : intervals)\\n            pq.offer(interval);\\n        \\n        int[] latest = {-1,-1};\\n        int count = 0;\\n        while(!pq.isEmpty())\\n        {\\n           int[] polled = pq.poll(); \\n           if(count == 0 || !(latest[0] <= polled[0] && latest[1] >= polled[1]))\\n           {\\n               latest = polled;\\n               count++;\\n           }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> a[0] - b[0]);\\n        \\n        for(int[] interval : intervals)\\n            pq.offer(interval);\\n        \\n        int[] latest = {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 471735,
                "title": "c-clear-concise-70-90",
                "content": "Basic idea: \\n- Sort \\n- Loop through the intervals: decrease the counter (# intervals after removal) when the max end is no less than the end of the current interval\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int res = intervals.size(), mx = 0;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& v: intervals) {\\n            if (mx >= v[1]) \\n                res--;\\n            else\\n                mx = v[1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int res = intervals.size(), mx = 0;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& v: intervals) {\\n            if (mx >= v[1]) \\n                res--;\\n            else\\n                mx = v[1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464407,
                "title": "a-simple-java-solution-faster-than-90-34-accepted-runtime-5-ms",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,new Comparator<int[]>(){\\n           public int compare(int[] o1,int[] o2){\\n               // return o1[0]-o2[0];\\n\\t\\t\\t   return o1[0]-o2[0]!=0?o1[0]-o2[0]:o2[1]-o1[1];\\n           } \\n        });\\n        int max=intervals[0][1];\\n        int ret=intervals.length;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[i][1]<=max){\\n                ret--;\\n            }else{\\n                max=intervals[i][1];\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,new Comparator<int[]>(){\\n           public int compare(int[] o1,int[] o2){\\n               // return o1[0]-o2[0];\\n\\t\\t\\t   return o1[0]-o2[0]!=0?o1[0]-o2[0]:o2[1]-o1[1];\\n           } \\n        });\\n        int max=intervals[0][1];\\n        int ret=intervals.length;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[i][1]<=max){\\n                ret--;\\n            }else{\\n                max=intervals[i][1];\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451362,
                "title": "java-solution-with-and-without-sort",
                "content": "**With sorting**:\\n\\nSorting makes it obvious that we get smallest intervals first and just keep mapping the previous big interval and the current interval to get the solution.\\n```\\nclass Solution {\\n    static class Data{\\n        int x,y;\\n        Data(int x,int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Data[] d = new Data[intervals.length];\\n        for(int i=0;i<intervals.length;++i) d[i] = new Data(intervals[i][0],intervals[i][1]);\\n        Arrays.sort(d,new Comparator<Data>(){\\n            public int compare(Data d1,Data d2){\\n                if(d1.x < d2.x) return -1;\\n                if(d2.x < d1.x) return 1;\\n                return -1 * (d1.y - d2.y);\\n            }\\n        });\\n        \\n        int rem = 1,prev = 0;\\n        \\n        for(int i=1;i<d.length;++i){\\n            if(d[i].x >= d[prev].x && d[i].y <= d[prev].y) continue;\\n            prev = i;\\n            rem++;\\n        }\\n        \\n        return rem;\\n    }\\n}\\n```\\n\\n**Without Sorting:**\\n\\n* We can make use of the constraints `0 <= intervals[i][0] < intervals[i][1] <= 10^5` a bit.\\n* Every interval has a start and an end.\\n* In this approach, we map the start with it\\'s best end.\\n* So for example, for `[[1,4],[3,6],[2,8],[1,20]]`, the table(as in `pairs` array) would look like:\\n\\n   * 1 => 20\\n   * 2 => 8\\n   * 3 => 6\\n* Now, we just percolate down from `1` to `3` keeping the best end at hand.\\n* In the above example, we keep `20` with us first. Since it annihilates everything, it is the only interval that remains. \\n* If we get a new end greater than the current one, we update the `prev` in the below code accordingly.\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n       int[] pairs = new int[100001];\\n       int start = -1,end = -1;\\n       for(int i=0;i<intervals.length;++i){\\n           pairs[intervals[i][0]] = Math.max(pairs[intervals[i][0]],intervals[i][1]);\\n           if(start == -1 || start > intervals[i][0]) start = intervals[i][0];\\n           if(end == -1 || end < intervals[i][1]) end = intervals[i][1];\\n       } \\n        \\n       int rem = 0,prev = 0;\\n       for(int i=start;i<=end;++i){\\n           if(pairs[i] > prev){\\n               rem++;\\n               prev = pairs[i];\\n           }\\n       } \\n        \\n       return rem; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static class Data{\\n        int x,y;\\n        Data(int x,int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Data[] d = new Data[intervals.length];\\n        for(int i=0;i<intervals.length;++i) d[i] = new Data(intervals[i][0],intervals[i][1]);\\n        Arrays.sort(d,new Comparator<Data>(){\\n            public int compare(Data d1,Data d2){\\n                if(d1.x < d2.x) return -1;\\n                if(d2.x < d1.x) return 1;\\n                return -1 * (d1.y - d2.y);\\n            }\\n        });\\n        \\n        int rem = 1,prev = 0;\\n        \\n        for(int i=1;i<d.length;++i){\\n            if(d[i].x >= d[prev].x && d[i].y <= d[prev].y) continue;\\n            prev = i;\\n            rem++;\\n        }\\n        \\n        return rem;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n       int[] pairs = new int[100001];\\n       int start = -1,end = -1;\\n       for(int i=0;i<intervals.length;++i){\\n           pairs[intervals[i][0]] = Math.max(pairs[intervals[i][0]],intervals[i][1]);\\n           if(start == -1 || start > intervals[i][0]) start = intervals[i][0];\\n           if(end == -1 || end < intervals[i][1]) end = intervals[i][1];\\n       } \\n        \\n       int rem = 0,prev = 0;\\n       for(int i=start;i<=end;++i){\\n           if(pairs[i] > prev){\\n               rem++;\\n               prev = pairs[i];\\n           }\\n       } \\n        \\n       return rem; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451265,
                "title": "sort-interval-compare-java",
                "content": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int n = intervals.length;\\n        int[] first = intervals[0];\\n        int count=1;\\n        for(int i=1;i<n;i++) {\\n            if(!covers(first,intervals[i])) {\\n                first = intervals[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private boolean covers(int[] a,int[] b) {\\n        return a[0]<=b[0] && a[1]>=b[1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int n = intervals.length;\\n        int[] first = intervals[0];\\n        int count=1;\\n        for(int i=1;i<n;i++) {\\n            if(!covers(first,intervals[i])) {\\n                first = intervals[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private boolean covers(int[] a,int[] b) {\\n        return a[0]<=b[0] && a[1]>=b[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3268710,
                "title": "c-sorting-nlogn",
                "content": "Sort the intervals according to their start time and for case where we start time is same, keep intervals befor whose end is greater, as it might cover more intervals with same start time. Not process these intervals and maintain what is the max current interval end point and its coresponding start time. Now if an interval overlaps increment the count and our max interval will remain same else update the mx interval to the current interval \\n\\nSee the diagram to visualise it.\\n\\n![image](https://assets.leetcode.com/users/images/52520111-364c-47c9-85ac-ffc6f64fca41_1678194732.8177066.png)\\n\\nCode \\n\\n```\\nbool comp(vector<int>A, vector<int>B){\\n        if(A[0] == B[0])\\n            return A[1] > B[1];\\n        return A[0] < B[0] ;\\n    }\\n\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),comp) ;\\n        int ans = 0 , n = intervals.size();\\n        pair<int, int>mx = {intervals[0][0], intervals[0][1]};\\n        for(int i = 1 ; i < n; i++){\\n            int start = intervals[i][0], end = intervals[i][1] ;\\n            if(mx.first<=start && mx.second >= end){\\n                ans ++ ;\\n            }\\n            else\\n                mx = {start, end};\\n        }\\n        \\n        return n - ans ;\\n    }\\n};\\n```\\n\\nTC- O(n log n)\\nSc - O(1)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>A, vector<int>B){\\n        if(A[0] == B[0])\\n            return A[1] > B[1];\\n        return A[0] < B[0] ;\\n    }\\n\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),comp) ;\\n        int ans = 0 , n = intervals.size();\\n        pair<int, int>mx = {intervals[0][0], intervals[0][1]};\\n        for(int i = 1 ; i < n; i++){\\n            int start = intervals[i][0], end = intervals[i][1] ;\\n            if(mx.first<=start && mx.second >= end){\\n                ans ++ ;\\n            }\\n            else\\n                mx = {start, end};\\n        }\\n        \\n        return n - ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613415,
                "title": "python-solution-simple-sorting",
                "content": "```\\nclass Solution:\\n    # Sort the intervals by beginning, with end reversed, so that the larger one with occur before the smaller one\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: [x[0], -x[1]])\\n        result, start_old, end_old = 0, -float(\\'inf\\'), -float(\\'inf\\')\\n        for start, end in intervals:\\n            if not end <= end_old:\\n                result += 1\\n                start_old, end_old = start, end\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Sort the intervals by beginning, with end reversed, so that the larger one with occur before the smaller one\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: [x[0], -x[1]])\\n        result, start_old, end_old = 0, -float(\\'inf\\'), -float(\\'inf\\')\\n        for start, end in intervals:\\n            if not end <= end_old:\\n                result += 1\\n                start_old, end_old = start, end\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518941,
                "title": "easy-python-stack-solution",
                "content": "```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        res=[]\\n        for i in sorted(intervals,key=lambda x:(x[1],-x[0])):\\n           while res and i[0]<=res[-1][0] and i[1]>=res[-1][1]:\\n                res.pop()\\n           res.append(i)\\n        return len(res)        \\n```",
                "solutionTags": [],
                "code": "```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        res=[]\\n        for i in sorted(intervals,key=lambda x:(x[1],-x[0])):\\n           while res and i[0]<=res[-1][0] and i[1]>=res[-1][1]:\\n                res.pop()\\n           res.append(i)\\n        return len(res)        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2296877,
                "title": "beats-100-percent-cpp-solutions-very-easy",
                "content": "class Solution {\\npublic:\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        if(a[0]>b[0])return false;\\n        if(a[0]==b[0] && b[1]>a[1])return false;\\n        return true;\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        int ans =0;\\n        int n=intervals.size();\\n        int y =intervals[0][1];\\n        for(int i =1;i<n;i++){\\n            if(y>=intervals[i][1]){\\n                ans++;\\n            }\\n            else{\\n                y=intervals[i][1];\\n            }\\n        }\\n        return n-ans;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        if(a[0]>b[0])return false;\\n        if(a[0]==b[0] && b[1]>a[1])return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2215102,
                "title": "simple-concise-c-heap-solution",
                "content": "Similar as the meeting scheduler\\nNote that the current pair don\\'t need to be updated every time.\\nAlso, there are 3 scenarios for whether to remove a pair (whether it is covered )\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        \\n        // Pair< start, end>\\n        // intervals are unique\\n        \\n        /*\\n            Algorithm:\\n            1. Use a min-heap <pair<int, int>> store intervals\\n               Sort by their \"start time\"\\n            2. Iterate until there is only one item in the heap\\n            \\n            3. Each time: pop one interval and compare with top()\\n               - Since pop.first must < top.first:\\n               - If pop.second(end time) > top.second(end time):\\n                 top() is covered by pop. remove top! (pop again)\\n               - count++;\\n               \\n            4. return count;\\n            \\n            Time: 1. build heap 2. iterate\\n                 O((N * logN))\\n            Space: O(N) for heap\\n        */\\n        \\n        \\n        priority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        \\n        for(auto interval: intervals){\\n            min_heap.push(make_pair(interval[0], interval[1]));\\n        }\\n        \\n        // At least one interval!\\n        int count=1;\\n      \\n        pair<int, int> cur;    \\n        // Becareful: update cur if needed!\\n        cur = min_heap.top(); min_heap.pop();\\n        \\n        // If only one item, don\\'t enter!\\n        while(!min_heap.empty()){\\n\\n            // Make next_cur the next top of the min_heap every iteration!\\n            pair<int, int> next_cur = min_heap.top();\\n            \\n            // e.g. cur: [2,8]  next_cur: [3,6]          \\n            if(cur.second >= next_cur.second){\\n                // Pop next_cur, cur remains\\n                min_heap.pop();               \\n            }\\n            // e.g. cur: [1,2]  next_cur: [1,4]\\n            else if(cur.first == next_cur.first && cur.second <= next_cur.second){\\n                // remove cur(already popped), update cur to be next_cur!\\n                cur = next_cur; min_heap.pop();  \\n            }\\n            // e.g. cur: [1,4] next_cur: [2,8]\\n            else{\\n                // update cur to be next_cur, count+1\\n                cur = next_cur; min_heap.pop();         \\n                count++;\\n            }\\n        }\\n        \\n        // At least one pair in intervals!\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        \\n        // Pair< start, end>\\n        // intervals are unique\\n        \\n        /*\\n            Algorithm:\\n            1. Use a min-heap <pair<int, int>> store intervals\\n               Sort by their \"start time\"\\n            2. Iterate until there is only one item in the heap\\n            \\n            3. Each time: pop one interval and compare with top()\\n               - Since pop.first must < top.first:\\n               - If pop.second(end time) > top.second(end time):\\n                 top() is covered by pop. remove top! (pop again)\\n               - count++;\\n               \\n            4. return count;\\n            \\n            Time: 1. build heap 2. iterate\\n                 O((N * logN))\\n            Space: O(N) for heap\\n        */\\n        \\n        \\n        priority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        \\n        for(auto interval: intervals){\\n            min_heap.push(make_pair(interval[0], interval[1]));\\n        }\\n        \\n        // At least one interval!\\n        int count=1;\\n      \\n        pair<int, int> cur;    \\n        // Becareful: update cur if needed!\\n        cur = min_heap.top(); min_heap.pop();\\n        \\n        // If only one item, don\\'t enter!\\n        while(!min_heap.empty()){\\n\\n            // Make next_cur the next top of the min_heap every iteration!\\n            pair<int, int> next_cur = min_heap.top();\\n            \\n            // e.g. cur: [2,8]  next_cur: [3,6]          \\n            if(cur.second >= next_cur.second){\\n                // Pop next_cur, cur remains\\n                min_heap.pop();               \\n            }\\n            // e.g. cur: [1,2]  next_cur: [1,4]\\n            else if(cur.first == next_cur.first && cur.second <= next_cur.second){\\n                // remove cur(already popped), update cur to be next_cur!\\n                cur = next_cur; min_heap.pop();  \\n            }\\n            // e.g. cur: [1,4] next_cur: [2,8]\\n            else{\\n                // update cur to be next_cur, count+1\\n                cur = next_cur; min_heap.pop();         \\n                count++;\\n            }\\n        }\\n        \\n        // At least one pair in intervals!\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180568,
                "title": "python-3-solution",
                "content": "class Solution:\\n\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:(x[0], -1*x[1]))\\n        \\n        left = intervals[0][0]\\n        right = intervals[0][1]\\n        \\n        res = 0\\n        \\n        for i in range(1, len(intervals)):\\n            intv = intervals[i]\\n            \\n            #covered intervals\\n            if left <= intv[0] and right >= intv[1]:\\n                res += 1\\n            \\n            #intersected intervals\\n            if right >= intv[0] and right <= intv[1]:\\n                right = intv[1]\\n            \\n            #neither covered nor intersected\\n            if right < intv[0]:\\n                left = intv[0]\\n                right = intv[1]\\n                \\n        return len(intervals) - res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:(x[0], -1*x[1]))\\n        \\n        left = intervals[0][0]\\n        right = intervals[0][1]\\n        \\n        res = 0\\n        \\n        for i in range(1, len(intervals)):\\n            intv = intervals[i]\\n            \\n            #covered intervals\\n            if left <= intv[0] and right >= intv[1]:\\n                res += 1\\n            \\n            #intersected intervals\\n            if right >= intv[0] and right <= intv[1]:\\n                right = intv[1]\\n            \\n            #neither covered nor intersected\\n            if right < intv[0]:\\n                left = intv[0]\\n                right = intv[1]\\n                \\n        return len(intervals) - res",
                "codeTag": "Java"
            },
            {
                "id": 2093214,
                "title": "java-using-sorting-easy-to-understand",
                "content": "```\\n\\tpublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tint removed = 0;\\n\\t\\tint last = -1;\\n\\n\\t\\t// Sort left ascending, right descending\\n\\t\\tArrays.sort(intervals, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tif (intervals[i][1] <= last) {\\n\\t\\t\\t\\tremoved++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlast = intervals[i][1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn intervals.length - removed;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\tpublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tint removed = 0;\\n\\t\\tint last = -1;\\n\\n\\t\\t// Sort left ascending, right descending\\n\\t\\tArrays.sort(intervals, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tif (intervals[i][1] <= last) {\\n\\t\\t\\t\\tremoved++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlast = intervals[i][1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn intervals.length - removed;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067116,
                "title": "super-easy-solution-c",
                "content": "Concept:Just sort the vector and then we will insert element in stack but before inserting we will check if it is over lapping or not.\\nIf yes then we can count it.\\nNow there are 2 case suppose you get example [[1,5],[2,3]] then 2,3 is inside 1,5 and now suppose you get.\\n[[1,4],[1,5]]. It is sorted but you should apply additinal condition because [1,5] covers [1,4].It happens because we sorted it using STL function it sort according to first element.This is a extra case.Now update stack by poping inital top and add new element.\\nEasy Right.\\nHappy LeetCoding.\\nUpvote and comment down below for doubts.\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int c=0;\\n        stack<vector<int>>s;\\n        sort(intervals.begin(),intervals.end());\\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            if(s.empty())\\n                s.push(intervals[i]);\\n            else{\\n                auto top=s.top();\\n                if(top[0]<=intervals[i][0]&&top[1]>=intervals[i][1])\\n                {\\n                    c++;\\n                }\\n                else if(top[0]==intervals[i][0]&&top[1]<=intervals[i][1])\\n                {\\n                    c++;\\n                    s.pop();\\n                    s.push({top[0],intervals[i][1]});\\n                }\\n                else\\n                    s.push(intervals[i]);\\n            }\\n        }\\n        return intervals.size()-c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int c=0;\\n        stack<vector<int>>s;\\n        sort(intervals.begin(),intervals.end());\\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            if(s.empty())\\n                s.push(intervals[i]);\\n            else{\\n                auto top=s.top();\\n                if(top[0]<=intervals[i][0]&&top[1]>=intervals[i][1])\\n                {\\n                    c++;\\n                }\\n                else if(top[0]==intervals[i][0]&&top[1]<=intervals[i][1])\\n                {\\n                    c++;\\n                    s.pop();\\n                    s.push({top[0],intervals[i][1]});\\n                }\\n                else\\n                    s.push(intervals[i]);\\n            }\\n        }\\n        return intervals.size()-c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788542,
                "title": "c-explained-with-comments-easy-solution-sorting-greedy-technique",
                "content": "**Time Complexity: O(n log n)**\\n**Space Complexity: Constant O(1)**\\n\\n**Approach Intution:** The intuition behind using the greedy approach is that we want that the overlapping intervals should be eliminated. In order to find the overlaping intervals we need to find the intervals which lies in the range of the larger intervals, this can be done by maintaining the intervals of the nearby range adjacent to each other. This can be done by applying sorting, but sorting need to be applied strategically which we will see while implementing the solution.\\n```\\nclass Solution {\\nprivate:\\n//here we have made our custom compare function to sort the vector of intervals in such a way that the intervals which starts from the beginning stays at the first\\n//if the two intervals have same starting point then the intervals which has more range will stays at the first position.\\n    static bool cmp(vector<int>a, vector<int>b){\\n\\t//if the starting point of both of them is same then we need to check for the ending point the interval having greater ending point has larger area of coverage and will occupy place before other\\n        if(a[0] == b[0]){\\n            return a[1]>b[1];\\n        }\\n        //first the main priority is to find the smaller starting point out of them \\n        return a[0]<b[0];\\n    }\\n\\t\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        \\n\\t\\t//we have initialized our ans to 1 because there will always be an interval with which other intervals will be compared in the starting.\\n        int ans = 1;\\n\\t\\t//we have decided to start the loop from 1 and 0th indexed interval we have considered ours as the interval which we have to include because there is no one forward to it which can overlap its coverage.\\n        vector<int>previousInterval = intervals[0];\\n        \\n        for(int i = 1; i<intervals.size(); i++){\\n\\t\\t//if the i th(current) interval lies in the range of the previously included interval then no need to include it in our counting \\n\\n//check that we are checking only the exit bound, not the starting bound because we know that the intervals are sorted in increasing order, so the intervals after the current will have the start bound greater than or equal to the one we are holding\\n            if(intervals[i][1]<=previousInterval[1]){\\n                continue;\\n            }\\n\\t\\t\\t\\n//if the i th(current) interval lies in the range of the previously included interval then no need to include it in our counting \\n            else{\\n                ans++;\\n                previousInterval = intervals[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n//here we have made our custom compare function to sort the vector of intervals in such a way that the intervals which starts from the beginning stays at the first\\n//if the two intervals have same starting point then the intervals which has more range will stays at the first position.\\n    static bool cmp(vector<int>a, vector<int>b){\\n\\t//if the starting point of both of them is same then we need to check for the ending point the interval having greater ending point has larger area of coverage and will occupy place before other\\n        if(a[0] == b[0]){\\n            return a[1]>b[1];\\n        }\\n        //first the main priority is to find the smaller starting point out of them \\n        return a[0]<b[0];\\n    }\\n\\t\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        \\n\\t\\t//we have initialized our ans to 1 because there will always be an interval with which other intervals will be compared in the starting.\\n        int ans = 1;\\n\\t\\t//we have decided to start the loop from 1 and 0th indexed interval we have considered ours as the interval which we have to include because there is no one forward to it which can overlap its coverage.\\n        vector<int>previousInterval = intervals[0];\\n        \\n        for(int i = 1; i<intervals.size(); i++){\\n\\t\\t//if the i th(current) interval lies in the range of the previously included interval then no need to include it in our counting \\n\\n//check that we are checking only the exit bound, not the starting bound because we know that the intervals are sorted in increasing order, so the intervals after the current will have the start bound greater than or equal to the one we are holding\\n            if(intervals[i][1]<=previousInterval[1]){\\n                continue;\\n            }\\n\\t\\t\\t\\n//if the i th(current) interval lies in the range of the previously included interval then no need to include it in our counting \\n            else{\\n                ans++;\\n                previousInterval = intervals[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787434,
                "title": "python3-heap-easy-implementation-beats-90",
                "content": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        events = defaultdict(list)\\n        \\n        for s, e in intervals:\\n            heapq.heappush(events[s], -e)\\n        \\n        res = 0\\n        cur_te = -10 ** 5\\n        for ts in sorted(list(events.keys())):\\n            te = -heapq.heappop(events[ts])\\n            if te > cur_te:\\n                cur_te = te\\n                res += 1\\n                \\n        return res\\n```\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        events = defaultdict(list)\\n        \\n        for s, e in intervals:\\n            heapq.heappush(events[s], -e)\\n        \\n        res = 0\\n        cur_te = -10 ** 5\\n        for ts in sorted(list(events.keys())):\\n            te = -heapq.heappop(events[ts])\\n            if te > cur_te:\\n                cur_te = te\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787345,
                "title": "two-java-solutions",
                "content": "## Brute Force\\n**Base idea:** for every interval, check if any other interval covers it.\\n\\nInitially, we assume that no interval is covered, i.e. `remaining -> len(intervals)`. Then, for every interval, we check if any other interval covers it, if it\\'s covered we\\'d have 1 less interval remaining.\\n\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int len = intervals.length;\\n        int remaining = len;\\n        for (int i = 0; i < len; i++) {\\n            int[] a = intervals[i];\\n            for (int j = 0; j < len; j++) {\\n                if (i == j) continue;\\n                \\n                int[] b = intervals[j];\\n                if (aIsCoveredByb(a, b)) {\\n                    remaining--;\\n                    break;\\n                }\\n            }\\n        }\\n        return remaining;\\n    }\\n    \\n    private boolean aIsCoveredByb(int[] a, int[] b) {\\n        return b[0] <= a[0] && a[1] <= b[1];\\n    }\\n}\\n```\\n\\n## Sorting\\n**Base idea:** We should be able to oganize the array in a way that the larger intervals come before, or after the intervals they cover.\\n\\nThe tricky part is finding an appropriate way to sort (at least for me it was). To sort, put the intervals with the lowest lower bounds and the largest higher bounds first. e.g.\\n\\n`[[1,4],[3,6],[2,8],[1,5]] -> sort -> [[1,5],[1,4],[2,8],[3,6]]`\\n\\nThis will put intervals that cover other intervals before the intervals they cover. Now we can fixate the largest interval (the first one) and go from left to right, every time we find an interval it covers, we have one less remaining interval.\\nIf we are met with one interval it doesn\\'t cover, that means we already went through all the intervals covered by the previous `large` interval, and we have a new `large` interval so we fixate it, and keep going until the end of the array. e.g.\\n\\n```\\n[[1,5],[1,4],[1,2],[2,8],[3,6]]\\n   |-----^-----|     |-----|\\n        -1    -1          -1\\n   \\n[[1,4],[2,3],[4,5],[6,7]]\\n   |-----|     |     |\\n        -1\\n```\\n\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) ->  {\\n            int firstDiff = a[0] - b[0];\\n            return firstDiff != 0 ? firstDiff : b[1] - a[1];\\n        });\\n        \\n        int len = intervals.length;\\n        int remaining = len;\\n        for (int i = 0, j = 1; j < len; j++) {\\n            int[] a = intervals[j];\\n            int[] b = intervals[i];\\n            if (aIsCoveredByb(a, b)) remaining--;\\n            else i = j;\\n        }\\n        return remaining;\\n    }\\n\\n    private boolean aIsCoveredByb(int[] a, int[] b) {\\n        return b[0] <= a[0] && a[1] <= b[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int len = intervals.length;\\n        int remaining = len;\\n        for (int i = 0; i < len; i++) {\\n            int[] a = intervals[i];\\n            for (int j = 0; j < len; j++) {\\n                if (i == j) continue;\\n                \\n                int[] b = intervals[j];\\n                if (aIsCoveredByb(a, b)) {\\n                    remaining--;\\n                    break;\\n                }\\n            }\\n        }\\n        return remaining;\\n    }\\n    \\n    private boolean aIsCoveredByb(int[] a, int[] b) {\\n        return b[0] <= a[0] && a[1] <= b[1];\\n    }\\n}\\n```\n```\\n[[1,5],[1,4],[1,2],[2,8],[3,6]]\\n   |-----^-----|     |-----|\\n        -1    -1          -1\\n   \\n[[1,4],[2,3],[4,5],[6,7]]\\n   |-----|     |     |\\n        -1\\n```\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) ->  {\\n            int firstDiff = a[0] - b[0];\\n            return firstDiff != 0 ? firstDiff : b[1] - a[1];\\n        });\\n        \\n        int len = intervals.length;\\n        int remaining = len;\\n        for (int i = 0, j = 1; j < len; j++) {\\n            int[] a = intervals[j];\\n            int[] b = intervals[i];\\n            if (aIsCoveredByb(a, b)) remaining--;\\n            else i = j;\\n        }\\n        return remaining;\\n    }\\n\\n    private boolean aIsCoveredByb(int[] a, int[] b) {\\n        return b[0] <= a[0] && a[1] <= b[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787074,
                "title": "c-easy-to-understand-sorting-short-simple-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        int ans=0;\\n\\t\\t//sort the vector\\n        sort(intervals.begin(),intervals.end());\\n        vector<int> temp = intervals[0];\\n        for(auto it : intervals)\\n        {\\n            if(temp[1]>=it[1])\\n            {\\n                ans++;\\n            }\\n            else if(temp[0]==it[0])\\n            {\\n                ans++;\\n                temp = it;\\n            }\\n            else\\n            {\\n                temp = it;\\n            }\\n        }\\n        cout<<ans;\\n        return n-ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        int ans=0;\\n\\t\\t//sort the vector\\n        sort(intervals.begin(),intervals.end());\\n        vector<int> temp = intervals[0];\\n        for(auto it : intervals)\\n        {\\n            if(temp[1]>=it[1])\\n            {\\n                ans++;\\n            }\\n            else if(temp[0]==it[0])\\n            {\\n                ans++;\\n                temp = it;\\n            }\\n            else\\n            {\\n                temp = it;\\n            }\\n        }\\n        cout<<ans;\\n        return n-ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1786995,
                "title": "please-help-c",
                "content": "Can someone please tell me that why  this code gives wrong answer  ;-\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int r=0,max=intervals[0][1];\\n        int l=intervals.size();\\n        for(int i=1;i<l;i++)\\n        {\\n            if(intervals[i][1]<=max)\\n                r++;\\n           else if(intervals[i][0]==intervals[i-1][0])\\n                r++;\\n            \\n            \\n            if(max<intervals[i][1])\\n                max=intervals[i][1];\\n        }\\n        return l-r;\\n    }\\n};\\n```\\nwhereas this code gives right answer :-\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int r=1;\\n        int x=intervals[0][0],y=intervals[0][1];\\n        int l=intervals.size();\\n        for(int i=1;i<l;i++)\\n        {\\n           if(intervals[i][0]>x &&  intervals[i][1]>y)\\n            r++;\\n            if(intervals[i][1]>y)\\n            {\\n                y=intervals[i][1];\\n                x=intervals[i][0];\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\nThanks in Advance",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int r=0,max=intervals[0][1];\\n        int l=intervals.size();\\n        for(int i=1;i<l;i++)\\n        {\\n            if(intervals[i][1]<=max)\\n                r++;\\n           else if(intervals[i][0]==intervals[i-1][0])\\n                r++;\\n            \\n            \\n            if(max<intervals[i][1])\\n                max=intervals[i][1];\\n        }\\n        return l-r;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int r=1;\\n        int x=intervals[0][0],y=intervals[0][1];\\n        int l=intervals.size();\\n        for(int i=1;i<l;i++)\\n        {\\n           if(intervals[i][0]>x &&  intervals[i][1]>y)\\n            r++;\\n            if(intervals[i][1]>y)\\n            {\\n                y=intervals[i][1];\\n                x=intervals[i][0];\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786989,
                "title": "java-simple-solution-sort",
                "content": "**Runtime: 8 ms, faster than 56.63% of Java online submissions for Remove Covered Intervals.\\nMemory Usage: 46.7 MB, less than 14.20% of Java online submissions for Remove Covered Intervals.**\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int count = 0;\\n        Arrays.sort(intervals,(a,b)->a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        int end = intervals[0][1];\\n        for(int i = 1;i<intervals.length;i++){\\n            if(intervals[i][1] <= end)count++;\\n            end = Math.max(end,intervals[i][1]);\\n        }\\n        return intervals.length - count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int count = 0;\\n        Arrays.sort(intervals,(a,b)->a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        int end = intervals[0][1];\\n        for(int i = 1;i<intervals.length;i++){\\n            if(intervals[i][1] <= end)count++;\\n            end = Math.max(end,intervals[i][1]);\\n        }\\n        return intervals.length - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786945,
                "title": "python-easy-and-clean-solution-explained",
                "content": "Approach is to take 1st interval as a **TRAP** \\nTraverse the remaining array and check whether some interval falls into the trap or trap itself falls into another trap and update the trap.\\n\\n***Code Breakdown:***\\n________________________________________________________________________\\n```\\n if i[0] == trap[0] or i[1] <= trap[1]:\\n```\\nif start is same, guaranteed one falls into the trap, \\n``` eg: [2,6], [2,3]```\\n\\n**or** If any interval has upper bound lesser than trap\\'s upperbound\\n``` eg: trap  = [1,8]``` and  an interval ```[2,4] ``` comes it will fall into the existing trap, lower boud will play no role here because array is sorted.\\n___________________________________________________________________________________\\n```\\ntrap[1] = max(trap[1], i[1])\\n```\\nif any interval falls into the trap we will just change the upperbound of the trap, in order to reduce duplicates.\\n``` eg:  [1,8],[2,4],[2,9]```\\nSo here , in this example we can see 2nd interval is falling under 1st interval as well as in 3rd interval, and we cant count it twice.\\n_________________________________________________________________________________\\n```\\nelse:  trap = i\\n```\\nelse if at any particular iteration if trap didn\\'t work we will change the trap to current range.\\n__________________________________________________________________________________\\n```\\n return len(intervals) -  count\\n ```\\n We have counted the number interval trapped,\\n and we have to return the number of intervals that are not trapped.\\n __________________________________________________________________________________\\n \\n \\n **Full Code:**\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()            \\n        trap, count = intervals[0], 0                     \\n        for i in intervals[1:]:                 \\n            if i[0] == trap[0] or i[1] <= trap[1]:       \\n                count += 1\\n                trap[1] = max(trap[1], i[1])       \\n            else:  trap = i\\n        return len(intervals) -  count\\n```",
                "solutionTags": [],
                "code": "```\\n if i[0] == trap[0] or i[1] <= trap[1]:\\n```\n``` eg: [2,6], [2,3]```\n``` eg: trap  = [1,8]```\n```[2,4] ```\n```\\ntrap[1] = max(trap[1], i[1])\\n```\n``` eg:  [1,8],[2,4],[2,9]```\n```\\nelse:  trap = i\\n```\n```\\n return len(intervals) -  count\\n ```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()            \\n        trap, count = intervals[0], 0                     \\n        for i in intervals[1:]:                 \\n            if i[0] == trap[0] or i[1] <= trap[1]:       \\n                count += 1\\n                trap[1] = max(trap[1], i[1])       \\n            else:  trap = i\\n        return len(intervals) -  count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786913,
                "title": "java-easy-solution-basic-sorting-solution",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] Intervals) {\\n        \\n    \\n    \\n        // Code here // Code here\\n        ArrayList<int[]>a=new ArrayList<int[]>();\\n        int n=Intervals.length;\\n        if(n==1)\\n        return 1;\\n        for(int i=0;i<n;i++) //making arraylist as deleting and shifting is not be to be taken cared much in ArrayList as compared to Array\\n        {\\n           // System.out.println(Arrays.toString(Intervals[i]));\\n            int part[]=new int[2];\\n            part[0]=Intervals[i][0];\\n            part[1]=Intervals[i][1];\\n            a.add(part);\\n            \\n        }\\n        Collections.sort(a,new Comparator<int[]>(){      //sorting using first value first, then on the second value if first one is equal\\n            @Override\\n            public int compare(int o1[],int o2[])\\n            {\\n                if(o1[0]!=o2[0])\\n                return o1[0]-o2[0];\\n                return o2[1]-o1[1];\\n            }\\n        });\\n        int length=a.size();\\n    /*     for(int k=0;k<length;k++)\\n        {\\n            System.out.println(Arrays.toString(a.get(k)));\\n        }*/\\n      //  int len=a.size();\\n        int i=0;\\n        length--;\\n        while(true)\\n        {\\n        if(a.get(i)[0]<=a.get(i+1)[0] && a.get(i)[1]>=a.get(i+1)[1])\\n        {\\n        \\n           \\n            a.remove(i+1);\\n            length--;\\n             if(i==(length))\\n            break;\\n        }\\n        \\n        else   // we will move to next pair of element only if we are sure that next pair cant be consumed by present one;\\n        {\\n          //  System.out.println((a.size())+\"--\"+length+\" \"+i+\"(((\");\\n            i++;\\n           int o=a.size();\\n           if((i+1)>=(o))\\n           break;\\n           \\n           \\n            \\n        }\\n        \\n        \\n        }\\n        int l=a.size();//System.out.println(\"**\");\\n        for(int j=0;j<l;j++)\\n        {\\n            System.out.println(Arrays.toString(a.get(j)));\\n        }\\n        int y=a.size();\\n       return y;\\n        \\n        \\n        \\n    }\\n}\\n\\n```\\n\\nRead Comments ,It will definitely help,\\nlook for further optimization.",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] Intervals) {\\n        \\n    \\n    \\n        // Code here // Code here\\n        ArrayList<int[]>a=new ArrayList<int[]>();\\n        int n=Intervals.length;\\n        if(n==1)\\n        return 1;\\n        for(int i=0;i<n;i++) //making arraylist as deleting and shifting is not be to be taken cared much in ArrayList as compared to Array\\n        {\\n           // System.out.println(Arrays.toString(Intervals[i]));\\n            int part[]=new int[2];\\n            part[0]=Intervals[i][0];\\n            part[1]=Intervals[i][1];\\n            a.add(part);\\n            \\n        }\\n        Collections.sort(a,new Comparator<int[]>(){      //sorting using first value first, then on the second value if first one is equal\\n            @Override\\n            public int compare(int o1[],int o2[])\\n            {\\n                if(o1[0]!=o2[0])\\n                return o1[0]-o2[0];\\n                return o2[1]-o1[1];\\n            }\\n        });\\n        int length=a.size();\\n    /*     for(int k=0;k<length;k++)\\n        {\\n            System.out.println(Arrays.toString(a.get(k)));\\n        }*/\\n      //  int len=a.size();\\n        int i=0;\\n        length--;\\n        while(true)\\n        {\\n        if(a.get(i)[0]<=a.get(i+1)[0] && a.get(i)[1]>=a.get(i+1)[1])\\n        {\\n        \\n           \\n            a.remove(i+1);\\n            length--;\\n             if(i==(length))\\n            break;\\n        }\\n        \\n        else   // we will move to next pair of element only if we are sure that next pair cant be consumed by present one;\\n        {\\n          //  System.out.println((a.size())+\"--\"+length+\" \"+i+\"(((\");\\n            i++;\\n           int o=a.size();\\n           if((i+1)>=(o))\\n           break;\\n           \\n           \\n            \\n        }\\n        \\n        \\n        }\\n        int l=a.size();//System.out.println(\"**\");\\n        for(int j=0;j<l;j++)\\n        {\\n            System.out.println(Arrays.toString(a.get(j)));\\n        }\\n        int y=a.size();\\n       return y;\\n        \\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786895,
                "title": "java-solution",
                "content": "Sort the start based on ascending order. If start time of 2 intervals is same, then sort it based on desending order of end time. Once the intervals are sorted, start couting the intervals and once the end time is more than current max end time, increment the counter.\\t\\n\\t\\n\\t\\n\\tpublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tArrays.sort(intervals, (a, b) -> (a[0] == b[0]) ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\tint count = 0;\\n\\t\\tint end = 0;\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tif (end < intervals[i][1]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Sort the start based on ascending order. If start time of 2 intervals is same, then sort it based on desending order of end time. Once the intervals are sorted, start couting the intervals and once the end time is more than current max end time, increment the counter.\\t\\n\\t\\n\\t\\n\\tpublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tArrays.sort(intervals, (a, b) -> (a[0] == b[0]) ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\tint count = 0;\\n\\t\\tint end = 0;\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tif (end < intervals[i][1]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "C++"
            },
            {
                "id": 1786823,
                "title": "python-maxheap-solution",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals.sort(key=lambda x: x[1], reverse=True) \\n        intervals.sort(key=lambda x: x[0]) # We shell sort it by the first number.\\n\\n        heap = []\\n        \\n        # If its bigger then -1 * peak(heap) [largest] we shell push it to the heap.\\n        for l, r in intervals:\\n            \\n            if len(heap) == 0:\\n                heapq.heappush(heap, -r)\\n            \\n            else:\\n                \\n                # This is supposed to be the largest number.\\n                if heap[0] > -r:\\n                    heapq.heappush(heap, -r)\\n        \\n        return len(heap)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals.sort(key=lambda x: x[1], reverse=True) \\n        intervals.sort(key=lambda x: x[0]) # We shell sort it by the first number.\\n\\n        heap = []\\n        \\n        # If its bigger then -1 * peak(heap) [largest] we shell push it to the heap.\\n        for l, r in intervals:\\n            \\n            if len(heap) == 0:\\n                heapq.heappush(heap, -r)\\n            \\n            else:\\n                \\n                # This is supposed to be the largest number.\\n                if heap[0] > -r:\\n                    heapq.heappush(heap, -r)\\n        \\n        return len(heap)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786761,
                "title": "java-easy-solution-o-nlogn-tc-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n=intervals.length;\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        int res=n;\\n        for(int i=0,j=1;j<n;j++){\\n            if(intervals[i][1]>=intervals[j][1])\\n                res--;\\n            else{\\n                if(intervals[i][0]==intervals[j][0])\\n                    res--;\\n                i=j;\\n            }\\n        }\\n     return res;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n=intervals.length;\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        int res=n;\\n        for(int i=0,j=1;j<n;j++){\\n            if(intervals[i][1]>=intervals[j][1])\\n                res--;\\n            else{\\n                if(intervals[i][0]==intervals[j][0])\\n                    res--;\\n                i=j;\\n            }\\n        }\\n     return res;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786740,
                "title": "python-sorting-simple-solution",
                "content": "## Logic:\\n1. Sort the intervals on the basis of start position and then on end position in reverse order.\\n2. Iterate over the intervals and check whether the next interval would be covered by previous interval. If true then the current interval can be removed.\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        count = len(intervals)\\n        start, end = intervals[0]\\n        \\n        for i in range(1, len(intervals)):\\n            if start <= intervals[i][0] and intervals[i][1] <= end:\\n                count -= 1\\n            else:\\n                start, end = intervals[i][0], intervals[i][1]\\n        return count\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        count = len(intervals)\\n        start, end = intervals[0]\\n        \\n        for i in range(1, len(intervals)):\\n            if start <= intervals[i][0] and intervals[i][1] <= end:\\n                count -= 1\\n            else:\\n                start, end = intervals[i][0], intervals[i][1]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786660,
                "title": "python-faster-than-78-simple",
                "content": "* Sort the intervals list with respect to the first element of inner pair.\\n* create a stack st\\n* first append the first pair in the stack st\\n* iterate over the intervals list, check if the pair is present in the top of the stack\\n* if present, pass\\n* if not present, check if the top of the stack is present in the pair, if present -> pop the top of stack and append the pair\\n* else, append the pair..!!\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0])\\n        \\n        st = []\\n        first = intervals[0]\\n        st.append(first)\\n        \\n        for l in intervals:\\n            \\n            if l!=first: \\n            \\n                x = st[-1]\\n                if l[0]<x[1] and l[0]>=x[0]:\\n                    if l[1]<=x[1]:\\n                        pass\\n                    elif x[0]>=l[0] and x[1]<=l[1]:\\n                            st.pop()\\n                            st.append(l)\\n                    else:\\n                        st.append(l)\\n                else:\\n                    st.append(l)\\n\\n        return len(st)\\n        \\n```\\n\\n**PLS UPVOTE IF YOU LIKE MY SOLUTION, HOPE YOU LIKE THIS.**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0])\\n        \\n        st = []\\n        first = intervals[0]\\n        st.append(first)\\n        \\n        for l in intervals:\\n            \\n            if l!=first: \\n            \\n                x = st[-1]\\n                if l[0]<x[1] and l[0]>=x[0]:\\n                    if l[1]<=x[1]:\\n                        pass\\n                    elif x[0]>=l[0] and x[1]<=l[1]:\\n                            st.pop()\\n                            st.append(l)\\n                    else:\\n                        st.append(l)\\n                else:\\n                    st.append(l)\\n\\n        return len(st)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786657,
                "title": "c",
                "content": "```\\n\\n bool comp ( const vector<int> &v1 , const vector<int> &v2 )\\n    {\\n        if ( v1[0] < v2[0] ) return true ; \\n        else if ( v1[0] == v2[0] ) \\n        {\\n            if ( v1[1] > v2[1] ) return true ; \\n        }\\n        return false ; \\n    }\\nclass Solution {\\npublic:\\n   \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort ( intervals.begin() , intervals.end() , comp ) ;\\n        int ans = intervals.size() ;\\n        int prevx = intervals[0][0] , prevy = intervals[0][1] ;\\n        \\n      \\n        for ( int i = 1 ; i < intervals.size() ; i++ )\\n        {\\n            int newx = intervals[i][0] , newy = intervals[i][1] ;\\n            if ( newx >= prevx and newy <= prevy ) ans-- ; \\n            prevx = min ( prevx , newx ) , prevy = max ( prevy , newy ) ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n bool comp ( const vector<int> &v1 , const vector<int> &v2 )\\n    {\\n        if ( v1[0] < v2[0] ) return true ; \\n        else if ( v1[0] == v2[0] ) \\n        {\\n            if ( v1[1] > v2[1] ) return true ; \\n        }\\n        return false ; \\n    }\\nclass Solution {\\npublic:\\n   \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort ( intervals.begin() , intervals.end() , comp ) ;\\n        int ans = intervals.size() ;\\n        int prevx = intervals[0][0] , prevy = intervals[0][1] ;\\n        \\n      \\n        for ( int i = 1 ; i < intervals.size() ; i++ )\\n        {\\n            int newx = intervals[i][0] , newy = intervals[i][1] ;\\n            if ( newx >= prevx and newy <= prevy ) ans-- ; \\n            prevx = min ( prevx , newx ) , prevy = max ( prevy , newy ) ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786655,
                "title": "python-easy-to-read-and-understand",
                "content": "Sort on a[0] and if same then -a[1]\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key= lambda x: (x[0], -x[1]))\\n        ans, right = 0, 0\\n        for u, v in intervals:\\n            if v > right:\\n                ans += 1\\n            right = max(right, v)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "Sort on a[0] and if same then -a[1]\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key= lambda x: (x[0], -x[1]))\\n        ans, right = 0, 0\\n        for u, v in intervals:\\n            if v > right:\\n                ans += 1\\n            right = max(right, v)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1786612,
                "title": "c-brute-force-time-o-n-2",
                "content": "This is a brute force method and the code can be passed.\\nTime complexity is O(N^2) \\nSpace complexity is O(N) \\n\\n# Source Code \\n```C++\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<vector<int>>& v = intervals;\\n        sort(v.begin(), v.end(), [](auto r, auto l) {\\n\\t\\t\\treturn r[0]!=l[0]?r[0]<l[0]:r[1]>l[1] ;\\n\\t\\t}); \\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        vector<bool> covered(n,false);\\n        for(int i = 0; i<n; i++) {\\n            int start =v[i][0];\\n            int end = v[i][1];\\n            int j = i+1;\\n            while(j<n && v[j][0]<=end) {\\n                if(v[j][1]<=end && !covered[j]) {\\n                    covered[j] = true;   \\n                    cnt++;\\n                }\\n                j++;\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```\\n\\n# Code with comment\\n```C++\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<vector<int>>& v = intervals;\\n        sort(v.begin(), v.end(), [](auto r, auto l) {\\n\\t\\t\\treturn r[0]!=l[0]?r[0]<l[0]:r[1]>l[1] ;\\n\\t\\t}); \\n\\t\\t// [[1,2],[1,4],[3,4]] will be sorted into [[1,4],[1,2],[3,4]]\\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        vector<bool> covered(n,false);\\n        for(int i = 0; i<n; i++) {\\n            int start =v[i][0];\\n            int end = v[i][1];\\n            int j = i+1;\\n\\t\\t\\t//for each interval_i [start_i, end_i], \\n\\t\\t\\t//we can run the following loop\\n            while(j<n && v[j][0]<=end) {\\n\\t\\t\\t\\t//for all j that start_i <= start_j <= end_i, run the loop for j here. \\n\\t\\t\\t\\t//becase start_j  have already in interval_i, so we only need to check if end_j ini nterval_i\\n\\t\\t\\t\\t//if it is, then count up. \\n                if(v[j][1]<=end && !covered[j]) {\\n                    covered[j] = true;   \\n\\t\\t\\t\\t\\t//set covered[j] as true so interval only can be counted when first time to be covered.\\n                    cnt++;\\n                }\\n                j++;\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<vector<int>>& v = intervals;\\n        sort(v.begin(), v.end(), [](auto r, auto l) {\\n\\t\\t\\treturn r[0]!=l[0]?r[0]<l[0]:r[1]>l[1] ;\\n\\t\\t}); \\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        vector<bool> covered(n,false);\\n        for(int i = 0; i<n; i++) {\\n            int start =v[i][0];\\n            int end = v[i][1];\\n            int j = i+1;\\n            while(j<n && v[j][0]<=end) {\\n                if(v[j][1]<=end && !covered[j]) {\\n                    covered[j] = true;   \\n                    cnt++;\\n                }\\n                j++;\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<vector<int>>& v = intervals;\\n        sort(v.begin(), v.end(), [](auto r, auto l) {\\n\\t\\t\\treturn r[0]!=l[0]?r[0]<l[0]:r[1]>l[1] ;\\n\\t\\t}); \\n\\t\\t// [[1,2],[1,4],[3,4]] will be sorted into [[1,4],[1,2],[3,4]]\\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        vector<bool> covered(n,false);\\n        for(int i = 0; i<n; i++) {\\n            int start =v[i][0];\\n            int end = v[i][1];\\n            int j = i+1;\\n\\t\\t\\t//for each interval_i [start_i, end_i], \\n\\t\\t\\t//we can run the following loop\\n            while(j<n && v[j][0]<=end) {\\n\\t\\t\\t\\t//for all j that start_i <= start_j <= end_i, run the loop for j here. \\n\\t\\t\\t\\t//becase start_j  have already in interval_i, so we only need to check if end_j ini nterval_i\\n\\t\\t\\t\\t//if it is, then count up. \\n                if(v[j][1]<=end && !covered[j]) {\\n                    covered[j] = true;   \\n\\t\\t\\t\\t\\t//set covered[j] as true so interval only can be counted when first time to be covered.\\n                    cnt++;\\n                }\\n                j++;\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786597,
                "title": "c-daily-leetcoding-challenge-feb-20-sorting",
                "content": "```\\n\\tint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int size = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        \\n        stack<vector<int>> st;\\n        st.push(intervals[0]);\\n        \\n        for(int i=1; i<size; i++){\\n            vector<int> top = st.top();\\n            if(top[0] <= intervals[i][0] and top[1] >= intervals[i][1]){\\n                continue;\\n            }else if(top[0] == intervals[i][0] and top[1] < intervals[i][1]){\\n                st.pop();\\n            }\\n            st.push(intervals[i]);\\n        }\\n        \\n        return st.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\tint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int size = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        \\n        stack<vector<int>> st;\\n        st.push(intervals[0]);\\n        \\n        for(int i=1; i<size; i++){\\n            vector<int> top = st.top();\\n            if(top[0] <= intervals[i][0] and top[1] >= intervals[i][1]){\\n                continue;\\n            }else if(top[0] == intervals[i][0] and top[1] < intervals[i][1]){\\n                st.pop();\\n            }\\n            st.push(intervals[i]);\\n        }\\n        \\n        return st.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1786568,
                "title": "java-o-n-solution-using-treemap",
                "content": "This is the solution using treemap to store maximum interval taken by every starting point.\\nmain logic:\\ntreemap stores in sorted order.\\ntime complexity: O(n)\\nSpace Complexity: O(n) (Worst case Scenerio)\\n\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length,ans = 0;\\n\\t\\t//using treemap to store maximum ending of every starting point.\\n        TreeMap<Integer,Integer> map = new TreeMap<Integer,Integer>();\\n        for(int[] i : intervals)\\n        {\\n            map.put(i[0],Math.max(map.getOrDefault(i[0],0),i[1]));\\n        }\\n\\t\\t// initializing flag to store first key.\\n        int end = 0,flag = 0;\\n        for (Map.Entry<Integer,Integer> entry : map.entrySet())\\n        {\\n            if(flag == 0)\\n            {\\n                end = entry.getValue();\\n                flag = 1;\\n                ans++;\\n            }\\n            else\\n            {\\n\\t\\t\\t// if the current ending point is greater than previous ending point. then ans will be incremented.\\n                int t = entry.getValue();\\n                if(t>end)\\n                {\\n                    end = t;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length,ans = 0;\\n\\t\\t//using treemap to store maximum ending of every starting point.\\n        TreeMap<Integer,Integer> map = new TreeMap<Integer,Integer>();\\n        for(int[] i : intervals)\\n        {\\n            map.put(i[0],Math.max(map.getOrDefault(i[0],0),i[1]));\\n        }\\n\\t\\t// initializing flag to store first key.\\n        int end = 0,flag = 0;\\n        for (Map.Entry<Integer,Integer> entry : map.entrySet())\\n        {\\n            if(flag == 0)\\n            {\\n                end = entry.getValue();\\n                flag = 1;\\n                ans++;\\n            }\\n            else\\n            {\\n\\t\\t\\t// if the current ending point is greater than previous ending point. then ans will be incremented.\\n                int t = entry.getValue();\\n                if(t>end)\\n                {\\n                    end = t;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786542,
                "title": "java-faster-than-98",
                "content": "```\\n public int removeCoveredIntervals(int[][] intervals) {\\n     Arrays.sort(intervals, (a, b) -> ((a[0]-b[0]) == 0 ? b[1]-a[1] : a[0]-b[0]) ); \\n     \\n     int count = 1;\\n     int base[] = intervals[0];\\n     for(int i=1; i<intervals.length; i++){\\n        if(intervals[i][1] > base[1]){\\n          base = intervals[i]; \\n          count++;  \\n        }\\n         \\n     }   \\n     return count; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int removeCoveredIntervals(int[][] intervals) {\\n     Arrays.sort(intervals, (a, b) -> ((a[0]-b[0]) == 0 ? b[1]-a[1] : a[0]-b[0]) ); \\n     \\n     int count = 1;\\n     int base[] = intervals[0];\\n     for(int i=1; i<intervals.length; i++){\\n        if(intervals[i][1] > base[1]){\\n          base = intervals[i]; \\n          count++;  \\n        }\\n         \\n     }   \\n     return count; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786506,
                "title": "java-easy-to-understand-written-notes",
                "content": "**\\n           int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            int c=intervals[j][0];\\n            int d=intervals[j][1];\\n\\t\\t\\t\\n\\t\\tWe will be sorting array on the basis of 1st value......\\n\\t\\t\\t\\nLets explore some test cases [1,4] ,[2,8], [3,6]\\n.................................................................... ith.......jth........................................................................................................\\n\\nand 2nd test case is  [1,2], [1,4]\\n...........................................ith......jth...................................................................................................................................\\n\\nif ith interval covers jth interval then (c>=a && b>=d).\\n\\nif jth interval covers ith interval then (c==a && b<=d)\\n\\n**\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n       Arrays.sort(intervals,(a,b)-> a[0]-b[0]);\\n        int i=0;\\n        int j=1;\\n        int ans=0;\\n        while(j<intervals.length){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            int c=intervals[j][0];\\n            int d=intervals[j][1];\\n             \\n            //if ith interval covers jth interval...............\\n            if(c>=a && b>=d){\\n                intervals[j]=intervals[i];\\n                ans++;\\n                i=j;\\n            // if jth interval cover ith interval...............\\n            }else if(c==a && b<=d){\\n                ans++;\\n               i=j; \\n             // no cover....................   \\n            }else{\\n                i++;\\n            }\\n            \\n            j++; \\n        }\\n        return intervals.length-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n       Arrays.sort(intervals,(a,b)-> a[0]-b[0]);\\n        int i=0;\\n        int j=1;\\n        int ans=0;\\n        while(j<intervals.length){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            int c=intervals[j][0];\\n            int d=intervals[j][1];\\n             \\n            //if ith interval covers jth interval...............\\n            if(c>=a && b>=d){\\n                intervals[j]=intervals[i];\\n                ans++;\\n                i=j;\\n            // if jth interval cover ith interval...............\\n            }else if(c==a && b<=d){\\n                ans++;\\n               i=j; \\n             // no cover....................   \\n            }else{\\n                i++;\\n            }\\n            \\n            j++; \\n        }\\n        return intervals.length-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786423,
                "title": "python-3-using-sorting-and-a-stack-92ms-14-5mb",
                "content": "It helps to sort the provided array first according to start indices. That way we can use simple if-else logic in order to determine which ranges get to stay and which don\\'t. After the entire for loop ends we simply return the number of items that are remaining in the stack.\\n\\nThe time compelxity is `O(nlogn)` because we sort the array (remember Python uses Timsort which has `O(nlogn)` worst-case complexity) and the space complexity is `O(n)` because at worst none of the intervals will overlap and our stack will simply be the original array.\\n\\n### Algorithm\\n\\nThe intuition is that there are three total cases:\\n1. The current interval is contained in the interval at the top of the stack.\\n2. The interval at the top of the stack is contained in the current interval.\\n3. Neither.\\n\\nFor #1 we don\\'t want to do anything and continue to the next iteration. For #2, since the top of the stack is now irrelevant, we pop it and push the current interval to the top. For any other case we simply push it to the top of the stack.\\n\\nIf we didn\\'t sort the array then we\\'d have to search the entire stack array and remove overlapping intervals rather than having to simply compare with the top.\\n\\nThe flowchart is as follows:\\n\\n![image](https://assets.leetcode.com/users/images/bb9f7370-7d6c-4d6e-8468-da7693b029fb_1645363363.7521431.png)\\n\\n\\n\\n### Code\\n\\n```\\ndef removeCoveredIntervals(intervals: List[List[int]]) -> int:\\n\\tintervals = sorted(intervals, key=lambda x: x[0])\\n\\tstack = [intervals[0]]\\n\\n\\tfor interval in intervals[1:]:\\n\\t\\tstart, end = interval\\n\\t\\ttop_start, top_end = stack[-1]\\n\\n\\t\\tif (start >= top_start) and (end <= top_end):\\n\\t\\t\\tcontinue            \\n\\t\\telif (start <= top_start) and (end >= top_end):\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tstack.append(interval)\\n\\t\\telse:\\n\\t\\t\\tstack.append(interval)\\n\\n\\treturn len(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\ndef removeCoveredIntervals(intervals: List[List[int]]) -> int:\\n\\tintervals = sorted(intervals, key=lambda x: x[0])\\n\\tstack = [intervals[0]]\\n\\n\\tfor interval in intervals[1:]:\\n\\t\\tstart, end = interval\\n\\t\\ttop_start, top_end = stack[-1]\\n\\n\\t\\tif (start >= top_start) and (end <= top_end):\\n\\t\\t\\tcontinue            \\n\\t\\telif (start <= top_start) and (end >= top_end):\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tstack.append(interval)\\n\\t\\telse:\\n\\t\\t\\tstack.append(interval)\\n\\n\\treturn len(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1786390,
                "title": "c-easy-solution-detailed-explanation",
                "content": "Everything is explained in the code with examples\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // Sorting the intervals \\n        sort(intervals.begin(), intervals.end());\\n        \\n        // Storing the first interval\\n        vector<int> previous;\\n        previous.push_back(intervals[0][0]);\\n        previous.push_back(intervals[0][1]);\\n        \\n        // There\\'ll be atleast one interval in the final answer\\n        int remaining = 1;\\n        \\n        for(int i=1; i<intervals.size(); i++){\\n            // Storing the current interval\\n            vector<int> current = {intervals[i][0], intervals[i][1]};\\n            \\n            // Current interval is covered by the previous interval\\n            // Ex: previous = [1,6], current = [3,5] ==> Final: [1,6]\\n            if(current[1] <= previous[1]){\\n                continue;\\n            }\\n            \\n            // Previous interval is covered by the current interval\\n            // Ex: previous = [1,5], current = [1,6] ==> Final: [1,6]\\n            if(current[0] == previous[0] && current[1] > previous[1]){\\n                previous[1] = current[1];\\n                continue;\\n            }\\n            \\n            // Other cases: Current interval is not covered by the previous interval or vice versa\\n            remaining++;\\n            \\n            // Updating the previous interval with current interval\\n            previous[0] = current[0];\\n            previous[1] = current[1];\\n        }\\n        return remaining;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // Sorting the intervals \\n        sort(intervals.begin(), intervals.end());\\n        \\n        // Storing the first interval\\n        vector<int> previous;\\n        previous.push_back(intervals[0][0]);\\n        previous.push_back(intervals[0][1]);\\n        \\n        // There\\'ll be atleast one interval in the final answer\\n        int remaining = 1;\\n        \\n        for(int i=1; i<intervals.size(); i++){\\n            // Storing the current interval\\n            vector<int> current = {intervals[i][0], intervals[i][1]};\\n            \\n            // Current interval is covered by the previous interval\\n            // Ex: previous = [1,6], current = [3,5] ==> Final: [1,6]\\n            if(current[1] <= previous[1]){\\n                continue;\\n            }\\n            \\n            // Previous interval is covered by the current interval\\n            // Ex: previous = [1,5], current = [1,6] ==> Final: [1,6]\\n            if(current[0] == previous[0] && current[1] > previous[1]){\\n                previous[1] = current[1];\\n                continue;\\n            }\\n            \\n            // Other cases: Current interval is not covered by the previous interval or vice versa\\n            remaining++;\\n            \\n            // Updating the previous interval with current interval\\n            previous[0] = current[0];\\n            previous[1] = current[1];\\n        }\\n        return remaining;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1786300,
                "title": "easy-brute-force",
                "content": "```\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<pair<int,int>> myVec;\\n        int m = intervals.size();\\n        int n = 2;\\n        for(int i=0;i<m;i++){\\n                myVec.push_back({intervals[i][1],intervals[i][0]});\\n        }\\n        sort(myVec.rbegin(),myVec.rend());\\n        int start,end;\\n        start = myVec[0].second;\\n        end = myVec[0].first;\\n        for(int i=0;i<m;i++){\\n            cout << myVec[i].first << myVec[i].second << endl;\\n        }\\n        int count=0;\\n        for(int i=1;i<m;i++){\\n            if(end >= myVec[i].first and start <= myVec[i].second){\\n                count++;\\n                //cout << \"interation #\" << i << endl;\\n            }\\n            else if(end==myVec[i].first and start > myVec[i].second)\\n            {\\n                count++;\\n              //  end=myVec[i].first;\\n                start=myVec[i].second;\\n            }\\n            else if(end>myVec[i].first and start == myVec[i].second)\\n            {    count++;\\n                end = myVec[i].first;\\n                \\n            }\\n            else{\\n                 start = myVec[i].second;\\n                 end = myVec[i].first;\\n            }\\n        }\\n       // cout << count;\\n        return m-count;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<pair<int,int>> myVec;\\n        int m = intervals.size();\\n        int n = 2;\\n        for(int i=0;i<m;i++){\\n                myVec.push_back({intervals[i][1],intervals[i][0]});\\n        }\\n        sort(myVec.rbegin(),myVec.rend());\\n        int start,end;\\n        start = myVec[0].second;\\n        end = myVec[0].first;\\n        for(int i=0;i<m;i++){\\n            cout << myVec[i].first << myVec[i].second << endl;\\n        }\\n        int count=0;\\n        for(int i=1;i<m;i++){\\n            if(end >= myVec[i].first and start <= myVec[i].second){\\n                count++;\\n                //cout << \"interation #\" << i << endl;\\n            }\\n            else if(end==myVec[i].first and start > myVec[i].second)\\n            {\\n                count++;\\n              //  end=myVec[i].first;\\n                start=myVec[i].second;\\n            }\\n            else if(end>myVec[i].first and start == myVec[i].second)\\n            {    count++;\\n                end = myVec[i].first;\\n                \\n            }\\n            else{\\n                 start = myVec[i].second;\\n                 end = myVec[i].first;\\n            }\\n        }\\n       // cout << count;\\n        return m-count;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1786242,
                "title": "c-solution-easy-to-understand-simple",
                "content": "\\n\\nclass Solution {\\n\\n\\npublic:\\n\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n\\t\\n    int removeCoveredIntervals(vector<vector<int>>& nums) {\\n\\t\\n        sort(nums.begin(),nums.end(),cmp);\\n        int n=nums.size();\\n        int ans=0;\\n        int end=nums[0][1];\\n        for(int i=1;i<n;i++){\\n            if(nums[i][1]<=end) {\\n            ans++;\\n            }\\n            else{\\n                end=nums[i][1];\\n            }\\n        }\\n        return n-ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n\\npublic:\\n\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1786216,
                "title": "c-straight-forward-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a,vector<int>b){\\n        if(a[0]!=b[0])  return a[0]<b[0];\\n        else return a[1]>b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        int ans=1;\\n        int prev_a=intervals[0][0];\\n        int prev_b=intervals[0][1];\\n        int i=1;\\n        while(i<intervals.size()){\\n            if(intervals[i][1]>prev_b)\\n            {\\n                prev_b=intervals[i][1];\\n                ans++;\\n            }\\n            i++;\\n            \\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a,vector<int>b){\\n        if(a[0]!=b[0])  return a[0]<b[0];\\n        else return a[1]>b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        int ans=1;\\n        int prev_a=intervals[0][0];\\n        int prev_b=intervals[0][1];\\n        int i=1;\\n        while(i<intervals.size()){\\n            if(intervals[i][1]>prev_b)\\n            {\\n                prev_b=intervals[i][1];\\n                ans++;\\n            }\\n            i++;\\n            \\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786154,
                "title": "c-greedy-sort-using-comparator-easy-to-understand-explaination",
                "content": "[**@Iemprashant**](https://leetcode.com/iemprashant/) \\uD83D\\uDE80\\n**1288. Remove Covered Intervals**\\n```\\n1. C++ Code. \\uD83C\\uDF93\\n2. Please Upvote if it helps\\u2B06\\uFE0F\\n3. Detailed Approach \\u2705\\n4. Github Repository for code:->\\n\\n```\\n\\u26A1[ GithubRepo](https://github.com/iemprashant/LeetHub)\\n \\n**Observation** \\uD83D\\uDCCD\\n```\\nIdea-1=>if we get a particular then the intervals between that is covered=> [1,4] is max so all [1,2], [1,3] are covered\\nIdea-2=>if we sort the intervals then , the second interval start would be covered in the first one. (as [a,b) covers [c,d) when  a<=c && d<=b) ,So sorting will cover the a<=c condition.\\nIdea-3=> for covering the second condition we will sort the array in increasing order of start also if start  is same, we will sort in decreasing by finsih.\\n```\\n**=>[1,4],[2,9],[1,2],[3,6]**\\n```\\n       =>1____2____3____4____5____6____7____8____9\\n         1--------------4\\n              2---------------------------------9\\n         1----2      \\n                   3-----------------6\\n```\\n Clearly we Can see [3,6] is covererd\\n**Approach** \\uD83D\\uDEA9 \\n1:-> First sort the arrary using Comparator.\\n2:-> Compartor will sort in the ascending , when start is same then sort finish in decending.\\n3:-> Put size of interval in ans variable.\\n4:-> Now take a count of max reach done at every interval, initialize with -1.\\n5:-> Traverse the vector, as start is sorted and start condition is covered already (IDEA-2) , We will check only Condition 2.\\n6:->Now if finish of curr vector is less than max reach ,So Inteval is covered=> decrease ans by one.\\n7:->if finish of curr vector is greater than maxreach, so Update the maxreach.\\n8:-> Return the ans.\\uD83D\\uDE03\\n**CODE** \\uD83D\\uDCCB\\n```\\n\\nbool campare(vector<int>a,vector<int>b){\\n    if(a[0]< b[0]){\\n        return true;\\n    }\\n    if(a[0]== b[0] && a[1]>b[1]){\\n        return true;\\n    }\\n    return false;\\n}\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),campare);\\n        int anssize=intervals.size();\\n        if(anssize==1){\\n            return anssize;\\n        }\\n        int maxreach=-1;\\n        for(int i=0;i<intervals.size();i++){\\n            (intervals[i][1]<=maxreach)?anssize--:(maxreach=intervals[i][1]);\\n        }\\n        return anssize;\\n    }\\n};\\n```\\n\\nPlease Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n1. C++ Code. \\uD83C\\uDF93\\n2. Please Upvote if it helps\\u2B06\\uFE0F\\n3. Detailed Approach \\u2705\\n4. Github Repository for code:->\\n\\n```\n```\\nIdea-1=>if we get a particular then the intervals between that is covered=> [1,4] is max so all [1,2], [1,3] are covered\\nIdea-2=>if we sort the intervals then , the second interval start would be covered in the first one. (as [a,b) covers [c,d) when  a<=c && d<=b) ,So sorting will cover the a<=c condition.\\nIdea-3=> for covering the second condition we will sort the array in increasing order of start also if start  is same, we will sort in decreasing by finsih.\\n```\n```\\n       =>1____2____3____4____5____6____7____8____9\\n         1--------------4\\n              2---------------------------------9\\n         1----2      \\n                   3-----------------6\\n```\n```\\n\\nbool campare(vector<int>a,vector<int>b){\\n    if(a[0]< b[0]){\\n        return true;\\n    }\\n    if(a[0]== b[0] && a[1]>b[1]){\\n        return true;\\n    }\\n    return false;\\n}\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),campare);\\n        int anssize=intervals.size();\\n        if(anssize==1){\\n            return anssize;\\n        }\\n        int maxreach=-1;\\n        for(int i=0;i<intervals.size();i++){\\n            (intervals[i][1]<=maxreach)?anssize--:(maxreach=intervals[i][1]);\\n        }\\n        return anssize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786080,
                "title": "fast-and-easy-to-understand-o-nlg-n-time-and-o-1-memory-c-solution",
                "content": "This question can be solved greedily, you want to look at the big intervals first then check if the smaller ones are a subinterval.\\n\\nTo do that I implemented a custom comparator that asserts the fact that if there exists an interval [st<sub>i</sub>, fn<sub>i</sub>] and [st<sub>i+1</sub>, fn<sub>i+1</sub>] either st<sub>i+1</sub> > st<sub>i</sub> or (st<sub>i+1</sub> == st<sub>i</sub> and fn<sub>i</sub> >= fn<sub>i+1</sub>).\\n\\nAfter sorting the intervals grab the first element in the intervals array and save it in a tmp variable because it is part of your solution since all the coming elements have a starting value that is greater than it or and ending value that is smaller than it.\\n\\nThen iterate on the intervals array, If you come across an interval that is covered by the tmp variable simply skip that interval, however if you come across an interval that is not covered replace the tmp\\'s value with the new interval\\'s value. You can do that safely because the sorting ensures that no upcoming starting value will be less than the tmp\\'s starting value, thus no uncovered interval will be missed.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        auto cmp = [](vector<int>& v1, vector<int>& v2)->bool {\\n            return v1[0] < v2[0] or (v1[0] == v2[0] and v1[1] >= v2[1]);\\n        };\\n        \\n        sort(intervals.begin(), intervals.end(), cmp);\\n        \\n        int ans = 1;\\n        \\n        vector<int> tmp = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); ++i) {\\n            int st = max(intervals[i][0], tmp[0]);\\n            int fn = min(intervals[i][1], tmp[1]);\\n            \\n            if (st != intervals[i][0] or fn != intervals[i][1]) {\\n                tmp = intervals[i]; ans +=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        auto cmp = [](vector<int>& v1, vector<int>& v2)->bool {\\n            return v1[0] < v2[0] or (v1[0] == v2[0] and v1[1] >= v2[1]);\\n        };\\n        \\n        sort(intervals.begin(), intervals.end(), cmp);\\n        \\n        int ans = 1;\\n        \\n        vector<int> tmp = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); ++i) {\\n            int st = max(intervals[i][0], tmp[0]);\\n            int fn = min(intervals[i][1], tmp[1]);\\n            \\n            if (st != intervals[i][0] or fn != intervals[i][1]) {\\n                tmp = intervals[i]; ans +=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785918,
                "title": "c-simple-solution-easy-to-understand-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),[](const vector<int> &a,const vector<int> &b){\\n            if(a[0]!=b[0]){\\n                return a[0]<b[0];\\n            }else {\\n                return a[1]>b[1];\\n            }\\n        });\\n        int num=0;\\n        bool check = 0;\\n        int l,r;\\n        int i=0;\\n        while(i<intervals.size()){\\n            if(check){\\n                if(intervals[i][0]>=l and intervals[i][1]<=r){\\n                    i++;\\n                }else{\\n                    check=0;\\n                }\\n            }else{\\n                num++;\\n                check=1;\\n                l=intervals[i][0],r=intervals[i][1];\\n                i++;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),[](const vector<int> &a,const vector<int> &b){\\n            if(a[0]!=b[0]){\\n                return a[0]<b[0];\\n            }else {\\n                return a[1]>b[1];\\n            }\\n        });\\n        int num=0;\\n        bool check = 0;\\n        int l,r;\\n        int i=0;\\n        while(i<intervals.size()){\\n            if(check){\\n                if(intervals[i][0]>=l and intervals[i][1]<=r){\\n                    i++;\\n                }else{\\n                    check=0;\\n                }\\n            }else{\\n                num++;\\n                check=1;\\n                l=intervals[i][0],r=intervals[i][1];\\n                i++;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785871,
                "title": "c-easy-to-understand-sorting",
                "content": "If we simply apply ``` sort(intervals.begin(), intervals.end()) ``` then output will be ``` [[1,2],[1,4],[3,4]] ```. \\n\\nIn this case covering interval [1,4] is coming after the covered interval [1,2].\\n\\nHence we have to modify the sorting in such a way that whenever two intervals have same start, the interval having higher end value should come first. Following function is used for the same.\\n\\n```\\nbool static compare( const vector<int>& v1, const vector<int>& v2 ) \\n    {\\n        if(v1[0]==v2[0])\\n            return v1[1]>v2[1];\\n        else\\n            return v1[0] < v2[0];\\n    }\\n```\\t\\nCode:\\n```\\nclass Solution {\\npublic:\\n    \\n    bool static compare( const vector<int>& v1, const vector<int>& v2 ) \\n    {\\n        if(v1[0]==v2[0])\\n            return v1[1]>v2[1];\\n        else\\n            return v1[0] < v2[0];\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) \\n    {\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        int count = 0, start = 0;\\n        \\n        for(int i=1; i<intervals.size(); i++)\\n        {\\n            if(intervals[start][1] >= intervals[i][1])\\n                count++;\\n            else\\n                start = i;\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```\\n\\n\\n\\t\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "``` sort(intervals.begin(), intervals.end()) ```\n``` [[1,2],[1,4],[3,4]] ```\n```\\nbool static compare( const vector<int>& v1, const vector<int>& v2 ) \\n    {\\n        if(v1[0]==v2[0])\\n            return v1[1]>v2[1];\\n        else\\n            return v1[0] < v2[0];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool static compare( const vector<int>& v1, const vector<int>& v2 ) \\n    {\\n        if(v1[0]==v2[0])\\n            return v1[1]>v2[1];\\n        else\\n            return v1[0] < v2[0];\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) \\n    {\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        int count = 0, start = 0;\\n        \\n        for(int i=1; i<intervals.size(); i++)\\n        {\\n            if(intervals[start][1] >= intervals[i][1])\\n                count++;\\n            else\\n                start = i;\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785803,
                "title": "java-sorting-just-calculate-the-right-maximum",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n\\t\\t//  consider no overlapping by default so answer will be the size of the intervals[][]\\n\\t\\tint answer = n;\\n        Arrays.sort(intervals, (a, b) -> {\\n            if (a[0] != b[0]) {\\n                return a[0] - b[0];\\n            }\\n            return b[1] - a[1];\\n        });\\n        \\n        //  right Maximum reach\\n        int rightSpan = intervals[0][1];\\n        for (int i = 1; i < n; i++) {\\n            int[] interval = intervals[i];\\n            int start = interval[0];\\n            int end = interval[1];\\n            if (end <= rightSpan) {\\n\\t\\t\\t    //  every time we see an overlapping decrease our answer by one \\n                answer--;\\n            } else {\\n\\t\\t\\t\\t// if no overlapping this means the current end is greater than the \\n\\t\\t\\t\\t// previous end so update the rightSpan\\n                rightSpan = end;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n/*\\n\\nNOTE : * we are not considering the start of the current interval because we have \\n\\t     sorted our array on the basis of start time.\\n\\t   * If the start time are same we want the interval with the greater end time \\n     \\t to maximize the covering of intervals.\\n\\n*/\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n\\t\\t//  consider no overlapping by default so answer will be the size of the intervals[][]\\n\\t\\tint answer = n;\\n        Arrays.sort(intervals, (a, b) -> {\\n            if (a[0] != b[0]) {\\n                return a[0] - b[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1785760,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        \\n        // if start time is different then one with lesser start time will come first\\n        // if start time is same then the one with larger end time will come first\\n        \\n        sort(intervals.begin(), intervals.end(), [&](vector<int> &i1, vector<int> &i2) {\\n            if(i1[0] == i2[0]) return i1[1] > i2[1];\\n            else return i1[0] < i2[0];\\n        });\\n        int maxEnd = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(maxEnd >= intervals[i][1]) {\\n                cnt++;\\n            } \\n            maxEnd = max(maxEnd, intervals[i][1]);\\n        }\\n        return n - cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        \\n        // if start time is different then one with lesser start time will come first\\n        // if start time is same then the one with larger end time will come first\\n        \\n        sort(intervals.begin(), intervals.end(), [&](vector<int> &i1, vector<int> &i2) {\\n            if(i1[0] == i2[0]) return i1[1] > i2[1];\\n            else return i1[0] < i2[0];\\n        });\\n        int maxEnd = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(maxEnd >= intervals[i][1]) {\\n                cnt++;\\n            } \\n            maxEnd = max(maxEnd, intervals[i][1]);\\n        }\\n        return n - cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785717,
                "title": "python-sort-o-nlogn-with-comments",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        # sort the interval by its 0th index\\n        intervals.sort()\\n        ans = 1\\n        i = 1\\n        curr = intervals[0]\\n        while i < len(intervals):\\n            # if [1,3] [1,5] [1,7] exists we should ideally count them as 1 as 1,7 will cover both 1,3 and 1,5\\n            if curr[0]==intervals[i][0]:\\n                curr = [curr[0],max(curr[1],intervals[i][1])]\\n            # when a previous interval couldn\\'t cover current interval,\\n            # add 1 to ans and update curr\\n            elif curr[1] < intervals[i][1]:\\n                ans+=1\\n                curr = intervals[i]\\n            i+=1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        # sort the interval by its 0th index\\n        intervals.sort()\\n        ans = 1\\n        i = 1\\n        curr = intervals[0]\\n        while i < len(intervals):\\n            # if [1,3] [1,5] [1,7] exists we should ideally count them as 1 as 1,7 will cover both 1,3 and 1,5\\n            if curr[0]==intervals[i][0]:\\n                curr = [curr[0],max(curr[1],intervals[i][1])]\\n            # when a previous interval couldn\\'t cover current interval,\\n            # add 1 to ans and update curr\\n            elif curr[1] < intervals[i][1]:\\n                ans+=1\\n                curr = intervals[i]\\n            i+=1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785678,
                "title": "python-sorting-98-faster-96-space-efficient",
                "content": "![image](https://assets.leetcode.com/users/images/f63b972a-f6c3-4342-8107-8da12e59aa6d_1645342587.2552063.png)\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        c = len(intervals)\\n        intervals.sort(key=lambda x: x[0])\\n        x, y = intervals[0]\\n        for i in range(1, len(intervals)):\\n            if x <= intervals[i][0] and intervals[i][1] <= y:\\n                c -= 1\\n                continue\\n            if intervals[i][0] <= x and y <= intervals[i][1]:\\n                c -= 1\\n            x, y = intervals[i][0], intervals[i][1]\\n        return c\\n```\\n\\n**Pleas upvote if you find it useful and interesting!!!\\nThank you.**",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        c = len(intervals)\\n        intervals.sort(key=lambda x: x[0])\\n        x, y = intervals[0]\\n        for i in range(1, len(intervals)):\\n            if x <= intervals[i][0] and intervals[i][1] <= y:\\n                c -= 1\\n                continue\\n            if intervals[i][0] <= x and y <= intervals[i][1]:\\n                c -= 1\\n            x, y = intervals[i][0], intervals[i][1]\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785593,
                "title": "c-very-easy-solution-using-stack",
                "content": "c++ solution using stack\\n```\\n int removeCoveredIntervals(vector<vector<int>>& inter) {\\n        sort(inter.begin(),inter.end());\\n        stack<vector<int>>st;\\n        for(auto x:inter)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(x);\\n            }\\n            else\\n            {\\n                vector<int>v=st.top();\\n                if(x[1]<=v[1])\\n                    continue;\\n                else if(x[0]==v[0]&&x[1]>v[1])\\n                {\\n                    st.pop();\\n                    \\n                }\\n               st.push(x);\\n            }\\n            \\n        }\\n        return st.size();\\n    }\\n\\t\\n\\t//if u find it helpfull please upvote.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "c++ solution using stack\\n```\\n int removeCoveredIntervals(vector<vector<int>>& inter) {\\n        sort(inter.begin(),inter.end());\\n        stack<vector<int>>st;\\n        for(auto x:inter)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(x);\\n            }\\n            else\\n            {\\n                vector<int>v=st.top();\\n                if(x[1]<=v[1])\\n                    continue;\\n                else if(x[0]==v[0]&&x[1]>v[1])\\n                {\\n                    st.pop();\\n                    \\n                }\\n               st.push(x);\\n            }\\n            \\n        }\\n        return st.size();\\n    }\\n\\t\\n\\t//if u find it helpfull please upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 1785569,
                "title": "clear-explanation-intuitive-java",
                "content": "It is obvious that we will consider all the intervals with larger length before considering the shorter ones. Now we have two options, either to sort by the end time or start time. \\n\\nLet\\'s sort by the end time. Consider you have intervals: `[[1,10],[3,4],[5,6],[1,2]]`\\nAfter sorting the intervals from end time our intervals array will be: `[[1,2],[3,4],[5,6],[1,10]]`\\nAs we can see, our very last interval `[1,10]` covers all the intervals before it, but we wont be able to keep track of the interval it covers as it is the last element in the array, hence we discard sorting by end time. ( There might be a solution which sorts by end time, so if you have come across one feel free to share) \\n\\nLet\\'s sort by start time. Considering the same intervals, After sorting by start time we will have `[[1,2],[1,10],[3,4],[5,6]]`\\nNow as we can see `[1,2]` comes under `[1,10]` but for simplicity we will consider having `[1,10]` before `[1,2]` because it covers large interval length. Hence we will sort by start time first, in case the start time is equal we will have the larger end time first. So now our array will look something like:` [[1,10],[1,2],[3,4],[5,6]]`\\n\\nWe will take each interval one by one and see if it covers next one:\\n\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, (i1,i2) -> (i1[0]==i2[0]?i2[1]-i1[1]:i1[0]-i2[0]));\\n        int c = intervals[0][0], d = intervals[0][1];\\n        int ans = intervals.length;\\n        for(int i=1;i<intervals.length;i++){\\n            int a = intervals[i][0], b = intervals[i][1];\\n            if(c<=a && b<=d) ans--; \\n            else {\\n                c = a;\\n                d = b;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, (i1,i2) -> (i1[0]==i2[0]?i2[1]-i1[1]:i1[0]-i2[0]));\\n        int c = intervals[0][0], d = intervals[0][1];\\n        int ans = intervals.length;\\n        for(int i=1;i<intervals.length;i++){\\n            int a = intervals[i][0], b = intervals[i][1];\\n            if(c<=a && b<=d) ans--; \\n            else {\\n                c = a;\\n                d = b;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785514,
                "title": "java-merge-intervals-approach",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int start;\\n        int end;\\n        Pair(int start,int end){\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Pair p[] = new Pair[intervals.length];\\n        for(int i=0;i<intervals.length;i++){\\n            p[i]=new Pair(intervals[i][0], intervals[i][1]);\\n        }\\n        Arrays.sort(p, new Comparator<Pair>(){\\n            public int compare(Pair p1, Pair p2){\\n                if(p1.start!=p2.start)\\n                    return p1.start-p2.start;\\n                return p2.end-p1.end;\\n            }\\n        });\\n        Stack<Pair> st = new Stack<Pair>();\\n        int ans=0;\\n        st.push(p[0]);\\n        for(int i=1;i<p.length;i++){\\n            Pair top = st.peek();\\n            if(p[i].start>=top.start && p[i].end<=top.end){\\n                continue;\\n            }\\n            st.push(p[i]);\\n            \\n            \\n        }\\n        \\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int start;\\n        int end;\\n        Pair(int start,int end){\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Pair p[] = new Pair[intervals.length];\\n        for(int i=0;i<intervals.length;i++){\\n            p[i]=new Pair(intervals[i][0], intervals[i][1]);\\n        }\\n        Arrays.sort(p, new Comparator<Pair>(){\\n            public int compare(Pair p1, Pair p2){\\n                if(p1.start!=p2.start)\\n                    return p1.start-p2.start;\\n                return p2.end-p1.end;\\n            }\\n        });\\n        Stack<Pair> st = new Stack<Pair>();\\n        int ans=0;\\n        st.push(p[0]);\\n        for(int i=1;i<p.length;i++){\\n            Pair top = st.peek();\\n            if(p[i].start>=top.start && p[i].end<=top.end){\\n                continue;\\n            }\\n            st.push(p[i]);\\n            \\n            \\n        }\\n        \\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785494,
                "title": "greedy-simple-o-nlogn-tc-and-o-n-space",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    static bool sortcol(const vector<int>& v1,const vector<int>& v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }else{\\n            return v1[0]<v2[0];\\n        }\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),sortcol);\\n        vector<pair<int,int>>vec;\\n        auto it=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(it[0]<=intervals[i][0] and it[1]>=intervals[i][1]){\\n                continue;\\n            }else{\\n                vec.push_back({it[0],it[1]});\\n                it=intervals[i];\\n            }\\n        }\\n        return vec.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortcol(const vector<int>& v1,const vector<int>& v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }else{\\n            return v1[0]<v2[0];\\n        }\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),sortcol);\\n        vector<pair<int,int>>vec;\\n        auto it=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(it[0]<=intervals[i][0] and it[1]>=intervals[i][1]){\\n                continue;\\n            }else{\\n                vec.push_back({it[0],it[1]});\\n                it=intervals[i];\\n            }\\n        }\\n        return vec.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785478,
                "title": "c-easy-sorting-solution-approach-explained",
                "content": "First we sort the intervals based on their starting value, then we keep storing the max time and min time till now. If any interval is in between min and max i.e. it has been covered already so we increment count. Count will give us number of intervals to be removed. So, number of intervals left= Total no. of intervals- count.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>v1, vector<int>v2){\\n        if(v1[0]==v2[0]) return v1[1]>v2[1]; //If starting value is same, sort on the basis of second value\\n        return v1[0]<v2[0];\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size(),count=0;\\n        if(n==1) return 1; \\n        sort(intervals.begin(),intervals.end(), comp);\\n        int mini=intervals[0][0], maxi=intervals[0][1];\\n        \\n        for(int i=1; i<intervals.size();i++){\\n            if(intervals[i][0]>=mini && intervals[i][1]<=maxi) count++;\\n            maxi=max(maxi,intervals[i][1]);\\n            mini=min(mini,intervals[i][0]);\\n        }\\n        return n-count;\\n    }\\n};\\n```\\nHope you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>v1, vector<int>v2){\\n        if(v1[0]==v2[0]) return v1[1]>v2[1]; //If starting value is same, sort on the basis of second value\\n        return v1[0]<v2[0];\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size(),count=0;\\n        if(n==1) return 1; \\n        sort(intervals.begin(),intervals.end(), comp);\\n        int mini=intervals[0][0], maxi=intervals[0][1];\\n        \\n        for(int i=1; i<intervals.size();i++){\\n            if(intervals[i][0]>=mini && intervals[i][1]<=maxi) count++;\\n            maxi=max(maxi,intervals[i][1]);\\n            mini=min(mini,intervals[i][0]);\\n        }\\n        return n-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785331,
                "title": "c-detailed-explanation-of-sort-and-edge-case-logic",
                "content": "First and foremost, we sort the intervals by each\\'s start value. Therefore, an input like `[[1,4],[3,6],[2,8]]` becomes `[[1,4],[2,8],[3,6]]`. Note how we now do not need to explicitly check whether a given interval\\'s start is >= the previous one.\\n\\nAll we need to do now is to traverse through this sorted list of intervals. For each interval, we need to check whether the right index (6 in `(3,6)`) is <= the previous right index (8 in `(2,8)`). If so, the current interval `(3,6)` will be covered by the previous one `(2,8)` and hence we don\\'t count it in the list of intervals that will remain.\\n\\nIf however, the current interval\\'s right index (8 in `(2,8)`) is greater than the previous interval\\'s right index (4 in `(1,4)`), then there is no overlap and hence we must count the current interval.\\n\\n---\\n\\nHowever, there is an **edge case** here which needs to be considered. Say we have something like `[[3,9],[3,10]]` after sorting. Now obviously `[3,9]` is covered by `[3,10]` but because 10 > 9, we will end up counting both.\\n\\nThis issue essentially occurs because at each step we are checking whether the previous interval can cover the current one, but not vice versa, which is precisely the case in this above example. Note an important point here. Because we are sorting the intervals (albeit by the start index), the above scenario can occur only if `prev_left == cur_left`. We know for a fact that `cur_left` can never be greater than `prev_left`, and if the current interval can cover the previous interval, then `prev_left has to be == cur_left`.\\n\\nThe solution for this issue is simple enough:\\nWhile sorting, we shall normally choose the interval whose start index is smaller. If, however, the cur_left == prev_left, then we shall choose the interval whose end index is greater (i.e. we arrange intervals in descending order of their end indices).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n\\t\\tsort(intervals.begin(), intervals.end(),\\n             [](vector<int> a, vector<int> b)\\n             { return (a[0] != b[0]) ? (a[0] < b[0]) : a[1] > b[1]; }\\n            );\\n        \\n        int prev_left = -1, prev_right = -1;\\n        int cnt = 0;\\n        \\n        for(int i = 0; i < intervals.size(); i++)\\n        {\\n            int cur_left = intervals[i][0], cur_right = intervals[i][1];\\n            \\n            // if cur_right > prev_right i.e. we do not have an overlapping interval\\n            if(cur_right > prev_right)\\n            {\\n                // update prev_right to now indicate to current interval\\'s right\\n                prev_right = cur_right;\\n                // this interval cannot be covered so include it\\n                ++cnt;\\n            }\\n\\n\\t\\t\\t// update prev_left to now indicate to current interval\\'s left\\n            prev_left = cur_left;\\n        }\\n        \\n        return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n\\t\\tsort(intervals.begin(), intervals.end(),\\n             [](vector<int> a, vector<int> b)\\n             { return (a[0] != b[0]) ? (a[0] < b[0]) : a[1] > b[1]; }\\n            );\\n        \\n        int prev_left = -1, prev_right = -1;\\n        int cnt = 0;\\n        \\n        for(int i = 0; i < intervals.size(); i++)\\n        {\\n            int cur_left = intervals[i][0], cur_right = intervals[i][1];\\n            \\n            // if cur_right > prev_right i.e. we do not have an overlapping interval\\n            if(cur_right > prev_right)\\n            {\\n                // update prev_right to now indicate to current interval\\'s right\\n                prev_right = cur_right;\\n                // this interval cannot be covered so include it\\n                ++cnt;\\n            }\\n\\n\\t\\t\\t// update prev_left to now indicate to current interval\\'s left\\n            prev_left = cur_left;\\n        }\\n        \\n        return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785283,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comparator(vector<int>a, vector<int>b){\\n        if(a[0] > b[0]) \\n            return false;\\n        else if (a[0] == b[0] && a[1] < b[1]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comparator);\\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        int count=1;\\n        \\n        for(int i=1;i<intervals.size();i++){\\n            if(start <= intervals[i][0] && end >= intervals[i][1])\\n                continue;\\n            else{\\n                ++count;\\n                start = intervals[i][0];\\n                end = intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    static bool comparator(vector<int>a, vector<int>b){\\n        if(a[0] > b[0]) \\n            return false;\\n        else if (a[0] == b[0] && a[1] < b[1]){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1785058,
                "title": "c-very-easy-solution-simple",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void func(vector<vector<int>>&intervals)\\n    {\\n        int n= intervals.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(intervals[i-1][0]==intervals[i][0])\\n            {\\n                if(intervals[i-1][1]<intervals[i][1])\\n                    swap(intervals[i-1][1],intervals[i][1]);\\n            }\\n        }\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals)\\n\\t{\\n        \\n      sort(intervals.begin(),intervals.end());          // sort them based on interval(i)\\n\\t\\t\\tfunc(intervals);         // if interval [i]== interval [i-1] then we consider the larger interval\\n        int count=1, low= intervals[0][0], high=intervals[0][1];         // we always consider the first value after the sorting \\n       for(int i=1;i<intervals.size();i++)\\n       {\\n          if(intervals[i][1]>high)\\n          {\\n              count++;       // increment everytime we are out of the higher bound\\n              high= intervals[i][1];\\n          }\\n       }\\n        return count;  \\n     }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    void func(vector<vector<int>>&intervals)\\n    {\\n        int n= intervals.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(intervals[i-1][0]==intervals[i][0])\\n            {\\n                if(intervals[i-1][1]<intervals[i][1])\\n                    swap(intervals[i-1][1],intervals[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1785028,
                "title": "2-solutions-c-sorting",
                "content": "***Applying Brute force after Sorting:***\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 ,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int cnt=0;\\n        for(int i=1;i<intervals.size();i++){\\n            int s=intervals[i][0];\\n            int e=intervals[i][1];\\n            for(int j=i-1;j>=0;j--){\\n                int currs=intervals[j][0];\\n                int curre=intervals[j][1];\\n                if(s>=currs && e<=curre){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```\\n\\n***Better Approach :***\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 ,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int cnt=0;\\n        int mxend=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][1]<=mxend){\\n                cnt++;\\n            }\\n            else{\\n                mxend=intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```\\n### *Please Upvote if you like the approach :)*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 ,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int cnt=0;\\n        for(int i=1;i<intervals.size();i++){\\n            int s=intervals[i][0];\\n            int e=intervals[i][1];\\n            for(int j=i-1;j>=0;j--){\\n                int currs=intervals[j][0];\\n                int curre=intervals[j][1];\\n                if(s>=currs && e<=curre){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 ,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int cnt=0;\\n        int mxend=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][1]<=mxend){\\n                cnt++;\\n            }\\n            else{\\n                mxend=intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784895,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(arr1,arr2)->Integer.compare(arr1[0],arr2[0]));\\n        int[] curr=new int[]{-1,-1};\\n        int result=0;\\n        for(int[] interval:intervals){\\n            if(interval[0]>curr[0] && interval[1]>curr[1]){\\n                curr[0]=interval[0];\\n                result++;\\n            }\\n            curr[1]=Math.max(curr[1],interval[1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(arr1,arr2)->Integer.compare(arr1[0],arr2[0]));\\n        int[] curr=new int[]{-1,-1};\\n        int result=0;\\n        for(int[] interval:intervals){\\n            if(interval[0]>curr[0] && interval[1]>curr[1]){\\n                curr[0]=interval[0];\\n                result++;\\n            }\\n            curr[1]=Math.max(curr[1],interval[1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784493,
                "title": "java-reuse-lc-56-explained",
                "content": "**Idea:**\\n* The solution is pretty similar to that of [LC 56. Merge Intervals](https://leetcode.com/problems/merge-intervals/discuss/1645484/Java-or-Greedy-or-Simple-with-comments)\\n* Sort by start time\\n* Start remaining intervals with value = size(intervals), i.e. initially all intervals are remaining \\n* For each interval pair, check if one is covered by the other. \\n* If either covers the other then, then this interval will be used for the next iteration. Reduce remaining by 1\\n* Else the latter interval will be used for the next iteration\\n\\n**Example:** [[1, 4],[3, 6],[2, 8]]\\n```\\nSort by start = [[1, 4],[2, 8],[3, 6]]\\n\\nprev = [1, 4], current = [2, 8], remaining = 3\\nneither covers the other, update prev = [2, 8], current = [3, 6]\\n\\nprev = [2, 8], current = [3, 6], remaining = 3\\nprev covers current, remaining = 2\\n\\n[Ans] 2\\n```\\n>**T/S:** O(n lg n)/O(n)\\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\tArrays.sort(intervals, Comparator.comparingInt(i -> i[0]));\\n\\tvar remaining = intervals.length;\\n\\n\\tfor (int i = 1, prev[] = intervals[0]; i < intervals.length; i++)\\n\\t\\tif (prev[0] <= intervals[i][0] && intervals[i][1] <= prev[1]) {\\n\\t\\t\\tremaining--;\\n\\t\\t} else {\\n\\t\\t\\tif (intervals[i][0] <= prev[0] && prev[1] <= intervals[i][1])\\n\\t\\t\\t\\tremaining--;\\n\\t\\t\\tprev = intervals[i];\\n\\t\\t}\\n\\n\\treturn remaining;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nSort by start = [[1, 4],[2, 8],[3, 6]]\\n\\nprev = [1, 4], current = [2, 8], remaining = 3\\nneither covers the other, update prev = [2, 8], current = [3, 6]\\n\\nprev = [2, 8], current = [3, 6], remaining = 3\\nprev covers current, remaining = 2\\n\\n[Ans] 2\\n```\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\tArrays.sort(intervals, Comparator.comparingInt(i -> i[0]));\\n\\tvar remaining = intervals.length;\\n\\n\\tfor (int i = 1, prev[] = intervals[0]; i < intervals.length; i++)\\n\\t\\tif (prev[0] <= intervals[i][0] && intervals[i][1] <= prev[1]) {\\n\\t\\t\\tremaining--;\\n\\t\\t} else {\\n\\t\\t\\tif (intervals[i][0] <= prev[0] && prev[1] <= intervals[i][1])\\n\\t\\t\\t\\tremaining--;\\n\\t\\t\\tprev = intervals[i];\\n\\t\\t}\\n\\n\\treturn remaining;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784479,
                "title": "java-easy-solution-beats-99-of-submission-runtime-2ms",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int count=0;\\n        for(int i=0;i<intervals.length;i++)\\n        {\\n            for(int j=0;j<intervals.length;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<= intervals[j][1])\\n                    {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return intervals.length-count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int count=0;\\n        for(int i=0;i<intervals.length;i++)\\n        {\\n            for(int j=0;j<intervals.length;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<= intervals[j][1])\\n                    {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return intervals.length-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688141,
                "title": "c-custom-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(vector<int>a, vector<int>b){\\n             if(a[0] > b[0]) return false;\\n             else if(a[0] == b[0] && a[1] < b[1]) return false;\\n             return true;\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n         \\n          sort(intervals.begin(),intervals.end(),comp);\\n         int maximum_end = intervals[0][1], covered_intervals = 0;\\n         for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][1] <= maximum_end) {\\n                covered_intervals++;\\n            }\\n            maximum_end = max(maximum_end, intervals[i][1]);\\n        }\\n        return intervals.size() - covered_intervals;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    static bool comp(vector<int>a, vector<int>b){\\n             if(a[0] > b[0]) return false;\\n             else if(a[0] == b[0] && a[1] < b[1]) return false;\\n             return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1549430,
                "title": "python-sort-solution-with-explanation",
                "content": "The logic is very straigtforward and easy to understand. If there is any part that\\'s not clear, please feel free to ask. \\n```\\n    def removeCoveredIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n    #Sort the list with increasing first index, and decreasing second index if the first index is same as previous element.\\n       \\n    #Example: [[1,2],[1,4],[2,4]]  will become [[1,4],[1,2],[2,4]] --> increasing on first and decreasing on second index\\n        \\n    # We need this because in above example [1,4] will give us maximum range. If we picked [1,2], the algorithm would think [1,4] is also needed to increase the range. Hoever if we just picked [1,4] in the first place, we won\\'t need [1,2]\\n    \\n        sored_interval = sorted(intervals, key = lambda x:(x[0],-x[1]) )\\n        start = float(\\'inf\\')\\n        end = float(\\'-inf\\')\\n        total = 0\\n        \\n        for interval in sored_interval:\\n            if interval[0] < start or interval[1] > end:\\n                total +=1\\n            prev = interval[0]\\n            start = min(start,interval[0])\\n            end = max(end,interval[1])\\n        return total\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    def removeCoveredIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n    #Sort the list with increasing first index, and decreasing second index if the first index is same as previous element.\\n       \\n    #Example: [[1,2],[1,4],[2,4]]  will become [[1,4],[1,2],[2,4]] --> increasing on first and decreasing on second index\\n        \\n    # We need this because in above example [1,4] will give us maximum range. If we picked [1,2], the algorithm would think [1,4] is also needed to increase the range. Hoever if we just picked [1,4] in the first place, we won\\'t need [1,2]\\n    \\n        sored_interval = sorted(intervals, key = lambda x:(x[0],-x[1]) )\\n        start = float(\\'inf\\')\\n        end = float(\\'-inf\\')\\n        total = 0\\n        \\n        for interval in sored_interval:\\n            if interval[0] < start or interval[1] > end:\\n                total +=1\\n            prev = interval[0]\\n            start = min(start,interval[0])\\n            end = max(end,interval[1])\\n        return total\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1423517,
                "title": "simple-c-24ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int begin = INT_MAX;\\n        int end = INT_MIN;\\n        begin = min(begin,intervals[0][0]);\\n        end = max(end,intervals[0][1]);\\n        vector<vector<int>>interim;\\n        interim.push_back({begin,end});\\n        for(int i = 1;i<intervals.size();i++)\\n        {\\n           int val1 = intervals[i][0];\\n           int val2 = intervals[i][1];\\n           if(val1>=interim.back()[0] and val2<=interim.back()[1])\\n               continue;\\n         \\n           else if(val1<=interim.back()[0] and val2>interim.back()[1])\\n           {\\n               interim.back()[0] = val1;\\n               interim.back()[1] = val2;\\n           }\\n              else if(val1>=interim.back()[0] and val2>interim.back()[1])\\n               interim.push_back({val1,val2});\\n        }\\n        int n = interim.size();\\n        return n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int begin = INT_MAX;\\n        int end = INT_MIN;\\n        begin = min(begin,intervals[0][0]);\\n        end = max(end,intervals[0][1]);\\n        vector<vector<int>>interim;\\n        interim.push_back({begin,end});\\n        for(int i = 1;i<intervals.size();i++)\\n        {\\n           int val1 = intervals[i][0];\\n           int val2 = intervals[i][1];\\n           if(val1>=interim.back()[0] and val2<=interim.back()[1])\\n               continue;\\n         \\n           else if(val1<=interim.back()[0] and val2>interim.back()[1])\\n           {\\n               interim.back()[0] = val1;\\n               interim.back()[1] = val2;\\n           }\\n              else if(val1>=interim.back()[0] and val2>interim.back()[1])\\n               interim.push_back({val1,val2});\\n        }\\n        int n = interim.size();\\n        return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319872,
                "title": "java-brute-force-sorting-3ms-beats-97-t-c-o-nlogn-s-c-o-1",
                "content": "\\n\\n\\t// Brute Force\\n\\t// O(n*n) O(1)\\n\\tpublic int removeCoveredIntervals1(int[][] intervals) {\\n\\n\\t\\tint len = intervals.length, rem = len;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (overlap(intervals[i], intervals[j])) {\\n\\t\\t\\t\\t\\trem--;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn rem;\\n\\t}\\n\\n\\t// Overlapping\\n\\t// O(1) O(1)\\n\\tpublic boolean overlap(int[] cand, int[] interval) {\\n\\t\\treturn (interval[0] <= cand[0] && cand[1] <= interval[1]);\\n\\t}\\n\\n\\t// Sorting\\n\\t// O(nlogn) O(1)\\n\\tpublic int removeCoveredIntervals2(int[][] intervals) {\\n\\n\\t\\tint len = intervals.length, rem = len;\\n\\t\\tArrays.sort(intervals, new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn (o1[0] != o2[0]) ? o1[0] - o2[0] : o2[1] - o1[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint end = intervals[0][1];\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (intervals[i][1] <= end)\\n\\t\\t\\t\\trem--;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t}\\n\\t\\treturn rem;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// Brute Force\\n\\t// O(n*n) O(1)\\n\\tpublic int removeCoveredIntervals1(int[][] intervals) {\\n\\n\\t\\tint len = intervals.length, rem = len;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (overlap(intervals[i], intervals[j])) {\\n\\t\\t\\t\\t\\trem--;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn rem;\\n\\t}\\n\\n\\t// Overlapping\\n\\t// O(1) O(1)\\n\\tpublic boolean overlap(int[] cand, int[] interval) {\\n\\t\\treturn (interval[0] <= cand[0] && cand[1] <= interval[1]);\\n\\t}\\n\\n\\t// Sorting\\n\\t// O(nlogn) O(1)\\n\\tpublic int removeCoveredIntervals2(int[][] intervals) {\\n\\n\\t\\tint len = intervals.length, rem = len;\\n\\t\\tArrays.sort(intervals, new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn (o1[0] != o2[0]) ? o1[0] - o2[0] : o2[1] - o1[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint end = intervals[0][1];\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (intervals[i][1] <= end)\\n\\t\\t\\t\\trem--;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t}\\n\\t\\treturn rem;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1275377,
                "title": "easy-c-solution-o-nlogn-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> a,pair<int,int> b) {\\n          if(a.first==b.first) return a.second>b.second;\\n          else return a.first<b.first;\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& in) {\\n          vector<pair<int,int>> px;\\n          for(int i=0; i<in.size(); i++) px.push_back(make_pair(in[i][0],in[i][1]));\\n          sort(px.begin(),px.end(),comp);\\n          pair<int,int> cur=px.front();\\n          int del=0;\\n          for(int i=1; i<px.size(); i++) {\\n                 del+=(cur.first<=px[i].first && px[i].second<=cur.second);\\n                 cur=make_pair(min(px[i].first,cur.first),max(cur.second,px[i].second)); \\n          }\\n        return (int)in.size()-del; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> a,pair<int,int> b) {\\n          if(a.first==b.first) return a.second>b.second;\\n          else return a.first<b.first;\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& in) {\\n          vector<pair<int,int>> px;\\n          for(int i=0; i<in.size(); i++) px.push_back(make_pair(in[i][0],in[i][1]));\\n          sort(px.begin(),px.end(),comp);\\n          pair<int,int> cur=px.front();\\n          int del=0;\\n          for(int i=1; i<px.size(); i++) {\\n                 del+=(cur.first<=px[i].first && px[i].second<=cur.second);\\n                 cur=make_pair(min(px[i].first,cur.first),max(cur.second,px[i].second)); \\n          }\\n        return (int)in.size()-del; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252228,
                "title": "easy-c-solution-commnted",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        //sort the intervals\\n        \\n        sort(intervals.begin(),intervals.end());\\n        int i=0;\\n        int j=1;\\n        int len=intervals.size();\\n        int removed=0;\\n        while(j<len)\\n        {\\n            //check whether interval i is covered by interval j\\n            if(intervals[j][0]<=intervals[i][0] && intervals[i][1]<=intervals[j][1])\\n            {\\n                //remove interval i since it is covered\\n                removed++;\\n                i=j;\\n                j++;\\n            }\\n            //check if interval j is covered by interval i\\n            else if(intervals[i][0]<=intervals[j][0] && intervals[j][1]<=intervals[i][1])\\n            {\\n                //remove interval j\\n                removed++;\\n                j++;\\n            }\\n            else\\n            {\\n                //if none of them have covered by each other\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        //return the remaining intervals\\n        return len-removed;\\n    }\\n};\\n```\\n**Please upote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        //sort the intervals\\n        \\n        sort(intervals.begin(),intervals.end());\\n        int i=0;\\n        int j=1;\\n        int len=intervals.size();\\n        int removed=0;\\n        while(j<len)\\n        {\\n            //check whether interval i is covered by interval j\\n            if(intervals[j][0]<=intervals[i][0] && intervals[i][1]<=intervals[j][1])\\n            {\\n                //remove interval i since it is covered\\n                removed++;\\n                i=j;\\n                j++;\\n            }\\n            //check if interval j is covered by interval i\\n            else if(intervals[i][0]<=intervals[j][0] && intervals[j][1]<=intervals[i][1])\\n            {\\n                //remove interval j\\n                removed++;\\n                j++;\\n            }\\n            else\\n            {\\n                //if none of them have covered by each other\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        //return the remaining intervals\\n        return len-removed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207022,
                "title": "c-greedy-solution-time-o-n-2-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int res = intervals.size();\\n        cout << res;\\n        \\n        for(int i = 0; i<intervals.size(); i++)\\n        {\\n            for(int j = 0; j<intervals.size(); j++)\\n            { \\n                if(i != j && intervals[i][0] >= intervals[j][0] && intervals[i][1] <= intervals[j][1] )\\n                { \\n                    res--;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}:\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int res = intervals.size();\\n        cout << res;\\n        \\n        for(int i = 0; i<intervals.size(); i++)\\n        {\\n            for(int j = 0; j<intervals.size(); j++)\\n            { \\n                if(i != j && intervals[i][0] >= intervals[j][0] && intervals[i][1] <= intervals[j][1] )\\n                { \\n                    res--;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}:\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1205487,
                "title": "javascript-short-and-easy-solution-94-56",
                "content": "Runtime: 80 ms, faster than 94.87% of JavaScript online submissions for Remove Covered Intervals.\\nMemory Usage: 40.6 MB, less than 56.41% of JavaScript online submissions for Remove Covered Intervals.\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals = intervals.sort((a,b)=>a[0]-b[0]);\\n    var result = [intervals[0]];\\n    for(i=1;i<intervals.length;i++){\\n        if(result[0][0]<=intervals[i][0] && result[0][1]>=intervals[i][1]) continue;\\n        if(result[0][0]>=intervals[i][0] && result[0][1]<=intervals[i][1]) result.shift();\\n        result.unshift(intervals[i]);    \\n    }\\n    return result.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals = intervals.sort((a,b)=>a[0]-b[0]);\\n    var result = [intervals[0]];\\n    for(i=1;i<intervals.length;i++){\\n        if(result[0][0]<=intervals[i][0] && result[0][1]>=intervals[i][1]) continue;\\n        if(result[0][0]>=intervals[i][0] && result[0][1]<=intervals[i][1]) result.shift();\\n        result.unshift(intervals[i]);    \\n    }\\n    return result.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1169591,
                "title": "c-priority-queue-beginner-friendly-commented-code",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    // IF START IS EQUAL THEN ARRANGE ON THE BASIS OF END VALUE AND PUT PAIR WITH MORE END VALUE FIRST\\n    struct comp{\\n        bool operator()(pair<int,int> p1,pair<int,int> p2){\\n            if(p1.first==p2.first)\\n                return p1.second<p2.second;\\n            return p1.first>p2.first;\\n        }\\n    };\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp> pq;\\n        \\n        for(int i=0;i<intervals.size();i++)pq.push({intervals[i][0],intervals[i][1]});\\n        \\n        int x=0;                      // CALCULATE NO OF INTERVALS WHICH ARE TO BE REMOVED\\n        int start=pq.top().first;\\n        int end=pq.top().second;\\n        pq.pop();\\n        \\n        while(pq.size()!=0){\\n            pair<int,int> p=pq.top();pq.pop();\\n            if(p.first>=start && p.second<=end)x++;  // IF INTERVAL RESIDES IN THE BOUNDARY WE CREATED INCREASE X\\n            start=min(start,p.first);\\n            end=max(end,p.second);\\n        }\\n        cout<<x;\\n        return intervals.size()-x;  //RETURN ANSWER\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    // IF START IS EQUAL THEN ARRANGE ON THE BASIS OF END VALUE AND PUT PAIR WITH MORE END VALUE FIRST\\n    struct comp{\\n        bool operator()(pair<int,int> p1,pair<int,int> p2){\\n            if(p1.first==p2.first)\\n                return p1.second<p2.second;\\n            return p1.first>p2.first;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1137907,
                "title": "simple-java-solution-explained",
                "content": "Idea is say we have the test case : [[3,10],[4,10],[5,14],[5,11],[5,12]]\\nPost sorting : 3,10 / 4,10 / 5,14 / 5,12 / 5,11\\nAccording to this fitst our higher limit is 10. and the upper limit is already sorted in ascending order.\\ntherfore 4,10 is always in range of 3,10 hence not incremented. (In genenal all ranges which have upper limit less 10 lie btw 3,10)\\nthe next higher range is 14 .... all the numbers after it have higher ranges less than 14... hence the answer returned will be 2.\\nThis could be flawed only if a test case such as 15,14 would exist. but the testcases are such lower range has to be less than the upper range.\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n\\t\\t//If the lower limit are not same it is sorted in descending. if the lower limit is same then in ascending.\\n        Arrays.sort(intervals,(a,b) -> a[0]==b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        // for(int i=0;i<intervals.length;i++)\\n        //     System.out.println(intervals[i][0]+\" \"+intervals[i][1]);\\n        \\n        int count = 0;\\n        int higher = Integer.MIN_VALUE;\\n        for(int i=0;i<intervals.length;i++)\\n        {\\n            \\n            if(intervals[i][1]>higher)\\n            {\\n                count++;\\n                higher = intervals[i][1];\\n                // System.out.println(count+\" \"+intervals[i][0]+\" \"+higher)//\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n\\t\\t//If the lower limit are not same it is sorted in descending. if the lower limit is same then in ascending.\\n        Arrays.sort(intervals,(a,b) -> a[0]==b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        // for(int i=0;i<intervals.length;i++)\\n        //     System.out.println(intervals[i][0]+\" \"+intervals[i][1]);\\n        \\n        int count = 0;\\n        int higher = Integer.MIN_VALUE;\\n        for(int i=0;i<intervals.length;i++)\\n        {\\n            \\n            if(intervals[i][1]>higher)\\n            {\\n                count++;\\n                higher = intervals[i][1];\\n                // System.out.println(count+\" \"+intervals[i][0]+\" \"+higher)//\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115118,
                "title": "4-line-simple-code-with-98-56-faster-with-o-1-space",
                "content": "JAVA CODE IS:\\n#   \\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n      Arrays.sort(intervals,(a,b) -> b[0]!=a[0] ? a[0]-b[0] : b[1]-a[1]);\\n      int max=0,remove=0;\\n       for(int a[] : intervals){\\n           if(a[1]<=max) remove++;\\n           max=Math.max(max,a[1]);\\n       }\\n        return intervals.length-remove;\\n    }\\n}\\n```\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n      Arrays.sort(intervals,(a,b) -> b[0]!=a[0] ? a[0]-b[0] : b[1]-a[1]);\\n      int max=0,remove=0;\\n       for(int a[] : intervals){\\n           if(a[1]<=max) remove++;\\n           max=Math.max(max,a[1]);\\n       }\\n        return intervals.length-remove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103130,
                "title": "java-2-solutions-brute-force-optimized-clean-solution",
                "content": "```\\nBRUTE FORCE O(n*n)\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int i=0;\\n      int count=0;\\n      for(int arr[]:intervals){\\n        boolean ci=false;                // cuvered interval\\n        int a=arr[0];\\n        int b=arr[1];\\n      \\n        for(int j=0;j<intervals.length;j++){\\n          if(i==j) continue;\\n           int c=intervals[j][0];\\n           int d=intervals[j][1];\\n      \\n\\t\\t   if(c<=a && b<=d){\\n                ci=true;\\n          }\\n          \\n        }\\n        if(!ci) { count++;\\n               \\n                }\\n        i++;\\n      }\\n       return count;\\n    }\\n}\\n```\\n```\\nO(nlogn) OPTIMIZED\\n if(intervals.length==1){\\n            return 1;\\n        }\\n      \\n           Arrays.sort(intervals, new java.util.Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) {\\n        if(a[0]!=b[0]) return Integer.compare(a[0], b[0]);\\n        return Integer.compare(b[1], a[1]);\\n      \\n    }\\n});\\n      int last = 0;\\n        if(intervals.length==1){\\n            return 1;\\n        }\\n        last = intervals[0][1]-1;\\n        int res = 1;\\n        for(int i=1;i<intervals.length;i++){\\n            if(last<intervals[i][0] || last<intervals[i][1]-1){\\n                   last=intervals[i][1]-1;\\n                    res++;\\n            }\\n        }\\n        return res;\\n```",
                "solutionTags": [],
                "code": "```\\nBRUTE FORCE O(n*n)\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int i=0;\\n      int count=0;\\n      for(int arr[]:intervals){\\n        boolean ci=false;                // cuvered interval\\n        int a=arr[0];\\n        int b=arr[1];\\n      \\n        for(int j=0;j<intervals.length;j++){\\n          if(i==j) continue;\\n           int c=intervals[j][0];\\n           int d=intervals[j][1];\\n      \\n\\t\\t   if(c<=a && b<=d){\\n                ci=true;\\n          }\\n          \\n        }\\n        if(!ci) { count++;\\n               \\n                }\\n        i++;\\n      }\\n       return count;\\n    }\\n}\\n```\n```\\nO(nlogn) OPTIMIZED\\n if(intervals.length==1){\\n            return 1;\\n        }\\n      \\n           Arrays.sort(intervals, new java.util.Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) {\\n        if(a[0]!=b[0]) return Integer.compare(a[0], b[0]);\\n        return Integer.compare(b[1], a[1]);\\n      \\n    }\\n});\\n      int last = 0;\\n        if(intervals.length==1){\\n            return 1;\\n        }\\n        last = intervals[0][1]-1;\\n        int res = 1;\\n        for(int i=1;i<intervals.length;i++){\\n            if(last<intervals[i][0] || last<intervals[i][1]-1){\\n                   last=intervals[i][1]-1;\\n                    res++;\\n            }\\n        }\\n        return res;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001457,
                "title": "python3-very-clean-simple-and-intuitive-greedy-o-nlogn-custom-sort",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[0], -x[1]))\\n        count = 0\\n        prev_end = -1\\n        \\n        for interval in intervals:\\n            if interval[1] <= prev_end:\\n                count += 1\\n            else:\\n                prev_end = interval[1]\\n                \\n        return (len(intervals) - count)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[0], -x[1]))\\n        count = 0\\n        prev_end = -1\\n        \\n        for interval in intervals:\\n            if interval[1] <= prev_end:\\n                count += 1\\n            else:\\n                prev_end = interval[1]\\n                \\n        return (len(intervals) - count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910732,
                "title": "python-o-1-space-o-n-log-n-solution-easy",
                "content": "```\\nclass Solution(object):\\n    def isOverlapping(self, cs, ce, ps, pe):\\n        return cs <= ps <= pe <= ce or ps <= cs <= ce <= pe\\n\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort()\\n\\n        length = len(intervals)\\n        previousStart = intervals[0][0]\\n        previousEnd = intervals[0][1]\\n\\n        for i in range(1, len(intervals)):\\n            currentInterval = intervals[i]\\n\\n            currentStart = currentInterval[0]\\n\\n            currentEnd = currentInterval[1]\\n\\n            if self.isOverlapping(currentStart, currentEnd, previousStart, previousEnd):\\n                previousStart = min(previousStart, currentStart)\\n                previousEnd = max(previousEnd, currentEnd)\\n                length -= 1\\n            else:\\n                previousStart = currentStart\\n                previousEnd = currentEnd\\n\\n        return length               \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isOverlapping(self, cs, ce, ps, pe):\\n        return cs <= ps <= pe <= ce or ps <= cs <= ce <= pe\\n\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort()\\n\\n        length = len(intervals)\\n        previousStart = intervals[0][0]\\n        previousEnd = intervals[0][1]\\n\\n        for i in range(1, len(intervals)):\\n            currentInterval = intervals[i]\\n\\n            currentStart = currentInterval[0]\\n\\n            currentEnd = currentInterval[1]\\n\\n            if self.isOverlapping(currentStart, currentEnd, previousStart, previousEnd):\\n                previousStart = min(previousStart, currentStart)\\n                previousEnd = max(previousEnd, currentEnd)\\n                length -= 1\\n            else:\\n                previousStart = currentStart\\n                previousEnd = currentEnd\\n\\n        return length               \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 908025,
                "title": "c-o-nlogn-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool static sortbysec(const pair<int,int> &a, const pair<int,int> &b) \\n        { \\n            if(a.first == b.first){\\n            return (a.second > b.second); }\\n            return a.first<b.first;\\n        }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size()==0){\\n            return 0;\\n        }\\n        vector<pair<int,int> > p;\\n        vector<int> v;\\n        int cnt=0;\\n        for(int i=0;i<intervals.size();i++){\\n            p.push_back(make_pair(intervals[i][0], intervals[i][1]));\\n        }\\n        sort(p.begin(), p.end(), sortbysec);\\n        for(int i=0;i<p.size();i++){\\n            v.push_back(p[i].second);\\n\\t\\t   }\\n        for(int i=0, j=1;i<v.size() && j<v.size();){\\n            if(v[i]<v[j]){\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                cnt++;\\n                j++;\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static sortbysec(const pair<int,int> &a, const pair<int,int> &b) \\n        { \\n            if(a.first == b.first){\\n            return (a.second > b.second); }\\n            return a.first<b.first;\\n        }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size()==0){\\n            return 0;\\n        }\\n        vector<pair<int,int> > p;\\n        vector<int> v;\\n        int cnt=0;\\n        for(int i=0;i<intervals.size();i++){\\n            p.push_back(make_pair(intervals[i][0], intervals[i][1]));\\n        }\\n        sort(p.begin(), p.end(), sortbysec);\\n        for(int i=0;i<p.size();i++){\\n            v.push_back(p[i].second);\\n\\t\\t   }\\n        for(int i=0, j=1;i<v.size() && j<v.size();){\\n            if(v[i]<v[j]){\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                cnt++;\\n                j++;\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892292,
                "title": "javascript-greedy-time-o-n-log-n-space-o-log-n",
                "content": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n   \\n    let prevEnd = 0\\n    let count = 0\\n\\n    for(let i of intervals){\\n        const end = i[1]\\n        if(end > prevEnd){\\n            count++\\n            prevEnd = end\\n        }\\n    }\\n    return count\\n};\\n```\\ntime: O(n log n)\\nspace: O(log n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n   \\n    let prevEnd = 0\\n    let count = 0\\n\\n    for(let i of intervals){\\n        const end = i[1]\\n        if(end > prevEnd){\\n            count++\\n            prevEnd = end\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890516,
                "title": "simple-python3-solution-with-clear-comments-faster-than-98-other-python-solutions",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n            \\n        # edge cases (empty, only one)\\n        \\n        if len(intervals) == 0:\\n            return 0\\n        \\n        if len(intervals) == 1:\\n            return 1\\n        \\n        result = 1 # has to have at least one at this point, e.g. [1,4], [1,5]\\n                \\n        # need to sort!!!!\\n\\t\\t# we want to have smaller starting bounds first and then break ties using the smaller end bound\\n        \\n        lastSorted = sorted(intervals, key=lambda interval:interval[1])\\n        intervals = sorted(lastSorted, key=lambda interval:interval[0])\\n \\n        firstInterval = intervals[0]\\n        \\n        currStart = firstInterval[0]\\n        currEnd = firstInterval[1]\\n           \\n\\t\\t# since we already grabbed the first interval, start with the second and continue until the end\\n        for interval in intervals[1:]:\\n            tempStart = interval[0]\\n            tempEnd = interval[1]\\n            \\n            # 1) new interval falls entirely within current interval\\n            if tempEnd <= currEnd:\\n                # do nothing!! this is a covered interval\\n                doNothing = 0\\n\\t\\t\\t\\t\\n            # 2) new interval has same start and either same end or longer end\\n            elif tempStart == currStart and tempEnd >= currEnd:\\n                # this new one covers our current, and we switch to use it next\\n                currStart = tempStart\\n                currEnd = tempEnd\\n\\t\\t\\t\\t\\n            # 3) new interval falls completely to the right\\n            elif tempStart >= currEnd:\\n                result += 1 # counting our previous interval as uncovered\\n                currStart = tempStart\\n                currEnd = tempEnd\\n\\t\\t\\t\\t\\n            # 4) partial overlap\\n            elif tempStart > currStart and tempEnd > currEnd:\\n                result += 1\\n                currStart = tempStart\\n                currEnd = tempEnd\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n            \\n        # edge cases (empty, only one)\\n        \\n        if len(intervals) == 0:\\n            return 0\\n        \\n        if len(intervals) == 1:\\n            return 1\\n        \\n        result = 1 # has to have at least one at this point, e.g. [1,4], [1,5]\\n                \\n        # need to sort!!!!\\n\\t\\t# we want to have smaller starting bounds first and then break ties using the smaller end bound\\n        \\n        lastSorted = sorted(intervals, key=lambda interval:interval[1])\\n        intervals = sorted(lastSorted, key=lambda interval:interval[0])\\n \\n        firstInterval = intervals[0]\\n        \\n        currStart = firstInterval[0]\\n        currEnd = firstInterval[1]\\n           \\n\\t\\t# since we already grabbed the first interval, start with the second and continue until the end\\n        for interval in intervals[1:]:\\n            tempStart = interval[0]\\n            tempEnd = interval[1]\\n            \\n            # 1) new interval falls entirely within current interval\\n            if tempEnd <= currEnd:\\n                # do nothing!! this is a covered interval\\n                doNothing = 0\\n\\t\\t\\t\\t\\n            # 2) new interval has same start and either same end or longer end\\n            elif tempStart == currStart and tempEnd >= currEnd:\\n                # this new one covers our current, and we switch to use it next\\n                currStart = tempStart\\n                currEnd = tempEnd\\n\\t\\t\\t\\t\\n            # 3) new interval falls completely to the right\\n            elif tempStart >= currEnd:\\n                result += 1 # counting our previous interval as uncovered\\n                currStart = tempStart\\n                currEnd = tempEnd\\n\\t\\t\\t\\t\\n            # 4) partial overlap\\n            elif tempStart > currStart and tempEnd > currEnd:\\n                result += 1\\n                currStart = tempStart\\n                currEnd = tempEnd\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888568,
                "title": "java-nlogn-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        int count = 0;\\n        \\n        Arrays.sort(intervals , (a,b)->{\\n          return a[0] - b[0];\\n     });\\n        int beg = -1;\\n        int end = -1;\\n        int res = 0;\\n        for(int i=0 ; i<intervals.length ; i++){\\n          if(intervals[i][0] >beg && intervals[i][1]> end){\\n            beg = intervals[i][0];\\n            res++;\\n          }\\n          end = Math.max(end , intervals[i][1]);\\n        }\\n      return res;\\n       \\n    } \\n  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        int count = 0;\\n        \\n        Arrays.sort(intervals , (a,b)->{\\n          return a[0] - b[0];\\n     });\\n        int beg = -1;\\n        int end = -1;\\n        int res = 0;\\n        for(int i=0 ; i<intervals.length ; i++){\\n          if(intervals[i][0] >beg && intervals[i][1]> end){\\n            beg = intervals[i][0];\\n            res++;\\n          }\\n          end = Math.max(end , intervals[i][1]);\\n        }\\n      return res;\\n       \\n    } \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885354,
                "title": "python-3-two-solutions-explanation-stack-implementation",
                "content": "**Test Case**\\n\\nHere are some useful small test cases for debugging.\\n\\n`[[1,2],[1,3]]`\\n`[[1,3],[1,8],[5,8]]`\\n`[[1,6],[4,6],[4,8]]`\\n\\n# **Solution - 1**\\n\\nThe Idea is to use a `stack` and keep track of the `Covered Intervals` using the top of stack and replacing it when needed\\n\\n1.  Sort the `intervals` list\\n2.  Initialize the `stack`\\n3.  If stack[-1][0] (`a`)  <= intervals[i][0] (`c`) and stack[-1][1] (`b`)  <= intervals[i][0] (`d`) , we pass , as the range is already covered by `stack[-1]`\\n4.  If stack[-1][0] (`a`)  >= intervals[i][0] (`c`) and stack[-1][1] (`b`)  >= intervals[i][0] (`d`) , we update `stack[-1]` , as the range is not covered by `stack[-1]`\\n5.  In all other case , we append to the `stack`\\n\\n```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        stack = []\\n        \\n        n = len(intervals)\\n        \\n\\t\\t#### [1]\\n        intervals.sort(key=lambda x: (x[0],-x[1]))\\n        \\n        i = 0\\n        \\n        while i < n:\\n            if stack:\\n                while i < n:\\n\\t\\t\\t\\t\\t##### [3]\\n                    if stack[-1][0] <= intervals[i][0] and intervals[i][1] <= stack[-1][1]:\\n                        pass\\n\\t\\t\\t\\t\\t##### [4]\\n                    elif stack[-1][0] >= intervals[i][0] and intervals[i][1] >= stack[-1][1]:\\n                        stack[-1] = intervals[i]\\n\\t\\t\\t\\t\\t##### [5]\\n                    else:\\n                        stack += [intervals[i]]\\n                    i += 1\\n            else:\\n\\t\\t\\t\\t##### [2]\\n                stack += [intervals[i]]\\n                i += 1\\n        \\n        \\n        return len(stack)\\n```\\n\\n# **Solution - 2**\\nIdea is to only keep track of the `second index` of each `interval[i]`\\n\\n1.  Sort the `intervals` list\\n2.  Initialize `previous_end=0` and `res=0`\\n3.  if `current_end` > `previous_end` , increment `res` and update `previous_end` with `current_end`\\n\\n```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        ### [1]\\n        intervals.sort(key=lambda x: [x[0], -x[1]])\\n\\n        ### [2]\\n        previous_end, res = 0, 0\\n        \\n        for _, current_end in intervals:\\n\\t\\t    ### [3]\\n            if current_end > previous_end:\\n                res += 1\\n                previous_end = current_end\\n        \\n        return res\\n```\\n\\nIf you like the solutions do `Up Vote`",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        stack = []\\n        \\n        n = len(intervals)\\n        \\n\\t\\t#### [1]\\n        intervals.sort(key=lambda x: (x[0],-x[1]))\\n        \\n        i = 0\\n        \\n        while i < n:\\n            if stack:\\n                while i < n:\\n\\t\\t\\t\\t\\t##### [3]\\n                    if stack[-1][0] <= intervals[i][0] and intervals[i][1] <= stack[-1][1]:\\n                        pass\\n\\t\\t\\t\\t\\t##### [4]\\n                    elif stack[-1][0] >= intervals[i][0] and intervals[i][1] >= stack[-1][1]:\\n                        stack[-1] = intervals[i]\\n\\t\\t\\t\\t\\t##### [5]\\n                    else:\\n                        stack += [intervals[i]]\\n                    i += 1\\n            else:\\n\\t\\t\\t\\t##### [2]\\n                stack += [intervals[i]]\\n                i += 1\\n        \\n        \\n        return len(stack)\\n```\n```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        ### [1]\\n        intervals.sort(key=lambda x: [x[0], -x[1]])\\n\\n        ### [2]\\n        previous_end, res = 0, 0\\n        \\n        for _, current_end in intervals:\\n\\t\\t    ### [3]\\n            if current_end > previous_end:\\n                res += 1\\n                previous_end = current_end\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566210,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            },
            {
                "id": 1568319,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            },
            {
                "id": 2008477,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            },
            {
                "id": 1980424,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            },
            {
                "id": 1905429,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            }
        ]
    }
]