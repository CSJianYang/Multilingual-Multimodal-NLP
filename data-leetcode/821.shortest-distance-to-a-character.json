[
    {
        "title": "Shortest Distance to a Character",
        "question_content": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\n&nbsp;\nExample 1:\n\nInput: s = \"loveleetcode\", c = \"e\"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2.\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\n\nExample 2:\n\nInput: s = \"aaab\", c = \"b\"\nOutput: [3,2,1,0]\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\ts[i] and c are lowercase English letters.\n\tIt is guaranteed that c occurs at least once in s.",
        "solutions": [
            {
                "id": 125788,
                "title": "c-java-python-2-pass-with-explanation",
                "content": "# Solution 1: Record the Position\\n\\nInitial result array.\\nLoop twice on the string `S`.\\nFirst forward pass to find shortest distant to character on left.\\nSecond backward pass to find shortest distant to character on right.\\n<br>\\n\\nIn python solution,  I merged these two `for` statement.\\nWe can do the same in C++/Java by:\\n```\\nfor (int i = 0; i >= 0; res[n-1] == n ? ++i : --i)\\n```\\nBut it will become less readable.\\n<br>\\n\\nTime complexity `O(N)`\\nSpace complexity `O(N)` for output\\n<br>\\n\\n**C++**\\n```cpp\\n    vector<int> shortestToChar(string S, char C) {\\n        int n = S.size(), pos = -n;\\n        vector<int> res(n, n);\\n        for (int i = 0; i < n; ++i) {\\n            if (S[i] == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S[i] == C)  pos = i;\\n            res[i] = min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java**\\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length(), pos = -n, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (S.charAt(i) == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S.charAt(i) == C)  pos = i;\\n            res[i] = Math.min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def shortestToChar(self, S, C):\\n        n, pos = len(S), -float(\\'inf\\')\\n        res = [n] * n\\n        for i in range(n) + range(n)[::-1]:\\n            if S[i] == C:\\n                pos = i\\n            res[i] = min(res[i], abs(i - pos))\\n        return res\\n```\\n<br><br>\\n\\n# Solution 2: DP\\nAnother idea is quite similar and has a sense of DP.\\n<br>\\n**C++:**\\n```cpp\\n    vector<int> shortestToChar2(string S, char C) {\\n        int n = S.size();\\n        vector<int> res(n);\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S[i] == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S.charAt(i) == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = Math.min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = Math.min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\\n**Python:**\\n```py\\n    def shortestToChar(self, S, C):\\n        n = len(S)\\n        res = [0 if c == C else n for c in S]\\n        for i in range(1, n):\\n            res[i] = min(res[i], res[i - 1] + 1)\\n        for i in range(n - 2, -1, -1):\\n            res[i] = min(res[i], res[i + 1] + 1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfor (int i = 0; i >= 0; res[n-1] == n ? ++i : --i)\\n```\n```cpp\\n    vector<int> shortestToChar(string S, char C) {\\n        int n = S.size(), pos = -n;\\n        vector<int> res(n, n);\\n        for (int i = 0; i < n; ++i) {\\n            if (S[i] == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S[i] == C)  pos = i;\\n            res[i] = min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length(), pos = -n, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            if (S.charAt(i) == C) pos = i;\\n            res[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; --i) {\\n            if (S.charAt(i) == C)  pos = i;\\n            res[i] = Math.min(res[i], pos - i);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def shortestToChar(self, S, C):\\n        n, pos = len(S), -float(\\'inf\\')\\n        res = [n] * n\\n        for i in range(n) + range(n)[::-1]:\\n            if S[i] == C:\\n                pos = i\\n            res[i] = min(res[i], abs(i - pos))\\n        return res\\n```\n```cpp\\n    vector<int> shortestToChar2(string S, char C) {\\n        int n = S.size();\\n        vector<int> res(n);\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S[i] == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\n```java\\n    public int[] shortestToChar(String S, char C) {\\n        int n = S.length();\\n        int[] res = new int[n];\\n        for (int i = 0; i < n; ++i)\\n            res[i] = S.charAt(i) == C ? 0 : n;\\n        for (int i = 1; i < n; ++i)\\n            res[i] = Math.min(res[i], res[i - 1] + 1);\\n        for (int i = n - 2; i >= 0; --i)\\n            res[i] = Math.min(res[i], res[i + 1] + 1);\\n        return res;\\n    }\\n```\n```py\\n    def shortestToChar(self, S, C):\\n        n = len(S)\\n        res = [0 if c == C else n for c in S]\\n        for i in range(1, n):\\n            res[i] = min(res[i], res[i - 1] + 1)\\n        for i in range(n - 2, -1, -1):\\n            res[i] = min(res[i], res[i + 1] + 1)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 126116,
                "title": "concise-java-solution-with-detailed-explanation-easy-understand",
                "content": "```\\n/** \"loveleetcode\" \"e\"\\n *  1. put 0 at all position equals to e, and max at all other position\\n *     we will get [max, max, max, 0, max, 0, 0, max, max, max, max, 0]\\n *  2. scan from left to right, if =max, skip, else dist[i+1] = Math.min(dp[i] + 1, dp[i+1]), \\n *     we can get [max, max, max, 0, 1, 0, 0, 1, 2, 3, 4, 0]\\n *  3. scan from right to left, use dp[i-1] = Math.min(dp[i] + 1, dp[i-1])\\n *     we will get[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] \\n */\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == c) continue;\\n            dist[i] = Integer.MAX_VALUE;\\n        }\\n        for (int i = 0; i < n-1; i++) {\\n            if (dist[i] == Integer.MAX_VALUE) continue;\\n            else dist[i + 1] = Math.min(dist[i+1], dist[i] + 1);\\n        }\\n        for (int i = n-1; i > 0; i--) {\\n            dist[i-1] = Math.min(dist[i-1], dist[i] + 1);\\n        }\\n        return dist; \\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] dist = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (s.charAt(i) == c) continue;\\n            dist[i] = Integer.MAX_VALUE;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1054410,
                "title": "c-two-pass-o-n-0ms-beats-100-easy-explanation",
                "content": "**EXPLANATION**\\n- First, iterate the string **\\'s\\'** and store the **indexes** of **\\'c\\'** present in \\'s\\' into an array or vector ( here **```vector<int>ioc```** ) .\\n- Make a **left** variable for storing the index of **left nearest \\'c\\'** in **```ioc```**  and a **right** variable for storing the index of **right nearest \\'c\\'** in **```ioc```**. Initially, **```left=0```** and **```right=0```**, that is keeping the first index of **```ioc```**.\\n- Then, iterate string **\\'s\\'** again and at each iteration check if *current index* crosses **```ioc[right]```** ( that is *index of \\'c\\' present in ioc pointed by right* ) then we need to make **```left = right```** and **```right=right+1```**.\\n- Also, at each iteration find the **minimum** value between the *following two* and store it in **```ans[i]```**.\\n\\t-  **absolute value of (right nearest \\'c\\' - current index)** represented by **``` abs(ioc[right]-i)```** \\n\\t-   **absolute value of (left nearest \\'c\\' - current index)** represented by **``` abs(ioc[left]-i)```**\\n- Return **ans**.\\n\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ioc; // vector for storing the indexed of c present in s\\n        int n=s.length();\\n        \\n        vector<int>ans(n); // answer vector\\n        \\n        for(int i=0;i<n;++i){\\n            if(s[i]==c) \\n                ioc.push_back(i);\\n        }\\n        \\n        int m=ioc.size(); // size of ioc vector\\n        int left=0,right=0;\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            // if current index has crossed ioc[right] then,\\n            // we need to make the current left to right and \\n            // increment current right for pointing to next index of ioc vector ( if exists )\\n            if(i>ioc[right]){\\n                left=right;\\n                if(right<m-1)\\n                    ++right;\\n            }\\n                        \\n            // difference = min(abs(right nearest \\'c\\' - curr index),abs(left nearest \\'c\\' - curr index))\\n            ans[i]=min(abs(ioc[right]-i),abs(ioc[left]-i)); \\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nConsidering *\\'n\\'* to be the size of the maximum size of the string *\\'s\\'*.\\n\\n**TIME COMPLEXITY**\\nO(n+n)=**O(n)** [ *For iterating the string two times* ]\\n\\n**SPACE COMPLEXITY**\\n**O(n)** [ *In worst case, all characters of \\'s\\' is \\'c\\', at that time ( number of \\'c\\' in \\'s\\' = size of \\'s\\' )* ]",
                "solutionTags": [
                    "C"
                ],
                "code": "```vector<int>ioc```\n```ioc```\n```ioc```\n```left=0```\n```right=0```\n```ioc```\n```ioc[right]```\n```left = right```\n```right=right+1```\n```ans[i]```\n``` abs(ioc[right]-i)```\n``` abs(ioc[left]-i)```\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ioc; // vector for storing the indexed of c present in s\\n        int n=s.length();\\n        \\n        vector<int>ans(n); // answer vector\\n        \\n        for(int i=0;i<n;++i){\\n            if(s[i]==c) \\n                ioc.push_back(i);\\n        }\\n        \\n        int m=ioc.size(); // size of ioc vector\\n        int left=0,right=0;\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            // if current index has crossed ioc[right] then,\\n            // we need to make the current left to right and \\n            // increment current right for pointing to next index of ioc vector ( if exists )\\n            if(i>ioc[right]){\\n                left=right;\\n                if(right<m-1)\\n                    ++right;\\n            }\\n                        \\n            // difference = min(abs(right nearest \\'c\\' - curr index),abs(left nearest \\'c\\' - curr index))\\n            ans[i]=min(abs(ioc[right]-i),abs(ioc[left]-i)); \\n\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054301,
                "title": "python-o-n-solution-explained",
                "content": "What we need to do in this problem is to iterate our data two times: one time from left to right and second time from right to left. Let us use auxilary function `letter_get(letter, dr)`, where `dr` is direction: `+1` for left->right traversal and `-1` for right -> left traversal.\\n\\nHow this function will work? We initialize it with zeroes first and we keep `cur` value, which represents the last place where we meet symbol `letter`. We traverse string, check each symbol and if it is equal to `letter`, we update `cur` place. We put `abs(i - cur)` to result: this is distance between current place and last place where we meet symbol `letter`.\\n\\nFinally, we apply our function twice for two directions and choose the smallest distance. Note also that we initialized `curr = -n`, because in this case we will have distances `>=n` for symbols for places, where we do not have elements equal to `letter` before, and this value is bigger than all possible values in answer, so it works as infinity here.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(n)` as well.\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        def letter_get(letter, dr):\\n            n = len(S)\\n            res, cur = [0]*n, -n\\n            for i in range(n)[::dr]:\\n                if S[i] == letter: cur = i\\n                res[i] = abs(i - cur)\\n            return res\\n        \\n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        def letter_get(letter, dr):\\n            n = len(S)\\n            res, cur = [0]*n, -n\\n            for i in range(n)[::dr]:\\n                if S[i] == letter: cur = i\\n                res[i] = abs(i - cur)\\n            return res\\n        \\n        return [min(x,y) for x,y in zip(letter_get(C, 1), letter_get(C, -1))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054366,
                "title": "javascript-2-pass-simple-solution-with-explanation",
                "content": "The problem becomes really simple if we consider the example.\\n```js\\n0 1 2 3 4 5 6 7 8 9 10 11\\nl o v e l e e t c o d  e\\n```\\nWhat is the shortest distance for index `9` if the character is `e`?\\nThe closest `e` from the left side has the index `6`.\\n`9 - 6 = 3`\\nThe closest `e` from the right side has the index `11`.\\n`11 - 9 = 2`\\nThe minimum distance between them is 2, so the answer is 2. Can we do it for any index?\\nYes we can, all we need to do is to keep track of the previous character index while iterating from the left to the right and vice versa. The only edge case here is that initially we could possibly don\\'t have a previous index, so to mitigate it for such indecies we can put the shortest distance for them as Infinity and once we complete 2 passes at least one non-Infinity value for each index should exist.\\nLet\\'s consider the example again.\\n```js\\ncharacter = \"e\"\\n\\nindex  | 0 1 2 3 4 5 6 7 8 9 10 11\\nchar   | l o v e l e e t c o d  e\\n// shortest distance from left to right\\nl -> r | I I I 0 1 0 0 1 2 3 4  0 // I = Infinity\\n// shortest distance from right to left\\nl <- r | 3 2 1 0 1 0 0 4 3 2 1  0\\n// the minimum between them is the answer\\nresult | 3 2 1 0 1 0 0 1 2 2 1  0\\n```\\n\\n```js\\nvar shortestToChar = function(s, c) {\\n    let n = s.length;\\n    let res = [];\\n        \\n    let prev = Infinity;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) prev = i;\\n        res[i] = Math.abs(prev - i);\\n    }\\n\\n    prev = Infinity;\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n      if (s[i] === c) prev = i;\\n      res[i] = Math.min(res[i], prev - i);\\n    }\\n\\n    return res;\\n}\\n```\\n\\nTime complexity: O(n)\\nSpace complexity: O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n0 1 2 3 4 5 6 7 8 9 10 11\\nl o v e l e e t c o d  e\\n```\n```js\\ncharacter = \"e\"\\n\\nindex  | 0 1 2 3 4 5 6 7 8 9 10 11\\nchar   | l o v e l e e t c o d  e\\n// shortest distance from left to right\\nl -> r | I I I 0 1 0 0 1 2 3 4  0 // I = Infinity\\n// shortest distance from right to left\\nl <- r | 3 2 1 0 1 0 0 4 3 2 1  0\\n// the minimum between them is the answer\\nresult | 3 2 1 0 1 0 0 1 2 2 1  0\\n```\n```js\\nvar shortestToChar = function(s, c) {\\n    let n = s.length;\\n    let res = [];\\n        \\n    let prev = Infinity;\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) prev = i;\\n        res[i] = Math.abs(prev - i);\\n    }\\n\\n    prev = Infinity;\\n\\n    for (let i = n - 1; i >= 0; i--) {\\n      if (s[i] === c) prev = i;\\n      res[i] = Math.min(res[i], prev - i);\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2173687,
                "title": "c-solution-simple-easy-understanding",
                "content": "**Explanation:**\\n* create two vectors :- `position` and `answer`.\\n* Traverse the string and collect all the position of given char using the `position` vector.\\n* Now traverse the string and find the shortest distance from the given char to all given positions.\\n* Keep pushing the distance to the `answer` vector and at last return it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> position;\\n        vector<int> answer;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==c)\\n                position.push_back(i);\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            int shortest_dist = INT_MAX;\\n            for(int j=0; j<position.size(); j++)\\n            {\\n                shortest_dist = min(shortest_dist, abs(i-position[j]));\\n            }\\n            answer.push_back(shortest_dist);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> position;\\n        vector<int> answer;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i]==c)\\n                position.push_back(i);\\n        }\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            int shortest_dist = INT_MAX;\\n            for(int j=0; j<position.size(); j++)\\n            {\\n                shortest_dist = min(shortest_dist, abs(i-position[j]));\\n            }\\n            answer.push_back(shortest_dist);\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054179,
                "title": "c-simple-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> res;\\n        int prev_char = -s.size();\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res.push_back(i - prev_char);\\n        }\\n\\n        for (int i = prev_char; i >= 0; i--) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res[i] = min(res[i], prev_char - i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> res;\\n        int prev_char = -s.size();\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res.push_back(i - prev_char);\\n        }\\n\\n        for (int i = prev_char; i >= 0; i--) {\\n            if (s[i] == c)\\n                prev_char = i;\\n            res[i] = min(res[i], prev_char - i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527161,
                "title": "python-o-n-by-propagation-85-w-diagram",
                "content": "Python O(n) by propagation\\n\\n---\\n\\n**Hint**:\\n\\nImagine parameter C as a flag on the line.\\n\\nThink of propagation technique:\\n**1st-pass** iteration **propagates distance** from C on the **left hand side**\\n**2nd-pass** iteration **propagates distance** from C on the **right hand side** with min( 1st-pass result, 2nd-pass propagation distance ) in order to update with shortest path.\\n\\n---\\n\\n**Abstract Model**:\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583205184.png)\\n\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        shortest_dist = []\\n        size = len(S)\\n        \\n        if size == 1:\\n            # Quick response for single character test case\\n            # Description guarantee that character C must exist in string S\\n            return [0]\\n        \\n        \\n        # Propagate distance from left to right\\n        for idx, char in enumerate(S):\\n            \\n            if char == C:\\n                shortest_dist.append(0)\\n            else:\\n                if idx == 0:\\n                    shortest_dist.append( size )\\n                else:\\n                    # Propagate distance from C on left hand side\\n                    shortest_dist.append( shortest_dist[-1] + 1)\\n                \\n                \\n                \\n        # Propagate distance from right to left               \\n        for idx in range(2, size+1):\\n            \\n            # Propagate distance from C on right hand side\\n            shortest_dist[-idx] = min(shortest_dist[-idx], shortest_dist[-idx+1]+1 )\\n\\n                \\n        return shortest_dist\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        shortest_dist = []\\n        size = len(S)\\n        \\n        if size == 1:\\n            # Quick response for single character test case\\n            # Description guarantee that character C must exist in string S\\n            return [0]\\n        \\n        \\n        # Propagate distance from left to right\\n        for idx, char in enumerate(S):\\n            \\n            if char == C:\\n                shortest_dist.append(0)\\n            else:\\n                if idx == 0:\\n                    shortest_dist.append( size )\\n                else:\\n                    # Propagate distance from C on left hand side\\n                    shortest_dist.append( shortest_dist[-1] + 1)\\n                \\n                \\n                \\n        # Propagate distance from right to left               \\n        for idx in range(2, size+1):\\n            \\n            # Propagate distance from C on right hand side\\n            shortest_dist[-idx] = min(shortest_dist[-idx], shortest_dist[-idx+1]+1 )\\n\\n                \\n        return shortest_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854034,
                "title": "python-99-92-faster-two-pointers-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        a,n=[],len(s)\\n        for i in range(n):\\n            if s[i]==c:\\n                a.append(i)\\n        answer=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                answer.append(0)\\n                j+=1\\n            elif i<a[0]:\\n                answer.append(a[0]-i)\\n            elif i>a[-1]:\\n                answer.append(i-a[-1])\\n            else:\\n                answer.append(min((a[j]-i),(i-a[j-1])))\\n        return answer\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        a,n=[],len(s)\\n        for i in range(n):\\n            if s[i]==c:\\n                a.append(i)\\n        answer=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                answer.append(0)\\n                j+=1\\n            elif i<a[0]:\\n                answer.append(a[0]-i)\\n            elif i>a[-1]:\\n                answer.append(i-a[-1])\\n            else:\\n                answer.append(min((a[j]-i),(i-a[j-1])))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343839,
                "title": "java-98-100",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        char[] arrS=S.toCharArray(); \\n        int[] dist=new int[arrS.length];\\n        int disToL=S.length(), disToR=S.length(); \\n        \\n        for(int i=0;i<arrS.length;i++){ //pass 1, determine distance to nearest C on the left \\n            if(arrS[i]==C)\\n                disToL=0;\\n            dist[i]=disToL;\\n            disToL++;\\n        }\\n        \\n        for(int i=arrS.length-1;i>=0;i--){ //pass 2, determine distance to nearest C on the right, compare with previous pass and take minimum \\n            if(arrS[i]==C)\\n                disToR=0;\\n            dist[i]=Math.min(dist[i],disToR);\\n            disToR++;\\n        }\\n        \\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        char[] arrS=S.toCharArray(); \\n        int[] dist=new int[arrS.length];\\n        int disToL=S.length(), disToR=S.length(); \\n        \\n        for(int i=0;i<arrS.length;i++){ //pass 1, determine distance to nearest C on the left \\n            if(arrS[i]==C)\\n                disToL=0;\\n            dist[i]=disToL;\\n            disToL++;\\n        }\\n        \\n        for(int i=arrS.length-1;i>=0;i--){ //pass 2, determine distance to nearest C on the right, compare with previous pass and take minimum \\n            if(arrS[i]==C)\\n                disToR=0;\\n            dist[i]=Math.min(dist[i],disToR);\\n            disToR++;\\n        }\\n        \\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131816,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        c = []\\n        for i, v in enumerate(S):\\n            if v == C:\\n                c.append(i)\\n\\n        r = []\\n        for i in range(len(S)):\\n            r.append(min([abs(t - i)for t in c]))\\n        return r\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        c = []\\n        for i, v in enumerate(S):\\n            if v == C:\\n                c.append(i)\\n\\n        r = []\\n        for i in range(len(S)):\\n            r.append(min([abs(t - i)for t in c]))\\n        return r\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125850,
                "title": "java-single-pass-with-trailing-pointer-concise",
                "content": "Idea is exactly the same as other solutions using stack or two pointers. Keep track of the last seen target character C as well as a left pointer pointing to the last non C character. \\n\\nIf you hit a nonC character and have not seen any C yet, max out that value.\\n\\nIf you hit a nonC character and have seen a C, the current distance to C is the current position i minus the index of the last seen C.\\n\\nIf you hit a C, update all entries from the left pointer up until the current index with the correct value. This is the minimum between the distance to the current C and the previous distance to another C. Finally, update the last seen C index to the current index.\\n\\n```\\n    public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n        \\n        int lastC = -1;\\n        int lastNonC = 0;\\n        \\n        for(int i = 0; i<S.length(); i++)\\n            if(S.charAt(i) == C){\\n                while(lastNonC<=i)\\n                    result[lastNonC] = Math.min(result[lastNonC], i-lastNonC++);\\n                lastC = i;\\n            }else\\n                result[i] = lastC != -1 ? i-lastC : Integer.MAX_VALUE;\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n        \\n        int lastC = -1;\\n        int lastNonC = 0;\\n        \\n        for(int i = 0; i<S.length(); i++)\\n            if(S.charAt(i) == C){\\n                while(lastNonC<=i)\\n                    result[lastNonC] = Math.min(result[lastNonC], i-lastNonC++);\\n                lastC = i;\\n            }else\\n                result[i] = lastC != -1 ? i-lastC : Integer.MAX_VALUE;\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055960,
                "title": "intuition-leads-to-approach-java-optimize-intuition-to-get-effective-solution",
                "content": "**Intuition:**\\n**Simple intuition**: \\n\\n* Suppose the answer is stored ans array.\\n* ans[i] is minimum of distances from all the positions of character C in string S\\nEx : Input: s = \"loveleetcode\", c = \"e\"\\nIndices of e = {3, 5, 6, 12}\\n* To get the shortest distance, we need to check the nearest from both sides.\\n* Run 2 loops from both end, updating the min value.\\n\\n**Solution**:\\n* We have to traverse the array two times, one from left to right & right to left.\\n\\n**Time Complexity**: Forward loop & Backward Loop : O(N) + O(N) ~ O(N)\\n**Space Complexity**: Without considering answer array : O(1) \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\n**Intuition 2**: \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int[] ans = new int[len];\\n        Arrays.fill(ans, len + 1);\\n        int j;\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                ans[i] = 0;\\n                j = i - 1;\\n                //fill reverse \\n                while(j >= 0 && ans[j] > i - j){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n                //fill forward\\n                j = i + 1;\\n                while( j < len && s.charAt(j) != c){\\n                    ans[j] = j - i;\\n                    j++;\\n                }\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Optimization**: \\nWhile traversing the string, \\n* ans[i] = 0 for all i where s.charAt(i) == c\\n* start filling from the index of character to both ends.\\n1. For forward: start filling {1, 2, 3... } from j = i+1 till we reach to another c or end of the string.\\n2. For backward : From j = i -1 till we reach to another c or start of the string.\\n\\t\\t\\t\\t\\t\\t\\tFill minimum of ans[j] &  i - j (distance of j from i).\\n* If at any point if ans[j] is less than & equal to i-j, for all the elements before jth index i-j is greater than ans[j]\\n\\n**Solution**:\\n* We have to traverse the array from one end, if there is a character c, update in backward too.\\n\\n**Time Complexity**: Forward loop & Backward Loop : O(N) + O(N/2) ~ O(N) where N is number of string.\\n**Space Complexity**: Without considering answer array : O(1) \\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int N = s.length();\\n        int[] ans = new int[N];\\n        int prev = N + 1, j;\\n        for (int i = 0; i < N; ++i) {\\n            if (s.charAt(i) == c) {\\n                ans[i] = 0;\\n                prev = 1;\\n                j = i-1;\\n                while( j >= 0 && ans[j] > i - j ){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n            }\\n            else\\n                ans[i] = prev++;\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int[] ans = new int[len];\\n        Arrays.fill(ans, len + 1);\\n        int j;\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                ans[i] = 0;\\n                j = i - 1;\\n                //fill reverse \\n                while(j >= 0 && ans[j] > i - j){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n                //fill forward\\n                j = i + 1;\\n                while( j < len && s.charAt(j) != c){\\n                    ans[j] = j - i;\\n                    j++;\\n                }\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int N = s.length();\\n        int[] ans = new int[N];\\n        int prev = N + 1, j;\\n        for (int i = 0; i < N; ++i) {\\n            if (s.charAt(i) == c) {\\n                ans[i] = 0;\\n                prev = 1;\\n                j = i-1;\\n                while( j >= 0 && ans[j] > i - j ){\\n                    ans[j] = i - j;\\n                    j--;\\n                }\\n            }\\n            else\\n                ans[i] = prev++;\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264608,
                "title": "c-basic-easy-implementaion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>out;\\n        vector<int>pos;\\n        \\n        //collect all the position of given char\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n                pos.push_back(i);\\n        }\\n        \\n        //traversal and find the min diffrence from the given char to all given pos\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int min_dis=INT_MAX;\\n            for(int j=0;j<pos.size();j++)\\n            {\\n                min_dis=min(min_dis,abs(i-pos[j]));\\n            }\\n            out.push_back(min_dis);\\n        }\\n        return out;\\n        \\n    }\\n};\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>out;\\n        vector<int>pos;\\n        \\n        //collect all the position of given char\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n                pos.push_back(i);\\n        }\\n        \\n        //traversal and find the min diffrence from the given char to all given pos\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int min_dis=INT_MAX;\\n            for(int j=0;j<pos.size();j++)\\n            {\\n                min_dis=min(min_dis,abs(i-pos[j]));\\n            }\\n            out.push_back(min_dis);\\n        }\\n        return out;\\n        \\n    }\\n};\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965854,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1054376,
                "title": "java-2-solutions-self-explained-easy-to-read-2-iterations",
                "content": "1- Using DP\\n* going from left to right, at each position i ans[i] = ans[i-1] + 1\\n* going from right to left, at each position i ans[i] = ans[i+1] + 1\\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, n);\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if(i > 0) ans[i] = Math.min(ans[i], ans[i-1] + 1);\\n        }\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if (i < n-1) ans[i] = Math.min(ans[i], ans[i+1] + 1);\\n        }\\n        return ans;\\n}\\n```\\n\\n2- keep track of last appearance of C\\n* pos = last appearance of c\\n* going from left to right, dist[i] = i - pos\\n* going from right to left, dist[i] = pos - i\\n\\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int pos = -n;\\n        int[] ans = new int[n];\\n\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n\\n        pos = 2*n;\\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = Math.min(ans[i], pos - i);\\n        }\\n\\n        return ans;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] ans = new int[n];\\n        Arrays.fill(ans, n);\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if(i > 0) ans[i] = Math.min(ans[i], ans[i-1] + 1);\\n        }\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) ans[i] = 0;\\n            else if (i < n-1) ans[i] = Math.min(ans[i], ans[i+1] + 1);\\n        }\\n        return ans;\\n}\\n```\n```\\npublic int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int pos = -n;\\n        int[] ans = new int[n];\\n\\n        for(int i=0; i<n; i++) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n\\n        pos = 2*n;\\n        for(int i=n-1; i>=0; i--) {\\n            if(s.charAt(i) == c) pos = i;\\n            ans[i] = Math.min(ans[i], pos - i);\\n        }\\n\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054157,
                "title": "javascript-simple-1-pass-beats-100",
                "content": "```javascript\\nvar shortestToChar = function(s, c) {\\n    const answer = Array(s.length).fill(Infinity);\\n    let l = Infinity, r = Infinity;\\n    \\n    for(let f = 0; f < s.length; f++) {\\n        const b = s.length-1-f;\\n        \\n        l = s[f] === c ? 0 : l+1;\\n        r = s[b] === c ? 0 : r+1;\\n        \\n        answer[f] = Math.min(answer[f], l);\\n        answer[b] = Math.min(answer[b], r);\\n    }\\n    return answer;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar shortestToChar = function(s, c) {\\n    const answer = Array(s.length).fill(Infinity);\\n    let l = Infinity, r = Infinity;\\n    \\n    for(let f = 0; f < s.length; f++) {\\n        const b = s.length-1-f;\\n        \\n        l = s[f] === c ? 0 : l+1;\\n        r = s[b] === c ? 0 : r+1;\\n        \\n        answer[f] = Math.min(answer[f], l);\\n        answer[b] = Math.min(answer[b], r);\\n    }\\n    return answer;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2170593,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>position;\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                position.push_back(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){ \\n        int mn=INT_MAX;\\n        for(int j=0;j<position.size();j++){\\n            mn=min(mn,abs(i-position[j]));\\n        }\\n             ans.push_back(mn);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>position;\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                position.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 514955,
                "title": "javascript-solution-with-comments",
                "content": "> Runtime: **92 ms**, faster than *51.38%* of JavaScript online submissions\\n> Memory Usage: **40.8 MB**, less than *58.84%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nconst shortestToChar = (s, c) => {\\n  // Create an array to hold the distances the same length as the string\\n  // And fill it with `Infinity` because `Math.min` gets used below\\n  // But filling with `s.length` or `104` (from Constraints) would also work.\\n  const res = new Array(s.length).fill(Infinity);\\n  for (\\n    // Create some variables to use while looping through the string\\n    // - `li` Left Index: Traverse the string from left to right\\n    // - `ld` Left Distance: Reset to `0` every time `c` is seen in the string\\n    // - `ri` Right Index: Traverse the string from right to left\\n    // - `rd` Right Distance: Reset to `0` every time `c` is seen in the string\\n    let li = 0, ld = Infinity, ri = s.length - 1, rd = Infinity;\\n    // Stop the loop before the Left Index goes off the right end of the string\\n    // This also stops the loop before the Right Index goes off the left end\\n    li < s.length;\\n    // After every iteration:\\n    // - The left index moves `1` place to the left\\n    // - The left distance increases by `1`\\n    // - The right index moves `1` place to the right\\n    // - The right distance increases by `1`\\n    li++, ld++, ri--, rd++\\n  ) {\\n    // If the character at the left index is the character we\\'re looking for,\\n    // reset the left distance to `0`\\n    if (s[li] === c) ld = 0;\\n    // As we move left, set the `res` array value to the lesser distance:\\n    // - `res[li]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Right Distance to the sought character\\n    // - `ld` Distance to the sought character looking left\\n    res[li] = Math.min(res[li], ld);\\n    // If the character at the right index is the character we\\'re looking for,\\n    // reset the right distance to `0`\\n    if (s[ri] === c) rd = 0;\\n    // As we move right, set the `res` array value to the lesser distance:\\n    // - `res[ri]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Left Distance to the sought character\\n    // - `rd` Distance to the sought character looking right\\n    res[ri] = Math.min(res[ri], rd);\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nconst shortestToChar = (s, c) => {\\n  // Create an array to hold the distances the same length as the string\\n  // And fill it with `Infinity` because `Math.min` gets used below\\n  // But filling with `s.length` or `104` (from Constraints) would also work.\\n  const res = new Array(s.length).fill(Infinity);\\n  for (\\n    // Create some variables to use while looping through the string\\n    // - `li` Left Index: Traverse the string from left to right\\n    // - `ld` Left Distance: Reset to `0` every time `c` is seen in the string\\n    // - `ri` Right Index: Traverse the string from right to left\\n    // - `rd` Right Distance: Reset to `0` every time `c` is seen in the string\\n    let li = 0, ld = Infinity, ri = s.length - 1, rd = Infinity;\\n    // Stop the loop before the Left Index goes off the right end of the string\\n    // This also stops the loop before the Right Index goes off the left end\\n    li < s.length;\\n    // After every iteration:\\n    // - The left index moves `1` place to the left\\n    // - The left distance increases by `1`\\n    // - The right index moves `1` place to the right\\n    // - The right distance increases by `1`\\n    li++, ld++, ri--, rd++\\n  ) {\\n    // If the character at the left index is the character we\\'re looking for,\\n    // reset the left distance to `0`\\n    if (s[li] === c) ld = 0;\\n    // As we move left, set the `res` array value to the lesser distance:\\n    // - `res[li]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Right Distance to the sought character\\n    // - `ld` Distance to the sought character looking left\\n    res[li] = Math.min(res[li], ld);\\n    // If the character at the right index is the character we\\'re looking for,\\n    // reset the right distance to `0`\\n    if (s[ri] === c) rd = 0;\\n    // As we move right, set the `res` array value to the lesser distance:\\n    // - `res[ri]` The default value, `Infinity` or, passed the halfway point,\\n    //   the previously set Left Distance to the sought character\\n    // - `rd` Distance to the sought character looking right\\n    res[ri] = Math.min(res[ri], rd);\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511187,
                "title": "javascript-2-passes",
                "content": "```\\nvar shortestToChar = function(S, C) {\\n    const dp = new Array(S.length).fill(Infinity);\\n    \\n    dp[0] = S[0] === C ? 0 : Infinity\\n    \\n    for(let i = 1; i < S.length; i++) {\\n        if(S[i] === C) {\\n            dp[i] = 0;\\n        } else {\\n            dp[i] = dp[i-1] === Infinity ? Infinity : dp[i-1] + 1;\\n        }\\n    }\\n\\n    let dist = Infinity;\\n    \\n    for(let i = S.length-1; i >= 0; i--) {\\n        if(S[i] === C) {\\n            dist = 0;\\n        }\\n        dp[i] = Math.min(dist, dp[i]);\\n        dist += 1;\\n    }\\n    \\n    return dp;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    const dp = new Array(S.length).fill(Infinity);\\n    \\n    dp[0] = S[0] === C ? 0 : Infinity\\n    \\n    for(let i = 1; i < S.length; i++) {\\n        if(S[i] === C) {\\n            dp[i] = 0;\\n        } else {\\n            dp[i] = dp[i-1] === Infinity ? Infinity : dp[i-1] + 1;\\n        }\\n    }\\n\\n    let dist = Infinity;\\n    \\n    for(let i = S.length-1; i >= 0; i--) {\\n        if(S[i] === C) {\\n            dist = 0;\\n        }\\n        dp[i] = Math.min(dist, dp[i]);\\n        dist += 1;\\n    }\\n    \\n    return dp;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1300191,
                "title": "java-do-check-out-for-explanation-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n\\nThe idea is to find the minimum char say c index from right for all position.\\nAnd again find the minimum char say c index from left for all position.\\nNow, whichever (left or right) gives you the minimum that is the minimum distance for char c for that position.\\n\\n```\\nclass Solution {\\n   \\n    public int[] shortestToChar(String s, char c) {\\n    \\n        int[] ans = new int[s.length()];\\n        int index = 0;\\n        \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.abs(i - index);\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.min(ans[i], Math.abs(i - index));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n------------------------------------------------------------",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\n    public int[] shortestToChar(String s, char c) {\\n    \\n        int[] ans = new int[s.length()];\\n        int index = 0;\\n        \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.abs(i - index);\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                index = i;\\n            }\\n            ans[i] = Math.min(ans[i], Math.abs(i - index));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226696,
                "title": "python3-any-improvement",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        L = []\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                L.append(idx)\\n        \\n        distance = []\\n        i = 0\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                distance.append(0)\\n                i += 1\\n            elif idx < L[0]:\\n                distance.append(L[0] - idx)\\n            elif idx > L[-1]:\\n                distance.append(idx - L[-1])\\n            else:\\n                distance.append(min((L[i] - idx), (idx - L[i-1])))                    \\n        return distance\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        L = []\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                L.append(idx)\\n        \\n        distance = []\\n        i = 0\\n        for idx, value in enumerate(s):\\n            if value == c:\\n                distance.append(0)\\n                i += 1\\n            elif idx < L[0]:\\n                distance.append(L[0] - idx)\\n            elif idx > L[-1]:\\n                distance.append(idx - L[-1])\\n            else:\\n                distance.append(min((L[i] - idx), (idx - L[i-1])))                    \\n        return distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090998,
                "title": "2-line-python-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        ids = [i for i in range(len(s)) if s[i] == c]\\n        return [min([abs(i-id_) for id_ in ids]) for i in range(len(s))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        ids = [i for i in range(len(s)) if s[i] == c]\\n        return [min([abs(i-id_) for id_ in ids]) for i in range(len(s))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055497,
                "title": "c-two-pass-easy-to-understand-solution",
                "content": "**Approach 1 : Using BFS for shortest distance** \\n\\tTime Complexity - O(n)\\n\\tSpace Complexity - O(n) \\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        queue<vector<int> > q;\\n        for(int i=0;i<len;i++)\\n            if(s[i]==c){\\n                q.push({i,0});\\n                ans[i]=0;\\n            }\\n        while(!q.empty()){\\n            int qsize=q.size();\\n            while(qsize--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                if(v[0]+1<len && ans[v[0]+1]==INT_MAX){\\n                    q.push({v[0]+1,v[1]+1});\\n                    ans[v[0]+1]=v[1]+1;\\n                } \\n                if(v[0]>0 && ans[v[0]-1]==INT_MAX){\\n                    q.push({v[0]-1,v[1]+1});\\n                    ans[v[0]-1]=v[1]+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n**Approach 2 :  Without extra space , two traversals -one from start , another from end**\\n\\tTime Complexity - O(n)\\n\\tSpace Complexity - O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        int pos_c=len*(-1);\\n        for(int i=0;i<len;i++){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],i-pos_c);\\n        }\\n        pos_c=2*len;\\n        for(int i=len-1;i>=0;i--){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],pos_c-i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHave doubts , please let me know in comments.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        queue<vector<int> > q;\\n        for(int i=0;i<len;i++)\\n            if(s[i]==c){\\n                q.push({i,0});\\n                ans[i]=0;\\n            }\\n        while(!q.empty()){\\n            int qsize=q.size();\\n            while(qsize--){\\n                vector<int> v=q.front();\\n                q.pop();\\n                if(v[0]+1<len && ans[v[0]+1]==INT_MAX){\\n                    q.push({v[0]+1,v[1]+1});\\n                    ans[v[0]+1]=v[1]+1;\\n                } \\n                if(v[0]>0 && ans[v[0]-1]==INT_MAX){\\n                    q.push({v[0]-1,v[1]+1});\\n                    ans[v[0]-1]=v[1]+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len=s.length();\\n        vector<int> ans(len,INT_MAX);\\n        int pos_c=len*(-1);\\n        for(int i=0;i<len;i++){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],i-pos_c);\\n        }\\n        pos_c=2*len;\\n        for(int i=len-1;i>=0;i--){\\n            if(s[i]==c)\\n                pos_c=i;\\n            ans[i]=min(ans[i],pos_c-i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914650,
                "title": "python3-100-faster-100-less-memory-20ms-14mb",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        l = [0] * len(S)\\n        prev = None\\n        for i, x in enumerate(S):\\n            if x == C:\\n\\n\\t\\t\\t\\t# only correct the closer half of the indexes between previous and current if previous is not None\\n                start = 0 if prev is None else (i + prev) // 2 + 1\\n\\n\\t\\t\\t\\t# slice assign where corrections are needed to a range\\n                l[start:i + 1] = range(i - start, -1, -1)\\n\\n                prev = i\\n            elif prev is not None:\\n                l[i] = i - prev\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        l = [0] * len(S)\\n        prev = None\\n        for i, x in enumerate(S):\\n            if x == C:\\n\\n\\t\\t\\t\\t# only correct the closer half of the indexes between previous and current if previous is not None\\n                start = 0 if prev is None else (i + prev) // 2 + 1\\n\\n\\t\\t\\t\\t# slice assign where corrections are needed to a range\\n                l[start:i + 1] = range(i - start, -1, -1)\\n\\n                prev = i\\n            elif prev is not None:\\n                l[i] = i - prev\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596450,
                "title": "c-easiest-o-n-time-100-fastest",
                "content": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> v , ans;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            if(s[i] == c)\\n                v.push_back(i);\\n        }\\n        int j = 0;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            \\n            if(j == 0)\\n                ans.push_back(v[j] - i); \\n            else if(j >= v.size())\\n                ans.push_back(i - v[j - 1]);\\n            else\\n                ans.push_back(min(v[j] - i , i - v[j - 1]));\\n            if(s[i] == c)\\n                j++;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> v , ans;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            if(s[i] == c)\\n                v.push_back(i);\\n        }\\n        int j = 0;\\n        for(int i = 0 ; i < s.size() ;i++){\\n            \\n            if(j == 0)\\n                ans.push_back(v[j] - i); \\n            else if(j >= v.size())\\n                ans.push_back(i - v[j - 1]);\\n            else\\n                ans.push_back(min(v[j] - i , i - v[j - 1]));\\n            if(s[i] == c)\\n                j++;\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557360,
                "title": "easy-java-o-n-soution",
                "content": "```\\npublic static int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] arr = new int[n];\\n        int c_position = -n;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = i - c_position;\\n        }\\n\\n        for (int i = n-1; i >= 0; i--) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = Math.min(arr[i], Math.abs(i - c_position));\\n        }\\n        return arr;\\n    }\\n\\t\\n\\t// Please Up-Vote\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int[] shortestToChar(String s, char c) {\\n        int n = s.length();\\n        int[] arr = new int[n];\\n        int c_position = -n;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = i - c_position;\\n        }\\n\\n        for (int i = n-1; i >= 0; i--) {\\n            if(s.charAt(i) == c){\\n                c_position = i;\\n            }\\n            arr[i] = Math.min(arr[i], Math.abs(i - c_position));\\n        }\\n        return arr;\\n    }\\n\\t\\n\\t// Please Up-Vote\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2226939,
                "title": "easiest-python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # occurence of charachter in the array.\\n        occ = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                occ.append(i)\\n        ans = []\\n        for i in range(len(s)):\\n            #checking distance of each point from occurences ans the selecting the least distance. \\n            tmplst = []\\n            for j in occ:\\n                tmplst.append(abs(i-j))\\n            ans.append(min(tmplst))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # occurence of charachter in the array.\\n        occ = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                occ.append(i)\\n        ans = []\\n        for i in range(len(s)):\\n            #checking distance of each point from occurences ans the selecting the least distance. \\n            tmplst = []\\n            for j in occ:\\n                tmplst.append(abs(i-j))\\n            ans.append(min(tmplst))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007025,
                "title": "python-3-solution-brute-force-and-two-pointers-2-solutions",
                "content": "Brute Force:\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        req = []\\n        ind_list = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                ind_list.append(i)\\n        min_dis = len(s)\\n        for j in range(len(s)):\\n            for k in range(len(ind_list)):\\n                min_dis = min(min_dis, abs(j - ind_list[k]))\\n            req.append(min_dis)\\n            min_dis = len(s)\\n            \\n        return req\\n```\\n\\nTwo Pointers, O(n) Time and Space\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n#         Travelling front to back\\n        result = [\"*\"] * len(s)\\n        i, j = 0, 0\\n        while i < len(s) and j < len(s):\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i += 1\\n                j += 1\\n            elif s[i] != c and s[j] == c:\\n                result[i] = abs(i-j)\\n                i += 1\\n            elif s[i] != c and s[j] != c:\\n                j += 1\\n    \\n#         Travelling back to front\\n        i = j = len(s) - 1\\n        while i >= 0 and j >= 0:\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i -= 1\\n                j -= 1\\n            elif s[i] != c and s[j] == c:\\n                if type(result[i]) == int:\\n                    result[i] = min(result[i], abs(i-j))\\n                else:\\n                    result[i] = abs(i-j)\\n                i -= 1\\n            elif s[i] != c and s[j] != c:\\n                j -= 1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        req = []\\n        ind_list = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                ind_list.append(i)\\n        min_dis = len(s)\\n        for j in range(len(s)):\\n            for k in range(len(ind_list)):\\n                min_dis = min(min_dis, abs(j - ind_list[k]))\\n            req.append(min_dis)\\n            min_dis = len(s)\\n            \\n        return req\\n```\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n#         Travelling front to back\\n        result = [\"*\"] * len(s)\\n        i, j = 0, 0\\n        while i < len(s) and j < len(s):\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i += 1\\n                j += 1\\n            elif s[i] != c and s[j] == c:\\n                result[i] = abs(i-j)\\n                i += 1\\n            elif s[i] != c and s[j] != c:\\n                j += 1\\n    \\n#         Travelling back to front\\n        i = j = len(s) - 1\\n        while i >= 0 and j >= 0:\\n            if s[i] == s[j] == c:\\n                result[i] = 0\\n                i -= 1\\n                j -= 1\\n            elif s[i] != c and s[j] == c:\\n                if type(result[i]) == int:\\n                    result[i] = min(result[i], abs(i-j))\\n                else:\\n                    result[i] = abs(i-j)\\n                i -= 1\\n            elif s[i] != c and s[j] != c:\\n                j -= 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054414,
                "title": "java-2-pointer-o-n-1ms-beats-97",
                "content": "\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int ptr1 = Integer.MAX_VALUE;\\n        int ptr2 = Integer.MAX_VALUE;\\n        int index = -1;\\n        int l = s.length();\\n        int[] ans = new int[l];\\n        \\n        while(index<l-1){\\n            int temp = index+1;\\n            \\n            while(temp<l && s.charAt(temp)!=c)\\n                temp++;\\n            \\n            if(temp == l){\\n                temp = Integer.MAX_VALUE;\\n            }\\n            \\n            ptr2 = ptr1;\\n            ptr1 = temp;\\n            \\n            index++;\\n            while(index<l && index<=temp){\\n                ans[index] = Math.min(Math.abs(ptr1-index),Math.abs(ptr2-index));\\n                index++;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int ptr1 = Integer.MAX_VALUE;\\n        int ptr2 = Integer.MAX_VALUE;\\n        int index = -1;\\n        int l = s.length();\\n        int[] ans = new int[l];\\n        \\n        while(index<l-1){\\n            int temp = index+1;\\n            \\n            while(temp<l && s.charAt(temp)!=c)\\n                temp++;\\n            \\n            if(temp == l){\\n                temp = Integer.MAX_VALUE;\\n            }\\n            \\n            ptr2 = ptr1;\\n            ptr1 = temp;\\n            \\n            index++;\\n            while(index<l && index<=temp){\\n                ans[index] = Math.min(Math.abs(ptr1-index),Math.abs(ptr2-index));\\n                index++;\\n            }\\n            index--;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1054364,
                "title": "2-pass-but-different-and-intuitive-comments-included",
                "content": "```\\nimport kotlin.math.min\\n\\nclass Solution {\\n    fun shortestToChar(s: String, c: Char): IntArray {\\n\\t// tracks postitions of occurences of the character c in string s\\n        var positions = mutableListOf<Int>()\\n\\t\\t\\n        var ans = mutableListOf<Int>()\\n        \\n        for(i in 0..s.length-1){\\n            if(s[i]==c)\\n                positions.add(i)\\n        }\\n\\t\\t\\n\\t// cannot explain this xD\\n        positions.add(-1)\\n        \\n\\t// position of left occurence of c in s\\n        var left = -1\\n\\t\\t\\n\\t// position of right occurence of c in s\\n        var right = positions.removeAt(0)\\n\\t\\t\\n\\t// left distance\\n        var ld : Int\\n\\t\\t\\n\\t// right distance\\n        var rd : Int\\n        \\n        for(i in 0..s.length-1){\\n            ld = Int.MAX_VALUE\\n            rd = Int.MAX_VALUE\\n            if(left!=-1)\\n                ld = i-left\\n            if(right!=-1)\\n                rd = right-i\\n            ans.add(min(ld, rd))\\n            \\n            if(i==right){\\n                left = right\\n                right = positions.removeAt(0)\\n            }\\n        }\\n        \\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.min\\n\\nclass Solution {\\n    fun shortestToChar(s: String, c: Char): IntArray {\\n\\t// tracks postitions of occurences of the character c in string s\\n        var positions = mutableListOf<Int>()\\n\\t\\t\\n        var ans = mutableListOf<Int>()\\n        \\n        for(i in 0..s.length-1){\\n            if(s[i]==c)\\n                positions.add(i)\\n        }\\n\\t\\t\\n\\t// cannot explain this xD\\n        positions.add(-1)\\n        \\n\\t// position of left occurence of c in s\\n        var left = -1\\n\\t\\t\\n\\t// position of right occurence of c in s\\n        var right = positions.removeAt(0)\\n\\t\\t\\n\\t// left distance\\n        var ld : Int\\n\\t\\t\\n\\t// right distance\\n        var rd : Int\\n        \\n        for(i in 0..s.length-1){\\n            ld = Int.MAX_VALUE\\n            rd = Int.MAX_VALUE\\n            if(left!=-1)\\n                ld = i-left\\n            if(right!=-1)\\n                rd = right-i\\n            ans.add(min(ld, rd))\\n            \\n            if(i==right){\\n                left = right\\n                right = positions.removeAt(0)\\n            }\\n        }\\n        \\n        return ans.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054208,
                "title": "shortest-distance-to-a-character-simple-dp-solution-w-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nSince this problem is asking us to reference characters both ahead and behind the current charcter, this should bring to mind a two-pass **dynamic programming** solution. We can iterate through the input string (**S**) once and fill our answer array (**ans**) with the distance from the preceeding occurrence of **C**.\\n\\nThen we can iterate backwards through **S** again so that we can pick the best result between the value we obtained in the first pass with the distance from the preceeding **C** going the opposite direction.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **80ms / 39.0MB** (beats 99% /100%).\\n```javascript\\nvar shortestToChar = function(S, C) {\\n    let len = S.length, ans = new Uint16Array(len)\\n    ans[0] = S.charAt(0) === C ? 0 : 10001\\n    for (let i = 1; i < len; i++) \\n        ans[i] = S.charAt(i) === C ? 0 : ans[i-1] + 1\\n    for (let i = len - 2; ~i; i--)\\n        ans[i] = Math.min(ans[i], ans[i+1] + 1)\\n    return ans\\n};\\n```\\n\\n---\\n\\n***Python3 Code:***\\n\\nThe best result for the code below is **28ms / 14.3MB** (beats 99% / 86%).\\n```python\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        ans = []\\n        ans.append(0 if S[0] == C else 10001)\\n        for i in range(1,len(S)):\\n            ans.append(0 if S[i] == C else ans[i-1] + 1)\\n        for i in range(len(S)-2,-1,-1):\\n            ans[i] = min(ans[i], ans[i+1] + 1)\\n        return ans\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **1ms / 38.8MB** (beats 97% / 93%).\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int len = S.length();\\n        int[] ans = new int[len];\\n        ans[0] = S.charAt(0) == C ? 0 : 10001;\\n        for (int i = 1; i < len; i++) \\n            ans[i] = S.charAt(i) == C ? 0 : ans[i-1] + 1;\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = Math.min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **0ms /6.5MB** (beats 100% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length();\\n        std::vector<int> ans;\\n        ans.push_back(S[0] == C ? 0 : 10001);\\n        for (int i = 1; i < len; i++) \\n            ans.push_back(S[i] == C ? 0 : ans[i-1] + 1);\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar shortestToChar = function(S, C) {\\n    let len = S.length, ans = new Uint16Array(len)\\n    ans[0] = S.charAt(0) === C ? 0 : 10001\\n    for (let i = 1; i < len; i++) \\n        ans[i] = S.charAt(i) === C ? 0 : ans[i-1] + 1\\n    for (let i = len - 2; ~i; i--)\\n        ans[i] = Math.min(ans[i], ans[i+1] + 1)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        ans = []\\n        ans.append(0 if S[0] == C else 10001)\\n        for i in range(1,len(S)):\\n            ans.append(0 if S[i] == C else ans[i-1] + 1)\\n        for i in range(len(S)-2,-1,-1):\\n            ans[i] = min(ans[i], ans[i+1] + 1)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int len = S.length();\\n        int[] ans = new int[len];\\n        ans[0] = S.charAt(0) == C ? 0 : 10001;\\n        for (int i = 1; i < len; i++) \\n            ans[i] = S.charAt(i) == C ? 0 : ans[i-1] + 1;\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = Math.min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length();\\n        std::vector<int> ans;\\n        ans.push_back(S[0] == C ? 0 : 10001);\\n        for (int i = 1; i < len; i++) \\n            ans.push_back(S[i] == C ? 0 : ans[i-1] + 1);\\n        for (int i = len - 2; i >= 0; i--)\\n            ans[i] = min(ans[i], ans[i+1] + 1);  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054175,
                "title": "c-o-n-simple-easy-understanding-cool-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> shortestToChar(string s, char c) {\\n\\t\\t\\tint n = s.size(), lastC = -n, i = 0;\\n\\t\\t\\tvector<int> ans (n, n);\\n\\t\\t\\tfor (; i < n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = i - lastC;\\n\\t\\t\\t}\\n\\t\\t\\tfor (i = lastC; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = min(ans[i], lastC - i);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> shortestToChar(string s, char c) {\\n\\t\\t\\tint n = s.size(), lastC = -n, i = 0;\\n\\t\\t\\tvector<int> ans (n, n);\\n\\t\\t\\tfor (; i < n; ++i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( s[i] == c ) lastC = i;\\n\\t\\t\\t\\tans[i] = i - lastC;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 687583,
                "title": "java-two-pointers-one-pass-time-o-n-optimal-faster-than-98-5",
                "content": "Approach:\\n\\nMaintain two pointers (one for the current character in S (sIndex) and the other (cIndex) to track the next occurence of C in S). Also have another variable to hold the previous occurence of C in S (prevCIndex) which is initially set to -1.\\n\\nFirstly, as it\\'s guaranteed to have at least one C in S, find the first occurence of C in S by incrementing C pointer (cIndex). Now, until the S pointer (sIndex) reaches C pointer (cIndex), calculate the shortest distance which is (cIndex - sIndex). Remember at this stage there is no previous occurrence of C in S. Therefore, `result[i] = cIndex - sIndex;`\\n\\nMoving on, there are two cases: \\n1) You might\\'ve a next of occurrence of C in S\\n2) You might not have any more occurrences of C (in the case which cIndex is beyond String length). \\n\\nIn the former, you get the minimum of the previous C Index and the current C Index to the current character in S (`Math.min(cIndex - sIndex, sIndex - prevCIndex)`)\\n& in the latter you just calculate the distance from the previous C Index to the current character in S (`sIndex - prevCIndex`).\\n\\nRefer to the below code for better understanding.\\n\\n```\\n   public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n\\n\\t\\t// Pointers to track C in S & the current moving index in S respectively\\n\\t\\tint cIndex = 0, sIndex = 0;\\n\\n\\t\\t// Pointer to track the previous occurrence of C in S - Initially set to -1\\n\\t\\tint prevCIndex = -1;\\n\\n\\t\\twhile (cIndex < S.length()) {\\n\\t\\t\\t// Find the first/next occurrence of C in S\\n\\t\\t\\twhile (cIndex < S.length() && S.charAt(cIndex) != C) {\\n\\t\\t\\t\\tcIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move the S pointer until C and fill the result with the shortest distance\\n\\t\\t\\twhile (sIndex < cIndex) {\\n\\t\\t\\t\\tif (prevCIndex == -1) {\\n\\t\\t\\t\\t\\t// Initial stage where there is no previous occurrence of C in S yet\\n\\t\\t\\t\\t\\tresult[sIndex] = cIndex - sIndex;\\n\\t\\t\\t\\t} else if (cIndex < S.length() && S.charAt(cIndex) == C) {\\n\\t\\t\\t\\t\\t// You have both previous and the next occurrences of C in S - Get the minimum\\n\\t\\t\\t\\t\\tresult[sIndex] = Math.min(cIndex - sIndex, sIndex - prevCIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Last stage where you crossed the last occurrence of C in S\\n\\t\\t\\t\\t\\tresult[sIndex] = sIndex - prevCIndex;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Increment the current pointer in S\\n\\t\\t\\t\\tsIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the current occurrence of C to previous\\n\\t\\t\\tprevCIndex = cIndex;\\n\\n\\t\\t\\t// Increment both the pointers\\n\\t\\t\\tsIndex++;\\n\\t\\t\\tcIndex++;\\n\\t\\t}\\n        \\n        return result;\\n    }\\n```\\n\\n\\nTime: O(n)\\nSpace: O(1) (Excluding the result array to be returned)",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n   public int[] shortestToChar(String S, char C) {\\n        int[] result = new int[S.length()];\\n\\n\\t\\t// Pointers to track C in S & the current moving index in S respectively\\n\\t\\tint cIndex = 0, sIndex = 0;\\n\\n\\t\\t// Pointer to track the previous occurrence of C in S - Initially set to -1\\n\\t\\tint prevCIndex = -1;\\n\\n\\t\\twhile (cIndex < S.length()) {\\n\\t\\t\\t// Find the first/next occurrence of C in S\\n\\t\\t\\twhile (cIndex < S.length() && S.charAt(cIndex) != C) {\\n\\t\\t\\t\\tcIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Move the S pointer until C and fill the result with the shortest distance\\n\\t\\t\\twhile (sIndex < cIndex) {\\n\\t\\t\\t\\tif (prevCIndex == -1) {\\n\\t\\t\\t\\t\\t// Initial stage where there is no previous occurrence of C in S yet\\n\\t\\t\\t\\t\\tresult[sIndex] = cIndex - sIndex;\\n\\t\\t\\t\\t} else if (cIndex < S.length() && S.charAt(cIndex) == C) {\\n\\t\\t\\t\\t\\t// You have both previous and the next occurrences of C in S - Get the minimum\\n\\t\\t\\t\\t\\tresult[sIndex] = Math.min(cIndex - sIndex, sIndex - prevCIndex);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Last stage where you crossed the last occurrence of C in S\\n\\t\\t\\t\\t\\tresult[sIndex] = sIndex - prevCIndex;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Increment the current pointer in S\\n\\t\\t\\t\\tsIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the current occurrence of C to previous\\n\\t\\t\\tprevCIndex = cIndex;\\n\\n\\t\\t\\t// Increment both the pointers\\n\\t\\t\\tsIndex++;\\n\\t\\t\\tcIndex++;\\n\\t\\t}\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420683,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n     {\\n        vector<int>indexes;\\n        vector<int>sol;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n     {\\n        vector<int>indexes;\\n        vector<int>sol;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686262,
                "title": "java-easy-to-understand",
                "content": "# Happy Coding\\u270C\\uFE0F\\u270C\\uFE0F\\u270C\\uFE0F\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c)\\n    {\\n    int[] arr=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int left=i-1;\\n            int right=i+1;\\n            while(left>=0 || right <s.length())\\n            {\\n                if(s.charAt(i)==c)\\n                {\\n                    arr[i]=0;\\n                    break;\\n                }\\n                \\n                if(right < s.length() && s.charAt(right) == c)\\n                {\\n                    arr[i]=right-i;\\n                    break;\\n                }\\n                if( left >= 0 && s.charAt(left)== c)\\n                {\\n                    arr[i]=i-left;\\n                    break;\\n                }\\n                left--;\\n                right++;\\n            }\\n        }\\n         return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c)\\n    {\\n    int[] arr=new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int left=i-1;\\n            int right=i+1;\\n            while(left>=0 || right <s.length())\\n            {\\n                if(s.charAt(i)==c)\\n                {\\n                    arr[i]=0;\\n                    break;\\n                }\\n                \\n                if(right < s.length() && s.charAt(right) == c)\\n                {\\n                    arr[i]=right-i;\\n                    break;\\n                }\\n                if( left >= 0 && s.charAt(left)== c)\\n                {\\n                    arr[i]=i-left;\\n                    break;\\n                }\\n                left--;\\n                right++;\\n            }\\n        }\\n         return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656937,
                "title": "java-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        char c1[] = s.toCharArray();\\n        for(int i = 0;i<c1.length;i++){\\n            if(c1[i] == c){\\n                list.add(i);\\n            }\\n        }\\n        int res[] = new int[c1.length];\\n        for(int i = 0;i<res.length;i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int p : list){\\n                min = Math.min(min, Math.abs(i-p));\\n            }\\n            res[i] = min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        char c1[] = s.toCharArray();\\n        for(int i = 0;i<c1.length;i++){\\n            if(c1[i] == c){\\n                list.add(i);\\n            }\\n        }\\n        int res[] = new int[c1.length];\\n        for(int i = 0;i<res.length;i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int p : list){\\n                min = Math.min(min, Math.abs(i-p));\\n            }\\n            res[i] = min;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318807,
                "title": "simple-javascript-solution-faster-than-80-only-1-loop",
                "content": "You just push a 0 if the char is the c, and if not you calculate the min between the distance of the last 0 and the next c in the string using indexOf and lastIndexOf\\n\\n````\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    \\n    let result = []\\n    \\n    for(let i = 0; i< s.length ; i++) {\\n        \\n        if(s.charAt(i) === c) result.push(0)\\n        else {\\n            const next = s.indexOf(c,i) === -1 ? Infinity : s.indexOf(c,i) -i\\n            const prev = result.lastIndexOf(0) === -1 ? Infinity : i- result.lastIndexOf(0) \\n            result.push(Math.min(next,prev))\\n        }\\n        \\n    }\\n    \\n    return result\\n};\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    \\n    let result = []\\n    \\n    for(let i = 0; i< s.length ; i++) {\\n        \\n        if(s.charAt(i) === c) result.push(0)\\n        else {\\n            const next = s.indexOf(c,i) === -1 ? Infinity : s.indexOf(c,i) -i\\n            const prev = result.lastIndexOf(0) === -1 ? Infinity : i- result.lastIndexOf(0) \\n            result.push(Math.min(next,prev))\\n        }\\n        \\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541999,
                "title": "java-98-faster-only-one-loop-simple-efficient",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        \\n        for (int i = 0, j = 0; i < ans.length; i++) {\\n            if (i == 0) j = s.indexOf(c);\\n            if (i > j && s.indexOf(c, i) >= 0 && Math.abs(j-i) > Math.abs(s.indexOf(c, i)-i)) {\\n                j = s.indexOf(c, i);\\n            }\\n            ans[i] = Math.abs(j-i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        \\n        for (int i = 0, j = 0; i < ans.length; i++) {\\n            if (i == 0) j = s.indexOf(c);\\n            if (i > j && s.indexOf(c, i) >= 0 && Math.abs(j-i) > Math.abs(s.indexOf(c, i)-i)) {\\n                j = s.indexOf(c, i);\\n            }\\n            ans[i] = Math.abs(j-i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056605,
                "title": "c-o-n-easy-to-understand",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        int n=s.length();\\n        vector<int>ans(n,0);\\n        int lp=-999999;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=i-lp;\\n        }\\n        \\n        lp=INT_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=min(ans[i],lp-i);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Upvote if found helpful**",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        int n=s.length();\\n        vector<int>ans(n,0);\\n        int lp=-999999;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=i-lp;\\n        }\\n        \\n        lp=INT_MAX;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                lp=i;\\n            \\n            ans[i]=min(ans[i],lp-i);\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055763,
                "title": "python-shortest-distance-to-a-character-runtime-32ms-memory-usage-14-200-kb",
                "content": "\"\"\"\\n        implemented by me \\n        Noted: Time Complexity = 32ms O(n)\\n                Space Complexity = O(n)\\n        \"\"\"\\n\\n        dist = []\\n        c_ind = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                c_ind.append(i)\\n\\n        c_count = 0\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                dist.append(0)\\n                if c_count < len(c_ind)-1:\\n                    c_count += 1\\n            elif c_count == 0:\\n                dist.append(abs(c_ind[c_count]-i))\\n            elif abs(c_ind[c_count-1]-i) <= abs(c_ind[c_count]-i):\\n                dist.append(abs(c_ind[c_count-1]-i))\\n            else:\\n                dist.append(abs(c_ind[c_count]-i))\\n\\n        return dist",
                "solutionTags": [
                    "Python"
                ],
                "code": "\"\"\"\\n        implemented by me \\n        Noted: Time Complexity = 32ms O(n)\\n                Space Complexity = O(n)\\n        \"\"\"\\n\\n        dist = []\\n        c_ind = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                c_ind.append(i)\\n\\n        c_count = 0\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                dist.append(0)\\n                if c_count < len(c_ind)-1:\\n                    c_count += 1\\n            elif c_count == 0:\\n                dist.append(abs(c_ind[c_count]-i))\\n            elif abs(c_ind[c_count-1]-i) <= abs(c_ind[c_count]-i):\\n                dist.append(abs(c_ind[c_count-1]-i))\\n            else:\\n                dist.append(abs(c_ind[c_count]-i))\\n\\n        return dist",
                "codeTag": "Unknown"
            },
            {
                "id": 1055141,
                "title": "any-language-two-pass-o-n-0ms-very-easy-with-detailed-explanation-example-on-golang",
                "content": "How to find a minimal distance? We need to take into consideration only distance from closest letters from left and right side. No need to count distance from far remote letters.\\n\\n\\nNext, when we see a part of a string like here and suppose we want to calculate distance from `o` to closest `e`\\'s.\\n```\\nleetcode\\n     ^\\n```\\nLet\\'s split a task into 2 symmetrical ones: distance from left letter and distance from right letter.\\n\\nHow to calculate and store distance from left `e`? Just walk through the string and check - if we see letter `e` then its distance is 0, and with any another letter distance increments by 1.\\n\\nSo distances between letters `e` will be (I\\'ve added extra space between letters for readibility):\\n\\n```\\nl    e      e      t       c       o       d      e\\n                                   ^\\n\\t\\t    0      1       2       3       4      5\\n```\\n\\nNext, go from right with the same distance calculation. But this time check if there\\'s a closer letter `e` from another side.\\n\\nWe may code this using any language only with standard operators and arrays. \\nHere\\'s an example on Golang.\\n\\n```golang\\nfunc shortestToChar(s string, c byte) []int {\\n\\t// cache string length\\n    var lens = len(s)\\n\\t// prepare a storage for the result \\n\\t// slice (or array, vector) with length equal to len(s) initialized with zeros\\n    var res = make([]int, lens)\\n    \\n    // current distance from last seen letter `c`\\n    // we start with increadibly high value to show it\\'s invalid\\n    var dist = lens + 100\\n    \\n    // scan from left to right, increase distance from last seen letter\\n    // flush distance to zero at every new seen required letter\\n    for i := 0; i < lens; i++ {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        res[i] = dist\\n        dist++\\n    }\\n    \\n    // the same backwards \\n    // but also check if we have less distance from opposite letter\\n    for i := lens-1; i >=0; i-- {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        if dist < res[i] {\\n            res[i] = dist\\n        }\\n        dist++\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nleetcode\\n     ^\\n```\n```\\nl    e      e      t       c       o       d      e\\n                                   ^\\n\\t\\t    0      1       2       3       4      5\\n```\n```golang\\nfunc shortestToChar(s string, c byte) []int {\\n\\t// cache string length\\n    var lens = len(s)\\n\\t// prepare a storage for the result \\n\\t// slice (or array, vector) with length equal to len(s) initialized with zeros\\n    var res = make([]int, lens)\\n    \\n    // current distance from last seen letter `c`\\n    // we start with increadibly high value to show it\\'s invalid\\n    var dist = lens + 100\\n    \\n    // scan from left to right, increase distance from last seen letter\\n    // flush distance to zero at every new seen required letter\\n    for i := 0; i < lens; i++ {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        res[i] = dist\\n        dist++\\n    }\\n    \\n    // the same backwards \\n    // but also check if we have less distance from opposite letter\\n    for i := lens-1; i >=0; i-- {\\n        if s[i] == c {\\n            dist = 0\\n        }\\n        if dist < res[i] {\\n            res[i] = dist\\n        }\\n        dist++\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1054648,
                "title": "java-solution-linear-time",
                "content": "```\\nclass Solution \\n{\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        int l = -1;\\n        int r = s.indexOf(c);\\n        int[] ans = new int[s.length()];\\n        \\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s.charAt(i) == c )\\n            {\\n                l = r;\\n                \\n                if(s.substring(i+1).indexOf(c) == -1)\\n                    r = -1;\\n                else\\n                    r = (i+1) + s.substring(i+1).indexOf(c);\\n            }\\n            \\n            if(r == -1)\\n                ans[i] = i-l;\\n            else if(l == -1)\\n                ans[i] = r-i;\\n            else if(r != -1 && l != -1)\\n                ans[i] = Math.min(i - l , r - i);\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution \\n{\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        int l = -1;\\n        int r = s.indexOf(c);\\n        int[] ans = new int[s.length()];\\n        \\n        for(int i = 0 ; i < s.length() ; i++)\\n        {\\n            if(s.charAt(i) == c )\\n            {\\n                l = r;\\n                \\n                if(s.substring(i+1).indexOf(c) == -1)\\n                    r = -1;\\n                else\\n                    r = (i+1) + s.substring(i+1).indexOf(c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1054131,
                "title": "python-o-n-simple-easy-understanding-cool-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t\\t\\tn = lastC =len(s)\\n\\t\\t\\tans = [n] * n\\n\\t\\t\\tfor i in itertools.chain(range(n), range(n)[::-1]):\\n\\t\\t\\t\\tif s[i] == c: lastC = i\\n\\t\\t\\t\\tans[i] = min(ans[i], abs( i - lastC))\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t\\t\\tn = lastC =len(s)\\n\\t\\t\\tans = [n] * n\\n\\t\\t\\tfor i in itertools.chain(range(n), range(n)[::-1]):\\n\\t\\t\\t\\tif s[i] == c: lastC = i\\n\\t\\t\\t\\tans[i] = min(ans[i], abs( i - lastC))\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 872326,
                "title": "declarative-javascript-solution-using-array-reduce-and-array-map",
                "content": "Modern declarative JavaScript use of string destructuring and array methods.\\n\\nPlease keep in mind, this is an example of declarative JavaScript programming vs imperative solutions.\\nThe solution won\\'t be the fastest or the most memory efficient.\\n\\nHere\\'s some references if you\\'re more interested about what reduce and map can do:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map\\n\\n```\\nvar shortestToChar = function(S, C) {\\n    \\n    // We create an array of indices of where the character C occurs\\n    //\\n    // [...S] is a string destructuring, we turn the string into an array\\n    // of characters (in JavaScript, it\\'s really just single character strings)\\n    //\\n    // On this new string array, we use Array.reduce(), which is a powerful way of\\n    // exploring arrays with a callback function. The callback function in this example is\\n    // (acc, currC, ind) => currC === C ? [...acc, ind] : acc\\n    // which is stating \"for each element, take the \\'Accumulator\\', \\'Current Element\\', and \\'Index\\'\\n    // and return what our next accumulator will be\". The accumulator was initialized to be\\n    // an empty array and if the character matches, we copy our current accumulator array into\\n    // a new array and append the current Index. If it doesn\\'t match, just return our Accumulator\\n    //\\n    // The ultimate result is our accumulator, which is an array of indices.\\n    \\n    const indexesOfC = [...S].reduce(\\n        (acc, currC, currInd) => currC === C ? [...acc, currInd] : acc\\n        , [])\\n    \\n    // Here, we are mapping each character to a number. This is the perfect time\\n    // to use Array.map()! Array.map also uses a callback function, but this time it\\'s\\n    // (char, ind) => <some code returning what we want to map>\\n    // \"char\" being \"Current Element\" and \"ind\" being an optional parameter \"Current Index\"\\n    //\\n    // We then run an Array.reduce() on our indices of character C. This time the accumulator\\n    // is going to be recording the shortest distance from the current S index to the closest\\n    // C index. We return the smaller of the saved value (acc) and the distance (Math.abs(ind - curr))\\n    //\\n    // Note that the accumulator is initially set to Infinity. You can also use Number.MAX_VALUE.\\n    \\n    return [...S].map((char, ind) => \\n        indexesOfC.reduce((acc, curr) => \\n            Math.min(acc, Math.abs(ind - curr))\\n        , Infinity)\\n    )\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    \\n    // We create an array of indices of where the character C occurs\\n    //\\n    // [...S] is a string destructuring, we turn the string into an array\\n    // of characters (in JavaScript, it\\'s really just single character strings)\\n    //\\n    // On this new string array, we use Array.reduce(), which is a powerful way of\\n    // exploring arrays with a callback function. The callback function in this example is\\n    // (acc, currC, ind) => currC === C ? [...acc, ind] : acc\\n    // which is stating \"for each element, take the \\'Accumulator\\', \\'Current Element\\', and \\'Index\\'\\n    // and return what our next accumulator will be\". The accumulator was initialized to be\\n    // an empty array and if the character matches, we copy our current accumulator array into\\n    // a new array and append the current Index. If it doesn\\'t match, just return our Accumulator\\n    //\\n    // The ultimate result is our accumulator, which is an array of indices.\\n    \\n    const indexesOfC = [...S].reduce(\\n        (acc, currC, currInd) => currC === C ? [...acc, currInd] : acc\\n        , [])\\n    \\n    // Here, we are mapping each character to a number. This is the perfect time\\n    // to use Array.map()! Array.map also uses a callback function, but this time it\\'s\\n    // (char, ind) => <some code returning what we want to map>\\n    // \"char\" being \"Current Element\" and \"ind\" being an optional parameter \"Current Index\"\\n    //\\n    // We then run an Array.reduce() on our indices of character C. This time the accumulator\\n    // is going to be recording the shortest distance from the current S index to the closest\\n    // C index. We return the smaller of the saved value (acc) and the distance (Math.abs(ind - curr))\\n    //\\n    // Note that the accumulator is initially set to Infinity. You can also use Number.MAX_VALUE.\\n    \\n    return [...S].map((char, ind) => \\n        indexesOfC.reduce((acc, curr) => \\n            Math.min(acc, Math.abs(ind - curr))\\n        , Infinity)\\n    )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 605819,
                "title": "2-solutions-easy-to-understand-faster-binary-search-python-solution",
                "content": "```\\n    def using_solution_tab_solution(self, S, C):\\n        out = []\\n        prev = float(\\'inf\\')\\n        for i, v in enumerate(S):\\n            if v == C: prev = i\\n            out.append(abs(prev - i))\\n        prev = float(\\'inf\\')\\n        for i in range(len(S) -1 , -1 , -1):\\n            v = S[i]\\n            if v == C: prev = i\\n            out[i] = min(out[i], abs(prev - i))\\n        return out\\n        \\n    def using_binary_search(self, S, C):\\n        occurences = [i for i,v in enumerate(S) if v == C]\\n        out = []\\n        for i,v in enumerate(S):\\n            closest = self.find_closest(occurences, i)\\n            out.append(abs(closest - i))\\n        return out\\n      \\n    def find_closest(self, arr, target):\\n        # using binary search to find closest\\n        start, end = 0, len(arr) - 1\\n        while start < end - 1:\\n            mid = (start + end) // 2\\n            diff = arr[mid] - target\\n            if diff == 0: return arr[mid]\\n            elif diff < 0: start = mid\\n            else: end = mid\\n        # print(arr[start], arr[end])\\n        return arr[end] if abs(arr[end] - target) <= abs(arr[start] - target) else arr[start]\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n    def using_solution_tab_solution(self, S, C):\\n        out = []\\n        prev = float(\\'inf\\')\\n        for i, v in enumerate(S):\\n            if v == C: prev = i\\n            out.append(abs(prev - i))\\n        prev = float(\\'inf\\')\\n        for i in range(len(S) -1 , -1 , -1):\\n            v = S[i]\\n            if v == C: prev = i\\n            out[i] = min(out[i], abs(prev - i))\\n        return out\\n        \\n    def using_binary_search(self, S, C):\\n        occurences = [i for i,v in enumerate(S) if v == C]\\n        out = []\\n        for i,v in enumerate(S):\\n            closest = self.find_closest(occurences, i)\\n            out.append(abs(closest - i))\\n        return out\\n      \\n    def find_closest(self, arr, target):\\n        # using binary search to find closest\\n        start, end = 0, len(arr) - 1\\n        while start < end - 1:\\n            mid = (start + end) // 2\\n            diff = arr[mid] - target\\n            if diff == 0: return arr[mid]\\n            elif diff < 0: start = mid\\n            else: end = mid\\n        # print(arr[start], arr[end])\\n        return arr[end] if abs(arr[end] - target) <= abs(arr[start] - target) else arr[start]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 465841,
                "title": "javascript-solution",
                "content": "Probably not the best solution but it\\'s straightforward and works \\n\\nSteps:\\n- initialize an array \\n- Loop through the string\\n- find the closest character C with a helper function \\n\\n- at each letter, calculate and return the distance of the closest C \\n- push that value distance to the array \\n\\n\\n```\\nvar shortestToChar = function(S, C) {\\n    let arr = []\\n    for (let i = 0; i < S.length; i++) {\\n        // should return i of the closest character\\n        let closest = findClosest(i, S, C); \\n        \\n        // add to array \\n        arr.push(closest)\\n    }\\n    return arr\\n};\\n\\nvar findClosest = function(i, S, C) {\\n    if (S[i] === C) return 0\\n    \\n    let j = 1\\n\\t// set limits for beginning and end of S string\\n    while (i >= 0 || i <= S.length) {\\n\\t\\t// checks the character in either direction by j units\\n        if (S[i + j] === C || S[i - j] === C) {\\n            return j;\\n        }\\n        j++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(S, C) {\\n    let arr = []\\n    for (let i = 0; i < S.length; i++) {\\n        // should return i of the closest character\\n        let closest = findClosest(i, S, C); \\n        \\n        // add to array \\n        arr.push(closest)\\n    }\\n    return arr\\n};\\n\\nvar findClosest = function(i, S, C) {\\n    if (S[i] === C) return 0\\n    \\n    let j = 1\\n\\t// set limits for beginning and end of S string\\n    while (i >= 0 || i <= S.length) {\\n\\t\\t// checks the character in either direction by j units\\n        if (S[i + j] === C || S[i - j] === C) {\\n            return j;\\n        }\\n        j++;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444317,
                "title": "python-with-comments",
                "content": "\\'\\'\\'\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n\\n        res = []\\n        pos = [] \\n        \\n        # keep indexes of C in S\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                pos.append(i)                \\n        \\n        for i in range(len(S)):\\n            # set default value as length of S\\n\\t\\t\\tmn = len(S) \\n            for p in pos:                \\n                # calculate minimum value of distance\\n\\t\\t\\t\\tmn = min(mn, abs(i-p)) \\n            res.append(mn)\\n        return res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n\\n        res = []\\n        pos = [] \\n        \\n        # keep indexes of C in S\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                pos.append(i)                \\n        \\n        for i in range(len(S)):\\n            # set default value as length of S\\n\\t\\t\\tmn = len(S) \\n            for p in pos:                \\n                # calculate minimum value of distance\\n\\t\\t\\t\\tmn = min(mn, abs(i-p)) \\n            res.append(mn)\\n        return res\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 125798,
                "title": "c-simplest-solution-o-n",
                "content": "    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length(), loc = -1;\\n        vector<int> result(len, INT_MAX);\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], loc != -1 ? abs(i - loc) : INT_MAX);\\n        }\\n        \\n        for(int i = len - 1; i >= 0; i--) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], abs(i - loc));\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> shortestToChar(string S, char C) {\\n        int len = S.length(), loc = -1;\\n        vector<int> result(len, INT_MAX);\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], loc != -1 ? abs(i - loc) : INT_MAX);\\n        }\\n        \\n        for(int i = len - 1; i >= 0; i--) {\\n            if(S[i] == C) loc = i;\\n            result[i] = min(result[i], abs(i - loc));\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3590757,
                "title": "very-easy-to-understand",
                "content": "# PLEASE UPVOTE IF YOU ANYWAY LIKE IT\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>left(s.size(),-1);\\n        int j=0;\\n        int flag=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                left[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                left[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                left[i]=j++;\\n            }\\n        }\\n        vector<int>right(s.size(),-1);\\n        j=0;\\n        flag=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                right[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                right[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                right[i]=j++;\\n            }\\n        }\\n        vector<int>hny;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(left[i]>=0 && right[i]>=0)\\n            {\\n                hny.push_back(min(left[i],right[i]));\\n            }\\n            else \\n              hny.push_back(max(left[i],right[i]));\\n        }\\n        return hny;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>left(s.size(),-1);\\n        int j=0;\\n        int flag=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                left[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                left[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                left[i]=j++;\\n            }\\n        }\\n        vector<int>right(s.size(),-1);\\n        j=0;\\n        flag=0;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(s[i]==c && flag==1)\\n            {\\n                right[i]=0;\\n                j=0;\\n            }\\n            if(s[i]==c)\\n            {\\n                right[i]=0;\\n                j=1;\\n                flag=1;\\n            }\\n            else if(s[i]!=c && flag==1)\\n            {\\n                right[i]=j++;\\n            }\\n        }\\n        vector<int>hny;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(left[i]>=0 && right[i]>=0)\\n            {\\n                hny.push_back(min(left[i],right[i]));\\n            }\\n            else \\n              hny.push_back(max(left[i],right[i]));\\n        }\\n        return hny;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481559,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n\\tvector<int>v;\\n\\tfor (int i = 0;i < n;i++) {\\n\\t\\tint distance = 0;\\n\\t\\tfor (int j = i, k = i;j < n || k >= 0;j++, k--) {\\n\\t\\t\\tif ((k >= 0 && s[k] == c) || (j < n && s[j] == c )) {\\n\\t\\t\\t\\tv.push_back(distance);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdistance++;\\n\\t\\t}\\n\\n\\t}\\n\\treturn v;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        n=len(s)\\n        arr=[i for i in range(n) if s[i]==c]\\n        arr1=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                arr1.append(0)\\n                j=j+1\\n            elif i<arr[0]:\\n                arr1.append(arr[0]-i)\\n            elif i>arr[-1]:\\n                arr1.append(i-arr[-1])\\n            else:\\n                arr1.append(min(arr[j]-i,i-arr[j-1]))\\n        return arr1\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        int currentIndex = -1; \\n        int leftIndex = findNextOccurance(s, -1, c);\\n        fillCreek(result, -leftIndex, leftIndex);\\n        while(true){\\n            int rightIndex = findNextOccurance( s, leftIndex, c);\\n            if( rightIndex == -1){\\n                fillCreek( result, leftIndex, s.length() + ( s.length()-1-leftIndex ));\\n                break;\\n            }\\n            fillCreek(result, leftIndex, rightIndex);\\n            leftIndex = rightIndex; \\n        }\\n        return result;\\n    }\\n    public int findNextOccurance(String s, int fromIndex, char c){\\n        for( int i = fromIndex+1; i< s.length(); i++){\\n            if( s.charAt(i) == c ) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public void fillCreek(int[] result, int leftIndex, int rightIndex){\\n        int from = Math.max( leftIndex, 0);\\n        int to = Math.min( rightIndex, result.length-1);\\n        for( int i = from ; i<= to; i++){\\n            result[i] = Math.min( i - leftIndex ,  rightIndex - i  );\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n\\tvector<int>v;\\n\\tfor (int i = 0;i < n;i++) {\\n\\t\\tint distance = 0;\\n\\t\\tfor (int j = i, k = i;j < n || k >= 0;j++, k--) {\\n\\t\\t\\tif ((k >= 0 && s[k] == c) || (j < n && s[j] == c )) {\\n\\t\\t\\t\\tv.push_back(distance);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tdistance++;\\n\\t\\t}\\n\\n\\t}\\n\\treturn v;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        n=len(s)\\n        arr=[i for i in range(n) if s[i]==c]\\n        arr1=[]\\n        j=0\\n        for i in range(n):\\n            if s[i]==c:\\n                arr1.append(0)\\n                j=j+1\\n            elif i<arr[0]:\\n                arr1.append(arr[0]-i)\\n            elif i>arr[-1]:\\n                arr1.append(i-arr[-1])\\n            else:\\n                arr1.append(min(arr[j]-i,i-arr[j-1]))\\n        return arr1\\n```\n```Java []\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        int currentIndex = -1; \\n        int leftIndex = findNextOccurance(s, -1, c);\\n        fillCreek(result, -leftIndex, leftIndex);\\n        while(true){\\n            int rightIndex = findNextOccurance( s, leftIndex, c);\\n            if( rightIndex == -1){\\n                fillCreek( result, leftIndex, s.length() + ( s.length()-1-leftIndex ));\\n                break;\\n            }\\n            fillCreek(result, leftIndex, rightIndex);\\n            leftIndex = rightIndex; \\n        }\\n        return result;\\n    }\\n    public int findNextOccurance(String s, int fromIndex, char c){\\n        for( int i = fromIndex+1; i< s.length(); i++){\\n            if( s.charAt(i) == c ) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public void fillCreek(int[] result, int leftIndex, int rightIndex){\\n        int from = Math.max( leftIndex, 0);\\n        int to = Math.min( rightIndex, result.length-1);\\n        for( int i = from ; i<= to; i++){\\n            result[i] = Math.min( i - leftIndex ,  rightIndex - i  );\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287751,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int>ans;\\n        vector<int>temp;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==c)\\n            temp.push_back(i);\\n        }\\n        int ind1=0;\\n        int n=temp.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if(ind1==n-1)\\n            {\\n                ans.push_back(abs(i-temp[ind1]));\\n            }\\n            else{\\n                if (abs(i-temp[ind1])>abs(i-temp[ind1+1]))\\n                {\\n                    ind1++;\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n                else{\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int>ans;\\n        vector<int>temp;\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if (s[i]==c)\\n            temp.push_back(i);\\n        }\\n        int ind1=0;\\n        int n=temp.size();\\n        for (int i=0;i<s.size();i++)\\n        {\\n            if(ind1==n-1)\\n            {\\n                ans.push_back(abs(i-temp[ind1]));\\n            }\\n            else{\\n                if (abs(i-temp[ind1])>abs(i-temp[ind1+1]))\\n                {\\n                    ind1++;\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n                else{\\n                    ans.push_back(abs(i-temp[ind1]));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103959,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n      vector<int>ind;\\n      vector<int>ans;\\n      for(int i=0;i<s.size();i++)  {\\n          if(s[i]==c)ind.push_back(i);\\n      }\\n      \\n      for(int i=0;i<s.size();i++){\\n          int d=100000;\\n          for(int j=0;j<ind.size();j++){\\n          int d2 = abs(i-ind[j]);\\n           if(d2<d)d=d2;\\n          }                  \\n          ans.push_back(d);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n      vector<int>ind;\\n      vector<int>ans;\\n      for(int i=0;i<s.size();i++)  {\\n          if(s[i]==c)ind.push_back(i);\\n      }\\n      \\n      for(int i=0;i<s.size();i++){\\n          int d=100000;\\n          for(int j=0;j<ind.size();j++){\\n          int d2 = abs(i-ind[j]);\\n           if(d2<d)d=d2;\\n          }                  \\n          ans.push_back(d);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091201,
                "title": "c-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>ispresent;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)ispresent.push_back(i);\\n        }\\n        vector<int>ans(s.length());\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                ans[i]=0;\\n            }\\n            else{\\n                int val=INT_MAX;\\n                for(int k=0;k<ispresent.size();k++){\\n                    val=min(val,abs(i-ispresent[k]));\\n                }\\n                ans[i]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>ispresent;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)ispresent.push_back(i);\\n        }\\n        vector<int>ans(s.length());\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c){\\n                ans[i]=0;\\n            }\\n            else{\\n                int val=INT_MAX;\\n                for(int k=0;k<ispresent.size();k++){\\n                    val=min(val,abs(i-ispresent[k]));\\n                }\\n                ans[i]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747153,
                "title": "runs-100-faster-cpp-soln-o-n",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(s.size());\\n        int last = -n ;\\n       for(int i = 0 ; i < n ;i++){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(i-last);\\n       }\\n        for(int i = n-1 ; i >= 0 ;i--){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(min(abs(last-i) , ans[i]));\\n       }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(s.size());\\n        int last = -n ;\\n       for(int i = 0 ; i < n ;i++){\\n           if(s[i]==c)\\n               last= i ; \\n           \\n           ans[i]=(i-last);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2566014,
                "title": "c-fast-and-easy-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int fdist=INT_MAX,bdist=INT_MAX;\\n        vector<int>ans(s.size(),INT_MAX);\\n       for(int i=0,j=s.size()-1;i<s.size();++i,--j)\\n       {\\n           if(s[i]==c) fdist=0;\\n           if(s[j]==c) bdist=0;\\n           \\n           ans[i]=min(fdist,ans[i]);\\n           ans[j]=min(bdist,ans[j]);\\n           \\n           if(fdist!=INT_MAX) fdist++;\\n           if(bdist!=INT_MAX) bdist++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int fdist=INT_MAX,bdist=INT_MAX;\\n        vector<int>ans(s.size(),INT_MAX);\\n       for(int i=0,j=s.size()-1;i<s.size();++i,--j)\\n       {\\n           if(s[i]==c) fdist=0;\\n           if(s[j]==c) bdist=0;\\n           \\n           ans[i]=min(fdist,ans[i]);\\n           ans[j]=min(bdist,ans[j]);\\n           \\n           if(fdist!=INT_MAX) fdist++;\\n           if(bdist!=INT_MAX) bdist++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552819,
                "title": "js-easy-solution-100",
                "content": "```\\nvar shortestToChar = function(s, c) {\\n    const indexOfC = [];\\n    const output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) {\\n            indexOfC.push(i)\\n        }\\n    }\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        output[i] = +Infinity;\\n        for (let j = 0; j < indexOfC.length; j++) {\\n            if (i === indexOfC[j]) {\\n                output[i] = 0;\\n                break;\\n            } else {\\n                if (Math.abs(indexOfC[j] - i) > output[i]) break;\\n                output[i] = Math.min(output[i], Math.abs(indexOfC[j] - i));\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(s, c) {\\n    const indexOfC = [];\\n    const output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === c) {\\n            indexOfC.push(i)\\n        }\\n    }\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        output[i] = +Infinity;\\n        for (let j = 0; j < indexOfC.length; j++) {\\n            if (i === indexOfC[j]) {\\n                output[i] = 0;\\n                break;\\n            } else {\\n                if (Math.abs(indexOfC[j] - i) > output[i]) break;\\n                output[i] = Math.min(output[i], Math.abs(indexOfC[j] - i));\\n            }\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394618,
                "title": "easiest-approach-5-ms-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>sk;\\n        vector<int>res;\\n        vector<int>temp;\\n        int ss=0;\\n        int mins;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)\\n\\t\\t\\t//storing all the c character location i.e \\'e\\' in sk i.e [3,5,6,11]\\n             sk.push_back(i);\\n        }\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<sk.size();j++){\\n\\t\\t\\t//now subtracting every i value with all value of character locations and storing the minimum in res vector.\\n\\t\\t\\n                mins=abs(sk[j]-i);\\n                temp.push_back(mins);\\n            }\\n\\t\\t\\t\\t//in first iteration [3-0=3,5-0=5,6-0=6,11-0=0] so removing the minimum elemnet from this that is 3 and stroing is res.\\n            int min=temp[0];\\n            for(auto i:temp){\\n                if(i<min){\\n                    min=i;\\n                }\\n            }\\n            res.push_back(min);\\n            temp.clear();\\n        \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>sk;\\n        vector<int>res;\\n        vector<int>temp;\\n        int ss=0;\\n        int mins;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==c)\\n\\t\\t\\t//storing all the c character location i.e \\'e\\' in sk i.e [3,5,6,11]\\n             sk.push_back(i);\\n        }\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<sk.size();j++){\\n\\t\\t\\t//now subtracting every i value with all value of character locations and storing the minimum in res vector.\\n\\t\\t\\n                mins=abs(sk[j]-i);\\n                temp.push_back(mins);\\n            }\\n\\t\\t\\t\\t//in first iteration [3-0=3,5-0=5,6-0=6,11-0=0] so removing the minimum elemnet from this that is 3 and stroing is res.\\n            int min=temp[0];\\n            for(auto i:temp){\\n                if(i<min){\\n                    min=i;\\n                }\\n            }\\n            res.push_back(min);\\n            temp.clear();\\n        \\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281644,
                "title": "c-o-n-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int a=s.length();\\n        int arr1[a];\\n        int arr2[a];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr1[i]=100000;\\n            arr2[i]=100000;\\n        }\\n        int occur1;\\n        int flag1=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr1[i]=0;\\n                flag1=1;\\n                occur1=i;\\n            }\\n            if (flag1==1)\\n            {\\n                arr1[i]=i-occur1;\\n            }\\n        }\\n        int occur2;\\n        int flag2=0;\\n        for(int i=a-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr2[i]=0;\\n                flag2=1;\\n                occur2=i;\\n            }\\n            if (flag2==1)\\n            {\\n                arr2[i]=occur2-i;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int mele=min(arr1[i],arr2[i]);\\n            ans.push_back(mele);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int a=s.length();\\n        int arr1[a];\\n        int arr2[a];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr1[i]=100000;\\n            arr2[i]=100000;\\n        }\\n        int occur1;\\n        int flag1=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr1[i]=0;\\n                flag1=1;\\n                occur1=i;\\n            }\\n            if (flag1==1)\\n            {\\n                arr1[i]=i-occur1;\\n            }\\n        }\\n        int occur2;\\n        int flag2=0;\\n        for(int i=a-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n            {\\n                arr2[i]=0;\\n                flag2=1;\\n                occur2=i;\\n            }\\n            if (flag2==1)\\n            {\\n                arr2[i]=occur2-i;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int mele=min(arr1[i],arr2[i]);\\n            ans.push_back(mele);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183851,
                "title": "python3-o-n-o-n-runtime-53ms-78-92-memory-13-9mb-91-60",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, string: str, char: str) -> List[int]:\\n        return self.optimalSolution(string, char)\\n#     O(n) || O(n)\\n# Runtime: 53ms 78.92% Memory: 13.9mb 91.60%\\n    def optimalSolution(self, string, char):\\n        n = len(string)\\n        leftArray, rightArray, result = ([float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n)\\n        temp = float(\\'inf\\')\\n        for i in range(len(string)):\\n            if string[i] == char:\\n                temp = 0\\n            leftArray[i] = temp\\n            temp += 1\\n\\n        temp = float(\\'inf\\')\\n        for i in reversed(range(len(string))):\\n            if string[i] == char:\\n                temp = 0\\n            rightArray[i] = temp\\n            temp += 1\\n\\n\\n        for i in range(len(result)):\\n            result[i] = min(leftArray[i], rightArray[i])\\n\\n        return result\\n\\n    \\n#     O(n^2) || O(n) Runtime: TLE\\n    def bruteForce(self, string, char):\\n        sequence = [float(\\'inf\\')] * len(string)\\n        newList = []\\n        for idx, val in enumerate(string):\\n            if val == char:\\n                newList.append(idx)\\n\\n        for val1 in newList:\\n            for idx2, val2 in enumerate(string):\\n                sequence[idx2] = min(sequence[idx2], abs(idx2-val1))\\n\\n        return sequence\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, string: str, char: str) -> List[int]:\\n        return self.optimalSolution(string, char)\\n#     O(n) || O(n)\\n# Runtime: 53ms 78.92% Memory: 13.9mb 91.60%\\n    def optimalSolution(self, string, char):\\n        n = len(string)\\n        leftArray, rightArray, result = ([float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n, \\n                                         [float(\\'inf\\')] * n)\\n        temp = float(\\'inf\\')\\n        for i in range(len(string)):\\n            if string[i] == char:\\n                temp = 0\\n            leftArray[i] = temp\\n            temp += 1\\n\\n        temp = float(\\'inf\\')\\n        for i in reversed(range(len(string))):\\n            if string[i] == char:\\n                temp = 0\\n            rightArray[i] = temp\\n            temp += 1\\n\\n\\n        for i in range(len(result)):\\n            result[i] = min(leftArray[i], rightArray[i])\\n\\n        return result\\n\\n    \\n#     O(n^2) || O(n) Runtime: TLE\\n    def bruteForce(self, string, char):\\n        sequence = [float(\\'inf\\')] * len(string)\\n        newList = []\\n        for idx, val in enumerate(string):\\n            if val == char:\\n                newList.append(idx)\\n\\n        for val1 in newList:\\n            for idx2, val2 in enumerate(string):\\n                sequence[idx2] = min(sequence[idx2], abs(idx2-val1))\\n\\n        return sequence\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094832,
                "title": "nice-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ans;\\n        int n = s.size();\\n        for(int i=0;i<n;++i){\\n            if(s[i]==c){\\n                ans.push_back(0);\\n            }\\n            else{\\n                int st = i;\\n                int en = i;\\n                bool find1=false,find2=false;\\n                while(st>=0){\\n                    if(s[st]==c){\\n                        find1 = true;\\n                        break;\\n                    }\\n                    st--;\\n                }\\n                while(en<n){\\n                    if(s[en]==c){\\n                        find2 = true;\\n                        break;\\n                    }\\n                    en++;\\n                }\\n                if(find1 && find2){\\n                    ans.push_back(min(en-i,i-st));                    \\n                }else if(find1){\\n                    ans.push_back(i-st);\\n                }else{\\n                    ans.push_back(en-i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> ans;\\n        int n = s.size();\\n        for(int i=0;i<n;++i){\\n            if(s[i]==c){\\n                ans.push_back(0);\\n            }\\n            else{\\n                int st = i;\\n                int en = i;\\n                bool find1=false,find2=false;\\n                while(st>=0){\\n                    if(s[st]==c){\\n                        find1 = true;\\n                        break;\\n                    }\\n                    st--;\\n                }\\n                while(en<n){\\n                    if(s[en]==c){\\n                        find2 = true;\\n                        break;\\n                    }\\n                    en++;\\n                }\\n                if(find1 && find2){\\n                    ans.push_back(min(en-i,i-st));                    \\n                }else if(find1){\\n                    ans.push_back(i-st);\\n                }else{\\n                    ans.push_back(en-i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984164,
                "title": "shortest-distance-to-a-character",
                "content": "```\\nvector<int> shortestToChar(string s, char c) {\\n        vector<int> index;\\n        vector<int> ans;\\n        int k1 = 0, k2 = 1;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        index.push_back(INT_MAX);\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(i > index[k2])\\n            {\\n                k1++;\\n                k2++;\\n            }\\n            ans.push_back(min(abs(index[k1]-i),abs(index[k2]-i)));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> shortestToChar(string s, char c) {\\n        vector<int> index;\\n        vector<int> ans;\\n        int k1 = 0, k2 = 1;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        index.push_back(INT_MAX);\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(i > index[k2])\\n            {\\n                k1++;\\n                k2++;\\n            }\\n            ans.push_back(min(abs(index[k1]-i),abs(index[k2]-i)));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1738902,
                "title": "easy-to-understand-java-code",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int min=Integer.MAX_VALUE;\\n        int[] array=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<s.length();j++){\\n                if(s.charAt(j)==c){\\n                    min=Math.min(min,Math.abs(i-j));\\n                }   \\n            }\\n            array[i]=min;\\n            min=Integer.MAX_VALUE;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int min=Integer.MAX_VALUE;\\n        int[] array=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            for(int j=0;j<s.length();j++){\\n                if(s.charAt(j)==c){\\n                    min=Math.min(min,Math.abs(i-j));\\n                }   \\n            }\\n            array[i]=min;\\n            min=Integer.MAX_VALUE;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718249,
                "title": "beats-100-runtime-optimal-2-pass-in-python",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        #Time: O(n)\\n        #Space: O(n)\\n        \\n        #Represents how far a character is away from c (x = inf)\\n        #loveleetcode\\n        #xxx010012340 - first pass\\n        #321010043210 - second pass\\n        #321010012210 - answer (take min of both first and second pass)\\n        \\n        answer = [float(\\'inf\\') for _ in range(len(s))]\\n        \\n        counter = float(\\'inf\\')\\n        for idx in range(len(s)):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n                \\n            answer[idx] = min(answer[idx], counter)\\n        \\n        counter = float(\\'inf\\')\\n        for idx in reversed(range(len(s))):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n            \\n            answer[idx] = min(answer[idx], counter)\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        #Time: O(n)\\n        #Space: O(n)\\n        \\n        #Represents how far a character is away from c (x = inf)\\n        #loveleetcode\\n        #xxx010012340 - first pass\\n        #321010043210 - second pass\\n        #321010012210 - answer (take min of both first and second pass)\\n        \\n        answer = [float(\\'inf\\') for _ in range(len(s))]\\n        \\n        counter = float(\\'inf\\')\\n        for idx in range(len(s)):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n                \\n            answer[idx] = min(answer[idx], counter)\\n        \\n        counter = float(\\'inf\\')\\n        for idx in reversed(range(len(s))):\\n            #Run into a C -> reset our counter\\n            if s[idx] == c:\\n                counter = 0\\n            #Run into something else -> increment our counter and assign the count to answer\\n            else:\\n                counter += 1\\n            \\n            answer[idx] = min(answer[idx], counter)\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505571,
                "title": "easy-solution-using-c",
                "content": "# vector<int> shortestToChar(string s, char c) {\\n        vector<int> v;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == c)\\n                v.push_back(i);\\n        }\\n\\n        vector<int> result;\\n        int index, diff;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            index = INT_MAX;\\n            for (int j = 0; j < v.size(); j++)\\n            {\\n                diff = abs(i - v[j]);\\n                index = min(index, diff);\\n            }\\n            result.push_back(index);\\n        }\\n\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "# vector<int> shortestToChar(string s, char c) {\\n        vector<int> v;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (s[i] == c)\\n                v.push_back(i);\\n        }\\n\\n        vector<int> result;\\n        int index, diff;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            index = INT_MAX;\\n            for (int j = 0; j < v.size(); j++)\\n            {\\n                diff = abs(i - v[j]);\\n                index = min(index, diff);\\n            }\\n            result.push_back(index);\\n        }\\n\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1262329,
                "title": "easy-to-understand-o-n-c-java",
                "content": "Implementation\\n\\n**1st Approach in C++**\\nTime Complexity = O(N), Space Complexity = O(N)\\n\\n```\\nvector<int> shortestToChar(string s, char c) {\\n    vector<int> vec, res;\\n    for(int itr = 0; itr < s.size(); itr++){\\n        if(s[itr] == c) vec.push_back(itr);\\n    }\\n    \\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.size(); itr++){\\n        if(vec[jtr] >= itr || jtr+1 == vec.size()) res.push_back(abs(vec[jtr]-itr));\\n        else{\\n            dif1 = abs(vec[jtr+1]-itr);\\n            dif2 = abs(vec[jtr]-itr);\\n            if(dif1 <= dif2){\\n                res.push_back(dif1);\\n                jtr++;\\n            }\\n            else res.push_back(dif2);\\n        }\\n    }\\n    return res;        \\n}\\n```\\n\\n\\n**2nd Approach in Java**\\nTime Complexity = O(N), Space Complexity = O(N)\\n\\n```\\npublic int[] shortestToChar(String s, char c) {\\n    ArrayList<Integer> arr = new ArrayList<Integer>();        \\n    for(int itr = 0; itr < s.length(); itr++){\\n        if(s.charAt(itr) == c) arr.add(itr);\\n    }\\n\\t\\n    int[] res = new int[s.length()];\\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.length(); itr++){\\n        if(arr.get(jtr) >= itr || jtr+1 == arr.size()) res[itr] = Math.abs(arr.get(jtr)-itr);\\n        else{                \\n            dif1 = Math.abs(arr.get(jtr+1)-itr);\\n            dif2 = Math.abs(arr.get(jtr)-itr);\\n            if(dif1 <= dif2){\\n                res[itr] = dif1;\\n                jtr++;\\n            }\\n            else res[itr] = dif2;\\n        }\\n    }\\n    return res; \\n}\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nvector<int> shortestToChar(string s, char c) {\\n    vector<int> vec, res;\\n    for(int itr = 0; itr < s.size(); itr++){\\n        if(s[itr] == c) vec.push_back(itr);\\n    }\\n    \\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.size(); itr++){\\n        if(vec[jtr] >= itr || jtr+1 == vec.size()) res.push_back(abs(vec[jtr]-itr));\\n        else{\\n            dif1 = abs(vec[jtr+1]-itr);\\n            dif2 = abs(vec[jtr]-itr);\\n            if(dif1 <= dif2){\\n                res.push_back(dif1);\\n                jtr++;\\n            }\\n            else res.push_back(dif2);\\n        }\\n    }\\n    return res;        \\n}\\n```\n```\\npublic int[] shortestToChar(String s, char c) {\\n    ArrayList<Integer> arr = new ArrayList<Integer>();        \\n    for(int itr = 0; itr < s.length(); itr++){\\n        if(s.charAt(itr) == c) arr.add(itr);\\n    }\\n\\t\\n    int[] res = new int[s.length()];\\n    int dif1 = 0, dif2 = 0;    \\n    for(int jtr = 0, itr = 0; itr < s.length(); itr++){\\n        if(arr.get(jtr) >= itr || jtr+1 == arr.size()) res[itr] = Math.abs(arr.get(jtr)-itr);\\n        else{                \\n            dif1 = Math.abs(arr.get(jtr+1)-itr);\\n            dif2 = Math.abs(arr.get(jtr)-itr);\\n            if(dif1 <= dif2){\\n                res[itr] = dif1;\\n                jtr++;\\n            }\\n            else res[itr] = dif2;\\n        }\\n    }\\n    return res; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063474,
                "title": "c-simplest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n,0);\\n        int prev = -1;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = i - prev; \\n            else\\n                ans[i] = INT_MAX;\\n        }\\n        prev = -1;\\n        for(int i = n-1; i>=0; i--){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = min(ans[i],prev - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n,0);\\n        int prev = -1;\\n        for(int i = 0; i<n; i++){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = i - prev; \\n            else\\n                ans[i] = INT_MAX;\\n        }\\n        prev = -1;\\n        for(int i = n-1; i>=0; i--){\\n            if(s[i] == c)\\n                prev = i;\\n            if(prev!=-1)\\n                ans[i] = min(ans[i],prev - i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054837,
                "title": "easier-to-understand-python-solution",
                "content": "idea is to traverse from left to right and check the distance of character c and in second iteration we traverse from right to left and update the min(right side,  left side)\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n```\\ndef shortestToChar(self, s, c):\\n        \"\"\"\\n        :type s: str\\n        :type c: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [float(\\'inf\\')] * (len(s))\\n        last = float(\\'inf\\')\\n        for i, v in enumerate(s):\\n            if v ==c:\\n                res[i] = 0\\n                last = 0\\n            else:\\n                if last != float(\\'inf\\'):\\n                    res[i] = last+1\\n                    last = res[i]\\n        last = float(\\'inf\\')                    \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == e:\\n                last = res[i]\\n            elif i+1<len(s):\\n                last = res[i+1]+1\\n            res[i] = min(last, res[i])\\n        return res    \\n```",
                "solutionTags": [],
                "code": "```\\ndef shortestToChar(self, s, c):\\n        \"\"\"\\n        :type s: str\\n        :type c: str\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [float(\\'inf\\')] * (len(s))\\n        last = float(\\'inf\\')\\n        for i, v in enumerate(s):\\n            if v ==c:\\n                res[i] = 0\\n                last = 0\\n            else:\\n                if last != float(\\'inf\\'):\\n                    res[i] = last+1\\n                    last = res[i]\\n        last = float(\\'inf\\')                    \\n        for i in range(len(s)-1, -1, -1):\\n            if s[i] == e:\\n                last = res[i]\\n            elif i+1<len(s):\\n                last = res[i+1]+1\\n            res[i] = min(last, res[i])\\n        return res    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1054586,
                "title": "shortest-distance-to-character-c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx) {\\n                    dist = min(dist, abs(d - i));\\n                }\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx) {\\n                    dist = min(dist, abs(d - i));\\n                }\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054571,
                "title": "c-solution",
                "content": "```public class Solution {\\n    public int[] ShortestToChar(string s, char c) {\\n\\n        int sLength = s.Length;\\n        int[] res = new int[sLength];\\n        int distLeft = -1, distRight = -1;\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            res[i] = Int32.MaxValue;\\n        }\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                res[i] = 0;\\n                distLeft = i;\\n            }\\n            else\\n            {\\n                if (distLeft != -1 && Math.Abs(i - distLeft) < res[i])\\n                    res[i] = Math.Abs(i - distLeft);\\n            }\\n            \\n            int j = sLength - i - 1;\\n            if (s[j] == c)\\n            {\\n                res[j] = 0;\\n                distRight = j;\\n            }\\n            else\\n            {\\n                if (distRight != -1 && Math.Abs(j - distRight) < res[j])\\n                    res[j] = Math.Abs(j - distRight);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] ShortestToChar(string s, char c) {\\n\\n        int sLength = s.Length;\\n        int[] res = new int[sLength];\\n        int distLeft = -1, distRight = -1;\\n        \\n        for (int i = 0; i < sLength; i++)\\n        {\\n            res[i] = Int32.MaxValue;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1054128,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    \\n    public int closest(int elem, List<Integer> list)\\n    {\\n        if(elem<=list.get(0))\\n        {\\n            return Math.abs(list.get(0)-elem);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<list.size();i++)\\n        {\\n            int diff = Math.abs(list.get(i)-elem);\\n            if(min>diff)\\n            {\\n                min = diff;\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    public int[] shortestToChar(String s, char c) {\\n        // storing the index of c character in a list\\n        List<Integer> list =  new ArrayList<>();\\n        int[] res = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                res[i] = 0;\\n            else\\n            {\\n                // finding the nearest distance\\n                int k = closest(i, list);\\n                res[i] = k;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int closest(int elem, List<Integer> list)\\n    {\\n        if(elem<=list.get(0))\\n        {\\n            return Math.abs(list.get(0)-elem);\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<list.size();i++)\\n        {\\n            int diff = Math.abs(list.get(i)-elem);\\n            if(min>diff)\\n            {\\n                min = diff;\\n            }\\n        }\\n        return min;\\n    }\\n    \\n    public int[] shortestToChar(String s, char c) {\\n        // storing the index of c character in a list\\n        List<Integer> list =  new ArrayList<>();\\n        int[] res = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s.charAt(i)==c)\\n                res[i] = 0;\\n            else\\n            {\\n                // finding the nearest distance\\n                int k = closest(i, list);\\n                res[i] = k;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989004,
                "title": "easy-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n=s.size();\\n        vector<int>res(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            if(s[i]==c){\\n                res[i]=0;\\n                for(int j=i-1,k=1;j>=0;j--,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n                for(int j=i+1,k=1;j<n;j++,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n=s.size();\\n        vector<int>res(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            if(s[i]==c){\\n                res[i]=0;\\n                for(int j=i-1,k=1;j>=0;j--,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n                for(int j=i+1,k=1;j<n;j++,k++){\\n                    if(k<res[j])res[j]=k;\\n                    else break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922852,
                "title": "c-easy-100-memory",
                "content": "to solve this problem we need to do the following :\\n1. Store all the positions of C in string S\\n2. Find the min distance between any letter to C\\n```\\nvector<int> shortestToChar(string S, char C) {\\n        vector<int> pos, dist;\\n\\t\\t//storeing all positions of C\\n        for(int i=0; i<S.size(); i++){\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n\\t\\t//finding min distance\\n        for(int i=0; i<S.size(); i++){\\n            int mn=INT_MAX;\\n            for(int j=0; j<pos.size(); j++){\\n                mn = min(mn, abs(pos[j]-i));\\n            }\\n            dist.push_back(mn);\\n        }\\n        return dist;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "to solve this problem we need to do the following :\\n1. Store all the positions of C in string S\\n2. Find the min distance between any letter to C\\n```\\nvector<int> shortestToChar(string S, char C) {\\n        vector<int> pos, dist;\\n\\t\\t//storeing all positions of C\\n        for(int i=0; i<S.size(); i++){\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n\\t\\t//finding min distance\\n        for(int i=0; i<S.size(); i++){\\n            int mn=INT_MAX;\\n            for(int j=0; j<pos.size(); j++){\\n                mn = min(mn, abs(pos[j]-i));\\n            }\\n            dist.push_back(mn);\\n        }\\n        return dist;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 728595,
                "title": "sharing-most-elegant-cpp-solution-12-ms",
                "content": "```\\nvector<int> shortestToChar(string S, char C) {\\n        set<int>s; int currentMin(INT_MAX);vector<int>ans{};\\n        for(int i=0;i<S.length();i++) if(S[i]==C) s.insert(i);\\n        for(int i=0;i<S.length();i++){\\n            for(auto x:s){\\n                if(abs(i-x)<currentMin) currentMin=abs(i-x);\\n            }\\n            ans.push_back(currentMin);\\n            currentMin=INT_MAX;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> shortestToChar(string S, char C) {\\n        set<int>s; int currentMin(INT_MAX);vector<int>ans{};\\n        for(int i=0;i<S.length();i++) if(S[i]==C) s.insert(i);\\n        for(int i=0;i<S.length();i++){\\n            for(auto x:s){\\n                if(abs(i-x)<currentMin) currentMin=abs(i-x);\\n            }\\n            ans.push_back(currentMin);\\n            currentMin=INT_MAX;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 619508,
                "title": "rust-100-with-iterators",
                "content": "```\\nimpl Solution {\\n    pub fn shortest_to_char(s: String, c: char) -> Vec<i32> {\\n        (0..s.len()).map(|i| {\\n            let left = s[0..i+1].chars().rev().position(|k| k == c).unwrap_or(99999usize);\\n            let right = s[i..].find(c).unwrap_or(99999usize);\\n            (if left < right {left} else {right}) as i32\\n        })\\n        .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn shortest_to_char(s: String, c: char) -> Vec<i32> {\\n        (0..s.len()).map(|i| {\\n            let left = s[0..i+1].chars().rev().position(|k| k == c).unwrap_or(99999usize);\\n            let right = s[i..].find(c).unwrap_or(99999usize);\\n            (if left < right {left} else {right}) as i32\\n        })\\n        .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 604194,
                "title": "c-beats-all",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char c) {\\n        vector<int> v;\\n        auto f = find(S.begin(),S.end(),c);\\n        auto i = S.begin();\\n        while(i!=f+1 && i!=S.end())\\n        {\\n            v.push_back(abs(i-f));\\n            i++;\\n        }\\n        auto fe = find(f+1,S.end(),c);\\n        while(i!=S.end())\\n        {\\n            if(*i==c)\\n            {\\n                v.push_back(0);\\n                f = i;\\n                fe = find(f+1,S.end(),c);\\n                i++;\\n            }\\n            else\\n            {\\n                if(fe!=S.end())\\n                    v.push_back(min(abs(fe-i),abs(f-i)));\\n                else\\n                    v.push_back(abs(f-i));\\n                i++;\\n            }\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char c) {\\n        vector<int> v;\\n        auto f = find(S.begin(),S.end(),c);\\n        auto i = S.begin();\\n        while(i!=f+1 && i!=S.end())\\n        {\\n            v.push_back(abs(i-f));\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 600909,
                "title": "simple-cpp-100-100",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n\\t\\t\\tvector<int> idx,res;\\n\\t\\t\\tbool first = true;\\n\\t\\t\\t//this is just to maintain a  vector to maintain values\\n\\t\\t\\tfor(int  i = 0 ; i < S.size();i++){\\n\\t\\t\\t\\tif(S[i]==C&&first){\\n\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\tfirst=false;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(S[i]==C){\\n\\t\\t\\t\\t\\t\\tidx.push_back(i);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n        //the below function is the main logic\\n      \\n\\t  int temp = 1 ; \\n        for(int i = 0 ; i  <S.size();i++){\\n            if(S[i]!=C)res.push_back(min(abs(idx[temp-1]-i),abs(idx[temp]-i)));\\n            else{\\n             res.push_back(0);\\n                if(temp!=idx.size()-1) temp++;\\n                else continue;\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506937,
                "title": "easy-to-understand-c-solution-8ms",
                "content": "Runtime: 8 ms, faster than 98.14% of C++ online submissions for Shortest Distance to a Character.\\nMemory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Shortest Distance to a Character.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        \\n        vector<int> res;\\n        vector<int> pos;\\n        \\n        for(int i=0; i<S.size(); i++)\\n        {\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }\\n        \\n        for(int i = 0; i < S.size(); i++)\\n        {\\n            int index = lower_bound(pos.begin(), pos.end(), i) - pos.begin();\\n            int prevDiff = (index - 1 >= 0 ? i - pos[index - 1] : INT_MAX);\\n            int nextDiff = (index < pos.size()  ? pos[index] - i : INT_MAX);\\n            \\n            int minDiff = min(prevDiff, nextDiff);\\n            res.push_back(minDiff);\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        \\n        vector<int> res;\\n        vector<int> pos;\\n        \\n        for(int i=0; i<S.size(); i++)\\n        {\\n            if(S[i] == C)\\n                pos.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429615,
                "title": "python-easy-solution",
                "content": "class Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        output = []\\n        \\n        cins = [index for index, value in enumerate(S) if value == C]\\n        print(cins)\\n        for i in range(len(S)) :\\n            if i in cins :\\n                output.append(0)\\n            else :\\n                output.append(min(map(lambda x : abs(x-i),cins)))\\n            \\n        return output\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        output = []\\n        \\n        cins = [index for index, value in enumerate(S) if value == C]\\n        print(cins)\\n        for i in range(len(S)) :\\n            if i in cins :\\n                output.append(0)\\n            else :\\n                output.append(min(map(lambda x : abs(x-i),cins)))\\n            \\n        return output\\n",
                "codeTag": "Java"
            },
            {
                "id": 416688,
                "title": "simple-intuitive-solution-c",
                "content": "Just keep a check on places of occurences of \\'C\\' and greedily choose the shortest (to left or right)\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> es;\\n        \\n        if(S.size()==1)\\n        {\\n            return {0};\\n        }\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            if(S[i]==C)\\n            {\\n                es.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans(S.size());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(es.size()>1 && abs(i-*es.begin())>abs(i-*(es.begin()+1)))\\n            {\\n                es.erase(es.begin());\\n            }\\n            ans[i]=abs(i-*es.begin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> es;\\n        \\n        if(S.size()==1)\\n        {\\n            return {0};\\n        }\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            if(S[i]==C)\\n            {\\n                es.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> ans(S.size());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if(es.size()>1 && abs(i-*es.begin())>abs(i-*(es.begin()+1)))\\n            {\\n                es.erase(es.begin());\\n            }\\n            ans[i]=abs(i-*es.begin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411160,
                "title": "python-3-o-1-auxiliary-space-one-traversal-algorithm",
                "content": "Instead of keeping O(2N) minimum distance list by traversing twice, I just kept the length of the substring that exists between the character C or edge and output the distance.\\n```\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        r, seen_c, l = [], False, 0\\n        for w in S:\\n            if w == C:\\n                if seen_c:                              # C\"substring\"C\\n                    for i in range(1,l//2+1):\\n                        r.append(i)\\n                    for i in range(l//2+l%2,0,-1):\\n                        r.append(i)\\n                else:                                     # [\"substring\"C\\n                    for i in range(l,0,-1):\\n                        r.append(i)\\n                seen_c, l = True, 0\\n                r.append(0)\\n            else:\\n                l += 1\\n        for i in range(1,l+1):               # C\"substring\"]\\n            r.append(i)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        r, seen_c, l = [], False, 0\\n        for w in S:\\n            if w == C:\\n                if seen_c:                              # C\"substring\"C\\n                    for i in range(1,l//2+1):\\n                        r.append(i)\\n                    for i in range(l//2+l%2,0,-1):\\n                        r.append(i)\\n                else:                                     # [\"substring\"C\\n                    for i in range(l,0,-1):\\n                        r.append(i)\\n                seen_c, l = True, 0\\n                r.append(0)\\n            else:\\n                l += 1\\n        for i in range(1,l+1):               # C\"substring\"]\\n            r.append(i)\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363065,
                "title": "python-bfs-on-graph-commented-and-explained",
                "content": "**Idea**\\n- Shortest distance to a character === Shortest distance from a character\\n- build uniform graph and run a BFS algo\\n- keep a variable r outside the loop to keep track of raduis\\n\\n**## initial ##**\\n- Not aware that the special char could occur multiple times in the string, I intilaly built a graph in which each node is simply a char in S and did a BFS. This approach of building a graph would work only if the characters in the string were unique (duplicates not allowed)\\n\\n**## Modified ##**\\n- In order to count for duplicates, now we must allow duplictaes in the graph. So, Instead of building a graph of chars where a node = char, we make a graph in which each node represents a (char, index) pair. Now we need to run BFS as many times as C occures in S and \\n\\n**Steps**\\n- Build a graph that allows duplicates - node = (char, index) pair\\n- Iterate iver the string S and for every encounter of the desired char C -> run a BFS on the graph with C as the starting point in the queue\\n- keep track of min distance of every char from C in a dictionary\\n\\n**Example to demonstarte idea:**\\nS = \"lovely\", C = \"L\"\\n\\nl   o   v   e   l   y\\n0  1  2   3  4  5  -> distances from C when C = the first incident of l at index 0\\n4  3  2   1  0  1  -> distances from C when C = second incident of l at index 4\\n0  1  2   1  0  1  -> the smaller of the two distances above is the final distance we need to return\\n\\n**Visuals**\\n- ![image](https://assets.leetcode.com/users/abadawi/image_1566317520.png)\\n- ![image](https://assets.leetcode.com/users/abadawi/image_1566317527.png)\\n\\n**Code**\\n\\n```\\ndef shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        # build graph:\\n        from collections import defaultdict\\n        d = defaultdict(set)\\n        for i in range(1, len(S)-1):\\n            if i+1 >= 0 and i+1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i+1], i+1))\\n                d[(S[i+1], i+1)].add((S[i], i)) # undirected\\n            if i-1 >= 0 and i-1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i-1], i-1))\\n                d[(S[i-1], i-1)].add((S[i], i)) # undirected\\n        \\n        # helper bfs #\\n        def bfs(srcNode): # src node format -> (char, index)\\n            from collections import deque\\n            q = deque()\\n            q.append((srcNode, 0)) # node, r\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    node, r = q.popleft()\\n                    visited.add(node)\\n                    # process/update the distances dict\\n                    if node not in distances:\\n                        distances[node] = r\\n                    else:\\n                        if r < distances[node]:\\n                            distances[node] = r\\n                    # expand raduis of bfs\\n                    for nei in d[node]:\\n                        if nei not in visited:\\n                            q.append((nei, r+1))       \\n        \\n        distances = {}\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                bfs((S[i], i))\\n        \\n        # Empty distances dict into list:\\n        res = []\\n        for i in range(len(S)):\\n            res.append(distances[(S[i], i)])\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef shortestToChar(self, S: str, C: str) -> List[int]:\\n        \\n        # build graph:\\n        from collections import defaultdict\\n        d = defaultdict(set)\\n        for i in range(1, len(S)-1):\\n            if i+1 >= 0 and i+1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i+1], i+1))\\n                d[(S[i+1], i+1)].add((S[i], i)) # undirected\\n            if i-1 >= 0 and i-1 <= len(S)-1:\\n                d[(S[i], i)].add((S[i-1], i-1))\\n                d[(S[i-1], i-1)].add((S[i], i)) # undirected\\n        \\n        # helper bfs #\\n        def bfs(srcNode): # src node format -> (char, index)\\n            from collections import deque\\n            q = deque()\\n            q.append((srcNode, 0)) # node, r\\n            visited = set()\\n            while q:\\n                for i in range(len(q)):\\n                    node, r = q.popleft()\\n                    visited.add(node)\\n                    # process/update the distances dict\\n                    if node not in distances:\\n                        distances[node] = r\\n                    else:\\n                        if r < distances[node]:\\n                            distances[node] = r\\n                    # expand raduis of bfs\\n                    for nei in d[node]:\\n                        if nei not in visited:\\n                            q.append((nei, r+1))       \\n        \\n        distances = {}\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                bfs((S[i], i))\\n        \\n        # Empty distances dict into list:\\n        res = []\\n        for i in range(len(S)):\\n            res.append(distances[(S[i], i)])\\n        return res\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 359339,
                "title": "java-sliding-window-2-pass-full-details",
                "content": "The 1st pattern that came to mind was to use a **Sliding Window**. We can do it T:O(n), S:O(n) like the accepted solution. The below Java code runs in 1ms. It uses 2 pointers to check for the closest occurence of C from i and the second closest occurence of C (if it exists) from i. Here, we also get the *Mininimum Absolute Distance* between *(curr - i)* and *(next - i)*. As soon as i is closer to next that it is to curr, we update curr with next and next with the next occurene of C (if it exists) in the list of occurences we created earlier.\\n\\n**Algo:**\\n\\n1.  Store all occurences of C in S into a list\\n2.  Go through S once by checking for Min_Absolute_Distance(curr - i, next - i)\\n3.  Update curr and next accordingly as soon as i is closer to next than curr\\n\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];\\n        \\n        // Handle edge cases (0, null, etc)\\n        if (S == null || S.length() == 0)\\n            return output;\\n                                \\n        // Store all positions of C in S\\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n                        \\n        // Sliding window  \\n        int j = 0;\\n        int curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }   \\n        \\n        return output;\\n    }     \\n}\\n```\\nCompact version:\\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];        \\n        if (S == null || S.length() == 0) return output;\\n                            \\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n \\n        int j = 0,curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }           \\n        return output;\\n    }     \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];\\n        \\n        // Handle edge cases (0, null, etc)\\n        if (S == null || S.length() == 0)\\n            return output;\\n                                \\n        // Store all positions of C in S\\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n                        \\n        // Sliding window  \\n        int j = 0;\\n        int curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }   \\n        \\n        return output;\\n    }     \\n}\\n```\n```java\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int[] output = new int[S.length()];        \\n        if (S == null || S.length() == 0) return output;\\n                            \\n        List<Integer> occurrences = new ArrayList<>();\\n        for (int i=0; i<S.length(); i++)\\n            if (S.charAt(i) == C) \\n                occurrences.add(i);\\n \\n        int j = 0,curr = occurrences.get(j);\\n        int next = occurrences.size() > 1 ? occurrences.get(++j) : curr;\\n        for (int i=0; i<S.length(); i++) {                        \\n            if (Math.abs(curr-i) < Math.abs(next-i))\\n                output[i] = Math.abs(curr-i);\\n            else {\\n                output[i] = Math.abs(next-i);\\n                curr = next;\\n                if (j+1 < occurrences.size())              \\n                    next = occurrences.get(++j);\\n                else\\n                    next = curr;\\n            }                                            \\n        }           \\n        return output;\\n    }     \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325759,
                "title": "c-solution-o-n",
                "content": "C# solution. o(n)\\n```\\npublic int[] ShortestToChar(string S, char C) {\\n        int[] result = new int[S.Length];\\n        int head = S.Length + 1;\\n        int tail = S.Length + 1;\\n        \\n        for (int i = 0, j = S.Length - 1; i < S.Length; i++, j--)\\n        {\\n            if (S[i] == C)\\n            {\\n                head = 0;\\n            }\\n            \\n            if (S[j] == C)\\n            {\\n                tail = 0;\\n            }\\n            \\n            if(i < j)\\n            {\\n                result[i] = head++;\\n                result[j] = tail++;\\n            }\\n            else if(i == j)\\n            {\\n                result[i] = Math.Min(head++, tail++);\\n            }\\n            else \\n            {\\n                result[i] = Math.Min(head++, result[i]);\\n                result[j] = Math.Min(tail++, result[j]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] ShortestToChar(string S, char C) {\\n        int[] result = new int[S.Length];\\n        int head = S.Length + 1;\\n        int tail = S.Length + 1;\\n        \\n        for (int i = 0, j = S.Length - 1; i < S.Length; i++, j--)\\n        {\\n            if (S[i] == C)\\n            {\\n                head = 0;\\n            }\\n            \\n            if (S[j] == C)\\n            {\\n                tail = 0;\\n            }\\n            \\n            if(i < j)\\n            {\\n                result[i] = head++;\\n                result[j] = tail++;\\n            }\\n            else if(i == j)\\n            {\\n                result[i] = Math.Min(head++, tail++);\\n            }\\n            else \\n            {\\n                result[i] = Math.Min(head++, result[i]);\\n                result[j] = Math.Min(tail++, result[j]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324885,
                "title": "python-easy-two-passes-solution",
                "content": "99.7% speed\\n```\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        indc, dis = float(\\'-inf\\'), [0] * len(S)\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                indc = i\\n            dis[i] = i - indc\\n        \\n        indc = float(\\'inf\\')\\n        for j in range(len(dis))[::-1]:\\n            if S[j] == C:\\n                indc = j\\n            dis[j] = min(dis[j], indc-j)\\n        \\n        return dis\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        indc, dis = float(\\'-inf\\'), [0] * len(S)\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                indc = i\\n            dis[i] = i - indc\\n        \\n        indc = float(\\'inf\\')\\n        for j in range(len(dis))[::-1]:\\n            if S[j] == C:\\n                indc = j\\n            dis[j] = min(dis[j], indc-j)\\n        \\n        return dis\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285409,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        return [min([abs(j-i) for j in [x for x,y in enumerate(S) if y==C]]) for i in range(len(S))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        return [min([abs(j-i) for j in [x for x,y in enumerate(S) if y==C]]) for i in range(len(S))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205746,
                "title": "python-easy-to-understand",
                "content": "```\\ndef shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        if C not in S:\\n            return []\\n        ans = [-1] * len(S)\\n        start = float(\"Inf\")\\n        ind = []\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                ans[i] = 0\\n                ind.append(i)\\n        if len(S) > ind[-1] + 1:\\n            ind.append(float(\"Inf\"))\\n        for j in range(len(S)):\\n            if S[j] != C:\\n                ans[j] = min(abs(j-start), abs(j-ind[0]))\\n            else:\\n                start = ind[0]\\n                ind.pop(0)\\n        return ans\\n        \\n```",
                "solutionTags": [],
                "code": "```\\ndef shortestToChar(self, S, C):\\n        \"\"\"\\n        :type S: str\\n        :type C: str\\n        :rtype: List[int]\\n        \"\"\"\\n        if C not in S:\\n            return []\\n        ans = [-1] * len(S)\\n        start = float(\"Inf\")\\n        ind = []\\n        for i in range(len(S)):\\n            if S[i] == C:\\n                ans[i] = 0\\n                ind.append(i)\\n        if len(S) > ind[-1] + 1:\\n            ind.append(float(\"Inf\"))\\n        for j in range(len(S)):\\n            if S[j] != C:\\n                ans[j] = min(abs(j-start), abs(j-ind[0]))\\n            else:\\n                start = ind[0]\\n                ind.pop(0)\\n        return ans\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 156216,
                "title": "2-pass-solution-in-c-beats-100-submissions",
                "content": "For a given element at position `i`, it\\'s shortest distance to the `C` is `min(shortest_distance_to_left_occuence[i], shortest_distance_to_right_occurence[i])`, where `shortest_distance_to_left_occurence[i] = 0 if S[i] == C else shortest_distance_to_left_occurence[i-1] + 1`. Similarly `shortest_distance_to_right_occurence[i] = 0 if S[i] == C else shortest_distance_to_left_occurence[i+1] + 1`.\\n\\nFirst pass keeps track of the shortest distance to the left occurence of the `C` and second pass takes into account right occurences of `C`.\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> distance(S.size(), S.size());\\n        for (int i = 0; i < S.size(); ++i) {\\n            if (S[i] == C) {\\n                distance[i] = 0;\\n            } else if (i > 0) {\\n                distance[i] = distance[i-1] + 1;\\n            }\\n        }\\n        for (int i = S.size() - 2; i >= 0; --i) {\\n            distance[i] = min(distance[i], distance[i+1] + 1);\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string S, char C) {\\n        vector<int> distance(S.size(), S.size());\\n        for (int i = 0; i < S.size(); ++i) {\\n            if (S[i] == C) {\\n                distance[i] = 0;\\n            } else if (i > 0) {\\n                distance[i] = distance[i-1] + 1;\\n            }\\n        }\\n        for (int i = S.size() - 2; i >= 0; --i) {\\n            distance[i] = min(distance[i], distance[i+1] + 1);\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128296,
                "title": "python-solution-from-a-beginner",
                "content": "I am new to Python, I know it is not the most efficient way...but hope you enjoy. :)\\n\\n```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        myList = [i for i,letter in enumerate(S) if letter == C]\\n        result = []\\n        for i in range(len(S)):\\n            min_pos = []\\n            for j in myList:\\n                min_pos.append(abs(j-i))\\n            result.append(min(min_pos))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, S, C):\\n        myList = [i for i,letter in enumerate(S) if letter == C]\\n        result = []\\n        for i in range(len(S)):\\n            min_pos = []\\n            for j in myList:\\n                min_pos.append(abs(j-i))\\n            result.append(min(min_pos))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125801,
                "title": "python-o-n-solution",
                "content": "* Idea is to move from left to right, right to left and update distance related to seen character\\n``` \\nclass Solution:\\n    def shortestToChar(self, s, c):\\n        res = [float(\"inf\")] * len(s)\\n        dx = 1\\n        cur = i = 0\\n        while i > -1:\\n            if cur:\\n                res[i] = min(res[i], cur)\\n                cur += 1\\n            if s[i] == c:\\n                res[i] = 0\\n                cur = 1\\n            i += dx\\n            if i == len(s):\\n                dx = -1\\n                cur = 0\\n                i -= 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def shortestToChar(self, s, c):\\n        res = [float(\"inf\")] * len(s)\\n        dx = 1\\n        cur = i = 0\\n        while i > -1:\\n            if cur:\\n                res[i] = min(res[i], cur)\\n                cur += 1\\n            if s[i] == c:\\n                res[i] = 0\\n                cur = 1\\n            i += dx\\n            if i == len(s):\\n                dx = -1\\n                cur = 0\\n                i -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034738,
                "title": "best-java-solution-beats-60",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shortestToChar(String str, char c) {\\n        StringBuilder s = new StringBuilder(str);\\n\\n        int ans[] = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n                continue;\\n            }\\n            String s1 = s.substring(0,i);\\n            String s2 = s.substring(i+1);\\n\\n            int a = s1.lastIndexOf(c);\\n            int b = s2.indexOf(c);\\n\\n            if(a==-1) a = Integer.MAX_VALUE;\\n            else a = s1.length()-a;\\n\\n            if(b==-1) b = Integer.MAX_VALUE;\\n            else b = b+1;\\n\\n\\n            ans[i] = Math.min(a,b);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String str, char c) {\\n        StringBuilder s = new StringBuilder(str);\\n\\n        int ans[] = new int[s.length()];\\n\\n        for(int i=0; i<s.length(); i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n                continue;\\n            }\\n            String s1 = s.substring(0,i);\\n            String s2 = s.substring(i+1);\\n\\n            int a = s1.lastIndexOf(c);\\n            int b = s2.indexOf(c);\\n\\n            if(a==-1) a = Integer.MAX_VALUE;\\n            else a = s1.length()-a;\\n\\n            if(b==-1) b = Integer.MAX_VALUE;\\n            else b = b+1;\\n\\n\\n            ans[i] = Math.min(a,b);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899350,
                "title": "simple-solution-using-two-pointers-o-n-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using two pointer approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We need to store previous and next closest occurrence of the character `c` in both the sides of the current index, `i`.\\n- `previous` will have the closest occurrence of `c` to the left side of `i`.\\n- `next` will have the closest occurrence of `c` to the right side of `i`. \\n- Everytime `i` moves past `next`, the following operations will be made\\n  * `prev = next` \\n  * `next` moves forward in searching the next occurrence of `c` \\n- At every index, the absolute minumum of `next - i` and `i - previous` gives the shortest distance to `c` \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) (for result array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        \\n        // Find the first occurrence of c\\n        int next = moveForward(s, c, 0);\\n        int previous = next;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (i > next) {\\n                previous = next;\\n                next = moveForward(s, c, next + 1);\\n            }\\n\\n            result[i] = Math.abs(Math.min(next - i, i - previous));\\n        }\\n\\n        return result;\\n    }\\n\\n    private int moveForward(String s, char c, int position) {\\n        while(position < s.length()) {\\n            if (s.charAt(position) == c) {\\n                break;\\n            }\\n            ++position;\\n        }\\n\\n        // When `c` does not occur further in the string, return MAX value\\n        // This makes `previous` as the only valid closest occurrence\\n        if (position == s.length()) {\\n            return Integer.MAX_VALUE;\\n        }\\n        return position;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] result = new int[s.length()];\\n        \\n        // Find the first occurrence of c\\n        int next = moveForward(s, c, 0);\\n        int previous = next;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            if (i > next) {\\n                previous = next;\\n                next = moveForward(s, c, next + 1);\\n            }\\n\\n            result[i] = Math.abs(Math.min(next - i, i - previous));\\n        }\\n\\n        return result;\\n    }\\n\\n    private int moveForward(String s, char c, int position) {\\n        while(position < s.length()) {\\n            if (s.charAt(position) == c) {\\n                break;\\n            }\\n            ++position;\\n        }\\n\\n        // When `c` does not occur further in the string, return MAX value\\n        // This makes `previous` as the only valid closest occurrence\\n        if (position == s.length()) {\\n            return Integer.MAX_VALUE;\\n        }\\n        return position;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765194,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, i + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, i + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566001,
                "title": "two-pointer-o-n-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Using two pointer approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->We will have two pointers, and change them over when the right one will be more closer, the right one will become left pointer , and we\\'ll get a  new right pointer if there exists one.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) {for solution array only}\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int[] shortestToChar(String s, char c)\\n    {\\n        char[] arr=s.toCharArray();\\n        boolean f2=false; //flag for telling if there is second right available\\n        int ptr1=0,ptr2=0;\\n        for(int i=0;i<arr.length;i++) //gets the first occurence\\n            if(c==arr[i])\\n            {\\n                ptr1=i;\\n                break;\\n            }\\n\\n        for(int i=ptr1+1;i<arr.length;i++) //gets the second occurence if there is one , thats why the flag is used which is false by default\\n            if(c==arr[i])\\n            {\\n                ptr2=i;\\n                f2=true;\\n                break;\\n            }\\n\\n        int[] result=new int[s.length()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(f2) //if second occurence exists\\n            {\\n                if((Math.abs(ptr1-i)>=(Math.abs(ptr2-i)))) //gets triggered if the right one is more closer or equally closer\\n                { //inside we are changing the pointers\\n                    int j;\\n                    boolean flag=false; //tells if we have another occurence of given character\\n                    for(j=ptr2+1;j<arr.length;j++)\\n                        if(arr[j]==c)\\n                        {\\n                            flag=true;\\n                            break;\\n                        }\\n                    if(flag) //updates both pointers if we get an occurence\\n                    {\\n                        ptr1=ptr2;\\n                        ptr2=j;\\n                    }\\n                    else //else only ptr1 will be changed , and this this if will not be triggered again\\n                    {\\n                        ptr1=ptr2;\\n                        f2=false;\\n                    }\\n                }\\n            }\\n            result[i]=Math.abs(ptr1-i);\\n        }\\n        return result\\n        ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int[] shortestToChar(String s, char c)\\n    {\\n        char[] arr=s.toCharArray();\\n        boolean f2=false; //flag for telling if there is second right available\\n        int ptr1=0,ptr2=0;\\n        for(int i=0;i<arr.length;i++) //gets the first occurence\\n            if(c==arr[i])\\n            {\\n                ptr1=i;\\n                break;\\n            }\\n\\n        for(int i=ptr1+1;i<arr.length;i++) //gets the second occurence if there is one , thats why the flag is used which is false by default\\n            if(c==arr[i])\\n            {\\n                ptr2=i;\\n                f2=true;\\n                break;\\n            }\\n\\n        int[] result=new int[s.length()];\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(f2) //if second occurence exists\\n            {\\n                if((Math.abs(ptr1-i)>=(Math.abs(ptr2-i)))) //gets triggered if the right one is more closer or equally closer\\n                { //inside we are changing the pointers\\n                    int j;\\n                    boolean flag=false; //tells if we have another occurence of given character\\n                    for(j=ptr2+1;j<arr.length;j++)\\n                        if(arr[j]==c)\\n                        {\\n                            flag=true;\\n                            break;\\n                        }\\n                    if(flag) //updates both pointers if we get an occurence\\n                    {\\n                        ptr1=ptr2;\\n                        ptr2=j;\\n                    }\\n                    else //else only ptr1 will be changed , and this this if will not be triggered again\\n                    {\\n                        ptr1=ptr2;\\n                        f2=false;\\n                    }\\n                }\\n            }\\n            result[i]=Math.abs(ptr1-i);\\n        }\\n        return result\\n        ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317704,
                "title": "c-unique-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>indexes;\\n        vector<int>sol;\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n\\n        return sol;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int>indexes;\\n        vector<int>sol;\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i] == c) indexes.push_back(i);\\n        }\\n\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            int min_dist = 10000;\\n            for(int j : indexes)\\n            {\\n                min_dist = min(min_dist,abs(j-i));\\n            }\\n            sol.push_back(min_dist);\\n        }\\n\\n        return sol;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316847,
                "title": "shortest-distance-to-a-character-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j;\\n        vector<int> ans;\\n        vector<int> pos;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos.push_back(i);\\n            }\\n        }\\n        j=0;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(j==pos.size()-1)\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else if(abs(i-pos[j])>abs(i-pos[j+1]))\\n            {\\n                j++;\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j;\\n        vector<int> ans;\\n        vector<int> pos;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos.push_back(i);\\n            }\\n        }\\n        j=0;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            if(j==pos.size()-1)\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else if(abs(i-pos[j])>abs(i-pos[j+1]))\\n            {\\n                j++;\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n            else\\n            {\\n                ans.push_back(abs(i-pos[j]));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316820,
                "title": "shortest-distance-to-a-character-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j, k, min;\\n        vector<int> ans;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            min = 100000;\\n            for(j=0 ; j<s.length() ; j++)\\n            {\\n                if(s[j]==c && abs(i-j)<min)\\n                {\\n                    min = abs(i-j);\\n                    for(k=j+1 ; k<s.length() ; k++)\\n                    {\\n                        if(s[k]==c && abs(k-i)<min)\\n                        {\\n                            min = abs(k-i);\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(min);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int i, j, k, min;\\n        vector<int> ans;\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            min = 100000;\\n            for(j=0 ; j<s.length() ; j++)\\n            {\\n                if(s[j]==c && abs(i-j)<min)\\n                {\\n                    min = abs(i-j);\\n                    for(k=j+1 ; k<s.length() ; k++)\\n                    {\\n                        if(s[k]==c && abs(k-i)<min)\\n                        {\\n                            min = abs(k-i);\\n                        }\\n                    }\\n                }\\n            }\\n            ans.push_back(min);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149079,
                "title": "best-explained-solution",
                "content": "\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Go",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len = s.length();\\n        int ans[] = new int[len];\\n        int prev = len;\\n        \\n        // forward\\n        for(int i = 0; i < len; i++){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = 0;\\n            }\\n            else\\n                ans[i] = ++prev;\\n        }\\n        \\n        prev = len;\\n        for(int i = len-1; i >= 0; i--){\\n            if(s.charAt(i) == c){\\n                prev = 0;\\n                ans[i] = Math.min(ans[i], 0);\\n            }\\n            else\\n                ans[i] = Math.min(ans[i], ++prev);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901189,
                "title": "javascript-js-simple-easy-to-understand",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, prev + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n    let prev = s.indexOf(c);\\n    let next = prev;\\n    const distance = [];\\n    for (let i = 0; i < s.length; i ++) {\\n        if (s[i] === c) {\\n            prev = i;\\n            next = s.indexOf(c, prev + 1);\\n        }\\n        distance.push(Math.min(Math.abs(prev - i), Math.abs(next - i)));\\n    }\\n    return distance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2874523,
                "title": "python3-long-but-fast-faster-than-97-10",
                "content": "# Code\\n```\\nclass Solution:\\n    def getIndicies(self, s, c):\\n        indicies = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                indicies.append(i)\\n        return indicies\\n    def getShortest(self, idx, indicies):\\n        if idx in indicies: return 0\\n        if idx < indicies[0]: return abs(idx - indicies[0])\\n        elif idx > indicies[-1]: return abs(indicies[-1] - idx)\\n        for index in range(len(indicies)):\\n            if indicies[index] > idx:\\n                minDistance = min(abs(idx - indicies[index]), abs(idx - indicies[index - 1]))\\n                return minDistance\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        indicies = sorted(self.getIndicies(s, c), key=lambda x:x)\\n        result = []\\n        for i in range(len(s)):\\n            result.append(self.getShortest(i, indicies))\\n        return result\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/821d480c-a58b-418b-8032-8aec83439aa7_1670107858.6099043.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getIndicies(self, s, c):\\n        indicies = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                indicies.append(i)\\n        return indicies\\n    def getShortest(self, idx, indicies):\\n        if idx in indicies: return 0\\n        if idx < indicies[0]: return abs(idx - indicies[0])\\n        elif idx > indicies[-1]: return abs(indicies[-1] - idx)\\n        for index in range(len(indicies)):\\n            if indicies[index] > idx:\\n                minDistance = min(abs(idx - indicies[index]), abs(idx - indicies[index - 1]))\\n                return minDistance\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        indicies = sorted(self.getIndicies(s, c), key=lambda x:x)\\n        result = []\\n        for i in range(len(s)):\\n            result.append(self.getShortest(i, indicies))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632244,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n  = s.length();\\n        vector<int > res(n,INT_MAX),v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == c){\\n                res[i] = 0;\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=c)\\n            {\\n                for(int j=0;j<v.size();j++)\\n                {\\n                    res[i] = min(res[i],abs(v[j]-i));\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n  = s.length();\\n        vector<int > res(n,INT_MAX),v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] == c){\\n                res[i] = 0;\\n                v.push_back(i);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=c)\\n            {\\n                for(int j=0;j<v.size();j++)\\n                {\\n                    res[i] = min(res[i],abs(v[j]-i));\\n                    \\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592295,
                "title": "python-simplest-solution",
                "content": "```\\n\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp = []\\n        ind = s.index(c)\\n        for i in range(len(s)):\\n            if abs(ind-i)>abs(s.find(c,i)-i):\\n                ind = s.index(c,i)\\n            if s[i]!=c:\\n                temp.append(abs(ind-i))\\n            else:\\n                temp.append(0)\\n        return temp\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp = []\\n        ind = s.index(c)\\n        for i in range(len(s)):\\n            if abs(ind-i)>abs(s.find(c,i)-i):\\n                ind = s.index(c,i)\\n            if s[i]!=c:\\n                temp.append(abs(ind-i))\\n            else:\\n                temp.append(0)\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533533,
                "title": "o-1-space-prefix-suffix-with-comments",
                "content": "\\n# Python\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t    \"\"\"\\n        Q. Min/Max distance to closest character [left or right]\\n        \\n        Character can be present to left or right both\\n        \\n        1. Trace from left  to right & count distance from last char found\\n        2. Trace from right to left:\\n           Three cases would be there: \\n        \\n            Case1:  [a _ _ _ _ _ a]  -> already non-zero & flag true from right, take min\\n            Case2:  [a _ _ _ _ _ _]  -> already non-zero & flag false, then leave\\n            Case3:  [_ _ _ _ _ _ a]  -> already zero & flag true, update the sum  \\n        \"\"\"\\n        n= len(s)\\n        pre=  [0 for i in range(0,n)]\\n        flag= False\\n        \\n        for i in range(0,n):\\n            if s[i]==c: flag=True\\n            elif flag: pre[i]= pre[i-1]+1\\n        \\n        flag=False;\\n        \\n        for i in range(n-1,-1,-1):\\n            if s[i]==c: flag=True \\n            elif flag and pre[i]==0: pre[i]= pre[i+1]+1\\n            elif flag and pre[i]>0:   pre[i]= min(pre[i],pre[i+1]+1)        \\n        return pre",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n# Python\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n\\t    \"\"\"\\n        Q. Min/Max distance to closest character [left or right]\\n        \\n        Character can be present to left or right both\\n        \\n        1. Trace from left  to right & count distance from last char found\\n        2. Trace from right to left:\\n           Three cases would be there: \\n        \\n            Case1:  [a _ _ _ _ _ a]  -> already non-zero & flag true from right, take min\\n            Case2:  [a _ _ _ _ _ _]  -> already non-zero & flag false, then leave\\n            Case3:  [_ _ _ _ _ _ a]  -> already zero & flag true, update the sum  \\n        \"\"\"\\n        n= len(s)\\n        pre=  [0 for i in range(0,n)]\\n        flag= False\\n        \\n        for i in range(0,n):\\n            if s[i]==c: flag=True\\n            elif flag: pre[i]= pre[i-1]+1\\n        \\n        flag=False;\\n        \\n        for i in range(n-1,-1,-1):\\n            if s[i]==c: flag=True \\n            elif flag and pre[i]==0: pre[i]= pre[i+1]+1\\n            elif flag and pre[i]>0:   pre[i]= min(pre[i],pre[i+1]+1)        \\n        return pre",
                "codeTag": "Python3"
            },
            {
                "id": 2497968,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans=new int[s.length()];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=c){\\n                for(int j=i+1;j<s.length();j++){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=j-i;\\n                        break;\\n                    }\\n                    \\n                }\\n                for(int j=i-1;j>=0;j--){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=Math.min(ans[i],Math.abs(i-j));\\n                        break;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans=new int[s.length()];\\n        Arrays.fill(ans,Integer.MAX_VALUE);\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                ans[i]=0;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)!=c){\\n                for(int j=i+1;j<s.length();j++){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=j-i;\\n                        break;\\n                    }\\n                    \\n                }\\n                for(int j=i-1;j>=0;j--){\\n                    if(s.charAt(j)==c){\\n                        ans[i]=Math.min(ans[i],Math.abs(i-j));\\n                        break;\\n                        \\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467922,
                "title": "c-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> ans(s.size());\\n        int pos=-s.size();\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos=i;\\n            }\\n            ans[i]=i-pos;\\n        }\\n        for(int i=pos-1;i>=0;i--)\\n        {\\n            if(s[i]==c)\\n                pos=i;\\n            ans[i]=min(ans[i],pos-i);\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> ans(s.size());\\n        int pos=-s.size();\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                pos=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2460480,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        vector<int>index;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int idx=i;\\n            int dis=INT_MAX;\\n            for(int j=0;j<index.size();j++)\\n            {\\n               dis=min(dis,abs(idx-index[j]));\\n            }\\n            ans.push_back(dis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n        vector<int>index;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                index.push_back(i);\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int idx=i;\\n            int dis=INT_MAX;\\n            for(int j=0;j<index.size();j++)\\n            {\\n               dis=min(dis,abs(idx-index[j]));\\n            }\\n            ans.push_back(dis);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429280,
                "title": "2-simple-and-concise-python-solutions-with-in-depth-explanation",
                "content": "Solution 1:\\nWe will create a list called indices or storing the indices of c. Then we will find the closest absolute distance\\nbetween the current character and the c. We will use another list named res to store the result. Now we will run a for loop from i=0 to i=len(s). Every time we put minIndex to some random large number let\\'s say 99999. We have to choose this random number such that it is always greater than the len(s). In this for loop if s[i]==c i.e if currecnt character in s is equal to c then we know that the closest distacnce is obviously 0. If s[i] !=c , then we will run a for loop from the indices list which we got previously. This for loop checks for the minimum index among all the available indices. At last we will return our res list.  \\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        for i in range(len(s):\\n\\t\\t\\tif s[i]==c:\\n\\t\\t\\t\\tindices.append(i)\\n\\t    print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                for index in indices:\\n                    minIndex=min(abs(i-index),minIndex)\\n                res.append(minIndex)\\n        return res\\n```\\nSolution 2:\\nThis is same as solution 1 except that we use one liner for creating indices list and checking the minimum Index in the else part of for loop.\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        indices=[i for i, x in enumerate(s) if x == c]\\n        print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                res.append(min(abs(i-index) for index in indices))\\n        return res\\n```\\nPlease upvote if you like the solution. \\nConnect with me at https://www.linkedin.com/in/podilichaitanyaakhilkumar/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        for i in range(len(s):\\n\\t\\t\\tif s[i]==c:\\n\\t\\t\\t\\tindices.append(i)\\n\\t    print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                for index in indices:\\n                    minIndex=min(abs(i-index),minIndex)\\n                res.append(minIndex)\\n        return res\\n```\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res=[]\\n        indices=[i for i, x in enumerate(s) if x == c]\\n        print(indices)\\n        for i in range(len(s)):\\n            minIndex=99999\\n            if s[i]==c:\\n                res.append(0)\\n            else:\\n                res.append(min(abs(i-index) for index in indices))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416137,
                "title": "easy-javascript-solution-beats-92",
                "content": "```\\nvar shortestToChar = function(s, c) {\\n    const newarr = new Array(s.length).fill(null);\\n    let position = [];\\n    for(let i =0; i<s.length; i++) {\\n        if(s[i] === c) {\\n           position.push(i); \\n            newarr[i] = 0;\\n        }\\n    }\\n    let i =0;\\n    let j =0;\\n    while(i<s.length) {\\n        const currentVal = Math.abs(i - position[j]);\\n        const nextVal =  Math.abs(isNaN(i - position[j + 1]) ? i -position[j] : i - position[j + 1]);  \\n        if( currentVal < nextVal) {\\n            newarr[i] = s[i] === c ? 0 : currentVal\\n        } else {\\n            newarr[i] = s[i] === c ? 0 : nextVal\\n            if(j < position.length -1) {\\n             j++   \\n            }\\n            \\n        }\\n        i++\\n    }\\n    return newarr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shortestToChar = function(s, c) {\\n    const newarr = new Array(s.length).fill(null);\\n    let position = [];\\n    for(let i =0; i<s.length; i++) {\\n        if(s[i] === c) {\\n           position.push(i); \\n            newarr[i] = 0;\\n        }\\n    }\\n    let i =0;\\n    let j =0;\\n    while(i<s.length) {\\n        const currentVal = Math.abs(i - position[j]);\\n        const nextVal =  Math.abs(isNaN(i - position[j + 1]) ? i -position[j] : i - position[j + 1]);  \\n        if( currentVal < nextVal) {\\n            newarr[i] = s[i] === c ? 0 : currentVal\\n        } else {\\n            newarr[i] = s[i] === c ? 0 : nextVal\\n            if(j < position.length -1) {\\n             j++   \\n            }\\n            \\n        }\\n        i++\\n    }\\n    return newarr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379300,
                "title": "c-solution-easy-to-understand",
                "content": "\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> answer;\\n        int mi = INT_MAX;\\n        bool found = false;\\n        \\n        for(int i=0;i<s.length();i++) {\\n            found = false;\\n            mi = INT_MAX;\\n            for(int j=0;j<s.length();j++) {\\n                \\n\\t\\t\\t\\t//pushing 0 if the current index itself contains the required character\\n                if(s[i] == c) {\\n                    answer.push_back(0);\\n                    break;\\n                }\\n                \\n\\t\\t\\t\\t//storing minimum distance everytime the character is found\\n                if(s[j] == c) {\\n                    mi = min(mi, abs(i-j));\\n                    found = true;\\n                }\\n                \\n\\t\\t\\t\\t//when the whole string is iterated and we found the matching character atleast once\\n                if(found && j==s.length()-1) {\\n                    answer.push_back(mi);\\n                    break;\\n                }           \\n            }         \\n        }\\n        return answer;\\n     }",
                "solutionTags": [],
                "code": "\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> answer;\\n        int mi = INT_MAX;\\n        bool found = false;\\n        \\n        for(int i=0;i<s.length();i++) {\\n            found = false;\\n            mi = INT_MAX;\\n            for(int j=0;j<s.length();j++) {\\n                \\n\\t\\t\\t\\t//pushing 0 if the current index itself contains the required character\\n                if(s[i] == c) {\\n                    answer.push_back(0);\\n                    break;\\n                }\\n                \\n\\t\\t\\t\\t//storing minimum distance everytime the character is found\\n                if(s[j] == c) {\\n                    mi = min(mi, abs(i-j));\\n                    found = true;\\n                }\\n                \\n\\t\\t\\t\\t//when the whole string is iterated and we found the matching character atleast once\\n                if(found && j==s.length()-1) {\\n                    answer.push_back(mi);\\n                    break;\\n                }           \\n            }         \\n        }\\n        return answer;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 2283509,
                "title": "python-simple-solution-explained",
                "content": "Hello,\\n\\nI did submit my simple solution.\\n\\nI try to find all the **indexes** of the **character** and then i loop over the string again to calculate the shortest distance based of the **indexes**. \\n\\n```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res = []\\n        index = []\\n        for i in range(len(s)):\\n            if s[i]  == c:\\n                index.append(i)\\n        for i in range(len(s)):\\n            if len(index) > 1:\\n                if abs(i-index[0])>abs(i-index[1]):\\n                    index.pop(0)\\n            res.append(abs(i-index[0]))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        res = []\\n        index = []\\n        for i in range(len(s)):\\n            if s[i]  == c:\\n                index.append(i)\\n        for i in range(len(s)):\\n            if len(index) > 1:\\n                if abs(i-index[0])>abs(i-index[1]):\\n                    index.pop(0)\\n            res.append(abs(i-index[0]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260097,
                "title": "two-pass-technique-c-o-n-o-1",
                "content": "```\\n// Two pass technique:\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n, -1);\\n        \\n        // from right to left, maintain lastOccurence of c and update ans[i] accordingly.\\n        int lastOcc = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == c){\\n                lastOcc = i;\\n                ans[i] = 0;\\n            } \\n            else{\\n                ans[i] = abs(lastOcc - i);\\n            }\\n        }\\n        \\n         // from left to right, maintain firstOccurence of c and update ans[i] accordingly if found minimum.\\n        int firstOcc = lastOcc;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == c){\\n                firstOcc = i;\\n                ans[i] = 0;\\n            }\\n            else{\\n                ans[i] = min(ans[i], abs(firstOcc - i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Two pass technique:\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.size();\\n        vector<int> ans(n, -1);\\n        \\n        // from right to left, maintain lastOccurence of c and update ans[i] accordingly.\\n        int lastOcc = -1;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i] == c){\\n                lastOcc = i;\\n                ans[i] = 0;\\n            } \\n            else{\\n                ans[i] = abs(lastOcc - i);\\n            }\\n        }\\n        \\n         // from left to right, maintain firstOccurence of c and update ans[i] accordingly if found minimum.\\n        int firstOcc = lastOcc;\\n        for(int i=0;i<n;i++){\\n            if(s[i] == c){\\n                firstOcc = i;\\n                ans[i] = 0;\\n            }\\n            else{\\n                ans[i] = min(ans[i], abs(firstOcc - i));\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207577,
                "title": "easy-o-n",
                "content": "```\\nfunc shortestToChar(s string, c byte) []int {\\n    var res []int\\n    \\n    firstOccurennce, lastOccurence := -1, -1\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            if firstOccurennce == -1 {\\n                firstOccurennce = i\\n            }\\n            \\n            lastOccurence = i\\n        }\\n    }\\n\\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            res = append(res, 0)\\n            firstOccurennce = i\\n        } else {\\n            res = append(res, abs(i - firstOccurennce))\\n        }\\n    }\\n    \\n    for i := len(s) - 1; i > -1; i-- {\\n        if s[i] == c {\\n            lastOccurence = i\\n        } else {\\n            res[i] = min(res[i], abs(i - lastOccurence))\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 {\\n        return a\\n    }\\n    \\n    return -a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Go"
                ],
                "code": "```\\nfunc shortestToChar(s string, c byte) []int {\\n    var res []int\\n    \\n    firstOccurennce, lastOccurence := -1, -1\\n    \\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            if firstOccurennce == -1 {\\n                firstOccurennce = i\\n            }\\n            \\n            lastOccurence = i\\n        }\\n    }\\n\\n    for i := 0; i < len(s); i++ {\\n        if s[i] == c {\\n            res = append(res, 0)\\n            firstOccurennce = i\\n        } else {\\n            res = append(res, abs(i - firstOccurennce))\\n        }\\n    }\\n    \\n    for i := len(s) - 1; i > -1; i-- {\\n        if s[i] == c {\\n            lastOccurence = i\\n        } else {\\n            res[i] = min(res[i], abs(i - lastOccurence))\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc abs(a int) int {\\n    if a >= 0 {\\n        return a\\n    }\\n    \\n    return -a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117263,
                "title": "javascript-infinity-solution-2-pointers-v-s-2-pass",
                "content": "**2 Pointers**\\n\\nRecord all indexes of `c`, then determine the **NEAREST distance from BOTH SIDES** for each `s[i]`.\\n> Note: for BOUNDARY condition, I add `-Infinity` and `Infinity` at both ends.\\n\\n```\\ns=loveleetcode, c=\"e\"\\nind=[-Infinity,3,5,6,11,Infinity]\\n\\ns[0]~[3]:  compare i with left=-Infinity, right=3\\ns[4]~[5]:  compare i with left=3, right=5\\ns[6]:      compare i with left=5, right=6\\ns[7]~[11]: compare i with left=6, right=11\\n```\\n\\n```\\nvar shortestToChar = function(s, c) {\\n    let ind=[-Infinity];\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]==c){ind.push(i)};\\n    }\\n    ind.push(Infinity);\\n\\t\\n    let now=0, output=[];\\n    for(let j=0; j<s.length; j++){\\n        if(j>ind[now]){now++};\\n\\t\\t// now-1=LEFT pointer, now=RIGHT pointer\\n        output.push(Math.min(Math.abs(j-ind[now-1]), Math.abs(j-ind[now])));\\n    }\\n    return output;\\n};\\n```\\n\\n**2 Pass**\\n\\nLoop from left to get **NEAREST distance from LEFT**.\\nThen loop from right again, update the **MINIMUM of two**.\\n```\\ns=loveleetcode, c=\"e\"\\n            l o v e l e e t c o d e\\nfrom left   X X X 0 1 0 0 1 2 3 4 0\\nfrom right  3 2 1 0 1 0 0 4 3 2 1 0\\nMIN         3 2 1 0 1 0 0 1 2 2 1 0\\n```\\n\\n```\\nvar shortestToChar = function(s, c) {\\n    let output=[], dis=Infinity;\\n    for(let i=0; i<s.length; i++){\\n        dis=s[i]==c? 0: ++dis;\\n        output.push(dis);\\n    }\\n    dis=Infinity;\\n    for(let j=s.length-1; j>=0; j--){\\n        dis=s[j]==c? 0: ++dis;\\n\\t\\t// compare MIN of dis(left) & dis(right)\\n        output[j]=Math.min(dis, output[j]);\\n    }\\n    return output;\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\ns=loveleetcode, c=\"e\"\\nind=[-Infinity,3,5,6,11,Infinity]\\n\\ns[0]~[3]:  compare i with left=-Infinity, right=3\\ns[4]~[5]:  compare i with left=3, right=5\\ns[6]:      compare i with left=5, right=6\\ns[7]~[11]: compare i with left=6, right=11\\n```\n```\\nvar shortestToChar = function(s, c) {\\n    let ind=[-Infinity];\\n    for(let i=0; i<s.length; i++){\\n        if(s[i]==c){ind.push(i)};\\n    }\\n    ind.push(Infinity);\\n\\t\\n    let now=0, output=[];\\n    for(let j=0; j<s.length; j++){\\n        if(j>ind[now]){now++};\\n\\t\\t// now-1=LEFT pointer, now=RIGHT pointer\\n        output.push(Math.min(Math.abs(j-ind[now-1]), Math.abs(j-ind[now])));\\n    }\\n    return output;\\n};\\n```\n```\\ns=loveleetcode, c=\"e\"\\n            l o v e l e e t c o d e\\nfrom left   X X X 0 1 0 0 1 2 3 4 0\\nfrom right  3 2 1 0 1 0 0 4 3 2 1 0\\nMIN         3 2 1 0 1 0 0 1 2 2 1 0\\n```\n```\\nvar shortestToChar = function(s, c) {\\n    let output=[], dis=Infinity;\\n    for(let i=0; i<s.length; i++){\\n        dis=s[i]==c? 0: ++dis;\\n        output.push(dis);\\n    }\\n    dis=Infinity;\\n    for(let j=s.length-1; j>=0; j--){\\n        dis=s[j]==c? 0: ++dis;\\n\\t\\t// compare MIN of dis(left) & dis(right)\\n        output[j]=Math.min(dis, output[j]);\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2107104,
                "title": "821-shortest-distance-to-a-character-array-java-solution",
                "content": "Hi, in this problem i follow below steps :------>\\n\\n*First create a list to store the location of character c in given array.\\n*Create an array for result and the traverse again the array and calculate the minimum distance using created list. See Below Code ---->\\n\\nHappy Coding :)\\n\\nCODE ------>\\n\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        int n = s.length();\\n        \\n        list.add(-10000);\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i)==c){\\n                list.add(i);\\n            }\\n        }\\n        list.add(10000);\\n        \\n        int first = list.get(0);\\n        int second = list.get(1);\\n        int j = 2;\\n        int[] res = new int[n];\\n        \\n        for (int i=0; i<n; i++){\\n            if(s.charAt(i)!=c){\\n                res[i] = Math.min(i-first, second-i);\\n            }else{\\n                first = second;\\n                second = list.get(j++);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list = new ArrayList<>();\\n        int n = s.length();\\n        \\n        list.add(-10000);\\n        for (int i=0; i<n; i++){\\n            if (s.charAt(i)==c){\\n                list.add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2078271,
                "title": "java-1ms-99-09",
                "content": "```\\nclass Solution {\\n    int getIndex(String s, char c, int start){\\n        for(int i = start;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        int prev = getIndex(s, c, 0);\\n        int next = prev;\\n        \\n        for (int k = 0; k<s.length(); k++){\\n            ans[k] = Math.min(Math.abs(k-prev), Math.abs(next-k));\\n            if(next==k){\\n                prev = next;\\n                next = getIndex(s,c,k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    int getIndex(String s, char c, int start){\\n        for(int i = start;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public int[] shortestToChar(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        int prev = getIndex(s, c, 0);\\n        int next = prev;\\n        \\n        for (int k = 0; k<s.length(); k++){\\n            ans[k] = Math.min(Math.abs(k-prev), Math.abs(next-k));\\n            if(next==k){\\n                prev = next;\\n                next = getIndex(s,c,k+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025617,
                "title": "java-too-easy-solution",
                "content": "//do upvote :)\\n\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int ans[]=new int[s.length()];\\n        ArrayList<Integer> li=new ArrayList<>();\\n        //Store the index of the character\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                li.add(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<li.size();j++){\\n                int x=Math.abs(i-li.get(j));\\n                if(x<min){\\n                    min=x;\\n                }\\n            }\\n            ans[i]=min;\\n        }\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int ans[]=new int[s.length()];\\n        ArrayList<Integer> li=new ArrayList<>();\\n        //Store the index of the character\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==c){\\n                li.add(i);\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            int min=Integer.MAX_VALUE;\\n            for(int j=0;j<li.size();j++){\\n                int x=Math.abs(i-li.get(j));\\n                if(x<min){\\n                    min=x;\\n                }\\n            }\\n            ans[i]=min;\\n        }\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2022757,
                "title": "it-s-beginner-s-thinking",
                "content": "\\tc_index = [i for i, value in enumerate(list(s)) if value == c]\\n\\tanswer = []\\n\\tfor i in range(len(s)):\\n\\t\\ttemp = []\\n\\t\\tfor j in c_index:\\n\\t\\t\\ttemp.append(abs(i - j))\\n\\t\\tanswer.append(min(temp))\\n\\treturn answer",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tc_index = [i for i, value in enumerate(list(s)) if value == c]\\n\\tanswer = []\\n\\tfor i in range(len(s)):\\n\\t\\ttemp = []\\n\\t\\tfor j in c_index:\\n\\t\\t\\ttemp.append(abs(i - j))\\n\\t\\tanswer.append(min(temp))\\n\\treturn answer",
                "codeTag": "Unknown"
            },
            {
                "id": 1973716,
                "title": "scan-twice-easy-to-read",
                "content": "Below was my thought process although I could not find optimized solution at once\\n\\nto find closet distance\\n1. init array with maximum distance of len(n)\\n2. scan left to right find distance and store previous occurence index\\n3. scan right to left and store previous occurence index\\n\\n```\\n public int[] shortestToChar(String s, char c) {\\n        int n=s.length();\\n        int[] res= new int[n];\\n        Arrays.fill(res,n);\\n        int prev=-n;\\n        \\n        for(int i=0;i<n;i++){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n                \\n        for(int i=n-1;i>=0;i--){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n        \\n        return res;\\n    }\\n\\t\\n\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] shortestToChar(String s, char c) {\\n        int n=s.length();\\n        int[] res= new int[n];\\n        Arrays.fill(res,n);\\n        int prev=-n;\\n        \\n        for(int i=0;i<n;i++){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n                \\n        for(int i=n-1;i>=0;i--){\\n            char r=s.charAt(i);\\n            if(r==c){\\n                res[i]=0;\\n                prev=i;\\n            }else{\\n                res[i]=Math.min(res[i],Math.abs(prev-i));\\n            }            \\n        }\\n        \\n        return res;\\n    }\\n\\t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929483,
                "title": "c-simple-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len = s.size();\\n        vector<int> ans(len , INT_MAX);\\n        int pos = -1;\\n        \\n        for(int i = 0 ; i<len ; i++){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = (i-pos);\\n            }\\n        }\\n            pos = -1;\\n        \\n        \\n        for(int i = len-1 ; i>=0 ; i--){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = min(ans[i] , (pos-i));\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int len = s.size();\\n        vector<int> ans(len , INT_MAX);\\n        int pos = -1;\\n        \\n        for(int i = 0 ; i<len ; i++){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = (i-pos);\\n            }\\n        }\\n            pos = -1;\\n        \\n        \\n        for(int i = len-1 ; i>=0 ; i--){\\n            if(s[i] == c){\\n                pos = i;\\n            }\\n            if(pos != -1){\\n                ans[i] = min(ans[i] , (pos-i));\\n            }\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830996,
                "title": "javascript-straight-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   const arr = s.split(\"\")\\n   let count = 0;\\n   const answer = []\\n    const newArr = arr.map( (item, index) => {\\n        if(item === c) { \\n            count = count + 1;\\n           return arr[index] = count\\n        }else { \\n            return arr[index] = item\\n        }\\n    })\\n    \\n    for(let i=0; i<arr.length; i++) { \\n        let min = 0;\\n        for(let j=1; j<=count;j++) {\\n            const index = newArr.indexOf(j)\\n            const distance = Math.abs(i - index);\\n            if( arr[i] === j) { \\n                min = 0;\\n                break;\\n            }else if(distance < min || min ===0) { \\n                min = distance\\n            }\\n        }\\n        answer.push(min)\\n        \\n    }\\n    \\n    return answer\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   const arr = s.split(\"\")\\n   let count = 0;\\n   const answer = []\\n    const newArr = arr.map( (item, index) => {\\n        if(item === c) { \\n            count = count + 1;\\n           return arr[index] = count\\n        }else { \\n            return arr[index] = item\\n        }\\n    })\\n    \\n    for(let i=0; i<arr.length; i++) { \\n        let min = 0;\\n        for(let j=1; j<=count;j++) {\\n            const index = newArr.indexOf(j)\\n            const distance = Math.abs(i - index);\\n            if( arr[i] === j) { \\n                min = 0;\\n                break;\\n            }else if(distance < min || min ===0) { \\n                min = distance\\n            }\\n        }\\n        answer.push(min)\\n        \\n    }\\n    \\n    return answer\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816678,
                "title": "c-simple-solution",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx)    dist = min(dist, abs(d - i));\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        vector<int> idx;\\n        int N = s.length();\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] == c)\\n                idx.push_back(i);\\n        }\\n        vector<int> res(N, 0);\\n        for (int i = 0; i < N; i++) {\\n            if (s[i] != c) {\\n                int dist = INT_MAX;\\n                for (int d: idx)    dist = min(dist, abs(d - i));\\n                res[i] = dist;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748946,
                "title": "c-two-pointer-approach",
                "content": "```\\n\\n\\n public int[] ShortestToChar(string s, char c) {\\n\\n    if (s == null || s == \"\" || c == null) {\\n      return new int[] {\\n        0\\n      };\\n    }\\n\\n    int[] values = new int[s.Length];\\n\\n    int l = 0, r = 0, n = s.Length, short_dist_sofar = 0, curr_dist_sofar = 0;\\n    int visitcount = 0;\\n\\n    while (r < n) {\\n      if (s[r] == c) {\\n        curr_dist_sofar = r;\\n        short_dist_sofar = (short_dist_sofar == 0 && visitcount == 0) ? r : short_dist_sofar;\\n        while (l <= r) {\\n          int prev_dist = Math.Abs(l - short_dist_sofar);\\n          int curr_dist = Math.Abs(l - curr_dist_sofar);\\n          int min_dist = Math.Min(prev_dist, curr_dist);\\n          values[l] = min_dist;\\n          short_dist_sofar = (l == r) ? curr_dist_sofar : short_dist_sofar;\\n          l++;\\n          visitcount++;\\n        }\\n      }\\n      r++;\\n    }\\n\\n    while (visitcount < n) {\\n      values[visitcount] = Math.Abs(visitcount - short_dist_sofar);\\n      visitcount++;\\n    }\\n\\n    return values;\\n  }\\n\\n```\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n\\n\\n public int[] ShortestToChar(string s, char c) {\\n\\n    if (s == null || s == \"\" || c == null) {\\n      return new int[] {\\n        0\\n      };\\n    }\\n\\n    int[] values = new int[s.Length];\\n\\n    int l = 0, r = 0, n = s.Length, short_dist_sofar = 0, curr_dist_sofar = 0;\\n    int visitcount = 0;\\n\\n    while (r < n) {\\n      if (s[r] == c) {\\n        curr_dist_sofar = r;\\n        short_dist_sofar = (short_dist_sofar == 0 && visitcount == 0) ? r : short_dist_sofar;\\n        while (l <= r) {\\n          int prev_dist = Math.Abs(l - short_dist_sofar);\\n          int curr_dist = Math.Abs(l - curr_dist_sofar);\\n          int min_dist = Math.Min(prev_dist, curr_dist);\\n          values[l] = min_dist;\\n          short_dist_sofar = (l == r) ? curr_dist_sofar : short_dist_sofar;\\n          l++;\\n          visitcount++;\\n        }\\n      }\\n      r++;\\n    }\\n\\n    while (visitcount < n) {\\n      values[visitcount] = Math.Abs(visitcount - short_dist_sofar);\\n      visitcount++;\\n    }\\n\\n    return values;\\n  }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715270,
                "title": "java-solution",
                "content": "```class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0; i< s.length();i++){\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }\\n        int j=0;\\n        int k=0;\\n        List<Integer> list2=new ArrayList<>();\\n        while(j < s.length()){\\n            if(k==0){\\n                list2.add(Math.abs(list.get(k)-j));\\n            }\\n            else{\\n                int val1=Math.abs(list.get(k-1)-j);\\n                int val2=Math.abs(list.get(k)-j);\\n                if(val1 < val2)\\n                    list2.add(val1);\\n                else\\n                    list2.add(val2);\\n            }\\n            if(j==list.get(k) && k < list.size()-1)\\n                k++;\\n            j++;\\n        }\\n        int[] result=new int[list2.size()];\\n        int i=0;\\n        for(int ele:list2)\\n            result[i++]=ele;\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=0; i< s.length();i++){\\n            if(s.charAt(i)==c)\\n                list.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1706047,
                "title": "java-using-a-list-to-store-indexes-of-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len=s.length();\\n        int[] ans=new int[len];\\n        List<Integer> list=new ArrayList();\\n        for(int i=0;i<len;i++)\\n        {\\n            if(s.charAt(i)==c)\\n            {\\n                list.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(j==0)\\n                ans[i]=Math.abs(list.get(j)-i);\\n            else\\n                ans[i]=Math.min(Math.abs(list.get(j-1)-i),Math.abs(list.get(j)-i));\\n            if(ans[i]==0 && j<list.size()-1)\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int len=s.length();\\n        int[] ans=new int[len];\\n        List<Integer> list=new ArrayList();\\n        for(int i=0;i<len;i++)\\n        {\\n            if(s.charAt(i)==c)\\n            {\\n                list.add(i);\\n            }\\n        }\\n        int j=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(j==0)\\n                ans[i]=Math.abs(list.get(j)-i);\\n            else\\n                ans[i]=Math.min(Math.abs(list.get(j-1)-i),Math.abs(list.get(j)-i));\\n            if(ans[i]==0 && j<list.size()-1)\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704001,
                "title": "java-simple-easy",
                "content": "```\\n    public int[] shortestToChar(String s, char c) {\\n        char[] arr = s.toCharArray();\\n        int[] result = new int[s.length()];\\n        \\n        int first = Integer.MAX_VALUE;\\n        int second = Integer.MAX_VALUE;\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            for (int j=i; j<s.length(); j++) {\\n                if (arr[j] == c && first == Integer.MAX_VALUE) {\\n                    first = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            for (int j=i; j>=0; j--) {\\n                if (arr[j] == c && second == Integer.MAX_VALUE) {\\n                    second = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            result[i] = Math.min(first, second);\\n            first = Integer.MAX_VALUE;\\n            second = Integer.MAX_VALUE;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] shortestToChar(String s, char c) {\\n        char[] arr = s.toCharArray();\\n        int[] result = new int[s.length()];\\n        \\n        int first = Integer.MAX_VALUE;\\n        int second = Integer.MAX_VALUE;\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            for (int j=i; j<s.length(); j++) {\\n                if (arr[j] == c && first == Integer.MAX_VALUE) {\\n                    first = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            for (int j=i; j>=0; j--) {\\n                if (arr[j] == c && second == Integer.MAX_VALUE) {\\n                    second = Math.abs(j - i);\\n                    break;\\n                } \\n            }\\n            result[i] = Math.min(first, second);\\n            first = Integer.MAX_VALUE;\\n            second = Integer.MAX_VALUE;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678713,
                "title": "cpp-soln",
                "content": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n      vector<int> ans;\\n      vector<int> v;\\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==c)\\n          v.push_back(i);\\n      }\\n      \\n      \\n      \\n      for(int j=0;j<s.size();j++)\\n      {\\n        int t,l=100000;\\n        for(int k=0;k<v.size();k++)\\n        {\\n          \\n          t=abs(j-v[k]);\\n          l=min(l,t);\\n          \\n        }\\n        ans.push_back(l);\\n        \\n      }\\n      \\n   return ans;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        \\n      vector<int> ans;\\n      vector<int> v;\\n      for(int i=0;i<s.size();i++)\\n      {\\n        if(s[i]==c)\\n          v.push_back(i);\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1650522,
                "title": "100-fast-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n         vector<int> res(s.length(),INT_MAX);\\n        \\n         int pos = -1;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(s[i] == c)\\n             {\\n                 pos = i;\\n                 res[i] = 0;\\n             }\\n             \\n             if(pos !=-1 && abs(i-pos) < res[i])\\n                 res[i] = abs(i-pos);\\n         }\\n        \\n        \\n        for(int i=s.length() - 1;i>=0 ;i--)\\n        {\\n            if(s[i] == c)\\n            {\\n                pos = i;\\n            }\\n            if(res[i] > abs(pos - i))\\n                res[i] = abs(pos -i);\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n         vector<int> res(s.length(),INT_MAX);\\n        \\n         int pos = -1;\\n         for(int i=0;i<s.length();i++)\\n         {\\n             if(s[i] == c)\\n             {\\n                 pos = i;\\n                 res[i] = 0;\\n             }\\n             \\n             if(pos !=-1 && abs(i-pos) < res[i])\\n                 res[i] = abs(i-pos);\\n         }\\n        \\n        \\n        for(int i=s.length() - 1;i>=0 ;i--)\\n        {\\n            if(s[i] == c)\\n            {\\n                pos = i;\\n            }\\n            if(res[i] > abs(pos - i))\\n                res[i] = abs(pos -i);\\n        }\\n        \\n        \\n        return res;\\n        \\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643399,
                "title": "c-faster-than-100-of-solutions",
                "content": "```\\n// simple solution just need to keep track of \\n// nearest left and nearest right done using 2\\n// ask me in comments if you have any query \\n// will try my best \\n// please upvote !!!\\n\\n  vector<int> shortestToChar(string s, char c) \\n    {\\n       int l=0,r=0,i=0,n=s.length();\\n        vector<int>ans(n);\\n      \\n        while(i<s.length())\\n        {      \\n            if(s[i]==c)\\n            {   \\n                l=i;\\n                r=i+1;\\n            }\\n             while(r<n && s[r]!=c) r++;\\n             while(l<n && s[l]!=c) l++;\\n         \\n            if(r==n) r=INT_MAX;\\n            ans[i]=min(abs(l-i),abs(r-i));\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n// simple solution just need to keep track of \\n// nearest left and nearest right done using 2\\n// ask me in comments if you have any query \\n// will try my best \\n// please upvote !!!\\n\\n  vector<int> shortestToChar(string s, char c) \\n    {\\n       int l=0,r=0,i=0,n=s.length();\\n        vector<int>ans(n);\\n      \\n        while(i<s.length())\\n        {      \\n            if(s[i]==c)\\n            {   \\n                l=i;\\n                r=i+1;\\n            }\\n             while(r<n && s[r]!=c) r++;\\n             while(l<n && s[l]!=c) l++;\\n         \\n            if(r==n) r=INT_MAX;\\n            ans[i]=min(abs(l-i),abs(r-i));\\n            i++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1619364,
                "title": "python-simple-solution-with-help-of-list-comprehension",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        s = list(s)\\n        x = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                s[i] = 0\\n                x.append(i)\\n        for i in range(len(s)):\\n            s[i] = min([abs(j-i) for j in x])\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        s = list(s)\\n        x = []\\n        for i in range(len(s)):\\n            if s[i] == c:\\n                s[i] = 0\\n                x.append(i)\\n        for i in range(len(s)):\\n            s[i] = min([abs(j-i) for j in x])\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618164,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                count++;\\n            }\\n        } \\n        int[] array = new int[count];\\n        \\n        int j = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                array[j] = i;\\n                j++;\\n            }\\n        }\\n        \\n        \\n        int[] answer = new int[s.length()];\\n        int k = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            \\n            if(s.charAt(i) != c){\\n                if(k > 0){\\n                    answer[i] = Math.min(Math.abs(array[k] - i), Math.abs(array[k-1] - i));\\n                }\\n                else{\\n                    answer[i] = Math.abs(array[k] - i);\\n                }\\n            }\\n            else if(s.charAt(i) == c){\\n                answer[i] = 0;\\n                if(k < array.length-1){\\n                    k++;   \\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int count = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                count++;\\n            }\\n        } \\n        int[] array = new int[count];\\n        \\n        int j = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == c){\\n                array[j] = i;\\n                j++;\\n            }\\n        }\\n        \\n        \\n        int[] answer = new int[s.length()];\\n        int k = 0;\\n        for(int i = 0; i < s.length(); i++){\\n            \\n            if(s.charAt(i) != c){\\n                if(k > 0){\\n                    answer[i] = Math.min(Math.abs(array[k] - i), Math.abs(array[k-1] - i));\\n                }\\n                else{\\n                    answer[i] = Math.abs(array[k] - i);\\n                }\\n            }\\n            else if(s.charAt(i) == c){\\n                answer[i] = 0;\\n                if(k < array.length-1){\\n                    k++;   \\n                }\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616196,
                "title": "c-two-pointer-easy-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int start = 0,end= 0;\\n        int len = s.size();\\n        vector<int> ans(len, INT_MAX);\\n        bool flag = 0;\\n        while(start <= end && end < len){\\n            if(flag){\\n                ans[end] = end-start+1;\\n            }\\n            while(start <= end && s[end] == c){\\n                flag = 1;\\n                ans[start] = min(ans[start],end-start);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please don\\'t forget to upvote.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int start = 0,end= 0;\\n        int len = s.size();\\n        vector<int> ans(len, INT_MAX);\\n        bool flag = 0;\\n        while(start <= end && end < len){\\n            if(flag){\\n                ans[end] = end-start+1;\\n            }\\n            while(start <= end && s[end] == c){\\n                flag = 1;\\n                ans[start] = min(ans[start],end-start);\\n                start++;\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603964,
                "title": "javascript-easy-to-understand",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   s = s.split(\\'\\')\\n  let position = []\\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          position.push(i)\\n      }\\n  }  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          s[i] = 0\\n      } else {\\n          let min = Infinity\\n          for(let j = 0; j < position.length; j++) {\\n              let num = position[j]\\n              if(Math.abs(num - i) < min) {\\n                  min = Math.abs(num - i)\\n              }\\n          }\\n          s[i] = min\\n      }\\n  }\\n\\n  return s\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {character} c\\n * @return {number[]}\\n */\\nvar shortestToChar = function(s, c) {\\n   s = s.split(\\'\\')\\n  let position = []\\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          position.push(i)\\n      }\\n  }  \\n  \\n  for(let i = 0; i < s.length; i++) {\\n      let letter = s[i]\\n      if(letter === c) {\\n          s[i] = 0\\n      } else {\\n          let min = Infinity\\n          for(let j = 0; j < position.length; j++) {\\n              let num = position[j]\\n              if(Math.abs(num - i) < min) {\\n                  min = Math.abs(num - i)\\n              }\\n          }\\n          s[i] = min\\n      }\\n  }\\n\\n  return s\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596687,
                "title": "python-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        from collections import defaultdict\\n        mydict=defaultdict(list)\\n        for i in range(len(s)):\\n            mydict[s[i]].append(i)\\n        \\n        res=[]\\n        for j in range(len(s)):\\n            if len(mydict[c])==1:\\n                res.append(abs(j-mydict[c][0]))\\n            else:\\n                mn=len(s)\\n                for val in mydict[c]:\\n                    mn=min(mn,abs(j-val))\\n                res.append(mn)\\n        \\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        from collections import defaultdict\\n        mydict=defaultdict(list)\\n        for i in range(len(s)):\\n            mydict[s[i]].append(i)\\n        \\n        res=[]\\n        for j in range(len(s)):\\n            if len(mydict[c])==1:\\n                res.append(abs(j-mydict[c][0]))\\n            else:\\n                mn=len(s)\\n                for val in mydict[c]:\\n                    mn=min(mn,abs(j-val))\\n                res.append(mn)\\n        \\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525508,
                "title": "c-easy-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> answer(s.length());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n                answer[i]=0;\\n            else\\n            {\\n                //left side\\n                int j=i-1;\\n                int left=0;\\n                bool leftflag=false;\\n                \\n                while(j>=0)\\n                {\\n                    if(s[j]==c)\\n                    {\\n                        leftflag=true;\\n                        left++;\\n                        break;\\n                    }\\n                    left++;\\n                    j--;\\n                }\\n                //right side\\n                bool rightflag=false;\\n                int k=i+1;\\n                int right=0;\\n                while(k<s.length())\\n                {\\n                    if(s[k]==c)\\n                    {\\n                        rightflag=true;\\n                        right++;\\n                        break;\\n                    }\\n                    right++;\\n                    k++;\\n                }\\n                if(leftflag==true && rightflag==true)\\n                    answer[i]=min(left,right);\\n                else if(leftflag==false && rightflag==true)\\n                {\\n                    answer[i]=right;\\n                }\\n                else if(rightflag==false && leftflag==true)\\n                {\\n                    answer[i]=left;\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) \\n    {\\n        vector<int> answer(s.length());\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==c)\\n                answer[i]=0;\\n            else\\n            {\\n                //left side\\n                int j=i-1;\\n                int left=0;\\n                bool leftflag=false;\\n                \\n                while(j>=0)\\n                {\\n                    if(s[j]==c)\\n                    {\\n                        leftflag=true;\\n                        left++;\\n                        break;\\n                    }\\n                    left++;\\n                    j--;\\n                }\\n                //right side\\n                bool rightflag=false;\\n                int k=i+1;\\n                int right=0;\\n                while(k<s.length())\\n                {\\n                    if(s[k]==c)\\n                    {\\n                        rightflag=true;\\n                        right++;\\n                        break;\\n                    }\\n                    right++;\\n                    k++;\\n                }\\n                if(leftflag==true && rightflag==true)\\n                    answer[i]=min(left,right);\\n                else if(leftflag==false && rightflag==true)\\n                {\\n                    answer[i]=right;\\n                }\\n                else if(rightflag==false && leftflag==true)\\n                {\\n                    answer[i]=left;\\n                }\\n            }\\n        }\\n        return answer;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456750,
                "title": "two-pass-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int[] res = new int[s.length()];\\n        Arrays.fill(res, Integer.MAX_VALUE); // all the distances are MAX for initilization\\n        int pos = -1; // if we haven\\'t seen c yet, mark it as -1\\n        \\n        // after each c, update distance\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) {\\n                pos = i;\\n                res[i] = 0;\\n            }\\n            else if (pos != -1 && chars[i] != c) {\\n                res[i] = Math.abs(i - pos);\\n            }\\n        }\\n        // before each c, update distance\\n        for (int i = chars.length - 1; i >= 0; i--) {\\n            if (chars[i] == c) {\\n                pos = i;\\n            }\\n            else {\\n                res[i] = Math.min(res[i], Math.abs(i - pos));\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        \\n        int[] res = new int[s.length()];\\n        Arrays.fill(res, Integer.MAX_VALUE); // all the distances are MAX for initilization\\n        int pos = -1; // if we haven\\'t seen c yet, mark it as -1\\n        \\n        // after each c, update distance\\n        char[] chars = s.toCharArray();\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) {\\n                pos = i;\\n                res[i] = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1431570,
                "title": "java-easy-solution-o-n-time",
                "content": "\\n    public int[] shortestToChar(String s, char c) {\\n        int[] res = new int[s.length()];\\n        int dist = 0;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0)\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        for (int i = s.length() - 1; i >= 0 ; i--)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0 && (res[i] == 0  || dist < res[i]))\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int[] shortestToChar(String s, char c) {\\n        int[] res = new int[s.length()];\\n        int dist = 0;\\n        \\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0)\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        for (int i = s.length() - 1; i >= 0 ; i--)\\n        {\\n            if (s.charAt(i) == c)\\n            {\\n                dist = 0;\\n                res[i] = dist++;\\n            }\\n            else if (dist > 0 && (res[i] == 0  || dist < res[i]))\\n            {\\n                res[i] = dist++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1430002,
                "title": "intuitive-approach-c",
                "content": "\\n \\n \\n \\n \\n \\n \\n \\n vector<int> ans;\\n    vector<int> v;\\n    for(int i=0;i<s.length();i++)\\n    {\\n        if(s[i]==c)\\n            v.push_back(i);\\n    }\\n    \\n    for(int i =0;i<s.length();i++)\\n    {\\n        int mindist = INT_MAX;\\n        for(int x =0;x<size(v);x++)\\n        {\\n            mindist = min(mindist,abs(i-v[x]));\\n        }\\n        ans.push_back(mindist);\\n    }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n \\n \\n \\n \\n \\n \\n \\n vector<int> ans;\\n    vector<int> v;\\n    for(int i=0;i<s.length();i++)\\n    {\\n        if(s[i]==c)\\n            v.push_back(i);\\n    }\\n    \\n    for(int i =0;i<s.length();i++)\\n    {\\n        int mindist = INT_MAX;\\n        for(int x =0;x<size(v);x++)\\n        {\\n            mindist = min(mindist,abs(i-v[x]));\\n        }\\n        ans.push_back(mindist);\\n    }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1402373,
                "title": "java-2-pass-solution-o-n-time",
                "content": "**Runtime: 2 ms\\nMemory Usage: 39.8 MB**\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int res[] = new int[s.length()];\\n        int idx = -1;\\n        \\n        //left scan \\n        for(int i = 0;i< s.length();i++){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx == -1)res[i] = Integer.MAX_VALUE;\\n            else res[i] = Math.abs(idx - i);\\n        }\\n        \\n        //right scan\\n        idx = -1;\\n        for(int i = s.length() - 1;i>=0;i--){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx != -1)res[i] = Math.min(res[i],Math.abs(i - idx));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n**Time Complexity : 2*O(N) -> O(N)\\nSpace Complexity : O(N) (for output)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        int res[] = new int[s.length()];\\n        int idx = -1;\\n        \\n        //left scan \\n        for(int i = 0;i< s.length();i++){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx == -1)res[i] = Integer.MAX_VALUE;\\n            else res[i] = Math.abs(idx - i);\\n        }\\n        \\n        //right scan\\n        idx = -1;\\n        for(int i = s.length() - 1;i>=0;i--){\\n            if(s.charAt(i) == c)idx = i;\\n            if(idx != -1)res[i] = Math.min(res[i],Math.abs(i - idx));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394746,
                "title": "2-pointers-java-scan-for-occurrences-easy",
                "content": "**Flow**\\n1. scan for occurrences of char c\\n2. Then init pointer current \\n3. Compare abs for pointer and nextPointer for each char a \\n4. If next is smaller then increase pointer\\n! Also check for out of bounds if so just place asb for current pointer no need for the next one \\n\\n\\n ```\\n        char[] chars = s.toCharArray();\\n        int[] result = new int[chars.length];\\n        List<Integer> occurrences = new ArrayList<>();\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) occurrences.add(i);\\n        }\\n\\n        int curOcIndx = 0;\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            Integer curOcr = occurrences.get(curOcIndx);\\n            if (curOcIndx+1 < occurrences.size()) {\\n                Integer nextOcr = occurrences.get(curOcIndx+1);\\n                if (Math.abs(curOcr - i) < Math.abs(nextOcr - i)) {\\n                    result[i] = Math.abs(curOcr - i);\\n                } else {\\n                    result[i] = Math.abs(nextOcr - i);\\n                    curOcIndx++;\\n                }\\n            } else result[i] = Math.abs(curOcr - i);\\n        }\\n        return result;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n        char[] chars = s.toCharArray();\\n        int[] result = new int[chars.length];\\n        List<Integer> occurrences = new ArrayList<>();\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            if (chars[i] == c) occurrences.add(i);\\n        }\\n\\n        int curOcIndx = 0;\\n\\n        for (int i = 0; i < chars.length; i++) {\\n            Integer curOcr = occurrences.get(curOcIndx);\\n            if (curOcIndx+1 < occurrences.size()) {\\n                Integer nextOcr = occurrences.get(curOcIndx+1);\\n                if (Math.abs(curOcr - i) < Math.abs(nextOcr - i)) {\\n                    result[i] = Math.abs(curOcr - i);\\n                } else {\\n                    result[i] = Math.abs(nextOcr - i);\\n                    curOcIndx++;\\n                }\\n            } else result[i] = Math.abs(curOcr - i);\\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382699,
                "title": "cpp-solution-faster-than-97-cpp-solutions-and-memory-consumption-less-than-98-8-cpp-solutions",
                "content": "vector<int> shortestToChar(string s, char c) {\\n        // naive approach:(faster)-----------------------------------\\n        vector<int>ans(s.length(),100000);\\n        vector<int>index;\\n        for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        for(int i = 0;i<s.length();i++)if(s[i] == c) ans[i] = 0;\\n            else \\n                for(int j = 0;j<index.size();j++)\\n                  ans[i] = min(ans[i],abs(i-index[j]));\\n        return ans;\\n        // binary search using lower_bound:(slower)-------------------\\n        // vector<int>ans(s.length());\\n        // vector<int>index;\\n        // for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        // for(int i = 0;i<s.length();i++){\\n        //     if(s[i] == c){\\n        //         ans[i] = 0;\\n        //         continue;\\n        //     }\\n        //     int x  =lower_bound(index.begin(),index.end(),i)-index.begin();\\n        //     if(x == index.size() or x == 0)\\n        //         ans[i] = abs(index[x]-i);\\n        //     else ans[i] = min(abs(index[x]-i),abs(index[x-1]-i));\\n        // }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<int> shortestToChar(string s, char c) {\\n        // naive approach:(faster)-----------------------------------\\n        vector<int>ans(s.length(),100000);\\n        vector<int>index;\\n        for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        for(int i = 0;i<s.length();i++)if(s[i] == c) ans[i] = 0;\\n            else \\n                for(int j = 0;j<index.size();j++)\\n                  ans[i] = min(ans[i],abs(i-index[j]));\\n        return ans;\\n        // binary search using lower_bound:(slower)-------------------\\n        // vector<int>ans(s.length());\\n        // vector<int>index;\\n        // for(int i = 0;i<s.length();i++)if(s[i] == c)index.push_back(i);\\n        // for(int i = 0;i<s.length();i++){\\n        //     if(s[i] == c){\\n        //         ans[i] = 0;\\n        //         continue;\\n        //     }\\n        //     int x  =lower_bound(index.begin(),index.end(),i)-index.begin();\\n        //     if(x == index.size() or x == 0)\\n        //         ans[i] = abs(index[x]-i);\\n        //     else ans[i] = min(abs(index[x]-i),abs(index[x-1]-i));\\n        // }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1379201,
                "title": "c-binary-search-o-nlogm-0ms-beats-100",
                "content": "Make an array store all the presence of c in it,after that use binary search to find the shortest distance\\n```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> vec;\\n        vec.push_back(INT_MIN);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==c){\\n                vec.push_back(i);\\n            }\\n        }\\n        vec.push_back(INT_MAX);\\n     \\n        if(vec.size()==2){\\n            return {};\\n        }\\n        else{\\n            vector<int> nums;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==c){\\n                    nums.push_back(0);\\n                    continue;\\n                }\\n                auto x=lower_bound(vec.begin(),vec.end(),i);\\n                int lb=x-vec.begin();\\n                lb--;\\n                auto y=upper_bound(vec.begin(),vec.end(),i);\\n                int ub=y-vec.begin();\\n                if(vec[lb]==INT_MIN){\\n                    nums.push_back(min(*x-0,abs(vec[ub]-i)));\\n                }\\n                else if(vec[ub]==INT_MAX){\\n                    nums.push_back(abs(i-vec[lb]));\\n                }\\n                else{\\n                    nums.push_back(min(abs(i-vec[lb]),abs(vec[ub]-i)));\\n                }\\n            }\\n            return nums;   \\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n vector<int> shortestToChar(string s, char c) {\\n        vector<int> vec;\\n        vec.push_back(INT_MIN);\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==c){\\n                vec.push_back(i);\\n            }\\n        }\\n        vec.push_back(INT_MAX);\\n     \\n        if(vec.size()==2){\\n            return {};\\n        }\\n        else{\\n            vector<int> nums;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==c){\\n                    nums.push_back(0);\\n                    continue;\\n                }\\n                auto x=lower_bound(vec.begin(),vec.end(),i);\\n                int lb=x-vec.begin();\\n                lb--;\\n                auto y=upper_bound(vec.begin(),vec.end(),i);\\n                int ub=y-vec.begin();\\n                if(vec[lb]==INT_MIN){\\n                    nums.push_back(min(*x-0,abs(vec[ub]-i)));\\n                }\\n                else if(vec[ub]==INT_MAX){\\n                    nums.push_back(abs(i-vec[lb]));\\n                }\\n                else{\\n                    nums.push_back(min(abs(i-vec[lb]),abs(vec[ub]-i)));\\n                }\\n            }\\n            return nums;   \\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352511,
                "title": "100-faster-java-2-pass-solution",
                "content": "```\\n public static int[] shortestToChar2Pass(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        char[] arr = s.toCharArray();\\n        int pos = -arr.length;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; i--) {\\n            if (arr[i] == c) pos = i;\\n            if (pos - i < ans[i]) {\\n                ans[i] = pos - i;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public static int[] shortestToChar2Pass(String s, char c) {\\n        int[] ans = new int[s.length()];\\n        char[] arr = s.toCharArray();\\n        int pos = -arr.length;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (arr[i] == c) pos = i;\\n            ans[i] = i - pos;\\n        }\\n        for (int i = pos - 1; i >= 0; i--) {\\n            if (arr[i] == c) pos = i;\\n            if (pos - i < ans[i]) {\\n                ans[i] = pos - i;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1349618,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        //c[ l o, v, e, l, e, e, t, c, o, d, e]\\n        //t[ 0, 1, 2,3 ,4, 5, 6, 7, 8, 9, 10, 11]\\n        //   i\\n        //v[3, 5, 6, 11]\\n        //  iB jF\\n        vector<int> v, ans;\\n        int m = s.size();\\n        for(int i = 0; i<m; i++)\\n            if(s[i] == c)\\n                v.push_back(i);\\n        int  n = v.size();\\n        int iB = 0, iF = 1;\\n        for(int i = 0; i<m; i++ ){\\n            if(iF<n){\\n                ans.push_back(min(abs(i-  v[iB]), abs(v[iF]- i)));\\n                if(abs(i-  v[iB])>= abs(v[iF]- i)){\\n                    iF++;\\n                    iB++;\\n                }\\n            }\\n            else\\n                ans.push_back(abs(i- v[iB]));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        //c[ l o, v, e, l, e, e, t, c, o, d, e]\\n        //t[ 0, 1, 2,3 ,4, 5, 6, 7, 8, 9, 10, 11]\\n        //   i\\n        //v[3, 5, 6, 11]\\n        //  iB jF\\n        vector<int> v, ans;\\n        int m = s.size();\\n        for(int i = 0; i<m; i++)\\n            if(s[i] == c)\\n                v.push_back(i);\\n        int  n = v.size();\\n        int iB = 0, iF = 1;\\n        for(int i = 0; i<m; i++ ){\\n            if(iF<n){\\n                ans.push_back(min(abs(i-  v[iB]), abs(v[iF]- i)));\\n                if(abs(i-  v[iB])>= abs(v[iF]- i)){\\n                    iF++;\\n                    iB++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1337089,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp=[]\\n        result =[]\\n        for char in range(len(s)):\\n            if s[char]==c:\\n                temp.append(char)\\n        for j in range(len(s)):\\n            result.append(min(list(map(lambda x:abs(x-j), temp))))\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        temp=[]\\n        result =[]\\n        for char in range(len(s)):\\n            if s[char]==c:\\n                temp.append(char)\\n        for j in range(len(s)):\\n            result.append(min(list(map(lambda x:abs(x-j), temp))))\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332255,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        char chr[]=s.toCharArray();\\n        int len=s.length();\\n        int ans[]=new int[len];\\n        \\n        for(int i=0; i<len; i++)\\n        {\\n            if(chr[i]==c)\\n            {\\n                ans[i]=0;\\n                continue;\\n            }\\n            int shortestDist=Integer.MAX_VALUE;\\n            for(int j=0; j<len; j++)\\n            {\\n                if(chr[j]==c)\\n                {\\n                    int dist = Math.abs(i-j);\\n                    if(dist < shortestDist)\\n                        shortestDist=dist;\\n                    else if(dist > shortestDist)\\n                        break;\\n                }\\n            }\\n            ans[i]=shortestDist;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n// By Arindam Ghosh\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) \\n    {\\n        char chr[]=s.toCharArray();\\n        int len=s.length();\\n        int ans[]=new int[len];\\n        \\n        for(int i=0; i<len; i++)\\n        {\\n            if(chr[i]==c)\\n            {\\n                ans[i]=0;\\n                continue;\\n            }\\n            int shortestDist=Integer.MAX_VALUE;\\n            for(int j=0; j<len; j++)\\n            {\\n                if(chr[j]==c)\\n                {\\n                    int dist = Math.abs(i-j);\\n                    if(dist < shortestDist)\\n                        shortestDist=dist;\\n                    else if(dist > shortestDist)\\n                        break;\\n                }\\n            }\\n            ans[i]=shortestDist;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n// By Arindam Ghosh\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302503,
                "title": "c-2-approaches-using-map-without-map-2-pass",
                "content": "```\\n//Approach-1 (Using map)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        map<char, vector<int>> mp;\\n        int n = s.length();\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                mp[c].push_back(i); //store all indices of char c\\n        }\\n        \\n        \\n            \\n        vector<int> result(n, 0);\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] != c) {\\n                int dis = INT_MAX;\\n                for(int &idx : mp[c]) {\\n                    dis = min(dis, abs(i-idx)); //find the best index which gives min distance\\n                }\\n                result[i] = dis;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Simple 2 pass solution)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n        vector<int> result(n, 0);\\n        int prev =  -10001;\\n        \\n\\t\\t//find closest to left\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = abs(i-prev);\\n        }\\n        \\n\\t\\t//Find closest to right and choose minimum from left and right\\n\\t\\tprev = 10001;\\n        for(int i = n-1; i>=0; i--) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = min(result[i], abs(prev-i));\\n        }       \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using map)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        map<char, vector<int>> mp;\\n        int n = s.length();\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                mp[c].push_back(i); //store all indices of char c\\n        }\\n        \\n        \\n            \\n        vector<int> result(n, 0);\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(s[i] != c) {\\n                int dis = INT_MAX;\\n                for(int &idx : mp[c]) {\\n                    dis = min(dis, abs(i-idx)); //find the best index which gives min distance\\n                }\\n                result[i] = dis;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Simple 2 pass solution)\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n        int n = s.length();\\n        vector<int> result(n, 0);\\n        int prev =  -10001;\\n        \\n\\t\\t//find closest to left\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = abs(i-prev);\\n        }\\n        \\n\\t\\t//Find closest to right and choose minimum from left and right\\n\\t\\tprev = 10001;\\n        for(int i = n-1; i>=0; i--) {\\n            if(s[i] == c)\\n                prev = i;\\n            result[i] = min(result[i], abs(prev-i));\\n        }       \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291395,
                "title": "solution-for-slow-learner-like-me-o-n2-solution-intuitive",
                "content": "I recently had this question at an interview and came up with this solution, suprisingly the interviewer gave me a pass. I was facing trouble reaching O(n) but was helped a lot to reach a similar solution as @lee215\\n\\n```\\npublic int[] shortestToCha1r(String s, char c) {\\n       \\n        // save position of c in arraylist\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i =0;i< s.length();i++)\\n        {   if(s.charAt(i)==c) {\\n                arr.add(i);\\n            }\\n        }\\n        \\n        int brr[] = new int[s.length()];\\n        for(int i =0;i<s.length();i++) {\\n            // cal shortest distance from i to nearest c\\n            int min=Integer.max;\\n            for(int j=0;j<arr.size();j++) {\\n                if(Math.abs(i-arr.get(j))<min) {\\n                    min= Math.abs(i-arr.get(j));\\n                }\\n            }\\n            brr[i]=min;\\n        }\\n    return brr;\\n    \\n    }\\n",
                "solutionTags": [],
                "code": "I recently had this question at an interview and came up with this solution, suprisingly the interviewer gave me a pass. I was facing trouble reaching O(n) but was helped a lot to reach a similar solution as @lee215\\n\\n```\\npublic int[] shortestToCha1r(String s, char c) {\\n       \\n        // save position of c in arraylist\\n        List<Integer> arr = new ArrayList<>();\\n        for(int i =0;i< s.length();i++)\\n        {   if(s.charAt(i)==c) {\\n                arr.add(i);\\n            }\\n        }\\n        \\n        int brr[] = new int[s.length()];\\n        for(int i =0;i<s.length();i++) {\\n            // cal shortest distance from i to nearest c\\n            int min=Integer.max;\\n            for(int j=0;j<arr.size();j++) {\\n                if(Math.abs(i-arr.get(j))<min) {\\n                    min= Math.abs(i-arr.get(j));\\n                }\\n            }\\n            brr[i]=min;\\n        }\\n    return brr;\\n    \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1265996,
                "title": "java-solution-in-10-lines-with-explanation",
                "content": "**Explanation** - We first create a TreeSet containing the positions of character c in string s. Then we iterate through all the indices of string s and find the nearest two values from the current position in the string using this set. One of these two values is less than the current position and the other greater. We calculate the difference of both from the current position. The lower one is the answer. We do this for all positions in the string.\\n```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        var posSet = IntStream.range(0,s.length()).filter(i -> s.charAt(i) == c)\\n            .collect(TreeSet<Integer>::new,TreeSet::add,TreeSet::addAll);\\n        \\n        return IntStream.range(0,s.length()).map(i -> {\\n            var floor = Objects.requireNonNullElse(posSet.floor(i), Integer.MAX_VALUE);\\n            var ceil  = Objects.requireNonNullElse(posSet.ceiling(i), Integer.MAX_VALUE);\\n            return Integer.min(Math.abs(floor - i), Math.abs(ceil - i));\\n        }).toArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shortestToChar(String s, char c) {\\n        var posSet = IntStream.range(0,s.length()).filter(i -> s.charAt(i) == c)\\n            .collect(TreeSet<Integer>::new,TreeSet::add,TreeSet::addAll);\\n        \\n        return IntStream.range(0,s.length()).map(i -> {\\n            var floor = Objects.requireNonNullElse(posSet.floor(i), Integer.MAX_VALUE);\\n            var ceil  = Objects.requireNonNullElse(posSet.ceiling(i), Integer.MAX_VALUE);\\n            return Integer.min(Math.abs(floor - i), Math.abs(ceil - i));\\n        }).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237231,
                "title": "python-o-n-simple-solution",
                "content": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # create answer list\\n        length = len(s)\\n        ans = [length] * length\\n        \\n        # work left to right        \\n        for i in range(length):\\n            if s[i]==c:\\n                ans[i]=0\\n            elif i > 0:\\n                ans[i]=ans[i-1] + 1\\n        \\n        # work right to left (using negative indexing)\\n        for i in range(1, length+1):\\n            if i > 1:\\n                ans[-i]=min(ans[-i+1] + 1, ans[-i])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestToChar(self, s: str, c: str) -> List[int]:\\n        # create answer list\\n        length = len(s)\\n        ans = [length] * length\\n        \\n        # work left to right        \\n        for i in range(length):\\n            if s[i]==c:\\n                ans[i]=0\\n            elif i > 0:\\n                ans[i]=ans[i-1] + 1\\n        \\n        # work right to left (using negative indexing)\\n        for i in range(1, length+1):\\n            if i > 1:\\n                ans[-i]=min(ans[-i+1] + 1, ans[-i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231753,
                "title": "c-1-o-n-optimized-brute-force-2-dp-based-o-n",
                "content": "**1. O(n) based optimized**\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        int lastPosC = -n;\\n        vector<int> ans(n, n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = i - lastPosC;\\n        }\\n        for (int i = lastPosC - 1; i >= 0; i--)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = min(lastPosC - i, ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2. DP BASED**\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = s[i] == c ? 0 : n;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = min(ans[i], ans[i - 1] + 1);\\n        }\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            ans[i] = min(ans[i], ans[i + 1] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        int lastPosC = -n;\\n        vector<int> ans(n, n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = i - lastPosC;\\n        }\\n        for (int i = lastPosC - 1; i >= 0; i--)\\n        {\\n            if (s[i] == c)\\n            {\\n                lastPosC = i;\\n            }\\n            ans[i] = min(lastPosC - i, ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string s, char c)\\n    {\\n        int n = s.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = s[i] == c ? 0 : n;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = min(ans[i], ans[i - 1] + 1);\\n        }\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            ans[i] = min(ans[i], ans[i + 1] + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1810314,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1972844,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1568015,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1662769,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2053090,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1955192,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1790666,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "This is not an easy question!\\n"
                    },
                    {
                        "username": "aaryakapoor10",
                        "content": "this should be categorized as a medium-level ques!"
                    },
                    {
                        "username": "vanderpuye",
                        "content": "I did not understand this question at all. Say we had an example \"abcde\" and we are given \\'C\\' as the char to search for are we looking at the shortest distance from the beginning to that character, from the end to that character, from another to that character? \\n\\nAnd I even got more confused when the problem description said the shortest distance \"FROM\" the character \\'e\\'.\\n\\nI could not figure out what that array corresponded to at all. Someone please explain."
                    },
                    {
                        "username": "sounakb377",
                        "content": "First of all the char can\\'t be \\'C\\'. It has to be a lower case alphabet, and it has to be present in the given string.\\n\\nSecondly, you need to find the shortest distance between every character in the string to the given char (WHICH IS PART OF THE SAME STRING). So for \"abcde\", \\'c\\', you\\'ll get [2,1,0,1,2].\\n\\nBecause, distance from \\'a\\' (index = 0) to \\'c\\' (nearest and only index = 2) is 2-0=2. From \\'b\\' (index = 1) to \\'c\\' (nearest and only index = 2) is 1-0=1. From \\'c\\' (index = 2) to \\'c\\' (nearest and only index = 2) is 2-2=0. And so on.\\n\\nHope this was helpful."
                    },
                    {
                        "username": "whatmansi",
                        "content": "1. using for loop that runs from i = 0 to i<string_size, find all those indexes where the given character is present & store them all in a vector indexes.\\n2. now use nested for loop that runs from i = 0 to i<string.size & j = 0 to j<indexes.size,  to find the absolute value & store all those value for particular index in a vector.\\n3. find the minimum value among all those stored values in 2nd step & delete all the elements from the 2nd step vector.\\n4. store this minimum value in new vector, all the values will be stored in this vector, return this vector."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "This solution should not recommended at all because of extra space and O(n^2) time complexity which is very bad."
                    },
                    {
                        "username": "Rebv18",
                        "content": "works, but O(n^2) is not ideal at all. plus extra memory is wasted with index vector"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "we can use treeset to store index of all occurences of 'c' then use the floor and ceiling methods to find closet distance . \n"
                    },
                    {
                        "username": "mochiball",
                        "content": "I was starting two pointers and expanding them outwards at each index. Worked for me but not optimal ! "
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "100% beat cpp!\\nclass Solution {\\npublic:\\n    vector<int> shortestToChar(string s, char c) {\\n       int n = s.size();\\n       vector<int> ans(s.size());\\n       int pos = -n;\\n       for(int i = 0 ; i<n ; i++){\\n           if(s[i]==c) pos =i;\\n           ans[i]=i-pos; \\n       } \\n       pos = 2*n;\\n       for(int i = n-1; i>=0 ; i--){\\n           if(s[i]==c) pos = i;\\n           ans[i]=min(ans[i],pos-i);\\n       }\\n       return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "playful-Cloud",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    }
]