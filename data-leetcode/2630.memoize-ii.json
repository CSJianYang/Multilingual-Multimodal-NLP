[
    {
        "title": "Memoize II",
        "question_content": "Given a function fn,&nbsp;return&nbsp;a&nbsp;memoized&nbsp;version of that function.\nA&nbsp;memoized&nbsp;function is a function that will never be called twice with&nbsp;the same inputs. Instead it will return&nbsp;a cached value.\nfn&nbsp;can be any function and there are no constraints on what type of values it accepts. Inputs are considered identical if they are&nbsp;=== to each other.\n&nbsp;\nExample 1:\n\nInput: \ngetInputs = () => [[2,2],[2,2],[1,2]]\nfn = function (a, b) { return a + b; }\nOutput: [{\"val\":4,\"calls\":1},{\"val\":4,\"calls\":1},{\"val\":3,\"calls\":2}]\nExplanation:\nconst inputs = getInputs();\nconst memoized = memoize(fn);\nfor (const arr of inputs) {\n  memoized(...arr);\n}\nFor the inputs of (2, 2): 2 + 2 = 4, and it required a call to fn().\nFor the inputs of (2, 2): 2 + 2 = 4, but those inputs were seen before so no call to fn() was required.\nFor the inputs of (1, 2): 1 + 2 = 3, and it required another call to fn() for a total of 2.\n\nExample 2:\n\nInput: \ngetInputs = () => [[{},{}],[{},{}],[{},{}]] \nfn = function (a, b) { return ({...a, ...b}); }\nOutput: [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":2},{\"val\":{},\"calls\":3}]\nExplanation:\nMerging two empty objects will always result in an empty object. It may seem like there should only be 1&nbsp;call to fn() because of cache-hits, however none of those objects are === to each other.\n\nExample 3:\n\nInput: \ngetInputs = () => { const o = {}; return [[o,o],[o,o],[o,o]]; }\nfn = function (a, b) { return ({...a, ...b}); }\nOutput: [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1}]\nExplanation:\nMerging two empty objects will always result in an empty object. The 2nd and 3rd third function calls result in a cache-hit. This is because every object passed in is identical.\n\n&nbsp;\nConstraints:\n\n\t1 <= inputs.length <= 105\n\t0 <= inputs.flat().length <= 105\n\tinputs[i][j] != NaN",
        "solutions": [
            {
                "id": 3408825,
                "title": "using-map-and-symbol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> A Map\\'s keys can be any value (including functions, objects, or any primitive). NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.\\n\\n# Approach\\n\\nMap is perfect for storing single argument. Each consecutive argument must have cache based on previous argument, which will form a tree like structure, like this:\\n\\n```\\nfn(1,3,4) // { 1: { 3: { 4: {}}}};\\nfn(1,4,3) // { 1: { 3: { 4: {}}, 4: { 3: {}}}};\\n```\\n\\nThe only problem, is how do we store our result. It\\'s been never stated, that memoized function will be called with the same amount of arguments every time. We need a way to store our result anywhere on the path and also make sure that it will never be misteaken with argument. Here is example.\\n\\n```\\nfn(1,3) // { 1: { 3: 4}};\\n-> 4\\nfn(1)   // { 1: { 3: 4}};\\n-> { 3: 4 } // returning cache branch as result\\n```\\n\\nThere are different aproaches to overcome this. But since \\n> Every Symbol() call is guaranteed to return a unique Symbol\\n\\nwe can use it to store actual result with guarantee, that it will never match any argument.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst RES = Symbol(\"result\");\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const globalCache = new Map();\\n\\n    return (...params) => {\\n        let currentCache = globalCache;\\n        for(const param of params) {\\n            if (!currentCache.has(param)) {\\n                currentCache.set(param, new Map());\\n            }\\n            currentCache = currentCache.get(param);\\n        }\\n\\n        if (currentCache.has(RES)) return currentCache.get(RES);\\n\\n        const result = fn(...params);\\n\\n        currentCache.set(RES, result);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfn(1,3,4) // { 1: { 3: { 4: {}}}};\\nfn(1,4,3) // { 1: { 3: { 4: {}}, 4: { 3: {}}}};\\n```\n```\\nfn(1,3) // { 1: { 3: 4}};\\n-> 4\\nfn(1)   // { 1: { 3: 4}};\\n-> { 3: 4 } // returning cache branch as result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408324,
                "title": "assign-id-to-object-without-trie",
                "content": "```ts\\ntype Fn = (...params: any) => any\\n\\n/**\\n * \\u51FD\\u6570\\u7684\\u53C2\\u6570\\u53EF\\u4EE5\\u662F\\u4EFB\\u610F\\u7C7B\\u578B\\u7684\\u6570\\u636E.\\n */\\nfunction memoize(fn: Fn): Fn {\\n  const idPool = new Map<unknown, number>()\\n  const cache: Map<string, ReturnType<Fn>> = new Map()\\n  return function (...args: Parameters<Fn>): ReturnType<Fn> {\\n    const key = args.map(getId).join(\\',\\')\\n    if (cache.has(key)) {\\n      return cache.get(key)!\\n    }\\n    const res = fn(...args)\\n    cache.set(key, res)\\n    return res\\n  }\\n\\n  function getId(o: unknown): number {\\n    if (idPool.has(o)) {\\n      return idPool.get(o)!\\n    }\\n    const id = idPool.size\\n    idPool.set(o, id)\\n    return id\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```ts\\ntype Fn = (...params: any) => any\\n\\n/**\\n * \\u51FD\\u6570\\u7684\\u53C2\\u6570\\u53EF\\u4EE5\\u662F\\u4EFB\\u610F\\u7C7B\\u578B\\u7684\\u6570\\u636E.\\n */\\nfunction memoize(fn: Fn): Fn {\\n  const idPool = new Map<unknown, number>()\\n  const cache: Map<string, ReturnType<Fn>> = new Map()\\n  return function (...args: Parameters<Fn>): ReturnType<Fn> {\\n    const key = args.map(getId).join(\\',\\')\\n    if (cache.has(key)) {\\n      return cache.get(key)!\\n    }\\n    const res = fn(...args)\\n    cache.set(key, res)\\n    return res\\n  }\\n\\n  function getId(o: unknown): number {\\n    if (idPool.has(o)) {\\n      return idPool.get(o)!\\n    }\\n    const id = idPool.size\\n    idPool.set(o, id)\\n    return id\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3413397,
                "title": "2-cache-implementations-4-tricky-edge-cases",
                "content": "##### Edge cases\\nLets explore possible edge cases\\n```\\n// 1. Different `this` values\\nconst memoizedFn = memoize(function (a) {\\n  return a + this.value;\\n});\\nmemoizedFn.call({value: 1}, 2);\\nmemoizedFn.call({value: 2}, 2);\\n\\n// 2. Different args number\\nconst memoizedFn = memoize(function (a, b = 1) {\\n  return a + b;\\n});\\nmemoizedFn(1);\\nmemoizedFn(1, 2);\\n\\n// 3. Undefined value as a result\\nconst memoizedFn = memoize(function (a) {\\n  return a === 1 ? undefined : a;\\n});\\nmemoizedFn(1); // undefined\\nmemoizedFn(2); // 2\\n\\n// 4. Argument as object key (critical for choosing right data structure)\\nmemoizedFn(\\'hasOwnProperty\\');\\nmemoizedFn(\\'valueOf\\');\\n```\\n\\n# Solution\\nIn order to retrieve old values, we need to memoize them somehow. High level solution will look like this.\\n\\n```\\nfunction memoize(fn) {\\n    const cache = new Cache(); // ?\\n    return function(...args) {\\n        // memoize `this` as well\\n        const argsWithThis = [this, ...args];\\n        if (cache.has(argsWithThis)) {\\n            return cache.get(argsWithThis);\\n        }\\n\\n        // dont forget about `this`\\n        const value = fn.apply(this, args);\\n        cache.set(argsWithThis, value);\\n        return value;\\n    }\\n}\\n```\\n\\nSo the question is how to implement the cache? I will describe 2 possible options here.\\n\\n##### Trie\\n```\\nclass Cache {\\n    constructor() {\\n        // Map uses SameValueZero algorithm for comparison that is totally fine for us\\n        this.trie = new Map();\\n        // Using symbol to ensure uniqueness\\n        this.key = Symbol();\\n    }\\n\\n    has(args) {\\n        let current = this.trie;\\n        for (const arg of args) {\\n            if (!current.has(arg)) {\\n                return false;\\n            }\\n            current = current.get(arg);\\n        }\\n        return current?.has(this.key);\\n    }\\n\\n    get(args) {\\n        let current = this.trie;\\n        for (const arg of args) {\\n            current = current.get(arg);\\n        }\\n        return current.get(this.key);\\n\\n    }\\n\\n    set(args, value) {\\n        let current = this.trie;\\n        for (const arg of args) {\\n            if (!current.has(arg)) {\\n                current.set(arg, new Map());\\n            }\\n            current = current.get(arg);\\n        }\\n        current.set(this.key, value);\\n    }\\n}\\n```\\n##### Plain object\\nWe will store all values in one Map and will keep keys in another.\\n```\\nclass Cache {\\n    constructor() {\\n        this.values = new Map();\\n        this.keys = new Map();\\n        this.id = 0;\\n    }\\n\\n    getCacheKey(args) {\\n        return args.map(arg => {\\n            if (!this.keys.has(arg)) {\\n                this.keys.set(arg, this.id++);\\n            }\\n\\n            return this.keys.get(arg);\\n        }).join(\\'_\\');\\n    }\\n\\n    has(args) {\\n        const key = this.getCacheKey(args);\\n        return this.values.has(key);\\n    }\\n\\n    get(args) {\\n        const key = this.getCacheKey(args);\\n        return this.values.get(key);\\n    }\\n\\n    set(args, value) {\\n        const key = this.getCacheKey(args);\\n        this.values.set(key, value);\\n    }\\n}\\n```\\n\\n\\n\\n---\\n*If you have other possible solutions, feel free to share them in the comments.*",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// 1. Different `this` values\\nconst memoizedFn = memoize(function (a) {\\n  return a + this.value;\\n});\\nmemoizedFn.call({value: 1}, 2);\\nmemoizedFn.call({value: 2}, 2);\\n\\n// 2. Different args number\\nconst memoizedFn = memoize(function (a, b = 1) {\\n  return a + b;\\n});\\nmemoizedFn(1);\\nmemoizedFn(1, 2);\\n\\n// 3. Undefined value as a result\\nconst memoizedFn = memoize(function (a) {\\n  return a === 1 ? undefined : a;\\n});\\nmemoizedFn(1); // undefined\\nmemoizedFn(2); // 2\\n\\n// 4. Argument as object key (critical for choosing right data structure)\\nmemoizedFn(\\'hasOwnProperty\\');\\nmemoizedFn(\\'valueOf\\');\\n```\n```\\nfunction memoize(fn) {\\n    const cache = new Cache(); // ?\\n    return function(...args) {\\n        // memoize `this` as well\\n        const argsWithThis = [this, ...args];\\n        if (cache.has(argsWithThis)) {\\n            return cache.get(argsWithThis);\\n        }\\n\\n        // dont forget about `this`\\n        const value = fn.apply(this, args);\\n        cache.set(argsWithThis, value);\\n        return value;\\n    }\\n}\\n```\n```\\nclass Cache {\\n    constructor() {\\n        // Map uses SameValueZero algorithm for comparison that is totally fine for us\\n        this.trie = new Map();\\n        // Using symbol to ensure uniqueness\\n        this.key = Symbol();\\n    }\\n\\n    has(args) {\\n        let current = this.trie;\\n        for (const arg of args) {\\n            if (!current.has(arg)) {\\n                return false;\\n            }\\n            current = current.get(arg);\\n        }\\n        return current?.has(this.key);\\n    }\\n\\n    get(args) {\\n        let current = this.trie;\\n        for (const arg of args) {\\n            current = current.get(arg);\\n        }\\n        return current.get(this.key);\\n\\n    }\\n\\n    set(args, value) {\\n        let current = this.trie;\\n        for (const arg of args) {\\n            if (!current.has(arg)) {\\n                current.set(arg, new Map());\\n            }\\n            current = current.get(arg);\\n        }\\n        current.set(this.key, value);\\n    }\\n}\\n```\n```\\nclass Cache {\\n    constructor() {\\n        this.values = new Map();\\n        this.keys = new Map();\\n        this.id = 0;\\n    }\\n\\n    getCacheKey(args) {\\n        return args.map(arg => {\\n            if (!this.keys.has(arg)) {\\n                this.keys.set(arg, this.id++);\\n            }\\n\\n            return this.keys.get(arg);\\n        }).join(\\'_\\');\\n    }\\n\\n    has(args) {\\n        const key = this.getCacheKey(args);\\n        return this.values.has(key);\\n    }\\n\\n    get(args) {\\n        const key = this.getCacheKey(args);\\n        return this.values.get(key);\\n    }\\n\\n    set(args, value) {\\n        const key = this.getCacheKey(args);\\n        this.values.set(key, value);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406786,
                "title": "write-a-customer-trie",
                "content": "# Intuition\\nI tried to use hashmap, write my own hash function, just use === to do linear search etc....nothing worked.\\nUntil I simpled used somethink like a Trie.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(args.length)\\n\\n- Space complexity:\\nO(args.length)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\n\\nclass TrieNode {\\n  constructor() {\\n    this.value = null;\\n    this.children = new Map();\\n  }\\n\\n  getValue(args) {\\n    if (this.children === null) {\\n      return undefined;\\n    }\\n    return this.children.get(args);\\n  }\\n\\n  setValue(args, value) {\\n    if (this.children === null) {\\n      return;\\n    }\\n    this.children.set(args, value);\\n  }\\n}\\n\\nfunction memoize(fn) {\\n  const cache = new TrieNode();\\n\\n  return function memoized(...args) {\\n    if (args.length === 0) {\\n      if (cache.value !== null) {\\n        return cache.value;\\n      }\\n      const result = fn.apply(this, args);\\n      cache.value = result;\\n      return result;\\n    }\\n\\n    let currentNode = cache;\\n    for (let i = 0; i < args.length; i++) {\\n      const arg = args[i];\\n      let childNode = currentNode.getValue(arg);\\n      if (childNode === undefined) {\\n        childNode = new TrieNode();\\n        currentNode.setValue(arg, childNode);\\n      }\\n      currentNode = childNode;\\n    }\\n\\n    if (currentNode.value === null) {\\n      const result = fn.apply(this, args);\\n      currentNode.value = result;\\n    }\\n\\n    return currentNode.value;\\n  };\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\n\\nclass TrieNode {\\n  constructor() {\\n    this.value = null;\\n    this.children = new Map();\\n  }\\n\\n  getValue(args) {\\n    if (this.children === null) {\\n      return undefined;\\n    }\\n    return this.children.get(args);\\n  }\\n\\n  setValue(args, value) {\\n    if (this.children === null) {\\n      return;\\n    }\\n    this.children.set(args, value);\\n  }\\n}\\n\\nfunction memoize(fn) {\\n  const cache = new TrieNode();\\n\\n  return function memoized(...args) {\\n    if (args.length === 0) {\\n      if (cache.value !== null) {\\n        return cache.value;\\n      }\\n      const result = fn.apply(this, args);\\n      cache.value = result;\\n      return result;\\n    }\\n\\n    let currentNode = cache;\\n    for (let i = 0; i < args.length; i++) {\\n      const arg = args[i];\\n      let childNode = currentNode.getValue(arg);\\n      if (childNode === undefined) {\\n        childNode = new TrieNode();\\n        currentNode.setValue(arg, childNode);\\n      }\\n      currentNode = childNode;\\n    }\\n\\n    if (currentNode.value === null) {\\n      const result = fn.apply(this, args);\\n      currentNode.value = result;\\n    }\\n\\n    return currentNode.value;\\n  };\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479966,
                "title": "java-script-solution-for-memoize-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe memoize function takes a function fn as its parameter and returns a new function that caches the results of fn based on its input arguments. The cache is stored in a global Map called globalCache.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen the memoized function is called with some input arguments, the function first checks if the current cache (which is initially the globalCache) contains the arguments. If not, it creates a new Map object in the cache for the arguments. It then sets the current cache to be the Map object for the current argument, and continues this process until it has created a Map object for each argument.\\n\\nIf the memoized function has already been called with the same input arguments, the cached result is returned immediately without calling fn again.\\n\\nIf the memoized function has not been called with the input arguments before, it calls the original function fn with the input arguments and stores the result in the cache. It then returns the result.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the memoized function is O(N), where N is the number of arguments passed to the function. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The space complexity is also O(N), because a new Map object is created for each unique set of arguments.\\n\\n# Code\\n```\\nconst RES = Symbol(\"res\");\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const globalCache = new Map();\\n\\n    return (...params) => {\\n        let currentCache = globalCache;\\n        for(const param of params) {\\n            if (!currentCache.has(param)) {\\n                currentCache.set(param, new Map());\\n            }\\n            currentCache = currentCache.get(param);\\n        }\\n\\n        if (currentCache.has(RES)) return currentCache.get(RES);\\n\\n        const result = fn(...params);\\n\\n        currentCache.set(RES, result);\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst RES = Symbol(\"res\");\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const globalCache = new Map();\\n\\n    return (...params) => {\\n        let currentCache = globalCache;\\n        for(const param of params) {\\n            if (!currentCache.has(param)) {\\n                currentCache.set(param, new Map());\\n            }\\n            currentCache = currentCache.get(param);\\n        }\\n\\n        if (currentCache.has(RES)) return currentCache.get(RES);\\n\\n        const result = fn(...params);\\n\\n        currentCache.set(RES, result);\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3412651,
                "title": "clean-javascript-with-custom-trie-implementation",
                "content": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nclass Node {\\n  value = undefined;\\n  nodes = new Map();\\n}\\n\\nclass Trie {\\n  root = new Node();\\n\\n  add(node, inputs, i, result) {\\n    if (i >= inputs.length) {\\n      node.value = result;\\n      return;\\n    }\\n    const currentValue = inputs[i];\\n    if (node.nodes.has(currentValue)) {\\n      return this.add(node.nodes.get(currentValue), inputs, i + 1, result);\\n    }\\n    node.nodes.set(currentValue, new Node());\\n    return this.add(node.nodes.get(currentValue), inputs, i + 1, result);\\n  }\\n\\n  check(node, inputs, i) {\\n    if (!node) return undefined;\\n    if (i >= inputs.length) return node.value;\\n    return this.check(node.nodes.get(inputs[i]), inputs, i + 1);\\n  }\\n\\n  addResultForInputs(inputs, result) {\\n    this.add(this.root, inputs, 0, result);\\n  }\\n\\n  getResultForInputs(inputs) {\\n    return this.check(this.root, inputs, 0);\\n  }\\n}\\n\\nfunction memoize(fn) {\\n  const trie = new Trie();\\n  return function (...args) {\\n    const memoizedValue = trie.getResultForInputs(args);\\n    if (memoizedValue != undefined) return memoizedValue;\\n    let result = fn(...args);\\n    trie.addResultForInputs(args, result);\\n    return result;\\n  };\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nclass Node {\\n  value = undefined;\\n  nodes = new Map();\\n}\\n\\nclass Trie {\\n  root = new Node();\\n\\n  add(node, inputs, i, result) {\\n    if (i >= inputs.length) {\\n      node.value = result;\\n      return;\\n    }\\n    const currentValue = inputs[i];\\n    if (node.nodes.has(currentValue)) {\\n      return this.add(node.nodes.get(currentValue), inputs, i + 1, result);\\n    }\\n    node.nodes.set(currentValue, new Node());\\n    return this.add(node.nodes.get(currentValue), inputs, i + 1, result);\\n  }\\n\\n  check(node, inputs, i) {\\n    if (!node) return undefined;\\n    if (i >= inputs.length) return node.value;\\n    return this.check(node.nodes.get(inputs[i]), inputs, i + 1);\\n  }\\n\\n  addResultForInputs(inputs, result) {\\n    this.add(this.root, inputs, 0, result);\\n  }\\n\\n  getResultForInputs(inputs) {\\n    return this.check(this.root, inputs, 0);\\n  }\\n}\\n\\nfunction memoize(fn) {\\n  const trie = new Trie();\\n  return function (...args) {\\n    const memoizedValue = trie.getResultForInputs(args);\\n    if (memoizedValue != undefined) return memoizedValue;\\n    let result = fn(...args);\\n    trie.addResultForInputs(args, result);\\n    return result;\\n  };\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412240,
                "title": "js-typescript-easiest-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a cache object to store previously computed results of a function, and return the cached result instead of recomputing if the same input is provided again. This approach is simple to implement but may consume a lot of memory if the function is called with a large number of unique inputs.\\n\\nUse a data structure like a hash table or a tree to store previously computed results of a function, and retrieve the result from the data structure if the same input is provided again. This approach can be more memory-efficient than a cache object, but may be more complex to implement.\\n\\nUse a memoization library or framework that provides a pre-built solution for caching function results. This can be an easy and convenient approach, but may require some learning curve to understand the library or framework.\\n\\nOverall, the choice of approach will depend on factors such as the complexity of the function being memoized, the expected number of unique inputs, and the memory constraints of the application\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a cache object or data structure to store the cached results.\\n\\nCreate a wrapper function that takes the original function as an argument.\\n\\nInside the wrapper function, return a new function that takes the arguments for the original function as its own arguments.\\n\\nInside the new function, check if the cached result exists for the current set of arguments. If it does, return the cached result.\\n\\nIf the cached result does not exist, call the original function with the current set of arguments, store the result in the cache, and return the result.\\n\\nAdd a way to clear the cache if needed, for example, if the input to the original function has changed.\\n\\nReturn the new function from the wrapper function.\\n\\nOverall, this approach should allow the original function to be called with the same set of arguments multiple times without having to recompute the result, thus reducing the computation time and improving performance.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: \\nO(n), where n is the number of arguments passed to the memoized function. The time complexity of the memoized function is mainly due to the traversal of the Trie data structure to retrieve or store cached results. The worst-case scenario is when all the arguments passed to the function are unique, which would require traversing the entire Trie structure for every call to the function.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mn), where m is the maximum number of unique arguments for any given position in the argument list, and n is the length of the argument list. The space complexity is due to the storage of cached results in the Trie data structure. The worst-case scenario is when all the arguments passed to the function are unique, which would require creating a new Trie node for every argument at every position in the argument list.\\n# Code\\n```javascript []\\n// Define a type for memoized functions\\nconst memoize = (fn) => {\\n  // Define a TrieNode class to store the cache\\n  class TrieNode {\\n    constructor() {\\n      this.value = null;\\n      this.children = new Map();\\n    }\\n\\n    getValue(args) {\\n      return this.children.get(args)?.value;\\n    }\\n\\n    setValue(args, value) {\\n      const childNode = this.children.get(args) ?? new TrieNode();\\n      childNode.value = value;\\n      this.children.set(args, childNode);\\n    }\\n  }\\n\\n  // Create a cache using the TrieNode class\\n  const cache = new TrieNode();\\n\\n  // Define the memoized function\\n  const memoized = (...args) => {\\n    // If no arguments are passed, return the cached value\\n    if (args.length === 0) {\\n      if (cache.value !== null) {\\n        return cache.value;\\n      }\\n      const result = fn.apply(this, args);\\n      cache.value = result;\\n      return result;\\n    }\\n\\n    // Traverse the TrieNode based on the arguments\\n    let currentNode = cache;\\n    for (let i = 0; i < args.length; i++) {\\n      const arg = args[i];\\n      const childNode = currentNode.children.get(arg) ?? new TrieNode();\\n      currentNode.children.set(arg, childNode);\\n      currentNode = childNode;\\n    }\\n\\n    // If the value is not cached, cache it and return it\\n    if (currentNode.value === null) {\\n      const result = fn.apply(this, args);\\n      currentNode.value = result;\\n    }\\n\\n    return currentNode.value;\\n  };\\n\\n  return memoized;\\n};\\n\\n```\\n```TypeScript []\\ntype MemoizedFn<T> = (...args: any[]) => T;\\n\\nclass TrieNode<T> {\\n  value: T | null = null;\\n  children = new Map<any, TrieNode<T>>();\\n\\n  getValue(args: any[]): T | undefined {\\n    return this.children.get(args)?.value;\\n  }\\n\\n  setValue(args: any[], value: T): void {\\n    const childNode = this.children.get(args) ?? new TrieNode<T>();\\n    childNode.value = value;\\n    this.children.set(args, childNode);\\n  }\\n}\\n\\nfunction memoize<T>(fn: (...args: any[]) => T): MemoizedFn<T> {\\n  const cache = new TrieNode<T>();\\n\\n  const memoized = (...args: any[]): T => {\\n    if (args.length === 0) {\\n      if (cache.value !== null) {\\n        return cache.value;\\n      }\\n      const result = fn.apply(this, args);\\n      cache.value = result;\\n      return result;\\n    }\\n\\n    let currentNode = cache;\\n    for (let i = 0; i < args.length; i++) {\\n      const arg = args[i];\\n      const childNode = currentNode.children.get(arg) ?? new TrieNode<T>();\\n      currentNode.children.set(arg, childNode);\\n      currentNode = childNode;\\n    }\\n\\n    if (currentNode.value === null) {\\n      const result = fn.apply(this, args);\\n      currentNode.value = result;\\n    }\\n\\n    return currentNode.value as T;\\n  };\\n\\n  return memoized;\\n}\\n```\\n\\n```\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n// Define a type for memoized functions\\nconst memoize = (fn) => {\\n  // Define a TrieNode class to store the cache\\n  class TrieNode {\\n    constructor() {\\n      this.value = null;\\n      this.children = new Map();\\n    }\\n\\n    getValue(args) {\\n      return this.children.get(args)?.value;\\n    }\\n\\n    setValue(args, value) {\\n      const childNode = this.children.get(args) ?? new TrieNode();\\n      childNode.value = value;\\n      this.children.set(args, childNode);\\n    }\\n  }\\n\\n  // Create a cache using the TrieNode class\\n  const cache = new TrieNode();\\n\\n  // Define the memoized function\\n  const memoized = (...args) => {\\n    // If no arguments are passed, return the cached value\\n    if (args.length === 0) {\\n      if (cache.value !== null) {\\n        return cache.value;\\n      }\\n      const result = fn.apply(this, args);\\n      cache.value = result;\\n      return result;\\n    }\\n\\n    // Traverse the TrieNode based on the arguments\\n    let currentNode = cache;\\n    for (let i = 0; i < args.length; i++) {\\n      const arg = args[i];\\n      const childNode = currentNode.children.get(arg) ?? new TrieNode();\\n      currentNode.children.set(arg, childNode);\\n      currentNode = childNode;\\n    }\\n\\n    // If the value is not cached, cache it and return it\\n    if (currentNode.value === null) {\\n      const result = fn.apply(this, args);\\n      currentNode.value = result;\\n    }\\n\\n    return currentNode.value;\\n  };\\n\\n  return memoized;\\n};\\n\\n```\n```TypeScript []\\ntype MemoizedFn<T> = (...args: any[]) => T;\\n\\nclass TrieNode<T> {\\n  value: T | null = null;\\n  children = new Map<any, TrieNode<T>>();\\n\\n  getValue(args: any[]): T | undefined {\\n    return this.children.get(args)?.value;\\n  }\\n\\n  setValue(args: any[], value: T): void {\\n    const childNode = this.children.get(args) ?? new TrieNode<T>();\\n    childNode.value = value;\\n    this.children.set(args, childNode);\\n  }\\n}\\n\\nfunction memoize<T>(fn: (...args: any[]) => T): MemoizedFn<T> {\\n  const cache = new TrieNode<T>();\\n\\n  const memoized = (...args: any[]): T => {\\n    if (args.length === 0) {\\n      if (cache.value !== null) {\\n        return cache.value;\\n      }\\n      const result = fn.apply(this, args);\\n      cache.value = result;\\n      return result;\\n    }\\n\\n    let currentNode = cache;\\n    for (let i = 0; i < args.length; i++) {\\n      const arg = args[i];\\n      const childNode = currentNode.children.get(arg) ?? new TrieNode<T>();\\n      currentNode.children.set(arg, childNode);\\n      currentNode = childNode;\\n    }\\n\\n    if (currentNode.value === null) {\\n      const result = fn.apply(this, args);\\n      currentNode.value = result;\\n    }\\n\\n    return currentNode.value as T;\\n  };\\n\\n  return memoized;\\n}\\n```\n```\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411095,
                "title": "beats-100-trie-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const root = new Map();\\n    return function (...args) {\\n        let node = root;\\n        for (const arg of args) {\\n            if(!node.has(arg)) node.set(arg, new Map());\\n            node = node.get(arg);\\n        }\\n        if (!node.has(\"__CACHE__\")) node.set(\"__CACHE__\", fn(...args));\\n        return node.get(\"__CACHE__\");\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const root = new Map();\\n    return function (...args) {\\n        let node = root;\\n        for (const arg of args) {\\n            if(!node.has(arg)) node.set(arg, new Map());\\n            node = node.get(arg);\\n        }\\n        if (!node.has(\"__CACHE__\")) node.set(\"__CACHE__\", fn(...args));\\n        return node.get(\"__CACHE__\");\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583987,
                "title": "ts-custom-hashing-vs-trie-like-approach",
                "content": "The first attempt at solving this problem might mirror the one from [the base problem](https://leetcode.com/problems/memoize/) ([cracked here](https://leetcode.com/problems/memoize/solutions/3500116/ts-hashing-scoping-337ms-107-9mb/)), which means we need to figure out a way to turn also objects, arrays, symbols, etc. into some form of string that we will use as a hash in a fashion similar to what we did in the base problem.\\n\\nAnd this is not a trivial problem, given how JS works; but we can act creatively and start by using `JSON.stringify` to do most of the work for us.\\n\\nUnfortunately this function does not do well with some values: `undefined`, for example, gets converted to `null` in some cases, like when in an array (as `args` is), plus we still need a way to keep track of what objects were seen before.\\n\\nLuckily `JSON.stringify` allows us to pass an optional second parameter which is a parsing function, that we will set up calling it `parser`; this function takes key (that we won\\'t be using) and a value `val` for each object parsed, so we can write a few special cases:\\n* first of all, when we will received `val` as a symbol, we will check if we already encountered it previously in the dedicated store `seenSymbols` (I might have used another `Map` for this, but given how few we will face, I thought it would not have made a major difference to change a bit):\\n    * if we did not encounter it before (ie: `seen === null`), we will replace `seen` with an array composed of the value itself and the current size of `seenSymbols`, where we are going to `.push` it right after;\\n    * in any case, we will `return` a string composed of the word `symbol` and its order of appeareance (ie: `seen[1]`]);\\n* if `val` is an object other than `null`, we will check if we already encountered before, checking the property `used` in it (it works just fine also for arrays);\\n    * if we have not used it before, we will add the property with `Object.defineProperty` (which is a great way to add a non-enumerable property, so that it won\\'t appear when computing the result) and with a value equal to the increased value of `objCounter`;\\n    * in order to parse this value, we will have to create a new object adding the property `used` explicitly just for `JSON.stringify`;\\n* for all the other cases, we will `return` a random string (like the name of my late cat) to cover the `undefined` case` or the value itself for any other type of value.\\n\\nHaving done this, we can now proceed like we did for the base problem and `return` the stored version when we alread have one (ie: the hash `key` so computed is in `store`), otherwise we will compute it anew, write it in `store` with the matching `key` and `return` it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```ts\\ntype Fn = (...params: any) => any\\n\\nconst seenSymbols = [];\\n\\nlet objCounter = 0;\\n\\nconst parser = (_, val) => {\\n    if (typeof val === \\'symbol\\') {\\n        // checking if we saw the symbol previously\\n        let seen = seenSymbols.find(el => el[0] === val);\\n        // if it is the first time we see this symbol, we create the entry\\n        if (!seen) {\\n            seen = [val, seenSymbols.length];\\n            seenSymbols.push(seen);\\n        }\\n        return `symbol${seen[1]}`;\\n    }\\n    // special case for already used objects\\n    if (val && typeof val === \\'object\\') {\\n        if (!val.used) Object.defineProperty(val, \"used\", {value: ++objCounter});\\n        return {...val, used: val.used};\\n    }\\n    // parsing `undefined` as some random string\\n    return val === undefined ? \"pippi\" : val;\\n}\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return (...args) => {\\n        // hashing args into a key\\n        const key = args.map(arg => JSON.stringify(arg, parser)).join(\"+\");\\n        // checking if we saw all the previous values before\\n        if (store.has(key)) return store.get(key);\\n        // if not, we use fn and store the result\\n        let res;\\n        return (\\n            res = fn(...args), store.set(key, res), res\\n        );\\n    }\\n}\\n```\\n\\nI tried replacing the `Map` of the store with a common object, but it was really not worth it - a bit slower and 4-5MB more burnt to achieve the same result:\\n\\n```ts\\ntype Fn = (...params: any) => any\\n\\nconst seenSymbols = [];\\n\\nlet objCounter = 0;\\n\\nconst parser = (_, val) => {\\n    if (typeof val === \\'symbol\\') {\\n        // checking if we saw the symbol previously\\n        let seen = seenSymbols.find(el => el[0] === val);\\n        // if it is the first time we see this symbol, we create the entry\\n        if (!seen) {\\n            seen = [val, seenSymbols.length];\\n            seenSymbols.push(seen);\\n        }\\n        return `symbol${seen[1]}`;\\n    }\\n    // special case for already used objects\\n    if (val && typeof val === \\'object\\') {\\n        if (!val.used) Object.defineProperty(val, \"used\", {value: ++objCounter});\\n        return {...val, used: val.used};\\n    }\\n    // parsing `undefined` as some random string\\n    return val === undefined ? \"pippi\" : val;\\n}\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = {};\\n    return (...args) => {\\n        // hashing args into a key\\n        const key = args.map(arg => JSON.stringify(arg, parser)).join(\"+\");\\n        // checking if we saw all the previous values before\\n        return store[key] !== undefined ? store[key] : store[key] = fn(...args);\\n    }\\n}\\n```\\n\\nBut can we do better, possibly avoiding all that painful hashing to string, that definitely won\\'t come cheap to us?\\n\\nYes, if we create a trie-like structure parsing each `arg` in `args` and going down that traversal with `curr` initially set to be `store`, we verify if we have been already been here with a previous sequence of parameters (and conveniently enough, a `Map` will do the job of comparing objects, arrays and symbols for us, without converting them to strings like an object would do).\\n\\nSimilar to a trie traversal, whenever we reach a node for the first time, we will create a new node (ie: a new `Map`) right before proceeding.\\n\\nIf at the end of the run we have a property we preset as `res` (I set a string, but you can use whatever unique value you want to set, like a peculiar decimal number or, possibly better, a symbol), we will just `return` what we had computed before.\\n\\nIf not, we store the result of calling `fn` with `args` in `tmp`, store it in `curr` under the key `res` and finally `return` that.\\n\\n```ts\\ntype Fn = (...params: any) => any\\n\\nconst res = \"res\";\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return (...args) => {\\n        let curr = store;\\n        for (const arg of args) {\\n            // if we were never here before, we create a new node for it\\n            if (!curr.has(arg)) curr.set(arg, new Map);\\n            // advancing curr\\n            curr = curr.get(arg);\\n        }\\n        // case 1: result found\\n        if (curr.has(res)) return curr.get(res);\\n        // case 2: result needs to be created and stored\\n        const tmp = fn(...args);\\n        curr.set(res, tmp);\\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Trie",
                    "Hash Function"
                ],
                "code": "```ts\\ntype Fn = (...params: any) => any\\n\\nconst seenSymbols = [];\\n\\nlet objCounter = 0;\\n\\nconst parser = (_, val) => {\\n    if (typeof val === \\'symbol\\') {\\n        // checking if we saw the symbol previously\\n        let seen = seenSymbols.find(el => el[0] === val);\\n        // if it is the first time we see this symbol, we create the entry\\n        if (!seen) {\\n            seen = [val, seenSymbols.length];\\n            seenSymbols.push(seen);\\n        }\\n        return `symbol${seen[1]}`;\\n    }\\n    // special case for already used objects\\n    if (val && typeof val === \\'object\\') {\\n        if (!val.used) Object.defineProperty(val, \"used\", {value: ++objCounter});\\n        return {...val, used: val.used};\\n    }\\n    // parsing `undefined` as some random string\\n    return val === undefined ? \"pippi\" : val;\\n}\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return (...args) => {\\n        // hashing args into a key\\n        const key = args.map(arg => JSON.stringify(arg, parser)).join(\"+\");\\n        // checking if we saw all the previous values before\\n        if (store.has(key)) return store.get(key);\\n        // if not, we use fn and store the result\\n        let res;\\n        return (\\n            res = fn(...args), store.set(key, res), res\\n        );\\n    }\\n}\\n```\n```ts\\ntype Fn = (...params: any) => any\\n\\nconst seenSymbols = [];\\n\\nlet objCounter = 0;\\n\\nconst parser = (_, val) => {\\n    if (typeof val === \\'symbol\\') {\\n        // checking if we saw the symbol previously\\n        let seen = seenSymbols.find(el => el[0] === val);\\n        // if it is the first time we see this symbol, we create the entry\\n        if (!seen) {\\n            seen = [val, seenSymbols.length];\\n            seenSymbols.push(seen);\\n        }\\n        return `symbol${seen[1]}`;\\n    }\\n    // special case for already used objects\\n    if (val && typeof val === \\'object\\') {\\n        if (!val.used) Object.defineProperty(val, \"used\", {value: ++objCounter});\\n        return {...val, used: val.used};\\n    }\\n    // parsing `undefined` as some random string\\n    return val === undefined ? \"pippi\" : val;\\n}\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = {};\\n    return (...args) => {\\n        // hashing args into a key\\n        const key = args.map(arg => JSON.stringify(arg, parser)).join(\"+\");\\n        // checking if we saw all the previous values before\\n        return store[key] !== undefined ? store[key] : store[key] = fn(...args);\\n    }\\n}\\n```\n```ts\\ntype Fn = (...params: any) => any\\n\\nconst res = \"res\";\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return (...args) => {\\n        let curr = store;\\n        for (const arg of args) {\\n            // if we were never here before, we create a new node for it\\n            if (!curr.has(arg)) curr.set(arg, new Map);\\n            // advancing curr\\n            curr = curr.get(arg);\\n        }\\n        // case 1: result found\\n        if (curr.has(res)) return curr.get(res);\\n        // case 2: result needs to be created and stored\\n        const tmp = fn(...args);\\n        curr.set(res, tmp);\\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409028,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nfunction memoize(fn) {\\n  const cache = new Map();\\n\\n  function explore(args) {\\n    let node = cache;\\n    for (const arg of args) {\\n      if (!node.has(arg)) {\\n        node.set(arg, new Map());\\n      }\\n      node = node.get(arg);\\n    }\\n\\n    if (node.has(\\'value\\')) {\\n      return node.get(\\'value\\');\\n    } else {\\n      const value = fn(...args);\\n      node.set(\\'value\\', value);\\n      return value;\\n    }\\n  }\\n\\n  return function memoized(...args) {\\n    return explore(args);\\n  };\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n  const cache = new Map();\\n\\n  function explore(args) {\\n    let node = cache;\\n    for (const arg of args) {\\n      if (!node.has(arg)) {\\n        node.set(arg, new Map());\\n      }\\n      node = node.get(arg);\\n    }\\n\\n    if (node.has(\\'value\\')) {\\n      return node.get(\\'value\\');\\n    } else {\\n      const value = fn(...args);\\n      node.set(\\'value\\', value);\\n      return value;\\n    }\\n  }\\n\\n  return function memoized(...args) {\\n    return explore(args);\\n  };\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839973,
                "title": "tiny-solution-289ms-beats-99-using-string-hash-no-map-or-trie-etc",
                "content": "# Intuition\\nReal world JS memoizers pretty much always rely on a string-based hash (eg JSON.stringify) because it\\'s usually more important that an Object argument is a *value* match, not an exact *reference* (ie, ===) match.\\n\\nThis is by definition of what memoization is for: it doesn\\'t matter if the argument is an exact object match, because the return value of the memoized function is almost certainly dependant on the *values* of the Object.\\n\\n# Approach\\nBut this is a sneaky and contrived problem. So we have used a sneaky and contrived solution. The value of any Object argument basically doesn\\'t matter - we care only about === equivalence. \\n\\nThe solutions here so far all do a similar thing: cache the arguments array (in part or in whole), and then for each lookup they do an inefficient and exhaustive === comparison search (most not much better than $$O(n)$$) to find a 100% match.\\n\\nInstead, we use the good old string-based key hash. This means we have to deal with 2 big problems: Symbols and Objects. We can\\'t stringify Objects because we need a === match, and Symbols are opaquely unique so again there\\'s no direct way to generate a unique identifier.\\n\\nFor Objects, we just create a non-enumerable property that uniquely tags each individual Object that we see, and build our hash using that tag.\\n\\nFor Symbols, we simply push them into an Array, which assigns each Symbol a unique ID. Then we have to use Array.indexOf() to help build the hash key. This is the only kind of argument that isn\\'t $$O(1)$$ with respect to the number of memoized function calls in the cache.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$ with respect to cached function calls\\n$$O(n)$$ with respect to length of argument list per call\\n\\n- Space complexity:\\n$$O(n*m)$$ where `n` = number of cached results and `m` = average length of argument list\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = Object.create(null);\\n    const syms = [];\\n    let seq = 0;\\n\\n    return function() {\\n        const len = arguments.length;\\n        const arg = Array.prototype.slice.call(arguments);\\n        let key = \\'\\';\\n        for (let i=0; i<len; i++) {\\n            let A = arg[i];\\n            if (A && typeof A===\\'object\\') {\\n                if (!A.cheat) Object.defineProperty(A, \\'cheat\\', {value:\\':obj\\'+(++seq), enumerable:0});\\n                key += A.cheat;\\n            } else\\n            if (typeof A===\\'symbol\\') {\\n                let s = syms.indexOf(A);\\n                if (s < 0) s = syms.push(A);\\n                key += \\':sym\\'+s;\\n            } else\\n                key += \\':\\'+String(A);\\n        }\\n        if (key in cache) return cache[key];\\n        return cache[key] = fn.apply(this, arguments);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = Object.create(null);\\n    const syms = [];\\n    let seq = 0;\\n\\n    return function() {\\n        const len = arguments.length;\\n        const arg = Array.prototype.slice.call(arguments);\\n        let key = \\'\\';\\n        for (let i=0; i<len; i++) {\\n            let A = arg[i];\\n            if (A && typeof A===\\'object\\') {\\n                if (!A.cheat) Object.defineProperty(A, \\'cheat\\', {value:\\':obj\\'+(++seq), enumerable:0});\\n                key += A.cheat;\\n            } else\\n            if (typeof A===\\'symbol\\') {\\n                let s = syms.indexOf(A);\\n                if (s < 0) s = syms.push(A);\\n                key += \\':sym\\'+s;\\n            } else\\n                key += \\':\\'+String(A);\\n        }\\n        if (key in cache) return cache[key];\\n        return cache[key] = fn.apply(this, arguments);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406708,
                "title": "typescript-solution-with-trie-structure",
                "content": "We can use Trie Node structure for this problem\\n\\n$$n = params.length$$\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ (I\\'m not sure about it)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\ninterface Trie {\\n    val?: any;\\n    map: Map<any, Trie>;\\n}\\n\\nfunction memoize(fn: Fn): Fn {\\n    const results: Map<any, Trie> = new Map();\\n\\n    let voidResolved = false;\\n    let voidResult: any = null;\\n\\n    return function(...params: any) {\\n        let currentMap = results;\\n\\n        // For empty params use specific variables\\n        if (params.length === 0) {\\n            if (!voidResolved) {\\n                const result = fn(...params);\\n                voidResult = result;\\n                voidResolved = true;\\n            }\\n            return voidResult;\\n        }\\n\\n\\n        for (let i = 0; i < params.length; i++) {\\n            const param = params[i];\\n\\n            const trie = currentMap.get(param);\\n            \\n            if (i === params.length - 1) {\\n                let result: any;\\n                if (!trie) {\\n                    result = fn(...params);\\n                    const newTrie = {\\n                        val: result,\\n                        map: new Map()\\n                    };\\n                    currentMap.set(param, newTrie);\\n                } else {\\n                    if (!(\\'val\\' in trie)) {\\n                        trie.val = fn(...params);\\n                    }\\n                    result = trie.val;\\n                }\\n\\n                return result;\\n            }\\n\\n            if (!trie) {\\n                const newTrie = {\\n                    map: new Map()\\n                };\\n                currentMap.set(param, newTrie);\\n            } \\n            currentMap = currentMap.get(param).map;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Trie"
                ],
                "code": "We can use Trie Node structure for this problem\\n\\n$$n = params.length$$\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ (I\\'m not sure about it)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\ninterface Trie {\\n    val?: any;\\n    map: Map<any, Trie>;\\n}\\n\\nfunction memoize(fn: Fn): Fn {\\n    const results: Map<any, Trie> = new Map();\\n\\n    let voidResolved = false;\\n    let voidResult: any = null;\\n\\n    return function(...params: any) {\\n        let currentMap = results;\\n\\n        // For empty params use specific variables\\n        if (params.length === 0) {\\n            if (!voidResolved) {\\n                const result = fn(...params);\\n                voidResult = result;\\n                voidResolved = true;\\n            }\\n            return voidResult;\\n        }\\n\\n\\n        for (let i = 0; i < params.length; i++) {\\n            const param = params[i];\\n\\n            const trie = currentMap.get(param);\\n            \\n            if (i === params.length - 1) {\\n                let result: any;\\n                if (!trie) {\\n                    result = fn(...params);\\n                    const newTrie = {\\n                        val: result,\\n                        map: new Map()\\n                    };\\n                    currentMap.set(param, newTrie);\\n                } else {\\n                    if (!(\\'val\\' in trie)) {\\n                        trie.val = fn(...params);\\n                    }\\n                    result = trie.val;\\n                }\\n\\n                return result;\\n            }\\n\\n            if (!trie) {\\n                const newTrie = {\\n                    map: new Map()\\n                };\\n                currentMap.set(param, newTrie);\\n            } \\n            currentMap = currentMap.get(param).map;\\n        }\\n    }\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4037266,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    const cache = new Map();\\n\\n    return function() {\\n        const args = arguments;\\n        const { length } = args;\\n        let i = -1;\\n        let map = cache;\\n\\n        while (++i < length) {\\n            if (!map.has(args[i])) {\\n                const newMap = new Map();\\n                map.set(args[i], newMap);\\n                map = newMap;\\n            } else {\\n                map = map.get(args[i]);\\n            }\\n        }\\n\\n        if(!map.has(\\'$result\\')) {\\n            const result = fn.apply(this, args);\\n            map.set(\\'$result\\', result);\\n            return result;\\n        }\\n\\n        return map.get(\\'$result\\');\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    const cache = new Map();\\n\\n    return function() {\\n        const args = arguments;\\n        const { length } = args;\\n        let i = -1;\\n        let map = cache;\\n\\n        while (++i < length) {\\n            if (!map.has(args[i])) {\\n                const newMap = new Map();\\n                map.set(args[i], newMap);\\n                map = newMap;\\n            } else {\\n                map = map.get(args[i]);\\n            }\\n        }\\n\\n        if(!map.has(\\'$result\\')) {\\n            const result = fn.apply(this, args);\\n            map.set(\\'$result\\', result);\\n            return result;\\n        }\\n\\n        return map.get(\\'$result\\');\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032933,
                "title": "simple-recursive-solution",
                "content": "# Intuition\\nThe catch here in the problem statement is to memoize the values based on the reference, so arguments provided as-is should be mmintained in a data structure so that function does not get executed multiple times.\\nSo, we can use inbuilt map which allows to use objects as keys instead of just strings. But, the problem over here is when there are multiple objects are passed as arguments to the input function, map does not have functionality to accept to those values and maintain internally.\\n\\nTo acheive that, a trie like data structure can be implemented to store and retrieve values (based on map) considering the list of arguments as the top down tree path. Example code snippet below:\\n\\n\\n# Code\\n```\\n// Class used to maintain + retrieve memoized values for the provided references path\\nclass TrieMap {\\n  static nodeActualValue = \\'@@actualValue@@\\';\\n\\n  constructor() {\\n    this.map = new Map();\\n  }\\n\\n  /**\\n   * Returns the value for the given array path if exists in map, otherwise null.\\n   */\\n  #getValueFromPath(map, path, depth = 0) {\\n    const pathKey = path[depth];\\n\\n    if (depth >= path.length) {\\n      return map.get(TrieMap.nodeActualValue);\\n    }\\n\\n    if (map.has(pathKey)) {\\n      return this.#getValueFromPath(map.get(pathKey), path, depth + 1);\\n    }\\n\\n    return null;\\n  }\\n\\n  /**\\n   * Returns true when the given path elements exists in map, otherwise false.\\n   */\\n  #hasPath(map, path, depth = 0) {\\n    if (depth >= path.length) {\\n      return map.has(TrieMap.nodeActualValue);\\n    }\\n\\n    const pathKey = path[depth];\\n\\n    if (map.has(pathKey)) {\\n      return this.#hasPath(map.get(pathKey), path, depth + 1);\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Sets the value for the given path and map.\\n   */\\n  #setValueForPath(map, path, value, depth = 0) {\\n    if (depth >= path.length) {\\n      map.set(TrieMap.nodeActualValue, value);\\n      return;\\n    }\\n\\n    const pathKey = path[depth];\\n    const hasPathKey = map.has(pathKey)\\n    !hasPathKey && map.set(pathKey, new Map());\\n\\n    this.#setValueForPath(map.get(pathKey), path, value, depth + 1);\\n  }\\n\\n  get(path) {\\n    const pathArray = Array.isArray(path) ? path : [path];\\n    return this.#getValueFromPath(this.map, pathArray);\\n  }\\n\\n  has(path) {\\n    const pathArray = Array.isArray(path) ? path : [path];\\n    return this.#hasPath(this.map, pathArray, 0);\\n  }\\n\\n  set(path, value) {\\n    const pathArray = Array.isArray(path) ? path : [path];\\n    this.#setValueForPath(this.map, pathArray, value);\\n    return value;\\n  }\\n}\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const memo = new TrieMap();\\n    return function(...args) {\\n      return memo.has(args) ? memo.get(args) : memo.set(args, fn(...args));\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n// Class used to maintain + retrieve memoized values for the provided references path\\nclass TrieMap {\\n  static nodeActualValue = \\'@@actualValue@@\\';\\n\\n  constructor() {\\n    this.map = new Map();\\n  }\\n\\n  /**\\n   * Returns the value for the given array path if exists in map, otherwise null.\\n   */\\n  #getValueFromPath(map, path, depth = 0) {\\n    const pathKey = path[depth];\\n\\n    if (depth >= path.length) {\\n      return map.get(TrieMap.nodeActualValue);\\n    }\\n\\n    if (map.has(pathKey)) {\\n      return this.#getValueFromPath(map.get(pathKey), path, depth + 1);\\n    }\\n\\n    return null;\\n  }\\n\\n  /**\\n   * Returns true when the given path elements exists in map, otherwise false.\\n   */\\n  #hasPath(map, path, depth = 0) {\\n    if (depth >= path.length) {\\n      return map.has(TrieMap.nodeActualValue);\\n    }\\n\\n    const pathKey = path[depth];\\n\\n    if (map.has(pathKey)) {\\n      return this.#hasPath(map.get(pathKey), path, depth + 1);\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * Sets the value for the given path and map.\\n   */\\n  #setValueForPath(map, path, value, depth = 0) {\\n    if (depth >= path.length) {\\n      map.set(TrieMap.nodeActualValue, value);\\n      return;\\n    }\\n\\n    const pathKey = path[depth];\\n    const hasPathKey = map.has(pathKey)\\n    !hasPathKey && map.set(pathKey, new Map());\\n\\n    this.#setValueForPath(map.get(pathKey), path, value, depth + 1);\\n  }\\n\\n  get(path) {\\n    const pathArray = Array.isArray(path) ? path : [path];\\n    return this.#getValueFromPath(this.map, pathArray);\\n  }\\n\\n  has(path) {\\n    const pathArray = Array.isArray(path) ? path : [path];\\n    return this.#hasPath(this.map, pathArray, 0);\\n  }\\n\\n  set(path, value) {\\n    const pathArray = Array.isArray(path) ? path : [path];\\n    this.#setValueForPath(this.map, pathArray, value);\\n    return value;\\n  }\\n}\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const memo = new TrieMap();\\n    return function(...args) {\\n      return memo.has(args) ? memo.get(args) : memo.set(args, fn(...args));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985869,
                "title": "very-fast-ts-solution",
                "content": "# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return function(...args) {\\n        let currentStore = store;\\n        for (let i = 0; i < args.length; i++) {\\n            if (currentStore.has(args[i])) {\\n                currentStore = currentStore.get(args[i]);\\n            } else {\\n                let map = new Map();\\n                currentStore.set(args[i], map);\\n                currentStore = map;\\n            }\\n        }\\n        if (currentStore.has(\\'value\\')) {\\n            return currentStore.get(\\'value\\')\\n        }\\n\\n        let result = fn.call(this, ...args);\\n        currentStore.set(\\'value\\', result);\\n\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const store = new Map();\\n    return function(...args) {\\n        let currentStore = store;\\n        for (let i = 0; i < args.length; i++) {\\n            if (currentStore.has(args[i])) {\\n                currentStore = currentStore.get(args[i]);\\n            } else {\\n                let map = new Map();\\n                currentStore.set(args[i], map);\\n                currentStore = map;\\n            }\\n        }\\n        if (currentStore.has(\\'value\\')) {\\n            return currentStore.get(\\'value\\')\\n        }\\n\\n        let result = fn.call(this, ...args);\\n        currentStore.set(\\'value\\', result);\\n\\n        return result;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950817,
                "title": "ts-9-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis one was different from Memoize $$I$$ by allow various type of multiple input. I had to map that into an ID to avoid complexity of Trie.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing double `Map` should resolve the ID part since `Map` allow key of any type.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const ids = new Map<unknown, number>();\\n    const cache = new Map<string, unknown>();\\n    return function(...args) {\\n        let temp;\\n        const key = args.map(arg => ids.get(arg) ?? (ids.set(arg, temp = ids.size), temp)).join(\\'.\\');\\n        return cache.get(key) ?? (cache.set(key, temp = fn(...args)), temp);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    const ids = new Map<unknown, number>();\\n    const cache = new Map<string, unknown>();\\n    return function(...args) {\\n        let temp;\\n        const key = args.map(arg => ids.get(arg) ?? (ids.set(arg, temp = ids.size), temp)).join(\\'.\\');\\n        return cache.get(key) ?? (cache.set(key, temp = fn(...args)), temp);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938546,
                "title": "solution-using-tree-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass TreeNode {\\n    constructor() {\\n        this.map = new Map\\n        this.hasValue = false\\n        this.result = null\\n    }\\n\\n    set(path, idx, result) {\\n        let key = path[idx]\\n\\n        if (idx == path.length) {\\n            this.result = result\\n            this.hasValue = true\\n        } else {\\n            if(!this.map.has(key)) {\\n                this.map.set(key, new TreeNode)\\n            }\\n            this.map.get(key).set(path, idx + 1, result)\\n        }\\n    }\\n\\n    get(path, idx) {\\n        let key = path[idx]\\n        if(idx == path.length) {\\n            if(this.hasValue) {\\n                return {\\n                    success: true,\\n                    result: this.result\\n                }\\n            } \\n            return {\\n                success: false,\\n                result: null\\n            }\\n        } else {\\n            if(this.map.has(key)) {\\n                let childNode = this.map.get(key)\\n                return childNode.get(path, idx + 1)\\n            }\\n            return {\\n                success: false,\\n                result: null\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let rootNode = new TreeNode\\n\\n    return function(...args) {\\n        let output = rootNode.get(args, 0)\\n\\n        if(output.success){\\n            return output.result\\n        }\\n\\n        let result = fn.apply(null, args)\\n\\n        rootNode.set(args, 0, result)\\n\\n        return result\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nclass TreeNode {\\n    constructor() {\\n        this.map = new Map\\n        this.hasValue = false\\n        this.result = null\\n    }\\n\\n    set(path, idx, result) {\\n        let key = path[idx]\\n\\n        if (idx == path.length) {\\n            this.result = result\\n            this.hasValue = true\\n        } else {\\n            if(!this.map.has(key)) {\\n                this.map.set(key, new TreeNode)\\n            }\\n            this.map.get(key).set(path, idx + 1, result)\\n        }\\n    }\\n\\n    get(path, idx) {\\n        let key = path[idx]\\n        if(idx == path.length) {\\n            if(this.hasValue) {\\n                return {\\n                    success: true,\\n                    result: this.result\\n                }\\n            } \\n            return {\\n                success: false,\\n                result: null\\n            }\\n        } else {\\n            if(this.map.has(key)) {\\n                let childNode = this.map.get(key)\\n                return childNode.get(path, idx + 1)\\n            }\\n            return {\\n                success: false,\\n                result: null\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let rootNode = new TreeNode\\n\\n    return function(...args) {\\n        let output = rootNode.get(args, 0)\\n\\n        if(output.success){\\n            return output.result\\n        }\\n\\n        let result = fn.apply(null, args)\\n\\n        rootNode.set(args, 0, result)\\n\\n        return result\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923814,
                "title": "simple-typescript-solution",
                "content": "# Code\\n```\\ntype MemoizedFunction<Params extends unknown[], Return> = (\\n  ...params: Params\\n) => Return;\\ntype Memo = Map<unknown, Memo | unknown>;\\n\\nconst memoize = <Params extends unknown[], Return>(\\n  fn: (...params: Params) => Return\\n): MemoizedFunction<Params, Return> => {\\n  const memo: Memo = new Map();\\n  const RESULT_KEY = Symbol(\"result\");\\n  return (...args) => {\\n    let curMemo = memo;\\n    for (let i = 0; i < args.length; i++) {\\n      if (!curMemo.has(args[i])) curMemo.set(args[i], new Map());\\n      curMemo = curMemo.get(args[i]) as Memo;\\n    }\\n    if (!curMemo.has(RESULT_KEY)) curMemo.set(RESULT_KEY, fn(...args));\\n    return curMemo.get(RESULT_KEY) as Return;\\n  };\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table",
                    "Memoization"
                ],
                "code": "```\\ntype MemoizedFunction<Params extends unknown[], Return> = (\\n  ...params: Params\\n) => Return;\\ntype Memo = Map<unknown, Memo | unknown>;\\n\\nconst memoize = <Params extends unknown[], Return>(\\n  fn: (...params: Params) => Return\\n): MemoizedFunction<Params, Return> => {\\n  const memo: Memo = new Map();\\n  const RESULT_KEY = Symbol(\"result\");\\n  return (...args) => {\\n    let curMemo = memo;\\n    for (let i = 0; i < args.length; i++) {\\n      if (!curMemo.has(args[i])) curMemo.set(args[i], new Map());\\n      curMemo = curMemo.get(args[i]) as Memo;\\n    }\\n    if (!curMemo.has(RESULT_KEY)) curMemo.set(RESULT_KEY, fn(...args));\\n    return curMemo.get(RESULT_KEY) as Return;\\n  };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3769680,
                "title": "typescript-annotated-map-based-trie",
                "content": "# Intuition\\nMemoizing is tricky, and JavaScript arguments could really be any value. Developing a hashing algorithm that accepts an arbitrary list of arguments could be perilous, especially if arguments are objects that may contain non-serializable properties like prototypes.\\n\\nInstead, let\\'s produce a very generic algorithm that uses native JavaScript strict equality checks implemented by the `Map` class to avoid writing comparison logic ourselves. `Map` and `Set` are both notorious for supporting arbitrary JS values as keys, so they are a great fit for arguments which can be any value.\\n\\n# Approach\\nLet\\'s produce a trie structure to represent arguments & solutions.\\n\\nA node in our trie represents a call with the given argument chain.\\n\\n```ts\\ntype ArgNode {\\n  // Will be defined if we have a cached solution for this arg chain\\n  solution?: SolutionNode\\n  // Represents a subsequent argument\\n  nextArgs: Map<any, ArgNode>;\\n}\\n```\\n\\nOur solutionNode will be a \"box\" for a return value. We box the value in order to avoid to simplify the \"has solution\" check.\\n\\n```ts\\ntype SolutionNode = { ret: any };\\n```\\n\\nOur root Node represents a call with 0 arguments to the function. It has no solution yet.\\n```ts\\nconst rootNode: ArgNode = { nextArgs: new Map() };\\n```\\n\\nWhen we get called with a given list of arguments, we start at the root node and recursively traverse the trie to find previous solutions. If we do not find a node for the current arg, we create the new node(s) in order to allocate the spot to store our answer.\\n\\nOnce we finish traversing the structure, we should be at a node representing the specific argument chain we were called with. We can check for a cached solution here, or call the original function and cache the result.\\n\\n\\n# Complexity\\n- Time complexity: O(n) on argument length of the call.\\n\\n- Space complexity: O(k) on total unique argument chains \\n  - I\\'m pretty hand-wavy on this... More or less scales with unique calls.\\n\\n# Code\\n\\n```ts\\ntype SolutionNode = { ret: any };\\ntype ArgNode {\\n  // Will be defined if we have a cached solution for this arg chain\\n  solution?: SolutionNode\\n  // Represents a subsequent argument\\n  nextArgs: Map<any, ArgNode>;\\n}\\n\\nfunction memoize(fn: Fn): Fn {\\n    const rootNode: ArgNode = { nextArgs: new Map() };\\n\\n    return function(...args) {\\n        let cur: ArgNode = rootNode;\\n\\n        // If we have no args, we will end up at the root node.\\n        for(const arg of args) {\\n            if(!cur.nextArgs.has(arg)) {\\n                // If this arg hasn\\'t been seen before, \\n                // create an entry for it and continue\\n                cur.nextArgs.set(arg, { nextArgs: new Map() })\\n            }\\n            // Traverse to the next argument node\\n            cur = cur.nextArgs.get(arg);\\n        }\\n\\n        // We have reached the final spot in our Trie\\n        // representing a call with the current argument chain.\\n\\n        if(!cur.solution) {\\n            // If we don\\'t have a solution cached for this arg chain,\\n            // run the function and save the value\\n            const ret = fn(...args);\\n            cur.solution = { ret };\\n        }\\n\\n        // Return the cached value for the current arg chain.\\n        return cur.solution.ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Trie"
                ],
                "code": "```ts\\ntype ArgNode {\\n  // Will be defined if we have a cached solution for this arg chain\\n  solution?: SolutionNode\\n  // Represents a subsequent argument\\n  nextArgs: Map<any, ArgNode>;\\n}\\n```\n```ts\\ntype SolutionNode = { ret: any };\\n```\n```ts\\nconst rootNode: ArgNode = { nextArgs: new Map() };\\n```\n```ts\\ntype SolutionNode = { ret: any };\\ntype ArgNode {\\n  // Will be defined if we have a cached solution for this arg chain\\n  solution?: SolutionNode\\n  // Represents a subsequent argument\\n  nextArgs: Map<any, ArgNode>;\\n}\\n\\nfunction memoize(fn: Fn): Fn {\\n    const rootNode: ArgNode = { nextArgs: new Map() };\\n\\n    return function(...args) {\\n        let cur: ArgNode = rootNode;\\n\\n        // If we have no args, we will end up at the root node.\\n        for(const arg of args) {\\n            if(!cur.nextArgs.has(arg)) {\\n                // If this arg hasn\\'t been seen before, \\n                // create an entry for it and continue\\n                cur.nextArgs.set(arg, { nextArgs: new Map() })\\n            }\\n            // Traverse to the next argument node\\n            cur = cur.nextArgs.get(arg);\\n        }\\n\\n        // We have reached the final spot in our Trie\\n        // representing a call with the current argument chain.\\n\\n        if(!cur.solution) {\\n            // If we don\\'t have a solution cached for this arg chain,\\n            // run the function and save the value\\n            const ret = fn(...args);\\n            cur.solution = { ret };\\n        }\\n\\n        // Return the cached value for the current arg chain.\\n        return cur.solution.ret;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659766,
                "title": "na-ve-nested-maps-top-level-by-number-of-args",
                "content": "# Intuition\\nCreate a tree-like structure of maps that use the argument values as keys, with the value being at a \"leaf\" of the tree.\\n\\n# Approach\\nAt first I wanted to use WeakMap to minimize the footprint of the cache, but it doesn\\'t allow non-object arguments (since it only works with reference types and not value-only types). So like everyone else we just went with a map.\\n\\nInstead of the approach I saw of going down the tree and using a symbol to \"hide\" the value in the tree at the end, I create a caches based on different numbers of arguments. This probably makes it less memory efficient than algorithms that use a symbol.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map();\\n\\n    return function(...args) {\\n        let currentCache;\\n        if (cache.has(args.length)) {\\n            currentCache = cache.get(args.length);\\n        }\\n        else {\\n            currentCache = new Map();\\n            cache.set(args.length, currentCache);\\n        }\\n\\n        for (let i=0, len=args.length; i<=len; i++){\\n            const arg = args[i];\\n            const isEnd = i >= len - 1;\\n\\n            if (currentCache.has(arg)) {\\n                if (isEnd) {\\n                    return currentCache.get(arg);\\n                }\\n                else {\\n                    currentCache = currentCache.get(arg);\\n                }\\n            }\\n            else {\\n                if (isEnd) {\\n                    break;\\n                }\\n                else {\\n                    const newSubCache = new Map();\\n\\n                    currentCache.set(arg, newSubCache);\\n                    currentCache = newSubCache;\\n                }\\n            }\\n        }\\n\\n        var value = fn.apply(null, args);\\n\\n        currentCache.set(args[args.length - 1], value);\\n        return value;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const cache = new Map();\\n\\n    return function(...args) {\\n        let currentCache;\\n        if (cache.has(args.length)) {\\n            currentCache = cache.get(args.length);\\n        }\\n        else {\\n            currentCache = new Map();\\n            cache.set(args.length, currentCache);\\n        }\\n\\n        for (let i=0, len=args.length; i<=len; i++){\\n            const arg = args[i];\\n            const isEnd = i >= len - 1;\\n\\n            if (currentCache.has(arg)) {\\n                if (isEnd) {\\n                    return currentCache.get(arg);\\n                }\\n                else {\\n                    currentCache = currentCache.get(arg);\\n                }\\n            }\\n            else {\\n                if (isEnd) {\\n                    break;\\n                }\\n                else {\\n                    const newSubCache = new Map();\\n\\n                    currentCache.set(arg, newSubCache);\\n                    currentCache = newSubCache;\\n                }\\n            }\\n        }\\n\\n        var value = fn.apply(null, args);\\n\\n        currentCache.set(args[args.length - 1], value);\\n        return value;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627440,
                "title": "easy-trie-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a Trie data structure and store the arguments in it :)\\n# Complexity\\n- Time complexity: O(q*args.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWhere q is number of queries.\\n- Space complexity: O(args.length)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    class trie{\\n        val : any;\\n        next : Map<any,trie>;\\n        end : boolean;\\n        public constructor(){\\n            this.end = false;\\n            this.val = null;\\n            this.next = new Map<any,trie>();\\n        } \\n    }\\n    let root = new trie();\\n    \\n    function insert(args,fn : Fn){\\n        let cur = root;\\n        for(let x of args){\\n            if(!(cur.next.has(x))){\\n                cur.next.set(x,new trie());\\n            }\\n            cur = cur.next.get(x);\\n        }\\n        if(!cur.end){\\n            cur.end = true;\\n            cur.val = fn(...args);\\n        }\\n        return cur.val;\\n        \\n    }\\n\\n    \\n    return function(...args) {\\n        return insert(args,fn);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    class trie{\\n        val : any;\\n        next : Map<any,trie>;\\n        end : boolean;\\n        public constructor(){\\n            this.end = false;\\n            this.val = null;\\n            this.next = new Map<any,trie>();\\n        } \\n    }\\n    let root = new trie();\\n    \\n    function insert(args,fn : Fn){\\n        let cur = root;\\n        for(let x of args){\\n            if(!(cur.next.has(x))){\\n                cur.next.set(x,new trie());\\n            }\\n            cur = cur.next.get(x);\\n        }\\n        if(!cur.end){\\n            cur.end = true;\\n            cur.val = fn(...args);\\n        }\\n        return cur.val;\\n        \\n    }\\n\\n    \\n    return function(...args) {\\n        return insert(args,fn);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622122,
                "title": "easy-to-understand-solution-with-approach-explained-trie-solution-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution basically creates a new map at every step of the way for each arguments and at  the ends of the arguments just stores the result in a `ans` key. If for a given map ref parameter there is `ans` key it means it has been executed with those many arguments. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) -> N is no of arguments + 2 (constant-> for fn and ans key)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*k) -> N of arguments and k is no of unique arguments\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memoMap = new Map();\\n    return function(...args) {\\n        // if already memoized then check for the no. of arguments \\n        // and if ans key exist or not on the map and return.\\n        // otherwise create new map\\n        if(memoMap.has(fn)){\\n          let mapRef=memoMap.get(fn);\\n          let flag=true;\\n          args.forEach((arg)=>{\\n            if(flag && mapRef.has(arg)){\\n              mapRef=mapRef.get(arg);\\n            }else{\\n              flag=false;\\n            }\\n          })\\n          if(flag && mapRef.has(\"ans\")){\\n            return mapRef.get(\"ans\");\\n          }\\n        }else{\\n          memoMap.set(fn,new Map());\\n        }\\n\\n        // execute the function and create new maps for each arg and \\n        // at the end store the result in ans key and return the value \\n        const value = fn(...args);\\n        let mapRef=memoMap.get(fn);\\n        args.forEach((arg)=>{\\n          if(mapRef.has(arg)){\\n            mapRef=mapRef.get(arg);\\n          }else{\\n            mapRef.set(arg,new Map());\\n            mapRef=mapRef.get(arg);\\n          }\\n        });\\n        mapRef.set(\"ans\",value);\\n        return value;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memoMap = new Map();\\n    return function(...args) {\\n        // if already memoized then check for the no. of arguments \\n        // and if ans key exist or not on the map and return.\\n        // otherwise create new map\\n        if(memoMap.has(fn)){\\n          let mapRef=memoMap.get(fn);\\n          let flag=true;\\n          args.forEach((arg)=>{\\n            if(flag && mapRef.has(arg)){\\n              mapRef=mapRef.get(arg);\\n            }else{\\n              flag=false;\\n            }\\n          })\\n          if(flag && mapRef.has(\"ans\")){\\n            return mapRef.get(\"ans\");\\n          }\\n        }else{\\n          memoMap.set(fn,new Map());\\n        }\\n\\n        // execute the function and create new maps for each arg and \\n        // at the end store the result in ans key and return the value \\n        const value = fn(...args);\\n        let mapRef=memoMap.get(fn);\\n        args.forEach((arg)=>{\\n          if(mapRef.has(arg)){\\n            mapRef=mapRef.get(arg);\\n          }else{\\n            mapRef.set(arg,new Map());\\n            mapRef=mapRef.get(arg);\\n          }\\n        });\\n        mapRef.set(\"ans\",value);\\n        return value;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3621728,
                "title": "javascript-nested-map",
                "content": "# Intuition\\nThe storage has the following structure;\\nMap() -> Map(arg.length) -> Map(firstArg) -> Map(secondArg) -> ... -> Map(nArg) -> value;\\nBeats: 95.14% Runtime and 50.51% Memory. \\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = new Map();\\n    \\n    const calculateAndSave = (args) => {\\n        const result = fn(...args);\\n        let memLink = memo.get(args.length);\\n        if (!memo.has(args.length)) {\\n            const nestedMap = args.length === 0 ? result : new Map();\\n            memo.set(args.length, nestedMap);\\n            memLink = nestedMap;\\n        }\\n        \\n        args.forEach((arg, index) => {\\n            if (memLink.has(arg)) {\\n                memLink = memLink.get(arg);\\n            } else {\\n                const nestedMap = index === args.length - 1 ? result : new Map();\\n                memLink.set(arg, nestedMap);\\n                memLink = nestedMap; \\n            }\\n        });\\n\\n        return result;\\n    };\\n\\n    const returnFromCache = (args) => {\\n        if (!memo.has(args.length)) {\\n            return calculateAndSave(args);\\n        }\\n        let memLink = memo.get(args.length);\\n\\n        for (let arg of args) {\\n            if (memLink.has(arg)) {\\n                memLink = memLink.get(arg);\\n            } else {\\n                return calculateAndSave(args);\\n            }\\n        }\\n\\n        return memLink;\\n    }\\n\\n    return function(...args) {\\n        return returnFromCache(args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const memo = new Map();\\n    \\n    const calculateAndSave = (args) => {\\n        const result = fn(...args);\\n        let memLink = memo.get(args.length);\\n        if (!memo.has(args.length)) {\\n            const nestedMap = args.length === 0 ? result : new Map();\\n            memo.set(args.length, nestedMap);\\n            memLink = nestedMap;\\n        }\\n        \\n        args.forEach((arg, index) => {\\n            if (memLink.has(arg)) {\\n                memLink = memLink.get(arg);\\n            } else {\\n                const nestedMap = index === args.length - 1 ? result : new Map();\\n                memLink.set(arg, nestedMap);\\n                memLink = nestedMap; \\n            }\\n        });\\n\\n        return result;\\n    };\\n\\n    const returnFromCache = (args) => {\\n        if (!memo.has(args.length)) {\\n            return calculateAndSave(args);\\n        }\\n        let memLink = memo.get(args.length);\\n\\n        for (let arg of args) {\\n            if (memLink.has(arg)) {\\n                memLink = memLink.get(arg);\\n            } else {\\n                return calculateAndSave(args);\\n            }\\n        }\\n\\n        return memLink;\\n    }\\n\\n    return function(...args) {\\n        return returnFromCache(args);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579682,
                "title": "memoization-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const key = Symbol()\\n  const memo = new Map()\\n  return function(...args) {\\n    let curr = memo\\n    if (args.length === 0 && !curr.has(key)) {\\n      curr.set(key, fn())\\n    }\\n    args.forEach((arg, i) => {\\n      if (curr.has(arg)) {\\n        curr = curr.get(arg)\\n          if (i === (args.length - 1) && !curr.has(key)){\\n            curr.set(key, fn(...args))\\n          }\\n      } else {\\n        curr.set(arg, new Map())\\n        curr = curr.get(arg)\\n        if (i === (args.length - 1)){\\n          curr.set(key, fn(...args))\\n        }\\n      }\\n    })\\n    return curr.get(key);\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const key = Symbol()\\n  const memo = new Map()\\n  return function(...args) {\\n    let curr = memo\\n    if (args.length === 0 && !curr.has(key)) {\\n      curr.set(key, fn())\\n    }\\n    args.forEach((arg, i) => {\\n      if (curr.has(arg)) {\\n        curr = curr.get(arg)\\n          if (i === (args.length - 1) && !curr.has(key)){\\n            curr.set(key, fn(...args))\\n          }\\n      } else {\\n        curr.set(arg, new Map())\\n        curr = curr.get(arg)\\n        if (i === (args.length - 1)){\\n          curr.set(key, fn(...args))\\n        }\\n      }\\n    })\\n    return curr.get(key);\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539794,
                "title": "javascript-map-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    const trie = new Trie();\\n\\n    return function (...args) {\\n        let currentTrie = trie, value, index;\\n\\n        for (index = 0; index < args.length; index++) {\\n            const element = args[index];\\n\\n            if (currentTrie.children.get(element))\\n                currentTrie = currentTrie.children.get(element);\\n            else\\n                break;\\n        }\\n\\n        if (index === args.length && currentTrie.isCached)\\n            return currentTrie.cache;\\n\\n        value = fn(...args);\\n\\n        for (; index < args.length; index++) {\\n            const element = args[index];\\n\\n            currentTrie.children.set(element, new Trie());\\n            currentTrie = currentTrie.children.get(element);\\n        }\\n\\n        currentTrie.isCached = true;\\n        currentTrie.cache = value;\\n\\n        return value;\\n    }\\n}\\n\\nclass Trie {\\n    constructor() {\\n        this.children = new Map();\\n        this.isCached = false;\\n        this.cache = null;\\n    }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    const trie = new Trie();\\n\\n    return function (...args) {\\n        let currentTrie = trie, value, index;\\n\\n        for (index = 0; index < args.length; index++) {\\n            const element = args[index];\\n\\n            if (currentTrie.children.get(element))\\n                currentTrie = currentTrie.children.get(element);\\n            else\\n                break;\\n        }\\n\\n        if (index === args.length && currentTrie.isCached)\\n            return currentTrie.cache;\\n\\n        value = fn(...args);\\n\\n        for (; index < args.length; index++) {\\n            const element = args[index];\\n\\n            currentTrie.children.set(element, new Trie());\\n            currentTrie = currentTrie.children.get(element);\\n        }\\n\\n        currentTrie.isCached = true;\\n        currentTrie.cache = value;\\n\\n        return value;\\n    }\\n}\\n\\nclass Trie {\\n    constructor() {\\n        this.children = new Map();\\n        this.isCached = false;\\n        this.cache = null;\\n    }\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528004,
                "title": "using-tree-of-maps",
                "content": "# Approach\\nSets and Retrieves a key as a unique path in a tree of maps\\n\\n# Complexity\\n- Time complexity:\\nO(n) - n is the number of arguments passed to the function. Doesn\\'t account for the time complexity of the function.\\n\\n- Space complexity:\\nO(n) - n is the number of unique function calls\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    const cache = new Map()\\n    return function(...args) {\\n        let key = args.length > 0 ? getCacheKey(cache, args) : cache;\\n\\n        if (key.has(\\'result\\')) {\\n            return key.get(\\'result\\');\\n        }\\n\\n        const result = fn.apply(this, args);\\n        key.set(\\'result\\', result);\\n        return result;\\n    }\\n}\\n\\nfunction getCacheKey(cache, args) {\\n    let argCache = cache;\\n\\n    for (let i=0; i < args.length; i++) {\\n        let argKey = args[i]\\n        if (argCache.has(argKey)) {\\n            argCache = argCache.get(argKey)\\n        } else {\\n            let newCache = new Map()\\n            argCache.set(argKey, newCache)\\n            argCache = newCache\\n        }\\n    }\\n\\n    return argCache\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    const cache = new Map()\\n    return function(...args) {\\n        let key = args.length > 0 ? getCacheKey(cache, args) : cache;\\n\\n        if (key.has(\\'result\\')) {\\n            return key.get(\\'result\\');\\n        }\\n\\n        const result = fn.apply(this, args);\\n        key.set(\\'result\\', result);\\n        return result;\\n    }\\n}\\n\\nfunction getCacheKey(cache, args) {\\n    let argCache = cache;\\n\\n    for (let i=0; i < args.length; i++) {\\n        let argKey = args[i]\\n        if (argCache.has(argKey)) {\\n            argCache = argCache.get(argKey)\\n        } else {\\n            let newCache = new Map()\\n            argCache.set(argKey, newCache)\\n            argCache = newCache\\n        }\\n    }\\n\\n    return argCache\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3527923,
                "title": "simple-trie-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince there\\'s no requirement that the cache\\'s size is bounded, and there\\'s no way to combine comparisons, we use a simple trie.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNested maps, using a special \\'identity\\' key to index function call results. The identity key disambiguates fn(1, 2) and fn(1, 2, 3).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$ where k is the length of the argument list.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ We store the entire inputs (by reference). Constant overhead for each level of nesting (based on input).\\n\\n# Code\\n```\\nconst identity = {};\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return function(...args) {\\n        let cur = cache;\\n        for(let arg of args) {\\n            if(!cur.has(arg)) {\\n                cur.set(arg, new Map());\\n            }\\n            cur = cur.get(arg);\\n        }\\n\\n        if(!cur.has(identity)) {\\n            cur.set(identity, fn.apply(null, args));\\n        }\\n\\n\\n        return cur.get(identity);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst identity = {};\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache = new Map();\\n    return function(...args) {\\n        let cur = cache;\\n        for(let arg of args) {\\n            if(!cur.has(arg)) {\\n                cur.set(arg, new Map());\\n            }\\n            cur = cur.get(arg);\\n        }\\n\\n        if(!cur.has(identity)) {\\n            cur.set(identity, fn.apply(null, args));\\n        }\\n\\n\\n        return cur.get(identity);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524118,
                "title": "trie-map-symbol-simple-explanation",
                "content": "# Intuition\\n\\n**Brute force:**\\nWe can to store array of arguments and record results for each unique array of args. We simply search for an arguments list where number of args\\nis equal to current and each argument === with the matching argument list entry. \\nFails for large number of unique calls as it grows history array.\\n\\n**Optimization**\\nLinear search in the array of argument array is very costly.\\nSince argument order should also be fixed for a unique function call, what if we can search previous matching call as we see each new argument.\\nThis is nothing but a Trie data structure.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFortunately each argument across function call can be matched by === equality. Thus, it can act a unique key for a Map object.\\nUsing Map we can imagine a Trie DS where single argument is key in TrieNode.\\nFinally we need some unique key to denote function results in our TrieNode which should not clash with argument keys.\\nSuch unique key is possible with Symbol dataType of Js.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nfor n params finding the memoized result is, \\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace used by nested Map / Trie. For m unique (argument,index) across calls\\n$$O(m)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    const history = new Map();\\n    const VALUE = Symbol(\\'hasValue\\');\\n\\n    return function(...args) {\\n      let trieNode = history;\\n      for(let arg of args){\\n        if(trieNode.has(arg)){\\n          trieNode = trieNode.get(arg);\\n        }else {\\n          let next = new Map();\\n          trieNode.set(arg, next);\\n          trieNode = next;\\n        }\\n      }\\n      \\n      if(trieNode.has(VALUE))\\n        return trieNode.get(VALUE);\\n      \\n      const res = fn(...args);\\n      trieNode.set(VALUE, res);\\n      return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\nfunction memoize(fn) {\\n    const history = new Map();\\n    const VALUE = Symbol(\\'hasValue\\');\\n\\n    return function(...args) {\\n      let trieNode = history;\\n      for(let arg of args){\\n        if(trieNode.has(arg)){\\n          trieNode = trieNode.get(arg);\\n        }else {\\n          let next = new Map();\\n          trieNode.set(arg, next);\\n          trieNode = next;\\n        }\\n      }\\n      \\n      if(trieNode.has(VALUE))\\n        return trieNode.get(VALUE);\\n      \\n      const res = fn(...args);\\n      trieNode.set(VALUE, res);\\n      return res;\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521776,
                "title": "easy-to-understand-solution-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is how to deal object type value, such as `{}`, so we can transfer all input args to a unique value string, make object to int string, and the solution will be easy and clear.\\n# Approach\\nBelow is my approach code.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let vMap = new Map()\\n    let kMap = new Map()\\n    let id = 0\\n    return function(...args) {\\n        let k = \\'\\'\\n        for(let item of args) {\\n            if(kMap.has(item)) {\\n                k = k + \\'-\\' + kMap.get(item)\\n            } else {\\n                k = k + \\'-\\' + id\\n                kMap.set(item, id++)\\n            }\\n        }\\n\\n        if(vMap.has(k)) return vMap.get(k)\\n\\n        let v = fn(...args)\\n        vMap.set(k, v)\\n\\n        return v\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let vMap = new Map()\\n    let kMap = new Map()\\n    let id = 0\\n    return function(...args) {\\n        let k = \\'\\'\\n        for(let item of args) {\\n            if(kMap.has(item)) {\\n                k = k + \\'-\\' + kMap.get(item)\\n            } else {\\n                k = k + \\'-\\' + id\\n                kMap.set(item, id++)\\n            }\\n        }\\n\\n        if(vMap.has(k)) return vMap.get(k)\\n\\n        let v = fn(...args)\\n        vMap.set(k, v)\\n\\n        return v\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519236,
                "title": "2630-memoize-ii",
                "content": "# Intuition - \\nThe code implements a memoization technique to cache the results of a given function `fn`. It ensures that the function is not called multiple times with the same inputs, instead returning the cached result if available.\\n\\n# Approach - \\n1. The `memoize` function takes the original function (`fn`) as input and returns a memoized version of it.\\n2. The memoized function maintains a global cache (`globalCache`) using a nested `Map` structure.\\n3. When the memoized function is called with arguments (`params`), it iterates over the arguments and traverses the cache hierarchy to check if the current argument is already cached.\\n4. If the current argument is not found in the cache, a new entry is created in the cache hierarchy using a `Map`.\\n5. If the final cache level contains the result (`RES`), it is returned from the cache.\\n6. If the result is not found in the cache, the original function (`fn`) is called with the provided arguments (`params`) to calculate the result.\\n7. The result is then stored in the cache for future use.\\n8. The memoized function returns the result.\\n\\n# Complexity - \\n- The time complexity of the memoized function depends on the time complexity of the original function (`fn`), as well as the efficiency of cache lookups and insertions in the `Map` data structure.\\n- The space complexity is influenced by the number of unique argument combinations and the size of the cached results.\\n\\nOverall, the memoization technique improves performance by avoiding redundant function calls and reusing cached results when possible.\\n\\n# Code\\n```\\nconst RES = Symbol(\"res\");\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const globalCache = new Map();\\n\\n  return (...params) => {\\n    let currentCache = globalCache;\\n    for (const param of params) {\\n      if (!currentCache.has(param)) {\\n        currentCache.set(param, new Map());\\n      }\\n      currentCache = currentCache.get(param);\\n    }\\n\\n    if (currentCache.has(RES)) return currentCache.get(RES);\\n\\n    const result = fn(...params);\\n\\n    currentCache.set(RES, result);\\n    return result;\\n  };\\n}\\n\\nconst getInputs = () => [[{},{}],[{},{}],[{},{}]];\\nconst myFn = memoize(function (a, b) { return ({...a, ...b}); });\\n\\nconst inputs = getInputs();\\nconst output = [];\\nfor (const arr of inputs) {\\n  const calls = arr.reduce((acc, cur) => acc + (typeof cur === \\'object\\' ? 1 : 0), 0);\\n  output.push({ val: myFn(...arr), calls });\\n}\\n\\nconsole.log(output);\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst RES = Symbol(\"res\");\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const globalCache = new Map();\\n\\n  return (...params) => {\\n    let currentCache = globalCache;\\n    for (const param of params) {\\n      if (!currentCache.has(param)) {\\n        currentCache.set(param, new Map());\\n      }\\n      currentCache = currentCache.get(param);\\n    }\\n\\n    if (currentCache.has(RES)) return currentCache.get(RES);\\n\\n    const result = fn(...params);\\n\\n    currentCache.set(RES, result);\\n    return result;\\n  };\\n}\\n\\nconst getInputs = () => [[{},{}],[{},{}],[{},{}]];\\nconst myFn = memoize(function (a, b) { return ({...a, ...b}); });\\n\\nconst inputs = getInputs();\\nconst output = [];\\nfor (const arr of inputs) {\\n  const calls = arr.reduce((acc, cur) => acc + (typeof cur === \\'object\\' ? 1 : 0), 0);\\n  output.push({ val: myFn(...arr), calls });\\n}\\n\\nconsole.log(output);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518975,
                "title": "ts-using-trie-prefix-tree",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n  const trie = new Map();\\n\\n  return function (...params) {\\n    const node = { ref: trie };\\n\\n    for (const param of params) {\\n      if (!node.ref.has(param)) node.ref.set(param, new Map());\\n      node.ref = node.ref.get(param);\\n    }\\n\\n    if (node.ref.has(\\'result\\')) return node.ref.get(\\'result\\');\\n\\n    const result = fn(...params);\\n    node.ref.set(\\'result\\', result);\\n    \\n    return result;\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n  const trie = new Map();\\n\\n  return function (...params) {\\n    const node = { ref: trie };\\n\\n    for (const param of params) {\\n      if (!node.ref.has(param)) node.ref.set(param, new Map());\\n      node.ref = node.ref.get(param);\\n    }\\n\\n    if (node.ref.has(\\'result\\')) return node.ref.get(\\'result\\');\\n\\n    const result = fn(...params);\\n    node.ref.set(\\'result\\', result);\\n    \\n    return result;\\n  }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3518595,
                "title": "andreiusq-s-idea",
                "content": "# Intuition\\nThe problem requires us to implement memoization for a given function, which means caching the result of the function call when it\\'s called with the same arguments, so that it doesn\\'t have to recompute the same result again.\\n\\n# Approach\\nThe approach taken here is to use a `Map` data structure to cache the function\\'s return values for each set of arguments passed to it. When the function is called, it checks the cache to see if the result for the given arguments is already computed and stored in the cache. If it is, the cached result is returned and the function doesn\\'t have to compute the result again. If the result is not cached, then the function computes the result and stores it in the cache for future use.\\n\\nThe `Memoize` class implemented here provides the `write` and `read` methods to store and retrieve the cached results respectively. The `memoize` function takes the original function as an argument, and returns a new function that wraps the original function with memoization.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the `read` and `write` methods is O(n) where n is the number of arguments passed to the function. The time complexity of the memoized function is O(1) if the result is already cached, otherwise it\\'s O(n) as it involves a function call and cache write operation.\\n\\n- Space complexity:\\nThe space complexity of the cache is O(n), where n is the number of unique argument sets passed to the function. The space complexity of the memoized function is O(1) for each function call.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nclass Memoize {\\n  constructor() {\\n    this.cache = new Map();\\n  }\\n\\n  // Write the value into the tree at the specified key.\\n  write(key, value) {\\n    let curr = this.cache;\\n    for (const k of key) {\\n      if (!curr.has(k)) {\\n        curr.set(k, new Map());\\n      }\\n      curr = curr.get(k);\\n    }\\n    curr.set(\\'value\\', value);\\n  }\\n\\n  // Read the value from the tree at the specified key.\\n  read(key) {\\n    let curr = this.cache;\\n    for (const k of key) {\\n      if (!curr.has(k)) {\\n        return undefined;\\n      }\\n      curr = curr.get(k);\\n    }\\n    return curr.get(\\'value\\');\\n  }\\n}\\n\\nfunction memoize(fn) {\\n  const cache = new Memoize();\\n\\n  return function(...args) {\\n    const key = args;\\n    const cachedValue = cache.read(key);\\n\\n    if (cachedValue !== undefined) {\\n      return cachedValue;\\n    }\\n\\n    const value = fn.apply(this, args);\\n    cache.write(key, value);\\n    return value;\\n  };\\n}\\n\\n\\nfunction add(a, b) {\\n  console.log(`Running add(${a}, ${b})`);\\n  return a + b;\\n}\\n\\nconst memoizedAdd = memoize(add);\\n\\nconsole.log(memoizedAdd(1, 2)); // prints \"Running add(1, 2)\" and \"3\"\\nconsole.log(memoizedAdd(1, 2)); // prints \"3\"\\nconsole.log(memoizedAdd(2, 3)); // prints \"Running add(2, 3)\" and \"5\"\\nconsole.log(memoizedAdd(2, 3)); // prints \"5\"\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nclass Memoize {\\n  constructor() {\\n    this.cache = new Map();\\n  }\\n\\n  // Write the value into the tree at the specified key.\\n  write(key, value) {\\n    let curr = this.cache;\\n    for (const k of key) {\\n      if (!curr.has(k)) {\\n        curr.set(k, new Map());\\n      }\\n      curr = curr.get(k);\\n    }\\n    curr.set(\\'value\\', value);\\n  }\\n\\n  // Read the value from the tree at the specified key.\\n  read(key) {\\n    let curr = this.cache;\\n    for (const k of key) {\\n      if (!curr.has(k)) {\\n        return undefined;\\n      }\\n      curr = curr.get(k);\\n    }\\n    return curr.get(\\'value\\');\\n  }\\n}\\n\\nfunction memoize(fn) {\\n  const cache = new Memoize();\\n\\n  return function(...args) {\\n    const key = args;\\n    const cachedValue = cache.read(key);\\n\\n    if (cachedValue !== undefined) {\\n      return cachedValue;\\n    }\\n\\n    const value = fn.apply(this, args);\\n    cache.write(key, value);\\n    return value;\\n  };\\n}\\n\\n\\nfunction add(a, b) {\\n  console.log(`Running add(${a}, ${b})`);\\n  return a + b;\\n}\\n\\nconst memoizedAdd = memoize(add);\\n\\nconsole.log(memoizedAdd(1, 2)); // prints \"Running add(1, 2)\" and \"3\"\\nconsole.log(memoizedAdd(1, 2)); // prints \"3\"\\nconsole.log(memoizedAdd(2, 3)); // prints \"Running add(2, 3)\" and \"5\"\\nconsole.log(memoizedAdd(2, 3)); // prints \"5\"\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508809,
                "title": "js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = new Map();\\n  return function (...args) {\\n    let currentCache = cache;\\n\\n    for (const arg of args) {\\n      if (!currentCache.has(arg)) {\\n        currentCache.set(arg, new Map());\\n      }\\n      currentCache = currentCache.get(arg);\\n    }\\n\\n\\n    if (currentCache.has(\\'val\\')) {\\n      return currentCache.get(\\'val\\');\\n    }\\n\\n    const result = fn(...args);\\n    currentCache.set(\\'val\\', result);\\n    return result;\\n  };\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const cache = new Map();\\n  return function (...args) {\\n    let currentCache = cache;\\n\\n    for (const arg of args) {\\n      if (!currentCache.has(arg)) {\\n        currentCache.set(arg, new Map());\\n      }\\n      currentCache = currentCache.get(arg);\\n    }\\n\\n\\n    if (currentCache.has(\\'val\\')) {\\n      return currentCache.get(\\'val\\');\\n    }\\n\\n    const result = fn(...args);\\n    currentCache.set(\\'val\\', result);\\n    return result;\\n  };\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504197,
                "title": "javascript-using-maps",
                "content": "# Intuition\\nUsing a map we can parse and iterate over the arguments passed in to check if an answer is nested within our map datastructure.\\n\\n# Approach\\nThere\\'s a very special \\'gotcha\\' or edge case with this approach. Reduce functions that have initial values need to be accounted for even if there are no arguments being passed into the function! \\n\\nPlease leave a like if this helps you.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ number of parameters passed in.\\n\\n- Space complexity: $$O(n)$$ number of parameters needed to be stored in map\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\n\\n// function combineArgs(args) {\\n// }\\nfunction memoize(fn) {\\n    // store result String = function as string + parameters, result\\n    const cache = new Map();\\n    \\n    if (cache.has(String(fn)) === false) {\\n        cache.set(fn, new Map());\\n    }\\n// 83/89\\n    return function(...args) {\\n        // so how do we tell teh difference between args === args\\n        // for objects\\n        const fncache = cache.get(fn);\\n        let curr = fncache;\\n\\n        if (args.length == 0) { // for reduce.... functions with a initial value of 0\\n            if (curr.has(\"0\")) {\\n                curr = curr.get(\"0\");\\n            } else {\\n                curr.set(\"0\", new Map());\\n                curr = curr.get(\"0\")\\n                curr.set(\"answer\", fn(...args));\\n            }\\n\\n            return curr.get(\"answer\");\\n        } else {\\n            for (let i = 0; i < args.length; i++) {\\n                if (curr.has(args[i])) {\\n                    curr = curr.get(args[i]);\\n                } else {\\n                    curr.set(args[i], new Map());\\n                    curr = curr.get(args[i]);\\n                }\\n\\n                if (i == args.length-1) {\\n                    if (!curr.has(\\'answer\\')) {\\n                        curr.set(\\'answer\\', fn(...args));\\n                    }\\n                    return curr.get(\\'answer\\');\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\n\\n// function combineArgs(args) {\\n// }\\nfunction memoize(fn) {\\n    // store result String = function as string + parameters, result\\n    const cache = new Map();\\n    \\n    if (cache.has(String(fn)) === false) {\\n        cache.set(fn, new Map());\\n    }\\n// 83/89\\n    return function(...args) {\\n        // so how do we tell teh difference between args === args\\n        // for objects\\n        const fncache = cache.get(fn);\\n        let curr = fncache;\\n\\n        if (args.length == 0) { // for reduce.... functions with a initial value of 0\\n            if (curr.has(\"0\")) {\\n                curr = curr.get(\"0\");\\n            } else {\\n                curr.set(\"0\", new Map());\\n                curr = curr.get(\"0\")\\n                curr.set(\"answer\", fn(...args));\\n            }\\n\\n            return curr.get(\"answer\");\\n        } else {\\n            for (let i = 0; i < args.length; i++) {\\n                if (curr.has(args[i])) {\\n                    curr = curr.get(args[i]);\\n                } else {\\n                    curr.set(args[i], new Map());\\n                    curr = curr.get(args[i]);\\n                }\\n\\n                if (i == args.length-1) {\\n                    if (!curr.has(\\'answer\\')) {\\n                        curr.set(\\'answer\\', fn(...args));\\n                    }\\n                    return curr.get(\\'answer\\');\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492373,
                "title": "short-trie-solution-pure-js-with-explanation",
                "content": "# Intuition\\n1) **We can\\'t use stringify** because it\\'s very slow and it will mark distinct objects with the same structure as equal. \\na = {}, b = {} JSON.stringify(a) === JSON.stringify(a) - **wrong**, because a !== b\\n\\n2) It means we have to store args collections and search if we already used particular args combination.\\nBut if we store N function calls with K args in each, to find required combination we will need O(nk) time which is too slow\\n\\n3) Ok lets simplify this task: We have args [abcd, abcg, abed, abec], user passes newArgs [abed] and we want to quickly find a match...\\nIt sounds familiar to the classic **trie** datastructure problems.\\n\\n**Algorithm:**\\n1) build Trie\\n   - key in the Trie will be our args\\n   Map in js can use objects, null, undefined as a key\\n   - we add result of the call to the leaf of the trie\\n\\n2) each time we call function - we traverse our Trie \\n - we will find result for the exact args combination -> return result\\n - trie doesn\\'t have such args combination -> add new nodes to the trie and result to the last node.\\n\\nIt\\'s convinient to combine 1 and 2 in a single function,\\nit can be recursive or iterative (like any func to travers the tree)\\n\\n3) as usuall don\\'t forget to handle this properly\\n\\np.s. Please upvote this solution :)\\n# Code\\n```\\n//T.c: O(k) - k - length of the args\\n//S.c: O(k*calls) - calls - number of calls with uniq args\\nconst getResultFromTrie = (fn, args, thisArg, root) => {\\n    let cur = root\\n    for (let arg of args) {\\n        if (cur.has(arg)){  //dig into the tree until we find the leaf\\n            cur = cur.get(arg)\\n        } else {\\n            const tmp = new Map() //build new nodes if this is new args combination\\n            cur.set(arg, tmp)\\n            cur = tmp\\n        }\\n    }\\n\\n    //should be a better way to check case when { result: undefined } in the object...\\n    if (Object.keys(cur).includes(\\'result\\')) { \\n        return cur.result\\n    }\\n    cur.result = fn.apply(thisArg, args)\\n    return cur.result\\n}\\n\\nfunction memoize(fn) {\\n    const trie = new Map()\\n\\n    return function(...args) {\\n        return getResultFromTrie(fn, args, this, trie)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\n//T.c: O(k) - k - length of the args\\n//S.c: O(k*calls) - calls - number of calls with uniq args\\nconst getResultFromTrie = (fn, args, thisArg, root) => {\\n    let cur = root\\n    for (let arg of args) {\\n        if (cur.has(arg)){  //dig into the tree until we find the leaf\\n            cur = cur.get(arg)\\n        } else {\\n            const tmp = new Map() //build new nodes if this is new args combination\\n            cur.set(arg, tmp)\\n            cur = tmp\\n        }\\n    }\\n\\n    //should be a better way to check case when { result: undefined } in the object...\\n    if (Object.keys(cur).includes(\\'result\\')) { \\n        return cur.result\\n    }\\n    cur.result = fn.apply(thisArg, args)\\n    return cur.result\\n}\\n\\nfunction memoize(fn) {\\n    const trie = new Map()\\n\\n    return function(...args) {\\n        return getResultFromTrie(fn, args, this, trie)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486197,
                "title": "javascript-typescript-using-an-id-map-for-objects-and-symbols",
                "content": "# Code\\n```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    let memo = {};\\n    let count: number = 1;\\n    const idMap: Map<Object | Symbol, string> = new Map<Object | Symbol, string> ();\\n    function getObjectId(object: Object | Symbol): string {\\n        const objectId: string | undefined = idMap.get(object);\\n        if (objectId === undefined) {\\n            count += 1;\\n            const tempStr: string = \\'id: \\' + count;\\n            idMap.set(object, tempStr);\\n\\n            return tempStr;\\n        }\\n\\n        return objectId;\\n    }\\n    return function(...args) {\\n        const argArr = [...args];\\n        let str = \\'\\';\\n        //Check Object\\n        for(let i = 0; i<argArr.length; i++){\\n            if(typeof argArr[i] === \"object\" || typeof argArr[i] === \"symbol\") {\\n                str += \\', \\' + getObjectId(argArr[i]);\\n            } else {\\n                str += \\', \\' + argArr[i];\\n            }\\n        }\\n        //Repeat\\n        if(memo.hasOwnProperty(str)) return memo[str];\\n        //First Time\\n        const ret = fn(...args);\\n        memo[str] = ret;\\n        return ret;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Fn = (...params: any) => any\\n\\nfunction memoize(fn: Fn): Fn {\\n    let memo = {};\\n    let count: number = 1;\\n    const idMap: Map<Object | Symbol, string> = new Map<Object | Symbol, string> ();\\n    function getObjectId(object: Object | Symbol): string {\\n        const objectId: string | undefined = idMap.get(object);\\n        if (objectId === undefined) {\\n            count += 1;\\n            const tempStr: string = \\'id: \\' + count;\\n            idMap.set(object, tempStr);\\n\\n            return tempStr;\\n        }\\n\\n        return objectId;\\n    }\\n    return function(...args) {\\n        const argArr = [...args];\\n        let str = \\'\\';\\n        //Check Object\\n        for(let i = 0; i<argArr.length; i++){\\n            if(typeof argArr[i] === \"object\" || typeof argArr[i] === \"symbol\") {\\n                str += \\', \\' + getObjectId(argArr[i]);\\n            } else {\\n                str += \\', \\' + argArr[i];\\n            }\\n        }\\n        //Repeat\\n        if(memo.hasOwnProperty(str)) return memo[str];\\n        //First Time\\n        const ret = fn(...args);\\n        memo[str] = ret;\\n        return ret;\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3482612,
                "title": "readable-solution-using-trie-and-map",
                "content": "# Code\\n```\\nclass Trie {\\n    cache = {map: new Map()}\\n\\n    getNested = (params, index, map = this.cache.map) => {\\n        if(!params.length) {\\n            return this.cache\\n        }\\n        \\n        let key = params[index]\\n\\n        if(!map.has(key)) return -1\\n\\n        const cache = map.get(key)\\n\\n        if(index < params.length - 1) {\\n            return this.getNested(params, index+1, cache.map)\\n        } \\n  \\n        return cache\\n    } \\n\\n\\n    get = (params) => {\\n        return this.getNested(params, 0)\\n    }\\n\\n    setNested = (params, index, value, map = this.cache.map) => {\\n        if(!params.length) {\\n            this.cache.value = value\\n            this.cache.leaf = true\\n            return\\n        }\\n\\n        let key = params[index]\\n        let cache = map.get(key)\\n     \\n        if(!cache) {\\n            cache = {map: new Map()}\\n            map.set(key, cache)\\n        }\\n\\n        if(index === params.length - 1) {\\n            cache.value = value\\n            cache.leaf = true\\n            return\\n        }\\n\\n        this.setNested(params, index+1, value, cache.map)\\n    }\\n\\n    set = (params, value) => {\\n        this.setNested(params, 0, value)\\n    }\\n}\\n\\n\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let trie = new Trie()\\n\\n    return function (...args) {\\n        const cache = trie.get(args)\\n\\n        if(cache.leaf) return cache.value\\n\\n        const value = fn(...args)\\n\\n        trie.set(args, value)\\n\\n        return value\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Trie {\\n    cache = {map: new Map()}\\n\\n    getNested = (params, index, map = this.cache.map) => {\\n        if(!params.length) {\\n            return this.cache\\n        }\\n        \\n        let key = params[index]\\n\\n        if(!map.has(key)) return -1\\n\\n        const cache = map.get(key)\\n\\n        if(index < params.length - 1) {\\n            return this.getNested(params, index+1, cache.map)\\n        } \\n  \\n        return cache\\n    } \\n\\n\\n    get = (params) => {\\n        return this.getNested(params, 0)\\n    }\\n\\n    setNested = (params, index, value, map = this.cache.map) => {\\n        if(!params.length) {\\n            this.cache.value = value\\n            this.cache.leaf = true\\n            return\\n        }\\n\\n        let key = params[index]\\n        let cache = map.get(key)\\n     \\n        if(!cache) {\\n            cache = {map: new Map()}\\n            map.set(key, cache)\\n        }\\n\\n        if(index === params.length - 1) {\\n            cache.value = value\\n            cache.leaf = true\\n            return\\n        }\\n\\n        this.setNested(params, index+1, value, cache.map)\\n    }\\n\\n    set = (params, value) => {\\n        this.setNested(params, 0, value)\\n    }\\n}\\n\\n\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let trie = new Trie()\\n\\n    return function (...args) {\\n        const cache = trie.get(args)\\n\\n        if(cache.leaf) return cache.value\\n\\n        const value = fn(...args)\\n\\n        trie.set(args, value)\\n\\n        return value\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479043,
                "title": "cache-implementation-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    const root = new Map();\\n    return function (...args) {\\n        let node = root;\\n        for (const arg of args) {\\n            if(!node.has(arg)) node.set(arg, new Map());\\n            node = node.get(arg);\\n        }\\n        if (!node.has(\"__CACHE__\")) node.set(\"__CACHE__\", fn(...args));\\n        return node.get(\"__CACHE__\");\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    const root = new Map();\\n    return function (...args) {\\n        let node = root;\\n        for (const arg of args) {\\n            if(!node.has(arg)) node.set(arg, new Map());\\n            node = node.get(arg);\\n        }\\n        if (!node.has(\"__CACHE__\")) node.set(\"__CACHE__\", fn(...args));\\n        return node.get(\"__CACHE__\");\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478713,
                "title": "simple-intuitive-solution-explained-in-detail-bests-98-93",
                "content": "# Intuition\\nOnce we are done with the Memoize1 problem or are familiar with the concept present in it(memoization of a function in js),we can fairly understand the difference in this problem that we don\\'t have a fixed type or number of parameters here to pass in the \"fn\" function.\\nThe challenge here is to create a key out of the input parameter sets that are being passed to the \"fn\" function.\\n\\nExample: If we are given input arguments as [10,50,90] then we can cache the function\\'s result to the any key like \"10-50-90\" by stringifying with \"-\" or any identifier between them BUT here in this problem we can have inputs such as [10,[2,3,15],{\"a\":50}] so to create a unique key for such type of inputs we need to create nested maps or Trie like data structure to create our cache.\\n\\n# Approach\\nAs Javascript Map can create a unique key out of any data object,\\nwe will create a nested map to define our cache.\\nExample the previous input\\'s (  [10,[2,3,15],{\"a\":50}]  ) key and output(suppose output for this set of input is 99) will be stored as\\n{10:  {[2,3,15]:  {{\"a\":50}:  {\"result\":  99}}} }\\n\\n\\nNow in each function call of the memoised function we need to check\\nif the same heirarchy of inputs is present inside the cache by traversing it.If its a new input set(not present in the cache) we will iteratively create it in the cache(nested Map).\\n\\nWe will set \"result\"(any identifier) at the end of the traversal of inputs in the cache(nested Map) and initilialize it with the function\\'s value for the current set of inputs.(Finally caching the result). \\n\\nPlease upvote if it helped!!\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache=new Map()\\n    return function(...args) {\\n\\n        //creating / traversing the nested cache(trie like structure)\\n        let root=cache;\\n        for(let i=0;i<args.length;i++){\\n            if(!root.has(args[i])){\\n                root.set(args[i],new Map())\\n            }\\n            root=root.get(args[i])\\n        }\\n\\n        //at this point we are present in the final level of the cache tree created by the inputs\\n        if(root.has(\"result\")){\\n            return root.get(\"result\")\\n        }\\n        \\n        root.set(\"result\",fn(...args))\\n        return root.get(\"result\")\\n        \\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    let cache=new Map()\\n    return function(...args) {\\n\\n        //creating / traversing the nested cache(trie like structure)\\n        let root=cache;\\n        for(let i=0;i<args.length;i++){\\n            if(!root.has(args[i])){\\n                root.set(args[i],new Map())\\n            }\\n            root=root.get(args[i])\\n        }\\n\\n        //at this point we are present in the final level of the cache tree created by the inputs\\n        if(root.has(\"result\")){\\n            return root.get(\"result\")\\n        }\\n        \\n        root.set(\"result\",fn(...args))\\n        return root.get(\"result\")\\n        \\n        \\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478507,
                "title": "f-ck-using-a-trie-no-one-needs-that-bullsh-t-datastructure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\n// Critical testing that got me the solutioN!!!\\nconsole.log(unique_ID({}) === unique_ID({}))\\nconsole.log(unique_ID(Symbol()) === unique_ID(Symbol()))\\nconst a = { name: \"John\", age: 25 };\\nconsole.log(unique_ID(a) === unique_ID(a), a)\\nconsole.log(unique_ID(null) === unique_ID(null))\\nconsole.log(unique_ID(undefined) === unique_ID(undefined))\\nconsole.log(unique_ID(1) === unique_ID(1))\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Memoization technique from @ 2623. Memoize\\n https://leetcode.com/problems/memoize/\\n\\n# Complexity\\n- Time complexity: idk\\n- Space complexity: O(n)\\n![1.png](https://assets.leetcode.com/users/images/8dfaa6c0-45b1-442e-b8f7-f29015b75069_1683046124.507002.png)\\n\\n\\n# Code\\n```\\nconst ID_cache = new Map(); \\nlet currentId = 0;\\nfunction unique_ID(obj) {\\n    if (!ID_cache.has(obj)) ID_cache.set(obj, currentId++);\\n    return ID_cache.get(obj);\\n}\\nfunction memoize(fn) {\\n    let d = {} // F*ck using a Trie. No one needs that bullsh*t datastructure.\\n    return function(...args) {\\n        let key = args.map((arg)=>unique_ID(arg)).join()\\n        if (!(key in d)) d[key] = fn(...args);\\n        return d[key]\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Critical testing that got me the solutioN!!!\\nconsole.log(unique_ID({}) === unique_ID({}))\\nconsole.log(unique_ID(Symbol()) === unique_ID(Symbol()))\\nconst a = { name: \"John\", age: 25 };\\nconsole.log(unique_ID(a) === unique_ID(a), a)\\nconsole.log(unique_ID(null) === unique_ID(null))\\nconsole.log(unique_ID(undefined) === unique_ID(undefined))\\nconsole.log(unique_ID(1) === unique_ID(1))\\n```\n```\\nconst ID_cache = new Map(); \\nlet currentId = 0;\\nfunction unique_ID(obj) {\\n    if (!ID_cache.has(obj)) ID_cache.set(obj, currentId++);\\n    return ID_cache.get(obj);\\n}\\nfunction memoize(fn) {\\n    let d = {} // F*ck using a Trie. No one needs that bullsh*t datastructure.\\n    return function(...args) {\\n        let key = args.map((arg)=>unique_ID(arg)).join()\\n        if (!(key in d)) d[key] = fn(...args);\\n        return d[key]\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476129,
                "title": "easy-javascript-solution-using-map",
                "content": "The memoize function is a higher-order function that takes a function fn as its argument and returns a new function that caches the results of fn for future use. The memoized function keeps track of the arguments that are passed to it, and if the same set of arguments is passed again, the memoized function returns the cached result instead of recomputing it.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe implementation of the memoize function uses a Map object to store the cached results. The Map object is a key-value store that allows efficient lookup of values based on keys. Each key in the map represents one of the arguments passed to the memoized function. If the argument has not been seen before, a new nested Map is created for that argument, which will hold the cached results for that specific argument.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen the memoized function is called with a set of arguments, it first checks if the cached result exists in the nested Map object for those arguments. If the cached result exists, it returns it directly. If not, it calls the original function fn with the arguments and stores the result in the nested Map object for future use.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    var mp= new Map();\\n    return function(...args) {\\n        let saved= mp;\\n        for(var i=0;i<args.length;i++){\\n            if(! saved.has(args[i]))\\n            saved.set(args[i],new Map());\\n            saved= saved.get(args[i]);\\n        }\\n        let key=\"val\";\\n        if(! saved.has(key))\\n        saved.set(key, fn(...args));\\n        return saved.get(key);\\n\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    var mp= new Map();\\n    return function(...args) {\\n        let saved= mp;\\n        for(var i=0;i<args.length;i++){\\n            if(! saved.has(args[i]))\\n            saved.set(args[i],new Map());\\n            saved= saved.get(args[i]);\\n        }\\n        let key=\"val\";\\n        if(! saved.has(key))\\n        saved.set(key, fn(...args));\\n        return saved.get(key);\\n\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3465621,
                "title": "omg-easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nfunction memoize(fn) {\\n    const cache = new Map()\\n    return function(...args) {\\n        let tempCache = cache;\\n        for (const arg of args) {\\n            if (!tempCache.has(arg)) {\\n                tempCache.set(arg, new Map());\\n            }\\n            tempCache = tempCache.get(arg);\\n        }\\n        const cacheKey = JSON.stringify(args);\\n        if(!tempCache.has(cacheKey)){\\n            tempCache.set(cacheKey, fn(...arguments))\\n        }\\n        return tempCache.get(cacheKey)\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction memoize(fn) {\\n    const cache = new Map()\\n    return function(...args) {\\n        let tempCache = cache;\\n        for (const arg of args) {\\n            if (!tempCache.has(arg)) {\\n                tempCache.set(arg, new Map());\\n            }\\n            tempCache = tempCache.get(arg);\\n        }\\n        const cacheKey = JSON.stringify(args);\\n        if(!tempCache.has(cacheKey)){\\n            tempCache.set(cacheKey, fn(...arguments))\\n        }\\n        return tempCache.get(cacheKey)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3463546,
                "title": "symbol-ternary-and-map-builder-solution",
                "content": "# Intuition\\n\\n```\\nconst a = new Map();\\nconst b = a.set(1, 1);\\na === b // true\\n```\\n\\n# Code\\n```\\nconst valueKey = Symbol();\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const _memo = new Map();\\n  return function (...args) {\\n    let memo = _memo;\\n    for (const arg of args) {\\n      memo = memo.has(arg)\\n        ? memo.get(arg)\\n        : memo.set(arg, new Map()).get(arg);\\n    }\\n    return memo.has(valueKey)\\n      ? memo.get(valueKey)\\n      : memo.set(valueKey, fn(...args)).get(valueKey);\\n  };\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst a = new Map();\\nconst b = a.set(1, 1);\\na === b // true\\n```\n```\\nconst valueKey = Symbol();\\n\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const _memo = new Map();\\n  return function (...args) {\\n    let memo = _memo;\\n    for (const arg of args) {\\n      memo = memo.has(arg)\\n        ? memo.get(arg)\\n        : memo.set(arg, new Map()).get(arg);\\n    }\\n    return memo.has(valueKey)\\n      ? memo.get(valueKey)\\n      : memo.set(valueKey, fn(...args)).get(valueKey);\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442263,
                "title": "using-map-beats-87",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe memoization technique is used to optimize the performance of a function by caching its results for the same input arguments. The idea is to avoid recomputing the same result for the same input arguments, which can be time-consuming. The memoization function should be able to store the results of the original function in a cache and return the cached result if the same input arguments are passed again. No need for creating a Trie. Simpler solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used to solve this problem is to create a new function that takes the original function as input and returns a memoized version of the function. The memoized function uses a Map data structure to store the results of the original function for the same input arguments. The Map data structure is used to store the results in a nested structure, where each level of the Map corresponds to one of the input arguments. The final level of the Map stores the result of the original function for the given input arguments.\\n\\nThe memoized function first checks if the result for the given input arguments is already stored in the cache. If the result is already stored, the memoized function returns the cached result. If the result is not stored in the cache, the memoized function calls the original function with the input arguments and stores the result in the cache for future use.\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n-  Time complexity: The time complexity of the memoized function depends on the time complexity of the original function and the number of times the function is called with the same input arguments. If the function is called with the same input arguments multiple times, the memoized function returns the cached result, which reduces the time complexity of the function. Therefore, the time complexity of the memoized function is generally better than the time complexity of the original function.\\n- Space complexity: The space complexity of the memoized function depends on the number of unique input arguments passed to the function. The memoized function stores the results of the original function for each unique set of input arguments in the cache. Therefore, the space complexity of the memoized function is proportional to the number of unique input arguments passed to the function.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const root = new Map();\\n  return function (...args) {\\n    let current = root;\\n    for (let i = 0; i < args.length; i++) {\\n      if (!current.has(args[i])) {\\n        current.set(args[i], new Map());\\n      }\\n      current = current.get(args[i]);\\n    }\\n    if (!current.has(\\'result\\')) {\\n      current.set(\\'result\\', fn(...args));\\n    }\\n    return current.get(\\'result\\');\\n  };\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n  const root = new Map();\\n  return function (...args) {\\n    let current = root;\\n    for (let i = 0; i < args.length; i++) {\\n      if (!current.has(args[i])) {\\n        current.set(args[i], new Map());\\n      }\\n      current = current.get(args[i]);\\n    }\\n    if (!current.has(\\'result\\')) {\\n      current.set(\\'result\\', fn(...args));\\n    }\\n    return current.get(\\'result\\');\\n  };\\n}\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436977,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const root = new Map();\\n    return function(...args) {\\n        let cache = root;\\n        for (const arg of args) {\\n            if(!cache.has(arg)) cache.set(arg, new Map());\\n            cache = cache.get(arg);\\n        }\\n        let key = \\'_cache_\\';\\n        if (!cache.has(key)) cache.set(key, fn(...args));\\n        return cache.get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n */\\nfunction memoize(fn) {\\n    const root = new Map();\\n    return function(...args) {\\n        let cache = root;\\n        for (const arg of args) {\\n            if(!cache.has(arg)) cache.set(arg, new Map());\\n            cache = cache.get(arg);\\n        }\\n        let key = \\'_cache_\\';\\n        if (!cache.has(key)) cache.set(key, fn(...args));\\n        return cache.get(key);\\n    }\\n}\\n\\n\\n/** \\n * let callCount = 0;\\n * const memoizedFn = memoize(function (a, b) {\\n *\\t callCount += 1;\\n *   return a + b;\\n * })\\n * memoizedFn(2, 3) // 5\\n * memoizedFn(2, 3) // 5\\n * console.log(callCount) // 1 \\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1861129,
                "content": [
                    {
                        "username": "Vito_Ruiz",
                        "content": "I don\\'t understand the second test case: the input is the same, yet the call count still increases... Why should that be the behaivour??"
                    },
                    {
                        "username": "tingyunwang120",
                        "content": "[@Finesse](/Finesse) then [2,3] also !== [2,3]"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "[@humflelump](/humflelump) Thank you very much for your answer. You\\'re right. I didn\\'t think about the possibility of passing the argument as a function. Also, well noticed about performance. I will think about it and offer my solution. Have a nice day! :)"
                    },
                    {
                        "username": "humflelump",
                        "content": "[@DimkaLom](/DimkaLom) The short answer is the === definition of equality is the only way to GUARANTEE correctness (the memoized function will behave identically to the original assuming it\\'s pure)\\n\\n// A trivial example of a function that returns different results\\n// even when you pass \"identical\" objects\\nconst OBJ = {};\\nfunction getSomething(o) {\\n  return o === OBJ ? 1 : 2;\\n}\\ngetSomething(OBJ) !== getSomething({});\\n\\n\\nA more practical example would be trying to pass in callback functions. They might be identical except their lexical scopes are different and therefore they behave different even if their string representations are the same.\\n\\n\\nAlso there are performance reasons. What if you pass in a very large nested object. Then you pass in another very large nested object. Converting to a string is a very expensive operation. Just assuming they are different because they !== to each other is much more performant. \\n\\n\\nAnd finally what other definition of sameness would you use if not ===? That\\'s a very complex question without a good answer.\\n\\nP.S. I designed the question.\\n"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "I join the question. I know that in js objects have different references, hence {} !== {}. But what is the logic behind this in the memoization function? After all, we must remember the incoming arguments and the result of the output.\\nI was looking for a real-life example in which you need to look at object / array references, but I did not find it. I consider test case 2 incorrect and this requirement is redundant."
                    },
                    {
                        "username": "Finesse",
                        "content": "That are different objects which look the same. As the task says, the arguments are considered same only if `===` gives `true`. `{} !== {}` in JavaScript."
                    },
                    {
                        "username": "Zsix",
                        "content": "I try to solve this by using empty object as initial map but failed, using Map works, is it the cause of object address by reference?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Is there a way to solve initial values with the reduce function that don\\'t have any parameters passed in besides assume that if there are no args that it must be a reduce function with an initial value passed in?\\n\\nI solved the challenge, but it seems like it\\'s not rational to assume that args.length == 0 must mean it\\'s a reduce function. Seems like that\\'s not robust enough to determine.\\n\\nYou can\\'t really call the fn(...args) to check if it evaluates to a 0 (to assume initial value) because it counts as a function call count.\\n\\nWhat if one of the test cases was this:\\n `() => [[],[1,2],[]`\\n`function (a, b) {return a + b)`\\n\\nIt still outputs my testcase correctly as \\n`[{\"val\":null,\"calls\":1},{\"val\":4,\"calls\":2},{\"val\":null,\"calls\":2}]`\\nbut that just seems not very robust to me."
                    },
                    {
                        "username": "Mray000",
                        "content": "test case 82 is error"
                    },
                    {
                        "username": "Finesse",
                        "content": "Why only JavaScript? Can be a real problem in any language, except Python where tuples can be map keys."
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "I assume it\\'s because the test cases are based on javascript equality weirdness. I can\\'t speak to nuances of other languages, but I imagine the behavior is somewhat different. "
                    },
                    {
                        "username": "den4md",
                        "content": "Why are these 2 calls different?!\\n`() => [ [1], [1, undefined] ]`\\n\\nAs far as I know, if there is a `function foo (a, b) {...}`, then these two calls `foo(1)` and `foo(1, undefined)` both give `a === 1` and `b === undefined`.\\n\\nMaybe there is some sophisticated logic underneath, but anyway it makes sense to memoize only once...."
                    }
                ]
            },
            {
                "id": 1871724,
                "content": [
                    {
                        "username": "Vito_Ruiz",
                        "content": "I don\\'t understand the second test case: the input is the same, yet the call count still increases... Why should that be the behaivour??"
                    },
                    {
                        "username": "tingyunwang120",
                        "content": "[@Finesse](/Finesse) then [2,3] also !== [2,3]"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "[@humflelump](/humflelump) Thank you very much for your answer. You\\'re right. I didn\\'t think about the possibility of passing the argument as a function. Also, well noticed about performance. I will think about it and offer my solution. Have a nice day! :)"
                    },
                    {
                        "username": "humflelump",
                        "content": "[@DimkaLom](/DimkaLom) The short answer is the === definition of equality is the only way to GUARANTEE correctness (the memoized function will behave identically to the original assuming it\\'s pure)\\n\\n// A trivial example of a function that returns different results\\n// even when you pass \"identical\" objects\\nconst OBJ = {};\\nfunction getSomething(o) {\\n  return o === OBJ ? 1 : 2;\\n}\\ngetSomething(OBJ) !== getSomething({});\\n\\n\\nA more practical example would be trying to pass in callback functions. They might be identical except their lexical scopes are different and therefore they behave different even if their string representations are the same.\\n\\n\\nAlso there are performance reasons. What if you pass in a very large nested object. Then you pass in another very large nested object. Converting to a string is a very expensive operation. Just assuming they are different because they !== to each other is much more performant. \\n\\n\\nAnd finally what other definition of sameness would you use if not ===? That\\'s a very complex question without a good answer.\\n\\nP.S. I designed the question.\\n"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "I join the question. I know that in js objects have different references, hence {} !== {}. But what is the logic behind this in the memoization function? After all, we must remember the incoming arguments and the result of the output.\\nI was looking for a real-life example in which you need to look at object / array references, but I did not find it. I consider test case 2 incorrect and this requirement is redundant."
                    },
                    {
                        "username": "Finesse",
                        "content": "That are different objects which look the same. As the task says, the arguments are considered same only if `===` gives `true`. `{} !== {}` in JavaScript."
                    },
                    {
                        "username": "Zsix",
                        "content": "I try to solve this by using empty object as initial map but failed, using Map works, is it the cause of object address by reference?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Is there a way to solve initial values with the reduce function that don\\'t have any parameters passed in besides assume that if there are no args that it must be a reduce function with an initial value passed in?\\n\\nI solved the challenge, but it seems like it\\'s not rational to assume that args.length == 0 must mean it\\'s a reduce function. Seems like that\\'s not robust enough to determine.\\n\\nYou can\\'t really call the fn(...args) to check if it evaluates to a 0 (to assume initial value) because it counts as a function call count.\\n\\nWhat if one of the test cases was this:\\n `() => [[],[1,2],[]`\\n`function (a, b) {return a + b)`\\n\\nIt still outputs my testcase correctly as \\n`[{\"val\":null,\"calls\":1},{\"val\":4,\"calls\":2},{\"val\":null,\"calls\":2}]`\\nbut that just seems not very robust to me."
                    },
                    {
                        "username": "Mray000",
                        "content": "test case 82 is error"
                    },
                    {
                        "username": "Finesse",
                        "content": "Why only JavaScript? Can be a real problem in any language, except Python where tuples can be map keys."
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "I assume it\\'s because the test cases are based on javascript equality weirdness. I can\\'t speak to nuances of other languages, but I imagine the behavior is somewhat different. "
                    },
                    {
                        "username": "den4md",
                        "content": "Why are these 2 calls different?!\\n`() => [ [1], [1, undefined] ]`\\n\\nAs far as I know, if there is a `function foo (a, b) {...}`, then these two calls `foo(1)` and `foo(1, undefined)` both give `a === 1` and `b === undefined`.\\n\\nMaybe there is some sophisticated logic underneath, but anyway it makes sense to memoize only once...."
                    }
                ]
            },
            {
                "id": 1888114,
                "content": [
                    {
                        "username": "Vito_Ruiz",
                        "content": "I don\\'t understand the second test case: the input is the same, yet the call count still increases... Why should that be the behaivour??"
                    },
                    {
                        "username": "tingyunwang120",
                        "content": "[@Finesse](/Finesse) then [2,3] also !== [2,3]"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "[@humflelump](/humflelump) Thank you very much for your answer. You\\'re right. I didn\\'t think about the possibility of passing the argument as a function. Also, well noticed about performance. I will think about it and offer my solution. Have a nice day! :)"
                    },
                    {
                        "username": "humflelump",
                        "content": "[@DimkaLom](/DimkaLom) The short answer is the === definition of equality is the only way to GUARANTEE correctness (the memoized function will behave identically to the original assuming it\\'s pure)\\n\\n// A trivial example of a function that returns different results\\n// even when you pass \"identical\" objects\\nconst OBJ = {};\\nfunction getSomething(o) {\\n  return o === OBJ ? 1 : 2;\\n}\\ngetSomething(OBJ) !== getSomething({});\\n\\n\\nA more practical example would be trying to pass in callback functions. They might be identical except their lexical scopes are different and therefore they behave different even if their string representations are the same.\\n\\n\\nAlso there are performance reasons. What if you pass in a very large nested object. Then you pass in another very large nested object. Converting to a string is a very expensive operation. Just assuming they are different because they !== to each other is much more performant. \\n\\n\\nAnd finally what other definition of sameness would you use if not ===? That\\'s a very complex question without a good answer.\\n\\nP.S. I designed the question.\\n"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "I join the question. I know that in js objects have different references, hence {} !== {}. But what is the logic behind this in the memoization function? After all, we must remember the incoming arguments and the result of the output.\\nI was looking for a real-life example in which you need to look at object / array references, but I did not find it. I consider test case 2 incorrect and this requirement is redundant."
                    },
                    {
                        "username": "Finesse",
                        "content": "That are different objects which look the same. As the task says, the arguments are considered same only if `===` gives `true`. `{} !== {}` in JavaScript."
                    },
                    {
                        "username": "Zsix",
                        "content": "I try to solve this by using empty object as initial map but failed, using Map works, is it the cause of object address by reference?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Is there a way to solve initial values with the reduce function that don\\'t have any parameters passed in besides assume that if there are no args that it must be a reduce function with an initial value passed in?\\n\\nI solved the challenge, but it seems like it\\'s not rational to assume that args.length == 0 must mean it\\'s a reduce function. Seems like that\\'s not robust enough to determine.\\n\\nYou can\\'t really call the fn(...args) to check if it evaluates to a 0 (to assume initial value) because it counts as a function call count.\\n\\nWhat if one of the test cases was this:\\n `() => [[],[1,2],[]`\\n`function (a, b) {return a + b)`\\n\\nIt still outputs my testcase correctly as \\n`[{\"val\":null,\"calls\":1},{\"val\":4,\"calls\":2},{\"val\":null,\"calls\":2}]`\\nbut that just seems not very robust to me."
                    },
                    {
                        "username": "Mray000",
                        "content": "test case 82 is error"
                    },
                    {
                        "username": "Finesse",
                        "content": "Why only JavaScript? Can be a real problem in any language, except Python where tuples can be map keys."
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "I assume it\\'s because the test cases are based on javascript equality weirdness. I can\\'t speak to nuances of other languages, but I imagine the behavior is somewhat different. "
                    },
                    {
                        "username": "den4md",
                        "content": "Why are these 2 calls different?!\\n`() => [ [1], [1, undefined] ]`\\n\\nAs far as I know, if there is a `function foo (a, b) {...}`, then these two calls `foo(1)` and `foo(1, undefined)` both give `a === 1` and `b === undefined`.\\n\\nMaybe there is some sophisticated logic underneath, but anyway it makes sense to memoize only once...."
                    }
                ]
            },
            {
                "id": 1868481,
                "content": [
                    {
                        "username": "Vito_Ruiz",
                        "content": "I don\\'t understand the second test case: the input is the same, yet the call count still increases... Why should that be the behaivour??"
                    },
                    {
                        "username": "tingyunwang120",
                        "content": "[@Finesse](/Finesse) then [2,3] also !== [2,3]"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "[@humflelump](/humflelump) Thank you very much for your answer. You\\'re right. I didn\\'t think about the possibility of passing the argument as a function. Also, well noticed about performance. I will think about it and offer my solution. Have a nice day! :)"
                    },
                    {
                        "username": "humflelump",
                        "content": "[@DimkaLom](/DimkaLom) The short answer is the === definition of equality is the only way to GUARANTEE correctness (the memoized function will behave identically to the original assuming it\\'s pure)\\n\\n// A trivial example of a function that returns different results\\n// even when you pass \"identical\" objects\\nconst OBJ = {};\\nfunction getSomething(o) {\\n  return o === OBJ ? 1 : 2;\\n}\\ngetSomething(OBJ) !== getSomething({});\\n\\n\\nA more practical example would be trying to pass in callback functions. They might be identical except their lexical scopes are different and therefore they behave different even if their string representations are the same.\\n\\n\\nAlso there are performance reasons. What if you pass in a very large nested object. Then you pass in another very large nested object. Converting to a string is a very expensive operation. Just assuming they are different because they !== to each other is much more performant. \\n\\n\\nAnd finally what other definition of sameness would you use if not ===? That\\'s a very complex question without a good answer.\\n\\nP.S. I designed the question.\\n"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "I join the question. I know that in js objects have different references, hence {} !== {}. But what is the logic behind this in the memoization function? After all, we must remember the incoming arguments and the result of the output.\\nI was looking for a real-life example in which you need to look at object / array references, but I did not find it. I consider test case 2 incorrect and this requirement is redundant."
                    },
                    {
                        "username": "Finesse",
                        "content": "That are different objects which look the same. As the task says, the arguments are considered same only if `===` gives `true`. `{} !== {}` in JavaScript."
                    },
                    {
                        "username": "Zsix",
                        "content": "I try to solve this by using empty object as initial map but failed, using Map works, is it the cause of object address by reference?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Is there a way to solve initial values with the reduce function that don\\'t have any parameters passed in besides assume that if there are no args that it must be a reduce function with an initial value passed in?\\n\\nI solved the challenge, but it seems like it\\'s not rational to assume that args.length == 0 must mean it\\'s a reduce function. Seems like that\\'s not robust enough to determine.\\n\\nYou can\\'t really call the fn(...args) to check if it evaluates to a 0 (to assume initial value) because it counts as a function call count.\\n\\nWhat if one of the test cases was this:\\n `() => [[],[1,2],[]`\\n`function (a, b) {return a + b)`\\n\\nIt still outputs my testcase correctly as \\n`[{\"val\":null,\"calls\":1},{\"val\":4,\"calls\":2},{\"val\":null,\"calls\":2}]`\\nbut that just seems not very robust to me."
                    },
                    {
                        "username": "Mray000",
                        "content": "test case 82 is error"
                    },
                    {
                        "username": "Finesse",
                        "content": "Why only JavaScript? Can be a real problem in any language, except Python where tuples can be map keys."
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "I assume it\\'s because the test cases are based on javascript equality weirdness. I can\\'t speak to nuances of other languages, but I imagine the behavior is somewhat different. "
                    },
                    {
                        "username": "den4md",
                        "content": "Why are these 2 calls different?!\\n`() => [ [1], [1, undefined] ]`\\n\\nAs far as I know, if there is a `function foo (a, b) {...}`, then these two calls `foo(1)` and `foo(1, undefined)` both give `a === 1` and `b === undefined`.\\n\\nMaybe there is some sophisticated logic underneath, but anyway it makes sense to memoize only once...."
                    }
                ]
            },
            {
                "id": 1861056,
                "content": [
                    {
                        "username": "Vito_Ruiz",
                        "content": "I don\\'t understand the second test case: the input is the same, yet the call count still increases... Why should that be the behaivour??"
                    },
                    {
                        "username": "tingyunwang120",
                        "content": "[@Finesse](/Finesse) then [2,3] also !== [2,3]"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "[@humflelump](/humflelump) Thank you very much for your answer. You\\'re right. I didn\\'t think about the possibility of passing the argument as a function. Also, well noticed about performance. I will think about it and offer my solution. Have a nice day! :)"
                    },
                    {
                        "username": "humflelump",
                        "content": "[@DimkaLom](/DimkaLom) The short answer is the === definition of equality is the only way to GUARANTEE correctness (the memoized function will behave identically to the original assuming it\\'s pure)\\n\\n// A trivial example of a function that returns different results\\n// even when you pass \"identical\" objects\\nconst OBJ = {};\\nfunction getSomething(o) {\\n  return o === OBJ ? 1 : 2;\\n}\\ngetSomething(OBJ) !== getSomething({});\\n\\n\\nA more practical example would be trying to pass in callback functions. They might be identical except their lexical scopes are different and therefore they behave different even if their string representations are the same.\\n\\n\\nAlso there are performance reasons. What if you pass in a very large nested object. Then you pass in another very large nested object. Converting to a string is a very expensive operation. Just assuming they are different because they !== to each other is much more performant. \\n\\n\\nAnd finally what other definition of sameness would you use if not ===? That\\'s a very complex question without a good answer.\\n\\nP.S. I designed the question.\\n"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "I join the question. I know that in js objects have different references, hence {} !== {}. But what is the logic behind this in the memoization function? After all, we must remember the incoming arguments and the result of the output.\\nI was looking for a real-life example in which you need to look at object / array references, but I did not find it. I consider test case 2 incorrect and this requirement is redundant."
                    },
                    {
                        "username": "Finesse",
                        "content": "That are different objects which look the same. As the task says, the arguments are considered same only if `===` gives `true`. `{} !== {}` in JavaScript."
                    },
                    {
                        "username": "Zsix",
                        "content": "I try to solve this by using empty object as initial map but failed, using Map works, is it the cause of object address by reference?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Is there a way to solve initial values with the reduce function that don\\'t have any parameters passed in besides assume that if there are no args that it must be a reduce function with an initial value passed in?\\n\\nI solved the challenge, but it seems like it\\'s not rational to assume that args.length == 0 must mean it\\'s a reduce function. Seems like that\\'s not robust enough to determine.\\n\\nYou can\\'t really call the fn(...args) to check if it evaluates to a 0 (to assume initial value) because it counts as a function call count.\\n\\nWhat if one of the test cases was this:\\n `() => [[],[1,2],[]`\\n`function (a, b) {return a + b)`\\n\\nIt still outputs my testcase correctly as \\n`[{\"val\":null,\"calls\":1},{\"val\":4,\"calls\":2},{\"val\":null,\"calls\":2}]`\\nbut that just seems not very robust to me."
                    },
                    {
                        "username": "Mray000",
                        "content": "test case 82 is error"
                    },
                    {
                        "username": "Finesse",
                        "content": "Why only JavaScript? Can be a real problem in any language, except Python where tuples can be map keys."
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "I assume it\\'s because the test cases are based on javascript equality weirdness. I can\\'t speak to nuances of other languages, but I imagine the behavior is somewhat different. "
                    },
                    {
                        "username": "den4md",
                        "content": "Why are these 2 calls different?!\\n`() => [ [1], [1, undefined] ]`\\n\\nAs far as I know, if there is a `function foo (a, b) {...}`, then these two calls `foo(1)` and `foo(1, undefined)` both give `a === 1` and `b === undefined`.\\n\\nMaybe there is some sophisticated logic underneath, but anyway it makes sense to memoize only once...."
                    }
                ]
            },
            {
                "id": 1889245,
                "content": [
                    {
                        "username": "Vito_Ruiz",
                        "content": "I don\\'t understand the second test case: the input is the same, yet the call count still increases... Why should that be the behaivour??"
                    },
                    {
                        "username": "tingyunwang120",
                        "content": "[@Finesse](/Finesse) then [2,3] also !== [2,3]"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "[@humflelump](/humflelump) Thank you very much for your answer. You\\'re right. I didn\\'t think about the possibility of passing the argument as a function. Also, well noticed about performance. I will think about it and offer my solution. Have a nice day! :)"
                    },
                    {
                        "username": "humflelump",
                        "content": "[@DimkaLom](/DimkaLom) The short answer is the === definition of equality is the only way to GUARANTEE correctness (the memoized function will behave identically to the original assuming it\\'s pure)\\n\\n// A trivial example of a function that returns different results\\n// even when you pass \"identical\" objects\\nconst OBJ = {};\\nfunction getSomething(o) {\\n  return o === OBJ ? 1 : 2;\\n}\\ngetSomething(OBJ) !== getSomething({});\\n\\n\\nA more practical example would be trying to pass in callback functions. They might be identical except their lexical scopes are different and therefore they behave different even if their string representations are the same.\\n\\n\\nAlso there are performance reasons. What if you pass in a very large nested object. Then you pass in another very large nested object. Converting to a string is a very expensive operation. Just assuming they are different because they !== to each other is much more performant. \\n\\n\\nAnd finally what other definition of sameness would you use if not ===? That\\'s a very complex question without a good answer.\\n\\nP.S. I designed the question.\\n"
                    },
                    {
                        "username": "DimkaLom",
                        "content": "I join the question. I know that in js objects have different references, hence {} !== {}. But what is the logic behind this in the memoization function? After all, we must remember the incoming arguments and the result of the output.\\nI was looking for a real-life example in which you need to look at object / array references, but I did not find it. I consider test case 2 incorrect and this requirement is redundant."
                    },
                    {
                        "username": "Finesse",
                        "content": "That are different objects which look the same. As the task says, the arguments are considered same only if `===` gives `true`. `{} !== {}` in JavaScript."
                    },
                    {
                        "username": "Zsix",
                        "content": "I try to solve this by using empty object as initial map but failed, using Map works, is it the cause of object address by reference?"
                    },
                    {
                        "username": "powerup7",
                        "content": "Is there a way to solve initial values with the reduce function that don\\'t have any parameters passed in besides assume that if there are no args that it must be a reduce function with an initial value passed in?\\n\\nI solved the challenge, but it seems like it\\'s not rational to assume that args.length == 0 must mean it\\'s a reduce function. Seems like that\\'s not robust enough to determine.\\n\\nYou can\\'t really call the fn(...args) to check if it evaluates to a 0 (to assume initial value) because it counts as a function call count.\\n\\nWhat if one of the test cases was this:\\n `() => [[],[1,2],[]`\\n`function (a, b) {return a + b)`\\n\\nIt still outputs my testcase correctly as \\n`[{\"val\":null,\"calls\":1},{\"val\":4,\"calls\":2},{\"val\":null,\"calls\":2}]`\\nbut that just seems not very robust to me."
                    },
                    {
                        "username": "Mray000",
                        "content": "test case 82 is error"
                    },
                    {
                        "username": "Finesse",
                        "content": "Why only JavaScript? Can be a real problem in any language, except Python where tuples can be map keys."
                    },
                    {
                        "username": "michaelwhittemore",
                        "content": "I assume it\\'s because the test cases are based on javascript equality weirdness. I can\\'t speak to nuances of other languages, but I imagine the behavior is somewhat different. "
                    },
                    {
                        "username": "den4md",
                        "content": "Why are these 2 calls different?!\\n`() => [ [1], [1, undefined] ]`\\n\\nAs far as I know, if there is a `function foo (a, b) {...}`, then these two calls `foo(1)` and `foo(1, undefined)` both give `a === 1` and `b === undefined`.\\n\\nMaybe there is some sophisticated logic underneath, but anyway it makes sense to memoize only once...."
                    }
                ]
            }
        ]
    }
]