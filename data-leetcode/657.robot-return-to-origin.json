[
    {
        "title": "Merge Intervals",
        "question_content": "Given an array&nbsp;of intervals&nbsp;where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\n&nbsp;\nConstraints:\n\n\t1 <= intervals.length <= 104\n\tintervals[i].length == 2\n\t0 <= starti <= endi <= 104",
        "solutions": [
            {
                "id": 21222,
                "title": "a-simple-java-solution",
                "content": "The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous \"extended\" interval and start over.\\n\\nSorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)).\\n\\nI used a lambda comparator (Java 8) and a for-each loop to try to keep the code clean and simple.\\n\\nEDIT: The function signature changed in april 2019.\\nHere is a new version of the algorithm with arrays. To make more memory efficient, I reused the initial array (sort of \"in-place\") but it would be easy to create new subarrays if you wanted to keep the initial data.\\nIt takes less memory than 99% of the other solutions (sometimes 90% depending on the run) and is more than 10 times faster than the previous version with lists.\\n\\n\\tclass Solution {\\n\\t\\tpublic int[][] merge(int[][] intervals) {\\n\\t\\t\\tif (intervals.length <= 1)\\n\\t\\t\\t\\treturn intervals;\\n\\n\\t\\t\\t// Sort by ascending starting point\\n\\t\\t\\tArrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tint[] newInterval = intervals[0];\\n\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif (interval[0] <= newInterval[1]) // Overlapping intervals, move the end if needed\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\telse {                             // Disjoint intervals, add the new interval to the list\\n\\t\\t\\t\\t\\tnewInterval = interval;\\n\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t\\t}\\n\\t}\\n\\nPrevious version with lists.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n        if (intervals.size() <= 1)\\n            return intervals;\\n        \\n        // Sort by ascending starting point using an anonymous Comparator\\n        intervals.sort((i1, i2) -> Integer.compare(i1.start, i2.start));\\n        \\n        List<Interval> result = new LinkedList<Interval>();\\n        int start = intervals.get(0).start;\\n        int end = intervals.get(0).end;\\n        \\n        for (Interval interval : intervals) {\\n            if (interval.start <= end) // Overlapping intervals, move the end if needed\\n                end = Math.max(end, interval.end);\\n            else {                     // Disjoint intervals, add the previous one and reset bounds\\n                result.add(new Interval(start, end));\\n                start = interval.start;\\n                end = interval.end;\\n            }\\n        }\\n        \\n        // Add the last interval\\n        result.add(new Interval(start, end));\\n        return result;\\n    }\\n\\nEDIT: Updated with Java 8 lambda comparator.\\nEDIT 25/05/2019: Updated for new method signature.",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] merge(int[][] intervals) {\\n\\t\\t\\tif (intervals.length <= 1)\\n\\t\\t\\t\\treturn intervals;\\n\\n\\t\\t\\t// Sort by ascending starting point\\n\\t\\t\\tArrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n\\n\\t\\t\\tList<int[]> result = new ArrayList<>();\\n\\t\\t\\tint[] newInterval = intervals[0];\\n\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\tfor (int[] interval : intervals) {\\n\\t\\t\\t\\tif (interval[0] <= newInterval[1]) // Overlapping intervals, move the end if needed\\n\\t\\t\\t\\t\\tnewInterval[1] = Math.max(newInterval[1], interval[1]);\\n\\t\\t\\t\\telse {                             // Disjoint intervals, add the new interval to the list\\n\\t\\t\\t\\t\\tnewInterval = interval;\\n\\t\\t\\t\\t\\tresult.add(newInterval);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 21227,
                "title": "7-lines-easy-python",
                "content": "Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don't.\\n\\n    def merge(self, intervals):\\n        out = []\\n        for i in sorted(intervals, key=lambda i: i.start):\\n            if out and i.start <= out[-1].end:\\n                out[-1].end = max(out[-1].end, i.end)\\n            else:\\n                out += i,\\n        return out",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just go through the intervals sorted by start coordinate and either combine the current interval with the previous one if they overlap, or add it to the output by itself if they don't.\\n\\n    def merge(self, intervals):\\n        out = []\\n        for i in sorted(intervals, key=lambda i: i.start):\\n            if out and i.start <= out[-1].end:\\n                out[-1].end = max(out[-1].end, i.end)\\n            else:\\n                out += i,\\n        return out",
                "codeTag": "Python3"
            },
            {
                "id": 3161191,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n      if(intervals.size()==1)\\n         return intervals;\\n      vector<pair<int,int>> p;\\n      for(int i=0;i<intervals.size();i++)\\n      {\\n          p.push_back({intervals[i][0],intervals[i][1]});\\n      } \\n      sort(p.begin(),p.end());\\n\\n      vector<vector<int>> ans;\\n      int f=p[0].first,s=p[0].second;\\n      for(int i=0;i<p.size()-1;i++)\\n      {\\n          vector<int> a(2);\\n          if(s>=p[i+1].first)\\n          {\\n              s=max(s,p[i+1].second);\\n          }\\n          else\\n          {\\n              a[0]=f;\\n              a[1]=s;\\n              f=p[i+1].first;\\n              s=p[i+1].second;\\n              ans.push_back(a);\\n          }\\n      } \\n      int n=intervals.size();\\n      ans.push_back({f,s});\\n      return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x: x [0])\\n\\n        ans = []\\n\\n        for interval in intervals:\\n            if not ans or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        \\n        return ans\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tmin = Math.min(min, intervals[i][0]);\\n\\t\\t\\tmax = Math.max(max, intervals[i][0]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] range = new int[max - min + 1];\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\trange[intervals[i][0] - min] = Math.max(intervals[i][1] - min, range[intervals[i][0] - min]); \\n\\t\\t}\\n\\t\\t\\n\\t\\tint start = 0, end = 0;\\n\\t\\tLinkedList<int[]> result = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < range.length; i++) {\\n\\t\\t\\tif (range[i] == 0) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (i <= end) {\\n\\t\\t\\t\\tend = Math.max(range[i], end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = range[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n      if(intervals.size()==1)\\n         return intervals;\\n      vector<pair<int,int>> p;\\n      for(int i=0;i<intervals.size();i++)\\n      {\\n          p.push_back({intervals[i][0],intervals[i][1]});\\n      } \\n      sort(p.begin(),p.end());\\n\\n      vector<vector<int>> ans;\\n      int f=p[0].first,s=p[0].second;\\n      for(int i=0;i<p.size()-1;i++)\\n      {\\n          vector<int> a(2);\\n          if(s>=p[i+1].first)\\n          {\\n              s=max(s,p[i+1].second);\\n          }\\n          else\\n          {\\n              a[0]=f;\\n              a[1]=s;\\n              f=p[i+1].first;\\n              s=p[i+1].second;\\n              ans.push_back(a);\\n          }\\n      } \\n      int n=intervals.size();\\n      ans.push_back({f,s});\\n      return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals, key=lambda x: x [0])\\n\\n        ans = []\\n\\n        for interval in intervals:\\n            if not ans or ans[-1][1] < interval[0]:\\n                ans.append(interval)\\n            else:\\n                ans[-1][1] = max(ans[-1][1], interval[1])\\n        \\n        return ans\\n```\n```Java []\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tmin = Math.min(min, intervals[i][0]);\\n\\t\\t\\tmax = Math.max(max, intervals[i][0]);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] range = new int[max - min + 1];\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\trange[intervals[i][0] - min] = Math.max(intervals[i][1] - min, range[intervals[i][0] - min]); \\n\\t\\t}\\n\\t\\t\\n\\t\\tint start = 0, end = 0;\\n\\t\\tLinkedList<int[]> result = new LinkedList<>();\\n\\t\\tfor (int i = 0; i < range.length; i++) {\\n\\t\\t\\tif (range[i] == 0) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tif (i <= end) {\\n\\t\\t\\t\\tend = Math.max(range[i], end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = range[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.add(new int[] {start + min, end + min});\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21242,
                "title": "c-10-line-solution-easing-understanding",
                "content": "    vector<Interval> merge(vector<Interval>& ins) {\\n        if (ins.empty()) return vector<Interval>{};\\n        vector<Interval> res;\\n        sort(ins.begin(), ins.end(), [](Interval a, Interval b){return a.start < b.start;});\\n        res.push_back(ins[0]);\\n        for (int i = 1; i < ins.size(); i++) {\\n            if (res.back().end < ins[i].start) res.push_back(ins[i]);\\n            else\\n                res.back().end = max(res.back().end, ins[i].end);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<Interval> merge(vector<Interval>& ins) {\\n        if (ins.empty()) return vector<Interval>{};\\n        vector<Interval> res;\\n        sort(ins.begin(), ins.end(), [](Interval a, Interval b){return a.start < b.start;});\\n        res.push_back(ins[0]);\\n        for (int i = 1; i < ins.size(); i++) {\\n            if (res.back().end < ins[i].start) res.push_back(ins[i]);\\n            else\\n                res.back().end = max(res.back().end, ins[i].end);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 482195,
                "title": "c-9-lines-99-run-time-easy-to-understand-solution",
                "content": "```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]) output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            else output.push_back(intervals[i]); \\n        }\\n        return output;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]) output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            else output.push_back(intervals[i]); \\n        }\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21223,
                "title": "beat-98-java-sort-start-end-respectively",
                "content": "  The idea is that for the result distinct Interval, the latter one's start must > previous one's end.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\t// sort start&end\\n\\t\\tint n = intervals.size();\\n\\t\\tint[] starts = new int[n];\\n\\t\\tint[] ends = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tstarts[i] = intervals.get(i).start;\\n\\t\\t\\tends[i] = intervals.get(i).end;\\n\\t\\t}\\n\\t\\tArrays.sort(starts);\\n\\t\\tArrays.sort(ends);\\n\\t\\t// loop through\\n\\t\\tList<Interval> res = new ArrayList<Interval>();\\n\\t\\tfor (int i = 0, j = 0; i < n; i++) { // j is start of interval.\\n\\t\\t\\tif (i == n - 1 || starts[i + 1] > ends[i]) {\\n\\t\\t\\t\\tres.add(new Interval(starts[j], ends[i]));\\n\\t\\t\\t\\tj = i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "  The idea is that for the result distinct Interval, the latter one's start must > previous one's end.\\n\\n    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\t// sort start&end\\n\\t\\tint n = intervals.size();\\n\\t\\tint[] starts = new int[n];\\n\\t\\tint[] ends = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tstarts[i] = intervals.get(i).start;\\n\\t\\t\\tends[i] = intervals.get(i).end;\\n\\t\\t}\\n\\t\\tArrays.sort(starts);\\n\\t\\tArrays.sort(ends);\\n\\t\\t// loop through\\n\\t\\tList<Interval> res = new ArrayList<Interval>();\\n\\t\\tfor (int i = 0, j = 0; i < n; i++) { // j is start of interval.\\n\\t\\t\\tif (i == n - 1 || starts[i + 1] > ends[i]) {\\n\\t\\t\\t\\tres.add(new Interval(starts[j], ends[i]));\\n\\t\\t\\t\\tj = i + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1644017,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations",
                "content": "# **Two Types of Code || Normal & Solely relying on built in methods of STL library**\\n\\n**Intuition:-**\\nAfter reading the question we get that we need to merge the over lapping intervals and return the result by keeping the rest of the elements as it is.\\nTo find the overlapping intervals the intervals should be atleast sorted think about this .\\nThus for solving we need to sort and then check the consecutive intervals.  Once we find the overlapping interval. we will take the max element from it.\\n\\n**Algorithm:-**\\n1. Firstly, the base case : if there are no intervals return [] .\\n2. Sort the intervals .\\n3. While traversing the intervals vector we will come accross two coditions\\n* First condition : if there is a overlapping between the intervals then just take out the max element from the ending point and thus we merged them \\neg:- [1,4],[2,8]  =Mergerd intervals will be> [1,8]\\n* second condition : if there is no overlapping then simply push those interval to our resultant vector .\\n4. Now let\\'s move our finger\\'s to coding :)\\n \\n**Code type 1:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> result;\\n        //base case when threr are no intervals\\n        if(interval.size()==0)return result;\\n        //sort takes O(nlogn) time\\n        sort(interval.begin(),interval.end());\\n        //insert the the the first interval in the result\\n        result.push_back(interval[0]);\\n        int j=0;\\n        //Traverse the whole vector .Takes O(n) time\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            //if intevals are overlapping\\n            if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Code type 2:-**\\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //base case\\n        if(intervals.size()<=1) return intervals;\\n        //resultan vector\\n        vector<vector<int>> result;\\n        //sort takes O(nlogn) time\\n        sort(intervals.begin(), intervals.end()); \\n        //insert the the the first interval in the result\\n        result.push_back(intervals[0]);\\n         //Traverse the whole vector .Takes O(n) time\\n        for(int i=1; i<intervals.size(); i++) {\\n             //if intevals are overlapping\\n            if(result.back()[1] >= intervals[i][0]) result.back()[1] = max(result.back()[1] , intervals[i][1]);\\n            //else they are not overlapping\\n            else result.push_back(intervals[i]); \\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n**Time complexity :** *`O(nlogn) [for using the sort function] + O(n) [for traversing the interval] = O(nlogn)`*\\n**Space Complexity :** *`O(n) [For our resultant vector]`*\\n***\\n**Feel free to comment if you have some suggestions or upvote if you liked it.**\\n***\\nHere\\'s my [github link](https://github.com/Jatin-Shihora) where I keep my solutions.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> result;\\n        //base case when threr are no intervals\\n        if(interval.size()==0)return result;\\n        //sort takes O(nlogn) time\\n        sort(interval.begin(),interval.end());\\n        //insert the the the first interval in the result\\n        result.push_back(interval[0]);\\n        int j=0;\\n        //Traverse the whole vector .Takes O(n) time\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            //if intevals are overlapping\\n            if(result[j][1]>=interval[i][0]) result[j][1]=max(result[j][1],interval[i][1]);\\n            //else they are not overlapping\\n            else\\n            {\\n                j++;\\n                result.push_back(interval[i]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n//Comment and Upvote\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //base case\\n        if(intervals.size()<=1) return intervals;\\n        //resultan vector\\n        vector<vector<int>> result;\\n        //sort takes O(nlogn) time\\n        sort(intervals.begin(), intervals.end()); \\n        //insert the the the first interval in the result\\n        result.push_back(intervals[0]);\\n         //Traverse the whole vector .Takes O(n) time\\n        for(int i=1; i<intervals.size(); i++) {\\n             //if intevals are overlapping\\n            if(result.back()[1] >= intervals[i][0]) result.back()[1] = max(result.back()[1] , intervals[i][1]);\\n            //else they are not overlapping\\n            else result.push_back(intervals[i]); \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350272,
                "title": "python3-sort-o-nlog-n",
                "content": "```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key =lambda x: x[0])\\n        merged =[]\\n        for i in intervals:\\n\\t\\t\\t# if the list of merged intervals is empty \\n\\t\\t\\t# or if the current interval does not overlap with the previous,\\n\\t\\t\\t# simply append it.\\n            if not merged or merged[-1][-1] < i[0]:\\n                merged.append(i)\\n\\t\\t\\t# otherwise, there is overlap,\\n\\t\\t\\t#so we merge the current and previous intervals.\\n            else:\\n                merged[-1][-1] = max(merged[-1][-1], i[-1])\\n        return merged\\n```\\n\\n* Time complexity:\\n\\tIn python, use sort method to a list costs [O(nlogn)](https://wiki.python.org/moin/TimeComplexity), where n is the length of the list.\\n\\tThe for-loop used to merge intervals, costs O(n).\\n\\tO(nlogn)+O(n) = O(nlogn)\\n\\tSo the total time complexity is O(nlogn).\\n* Space complexity\\n\\tThe algorithm used a merged list and a variable i.\\n\\tIn the worst case, the merged list is equal to the length of the input intervals list. So the space complexity is O(n), where n is the length of the input list.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()\\n        merged = []\\n        for i in range(len(intervals)):\\n            if merged == []:\\n                merged.append(intervals[i])\\n            else:\\n                previous_end = merged[-1][1]\\n                current_start = intervals[i][0]\\n                current_end = intervals[i][1]\\n                if previous_end >= current_start: # overlap\\n                    merged[-1][1] = max(previous_end,current_end)\\n                else:\\n                    merged.append(intervals[i])\\n        return merged\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key =lambda x: x[0])\\n        merged =[]\\n        for i in intervals:\\n\\t\\t\\t# if the list of merged intervals is empty \\n\\t\\t\\t# or if the current interval does not overlap with the previous,\\n\\t\\t\\t# simply append it.\\n            if not merged or merged[-1][-1] < i[0]:\\n                merged.append(i)\\n\\t\\t\\t# otherwise, there is overlap,\\n\\t\\t\\t#so we merge the current and previous intervals.\\n            else:\\n                merged[-1][-1] = max(merged[-1][-1], i[-1])\\n        return merged\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()\\n        merged = []\\n        for i in range(len(intervals)):\\n            if merged == []:\\n                merged.append(intervals[i])\\n            else:\\n                previous_end = merged[-1][1]\\n                current_start = intervals[i][0]\\n                current_end = intervals[i][1]\\n                if previous_end >= current_start: # overlap\\n                    merged[-1][1] = max(previous_end,current_end)\\n                else:\\n                    merged.append(intervals[i])\\n        return merged\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186112,
                "title": "best-c-solution-ever-sorting-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Array + Sorting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of the Vector(intervals).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output) which can go upto size N , however the output does not count towards the space complexity.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of\\n    the Vector(intervals).\\n\\n    Space Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output)\\n    which can go upto size N , however the output does not count towards the space complexity.\\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        for(auto interval : intervals){\\n            if(output.empty() || output.back()[1] < interval[0]){\\n                output.push_back(interval);\\n            }\\n            else{\\n                output.back()[1] = max(output.back()[1], interval[1]);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN), Sorting the array(intervals) costs O(NlogN). Where N is the size of\\n    the Vector(intervals).\\n\\n    Space Complexity : O(1), Constant Space. Extra space is only allocated for the Vector(output)\\n    which can go upto size N , however the output does not count towards the space complexity.\\n\\n    Solved using Array + Sorting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        for(auto interval : intervals){\\n            if(output.empty() || output.back()[1] < interval[0]){\\n                output.push_back(interval);\\n            }\\n            else{\\n                output.back()[1] = max(output.back()[1], interval[1]);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600013,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nInitially sort the array and then push the first element into the answer for speculation.\\nWe have two condition if the first elements second part of ans array is greater than or equal to the second element first part of the \\ninterval array.\\nThe other condition we have to tackle is what if its not? then we push the particular element into the ans array which will be then be under speculation.\\ninterval: [[1,3],[2,6],[8,10],[15,18]]\\n             i\\nWe initally push the 1st element into the ans array:\\nans=[[1,3]]\\n      j        j points to the latest pushed element\\nThen we i is incremented.\\n[[1,3],[2,6],[8,10],[15,18]]\\n         i\\nNow the ans[j][1]>interval[i][0] this means there is a possiblity of merging so we merger them\\nRemember the way we merge is to take the second element as max(ans[j][1],interval[i][1])\\ncuz imagine we have this\\n[1,7][2,4] --->merge should be ---->[1,7]\\n\\nans=[[1,6]]\\n\\nthen we move i forward\\n\\n[[1,3],[2,6],[8,10],[15,18]]\\n               i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nThus we will push this into the ans array and speculate.\\n\\nans=[[1,6][8,10]]\\n            j   <----j is moved forward\\ni is moved forward \\n[[1,3],[2,6],[8,10],[15,18]]\\n                       i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nans=[[1,6][8,10][15,18]]\\n                  j\\n\\nThus yielding our final answer.\\n\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> ans;\\n        if(interval.size()==0)return ans;\\n        sort(interval.begin(),interval.end());\\n        ans.push_back(interval[0]);\\n        int j=0;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            if(ans[j][1]>=interval[i][0])\\n                ans[j][1]=max(ans[j][1],interval[i][1]);\\n            else\\n            {\\n                j++;\\n                ans.push_back(interval[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nInitially sort the array and then push the first element into the answer for speculation.\\nWe have two condition if the first elements second part of ans array is greater than or equal to the second element first part of the \\ninterval array.\\nThe other condition we have to tackle is what if its not? then we push the particular element into the ans array which will be then be under speculation.\\ninterval: [[1,3],[2,6],[8,10],[15,18]]\\n             i\\nWe initally push the 1st element into the ans array:\\nans=[[1,3]]\\n      j        j points to the latest pushed element\\nThen we i is incremented.\\n[[1,3],[2,6],[8,10],[15,18]]\\n         i\\nNow the ans[j][1]>interval[i][0] this means there is a possiblity of merging so we merger them\\nRemember the way we merge is to take the second element as max(ans[j][1],interval[i][1])\\ncuz imagine we have this\\n[1,7][2,4] --->merge should be ---->[1,7]\\n\\nans=[[1,6]]\\n\\nthen we move i forward\\n\\n[[1,3],[2,6],[8,10],[15,18]]\\n               i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nThus we will push this into the ans array and speculate.\\n\\nans=[[1,6][8,10]]\\n            j   <----j is moved forward\\ni is moved forward \\n[[1,3],[2,6],[8,10],[15,18]]\\n                       i\\nSince ans[j][1]<interval[i][0] thus not contributing to the merge.\\nans=[[1,6][8,10][15,18]]\\n                  j\\n\\nThus yielding our final answer.\\n\\n    vector<vector<int>> merge(vector<vector<int>>& interval) {\\n        vector<vector<int>> ans;\\n        if(interval.size()==0)return ans;\\n        sort(interval.begin(),interval.end());\\n        ans.push_back(interval[0]);\\n        int j=0;\\n        for(int i=1;i<interval.size();i++)\\n        {\\n            if(ans[j][1]>=interval[i][0])\\n                ans[j][1]=max(ans[j][1],interval[i][1]);\\n            else\\n            {\\n                j++;\\n                ans.push_back(interval[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355318,
                "title": "fully-explained-and-clean-interval-tree-for-facebook-follow-up-no-sorting",
                "content": "Inspired by https://leetcode.com/problems/merge-intervals/discuss/21452/Share-my-interval-tree-solution-no-sorting\\n\\n**Question**: How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\\n\\nWe need to have two functions for the tree (`add` interval and `query` tree). \\n\\n##### Implementation Details\\n`TreeNode` - On top of the left child, right child, start boundary, and end boundary, we have a **`middle` field** that determines whether a new interval goes to the left child, right right or merged with the current node.\\n\\n`add` - If the new interval touches or crosses the `middle` of the current node, we update the current node. Otherwise, we put the new interval into the left subtree or right subtree. \\n- Why do we use `middle` for comparison and not `start` or `end` boundaries? \\nThe reason is that we can use merge-sort technique to `query` the merged intervals result when the left subtree does not overlap with the right subtree. \\n\\n`query` - Use merge-sort technique by retrieving the merged intervals of the left subtree (i.e. `left_intervals`) and those of the right subtree (i.e. `right_intervals`). Because of the implementation of `add`, we can guarantee that\\n- if there\\'s an interval in the `left_intervals` that overlaps with the current node, then we know that all the intervals after that interval overlaps with the current node.\\n- The first few intervals or zero intervals in the `right_intervals` overlap with the current node.  \\n\\nHere\\'s the visualization:\\n```\\nleft_res = [ (intervals that do not overlap), (intervals that overlap with current node) ]\\nright_res = [ (intervals that overlap with current node), (intervals that do not overlap) ]\\n```\\n\\n##### Code\\n\\n```python\\nclass TreeNode:\\n    def __init__(self, start, end, middle):\\n        self.start = start\\n        self.end = end\\n        self.middle = middle\\n        self.left = self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = None\\n    \\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        for start, end in intervals:\\n            if not self.root:\\n                self.root = TreeNode(start, end, (start + end) // 2)\\n            else:\\n                self.add(self.root, start, end)\\n        \\n        return self.query(self.root)\\n    \\n    \\n    def add(self, node, start, end):     \\n        if end < node.middle:\\n            if node.left:\\n                self.add(node.left, start, end)\\n            else:\\n                node.left = TreeNode(start, end, (start + end) // 2)\\n        \\n        elif start > node.middle:\\n            if node.right:\\n                self.add(node.right, start, end)\\n            else:\\n                node.right = TreeNode(start, end, (start + end) // 2)\\n        \\n        else:\\n            node.start = min(node.start, start)\\n            node.end = max(node.end, end)\\n    \\n    def query(self, node):\\n        if not node:\\n            return []\\n        \\n        # merge-sort divide and conquer\\n        left_intervals = self.query(node.left)\\n        right_intervals = self.query(node.right)\\n        res = []\\n        \\n        inserted = False\\n        \\n        for lres in left_intervals:\\n            if lres[1] < node.start:\\n                res.append(lres)\\n            else:\\n                res.append([min(lres[0], node.start), node.end])\\n                inserted = True\\n                break\\n        \\n        if not inserted:\\n            res.append([node.start, node.end])\\n        \\n        for rres in right_intervals:\\n            if rres[0] <= node.end:\\n                res[-1][1] = max(node.end, rres[1])\\n            else:\\n                res.append(rres)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nleft_res = [ (intervals that do not overlap), (intervals that overlap with current node) ]\\nright_res = [ (intervals that overlap with current node), (intervals that do not overlap) ]\\n```\n```python\\nclass TreeNode:\\n    def __init__(self, start, end, middle):\\n        self.start = start\\n        self.end = end\\n        self.middle = middle\\n        self.left = self.right = None\\n\\nclass Solution:\\n    def __init__(self):\\n        self.root = None\\n    \\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        for start, end in intervals:\\n            if not self.root:\\n                self.root = TreeNode(start, end, (start + end) // 2)\\n            else:\\n                self.add(self.root, start, end)\\n        \\n        return self.query(self.root)\\n    \\n    \\n    def add(self, node, start, end):     \\n        if end < node.middle:\\n            if node.left:\\n                self.add(node.left, start, end)\\n            else:\\n                node.left = TreeNode(start, end, (start + end) // 2)\\n        \\n        elif start > node.middle:\\n            if node.right:\\n                self.add(node.right, start, end)\\n            else:\\n                node.right = TreeNode(start, end, (start + end) // 2)\\n        \\n        else:\\n            node.start = min(node.start, start)\\n            node.end = max(node.end, end)\\n    \\n    def query(self, node):\\n        if not node:\\n            return []\\n        \\n        # merge-sort divide and conquer\\n        left_intervals = self.query(node.left)\\n        right_intervals = self.query(node.right)\\n        res = []\\n        \\n        inserted = False\\n        \\n        for lres in left_intervals:\\n            if lres[1] < node.start:\\n                res.append(lres)\\n            else:\\n                res.append([min(lres[0], node.start), node.end])\\n                inserted = True\\n                break\\n        \\n        if not inserted:\\n            res.append([node.start, node.end])\\n        \\n        for rres in right_intervals:\\n            if rres[0] <= node.end:\\n                res[-1][1] = max(node.end, rres[1])\\n            else:\\n                res.append(rres)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644409,
                "title": "c-python-simple-solutions-w-explanation-sort-merge-o-nlogn-count-sort-o-n-r",
                "content": "We are given array of intervals and we need to merge all the overlapping intervals\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Sort & Merge)***\\n\\nTwo intervals `i1` and `i2` overlap only if `i1[1] >= i2[0]` and `i2[1] >= i1[0]` or vice-versa. So, whenever we find two such intervals, we need to merge them as `[min(i1[0], i2[0]), max(i1[1], i2[1])]`. However, directly using this approach would require us compare each pair of intervals, merge them if they overlap and restart the same process & continue the same till we dont find any overlapping between any pairs. This would lead to more than `O(N^2)` time complexity.\\n\\nA better approach would be to sort the given intervals first. This would allow us to iterate one by one and only compare between adjacent pair of intervals instead of every pair. We can maintain a sorted list and merge/insert new intervals one by one. Since, we have sorted the intervals, one of the condition of overlap is already satisfied - `i2[1] >= i1[0]` (since `i2[0] >= i1[0]` after sort & `i2[1] >= i2[0]`). \\n\\nThus, we only need to check if the new interval\\'s start (`i[0]` in below code) is <= last interval of sorted list (`ans.back()[1]`) formed till now. If it is overlapping, then we merge the two intervals by updating the last interval of the sorted list. If the intervals dont overlap, we can just add the new interval to the end of sorted list.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        vector<vector<int>> ans {I[0]};                        // adding 1st interval to avoid checking ans.empty() each time in loop\\n        for(auto i : I)\\n            if(i[0] <= ans.back()[1])                          // merge intervals if they overlap\\n                ans.back()[1] = max(ans.back()[1], i[1]);\\n            else                                               // else insert new interval\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        ans = [I[0]]\\n        for i in I:\\n            if i[0] <= ans[-1][1]:\\n                ans[-1][1] = max(ans[-1][1], i[1])\\n            else:\\n                ans.append(i)\\n        return ans\\n```\\n\\n***Time Complexity :*** <code>O(NlogN)</code>\\n***Space Complexity :*** `O(sort)`, required for in-built sort algortihm. The extra space used for output is generally not included in space complexity.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Inplace Merge)***\\n\\nYou could further optimize on space if you are allowed to modify the input itself in which case you can directly merge in-place. We could keep track of length of sorted sub-list in `I` in an variable `R` (denoting right end of sorted list formed till now). The rest of logic would be same as above. We would just replace last interval of sorted list denoted by `ans.back()` in previous approach with `I[R]` since we are merge inplace.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])                          \\n                I[R][1] = max(I[R][1], i[1]);\\n            else                                              \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\\n\\n***Time Complexity :*** <code>O(NlogN)</code>\\n***Space Complexity :*** `O(sort)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Counting Sort & Merge)***\\n\\nWe can sort the intervals using counting sort as well. This approach would be more efficient if the number of intervals are greater but the range is small. \\n\\nWe declare an array `ends` of length equal to greatest start of an interval. `ends[i]` will store the array of ends of interval starting at `i`. Once we fill `ends` using intervals from `I`, we can update intervals back into `I` in a sorted order. The rest of the code remains the same\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    void countingSort(vector<vector<int>>& I) {\\n        int range = 1 + (*max_element(begin(I), end(I), [](auto& i1, auto& i2){return i1[0] < i2[0];}))[0];\\n        vector<vector<int>> ends(range);          // ends[i] stores array of ends of interval starting at i\\n        for(auto& i : I) \\n            ends[i[0]].push_back(i[1]);\\n        for(int i = 0, j = 0; i < range; i++)     // insert intervals back into I in sorted order\\n            for(auto end : ends[i])\\n                I[j++] = {i, end};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        countingSort(I);\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])\\n                I[R][1] = max(I[R][1], i[1]);\\n            else               \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def merge(self, I):\\n        def countingSort():\\n            ends, j = defaultdict(list), 0\\n            for i in I:\\n                ends[i[0]].append(i[1])\\n            for i in range(1 + max(I, key = lambda i : i[0])[0]):\\n                for end in ends[i]:\\n                    I[j] = [i, end]\\n                    j += 1\\n                    \\n        countingSort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\\n\\n***Time Complexity :*** <code>O(N + R)</code>, where `R` is the range of intervals determined by largest start value of an interval\\n***Space Complexity :*** `O(R)`, required for storing `ends`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        vector<vector<int>> ans {I[0]};                        // adding 1st interval to avoid checking ans.empty() each time in loop\\n        for(auto i : I)\\n            if(i[0] <= ans.back()[1])                          // merge intervals if they overlap\\n                ans.back()[1] = max(ans.back()[1], i[1]);\\n            else                                               // else insert new interval\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        ans = [I[0]]\\n        for i in I:\\n            if i[0] <= ans[-1][1]:\\n                ans[-1][1] = max(ans[-1][1], i[1])\\n            else:\\n                ans.append(i)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        sort(begin(I), end(I));\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])                          \\n                I[R][1] = max(I[R][1], i[1]);\\n            else                                              \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        I.sort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void countingSort(vector<vector<int>>& I) {\\n        int range = 1 + (*max_element(begin(I), end(I), [](auto& i1, auto& i2){return i1[0] < i2[0];}))[0];\\n        vector<vector<int>> ends(range);          // ends[i] stores array of ends of interval starting at i\\n        for(auto& i : I) \\n            ends[i[0]].push_back(i[1]);\\n        for(int i = 0, j = 0; i < range; i++)     // insert intervals back into I in sorted order\\n            for(auto end : ends[i])\\n                I[j++] = {i, end};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& I) {\\n        countingSort(I);\\n        int R = 0;\\n        for(auto i : I)\\n            if(i[0] <= I[R][1])\\n                I[R][1] = max(I[R][1], i[1]);\\n            else               \\n                I[++R] = i;\\n        I.resize(R+1);\\n        return I;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def merge(self, I):\\n        def countingSort():\\n            ends, j = defaultdict(list), 0\\n            for i in I:\\n                ends[i[0]].append(i[1])\\n            for i in range(1 + max(I, key = lambda i : i[0])[0]):\\n                for end in ends[i]:\\n                    I[j] = [i, end]\\n                    j += 1\\n                    \\n        countingSort()\\n        R = 0\\n        for i in I:\\n            if i[0] <= I[R][1]:\\n                I[R][1] = max(I[R][1], i[1])\\n            else:\\n                I[(R := R + 1)] = i\\n        return I[:R+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21452,
                "title": "share-my-interval-tree-solution-no-sorting",
                "content": "I want to do it without sorting, because:\\nhttps://leetcode.com/discuss/67748/share-my-bst-interval-tree-solution-c-no-sorting?show=67748#q67748\\n\\nIn that post, I used BST of intervals. However, as you can see from that post, if each node is an interval, it is very difficult to keep each node disjoint. Although that code achieved this, it is hard to read. \\n\\nSo, I use interval tree in this post. You can google and find its variations, I am using the basic structure. Basically, each node will maintains a lot of intervals, depending on whether the interval intersect the middle of the node. It is easy to insert/delete an interval. The only difficult is: given an interval tree, how to get the final result, how to merge them in the final step?\\n\\n    class IntervalTree{\\n    public:\\n        int middle;\\n        int start, end;\\n        IntervalTree *left, *right;\\n        IntervalTree(int s, int e): start(s), end(e), middle((s+e)/2){\\n            this->left=this->right=NULL;\\n        }\\n};\\n\\n\\n    void InsertInterval(IntervalTree *node, Interval \\xa4tInterval){\\n    if(node == NULL)\\n        return;\\n\\n    if(currentInterval.end<node->middle){\\n        if(node->left)\\n            return InsertInterval(node->left, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->left = newnode;\\n            return;\\n        }\\n    }\\n\\n    if(currentInterval.start>node->middle){\\n        if(node->right)\\n            return InsertInterval(node->right, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->right = newnode;\\n            return;\\n        }\\n    }\\n\\n    //insert it to current node\\n    node->start=min(node->start, currentInterval.start);\\n    node->end=max(node->end, currentInterval.end);\\n\\n}\\n\\nSo, when you want to merge the intervals, you will do something like below:\\n\\n    void QueryInterval(vector<Interval> &retV, IntervalTree *node){\\n    //retV is the return vector\\n    vector<Interval> leftIntervals;\\n    vector<Interval> rightIntervals;\\n\\n    bool mergeleft = false; //whether current node merge with any intervals from left child. \\n    if(node->left){\\n        //return the merge of all intervals in left child. \\n        QueryInterval(leftIntervals, node->left);\\n        //merge left interval with myself. \\n        MergeLeftInterval(leftIntervals, node, retV, mergeleft);\\n    }\\n    if(!mergeleft){ //if we did not merge left intervals, add a new one\\n        Interval newinterval;\\n        newinterval.start = node->start;\\n        newinterval.end = node->end;\\n        retV.push_back(newinterval);\\n    }\\n    \\n    if(node->right){\\n        QueryInterval(rightIntervals, node->right);\\n        MergeRightInterval(rightIntervals, node, retV);\\n    }\\n    \\n    return;\\n}\\n\\n\\nAnd finally, the 2 child functions used above:\\n\\n    void MergeLeftInterval(vector<Interval> &leftIntervals, IntervalTree *node, vector<Interval> &retV, bool &merged){\\n    for(int i=0; i<leftIntervals.size(); i++){\\n        if(leftIntervals[i].end>=node->start){\\n            Interval newinterval;\\n            newinterval.start = min(leftIntervals[i].start, node->start);\\n            newinterval.end = node->end;\\n            retV.push_back(newinterval);\\n            merged = true;\\n            break;\\n        }\\n        else{\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n\\nvoid MergeRightInterval(vector<Interval> &rightIntervals, IntervalTree *node, vector<Interval> &retV){\\n    for(int i=0; i<rightIntervals.size(); i++){\\n        if(rightIntervals[i].start<=node->end){\\n            retV[retV.size()-1].end = max(rightIntervals[i].end, node->end);\\n        }\\n        else{\\n            retV.push_back(rightIntervals[i]);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "C++"
                ],
                "code": "I want to do it without sorting, because:\\nhttps://leetcode.com/discuss/67748/share-my-bst-interval-tree-solution-c-no-sorting?show=67748#q67748\\n\\nIn that post, I used BST of intervals. However, as you can see from that post, if each node is an interval, it is very difficult to keep each node disjoint. Although that code achieved this, it is hard to read. \\n\\nSo, I use interval tree in this post. You can google and find its variations, I am using the basic structure. Basically, each node will maintains a lot of intervals, depending on whether the interval intersect the middle of the node. It is easy to insert/delete an interval. The only difficult is: given an interval tree, how to get the final result, how to merge them in the final step?\\n\\n    class IntervalTree{\\n    public:\\n        int middle;\\n        int start, end;\\n        IntervalTree *left, *right;\\n        IntervalTree(int s, int e): start(s), end(e), middle((s+e)/2){\\n            this->left=this->right=NULL;\\n        }\\n};\\n\\n\\n    void InsertInterval(IntervalTree *node, Interval \\xa4tInterval){\\n    if(node == NULL)\\n        return;\\n\\n    if(currentInterval.end<node->middle){\\n        if(node->left)\\n            return InsertInterval(node->left, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->left = newnode;\\n            return;\\n        }\\n    }\\n\\n    if(currentInterval.start>node->middle){\\n        if(node->right)\\n            return InsertInterval(node->right, currentInterval);\\n        else{\\n            IntervalTree *newnode = new IntervalTree(currentInterval.start, currentInterval.end);\\n            node->right = newnode;\\n            return;\\n        }\\n    }\\n\\n    //insert it to current node\\n    node->start=min(node->start, currentInterval.start);\\n    node->end=max(node->end, currentInterval.end);\\n\\n}\\n\\nSo, when you want to merge the intervals, you will do something like below:\\n\\n    void QueryInterval(vector<Interval> &retV, IntervalTree *node){\\n    //retV is the return vector\\n    vector<Interval> leftIntervals;\\n    vector<Interval> rightIntervals;\\n\\n    bool mergeleft = false; //whether current node merge with any intervals from left child. \\n    if(node->left){\\n        //return the merge of all intervals in left child. \\n        QueryInterval(leftIntervals, node->left);\\n        //merge left interval with myself. \\n        MergeLeftInterval(leftIntervals, node, retV, mergeleft);\\n    }\\n    if(!mergeleft){ //if we did not merge left intervals, add a new one\\n        Interval newinterval;\\n        newinterval.start = node->start;\\n        newinterval.end = node->end;\\n        retV.push_back(newinterval);\\n    }\\n    \\n    if(node->right){\\n        QueryInterval(rightIntervals, node->right);\\n        MergeRightInterval(rightIntervals, node, retV);\\n    }\\n    \\n    return;\\n}\\n\\n\\nAnd finally, the 2 child functions used above:\\n\\n    void MergeLeftInterval(vector<Interval> &leftIntervals, IntervalTree *node, vector<Interval> &retV, bool &merged){\\n    for(int i=0; i<leftIntervals.size(); i++){\\n        if(leftIntervals[i].end>=node->start){\\n            Interval newinterval;\\n            newinterval.start = min(leftIntervals[i].start, node->start);\\n            newinterval.end = node->end;\\n            retV.push_back(newinterval);\\n            merged = true;\\n            break;\\n        }\\n        else{\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n\\nvoid MergeRightInterval(vector<Interval> &rightIntervals, IntervalTree *node, vector<Interval> &retV){\\n    for(int i=0; i<rightIntervals.size(); i++){\\n        if(rightIntervals[i].start<=node->end){\\n            retV[retV.size()-1].end = max(rightIntervals[i].end, node->end);\\n        }\\n        else{\\n            retV.push_back(rightIntervals[i]);\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 21276,
                "title": "a-clean-java-solution",
                "content": "    public class Solution {\\n        public List<Interval> merge(List<Interval> intervals) {\\n            Collections.sort(intervals, new Comparator<Interval>(){\\n                @Override\\n                public int compare(Interval obj0, Interval obj1) {\\n                    return obj0.start - obj1.start;\\n                }\\n            });\\n    \\n            List<Interval> ret = new ArrayList<>();\\n            Interval prev = null;\\n            for (Interval inter : intervals) {\\n                if (  prev==null || inter.start>prev.end ) {\\n                    ret.add(inter);\\n                    prev = inter;\\n                } else if (inter.end>prev.end) {\\n                    // Modify the element already in list\\n                    prev.end = inter.end;\\n                }\\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Interval> merge(List<Interval> intervals) {\\n            Collections.sort(intervals, new Comparator<Interval>(){\\n                @Override\\n                public int compare(Interval obj0, Interval obj1) {\\n                    return obj0.start - obj1.start;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 179876,
                "title": "thinking-process",
                "content": "In order to merge overlapped intervals, we should be able to tell whether two intervals are overlapped.\\n\\nGiven two intervals `[a, b]` and `[c, d]`, they do not overlap with each other if `b < c or d < a`.\\n\\nSo they overlap if `a <= d and c <= b` as below examples:\\n```\\n1)\\n-----\\na   b\\n\\n  -----\\n  c   d\\n2)\\n\\t-----\\n\\ta   b\\n\\n  -----\\n  c   d\\n```\\n\\nIf we sort intervals by starts of both intervals, then `a <= c`, since `c < d`, so `a < d` -- one requirement of overlapped intervals is met.\\n\\nThus, after we sort intervals by starts, two intervals overlap if `c <= b`.\\n\\nAll in all, we sort the intervals given in the problem by starts, and then iterate through the sorted intervals - we merge overlapped intervals on the fly.\\n\\nIs that one-pass enough to merge over-lapped intervals? Yes, since intervals[i + 1] cannot overlap with intervals[i - 1] if intervals[i] doesn\\'t in the sorted sequence.\\n****\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda interval : interval[0])\\n        res = [intervals[0]]\\n        for [start, end] in intervals:\\n            prev_start, prev_end = res[-1]\\n            if start <= prev_end:  # overlap\\n                res.pop()\\n                res.append([prev_start, max(prev_end, end)])\\n            else:\\n                res.append([start, end])\\n        return res\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n1)\\n-----\\na   b\\n\\n  -----\\n  c   d\\n2)\\n\\t-----\\n\\ta   b\\n\\n  -----\\n  c   d\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda interval : interval[0])\\n        res = [intervals[0]]\\n        for [start, end] in intervals:\\n            prev_start, prev_end = res[-1]\\n            if start <= prev_end:  # overlap\\n                res.pop()\\n                res.append([prev_start, max(prev_end, end)])\\n            else:\\n                res.append([start, end])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21332,
                "title": "short-python-solution",
                "content": "Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one.\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            if len(intervals) == 0: return []\\n            intervals = sorted(intervals, key = lambda x: x.start)\\n            res = [intervals[0]]\\n            for n in intervals[1:]:\\n                if n.start <= res[-1].end: res[-1].end = max(n.end, res[-1].end)\\n                else: res.append(n)\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "Sort the list first. Check if the new interval overlaps with the previous one in the output list. If yes, update it. Otherwise, append the new one.\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            if len(intervals) == 0: return []\\n            intervals = sorted(intervals, key = lambda x: x.start)\\n            res = [intervals[0]]\\n            for n in intervals[1:]:\\n                if n.start <= res[-1].end: res[-1].end = max(n.end, res[-1].end)\\n                else: res.append(n)\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 1644169,
                "title": "java-simple-steps-explained-simple-sort",
                "content": "# \\u2705 Approach 1 : Sorting \\n\\n---\\n\\n> ##### Sort by start of intervals, keep track of merging interval\\n\\n\\nOur task in this question is to merge the intervals which can merge:\\n* Only those intervals can merge whose start lies between the start and end of other interval .\\n*  I1 =  [1,5]   and I2 = [2,8] ,these intervals can merge as the start of I2 is lies between then interval range of I1\\n*  Now inorder to know adjacent interval which  can possibly merge we will sort all interval on the basis of start \\n\\n\\n**Steps :**\\n\\n---\\n* **Take some initial range** ( taking 0th index interval as initial range)\\n* Now, start iterating from 1 index in intervals array\\n* if its start lies in intial range , then increase your range by \\n```\\t \\t \\n\\t\\t\\t\\t\\t end =  Math.max(end,interval[i][1])                       `\\t\\t \\n```\\n * if there is no intersection of this interval with our range then add this range in ans arraylis and intialize new range by current index interval\\n \\n ####  Lets see code for more better understanding \\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83D\\uDCBB\\uD83D\\uDCBB :\\n ---\\n \\n ```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n\\t\\t// sort our intervals \\n      Arrays.sort(intervals, (o1,o2)->o1[0]-o2[0]);\\n   \\n        ArrayList<int[]> ans  =  new ArrayList<>();\\n\\t\\t// intial range \\n        int start  =  intervals[0][0];\\n        int end =  intervals[0][1]; \\n        \\n        int  i =1;\\n        while(i<intervals.length){\\n            int s = intervals[i][0];\\n            int e = intervals[i][1];\\n            // next interval start is smaller than prev end and array is sorted\\n            // so these two internal can merge\\n            if( s<=end  ) { \\n                // so merge both intervals \\n                end =  Math.max(end,e);\\n            }\\n            else{ // if merge not possible , then insert prev interval into list\\n                ans.add(new int[]{start,end});\\n                start = s;\\n                end =  e;                \\n            }\\n           i++;\\n        }\\n        \\n        ans.add(new int[] {start,end});\\n\\t\\t\\n\\t\\t  int arr[][] =  new int[ans.size()][];\\n\\t        for(int i=0;i<ans.size();i++) {\\n\\t        \\tint a[] =  new int[2];\\n\\t        \\tfor(int j=0;j<2;j++) {\\n\\t        \\t\\ta[j] =  ans.get(i).get(j);\\n\\t        \\t}\\n\\t        \\tarr[i] =  a;\\n\\t        }\\n\\t        \\n\\t        return   arr;\\n\\t\\t\\n\\t\\t // or \\n\\t\\t //  return ans.toArray(new int[0][]);\\n        \\n        \\n        \\n    }\\n}\\n```\\n\\n\\n\\n\\n---\\n\\n# **\\u2705** Approach 2 : Using TreeSet\\n\\n\\n\\n\\n```\\nclass Solution {\\n\\n    public int[][] merge(int[][] intervals) {       \\n        for (int interval[] : intervals) {\\n            add(interval[0], interval[1]);\\n        }\\n        int i = 0;\\n        int ans[][] = new int[map.size()][2];\\n        for (Map.Entry<Integer, Integer> it : map.entrySet()) {\\n            ans[i++] = new int[] { it.getKey(), it.getValue() };\\n        }\\n        return ans;\\n    }\\n\\n\\t// storing , {start,end} of interval \\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public void add(int left, int right) {\\n\\t\\t// finding greatest , smaller key than right \\n        if (map.floorKey(right) == null || map.get(map.floorKey(right)) < left) {\\n            map.put(left, right);\\n        } else {\\n            int start = left, end = right;\\n            while (true) {\\n                int l = map.floorKey(end);\\n                int r = map.get(l);\\n                start = Math.min(l, start);\\n                end = Math.max(r, end);\\n\\n                map.remove(l);\\n\\t\\t\\t\\t// if no longer merge can be done then break\\n                if (map.floorKey(end) == null || map.get(map.floorKey(end)) < start) {\\n                    break;\\n                }\\n            }\\n\\n            map.put(start, end);\\n        }\\n    }\\n}\\n\\n```\\n\\n >**Time Complexity** : **n*logn** , (each add operation  armotrised logn  )\\n >**space : O(n)**\\n >\\n\\n\\n### Do upvote if found useful\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\t \\t \\n\\t\\t\\t\\t\\t end =  Math.max(end,interval[i][1])                       `\\t\\t \\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n\\t\\t// sort our intervals \\n      Arrays.sort(intervals, (o1,o2)->o1[0]-o2[0]);\\n   \\n        ArrayList<int[]> ans  =  new ArrayList<>();\\n\\t\\t// intial range \\n        int start  =  intervals[0][0];\\n        int end =  intervals[0][1]; \\n        \\n        int  i =1;\\n        while(i<intervals.length){\\n            int s = intervals[i][0];\\n            int e = intervals[i][1];\\n            // next interval start is smaller than prev end and array is sorted\\n            // so these two internal can merge\\n            if( s<=end  ) { \\n                // so merge both intervals \\n                end =  Math.max(end,e);\\n            }\\n            else{ // if merge not possible , then insert prev interval into list\\n                ans.add(new int[]{start,end});\\n                start = s;\\n                end =  e;                \\n            }\\n           i++;\\n        }\\n        \\n        ans.add(new int[] {start,end});\\n\\t\\t\\n\\t\\t  int arr[][] =  new int[ans.size()][];\\n\\t        for(int i=0;i<ans.size();i++) {\\n\\t        \\tint a[] =  new int[2];\\n\\t        \\tfor(int j=0;j<2;j++) {\\n\\t        \\t\\ta[j] =  ans.get(i).get(j);\\n\\t        \\t}\\n\\t        \\tarr[i] =  a;\\n\\t        }\\n\\t        \\n\\t        return   arr;\\n\\t\\t\\n\\t\\t // or \\n\\t\\t //  return ans.toArray(new int[0][]);\\n        \\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public int[][] merge(int[][] intervals) {       \\n        for (int interval[] : intervals) {\\n            add(interval[0], interval[1]);\\n        }\\n        int i = 0;\\n        int ans[][] = new int[map.size()][2];\\n        for (Map.Entry<Integer, Integer> it : map.entrySet()) {\\n            ans[i++] = new int[] { it.getKey(), it.getValue() };\\n        }\\n        return ans;\\n    }\\n\\n\\t// storing , {start,end} of interval \\n    TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n    public void add(int left, int right) {\\n\\t\\t// finding greatest , smaller key than right \\n        if (map.floorKey(right) == null || map.get(map.floorKey(right)) < left) {\\n            map.put(left, right);\\n        } else {\\n            int start = left, end = right;\\n            while (true) {\\n                int l = map.floorKey(end);\\n                int r = map.get(l);\\n                start = Math.min(l, start);\\n                end = Math.max(r, end);\\n\\n                map.remove(l);\\n\\t\\t\\t\\t// if no longer merge can be done then break\\n                if (map.floorKey(end) == null || map.get(map.floorKey(end)) < start) {\\n                    break;\\n                }\\n            }\\n\\n            map.put(start, end);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21451,
                "title": "share-my-bst-interval-tree-solution-c-no-sorting",
                "content": "I share this solution because my friend was asked in his FB interview. He was asked to do it without sorting, for a large stream of intervals. The solution can be interval tree, but that is too complicated. Here I maintain a BST of distinct intervals. We dont need to maintain all the intervals like interval tree. We will merge intervals while we inserting. The code did not balance the tree. That is why performance is still 500+ms. \\n\\nSuppose we already have a BST of disjoint intervals. Given a new interval A, it will first find the toppest interval that has overlapping with A. Suppose it is B. Until now everything is easy. We simply traversed tree to reach this. \\n\\nThen, it will try to expand interval B. Now it becomes tricky. There are 3 cases. 1 case is simple. For the other 2 cases, you will need to delete currentNode, because it is already merged. You need to always correctly maintain prevNode and direction, in order to merge correctly in next round. For 1 case, you can end there. For another case, you need to continue exploration. \\nThe 2nd and 3rd case have duplicate code. However, I just keep it for better understanding.\\n\\nThe whole reason we can do this, is because: we will never meet a situation that we delete 1 node with 2 children but still keep its 2 children. If we remove 1 node, that means either his left or right is deleted. So, this is not really traditional node deletion in BST!!!!!! \\n\\nI only share my code that insert a new interval to a BST. Other parts are simple. \\nPlease see notes when we exploring left Children, comments are omitted when exploring right children.\\n\\n    void InsertInterval(BSTInterval *node, Interval \\xa4tInterval, BSTInterval *prev, int sign){\\n    //sign=1 if prev->left = node, sign=-1 if prev->right=node. \\n    \\n    int start=currentInterval.start, end = currentInterval.end;\\n    if(node==NULL){\\n        BSTInterval *newnode = new BSTInterval(start, end);\\n        if(sign==1){\\n            prev->left = newnode;\\n            return;\\n        }\\n        else{\\n            prev->right = newnode;\\n            return;\\n        }\\n    }\\n    if (node->start<=start && node->end>=end)\\n        return;\\n        \\n    if (node->start>end){\\n        InsertInterval(node->left, currentInterval, node, 1);\\n        return;\\n    }\\n    if (node->end<start){\\n        InsertInterval(node->right, currentInterval, node, -1);\\n        return;\\n    }\\n    \\n    \\n    /* Now we find the node that overlap with the interval we want to insert. \\n       We start from here and merge intervals. */\\n    //newLeft is always the new start after explore. \\n    int newLeft=min(start, node->start);\\n    if(start<node->start){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newLeft>currentNode->end){\\n                //apparently need to explore right direction. \\n                prevNode = currentNode;\\n                currentNode = currentNode->right;\\n                sign = -1;\\n            }\\n            else if (newLeft>currentNode->start){\\n                //apparently currentNode is not node, otherwise will not hit here\\n                //so, it is safe to delete currentNode\\n                //also, in this case, no need to explore more nodes, why?\\n                newLeft=currentNode->start;\\n                clear(currentNode->right);\\n                currentNode->right=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->left;\\n                else\\n                    prevNode->right = currentNode->left;\\n                //we don't need to explore. \\n                delete currentNode;\\n                break;//no need to continue, why?\\n            }\\n            else{ \\n                //be careful: currentNode will be deleted if it is not node\\n                //then, we need to update prevNode and sign directly\\n                //otherwise we can not properly delete next node!!!\\n                //this case still needs exploration.\\n                BSTInterval *leftChild = currentNode->left;\\n                if(currentNode!=node){\\n                    //prevNode and sign not changed. Just delete currentNode\\n                    clear(currentNode->right);\\n                    currentNode->right=NULL;\\n                    if(sign==1)\\n                        prevNode->left = leftChild;\\n                    else\\n                        prevNode->right = leftChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    //prevNode and sign changed. \\n                    prevNode = currentNode;\\n                    sign = 1;\\n                }\\n                currentNode=leftChild;\\n            }\\n        }\\n    }\\n    node->start = newLeft;\\n\\n    int newRight=max(end, node->end);\\n    if(end>node->end){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newRight<currentNode->start){\\n                prevNode = currentNode;\\n                currentNode = currentNode->left;\\n                sign = +1;\\n            }\\n            else if (newRight<currentNode->end){\\n                newRight=currentNode->end;\\n                clear(currentNode->left);\\n                currentNode->left=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->right;\\n                else\\n                    prevNode->right = currentNode->right;\\n                delete currentNode;\\n                break;\\n            }\\n            else{ \\n                BSTInterval *rightChild = currentNode->right;\\n                if(currentNode!=node){\\n                    clear(currentNode->left);\\n                    currentNode->left=NULL;\\n                    if(sign==1)\\n                        prevNode->left = rightChild;\\n                    else\\n                        prevNode->right = rightChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    prevNode = currentNode;\\n                    sign = -1;\\n                }\\n                currentNode=rightChild;                    \\n            }\\n        }\\n    }\\n    node->end = newRight;\\n\\n    return;\\n}",
                "solutionTags": [],
                "code": "I share this solution because my friend was asked in his FB interview. He was asked to do it without sorting, for a large stream of intervals. The solution can be interval tree, but that is too complicated. Here I maintain a BST of distinct intervals. We dont need to maintain all the intervals like interval tree. We will merge intervals while we inserting. The code did not balance the tree. That is why performance is still 500+ms. \\n\\nSuppose we already have a BST of disjoint intervals. Given a new interval A, it will first find the toppest interval that has overlapping with A. Suppose it is B. Until now everything is easy. We simply traversed tree to reach this. \\n\\nThen, it will try to expand interval B. Now it becomes tricky. There are 3 cases. 1 case is simple. For the other 2 cases, you will need to delete currentNode, because it is already merged. You need to always correctly maintain prevNode and direction, in order to merge correctly in next round. For 1 case, you can end there. For another case, you need to continue exploration. \\nThe 2nd and 3rd case have duplicate code. However, I just keep it for better understanding.\\n\\nThe whole reason we can do this, is because: we will never meet a situation that we delete 1 node with 2 children but still keep its 2 children. If we remove 1 node, that means either his left or right is deleted. So, this is not really traditional node deletion in BST!!!!!! \\n\\nI only share my code that insert a new interval to a BST. Other parts are simple. \\nPlease see notes when we exploring left Children, comments are omitted when exploring right children.\\n\\n    void InsertInterval(BSTInterval *node, Interval \\xa4tInterval, BSTInterval *prev, int sign){\\n    //sign=1 if prev->left = node, sign=-1 if prev->right=node. \\n    \\n    int start=currentInterval.start, end = currentInterval.end;\\n    if(node==NULL){\\n        BSTInterval *newnode = new BSTInterval(start, end);\\n        if(sign==1){\\n            prev->left = newnode;\\n            return;\\n        }\\n        else{\\n            prev->right = newnode;\\n            return;\\n        }\\n    }\\n    if (node->start<=start && node->end>=end)\\n        return;\\n        \\n    if (node->start>end){\\n        InsertInterval(node->left, currentInterval, node, 1);\\n        return;\\n    }\\n    if (node->end<start){\\n        InsertInterval(node->right, currentInterval, node, -1);\\n        return;\\n    }\\n    \\n    \\n    /* Now we find the node that overlap with the interval we want to insert. \\n       We start from here and merge intervals. */\\n    //newLeft is always the new start after explore. \\n    int newLeft=min(start, node->start);\\n    if(start<node->start){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newLeft>currentNode->end){\\n                //apparently need to explore right direction. \\n                prevNode = currentNode;\\n                currentNode = currentNode->right;\\n                sign = -1;\\n            }\\n            else if (newLeft>currentNode->start){\\n                //apparently currentNode is not node, otherwise will not hit here\\n                //so, it is safe to delete currentNode\\n                //also, in this case, no need to explore more nodes, why?\\n                newLeft=currentNode->start;\\n                clear(currentNode->right);\\n                currentNode->right=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->left;\\n                else\\n                    prevNode->right = currentNode->left;\\n                //we don't need to explore. \\n                delete currentNode;\\n                break;//no need to continue, why?\\n            }\\n            else{ \\n                //be careful: currentNode will be deleted if it is not node\\n                //then, we need to update prevNode and sign directly\\n                //otherwise we can not properly delete next node!!!\\n                //this case still needs exploration.\\n                BSTInterval *leftChild = currentNode->left;\\n                if(currentNode!=node){\\n                    //prevNode and sign not changed. Just delete currentNode\\n                    clear(currentNode->right);\\n                    currentNode->right=NULL;\\n                    if(sign==1)\\n                        prevNode->left = leftChild;\\n                    else\\n                        prevNode->right = leftChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    //prevNode and sign changed. \\n                    prevNode = currentNode;\\n                    sign = 1;\\n                }\\n                currentNode=leftChild;\\n            }\\n        }\\n    }\\n    node->start = newLeft;\\n\\n    int newRight=max(end, node->end);\\n    if(end>node->end){\\n        BSTInterval * currentNode = node;\\n        BSTInterval * prevNode = NULL;\\n        while(currentNode != NULL){\\n            if (newRight<currentNode->start){\\n                prevNode = currentNode;\\n                currentNode = currentNode->left;\\n                sign = +1;\\n            }\\n            else if (newRight<currentNode->end){\\n                newRight=currentNode->end;\\n                clear(currentNode->left);\\n                currentNode->left=NULL;\\n                if(sign==1) \\n                    prevNode->left = currentNode->right;\\n                else\\n                    prevNode->right = currentNode->right;\\n                delete currentNode;\\n                break;\\n            }\\n            else{ \\n                BSTInterval *rightChild = currentNode->right;\\n                if(currentNode!=node){\\n                    clear(currentNode->left);\\n                    currentNode->left=NULL;\\n                    if(sign==1)\\n                        prevNode->left = rightChild;\\n                    else\\n                        prevNode->right = rightChild;\\n                    delete currentNode;\\n                }\\n                else{\\n                    prevNode = currentNode;\\n                    sign = -1;\\n                }\\n                currentNode=rightChild;                    \\n            }\\n        }\\n    }\\n    node->end = newRight;\\n\\n    return;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 738403,
                "title": "python3-solution-with-a-detailed-explanation",
                "content": "\\n\\nI\\'ve found [this](https://leetcode.com/problems/merge-intervals/discuss/350272/Python3-Sort-O(Nlog(N))) and [this](https://leetcode.com/problems/merge-intervals/discuss/21332/Short-python-solution) solutions super helpful. \\n\\nWhat we\\'re trying to do is to merge intervals with overlap right? One a piece of paper try to merge `a = [1,3]` and `b = [2,5]`. How will you do that? If the right side of `a` (basically `a[1]`) is larger than the left side of `b` (meaning `b[0]`), then you can merge them. Otherwise, you can\\'t. Makes sense? So basically, you go overe all the intervals in `intervals` list, check them one by one and see whether they have overlap or not. Merge them if they had overlap, otherwise, add them to the `res` variable without any change. \\n\\nNote that if there is no interval in `intervals`, we don\\'t need to do anythingm right? (line `#1`), we return `[]`. In order to formalize this, we first `sort` the array (line `#2`). Check [sorted](https://realpython.com/python-sort/). Unlike to `sort()`, `sorted` accepts a key by which you can do useful stuff. We sort here by first element of each interval. Does this make sense? Once we sort it, we add the first interval to the output `res`. Note that, the first element of first interval should have the least amount of all. Let\\'s say `res = [[c,d]]. Now, we check the rest of `intervals` (line `#4`). Let\\'s say the next interval is `[e,f]`. There are two possibilities! Either `e <= d` or `e > d`, right? If `e > d`, the intervals don\\'t have any overlap. But, if `e <=d`, there is an overlap for sure (or at least we have `e = d` which still means that if `f > e`, we should merge the two intervals. That\\'s what we\\'re doing here. \\n\\n\\n`current` interval is compared with the last interval in the `res`, why? Because the last interval is an interval without any overlap to the interval before it in `res` except if there\\'s only one interval in `res`, and since we\\'ve sorted the list initially, current should not have any overlap with intervals before `res[-1]`. Makes sense? So if ` e <= d`, we change `d` with `f` (line `#6`). Otherwise, we append the `current` interval to `res`. We keep doing it until the last interval in `intervals` is visited. \\n\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: #1\\n            return []\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0]) #2\\n        res = [intervals[0]] #3\\n        \\n        for current in intervals[1:]: #4\\n            if current[0] <= res[-1][1]: #5\\n                res[-1][1] = max(current[1], res[-1][1]) #6\\n            else: \\n                res.append(current) #7\\n        return res #1\\n```\\n\\nThis explanation from [here](https://leetcode.com/problems/merge-intervals/discuss/350272/Python3-Sort-O(Nlog(N))) is super helpful to understand the procedure:\\n\\n```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```\\n\\n\\n\\n===============================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix it\\n\\nFinal note 2: I\\'m doing this writing since I think explaining something in a simple way to others would help me to understand better. Thanks for reading.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: #1\\n            return []\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0]) #2\\n        res = [intervals[0]] #3\\n        \\n        for current in intervals[1:]: #4\\n            if current[0] <= res[-1][1]: #5\\n                res[-1][1] = max(current[1], res[-1][1]) #6\\n            else: \\n                res.append(current) #7\\n        return res #1\\n```\n```\\nintervals [[1, 3], [2, 6], [8, 10], [15, 18]]\\nintervals.sort [[1, 3], [2, 6], [8, 10], [15, 18]]\\n\\ninterval = [1,3]\\nmerged =[]\\nnot merged:\\n\\tmerged =[ [1,3] ]\\n\\ninterval =[2,6]\\nmerged = [ [1,3] ]\\nmerged[-1][-1] = 3 > interval[0] = 2:\\n\\tmerged[-1][-1] = max(merged[-1][-1] = 3 ,interval[-1] = 6) =6\\nmerged = [[1,6]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338834,
                "title": "python-3-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Heap**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        minHeap = intervals\\n        heapify(minHeap)  # Heapify in increasing by the starting time order\\n        ans = []\\n        while minHeap:\\n            start, end = heappop(minHeap)\\n            while minHeap and minHeap[0][0] <= end:\\n                end = max(end, heappop(minHeap)[1])\\n            ans.append([start, end])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Sort (Version 1)**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n        ans = []\\n        n, i = len(intervals), 0\\n        while i < n:\\n            start, end = intervals[i]\\n            i += 1\\n            while i < n and intervals[i][0] <= end:\\n                end = max(end, intervals[i][1])\\n                i += 1\\n            ans.append([start, end])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(logN)`, for sorting.\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Sort (Version 2)**\\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n \\n        lastStart = lastEnd = intervals[0][0]\\n        ans = []\\n        for s, e in intervals:\\n            if s <= lastEnd:\\n                lastEnd = max(lastEnd, e)\\n            else:\\n                ans.append([lastStart, lastEnd])\\n                lastStart = s\\n                lastEnd = e\\n        ans.append([lastStart, lastEnd])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`\\n- Extra Space (without counting output as space): `O(logN)`, for sorting.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        minHeap = intervals\\n        heapify(minHeap)  # Heapify in increasing by the starting time order\\n        ans = []\\n        while minHeap:\\n            start, end = heappop(minHeap)\\n            while minHeap and minHeap[0][0] <= end:\\n                end = max(end, heappop(minHeap)[1])\\n            ans.append([start, end])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n        ans = []\\n        n, i = len(intervals), 0\\n        while i < n:\\n            start, end = intervals[i]\\n            i += 1\\n            while i < n and intervals[i][0] <= end:\\n                end = max(end, intervals[i][1])\\n                i += 1\\n            ans.append([start, end])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort()  # Sort in increasing order by the starting time\\n \\n        lastStart = lastEnd = intervals[0][0]\\n        ans = []\\n        for s, e in intervals:\\n            if s <= lastEnd:\\n                lastEnd = max(lastEnd, e)\\n            else:\\n                ans.append([lastStart, lastEnd])\\n                lastStart = s\\n                lastEnd = e\\n        ans.append([lastStart, lastEnd])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21507,
                "title": "javascript-solution",
                "content": "    function merge(intervals) {\\n      if (!intervals.length) return intervals\\n      intervals.sort((a, b) => a.start !== b.start ? a.start - b.start : a.end - b.end)\\n      var prev = intervals[0]\\n      var res = [prev]\\n      for (var curr of intervals) {\\n        if (curr.start <= prev.end) {\\n          prev.end = Math.max(prev.end, curr.end)\\n        } else {\\n          res.push(curr)\\n          prev = curr\\n        }\\n      }\\n      return res\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function merge(intervals) {\\n      if (!intervals.length) return intervals\\n      intervals.sort((a, b) => a.start !== b.start ? a.start - b.start : a.end - b.end)\\n      var prev = intervals[0]\\n      var res = [prev]\\n      for (var curr of intervals) {\\n        if (curr.start <= prev.end) {\\n          prev.end = Math.max(prev.end, curr.end)\\n        } else {\\n          res.push(curr)\\n          prev = curr\\n        }\\n      }\\n      return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1553054,
                "title": "56-merge-intervals-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> answer = new ArrayList<>();\\n        \\n        if(intervals.length != 0 || intervals != null){\\n            Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n            \\n            int start = intervals[0][0];\\n            int end = intervals[0][1];\\n            for(int[] i: intervals){\\n                if(i[0] <= end){\\n                    end = Math.max(end, i[1]);\\n                } else {\\n                    answer.add(new int[]{start,end});\\n                    start = i[0];\\n                    end = i[1];\\n                }\\n            }\\n            answer.add(new int[]{start,end}); \\n            \\n        }\\n        \\n        return answer.toArray(new int[0][]); \\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> answer = new ArrayList<>();\\n        \\n        if(intervals.length != 0 || intervals != null){\\n            Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n            \\n            int start = intervals[0][0];\\n            int end = intervals[0][1];\\n            for(int[] i: intervals){\\n                if(i[0] <= end){\\n                    end = Math.max(end, i[1]);\\n                } else {\\n                    answer.add(new int[]{start,end});\\n                    start = i[0];\\n                    end = i[1];\\n                }\\n            }\\n            answer.add(new int[]{start,end}); \\n            \\n        }\\n        \\n        return answer.toArray(new int[0][]); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462187,
                "title": "clean-and-concise-java-code-with-comments",
                "content": "``` java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0)\\n            return intervals;\\n        \\n        // sort intervals by starting value\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n\\t\\t// if end of previous interval is more than the start of current interval then there is a overlap\\n        LinkedList<int[]> mergedIntervals = new LinkedList<>();\\n        for(int[] curr : intervals) {\\n            //  if list empty or no overlap simply add current interval\\n            if(mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])\\n                mergedIntervals.add(curr);\\n            // else if overlap exists then merge curren tinterval with the previous interval\\n            else \\n                mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);\\n        }\\n        \\n        return mergedIntervals.toArray(new int[0][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0)\\n            return intervals;\\n        \\n        // sort intervals by starting value\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n        \\n\\t\\t// if end of previous interval is more than the start of current interval then there is a overlap\\n        LinkedList<int[]> mergedIntervals = new LinkedList<>();\\n        for(int[] curr : intervals) {\\n            //  if list empty or no overlap simply add current interval\\n            if(mergedIntervals.isEmpty() || mergedIntervals.getLast()[1] < curr[0])\\n                mergedIntervals.add(curr);\\n            // else if overlap exists then merge curren tinterval with the previous interval\\n            else \\n                mergedIntervals.getLast()[1] = Math.max(mergedIntervals.getLast()[1], curr[1]);\\n        }\\n        \\n        return mergedIntervals.toArray(new int[0][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400090,
                "title": "c-easy-beginner-friendly-detailed-explaination",
                "content": "\\n\\n# Code : \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        vector<vector<int>> ans;\\n        ans.push_back({arr[0][0], arr[0][1]});\\n        int i = 0;\\n        int merge = 0;\\n\\n        for(; i < n - 1; i++){\\n            int j = i+1;\\n            if(ans[i - merge][1] >= arr[j][0]){\\n                ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n                merge++;\\n            }else{\\n                ans.push_back({arr[j][0], arr[j][1]});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n---\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. $$Sort$$ the $$intervals$$ based on their start times so that we can easily identify which $$intervals$$ $$overlap$$.\\n2. $$Iterate$$ through the $$sorted$$ $$intervals$$ and $$merge$$ $$overlapping$$ $$intervals$$ into a $$single$$ $$interval$$.\\n3. $$Return$$ the $$merged$$ intervals.\\n   This approach would require $$iterating$$ over the intervals $$twice$$ - once for $$sorting$$ and once for $$merging$$. However, it should be noted that there may be more efficient ways to solve the problem, and the approach may need to be modified based on the specifics of the input and output requirements.\\n\\n\\n---\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The first step is to $$sort$$ the $$intervals$$ by their start time. We use the $$sort()$$ function from the $$STL$$ $$library$$ to do this. This is done to simplify the merging process as we will compare only adjacent intervals to determine if they overlap or not.\\n \\n```\\n    sort(arr.begin(), arr.end());\\n```\\n\\n2. Next, we $$initialize$$ $$an$$ $$empty$$ $$vector$$ ans to store the merged intervals. We then push the first interval to ans, as it cannot overlap with any other interval. \\n\\n```\\n    vector<vector<int>> ans;\\n    ans.push_back({arr[0][0], arr[0][1]});\\n```\\n\\n3. We then $$iterate$$ over the $$remaining$$ $$intervals$$, starting from index 1. If the current interval overlaps with the last interval in ans, we update the ending time of the last interval in ans to the maximum of its original ending time and the ending time of the current interval. We also increment a variable merge to keep track of the number of merged intervals.\\n\\n```\\n    int i = 0;\\n    int merge = 0;\\n    for(; i < n - 1; i++){\\n        int j = i+1;\\n        if(ans[i - merge][1] >= arr[j][0]){\\n            ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n            merge++;\\n        }\\n\\n```\\n\\n4. If the current interval does not overlap with the last interval in ans, we add the current interval to ans.\\n\\n```\\n    else {\\n        ans.push_back({arr[j][0], arr[j][1]});\\n    }\\n```\\n\\n5. Finally, we return ans, which contains the merged intervals.\\n\\n```\\n     return ans;\\n```\\n\\n\\n---\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The code sorts the given vector of intervals based on their starting position using sort().\\n`Time complexity: O(n log n)`\\n- It initializes a new vector ans to store the merged intervals and pushes the first interval to ans.\\n`Time complexity: O(1)`\\n- It iterates through the remaining intervals and checks if they overlap with the last interval in ans.\\n`Time complexity: O(n)`\\n- If the intervals overlap, it updates the ending position of the last interval in ans to the maximum of its original ending position and the ending position of the current interval.\\n`Time complexity: O(1)`\\n- If the intervals do not overlap, it adds the current interval to ans.\\n`Time complexity: O(1)`\\n- Finally, it returns ans containing the merged intervals.\\n`Time complexity: O(n)`\\n\\n- **To summarize, the given code implements a simple and efficient solution to merge overlapping intervals in $$O(n log n) $$time. Its clear and concise implementation makes it easy to understand and maintain. It\\'s definitely a good solution to upload in LeetCode\\'s solution section.**\\n\\n\\n---\\n\\n\\n\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the approach I outlined is O(n), where n is the number of intervals. This is because we need to store the merged intervals in a vector. In the worst case scenario where none of the intervals overlap, the merged vector would be the same size as the input vector. However, in practice, the number of merged intervals will be less than or equal to the number of input intervals. Overall, the space complexity of the approach is linear in the size of the input.\\n\\n---\\n\\n![cat upvote.png](https://assets.leetcode.com/users/images/9e396fb7-dcf4-4c24-b108-9239ca73718d_1681118559.9426527.png)\\n\\n\\n![upvote.png](https://assets.leetcode.com/users/images/62c16602-a9cc-4762-b53e-ec2417f76648_1687507600.6519113.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n\\n        vector<vector<int>> ans;\\n        ans.push_back({arr[0][0], arr[0][1]});\\n        int i = 0;\\n        int merge = 0;\\n\\n        for(; i < n - 1; i++){\\n            int j = i+1;\\n            if(ans[i - merge][1] >= arr[j][0]){\\n                ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n                merge++;\\n            }else{\\n                ans.push_back({arr[j][0], arr[j][1]});\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\n    sort(arr.begin(), arr.end());\\n```\n```\\n    vector<vector<int>> ans;\\n    ans.push_back({arr[0][0], arr[0][1]});\\n```\n```\\n    int i = 0;\\n    int merge = 0;\\n    for(; i < n - 1; i++){\\n        int j = i+1;\\n        if(ans[i - merge][1] >= arr[j][0]){\\n            ans[i - merge][1] = max(arr[j][1], ans[i - merge][1]);\\n            merge++;\\n        }\\n\\n```\n```\\n    else {\\n        ans.push_back({arr[j][0], arr[j][1]});\\n    }\\n```\n```\\n     return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810795,
                "title": "python-js-go-c-by-sort-merge-w-visualization",
                "content": "**Diagram and Visualization**\\n\\nAfter soring on endpoint pair, there are 3 possible cases for interval pairs during merging\\n\\n![image](https://assets.leetcode.com/users/images/8fee36e8-d9d4-4efb-8e91-05d3b0240a4f_1598347860.5559268.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/f6550399-4197-4ec4-8eeb-7c38de6672e8_1598347895.2212944.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/07c2b4fa-bd43-46df-b6a4-259840c0649b_1598347927.5255473.png)\\n\\n---\\n\\n**Implementation** by sort-and-merge\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        \\n        # predefined constant for start (left endpoint), and end (right endpoint)\\n        START, END = 0, 1\\n        \\n        result = []\\n        \\n        # make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        intervals.sort( key = lambda x: (x[START], x[END] ) ) \\n        \\n        for interval in intervals:\\n            \\n            if not result or ( result[-1][END] < interval[START] ):\\n\\t\\t\\t\\t# no overlapping\\n                result.append( interval )\\n            \\n            else:\\n\\t\\t\\t\\t# has overlapping\\n\\t\\t\\t\\t# merge with previous interval\\n                result[-1][END] = max(result[-1][END], interval[END])\\n                \\n        return result\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar merge = function(intervals) {\\n    \\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const [START, END] = [0, 1];\\n    \\n    let result = [];\\n    \\n    // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n    intervals.sort( (a, b) => a[START] != b[START] ? a[START] - b[START] : a[END] - b[END] );\\n    \\n    for( const curInterval of intervals){\\n        \\n        if( (result.length == 0) || ( result[result.length-1][END] < curInterval[START]) ){\\n            // no overlapping\\n            result.push( curInterval );\\n\\n            \\n        \\n        }else{\\n            // has overlapping\\n            // merge with previous interval\\n            result[result.length-1][END] = Math.max( result[result.length-1][END], curInterval[END] );\\n\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc max(x, y int) int {\\n    \\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n//---------------------\\n\\n\\nfunc merge(intervals [][]int) [][]int {\\n\\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const START, END = 0, 1\\n    \\n    result := make( [][]int, 0);\\n    \\n    sort.Slice(intervals, func(a, b int) bool {\\n        return (intervals[a][0] < intervals[b][0]) || ( (intervals[a][0] == intervals[b][0]) && (intervals[a][1] < intervals[b][1]) )\\n    })\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if ( len(result) == 0 ) || ( result[len(result)-1][END] < curInterval[START] ){\\n            \\n            // no overlapping\\n            result = append(result, curInterval)\\n            \\n        }else{\\n            \\n            // has overlapping\\n            // merge with previous interval\\n            result[len(result)-1][END] = max( result[len(result)-1][END], curInterval[END] )\\n        }\\n        \\n    }\\n    \\n    return result\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        // predefined constant for start (left endpoint), as well as end ( right endpoint)\\n        const int START=0, END=1;   \\n        \\n        vector< vector<int> > result;\\n    \\n        // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        sort( intervals.begin(), intervals.end() );\\n        \\n        for( auto const &curInterval : intervals ){\\n            \\n            if ( (result.size() == 0 ) || (result.back()[END] < curInterval[START] ) ){\\n                // no overlapping\\n                result.push_back( curInterval );\\n                \\n            }else{\\n                // has overlapping\\n                // merge with previous interval\\n                result.back()[END] = max( result.back()[END], curInterval[END] );\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        \\n        # predefined constant for start (left endpoint), and end (right endpoint)\\n        START, END = 0, 1\\n        \\n        result = []\\n        \\n        # make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        intervals.sort( key = lambda x: (x[START], x[END] ) ) \\n        \\n        for interval in intervals:\\n            \\n            if not result or ( result[-1][END] < interval[START] ):\\n\\t\\t\\t\\t# no overlapping\\n                result.append( interval )\\n            \\n            else:\\n\\t\\t\\t\\t# has overlapping\\n\\t\\t\\t\\t# merge with previous interval\\n                result[-1][END] = max(result[-1][END], interval[END])\\n                \\n        return result\\n```\n```\\nvar merge = function(intervals) {\\n    \\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const [START, END] = [0, 1];\\n    \\n    let result = [];\\n    \\n    // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n    intervals.sort( (a, b) => a[START] != b[START] ? a[START] - b[START] : a[END] - b[END] );\\n    \\n    for( const curInterval of intervals){\\n        \\n        if( (result.length == 0) || ( result[result.length-1][END] < curInterval[START]) ){\\n            // no overlapping\\n            result.push( curInterval );\\n\\n            \\n        \\n        }else{\\n            // has overlapping\\n            // merge with previous interval\\n            result[result.length-1][END] = Math.max( result[result.length-1][END], curInterval[END] );\\n\\n        }\\n    }\\n    \\n    return result;\\n};\\n```\n```\\nfunc max(x, y int) int {\\n    \\n    if x >= y {\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n//---------------------\\n\\n\\nfunc merge(intervals [][]int) [][]int {\\n\\n    // predefined constant for start (left endpoint), as well as end (right endpoint)\\n    const START, END = 0, 1\\n    \\n    result := make( [][]int, 0);\\n    \\n    sort.Slice(intervals, func(a, b int) bool {\\n        return (intervals[a][0] < intervals[b][0]) || ( (intervals[a][0] == intervals[b][0]) && (intervals[a][1] < intervals[b][1]) )\\n    })\\n    \\n    for _, curInterval := range intervals{\\n        \\n        if ( len(result) == 0 ) || ( result[len(result)-1][END] < curInterval[START] ){\\n            \\n            // no overlapping\\n            result = append(result, curInterval)\\n            \\n        }else{\\n            \\n            // has overlapping\\n            // merge with previous interval\\n            result[len(result)-1][END] = max( result[len(result)-1][END], curInterval[END] )\\n        }\\n        \\n    }\\n    \\n    return result\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        // predefined constant for start (left endpoint), as well as end ( right endpoint)\\n        const int START=0, END=1;   \\n        \\n        vector< vector<int> > result;\\n    \\n        // make all intervals sorted on (left endpoint, right endpoint) pair in ascending order\\n        sort( intervals.begin(), intervals.end() );\\n        \\n        for( auto const &curInterval : intervals ){\\n            \\n            if ( (result.size() == 0 ) || (result.back()[END] < curInterval[START] ) ){\\n                // no overlapping\\n                result.push_back( curInterval );\\n                \\n            }else{\\n                // has overlapping\\n                // merge with previous interval\\n                result.back()[END] = max( result.back()[END], curInterval[END] );\\n                \\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716744,
                "title": "javascript-clean-code",
                "content": "```javascript\\nvar merge = function(intervals) {\\n    if(!intervals.length) return [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    const result = [intervals[0]];\\n    \\n    for(let [start, end] of intervals) {\\n        const endPrev = result.at(-1)[1]\\n        if(start <= endPrev) result.at(-1)[1] = Math.max(end, endPrev);\\n        else result.push([start, end]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar merge = function(intervals) {\\n    if(!intervals.length) return [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n    \\n    const result = [intervals[0]];\\n    \\n    for(let [start, end] of intervals) {\\n        const endPrev = result.at(-1)[1]\\n        if(start <= endPrev) result.at(-1)[1] = Math.max(end, endPrev);\\n        else result.push([start, end]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21488,
                "title": "my-easy-c-solution",
                "content": "    static bool comp(const Interval& a, const Interval& b){\\n        return a.start < b.start;\\n    }\\n    vector<Interval> merge(vector<Interval> &intervals) {\\n        vector<Interval> result;\\n        if(intervals.empty()){\\n            return result;\\n        }\\n        sort(intervals.begin(), intervals.end(), comp);\\n        result.push_back(intervals[0]);\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i].start <= result.back().end){\\n                Interval temp(result.back().start, max(result.back().end, intervals[i].end));\\n                result.pop_back();\\n                result.push_back(temp);\\n            }\\n            else{\\n                result.push_back(intervals[i]);\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    static bool comp(const Interval& a, const Interval& b){\\n        return a.start < b.start;\\n    }\\n    vector<Interval> merge(vector<Interval> &intervals) {\\n        vector<Interval> result;\\n        if(intervals.empty()){\\n            return result;\\n        }\\n        sort(intervals.begin(), intervals.end(), comp);\\n        result.push_back(intervals[0]);\\n        for(int i = 1; i < intervals.size(); i++){\\n            if(intervals[i].start <= result.back().end){\\n                Interval temp(result.back().start, max(result.back().end, intervals[i].end));\\n                result.pop_back();\\n                result.push_back(temp);\\n            }\\n            else{\\n                result.push_back(intervals[i]);\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1528228,
                "title": "multiple-c-solution",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n# Method 01\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        \\n        sort(v.begin(),v.end());\\n        vector<vector<int>>ans;\\n   \\n        ans.push_back(v[0]);\\n\\n        int first = ans[0][0];\\n        int last = ans[0][1];\\n        int k=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n\\n            if(v[i][0]<=last)\\n            {\\n                ans[k][1] = max(v[i][1],last);\\n                ans[k][0] =  min(v[i][0],first);\\n                first = ans[k][0];\\n                last = ans[k][1];\\n            }\\n            else{\\n\\n                vector<int>temp;\\n                temp.push_back(v[i][0]);\\n                temp.push_back(v[i][1]);\\n\\n                ans.push_back(temp);\\n\\n                k++;\\n                first =  ans[k][0];\\n                last =  ans[k][1];\\n\\n            }\\n    }\\n            return ans;\\n    }\\n\\n};\\n```\\n# Method 02\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        int n = intervals.size();\\n        ans.push_back({intervals[0][0],intervals[0][1]});\\n       \\n        if(n==1)\\n            return ans;\\n        \\n        int a=0, b=0, i=1;\\n        while(i<n){\\n            if(ans[a][1]>=intervals[i][0]){\\n                ans[a][1]= max(ans[a][1],intervals[i][1]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n                a++;\\n            }\\n        }\\n        return ans;     \\n    }\\n};\\n```\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        \\n        sort(v.begin(),v.end());\\n        vector<vector<int>>ans;\\n   \\n        ans.push_back(v[0]);\\n\\n        int first = ans[0][0];\\n        int last = ans[0][1];\\n        int k=0;\\n\\n        for(int i=1;i<v.size();i++)\\n        {\\n\\n            if(v[i][0]<=last)\\n            {\\n                ans[k][1] = max(v[i][1],last);\\n                ans[k][0] =  min(v[i][0],first);\\n                first = ans[k][0];\\n                last = ans[k][1];\\n            }\\n            else{\\n\\n                vector<int>temp;\\n                temp.push_back(v[i][0]);\\n                temp.push_back(v[i][1]);\\n\\n                ans.push_back(temp);\\n\\n                k++;\\n                first =  ans[k][0];\\n                last =  ans[k][1];\\n\\n            }\\n    }\\n            return ans;\\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        int n = intervals.size();\\n        ans.push_back({intervals[0][0],intervals[0][1]});\\n       \\n        if(n==1)\\n            return ans;\\n        \\n        int a=0, b=0, i=1;\\n        while(i<n){\\n            if(ans[a][1]>=intervals[i][0]){\\n                ans[a][1]= max(ans[a][1],intervals[i][1]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n                a++;\\n            }\\n        }\\n        return ans;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939998,
                "title": "python-sort-and-traverse-explained",
                "content": "Let us sort our intervals by its starts and then iterate them one by one: we can have two options:\\n\\n1. The current ending point in our `ans` is less than `beg` of new interval: it means that we have a gap and we need to add new interval to our answer.\\n2. In the opposite case our intervals are overlapping, so we need to update the end for last interval we created.\\n\\n**Complexity:** time complexity is `O(n log n)` to sort intervals and space complexity is `O(n)` to keep sorted intervals and answer.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals):\\n        ans = []\\n        \\n        for beg, end in sorted(intervals):\\n            if not ans or ans[-1][1] < beg:\\n                ans += [[beg, end]]\\n            else:\\n                ans[-1][1] = max(ans[-1][1], end)\\n\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals):\\n        ans = []\\n        \\n        for beg, end in sorted(intervals):\\n            if not ans or ans[-1][1] < beg:\\n                ans += [[beg, end]]\\n            else:\\n                ans[-1][1] = max(ans[-1][1], end)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358410,
                "title": "c-brute-force-optimal-solution-commented-time-o-nlogn-auxiliary-space-o-1",
                "content": "**Brute Force Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end()); // Time taken by sort() is O(NlogN)\\n        vector<vector<int>> res;\\n        for(int i=0;i<len;i++){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            // for loop inside for loop takes time of O(N^2)\\n            for(int j=i+1;j<len;j++){\\n                int c=intervals[j][0];\\n                int d=intervals[j][1];\\n                if(b>=c){ \\n                    // Comparing pairs : (a,b) & (c,d)\\n                    // Interval overlap condition example - a=3,b=7,c=5,d=9\\n                    //  Real Line---a(3)------c(5)******b(7)-------d(9)----\\n                    // (a,max(b,d)) should be inserted in result(res) vector.\\n                    // b will only get updated if there is an overlap \\n                    // so as to merge maximum number of intervals\\n                    b=max(b,d);\\n                    // i pointer should now point to the pair pointed by j \\n                    // and in next iteration of j loop, j will point to the \\n                    // pair next to the one pointed by this i\\n                    i=j;\\n                }\\n            } \\n            res.push_back({a,b});\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Optimal Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Optimal Solution Time O(NlogN) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res; // result vector\\n        // insert the first element into the result vector\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<len;i++){\\n            if(res.back()[1]>=intervals[i][0])\\n                // back() points to the final element of the vector.\\n                // Update the endpoint of final element of result \\n                // vector if there is an overlap with intervals[i]\\n                res.back()[1]=max(res.back()[1], intervals[i][1]);\\n            else\\n                // If no overlap, insert intervals[i]\\n                res.push_back(intervals[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Brute Force Solution Time O(N^2) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end()); // Time taken by sort() is O(NlogN)\\n        vector<vector<int>> res;\\n        for(int i=0;i<len;i++){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            // for loop inside for loop takes time of O(N^2)\\n            for(int j=i+1;j<len;j++){\\n                int c=intervals[j][0];\\n                int d=intervals[j][1];\\n                if(b>=c){ \\n                    // Comparing pairs : (a,b) & (c,d)\\n                    // Interval overlap condition example - a=3,b=7,c=5,d=9\\n                    //  Real Line---a(3)------c(5)******b(7)-------d(9)----\\n                    // (a,max(b,d)) should be inserted in result(res) vector.\\n                    // b will only get updated if there is an overlap \\n                    // so as to merge maximum number of intervals\\n                    b=max(b,d);\\n                    // i pointer should now point to the pair pointed by j \\n                    // and in next iteration of j loop, j will point to the \\n                    // pair next to the one pointed by this i\\n                    i=j;\\n                }\\n            } \\n            res.push_back({a,b});\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // Optimal Solution Time O(NlogN) & Auxiliary Space O(1)\\n        int len=intervals.size();\\n        if(len<=1)\\n            return intervals;\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res; // result vector\\n        // insert the first element into the result vector\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<len;i++){\\n            if(res.back()[1]>=intervals[i][0])\\n                // back() points to the final element of the vector.\\n                // Update the endpoint of final element of result \\n                // vector if there is an overlap with intervals[i]\\n                res.back()[1]=max(res.back()[1], intervals[i][1]);\\n            else\\n                // If no overlap, insert intervals[i]\\n                res.push_back(intervals[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200549,
                "title": "faster-than-99-86-c-submissions-with-explanation",
                "content": "```\\n// There can be three cases with two intervals \\n// Casee 1:- No overlap\\n\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n\\n//  _______________\\n// | left interval |\\n// |_______________|\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // Sort the intervals so that the comparison between two intervals becomes easier \\n        sort(v.begin(),v.end());\\n        int n=v.size(),left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n        while(left<n && right<n)\\n        {\\n            // Case 1(No overlap so proceed)\\n            if(v[left][1]<v[right][0])\\n            {\\n                left=right;\\n                right++;\\n            }\\n            // Else overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                // Case 3(Full overlap)\\n                if(v[left][1]>=v[right][1])\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2(partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        // Now we\\'ll traverse the intervals again and populate the ans vector i.e the result vector\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        // Finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n// There can be three cases with two intervals \\n// Casee 1:- No overlap\\n\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n\\n//  _______________\\n// | left interval |\\n// |_______________|\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // Sort the intervals so that the comparison between two intervals becomes easier \\n        sort(v.begin(),v.end());\\n        int n=v.size(),left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n        while(left<n && right<n)\\n        {\\n            // Case 1(No overlap so proceed)\\n            if(v[left][1]<v[right][0])\\n            {\\n                left=right;\\n                right++;\\n            }\\n            // Else overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                // Case 3(Full overlap)\\n                if(v[left][1]>=v[right][1])\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2(partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        // Now we\\'ll traverse the intervals again and populate the ans vector i.e the result vector\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        // Finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733718,
                "title": "python-using-start-and-end-easy-to-understand",
                "content": "Instead of using start and end use [0] and [1]. It works\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: \\n            return []\\n        intervals.sort() #sort the list according to start index\\n        stack = [intervals[0]] #push the first element into the stack\\n        for current in intervals[1:]:\\n            if current[0] <= stack[-1][1]: #if the start of current element is less than or equal to the end of top element of stack then set\\n                #stack top element end = max( current end, stack top end)\\n                stack[-1][1] = max(current[1], stack[-1][1])\\n            else: \\n                #else append the current element into stack\\n                stack.append(current)\\n        return stack\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0: \\n            return []\\n        intervals.sort() #sort the list according to start index\\n        stack = [intervals[0]] #push the first element into the stack\\n        for current in intervals[1:]:\\n            if current[0] <= stack[-1][1]: #if the start of current element is less than or equal to the end of top element of stack then set\\n                #stack top element end = max( current end, stack top end)\\n                stack[-1][1] = max(current[1], stack[-1][1])\\n            else: \\n                #else append the current element into stack\\n                stack.append(current)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683624,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        if (intervals == null || intervals.Length == 0 || intervals.Length == 1)\\n            return intervals;\\n        \\n        List<int[]> res = new List<int[]>();\\n        \\n        intervals = intervals.OrderBy(x => x[0]).ToArray();\\n        \\n        int s = intervals[0][0],\\n            e = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.Length; i++)\\n            if (intervals[i][0] > e)\\n            {\\n                res.Add(new int[] { s, e });\\n                s = intervals[i][0];\\n                e = intervals[i][1];\\n            }\\n            else\\n                e = Math.Max(e, intervals[i][1]);\\n        \\n        res.Add(new int[] { s, e });\\n        \\n        return res.ToArray();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        if (intervals == null || intervals.Length == 0 || intervals.Length == 1)\\n            return intervals;\\n        \\n        List<int[]> res = new List<int[]>();\\n        \\n        intervals = intervals.OrderBy(x => x[0]).ToArray();\\n        \\n        int s = intervals[0][0],\\n            e = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.Length; i++)\\n            if (intervals[i][0] > e)\\n            {\\n                res.Add(new int[] { s, e }",
                "codeTag": "Java"
            },
            {
                "id": 3462073,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 158 videos for leetcode questions as of April 28, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\n\\nhttps://youtu.be/IuzSG0YEdXU\\n\\n---\\n\\n# Intuition\\nSort intervals with start points. It takes advantage of the fact that the intervals are sorted by start point, which allows us to avoid comparing every interval to every other interval.\\n\\n# Approach\\nThis is based on Python code. Other languages might be different.\\n\\n1. The merge method takes a list of lists as an argument. Each inner list represents an interval, and the first element of the inner list is the start point, and the second element is the end point.\\n\\n2. Check if the given list is empty, if yes, return an empty list.\\n\\n3. Initialize an empty list named merged to store the merged intervals.\\n\\n4. Sort the given list of intervals by the first element of each interval using the sort method and a lambda function.\\n\\n5. Set the variable prev to the first interval of the sorted intervals list.\\n\\n6. Iterate over the sorted intervals list, starting from the second interval.\\n\\n7. Check if the start point of the current interval is less than or equal to the end point of the previous interval.\\n\\n8. If yes, then update the end point of the previous interval with the maximum of the current interval\\'s end point and the previous interval\\'s end point.\\n9. If no, then append the previous interval to the merged list and set prev to the current interval.\\n\\n10. After the loop, append the last interval (prev) to the merged list.\\nReturn the merged list containing the merged intervals.\\n\\n# Complexity\\nThis is based on Python code. Other languages might be different.\\n\\n- Time complexity: O(n log n)\\nn is the length of the input list \\'intervals\\'. This is because the code sorts the intervals list in O(n log n) time using the built-in Python sorting algorithm, and then iterates over the sorted list once in O(n) time to merge overlapping intervals.\\n\\n- Space complexity: O(n)\\nn is the length of the input list \\'intervals\\'. This is because the code creates a new list \\'merged\\' to store the merged intervals, which can contain up to n elements if there are no overlapping intervals. Additionally, the code uses a constant amount of space to store the \\'prev\\' variable and other temporary variables, which does not depend on the size of the input.\\n\\n---\\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n---\\n\\n# Python\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        merged = []\\n        intervals.sort(key=lambda x: x[0])\\n\\n        prev = intervals[0]\\n\\n        for interval in intervals[1:]:\\n            if interval[0] <= prev[1]:\\n                prev[1] = max(prev[1], interval[1])\\n            else:\\n                merged.append(prev)\\n                prev = interval\\n        \\n        merged.append(prev)\\n\\n        return merged\\n```\\n# JavaScript\\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    if (!intervals || intervals.length === 0) {\\n        return [];\\n    }\\n\\n    let merged = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    let mergedInterval = intervals[0];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n\\n        if (interval[0] <= mergedInterval[1]) {\\n            mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n        } else {\\n            merged.push(mergedInterval);\\n            mergedInterval = interval;\\n        }\\n    }\\n\\n    merged.push(mergedInterval);\\n\\n    return merged;    \\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0) {\\n            return new int[0][];\\n        }\\n\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        List<int[]> merged = new ArrayList<>();\\n        int[] mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.add(mergedInterval);\\n                mergedInterval = interval; \\n            }\\n        }\\n\\n        merged.add(mergedInterval);\\n\\n        return merged.toArray(new int[merged.size()][]);        \\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) {\\n            return {};\\n        }\\n\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        vector<vector<int>> merged;\\n        vector<int> mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            const vector<int>& interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.push_back(mergedInterval);\\n                mergedInterval = interval;\\n            }\\n        }\\n\\n        merged.push_back(mergedInterval);\\n\\n        return merged;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if not intervals:\\n            return []\\n        \\n        merged = []\\n        intervals.sort(key=lambda x: x[0])\\n\\n        prev = intervals[0]\\n\\n        for interval in intervals[1:]:\\n            if interval[0] <= prev[1]:\\n                prev[1] = max(prev[1], interval[1])\\n            else:\\n                merged.append(prev)\\n                prev = interval\\n        \\n        merged.append(prev)\\n\\n        return merged\\n```\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    if (!intervals || intervals.length === 0) {\\n        return [];\\n    }\\n\\n    let merged = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    let mergedInterval = intervals[0];\\n\\n    for (let i = 1; i < intervals.length; i++) {\\n        let interval = intervals[i];\\n\\n        if (interval[0] <= mergedInterval[1]) {\\n            mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n        } else {\\n            merged.push(mergedInterval);\\n            mergedInterval = interval;\\n        }\\n    }\\n\\n    merged.push(mergedInterval);\\n\\n    return merged;    \\n};\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0) {\\n            return new int[0][];\\n        }\\n\\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\\n\\n        List<int[]> merged = new ArrayList<>();\\n        int[] mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.length; i++) {\\n            int[] interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = Math.max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.add(mergedInterval);\\n                mergedInterval = interval; \\n            }\\n        }\\n\\n        merged.add(mergedInterval);\\n\\n        return merged.toArray(new int[merged.size()][]);        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if (intervals.empty()) {\\n            return {};\\n        }\\n\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        vector<vector<int>> merged;\\n        vector<int> mergedInterval = intervals[0];\\n\\n        for (int i = 1; i < intervals.size(); i++) {\\n            const vector<int>& interval = intervals[i];\\n            \\n            if (interval[0] <= mergedInterval[1]) {\\n                mergedInterval[1] = max(mergedInterval[1], interval[1]);\\n            } else {\\n                merged.push_back(mergedInterval);\\n                mergedInterval = interval;\\n            }\\n        }\\n\\n        merged.push_back(mergedInterval);\\n\\n        return merged;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319024,
                "title": "98-96-super-easy-understand-javascript-solution-with-explains",
                "content": "```\\nvar merge = function(intervals) {\\n    if(intervals.length < 2) return intervals; \\n    intervals.sort((a,b) => a[0] - b[0]) //Arr have smaller element come first\\n    for(let i = 1; i < intervals.length; i += 1){\\n        curr = intervals[i];\\n        prev = intervals[i-1];\\n        if(curr[0] <= prev[1]){\\n            intervals[i] = [Math.min(prev[0],curr[0]), Math.max(prev[1],curr[1])]\\n            intervals.splice(i-1,1);\\n            i -= 1  // After merge, the arr become shorter\\n        }\\n    }\\n    return intervals\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    if(intervals.length < 2) return intervals; \\n    intervals.sort((a,b) => a[0] - b[0]) //Arr have smaller element come first\\n    for(let i = 1; i < intervals.length; i += 1){\\n        curr = intervals[i];\\n        prev = intervals[i-1];\\n        if(curr[0] <= prev[1]){\\n            intervals[i] = [Math.min(prev[0],curr[0]), Math.max(prev[1],curr[1])]\\n            intervals.splice(i-1,1);\\n            i -= 1  // After merge, the arr become shorter\\n        }\\n    }\\n    return intervals\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287714,
                "title": "new-c-solution-o-nlogn-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comparator( vector<int>& a, vector<int>& b )\\n    {\\n        return a[0] < b[0];\\n    }\\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        //Handle Edge cases\\n        if( intervals.empty() )\\n        {\\n            return res;\\n        }\\n        \\n        if( intervals.size() == 1 )\\n        {\\n            res.push_back( intervals[0]);\\n            return res;\\n        }\\n        \\n        //Sort the inetrvals first based on the start of interval\\n        sort( intervals.begin(), intervals.end(), comparator );\\n        \\n        //Push the first interval into the result\\n        res.push_back( intervals[0] );\\n        int i = 1;\\n        while( i < intervals.size() )\\n        {\\n            vector<int>& last = res.back();\\n            //Check for overlapping boundaries in the intervals and merge them suitably\\n            if( last[1] < intervals[i][0] )\\n            {\\n                res.push_back( intervals[i] );\\n            }\\n            else\\n            {\\n                last[1] = max( last[1], intervals[i][1] );\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comparator( vector<int>& a, vector<int>& b )\\n    {\\n        return a[0] < b[0];\\n    }\\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        //Handle Edge cases\\n        if( intervals.empty() )\\n        {\\n            return res;\\n        }\\n        \\n        if( intervals.size() == 1 )\\n        {\\n            res.push_back( intervals[0]);\\n            return res;\\n        }\\n        \\n        //Sort the inetrvals first based on the start of interval\\n        sort( intervals.begin(), intervals.end(), comparator );\\n        \\n        //Push the first interval into the result\\n        res.push_back( intervals[0] );\\n        int i = 1;\\n        while( i < intervals.size() )\\n        {\\n            vector<int>& last = res.back();\\n            //Check for overlapping boundaries in the intervals and merge them suitably\\n            if( last[1] < intervals[i][0] )\\n            {\\n                res.push_back( intervals[i] );\\n            }\\n            else\\n            {\\n                last[1] = max( last[1], intervals[i][1] );\\n            }\\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780416,
                "title": "c-100-east-9-lines-code-o-nlogn",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat we are going to do is first we will push the first interval in the vector and will iterate over all the other intervals in the array.\\n\\nconsidering each interval[a,b] in the array we will check if the start of the interval is smaller than the end of the last interval[x,y] present in our vector i.e. y>a\\nif it is so then we will update the end value we will update the end value y with max(y,b)\\n\\nif y!>a then we will simply push the interval in the vector\\n\\nfollow the same steps for rest of the array elements and return the vector after reaching at the end\\n\\n\\n# Dry Run:\\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\\n1 ) push(1,3) int the ans vector\\n\\n2 ) check if end point of the last interval present in the ans vector is greater than the start point of the next interval  if(ans.back()[1] >= intervals[i][0]) i.e. if(3>=2) ...if yes then update the end point of the last interval of the vector..ans.back()[1] = max(ans.back()[1] , intervals[i][1]);   i.e max(3,6)\\nnow out vector ans = {(1,6)}\\n\\nif(ans.back()[1] >= intervals[i][0]) is now true then simply push that element int ans vector\\n\\n3)follow step 2 for all other elements of interval array and return ans at the end of the program\\n\\n\\n\\n# Code\\n```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\\n    {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(ans.back()[1] >= intervals[i][0]) ans.back()[1] = max(ans.back()[1] , intervals[i][1]);\\n            else ans.push_back(intervals[i]); \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\\n    {\\n        if(intervals.size()<=1) return intervals;\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(ans.back()[1] >= intervals[i][0]) ans.back()[1] = max(ans.back()[1] , intervals[i][1]);\\n            else ans.push_back(intervals[i]); \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558586,
                "title": "best-and-simple-c-solution",
                "content": "Just take two pointers \"**start**\" and \"**end**\" pointing to the first index.\\nIterate through the vector:\\n\\t1. Update the **end** if the current index can merge with the \"**start**\" and \"**end**\" else\\n\\t2. Push the {start, end} into the answer, and make \"**start**\" and \"**end**\" pointing to current index.\\n\\n```\\nvector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        sort(v.begin(), v.end());\\t\\t\\n        int start = v[0][0];\\n        int end = v[0][1];        \\n\\t\\tvector<vector<int>> ans;\\n        \\n\\t\\tfor(int i=1;i<v.size();i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][0] <= end)\\n            {\\n                end = max(end, v[i][1]);\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        sort(v.begin(), v.end());\\t\\t\\n        int start = v[0][0];\\n        int end = v[0][1];        \\n\\t\\tvector<vector<int>> ans;\\n        \\n\\t\\tfor(int i=1;i<v.size();i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][0] <= end)\\n            {\\n                end = max(end, v[i][1]);\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349104,
                "title": "c-o-n-log-n-sort-by-start-time-and-merge-intervals",
                "content": "``` csharp\\nclass Interval\\n{\\n    public readonly int Start;\\n    public readonly int End;\\n    \\n    public Interval(int start, int end)\\n    {\\n        Start = start;\\n        End = end;\\n    }\\n}\\n\\npublic class Solution \\n{\\n    public int[][] Merge(int[][] input) \\n    {\\n        if(input == null || input.GetLength(0) <= 1)\\n        {\\n            return input;\\n        }\\n        \\n        List<Interval> intervals = new List<Interval>();\\n        List<int[]> result = new List<int[]>();\\n        \\n        for(int i = 0; i < input.GetLength(0); i++)\\n        {\\n            intervals.Add(new Interval(input[i][0], input[i][1]));\\n        }\\n        \\n        intervals = intervals.OrderBy(x => x.Start).ThenBy(x => x.End).ToList();\\n        \\n        int start = 0;\\n        int end = 0;        \\n        int j = 0;\\n        \\n        while(j < intervals.Count)\\n        {\\n            start = intervals[j].Start;\\n            end = intervals[j].End;\\n            j++;\\n            \\n            while(j < intervals.Count && intervals[j].Start <= end)\\n            {\\n                end = Math.Max(end, intervals[j].End);   \\n                j++;\\n            }       \\n            result.Add(new int[] { start, end});           \\n        }                \\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "``` csharp\\nclass Interval\\n{\\n    public readonly int Start;\\n    public readonly int End;\\n    \\n    public Interval(int start, int end)\\n    {\\n        Start = start;\\n        End = end;\\n    }\\n}\\n\\npublic class Solution \\n{\\n    public int[][] Merge(int[][] input) \\n    {\\n        if(input == null || input.GetLength(0) <= 1)\\n        {\\n            return input;\\n        }\\n        \\n        List<Interval> intervals = new List<Interval>();\\n        List<int[]> result = new List<int[]>();\\n        \\n        for(int i = 0; i < input.GetLength(0); i++)\\n        {\\n            intervals.Add(new Interval(input[i][0], input[i][1]));\\n        }\\n        \\n        intervals = intervals.OrderBy(x => x.Start).ThenBy(x => x.End).ToList();\\n        \\n        int start = 0;\\n        int end = 0;        \\n        int j = 0;\\n        \\n        while(j < intervals.Count)\\n        {\\n            start = intervals[j].Start;\\n            end = intervals[j].End;\\n            j++;\\n            \\n            while(j < intervals.Count && intervals[j].Start <= end)\\n            {\\n                end = Math.Max(end, intervals[j].End);   \\n                j++;\\n            }       \\n            result.Add(new int[] { start, end});           \\n        }                \\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1651683,
                "title": "solution-swift-merge-intervals",
                "content": "```swift\\nclass Solution {\\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        \\n        let sorted = intervals.sorted(by: {$0[0] < $1[0]})\\n        guard let first = sorted.first else { return [[Int]]() }\\n\\n        var merged = [first]\\n        \\n        for current in sorted {\\n            guard let last = merged.last else { continue }\\n\\n            let prev = last[0]\\n            let penult = last[1]\\n            \\n            let start = current[0], end = current[1]\\n            \\n            if penult >= start {\\n                merged[merged.count - 1] = [prev, max(penult, end)]\\n            } else {\\n                merged.append(current)\\n            }\\n        }\\n        return merged\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        \\n        let sorted = intervals.sorted(by: {$0[0] < $1[0]})\\n        guard let first = sorted.first else { return [[Int]]() }\\n\\n        var merged = [first]\\n        \\n        for current in sorted {\\n            guard let last = merged.last else { continue }\\n\\n            let prev = last[0]\\n            let penult = last[1]\\n            \\n            let start = current[0], end = current[1]\\n            \\n            if penult >= start {\\n                merged[merged.count - 1] = [prev, max(penult, end)]\\n            } else {\\n                merged.append(current)\\n            }\\n        }\\n        return merged\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325159,
                "title": "c-solution-with-easy-complete-explaination",
                "content": "**Time complexity - O(n logn) + O(n)**  \\n **space complexity - O(n)** \\n \\n steps:\\n 1. sort the given intervals on the basis of the starting point \\n    suppose- [3,5] 3 is the starting point(0) and  5 is the ending point(1) \\n2. After sorting there will be 3 cases coming up:\\n   case 1:\\n   If there is no overlapping in the intervals. in this take the max of the       ending points\\n   case 2:\\n   if there is partial overapping\\n   case 3 : \\n   when there is no overlapping\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n            \\n        vector<vector<int>> mergedIntervals;\\n        if(intervals.size()==0)\\n            return mergedIntervals;\\n        \\n        sort(intervals.begin(),intervals.end());// sort\\n        vector<int> pre_interval = intervals[0];\\n        // 0 is starting point\\n        //1 is ending point\\n        \\n        for(auto interval:intervals)\\n        {\\n            if(interval[0]<=pre_interval[1])// means there is overlapping of intervals\\n            {\\n                pre_interval[1]=max(interval[1],pre_interval[1]); // need to check which has max ending points hence we will make ending point of pre_interval to max\\n            }\\n            else\\n            { // if there is no overlapping\\n                mergedIntervals.push_back(pre_interval); // simplely push pre-interval to mergedintervals vector\\n                pre_interval=interval;\\n            }     \\n        }\\n        \\n        mergedIntervals.push_back(pre_interval);\\n        return mergedIntervals;\\n    }\\n};\\n```\\n***Please upvote if you like the solution and comment if have doubts***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n            \\n        vector<vector<int>> mergedIntervals;\\n        if(intervals.size()==0)\\n            return mergedIntervals;\\n        \\n        sort(intervals.begin(),intervals.end());// sort\\n        vector<int> pre_interval = intervals[0];\\n        // 0 is starting point\\n        //1 is ending point\\n        \\n        for(auto interval:intervals)\\n        {\\n            if(interval[0]<=pre_interval[1])// means there is overlapping of intervals\\n            {\\n                pre_interval[1]=max(interval[1],pre_interval[1]); // need to check which has max ending points hence we will make ending point of pre_interval to max\\n            }\\n            else\\n            { // if there is no overlapping\\n                mergedIntervals.push_back(pre_interval); // simplely push pre-interval to mergedintervals vector\\n                pre_interval=interval;\\n            }     \\n        }\\n        \\n        mergedIntervals.push_back(pre_interval);\\n        return mergedIntervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186514,
                "title": "python3-line-sweep-for-merge-interval-and-employee-free-time",
                "content": "`Merge Interval` and `Employee Free Time` are opposite to each other. \\nThe former computes the `occupied time`; the latter computes the `free time`. \\n\\nBoth questions can be solved using line-sweep method. \\n\\nSuppose `schedule = [[1,3],[6,7],[2,4],[2,5],[9,12]]`, \\nwe can represent it as a sorted array: `1( 2( 2( 3) 4) 5) 6( 7) 9( 12)`\\nIgnoring numbers, we have a schedule structure like `((())),(),()`\\nThe merged interval would be `(--),(--),(--)`\\nThe free time would be `(),--(),--()`\\n\\n``` python\\n\"\"\" Merge Interval\"\"\"\\nclass Solution:\\n    def merge(self, intervals):        \\n        START, END = 0, 1   # open first at same time\\n        events = []\\n        for iv in intervals:\\n            events.append((iv.start, START))\\n            events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        for i, (t, ev) in enumerate(events):\\n            if balance == 0: prev = t\\n            balance += (1 if ev == START else -1)\\n            if balance == 0: res.append(Interval(prev, t))\\n                \\n        return res\\n```\\n\\n``` python\\n\"\"\" Free Time\"\"\"\\nclass Solution:\\n    def employeeFreeTime(self, schedule):\\n        START, END = 0, 1    # open first at same time\\n        events = []\\n        for emp in schedule:\\n            for iv in emp:\\n                events.append((iv.start, START))\\n                events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        prev = None\\n        for t, event in events:\\n            if balance == 0 and prev is not None: res.append(Interval(prev, t))\\n            balance += (1 if event == START else -1)\\n            if balance == 0: prev = t\\n        return res\\n```",
                "solutionTags": [],
                "code": "``` python\\n\"\"\" Merge Interval\"\"\"\\nclass Solution:\\n    def merge(self, intervals):        \\n        START, END = 0, 1   # open first at same time\\n        events = []\\n        for iv in intervals:\\n            events.append((iv.start, START))\\n            events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        for i, (t, ev) in enumerate(events):\\n            if balance == 0: prev = t\\n            balance += (1 if ev == START else -1)\\n            if balance == 0: res.append(Interval(prev, t))\\n                \\n        return res\\n```\n``` python\\n\"\"\" Free Time\"\"\"\\nclass Solution:\\n    def employeeFreeTime(self, schedule):\\n        START, END = 0, 1    # open first at same time\\n        events = []\\n        for emp in schedule:\\n            for iv in emp:\\n                events.append((iv.start, START))\\n                events.append((iv.end, END))\\n        events.sort()\\n\\n        res = []\\n        balance = 0\\n        prev = None\\n        for t, event in events:\\n            if balance == 0 and prev is not None: res.append(Interval(prev, t))\\n            balance += (1 if event == START else -1)\\n            if balance == 0: prev = t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520772,
                "title": "c-java-python-javascript-array-tc-o-n-log-n-easy-to-understand-solution",
                "content": "# Intuition:\\nThe idea is to sort the intervals by their start time, and then merge them by checking if the end time of the previous interval is greater than or equal to the start time of the current interval. If so, we merge the intervals by updating the end time of the previous interval to be the maximum of its current end time and the end time of the current interval. Otherwise, we add the previous interval to the answer vector and update the previous interval to be the current interval.\\n\\n# Approach:\\n1. Sort the intervals based on their start time.\\n2. Initialize an empty vector of vectors to store the merged intervals.\\n3. Initialize a temporary vector to store the first interval from the sorted input vector.\\n4. Iterate over the input intervals from the second interval.\\n5. If the start time of the current interval is less than or equal to the end time of the temporary interval, update the end time of the temporary interval to be the maximum of its current end time and the end time of the current interval.\\n6. Otherwise, add the temporary interval to the answer vector and update the temporary interval to be the current interval.\\n7. After the loop, add the last temporary interval to the answer vector.\\n8. Return the answer vector.\\n# Complexity:\\n- Time Complexity:\\nThe time complexity of this approach is O(n log n) due to the sorting operation, where n is the number of intervals. The for loop takes O(n) time to iterate over all intervals, and the inner operations take constant time.\\n\\n- Space Complexity:\\nThe space complexity of this approach is O(n) to store the answer vector and the temporary vector.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        if(intervals.size()==0){\\n            return ans;\\n        }\\n        vector <int> temp = intervals[0];\\n        for(int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]<=temp[1]){\\n                temp[1]=max(temp[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(temp);\\n                temp=intervals[i];\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\\n---\\n# Java\\n```java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> ans = new ArrayList<>();\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n\\n        if (intervals.length == 0) {\\n            return ans.toArray(new int[0][]);\\n        }\\n\\n        int[] temp = intervals[0];\\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][0] <= temp[1]) {\\n                temp[1] = Math.max(temp[1], intervals[i][1]);\\n            } else {\\n                ans.add(temp);\\n                temp = intervals[i];\\n            }\\n        }\\n        ans.add(temp);\\n\\n        return ans.toArray(new int[0][]);\\n    }\\n}\\n```\\n---\\n# Python\\n```py\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        intervals.sort()\\n\\n        if len(intervals) == 0:\\n            return ans\\n\\n        temp = intervals[0]\\n        for interval in intervals:\\n            if interval[0] <= temp[1]:\\n                temp[1] = max(temp[1], interval[1])\\n            else:\\n                ans.append(temp)\\n                temp = interval\\n        ans.append(temp)\\n\\n        return ans\\n\\n```\\n---\\n# JavaScript\\n```js\\nvar merge = function(intervals) {\\n    let ans = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    if (intervals.length === 0) {\\n        return ans;\\n    }\\n\\n    let temp = intervals[0];\\n    for (let i = 0; i < intervals.length; i++) {\\n        if (intervals[i][0] <= temp[1]) {\\n            temp[1] = Math.max(temp[1], intervals[i][1]);\\n        } else {\\n            ans.push(temp);\\n            temp = intervals[i];\\n        }\\n    }\\n    ans.push(temp);\\n\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        if(intervals.size()==0){\\n            return ans;\\n        }\\n        vector <int> temp = intervals[0];\\n        for(int i=0;i<intervals.size();i++){\\n            if(intervals[i][0]<=temp[1]){\\n                temp[1]=max(temp[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(temp);\\n                temp=intervals[i];\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> ans = new ArrayList<>();\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n\\n        if (intervals.length == 0) {\\n            return ans.toArray(new int[0][]);\\n        }\\n\\n        int[] temp = intervals[0];\\n        for (int i = 0; i < intervals.length; i++) {\\n            if (intervals[i][0] <= temp[1]) {\\n                temp[1] = Math.max(temp[1], intervals[i][1]);\\n            } else {\\n                ans.add(temp);\\n                temp = intervals[i];\\n            }\\n        }\\n        ans.add(temp);\\n\\n        return ans.toArray(new int[0][]);\\n    }\\n}\\n```\n```py\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        intervals.sort()\\n\\n        if len(intervals) == 0:\\n            return ans\\n\\n        temp = intervals[0]\\n        for interval in intervals:\\n            if interval[0] <= temp[1]:\\n                temp[1] = max(temp[1], interval[1])\\n            else:\\n                ans.append(temp)\\n                temp = interval\\n        ans.append(temp)\\n\\n        return ans\\n\\n```\n```js\\nvar merge = function(intervals) {\\n    let ans = [];\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\n    if (intervals.length === 0) {\\n        return ans;\\n    }\\n\\n    let temp = intervals[0];\\n    for (let i = 0; i < intervals.length; i++) {\\n        if (intervals[i][0] <= temp[1]) {\\n            temp[1] = Math.max(temp[1], intervals[i][1]);\\n        } else {\\n            ans.push(temp);\\n            temp = intervals[i];\\n        }\\n    }\\n    ans.push(temp);\\n\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454316,
                "title": "java-treemap-simple-solution-with-explanation",
                "content": "The idea is to use both starts and ends as keys, but +1 for a start and -1 for an end as values. So, going by sorted keys and gathering sum of values we will know for sure when current interval finishes (we have + 1 at start and -1 at finish -> 0 when interval finishes). \\nIn case of overlaps starts will sum up (3 starts crossed -> 3) and eventually at the last finish(3 finishes crossed -> 3 -3 = 0) it became 0 nevertheless. \\n\\nComplexity is n(log(n)) due to the nature of tree map.\\n\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> list = new LinkedList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] interval : intervals) {\\n            map.put(interval[0], map.getOrDefault(interval[0], 0) + 1);\\n            map.put(interval[1], map.getOrDefault(interval[1], 0) - 1);\\n        }\\n        \\n        int activeInterval = 0;\\n        int start = 0;\\n        for (int key: map.keySet()) {\\n            if (activeInterval == 0) {\\n                start = key;\\n            }    \\n            activeInterval += map.get(key);\\n            if (activeInterval == 0) {\\n                list.add(new int[]{start, key});\\n            }\\n        }\\n        \\n        return listToArray(list);\\n    }\\n    \\n    private int[][] listToArray(List<int[]> list) {\\n        int[][] result = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            result[i] = list.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> list = new LinkedList<>();\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        \\n        for (int[] interval : intervals) {\\n            map.put(interval[0], map.getOrDefault(interval[0], 0) + 1);\\n            map.put(interval[1], map.getOrDefault(interval[1], 0) - 1);\\n        }\\n        \\n        int activeInterval = 0;\\n        int start = 0;\\n        for (int key: map.keySet()) {\\n            if (activeInterval == 0) {\\n                start = key;\\n            }    \\n            activeInterval += map.get(key);\\n            if (activeInterval == 0) {\\n                list.add(new int[]{start, key});\\n            }\\n        }\\n        \\n        return listToArray(list);\\n    }\\n    \\n    private int[][] listToArray(List<int[]> list) {\\n        int[][] result = new int[list.size()][2];\\n        for (int i = 0; i < list.size(); i++) {\\n            result[i] = list.get(i);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438042,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n\\t\\t\\treturn intervals;\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n\\t\\tfor (int[] interval : intervals) {\\n            // if list is empty or does not overlap with the previous, just append\\n            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {\\n                result.add(interval);\\n            } else {\\n                // if overlap, merge the current and previous intervals\\n                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);\\n            }\\n\\t\\t}\\n\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n\\t\\t\\treturn intervals;\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n\\t\\tfor (int[] interval : intervals) {\\n            // if list is empty or does not overlap with the previous, just append\\n            if (result.isEmpty() || result.get(result.size() - 1)[1] < interval[0]) {\\n                result.add(interval);\\n            } else {\\n                // if overlap, merge the current and previous intervals\\n                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);\\n            }\\n\\t\\t}\\n\\n\\t\\treturn result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928341,
                "title": "easy-js-solution",
                "content": "```\\nvar merge = function(intervals) {\\n    if (intervals.length == 0) return [];\\n    \\n    intervals.sort((a,b) => a[0] - b[0]);\\n    let stack = [];\\n    stack.push(intervals[0]);\\n    \\n    for (let i = 1; i < intervals.length; i++) {\\n        let prev = stack.pop();\\n        let cur = intervals[i];\\n        if (prev[1] >= cur[0]) {\\n            stack.push( [prev[0], Math.max(prev[1], cur[1])] );\\n        } else {\\n            stack.push(prev, cur);\\n        }\\n    }\\n    \\n    return stack;\\n    // Time Complexity: O(Nlog(N))\\n    // Space Complexity: O(N)\\n};\\n\\n// (1) [[1,3], [2,6]] => [[1,6]]\\n// (2) [[1,4],[2,3]] => [[1,4]]\\n// Two possible cases to perform merger:\\n// 1st case: we merge two arrays and obtain a bigger interval\\n// 2nd case: one array absorbs another array and the size doesn\\'t change.\\n// Therefore, to cover both cases, when we merge two arrays, we perform the following:\\n// [start of first arr, max(end of first arr, end of second arr)]\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    if (intervals.length == 0) return [];\\n    \\n    intervals.sort((a,b) => a[0] - b[0]);\\n    let stack = [];\\n    stack.push(intervals[0]);\\n    \\n    for (let i = 1; i < intervals.length; i++) {\\n        let prev = stack.pop();\\n        let cur = intervals[i];\\n        if (prev[1] >= cur[0]) {\\n            stack.push( [prev[0], Math.max(prev[1], cur[1])] );\\n        } else {\\n            stack.push(prev, cur);\\n        }\\n    }\\n    \\n    return stack;\\n    // Time Complexity: O(Nlog(N))\\n    // Space Complexity: O(N)\\n};\\n\\n// (1) [[1,3], [2,6]] => [[1,6]]\\n// (2) [[1,4],[2,3]] => [[1,4]]\\n// Two possible cases to perform merger:\\n// 1st case: we merge two arrays and obtain a bigger interval\\n// 2nd case: one array absorbs another array and the size doesn\\'t change.\\n// Therefore, to cover both cases, when we merge two arrays, we perform the following:\\n// [start of first arr, max(end of first arr, end of second arr)]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21560,
                "title": "fast-ana-simple-java-code",
                "content": "\\n The idea is to sort intervals based on start and iterate all itervals to merge them if:\\n\\n    curr.end >= iter.start\\n\\nThe time complexity is : sort nO(logn)+ merge: O(n) = nO(logn)\\n\\nNo Extra space except necessary result : )\\n\\n       public class Solution {\\n            public List<Interval> merge(List<Interval> intervals) {\\n                List<Interval> res = new LinkedList<Interval>();\\n                if(intervals.size()<2) return intervals;\\n                Collections.sort(intervals, new Comparator<Interval>() {\\n                @Override\\n                    public int compare(Interval o1, Interval o2) {\\n                        return o1.start-o2.start;\\n                    }\\n                });\\n                Interval curr = intervals.get(0);\\n                for(Interval iter: intervals) {\\n                    if(curr.end >= iter.start) {\\n                        curr.end = Math.max(curr.end,iter.end);\\n                    }else {\\n                        res.add(curr);\\n                        curr = iter;\\n                    }\\n                }\\n                res.add(curr);\\n                return res;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public List<Interval> merge(List<Interval> intervals) {\\n                List<Interval> res = new LinkedList<Interval>();\\n                if(intervals.size()<2) return intervals;\\n                Collections.sort(intervals, new Comparator<Interval>() {\\n                @Override\\n                    public int compare(Interval o1, Interval o2) {\\n                        return o1.start-o2.start;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3732852,
                "title": "most-optimal-solution-with-explanation-c-and-java-code",
                "content": "\\n\\n# Approach\\n- First, the intervals are sorted in ascending order based on their start times using the sort function. This is important for efficient merging.\\n\\n- A new vector called ans is created to store the merged intervals.\\n\\n- The solution iterates through each interval in the sorted intervals array.\\n\\n- If ans is empty or the start time of the current interval is greater than the end time of the last interval in ans, it means there is no overlap. In this case, the current interval is added to ans as a new non-overlapping interval.\\n\\n- If there is an overlap, the end time of the last interval in ans is updated to be the maximum of the current interval\\'s end time and the end time of the last interval in ans. This ensures that the merged interval covers the maximum range.\\n\\n- After iterating through all intervals, the function returns the ans vector, which contains the merged non-overlapping intervals.\\n\\nOverall, the solution works by sorting the intervals based on start times and then merging them iteratively, updating the end time as needed. This approach ensures that all overlapping intervals are merged, resulting in a set of non-overlapping intervals that cover the entire input array.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn + n)\\n\\n- Space complexity:\\nO(1). O(n) to store the answer\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for(int i = 0; i< intervals.size(); i++){\\n            if(ans.empty() || intervals[i][0]>ans.back()[1]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else {\\n                ans.back()[1] = max(intervals[i][1], ans.back()[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for (int[] interval : intervals) {\\n            if (ans.isEmpty() || interval[0] > ans.get(ans.size() - 1)[1]) {\\n                ans.add(interval);\\n            } else {\\n                ans.get(ans.size() - 1)[1] = Math.max(interval[1], ans.get(ans.size() - 1)[1]);\\n            }\\n        }\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for(int i = 0; i< intervals.size(); i++){\\n            if(ans.empty() || intervals[i][0]>ans.back()[1]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else {\\n                ans.back()[1] = max(intervals[i][1], ans.back()[1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\\n        List<int[]> ans = new ArrayList<>();\\n        \\n        for (int[] interval : intervals) {\\n            if (ans.isEmpty() || interval[0] > ans.get(ans.size() - 1)[1]) {\\n                ans.add(interval);\\n            } else {\\n                ans.get(ans.size() - 1)[1] = Math.max(interval[1], ans.get(ans.size() - 1)[1]);\\n            }\\n        }\\n        \\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311657,
                "title": "simplest-way-to-solve-easy-java-code-o-nlogn",
                "content": "class Solution {\\n\\n    public int[][] merge(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (o1,o2)->Integer.compare(o1[0],o2[0]));          //sort the array on the basis of first interval\\n        ArrayList<int[]> list = new ArrayList<>();                              //to store the merge intervals\\n        int start = intervals[0][0];                                            //initialize start and end by the interval of the first row\\n        int end = intervals[0][1];\\n        \\n        for(int i=1;i<intervals.length;i++){                    //initialize i by 1, zeorth index intervals  already stored in start & end\\n           int s = intervals[i][0];                             //now store the intervals to compare with the previous one\\n            int e = intervals[i][1];\\n            \\n            if(s<=end){                                         //Now compare if the start (s) interval is less than the previous end interval then \\n                end=Math.max(end,e);                            //merge them, means update our end by the greater value of the end interval\\n            }else{                                              //if not means that interval is not overlapping in the current interval               \\n                list.add(new int[]{start,end});                 //add that previous merged interval into list and update start & end by the current intervals\\n                start = s;\\n                end = e;\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});                         //Don\\'t forget to add the last updated interval\\n        \\n        // int[][] res = new int[list.size()][2];               //we have to return the ans int 2D array format, you can do this or can also return directly\\n        // int i=0;\\n        // for(int[] ans : list){\\n        //     res[i] = ans;\\n        //     i++;\\n        // }\\n        \\n        return list.toArray(new int[list.size()][2]);            //by using toArray in built function BOTH are correct!\\n    }\\n}\\n\\n***Note: Kindly Upvote this article, if you found it helpful. Thanks For Reading!!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[][] merge(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (o1,o2)->Integer.compare(o1[0],o2[0]));          //sort the array on the basis of first interval\\n        ArrayList<int[]> list = new ArrayList<>();                              //to store the merge intervals\\n        int start = intervals[0][0];                                            //initialize start and end by the interval of the first row\\n        int end = intervals[0][1];\\n        \\n        for(int i=1;i<intervals.length;i++){                    //initialize i by 1, zeorth index intervals  already stored in start & end\\n           int s = intervals[i][0];                             //now store the intervals to compare with the previous one\\n            int e = intervals[i][1];\\n            \\n            if(s<=end){                                         //Now compare if the start (s) interval is less than the previous end interval then \\n                end=Math.max(end,e);                            //merge them, means update our end by the greater value of the end interval\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1805268,
                "title": "go-clean-code-with-explanation-and-visual-10ms-100",
                "content": "Hello Gophers!\\n\\n\\n## [Problem: Merge Intervals](https://leetcode.com/problems/merge-intervals/)\\n\\n> Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\\n\\nWe want to merge all overlapping intervals, here is a quick example:\\n\\nParams: `[][]int{{x1, y1}, {x2, y2}, {x3, y3}}`  \\n```\\n|-----------|\\nx1          y1\\n     |-----------|\\n     x2          y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\\n\\nAs you can see, the two first intervals `{x1, y1}` and `{x2, y2}` are overlapping (`{x2, y1}`), so we need to merge them.\\n\\nResponse: `[][]int{{x1, y2}, {x3, y3}}`  \\n```\\n|----------------|\\nx1              y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\\n\\nThe goal is to have a slice (array) of non-overlapping intervals.\\n\\n### Constraints\\n\\n1. `1 <= intervals.length <= 104`\\n2. `intervals[i].length == 2`\\n3. `0 <= starti <= endi <= 104`\\n\\n\\n## Definitions\\n\\nAn interval `[x, y]` is \"overlapping\" with the interval `[a, b]` if `x` <= `b` && `y` >= `a` (or `y` >= `a` && `x` >= `b`):\\n\\n```\\n|-----------|           |          |-----------|\\nx           y           |          x           y \\n     |-----------|      |     |-----------| \\n     a           b      |     a           b \\n```\\n\\nAn interval `[x, y]` is \"completely overlapping\" with the interval `[a, b]` if `x` <= `a` && `y` >= `b`:\\n\\n```\\n|----------------|\\nx                y\\n     |-----|\\n     a     b\\n```\\n\\n\\n## Algorithm\\n\\nThe algorithm is simple, let\\'s say an interval has two items `{x, y}`:\\n1. Sort the slice (array) of intervals `intervals`\\n2. We create a new slice of intervals (from the first interval of `intervals`) nammed `mergedIntervals` (it will be the returned value)\\n3. We iterate on every items (except the first one) of the `intervals` slice (let\\'s call it `interval`)  \\nand we compare it with the last item of the `mergedIntervals` slice (let\\'s call it `top`)\\n\\t4. **If the `interval` \"completely overlap\" `top`**: change `interval` for `top`\\n\\t5. **Else if`interval` \"overlap\" (but not completely) `top`**: change the `y` value of `interval` for the `y` value of `top`\\n\\t6. **Else**: do nothing\\n\\n### Solution (code)\\n\\nTime: `O(nlogn)`\\nSpace: `O(n)`\\n\\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(n)\\nfunc merge(intervals [][]int) [][]int {\\n    if len(intervals) <= 1 {\\n        return intervals\\n    }\\n\\n\\t// Time: O(nlogn)\\n    sortIntervals(intervals)\\n    \\n\\t// Space: O(n)\\n    mergedIntervals := make([][]int, 0, len(intervals))\\n    mergedIntervals = append(mergedIntervals, intervals[0])\\n\\n\\t// Time: O(n)\\n    for _, interval := range intervals[1:] {        \\n        if top := mergedIntervals[len(mergedIntervals)-1]; interval[0] > top[1] {\\n            mergedIntervals = append(mergedIntervals, interval)\\n        } else if interval[1] > top[1] {\\n            top[1] = interval[1]\\n        }\\n    }\\n    \\n    return mergedIntervals\\n}\\n\\n// If an interval is {x, y},\\n// sortIntervals sorts the intervals by their \"x\" value.\\n// Time: O(nlogn)\\n// Space: O(1)\\nfunc sortIntervals(intervals [][]int) {\\n\\t// Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n}\\n```\\n\\n## Example\\n\\n`intervals`: `[][]int{{1, 4}, {0, 3}, {5, 7}, {1, 2}}`  \\n```\\n    |---------------|\\n    1               4\\n|--------------|\\n0              3\\n\\t                      |-----------|\\n                          5           7\\n    |------|\\n    1      2\\n```\\n\\n`intervals` sorted with `sortIntervals(...)`: `[][]int{{0, 3}, {1, 4}, {1, 2}, {5, 7}}`  \\n```\\n|--------------|\\n0              3\\n    |---------------|\\n    1               4\\n    |------|\\n    1      2\\n\\t                      |-----------|\\n                          5           7\\n```\\n\\n`mergedIntervals` creation with the first item of `intervals`: `[][]int{{0, 3}}`  \\n\\n```\\n|--------------|\\n0              3\\n```\\n\\n`mergedIntervals` after second `interval` `{1, 4}`: `[][]int{{0, 4}}`  (`{0, 3}` overlaps `{1, 4}`)\\n\\n```\\n|-------------------|\\n0                   4\\n```\\n\\n`mergedIntervals` after third `interval` `{1, 2}`: `[][]int{{0, 4}}`    (`{0, 4}` completely overlaps `{1, 4}`)\\n\\n```\\n|-------------------|\\n0                   4\\n```\\n\\n`mergedIntervals` after fourth `interval` `{5, 7}`: `[][]int{{0, 4}, {5, 7}}`   (no overlapping)\\n\\n```\\n|-------------------|\\n0                   4\\n\\t                      |-----------|\\n                          5           7\\n```\\n\\n## Follow-up\\n\\nA way to not have `O(n)` as space complexity would be to update the intervals sent in params (instead of creating a new one).\\n\\n## Similar Questions\\n\\n1. [[Medium] 56. Merge Intervals](https://leetcode.com/problems/merge-intervals/discuss/1805268/Go-Clean-Code-with-explanation-and-visual-(10ms-100)) **(this problem)**\\n2. [[Easy] 495. Teemo Attacking](https://leetcode.com/problems/teemo-attacking/discuss/1805603/Go-Clean-code-with-comments-(30ms-98))\\n3. [[Medium] 57. Insert Interval](https://leetcode.com/problems/insert-interval/discuss/1807161/Go-Clean-Code-with-visual-(1ms-100))\\n4. [[Medium] 986. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/discuss/1823039/Go-Clean-Code-with-explanation-and-visual-(10ms-100))\\n5. [[Easy] 252. Meeting Rooms](https://leetcode.com/problems/meeting-rooms/discuss/1512776/Go-Meeting-Rooms-Clean-solution)\\n6. [[Medium] 253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/1826838/Go-Multiple-Solutions-(0ms-100)) \\n7. [[Medium] 435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/discuss/1843676/Go-Clean-solution-(185ms-100))\\n8. [[Medium] 763. Partition Labels](https://leetcode.com/problems/partition-labels/discuss/2027004/Go-Merge-and-Sort-Intervals-0ms-(100))\\n9. [[Medium] Single-Threaded CPU](https://leetcode.com/problems/single-threaded-cpu/)\\n10. [[Hard] 759. Employee Free Time](https://leetcode.com/problems/employee-free-time/)\\n\\nI hope it helped! :)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n|-----------|\\nx1          y1\\n     |-----------|\\n     x2          y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\n```\\n|----------------|\\nx1              y2\\n\\t                    |-----------|\\n                        x3          y3\\n```\n```\\n|-----------|           |          |-----------|\\nx           y           |          x           y \\n     |-----------|      |     |-----------| \\n     a           b      |     a           b \\n```\n```\\n|----------------|\\nx                y\\n     |-----|\\n     a     b\\n```\n```go\\n// Time: O(nlogn + n) = O(nlogn)\\n// Space: O(n)\\nfunc merge(intervals [][]int) [][]int {\\n    if len(intervals) <= 1 {\\n        return intervals\\n    }\\n\\n\\t// Time: O(nlogn)\\n    sortIntervals(intervals)\\n    \\n\\t// Space: O(n)\\n    mergedIntervals := make([][]int, 0, len(intervals))\\n    mergedIntervals = append(mergedIntervals, intervals[0])\\n\\n\\t// Time: O(n)\\n    for _, interval := range intervals[1:] {        \\n        if top := mergedIntervals[len(mergedIntervals)-1]; interval[0] > top[1] {\\n            mergedIntervals = append(mergedIntervals, interval)\\n        } else if interval[1] > top[1] {\\n            top[1] = interval[1]\\n        }\\n    }\\n    \\n    return mergedIntervals\\n}\\n\\n// If an interval is {x, y},\\n// sortIntervals sorts the intervals by their \"x\" value.\\n// Time: O(nlogn)\\n// Space: O(1)\\nfunc sortIntervals(intervals [][]int) {\\n\\t// Time: O(nlogn)\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n}\\n```\n```\\n    |---------------|\\n    1               4\\n|--------------|\\n0              3\\n\\t                      |-----------|\\n                          5           7\\n    |------|\\n    1      2\\n```\n```\\n|--------------|\\n0              3\\n    |---------------|\\n    1               4\\n    |------|\\n    1      2\\n\\t                      |-----------|\\n                          5           7\\n```\n```\\n|--------------|\\n0              3\\n```\n```\\n|-------------------|\\n0                   4\\n```\n```\\n|-------------------|\\n0                   4\\n```\n```\\n|-------------------|\\n0                   4\\n\\t                      |-----------|\\n                          5           7\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912536,
                "title": "100-fastest-swift-solution-time-o-n-log-n-space-o-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(n)), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n    \\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [] }\\n        var intervals = intervals.sorted(by: { $0[0] < $1[0] })\\n        \\n        var ans = [[Int]]()\\n        var start = intervals[0][0]\\n        var end = intervals[0][1]\\n        \\n        for interval in intervals {\\n            guard end < interval[0] else {\\n                end = max(end, interval[1])\\n                continue\\n            }\\n            ans.append([start, end])\\n            start = interval[0]\\n            end = interval[1]\\n        }\\n        \\n        ans.append([start, end])\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(n)), where n is the number of intervals.\\n    //   - space: O(n), where n is the number of intervals.\\n    \\n    func merge(_ intervals: [[Int]]) -> [[Int]] {\\n        guard !intervals.isEmpty else { return [] }\\n        var intervals = intervals.sorted(by: { $0[0] < $1[0] })\\n        \\n        var ans = [[Int]]()\\n        var start = intervals[0][0]\\n        var end = intervals[0][1]\\n        \\n        for interval in intervals {\\n            guard end < interval[0] else {\\n                end = max(end, interval[1])\\n                continue\\n            }\\n            ans.append([start, end])\\n            start = interval[0]\\n            end = interval[1]\\n        }\\n        \\n        ans.append([start, end])\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810276,
                "title": "simple-java-solution",
                "content": "#### ***PLS UPVOTE :)***\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n        //declaring an array list to store the pairs\\n        ArrayList<int[]> list=new ArrayList<>();\\n        \\n        //sorting the given interval array based on starting point\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        \\n        //defining start and end point\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        \\n        //we will iterate through the 2d array intervals so in each iteration we will get a row[1D array] as i\\n        \\n        for(int[] i:intervals){\\n            //check if end point of 1st pair if greater than the starting point of the 2nd pair or not, basically we check it\\'s in overlapping condition or not\\n            \\n            if(i[0]<=end){\\n                end=Math.max(end,i[1]);\\n            }\\n            \\n            //otherwise add it in the list\\n            else{\\n                list.add(new int[]{start,end});\\n                start=i[0];\\n                end=i[1];\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});\\n        return list.toArray(new int[0][]);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        \\n        //declaring an array list to store the pairs\\n        ArrayList<int[]> list=new ArrayList<>();\\n        \\n        //sorting the given interval array based on starting point\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        \\n        //defining start and end point\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        \\n        //we will iterate through the 2d array intervals so in each iteration we will get a row[1D array] as i\\n        \\n        for(int[] i:intervals){\\n            //check if end point of 1st pair if greater than the starting point of the 2nd pair or not, basically we check it\\'s in overlapping condition or not\\n            \\n            if(i[0]<=end){\\n                end=Math.max(end,i[1]);\\n            }\\n            \\n            //otherwise add it in the list\\n            else{\\n                list.add(new int[]{start,end});\\n                start=i[0];\\n                end=i[1];\\n            }\\n            \\n        }\\n        \\n        list.add(new int[]{start,end});\\n        return list.toArray(new int[0][]);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351533,
                "title": "a-java-sorting-solution",
                "content": "The basic idea is to compare current end time with next start time, if next start time is smaller than current end time, then there is a collapse. In order to achieve this approach, we need to \\n\\n1.  Seperate start time and end time into different arrays and sort them in ascending order.\\n2.  For each end time, compare it with next start time. We use j to mark start time and i to mark end time.  When collapse appears, record start time and end time, and move j to next end time(which is i++) as the new start.\\n3.  Since this approach will miss the last stat time, add the last time section with start time j and the final end time.\\n```\\npublic int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0){\\n            return new int[0][];\\n        }\\n\\t\\t// seperate start and end \\n        int[] start = new int[intervals.length];\\n        int[] end = new int[intervals.length];\\n        List<int[]> res = new LinkedList<>();\\n        for(int i = 0; i < intervals.length; i++){\\n            start[i] = intervals[i][0];\\n            end[i] = intervals[i][1];\\n        }\\n\\t\\t\\n\\t\\t// sort start[] end[] respectively\\n        Arrays.sort(start);\\n        Arrays.sort(end);\\n\\t\\t\\n        int j = 0; // start time\\n        for(int i = 0; i < intervals.length - 1; i++) { // iterate end time\\n            if(start[i + 1] > end[i]) { // when collapse appears\\n                res.add(new int[] {start[j], end[i]}); // record\\n                j = i + 1; // move previous start time \\n            }    \\n        }\\n        res.add(new int[] {start[j], end[intervals.length - 1]}); // add last one\\n        return res.toArray(new int[res.size()][]);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "The basic idea is to compare current end time with next start time, if next start time is smaller than current end time, then there is a collapse. In order to achieve this approach, we need to \\n\\n1.  Seperate start time and end time into different arrays and sort them in ascending order.\\n2.  For each end time, compare it with next start time. We use j to mark start time and i to mark end time.  When collapse appears, record start time and end time, and move j to next end time(which is i++) as the new start.\\n3.  Since this approach will miss the last stat time, add the last time section with start time j and the final end time.\\n```\\npublic int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0){\\n            return new int[0][];\\n        }\\n\\t\\t// seperate start and end \\n        int[] start = new int[intervals.length];\\n        int[] end = new int[intervals.length];\\n        List<int[]> res = new LinkedList<>();\\n        for(int i = 0; i < intervals.length; i++){\\n            start[i] = intervals[i][0];\\n            end[i] = intervals[i][1];\\n        }\\n\\t\\t\\n\\t\\t// sort start[] end[] respectively\\n        Arrays.sort(start);\\n        Arrays.sort(end);\\n\\t\\t\\n        int j = 0; // start time\\n        for(int i = 0; i < intervals.length - 1; i++) { // iterate end time\\n            if(start[i + 1] > end[i]) { // when collapse appears\\n                res.add(new int[] {start[j], end[i]}); // record\\n                j = i + 1; // move previous start time \\n            }    \\n        }\\n        res.add(new int[] {start[j], end[intervals.length - 1]}); // add last one\\n        return res.toArray(new int[res.size()][]);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 299582,
                "title": "clean-python-beats-95",
                "content": "```\\ndef merge(self, intervals: \\'List[Interval]\\') -> \\'List[Interval]\\':\\n\\tif not intervals: return []\\n\\tintervals.sort()\\n\\n\\tunique = []\\n\\tlast = intervals[0]\\n\\tfor cur in intervals:\\n\\t\\tif cur[0] <= last[1]:\\n\\t\\t\\tlast[1] = max(last[1], cur[1])\\n\\t\\telse:\\n\\t\\t\\tunique.append(last)\\n\\t\\t\\tlast = cur\\n\\n\\tunique.append(last)\\n\\treturn unique\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef merge(self, intervals: \\'List[Interval]\\') -> \\'List[Interval]\\':\\n\\tif not intervals: return []\\n\\tintervals.sort()\\n\\n\\tunique = []\\n\\tlast = intervals[0]\\n\\tfor cur in intervals:\\n\\t\\tif cur[0] <= last[1]:\\n\\t\\t\\tlast[1] = max(last[1], cur[1])\\n\\t\\telse:\\n\\t\\t\\tunique.append(last)\\n\\t\\t\\tlast = cur\\n\\n\\tunique.append(last)\\n\\treturn unique\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3129464,
                "title": "95-javascript-fast-very-very-easy-to-understand-solution-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/EqL8ce_yZbI\\n\\nKorean video!\\n\\nhttps://youtu.be/CYGaPW7S5v4\\n# Code\\n```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    intervals.sort((a,b)=>a[0]-b[0])\\n    for(let i =1; i<intervals.length;i++){\\n        let [x,y] = intervals[i]\\n        let [prevX,prevY] = intervals[i-1]\\n        if(x <= prevY) {\\n            intervals[i-1][1] = Math.max(y,prevY);\\n            intervals.splice(i,1)\\n            i--\\n        }\\n    }\\n    return intervals    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\nvar merge = function(intervals) {\\n    intervals.sort((a,b)=>a[0]-b[0])\\n    for(let i =1; i<intervals.length;i++){\\n        let [x,y] = intervals[i]\\n        let [prevX,prevY] = intervals[i-1]\\n        if(x <= prevY) {\\n            intervals[i-1][1] = Math.max(y,prevY);\\n            intervals.splice(i,1)\\n            i--\\n        }\\n    }\\n    return intervals    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21404,
                "title": "easy-python-first-sort-with-start",
                "content": "    # Definition for an interval.\\n    # class Interval(object):\\n    #     def __init__(self, s=0, e=0):\\n    #         self.start = s\\n    #         self.end = e\\n    \\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda x: x.start)\\n            n=len(intervals)\\n            if n==0:\\n                return []\\n            re=[]\\n            re.append(intervals[0])\\n            for i in range(1,n):\\n                a=re[-1]\\n                b=intervals[i]\\n                if b.start>a.end:\\n                    re.append(b)\\n                else:\\n                    re[-1].end=max(a.end,b.end)\\n            return re",
                "solutionTags": [],
                "code": "    # Definition for an interval.\\n    # class Interval(object):\\n    #     def __init__(self, s=0, e=0):\\n    #         self.start = s\\n    #         self.end = e\\n    \\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda x: x.start)\\n            n=len(intervals)\\n            if n==0:\\n                return []\\n            re=[]\\n            re.append(intervals[0])\\n            for i in range(1,n):\\n                a=re[-1]\\n                b=intervals[i]\\n                if b.start>a.end:\\n                    re.append(b)\\n                else:\\n                    re[-1].end=max(a.end,b.end)\\n            return re",
                "codeTag": "Java"
            },
            {
                "id": 3707961,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0])\\n            ans.back()[1]=max(ans.back()[1],intervals[i][1]);\\n            else ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```Please upvote to motivate me write more solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0])\\n            ans.back()[1]=max(ans.back()[1],intervals[i][1]);\\n            else ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788731,
                "title": "c-easy-solution",
                "content": "\\n```\\nvector<vector<int>> merge(vector<vector<int>>& v) // v = intervals; \\n    {\\n        const int n = v.size();\\n        //now sort the vector such that v[i][0]\\'s will be in decreasing order and\\n        //                              v[i][1]\\'s will be in increasing order\\n        sort(v.begin(), v.end(), [&] (const vector<int> &a, const vector<int> &b)\\n        {\\n            if(a[0] != b[0])\\n                return a[0] < b[0];\\n            else\\n                return a[1] > b[1];\\n        });\\n        \\n        vector<vector<int>> ans;\\n        \\n        int start = v[0][0];\\n        int end = v[0][1];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][1] > end)\\n            {\\n                end = v[i][1];\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& v) // v = intervals; \\n    {\\n        const int n = v.size();\\n        //now sort the vector such that v[i][0]\\'s will be in decreasing order and\\n        //                              v[i][1]\\'s will be in increasing order\\n        sort(v.begin(), v.end(), [&] (const vector<int> &a, const vector<int> &b)\\n        {\\n            if(a[0] != b[0])\\n                return a[0] < b[0];\\n            else\\n                return a[1] > b[1];\\n        });\\n        \\n        vector<vector<int>> ans;\\n        \\n        int start = v[0][0];\\n        int end = v[0][1];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(v[i][0] > end)\\n            {\\n                ans.push_back({start, end});\\n                start = v[i][0];\\n                end = v[i][1];\\n            }\\n            else if(v[i][1] > end)\\n            {\\n                end = v[i][1];\\n            }\\n        }\\n        ans.push_back({start, end});\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089761,
                "title": "python-easy-solutions-with-explanation",
                "content": "\\n      #So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index.\\n\\n         intervals.sort(key = lambda x:x[0])\\n         i = 1\\n        while i < len(intervals):\\n            if intervals[i][0]<= intervals[i-1][1]:\\n            \\n        #This is to see which is min between 1, 2 . Checking the starting index of both arrays\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n            \\n            \\n         #Similarly finding the max value for ending pos\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i) #deleteing the i the part after merging \\n            \\n            \\n            else:\\n                i+=1\\n                continue\\n                \\n                \\n        return intervals\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n#If you find it helpful please upvote \\n#for any questions comment down I will reply asap",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n      #So here we have taken 0 and 1. Where 0 means the starting index and 1 means the ending index.\\n\\n         intervals.sort(key = lambda x:x[0])\\n         i = 1\\n        while i < len(intervals):\\n            if intervals[i][0]<= intervals[i-1][1]:\\n            \\n        #This is to see which is min between 1, 2 . Checking the starting index of both arrays\\n                intervals[i-1][0] = min(intervals[i-1][0], intervals[i][0])\\n            \\n            \\n         #Similarly finding the max value for ending pos\\n                intervals[i-1][1] = max(intervals[i-1][1], intervals[i][1])\\n                \\n                intervals.pop(i) #deleteing the i the part after merging \\n            \\n            \\n            else:\\n                i+=1\\n                continue\\n                \\n                \\n        return intervals\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n#If you find it helpful please upvote \\n#for any questions comment down I will reply asap",
                "codeTag": "Unknown"
            },
            {
                "id": 1083890,
                "title": "7-lines-c-simplest-solution-with-complete-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        // sorting intervals by their starting time\\n        sort(intervals.begin(), intervals.end());\\n        \\n        // keeping track of starting and ending of current interval \\n        int startingInterval = intervals[0][0], endingInterval = intervals[0][1];\\n        \\n        // starting from index 1 because we will start comparing current interval from the\\n        // last interval we have processed so far\\n        \\n        for(int i = 1; i < intervals.size(); ++i) {\\n            \\n            // if starting of current interval is less then or equal to ending of last \\n            // processed interval\\n            // then will update endingInterval so that it could be considered as merged\\n            if(intervals[i][0] <= endingInterval)\\n                endingInterval = max(endingInterval, intervals[i][1]);\\n            \\n            // inserting interval as till now we have minimum starting interval and maximum ending\\n            // interval which is merged so far, and updating our startingInterval and endingInterval\\n            // with the bounds of current interval\\n            else {\\n                ans.push_back({startingInterval , endingInterval});\\n                startingInterval = intervals[i][0];\\n                endingInterval  = intervals[i][1];\\n            }\\n        }\\n        \\n        // adding last pair which is left because loop will terminate at intervals size\\n        ans.push_back({startingInterval, endingInterval});\\n        return ans;\\n    }\\n};\\n```\\nKindly upvote if you understood the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        // sorting intervals by their starting time\\n        sort(intervals.begin(), intervals.end());\\n        \\n        // keeping track of starting and ending of current interval \\n        int startingInterval = intervals[0][0], endingInterval = intervals[0][1];\\n        \\n        // starting from index 1 because we will start comparing current interval from the\\n        // last interval we have processed so far\\n        \\n        for(int i = 1; i < intervals.size(); ++i) {\\n            \\n            // if starting of current interval is less then or equal to ending of last \\n            // processed interval\\n            // then will update endingInterval so that it could be considered as merged\\n            if(intervals[i][0] <= endingInterval)\\n                endingInterval = max(endingInterval, intervals[i][1]);\\n            \\n            // inserting interval as till now we have minimum starting interval and maximum ending\\n            // interval which is merged so far, and updating our startingInterval and endingInterval\\n            // with the bounds of current interval\\n            else {\\n                ans.push_back({startingInterval , endingInterval});\\n                startingInterval = intervals[i][0];\\n                endingInterval  = intervals[i][1];\\n            }\\n        }\\n        \\n        // adding last pair which is left because loop will terminate at intervals size\\n        ans.push_back({startingInterval, endingInterval});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940596,
                "title": "c-5-lines-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a) {\\n        sort(a.begin(), a.end());\\n        int i = 0, n = a.size();\\n        for (int j = 1; j < n; j++) \\n            if (a[j][0] > a[i][1]) a[++i] = a[j];\\n            else a[i][1] = max(a[i][1], a[j][1]);\\n        while (--n > i) a.pop_back(); \\n        return a;\\n    }\\n};\\n```\\nO(N) modified space :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a) {\\n        sort(a.begin(), a.end());\\n        int i = 0, n = a.size();\\n        for (int j = 1; j < n; j++) \\n            if (a[j][0] > a[i][1]) a[++i] = a[j];\\n            else a[i][1] = max(a[i][1], a[j][1]);\\n        while (--n > i) a.pop_back(); \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940325,
                "title": "c-python-linear-scan",
                "content": "Approach 1: C++\\n```\\nclass Solution { // Linear scan\\npublic: // Time/Space: O(NlogN); O(N)\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){return a[0] < b[0];});\\n\\t\\tsort(intervals.begin(), intervals.end()); // same as above above line\\n        vector<vector<int>> ans;\\n        for(auto& e: intervals){\\n            if(ans.empty() || e[0] > ans.back()[1]) ans.push_back(e);\\n            else ans.back()[1] = max(ans.back()[1], e[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2: Python\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:        \\n        ans = []        \\n        for i in sorted(intervals):\\n            if not ans or ans[-1][1]< i[0]:  ans.append(i)\\n            else:  ans[-1][1] = max(ans[-1][1], i[1])\\n        return ans             \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution { // Linear scan\\npublic: // Time/Space: O(NlogN); O(N)\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        //sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){return a[0] < b[0];});\\n\\t\\tsort(intervals.begin(), intervals.end()); // same as above above line\\n        vector<vector<int>> ans;\\n        for(auto& e: intervals){\\n            if(ans.empty() || e[0] > ans.back()[1]) ans.push_back(e);\\n            else ans.back()[1] = max(ans.back()[1], e[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:        \\n        ans = []        \\n        for i in sorted(intervals):\\n            if not ans or ans[-1][1]< i[0]:  ans.append(i)\\n            else:  ans[-1][1] = max(ans[-1][1], i[1])\\n        return ans             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 21467,
                "title": "my-c-o-nlogn-solution-580ms",
                "content": "Just copy the input to res and do sorting (in ascending order of start). Then try to merge the sorted interval: cur is the last processed interval and i is the current to-be-processed interval. if cur is ahead of i and no overlapping, just copy i to cur+1, and update cur to cur+1, otherwise, merge interval cur and i and move to i+1. At last, we need to resize res to remove the redundent intervals.  \\n\\n    class Solution {\\n    public:\\n        vector<Interval> merge(vector<Interval>& intervals) {\\n            int len = intervals.size(),i,cur;\\n            vector<Interval> res(intervals);\\n            if(len>1)\\n            {\\n                std::sort(res.begin(), res.end(), [](Interval i, Interval j){return i.start<j.start;});\\n                for(cur=0, i=1;i<len; ++i)\\n                    if(res[cur].end<res[i].start) res[++cur] = res[i]; // no overlapping, copy to cur+1, \\n                    else res[cur].end = max(res[cur].end, res[i].end); // cur and i overlap with each other, merge\\n                res.resize(cur+1); // resize to remove redundant intervals\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<Interval> merge(vector<Interval>& intervals) {\\n            int len = intervals.size(),i,cur;\\n            vector<Interval> res(intervals);\\n            if(len>1)\\n            {\\n                std::sort(res.begin(), res.end(), [](Interval i, Interval j){return i.start<j.start;}",
                "codeTag": "Java"
            },
            {
                "id": 1036776,
                "title": "simple-sorting-python-solution-o-n-log-n-time",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals)\\n        \\n        ans = []\\n        start = intervals[0][0]\\n        end = intervals[0][1]\\n        for i in intervals:\\n            if i[0] > end:\\n                ans.append([start, end])\\n                start, end = i[0], i[1]\\n            else:\\n                end = max(end, i[1])\\n        ans.append([start, end])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals = sorted(intervals)\\n        \\n        ans = []\\n        start = intervals[0][0]\\n        end = intervals[0][1]\\n        for i in intervals:\\n            if i[0] > end:\\n                ans.append([start, end])\\n                start, end = i[0], i[1]\\n            else:\\n                end = max(end, i[1])\\n        ans.append([start, end])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030287,
                "title": "9-line-javascript-solution",
                "content": "Sort the intervals by the start index in ascending order. We can tell if the current interval overlap with the previous one if the current start value > the previous end value. Update the previous interval accordingly. \\n\\n```\\nvar merge = function(intervals) {\\n  intervals.sort((a, b) => a[0] - b[0])\\n  const res = [intervals[0]]\\n  for (let curr of intervals) {\\n    prev = res[res.length - 1]\\n    if (prev[1] >= curr[0]) {\\n      prev[1] = Math.max(curr[1], prev[1])\\n    } else {\\n      res.push(curr)\\n    }\\n  }\\n  return res\\n};\\n```\\n*Note that modifying prev array also modifies the original res array due to JavaScript object copying properties.",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n  intervals.sort((a, b) => a[0] - b[0])\\n  const res = [intervals[0]]\\n  for (let curr of intervals) {\\n    prev = res[res.length - 1]\\n    if (prev[1] >= curr[0]) {\\n      prev[1] = Math.max(curr[1], prev[1])\\n    } else {\\n      res.push(curr)\\n    }\\n  }\\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855286,
                "title": "brute-force-approach-for-simple-understanding-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        int m = intervals.size();\\n        if(m==0)\\n            return res;\\n        int n = intervals[0].size();\\n\\n        \\n        for(int i=0; i<intervals.size(); i++){\\n            int tru = 0;\\n            \\n            for(int j=i+1; j<intervals.size(); j++){\\n                \\n                int a = intervals[i][0];\\n                int b = intervals[i][1];\\n                \\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n                \\n                if((a>=c && a<=d) || (b>=c && b<=d) || (c>=a && c<=b) || (d>=a && d<=b)){\\n                    intervals.erase(intervals.begin()+i);\\n                    intervals.erase(intervals.begin()+j-1);\\n                    intervals.push_back({min(a,c), max(b,d)});\\n                    i--;\\n                    tru = 1;\\n                    break;\\n                }                                            \\n            }\\n            if(tru==0)\\n                res.push_back({intervals[i][0], intervals[i][1]});\\n        }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        int m = intervals.size();\\n        if(m==0)\\n            return res;\\n        int n = intervals[0].size();\\n\\n        \\n        for(int i=0; i<intervals.size(); i++){\\n            int tru = 0;\\n            \\n            for(int j=i+1; j<intervals.size(); j++){\\n                \\n                int a = intervals[i][0];\\n                int b = intervals[i][1];\\n                \\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n                \\n                if((a>=c && a<=d) || (b>=c && b<=d) || (c>=a && c<=b) || (d>=a && d<=b)){\\n                    intervals.erase(intervals.begin()+i);\\n                    intervals.erase(intervals.begin()+j-1);\\n                    intervals.push_back({min(a,c), max(b,d)});\\n                    i--;\\n                    tru = 1;\\n                    break;\\n                }                                            \\n            }\\n            if(tru==0)\\n                res.push_back({intervals[i][0], intervals[i][1]});\\n        }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717511,
                "title": "cpp-c-solution-log-n-linear",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {  \\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n      //  cout.tie(NULL);\\n        vector<vector<int>>ans;  \\n        if(intervals.size()==0)\\n            return ans;\\n        sort(intervals.begin(),intervals.end()); \\n        int f=intervals[0][0]; \\n        int e=intervals[0][1]; \\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            int f2=intervals[i][0]; \\n            int e2=intervals[i][1]; \\n            if(max(f,f2)<=min(e,e2))//overlapping happens here\\n            {\\n                f=min(f,f2); \\n                e=max(e,e2);\\n            } \\n            else\\n            {\\n                ans.push_back({f,e}); \\n                f=f2; \\n                e=e2;\\n            }\\n\\n        } \\n        ans.push_back({f,e});\\n        return ans;\\n    }\\n\\t``` \\n\\tPlease upvote if you like my solution.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {  \\n        ios_base::sync_with_stdio(false); \\n        cin.tie(NULL); \\n      //  cout.tie(NULL);\\n        vector<vector<int>>ans;  \\n        if(intervals.size()==0)\\n            return ans;\\n        sort(intervals.begin(),intervals.end()); \\n        int f=intervals[0][0]; \\n        int e=intervals[0][1]; \\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            int f2=intervals[i][0]; \\n            int e2=intervals[i][1]; \\n            if(max(f,f2)<=min(e,e2))//overlapping happens here\\n            {\\n                f=min(f,f2); \\n                e=max(e,e2);\\n            } \\n            else\\n            {\\n                ans.push_back({f,e}); \\n                f=f2; \\n                e=e2;\\n            }\\n\\n        } \\n        ans.push_back({f,e});\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 281356,
                "title": "c-sort-then-merge",
                "content": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        var n = intervals.Length;\\n\\n        if (n <= 1) {\\n            return intervals;\\n        }\\n\\n        /* NOTE:\\n            better, because it does not modify the input (try best to immutability)\\n            but Time Limit Exceeded :(\\n        */ \\n        // var sortedIntervals = intervals.OrderBy(interval => interval[0]);\\n        Array.Sort(intervals, (a, b) => a[0] - b[0]);\\n\\n        var result = new List<int[]>();\\n        result.Add(intervals.ElementAt(0));\\n        for (int i = 1; i < n; i++) {\\n            var cur = intervals.ElementAt(i);\\n            var lastFromResult = result.Last();\\n\\n            if (lastFromResult[1] >= cur[0]) {\\n                lastFromResult[1] = Math.Max(lastFromResult[1], cur[1]);\\n            } else {\\n                result.Add(cur);\\n            }\\n        }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) {\\n        var n = intervals.Length;\\n\\n        if (n <= 1) {\\n            return intervals;\\n        }\\n\\n        /* NOTE:\\n            better, because it does not modify the input (try best to immutability)\\n            but Time Limit Exceeded :(\\n        */ \\n        // var sortedIntervals = intervals.OrderBy(interval => interval[0]);\\n        Array.Sort(intervals, (a, b) => a[0] - b[0]);\\n\\n        var result = new List<int[]>();\\n        result.Add(intervals.ElementAt(0));\\n        for (int i = 1; i < n; i++) {\\n            var cur = intervals.ElementAt(i);\\n            var lastFromResult = result.Last();\\n\\n            if (lastFromResult[1] >= cur[0]) {\\n                lastFromResult[1] = Math.Max(lastFromResult[1], cur[1]);\\n            } else {\\n                result.Add(cur);\\n            }\\n        }\\n\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21510,
                "title": "c-vanilla",
                "content": "Sort `intervals` according to `start`, scan from left to right and merge overlapping ones.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](Interval& l, Interval& r) {return l.start < r.start;});\\n        vector<Interval> ans;\\n        for (Interval& interval : intervals) {\\n            if (!ans.empty() && ans.back().end >= interval.start) {\\n                ans.back().end = max(ans.back().end, interval.end);\\n            } else {\\n                ans.push_back(interval);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](Interval& l, Interval& r) {return l.start < r.start;});\\n        vector<Interval> ans;\\n        for (Interval& interval : intervals) {\\n            if (!ans.empty() && ans.back().end >= interval.start) {\\n                ans.back().end = max(ans.back().end, interval.end);\\n            } else {\\n                ans.push_back(interval);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008939,
                "title": "super-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n    Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));\\n        List<int[]> res=new ArrayList<>();\\n        int low=intervals[0][0];\\n        int high=intervals[0][1];\\n\\n        for(int i=1;i<intervals.length;i++)\\n        {\\n           if(intervals[i][0]<=high){\\n               if(high<intervals[i][1])\\n               high=intervals[i][1];\\n           }\\n           else{\\n               res.add(new int[]{low,high});\\n               low=intervals[i][0];\\n               high=intervals[i][1];\\n           }\\n        }\\n        res.add(new int[]{low,high});  \\n       return res.toArray(new int[0][]);     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n    Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));\\n        List<int[]> res=new ArrayList<>();\\n        int low=intervals[0][0];\\n        int high=intervals[0][1];\\n\\n        for(int i=1;i<intervals.length;i++)\\n        {\\n           if(intervals[i][0]<=high){\\n               if(high<intervals[i][1])\\n               high=intervals[i][1];\\n           }\\n           else{\\n               res.add(new int[]{low,high});\\n               low=intervals[i][0];\\n               high=intervals[i][1];\\n           }\\n        }\\n        res.add(new int[]{low,high});  \\n       return res.toArray(new int[0][]);     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693730,
                "title": "java-easy-approach-with-comments-merge-intervals",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)-> Integer.compare(a[0],b[0]));\\n        Stack<int[]> stack = new Stack();\\n        stack.add(intervals[0]);    //pushing 1st interval\\n        \\n        //2nd interval se compare krenge\\n        for(int i=1;i<intervals.length;i++){\\n            \\n            int startpoint2 = intervals[i][0];  //2nd interval ka start point isliye 2\\n            int endpoint2 = intervals[i][1];\\n            \\n            //first interval stack mai h toh usse pop kro\\n            int poparray[] = stack.pop();\\n            \\n            int startpoint1 = poparray[0];\\n            int endpoint1 = poparray[1];\\n            \\n            //1 3\\n            //2 6  inko comapre\\n            int endmax = Math.max(endpoint2,endpoint1);\\n                \\n            if(endpoint1 >= startpoint2){\\n                int [] merge = new int[]{startpoint1,endmax};\\n                stack.add(merge);      //merge karne ke baad stack mai dal do \\n            }else{\\n                stack.add(poparray);\\n                 stack. add(intervals[i]);\\n            }        \\n        }\\n        int [][] output = new int [stack.size()][2];\\n        for(int i=output.length-1;i>=0;i--){\\n            int []poparray = stack.pop();\\n            output[i][0] = poparray[0];\\n            output[i][1] = poparray[1];\\n        }\\n        return output;\\n    }                           \\n}\\n```\\n![image](https://assets.leetcode.com/users/images/848bc7b1-68bc-433d-b411-03b6fca15cd8_1665573877.8034868.png)\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)-> Integer.compare(a[0],b[0]));\\n        Stack<int[]> stack = new Stack();\\n        stack.add(intervals[0]);    //pushing 1st interval\\n        \\n        //2nd interval se compare krenge\\n        for(int i=1;i<intervals.length;i++){\\n            \\n            int startpoint2 = intervals[i][0];  //2nd interval ka start point isliye 2\\n            int endpoint2 = intervals[i][1];\\n            \\n            //first interval stack mai h toh usse pop kro\\n            int poparray[] = stack.pop();\\n            \\n            int startpoint1 = poparray[0];\\n            int endpoint1 = poparray[1];\\n            \\n            //1 3\\n            //2 6  inko comapre\\n            int endmax = Math.max(endpoint2,endpoint1);\\n                \\n            if(endpoint1 >= startpoint2){\\n                int [] merge = new int[]{startpoint1,endmax};\\n                stack.add(merge);      //merge karne ke baad stack mai dal do \\n            }else{\\n                stack.add(poparray);\\n                 stack. add(intervals[i]);\\n            }        \\n        }\\n        int [][] output = new int [stack.size()][2];\\n        for(int i=output.length-1;i>=0;i--){\\n            int []poparray = stack.pop();\\n            output[i][0] = poparray[0];\\n            output[i][1] = poparray[1];\\n        }\\n        return output;\\n    }                           \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914800,
                "title": "python-simple-explanation-8-line",
                "content": "Create a temporary list and add elements when there is no overlap. If there is then perfrom merge.\\n\\n    def merge(self, l: List[List[int]]) -> List[List[int]]:\\n        k = []\\n        l.sort()\\n        for i in l:\\n            if not k or k[-1][1] < i[0]:\\n                k.append(i)\\n            else:\\n                k[-1][1] = max(k[-1][1],i[1])\\n        return k\\n\\t\\t\\n\\t\\t\\nRuntime: 163 ms\\nMemory Usage: 18.1 MB\\n\\n**Upvote if you found it useful**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "Create a temporary list and add elements when there is no overlap. If there is then perfrom merge.\\n\\n    def merge(self, l: List[List[int]]) -> List[List[int]]:\\n        k = []\\n        l.sort()\\n        for i in l:\\n            if not k or k[-1][1] < i[0]:\\n                k.append(i)\\n            else:\\n                k[-1][1] = max(k[-1][1],i[1])\\n        return k\\n\\t\\t\\n\\t\\t\\nRuntime: 163 ms\\nMemory Usage: 18.1 MB\\n\\n**Upvote if you found it useful**",
                "codeTag": "Python3"
            },
            {
                "id": 1444462,
                "title": "followup-bst-implementation-c",
                "content": "# **Facebook Followup - Stream of Intervals**\\n**General Question**: What if the data comes as a stream in real time - No meaningful sorting can be done.\\n\\nImplementation based on Interval based BSTs so that we can `query` multiple times. We also create an `insert` method that we will need for the interval tree.\\n\\n### Implementation Details & Code \\n \\n- `IntervalTree` is the new class that we need to define, and we will use it to define `start`, `end` and `mid` points for each node.\\n- `insertInterval` method - if the interval to be added touches or crosses the `middle` of the current node, we merge them directly, else we insert the new interval in the `left` or `right` subtree.\\n```\\nvoid insertInterval(IntervalTree *node, Interval *currentInterval) {\\n    if (currentInterval->end < node->middle) { // Check if the entire interval is included before middle.\\n        if (node->left) {\\n            insertInterval(node->left, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->left = newNode;\\n        }\\n    }\\n    else if (currentInterval->start > node->middle) { // Check if the entire interval is included after middle.\\n        if (node->right) {\\n            insertInterval(node->right, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->right = newNode;\\n        }\\n    }\\n    else { // Merge directly if the new interval does not fit before OR after the middle point.\\n        node->start = min(node->start, currentInterval->start);\\n        node->end = max(node->end, currentInterval->end);\\n    }\\n}\\n```\\n- `queryInterval` method - retrieve merged intervals of the `left` subtree, `leftIntervals` and those of the `right` subtree `rightIntervals`. \\n```\\nvoid queryInterval(vector<Interval *> &retV, IntervalTree *node) { \\n    // retV is the collection vector.\\n    vector<Interval *> leftIntervals;\\n    vector<Interval *> rightIntervals;\\n    \\n    // Check if we can merge the current node with intervals from the left subtree.\\n    bool mergeLeft = false; \\n    \\n    if (node->left) {\\n        queryInterval(leftIntervals, node->left); // Merge all the intervals in left subtree.\\n        mergeLeftInterval(leftIntervals, node, retV, mergeLeft); // Find the merge point with the leftIntervals.\\n    }\\n    \\n    if (!mergeLeft) { // If we didn\\'t merge left, create a new interval.\\n        Interval *newInterval = new Interval(node->start, node->end);\\n        retV.push_back(newInterval);\\n    }\\n    \\n    if (node->right) {\\n        queryInterval(rightIntervals, node->right); //Merge all the intervals in the right subtree.\\n        mergeRightInterval(rightIntervals, node, retV); // Find the merge point with the rightIntervals.\\n    }\\n}\\n```\\n- the two merge methods `mergeLeftInterval` and `mergeRightInterval` are implemented similarly\\n\\t- if we find an interval that overlaps with the current `node`, we know that everything after will overlap\\n\\t- the first intervals that overlap will be all merged and the rest inserted at the end\\n```\\nvoid mergeLeftInterval(vector<Interval *> &leftIntervals, IntervalTree *node, \\n                       vector<Interval *> &retV, bool &merged) {\\n    for (int i = 0; i < leftIntervals.size(); i++) { \\n\\t\\t// If any of the left intervals intersects with the current interval, we merge it and break.\\n        if (leftIntervals[i]->end >= node->start) { \\n            Interval *newInterval = new Interval(min(leftIntervals[i]->start, node->start), node->end); \\n            retV.push_back(newInterval);\\n            merged = true;\\n            break;\\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n```\\n```\\nvoid mergeRightInterval(vector<Interval *> &rightIntervals, IntervalTree *node,\\n                        vector<Interval *> &retV) {\\n    for (int i = 0; i < rightIntervals.size(); i++) {\\n        if (rightIntervals[i]->start <= node->end) {\\n\\t\\t\\t// We extend the right end of the last appended interval whenever an intersection takes place.\\n            retV[retV.size() - 1]->end = max(rightIntervals[i]->end, node->end); \\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(rightIntervals[i]); \\n        }\\n    }\\n}\\n```\\n\\nInspiration comes from this post: https://leetcode.com/problems/merge-intervals/discuss/21452/Share-my-interval-tree-solution-no-sorting\\n\\nAnd the explanation in [yongzx](https://leetcode.com/yongzx/) \\'s comment at the bottom of the solution tab. \\n\\nI am thankful to both of them for posting about this problem / followup! \\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nvoid insertInterval(IntervalTree *node, Interval *currentInterval) {\\n    if (currentInterval->end < node->middle) { // Check if the entire interval is included before middle.\\n        if (node->left) {\\n            insertInterval(node->left, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->left = newNode;\\n        }\\n    }\\n    else if (currentInterval->start > node->middle) { // Check if the entire interval is included after middle.\\n        if (node->right) {\\n            insertInterval(node->right, currentInterval);\\n        } else {\\n            IntervalTree *newNode = new IntervalTree(currentInterval->start, currentInterval->end);\\n            node->right = newNode;\\n        }\\n    }\\n    else { // Merge directly if the new interval does not fit before OR after the middle point.\\n        node->start = min(node->start, currentInterval->start);\\n        node->end = max(node->end, currentInterval->end);\\n    }\\n}\\n```\n```\\nvoid queryInterval(vector<Interval *> &retV, IntervalTree *node) { \\n    // retV is the collection vector.\\n    vector<Interval *> leftIntervals;\\n    vector<Interval *> rightIntervals;\\n    \\n    // Check if we can merge the current node with intervals from the left subtree.\\n    bool mergeLeft = false; \\n    \\n    if (node->left) {\\n        queryInterval(leftIntervals, node->left); // Merge all the intervals in left subtree.\\n        mergeLeftInterval(leftIntervals, node, retV, mergeLeft); // Find the merge point with the leftIntervals.\\n    }\\n    \\n    if (!mergeLeft) { // If we didn\\'t merge left, create a new interval.\\n        Interval *newInterval = new Interval(node->start, node->end);\\n        retV.push_back(newInterval);\\n    }\\n    \\n    if (node->right) {\\n        queryInterval(rightIntervals, node->right); //Merge all the intervals in the right subtree.\\n        mergeRightInterval(rightIntervals, node, retV); // Find the merge point with the rightIntervals.\\n    }\\n}\\n```\n```\\nvoid mergeLeftInterval(vector<Interval *> &leftIntervals, IntervalTree *node, \\n                       vector<Interval *> &retV, bool &merged) {\\n    for (int i = 0; i < leftIntervals.size(); i++) { \\n\\t\\t// If any of the left intervals intersects with the current interval, we merge it and break.\\n        if (leftIntervals[i]->end >= node->start) { \\n            Interval *newInterval = new Interval(min(leftIntervals[i]->start, node->start), node->end); \\n            retV.push_back(newInterval);\\n            merged = true;\\n            break;\\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(leftIntervals[i]);\\n        }\\n    }\\n}\\n```\n```\\nvoid mergeRightInterval(vector<Interval *> &rightIntervals, IntervalTree *node,\\n                        vector<Interval *> &retV) {\\n    for (int i = 0; i < rightIntervals.size(); i++) {\\n        if (rightIntervals[i]->start <= node->end) {\\n\\t\\t\\t// We extend the right end of the last appended interval whenever an intersection takes place.\\n            retV[retV.size() - 1]->end = max(rightIntervals[i]->end, node->end); \\n        } else {\\n\\t\\t\\t// Else we push the interval directly.\\n            retV.push_back(rightIntervals[i]); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1398334,
                "title": "c-simple-with-explanation-pattern-for-interval-problems",
                "content": "There are some interval based problems which are not really associated with any other data structure or algorithm but are all solved using a similar technique: Sort the intervals + One pass to update/calculate greedily.\\n\\n**1. Merge Intervals**\\n\\nWe want to merge any overlapping intervals. Let us start with the interval with the least left end. Then, we don\\'t want to miss any intervals that start immediately before it ends. If we sort the intervals by starting index, we will not miss any intervals while iterating over the sorted intervals. \\n\\nHow to merge greedily? First set **start** and **end** to the limits of the first interval in the sorted list. Then, if for an element i, starting[i] <= end, we know it overlaps because sorting by the first interval means start < starting[i] (so it means start < starting[i] <= end). Now, since we know the interval overlaps, we have to update the present interval. The start value doesn\\'t have to be updated since it is already the leftmost index possible in all the overlapping arrays. However the end index should be the rightmost index possible in all overlapping arrays, so end should be updated with the maximum of itself and ending[i].\\n\\nIf while iterating, starting[i] > end, we can add the range covered by {start,end} to the merged array, and restart merging like at i = 0 by setting start = starting[i] and end = ending[i].\\n\\nOnce we have completed traversal, the final merged element needs to be added (since we add an element only after the next interval does not overlap, but for the last element we cannot do this check). This completes merge intervals.\\n\\n```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        vector<vector<int>> merged;\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] <= end)\\n            {\\n                end = max(end, intervals[i][1]);\\n            }\\n            else\\n            {\\n                merged.push_back({start,end});\\n                \\n                start = intervals[i][0];\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        merged.push_back({start,end});\\n        \\n        return merged;\\n    }\\n```\\n\\n**2. Non-overlapping Intervals**\\n\\nThe problem asks to find \"*the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping*\". First is the sorting step. Suppose we sort like with merged intervals based on first index. Then, when we find overlapping intervals, which one should we delete? If we choose the interval which ends earlier we will have more space to accommodate more intervals. Hence we maintain only the earliest ending interval out of all overlapping intervals. \\n\\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n                \\n                if(intervals[i][1] < end)\\n                {\\n                    end = intervals[i][1];\\n                }\\n            }\\n            else\\n            {\\n                end = intervals[i][1];   \\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\\n\\nIf we sort by the second index, then the intervals are already arranged in least ending first order, so we can process the intervals more simply, on finding an overlap we can just remove the present interval (guaranteed to have a later ending than the one being compared to). \\n\\nHence another solution is to sort by the second index and then pick the first interval, remove all intervals in front of it overlapping with it, then update to the next interval and do the same, similar to how the intervals were processed for merging but with the second index.\\n\\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[1] < b[1];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n            }\\n            else\\n            {\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\\n\\nOther problems based on interval pattern (sort + greedy processing)\\n\\nhttps://leetcode.com/problems/non-overlapping-intervals/ (already discussed)\\nhttps://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/ (similar to non overlapping intervals)\\nhttps://leetcode.com/problems/meeting-rooms/\\nhttps://leetcode.com/problems/meeting-rooms-ii/\\nhttps://leetcode.com/problems/insert-interval/ (only greedy processing, good to familiarize with interval processing)",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        vector<vector<int>> merged;\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] <= end)\\n            {\\n                end = max(end, intervals[i][1]);\\n            }\\n            else\\n            {\\n                merged.push_back({start,end});\\n                \\n                start = intervals[i][0];\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        merged.push_back({start,end});\\n        \\n        return merged;\\n    }\\n```\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[0] < b[0];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n                \\n                if(intervals[i][1] < end)\\n                {\\n                    end = intervals[i][1];\\n                }\\n            }\\n            else\\n            {\\n                end = intervals[i][1];   \\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```\n```\\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){return a[1] < b[1];});\\n        \\n        int end = intervals[0][1];\\n        \\n        int remove = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n            if(intervals[i][0] < end)\\n            {\\n                remove++;\\n            }\\n            else\\n            {\\n                end = intervals[i][1];\\n            }\\n        }\\n        \\n        return remove;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21498,
                "title": "clean-java-sort-solution-using-comparator",
                "content": "    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\tif (intervals.isEmpty())\\n\\t\\t\\treturn intervals;\\n\\n\\t\\tCollections.sort(intervals, new Comparator<Interval>() {\\n\\t\\t\\tpublic int compare(Interval a, Interval b) {\\n\\t\\t\\t\\t// TODO Auto-generated method stub\\n\\t\\t\\t\\treturn a.start - b.start;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tList<Interval> ans = new LinkedList<Interval>();\\n\\t\\tInterval hold = intervals.get(0);\\n\\t\\tfor (int i = 1; i < intervals.size(); i++) {\\n\\t\\t\\tInterval current = intervals.get(i);\\n\\t\\t\\tif (hold.end >= current.start) {\\n\\t\\t\\t\\thold.end = Math.max(current.end, hold.end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans.add(hold);\\n\\t\\t\\t\\thold = current;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!ans.contains(hold))\\n\\t\\t\\tans.add(hold);\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "    public List<Interval> merge(List<Interval> intervals) {\\n\\t\\tif (intervals.isEmpty())\\n\\t\\t\\treturn intervals;\\n\\n\\t\\tCollections.sort(intervals, new Comparator<Interval>() {\\n\\t\\t\\tpublic int compare(Interval a, Interval b) {\\n\\t\\t\\t\\t// TODO Auto-generated method stub\\n\\t\\t\\t\\treturn a.start - b.start;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tList<Interval> ans = new LinkedList<Interval>();\\n\\t\\tInterval hold = intervals.get(0);\\n\\t\\tfor (int i = 1; i < intervals.size(); i++) {\\n\\t\\t\\tInterval current = intervals.get(i);\\n\\t\\t\\tif (hold.end >= current.start) {\\n\\t\\t\\t\\thold.end = Math.max(current.end, hold.end);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tans.add(hold);\\n\\t\\t\\t\\thold = current;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!ans.contains(hold))\\n\\t\\t\\tans.add(hold);\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3713888,
                "title": "java-striver-easy-understanding",
                "content": "**Time Complexity:** O(nlogn)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) return intervals;\\n\\n        Arrays.sort(intervals, (arr1, arr2) - > Integer.compare(arr1[0], arr2[0]));\\n\\n        List < int[] > output_arr = new ArrayList < > ();\\n        int[] current_interval = intervals[0];\\n        output_arr.add(current_interval);\\n\\n        for (int[] interval: intervals) {\\n            int current_begin = current_interval[0];\\n            int current_end = current_interval[1];\\n            int next_begin = interval[0];\\n            int next_end = interval[1];\\n\\n            if (current_end >= next_begin) {\\n                current_interval[1] = Math.max(current_end, next_end);\\n            } else {\\n                current_interval = interval;\\n                output_arr.add(current_interval);\\n            }\\n        }\\n        return output_arr.toArray(new int[output_arr.size()][]);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) return intervals;\\n\\n        Arrays.sort(intervals, (arr1, arr2) - > Integer.compare(arr1[0], arr2[0]));\\n\\n        List < int[] > output_arr = new ArrayList < > ();\\n        int[] current_interval = intervals[0];\\n        output_arr.add(current_interval);\\n\\n        for (int[] interval: intervals) {\\n            int current_begin = current_interval[0];\\n            int current_end = current_interval[1];\\n            int next_begin = interval[0];\\n            int next_end = interval[1];\\n\\n            if (current_end >= next_begin) {\\n                current_interval[1] = Math.max(current_end, next_end);\\n            } else {\\n                current_interval = interval;\\n                output_arr.add(current_interval);\\n            }\\n        }\\n        return output_arr.toArray(new int[output_arr.size()][]);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320349,
                "title": "c-fast-simple-sorting-169-ms-beats-82-2-51-1-mb-beats-83-68",
                "content": "# Approach\\nThe code is very simple at first we will sort the 2D array based on the first column. after that we will create a list of array and add the first row from the sorted 2D array. then we will just loop the 2D array and check if the list last array\\'s last element is greater than the current sorted array\\'s first element if yes then we will change the list element based on value, else we will add the element to the list.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) \\n    {\\n        List<int[]> output = new List<int[]>();\\n\\n        Array.Sort(intervals, (a,b)=>{return a[0]-b[0];});\\n\\n        output.Add(intervals[0]);\\n\\n        for(int i = 1; i < intervals.Length; i++)\\n        {\\n            if(output[output.Count - 1][1] >= intervals[i][0])\\n            {\\n                if(output[output.Count - 1][1] <= intervals[i][1]) \\n                    output[output.Count - 1][1] = intervals[i][1];\\n            }\\n            else output.Add(intervals[i]);\\n        }\\n\\n        return output.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] Merge(int[][] intervals) \\n    {\\n        List<int[]> output = new List<int[]>();\\n\\n        Array.Sort(intervals, (a,b)=>{return a[0]-b[0];});\\n\\n        output.Add(intervals[0]);\\n\\n        for(int i = 1; i < intervals.Length; i++)\\n        {\\n            if(output[output.Count - 1][1] >= intervals[i][0])\\n            {\\n                if(output[output.Count - 1][1] <= intervals[i][1]) \\n                    output[output.Count - 1][1] = intervals[i][1];\\n            }\\n            else output.Add(intervals[i]);\\n        }\\n\\n        return output.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215453,
                "title": "simple-c-solution",
                "content": "If you find it to be helpful please like and upvote \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ans[j][1]>=intervals[i][0])\\n            {\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }           \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int n=intervals.size();\\n        ans.push_back(intervals[0]);\\n        int j=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(ans[j][1]>=intervals[i][0])\\n            {\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else\\n            {\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }           \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205936,
                "title": "c-detailed-explaination-beats-100-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Explanation:**\\n* Sort the 2D vector.\\n* Then initialize a temp variable with the 1st pair from the intervals.\\n* Now we take each pair and compare its 1st element to the 2nd element of the temp to check whether it intersects with the pair.\\n* If it\\'s <= then we take max of temp\\'s 2nd element and the pair\\'s 2nd element and update it to the 2nd element of the temp.\\n* Else we just push temp to answer vector and update temp with the current pair from the loop.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        if(intervals.size()==0) \\n            return ans;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<int> temp=intervals[0];\\n        \\n        for(auto it: intervals)\\n        {\\n            if(it[0]<=temp[1])\\n            {\\n                temp[1]=max(it[1],temp[1]);\\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```\\n\\nT.C -> `O(Nlog(N)) +O(N)`\\nS.C=`O(N)`\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        vector<vector<int>> ans;\\n        \\n        if(intervals.size()==0) \\n            return ans;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<int> temp=intervals[0];\\n        \\n        for(auto it: intervals)\\n        {\\n            if(it[0]<=temp[1])\\n            {\\n                temp[1]=max(it[1],temp[1]);\\n            }\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        ans.push_back(temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871008,
                "title": "c-very-very-simple-code-easy-to-understand",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        int n=intervals.size(),start=intervals[0][0],end=intervals[0][1];\\n        for(int i=1;i<n;++i){\\n            if(intervals[i][0]<=end) end=max(end,intervals[i][1]);\\n            else res.push_back({start,end}),start=intervals[i][0],end=intervals[i][1];\\n        }\\n        res.push_back({start,end});\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        int n=intervals.size(),start=intervals[0][0],end=intervals[0][1];\\n        for(int i=1;i<n;++i){\\n            if(intervals[i][0]<=end) end=max(end,intervals[i][1]);\\n            else res.push_back({start,end}),start=intervals[i][0],end=intervals[i][1];\\n        }\\n        res.push_back({start,end});\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1644276,
                "title": "python-java-c-2-simple-solutions-o-n-r-and-o-nlogn-image-visualized-explanation",
                "content": "**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!** \\uD83D\\uDE01\\n\\n* **step 1: sort the intervals**\\n\\t* that means` intervals[i][0] >= intervals[i - 1][0]` after sorting\\n* **step 2: for each interval `[x, y]` in `intervals`:**\\n\\t* compare `[x, y]` and `ans.back() or ans[-1]`\\n\\t* There are 3 possible situations as shown in the figure below\\n\\t\\t* 1st: nothing to do\\n\\t\\t* 2nd: enlarge the `ans[-1][1] = y`\\n\\t\\t* 3rd: append `[x, y]` to `ans`\\n\\n![image](https://assets.leetcode.com/users/images/fba68a60-56fb-4158-b66a-dcb8c235242d_1640323116.0364041.jpeg)\\n\\n* **The difference between 2 solutions focus on the sort approach.**\\n\\t* **Solusion 1 O(NlogN)**\\n\\t\\t* use some standard sort approach like quick sort cost `O(NlogN)`\\n\\t* **Solution 2 O(N+R)**\\n\\t\\t* Fortunately, since `0 <= start_i <= end_i <= 10000`, we can use Hash Sort with hash bucket `R = max(start_i)` cost `O(N)` time.\\n\\t\\t\\t```\\n\\t\\t        R = max([x for [x, _] in intervals]) + 1\\n\\t\\t\\t\\tdata = [[] for x in range(R)]\\n\\t\\t\\t\\tfor [x, y] in intervals:\\n\\t\\t\\t\\t\\tdata[x].append(y)\\n\\t\\t\\t```\\n\\t\\t* Then traverse all `intervals` cost `O(N+R)` time\\n\\n\\n**C++ O(NlogN) Runtime: 12 ms, faster than 98.58%**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < intervals.size(); i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.empty() || x > ans.back()[1])\\n                ans.push_back(intervals[i]);\\n            else if (ans.back()[1] < y)\\n                ans.back()[1] = y;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Python O(NlogN) Runtime: 56 ms, faster than 98.37%**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        for [x, y] in sorted(intervals):\\n            if not ans or x > ans[-1][1]:\\n                ans.append([x, y])\\n            elif ans[-1][1] < y:\\n                ans[-1][1] = y\\n        return ans\\n```\\n**Python O(N+R) Runtime: 60 ms, faster than 94.11%**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        R = max([x for [x, _] in intervals]) + 1\\n        data = [[] for x in range(R)]\\n        for [x, y] in intervals:\\n            data[x].append(y)\\n        ans = []\\n        for x in range(R):\\n            for y in data[x]:\\n                if not ans or x > ans[-1][1]:\\n                    ans.append([x, y])\\n                elif ans[-1][1] < y:\\n                    ans[-1][1] = y\\n        return ans\\n```\\n\\n**Java O(NlogN) Runtime: 5 ms, faster than 95.64%**\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n        ArrayList<int[]> ans = new ArrayList<>(intervals.length);  \\n        for (int i = 0; i < intervals.length; i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.isEmpty() || x > ans.get(ans.size() - 1)[1])\\n                ans.add(intervals[i]);\\n            else if (ans.get(ans.size() - 1)[1] < y)\\n                ans.get(ans.size() - 1)[1] = y;\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [],
                "code": "```\\n\\t\\t        R = max([x for [x, _] in intervals]) + 1\\n\\t\\t\\t\\tdata = [[] for x in range(R)]\\n\\t\\t\\t\\tfor [x, y] in intervals:\\n\\t\\t\\t\\t\\tdata[x].append(y)\\n\\t\\t\\t```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < intervals.size(); i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.empty() || x > ans.back()[1])\\n                ans.push_back(intervals[i]);\\n            else if (ans.back()[1] < y)\\n                ans.back()[1] = y;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        ans = []\\n        for [x, y] in sorted(intervals):\\n            if not ans or x > ans[-1][1]:\\n                ans.append([x, y])\\n            elif ans[-1][1] < y:\\n                ans[-1][1] = y\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        R = max([x for [x, _] in intervals]) + 1\\n        data = [[] for x in range(R)]\\n        for [x, y] in intervals:\\n            data[x].append(y)\\n        ans = []\\n        for x in range(R):\\n            for y in data[x]:\\n                if not ans or x > ans[-1][1]:\\n                    ans.append([x, y])\\n                elif ans[-1][1] < y:\\n                    ans[-1][1] = y\\n        return ans\\n```\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\\n        ArrayList<int[]> ans = new ArrayList<>(intervals.length);  \\n        for (int i = 0; i < intervals.length; i ++) {\\n            int x = intervals[i][0], y = intervals[i][1];\\n            if (ans.isEmpty() || x > ans.get(ans.size() - 1)[1])\\n                ans.add(intervals[i]);\\n            else if (ans.get(ans.size() - 1)[1] < y)\\n                ans.get(ans.size() - 1)[1] = y;\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643943,
                "title": "python3-easy-to-understand-explained",
                "content": "First of all, we have to sort the input intervals by the start value. That will let us easily merge overlapping intervals. We just iterate over sorted intervals and compare the start and the end of adjacent intervals. If the end of the previous interval is greater or equal to the start of the next one, that means we can merge them. To merge two intervals we just expand the end of the previous interval to the end of the next.\\n\\nTime: **O(NlogN)** - sorting\\nSpace: **O(N)** - sorting in Python\\n\\nRuntime: 76 ms, faster than **97.62%** of Python3 online submissions for Merge Intervals.\\nMemory Usage: 16.2 MB, less than **10.13%** of Python3 online submissions for Merge Intervals.\\n\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        sortedInt = sorted(intervals, key = lambda i: i[0])\\n        res = list()\\n\\n        for start, end in sortedInt:\\n            if res and res[-1][1] >= start:\\n                res[-1][1] = max(res[-1][1], end)\\n            else:\\n                res.append([start, end])\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        sortedInt = sorted(intervals, key = lambda i: i[0])\\n        res = list()\\n\\n        for start, end in sortedInt:\\n            if res and res[-1][1] >= start:\\n                res[-1][1] = max(res[-1][1], end)\\n            else:\\n                res.append([start, end])\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408247,
                "title": "simple-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        int n = intervals.length;\\n        if(n==0) return new int[0][0];\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        List<int[]> res = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int[] temp = intervals[i];\\n            int j = i+1;\\n            while(j<n && intervals[j][0]<=temp[1]){\\n                temp[1] = Math.max(temp[1], intervals[j][1]);\\n                j+=1;\\n            }\\n            i = j - 1;\\n            res.add(temp);\\n        }\\n        int m = res.size();\\n        return res.toArray(new int[m][2]);\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        int n = intervals.length;\\n        if(n==0) return new int[0][0];\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        List<int[]> res = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int[] temp = intervals[i];\\n            int j = i+1;\\n            while(j<n && intervals[j][0]<=temp[1]){\\n                temp[1] = Math.max(temp[1], intervals[j][1]);\\n                j+=1;\\n            }\\n            i = j - 1;\\n            res.add(temp);\\n        }\\n        int m = res.size();\\n        return res.toArray(new int[m][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577210,
                "title": "go",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    var res [][]int\\n    i := 0\\n    for i < len(intervals) {\\n        left, right := intervals[i][0], intervals[i][1]\\n        j := i+1\\n        for j < len(intervals) && intervals[j][0] <= right {\\n            right = max(right, intervals[j][1])\\n            j++\\n        }\\n        res = append(res, []int{left, right})\\n        i = j\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    var res [][]int\\n    i := 0\\n    for i < len(intervals) {\\n        left, right := intervals[i][0], intervals[i][1]\\n        j := i+1\\n        for j < len(intervals) && intervals[j][0] <= right {\\n            right = max(right, intervals[j][1])\\n            j++\\n        }\\n        res = append(res, []int{left, right})\\n        i = j\\n    }\\n    \\n    return res\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387369,
                "title": "simple-java-o-n-log-n-solution-for-slow-learners-like-myself",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0)\\n            return new int[0][0];\\n        \\n        Arrays.sort(intervals, ((x, y) -> x[0] - y[0]));\\n        List<int[]> merged = new ArrayList<>();\\n        int[] current = intervals[0];\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (current[1] >= intervals[i][0])\\n                current[1] = Math.max(current[1], intervals[i][1]);\\n            else {\\n                merged.add(current);\\n                current = intervals[i];                \\n            }\\n        }\\n        merged.add(current);\\n        return merged.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals == null || intervals.length == 0)\\n            return new int[0][0];\\n        \\n        Arrays.sort(intervals, ((x, y) -> x[0] - y[0]));\\n        List<int[]> merged = new ArrayList<>();\\n        int[] current = intervals[0];\\n        for (int i = 1; i < intervals.length; i++) {\\n            if (current[1] >= intervals[i][0])\\n                current[1] = Math.max(current[1], intervals[i][1]);\\n            else {\\n                merged.add(current);\\n                current = intervals[i];                \\n            }\\n        }\\n        merged.add(current);\\n        return merged.toArray(new int[0][0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153979,
                "title": "elegant-c-solutions-one-without-modifying-intervals-and-one-inplace",
                "content": "# Without modifying `intervals`\\nSince we can\\'t sort interval, we want to instead ensure our destination vector is sorted. A insertion sort is required then. Insertion should be done as follows;\\n1. Find first destination interval that _ends_ after the incoming interval _starts_. Called _it_\\n2. If no such interval is found or the incoming interval _end_ is less than found intervals _start_ then we can just insert and be done.\\n3. Otherwise there must be an overlap, but it could be more than one. Do another search, this time for the first interval whose _start_ is greater than incoming interval _end_. Called _last_\\n4. Everything from [_it_, _last_) can be merged together with incoming interval into a single interval\\n\\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      std::vector<Interval> ret;\\n      \\n      for (auto& interval : intervals) {\\n        auto it = std::lower_bound(ret.begin(), ret.end(), interval.start, [](const Interval& l, int r) { return l.end < r; });\\n        \\n        if (it == ret.end() || interval.end < it->start) \\n          // No overlap, insert as is\\n          ret.insert(it, interval);\\n        else {\\n          // There is an overlap, there might be more, so find the upper bound too\\n          it->start = std::min(it->start, interval.start);\\n          auto last = std::upper_bound(it, ret.end(), interval.end, [](int l, const Interval& r) { return l < r.start; });\\n          it->end = std::max((last - 1)->end, interval.end);\\n          ret.erase(it + 1, last);\\n        }\\n      }\\n      return ret;\\n    }\\n```\\n\\n# Modifying `intervals`\\nIt would be helpful if the question specified whether or not the intervals are sorted, since the examples provided are sorted (by start). Never the less, once you get over that, and sort the list yourself, there is really only two options to consider.\\n\\n1. Two adjacent intervals don\\'t overlap\\n2. Two adjacent intervals overlap\\n\\nWell the first case is simple, there is nothing to see and we can just move alone to the next pair.\\nIn the second case, we know that _a[i].end_ is greater than or equal to _a[i + 1].start_ or there would be no overlap. Therefore the intervals can and should be merged into one. The merge is quite simple, we know that _a[i].start_ is less or equal to _a[i + 1].start_ since we sorted it that way. Hence the merged interval must start with _a[i].start_. The only other thing to consider is which interval ends last and do a simple max.\\n\\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      if (1 >= intervals.size()) {\\n        return intervals;\\n      }\\n      \\n      std::sort(intervals.begin(), intervals.end(), [](const Interval& l, const Interval& r) { return l.start < r.start; });\\n      \\n      auto curr = intervals.begin();\\n      auto next = curr;\\n      while (++next != intervals.end()) {\\n        if (curr->end >= next->start) {\\n          // There is an overlap, merge the two into the current\\n          curr->end = std::max(curr->end, next->end);\\n        } else {\\n          // There is no overlap, move the next to the end of our accepted intervals\\n          // If one or more preceeding intervals are no longer required, then one will be overwritten here\\n          *(++curr) = *next;\\n        }\\n      }\\n      // Mop up the rest\\n      intervals.erase(curr + 1, intervals.end());\\n      return intervals;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      std::vector<Interval> ret;\\n      \\n      for (auto& interval : intervals) {\\n        auto it = std::lower_bound(ret.begin(), ret.end(), interval.start, [](const Interval& l, int r) { return l.end < r; });\\n        \\n        if (it == ret.end() || interval.end < it->start) \\n          // No overlap, insert as is\\n          ret.insert(it, interval);\\n        else {\\n          // There is an overlap, there might be more, so find the upper bound too\\n          it->start = std::min(it->start, interval.start);\\n          auto last = std::upper_bound(it, ret.end(), interval.end, [](int l, const Interval& r) { return l < r.start; });\\n          it->end = std::max((last - 1)->end, interval.end);\\n          ret.erase(it + 1, last);\\n        }\\n      }\\n      return ret;\\n    }\\n```\n```cpp\\n    vector<Interval> merge(vector<Interval>& intervals) {\\n      if (1 >= intervals.size()) {\\n        return intervals;\\n      }\\n      \\n      std::sort(intervals.begin(), intervals.end(), [](const Interval& l, const Interval& r) { return l.start < r.start; });\\n      \\n      auto curr = intervals.begin();\\n      auto next = curr;\\n      while (++next != intervals.end()) {\\n        if (curr->end >= next->start) {\\n          // There is an overlap, merge the two into the current\\n          curr->end = std::max(curr->end, next->end);\\n        } else {\\n          // There is no overlap, move the next to the end of our accepted intervals\\n          // If one or more preceeding intervals are no longer required, then one will be overwritten here\\n          *(++curr) = *next;\\n        }\\n      }\\n      // Mop up the rest\\n      intervals.erase(curr + 1, intervals.end());\\n      return intervals;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811263,
                "title": "5-line-easy-code-simple-line-by-line-code-explanation-sorting",
                "content": "# \\u2705Intuition \\u2705\\nif the ending time of current intervals is greater than or eqaul to starting time of next interval, in this case overlapping of intervals occuring. in this case we merge these both intervals together.\\nexample:\\n[2,4] [3,6] [7,13] [10,12]\\n\\n1. in above example interval 1 and 2 will be overlap as ending time of 1st interval(which is 4) is greater than starting time of 2nd interval(which is 3). now merged interval range will be [2,6]\\nwe take max(4,6) for find ending  time of merged interval.so intetval will be [2,6]\\n\\n2. now we start comparing of new formed interval to next interval.\\n\\n3. In this time we have to compare [2,6] with [7,13] ,since 6 is less than 7 so here is no interval.\\n\\n4. Last we have [7,13] and [10,12] , since 10 is less than 13 so here will be overlapping. now we have to merge these both intervals but there is question that what will be ending time of merged interval.\\n\\nending time of merged interval will be :: max(13,12) which is 13.\\n \\nso, in this case final merged interval will be [7,13].\\n \\n\\n# Approach\\u2705\\n  Carefully read above intitution part you will find complete answer. how we have to approach this question\\u2705.\\n\\n\\n **if you find helpful, kindly upvote \\uD83D\\uDE80 ... Thanks** \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        for(int i = 0 ; i<n ;i++){\\n            if(ans.empty()){//1st time ans will be empty then simply push_back intervals in ans\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                vector<int>&v = ans.back();\\n                int y = v[1]; // end time of previous intervals compare y with i\\'s start time\\n                //intervals[i][0] ---> means start time || intervals[i][1] --> end time \\n             //in case of overlapping of intervals   \\n             if(intervals[i][0] <= y){//start time next interv. is <=prev. interval(overlap)\\n                //[2,4] [3,5] ---->merged interval will[2,5],end point will be max(4,5) \\n                   v[1] = max(intervals[i][1] , y);\\n                }\\n                // in case of no overlapping\\n                else{\\n                   ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Brainteaser",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>>ans;\\n        for(int i = 0 ; i<n ;i++){\\n            if(ans.empty()){//1st time ans will be empty then simply push_back intervals in ans\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                vector<int>&v = ans.back();\\n                int y = v[1]; // end time of previous intervals compare y with i\\'s start time\\n                //intervals[i][0] ---> means start time || intervals[i][1] --> end time \\n             //in case of overlapping of intervals   \\n             if(intervals[i][0] <= y){//start time next interv. is <=prev. interval(overlap)\\n                //[2,4] [3,5] ---->merged interval will[2,5],end point will be max(4,5) \\n                   v[1] = max(intervals[i][1] , y);\\n                }\\n                // in case of no overlapping\\n                else{\\n                   ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777963,
                "title": "c-sc-o-1-without-using-another-data-structure-i-e-in-place-solution",
                "content": "# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end());\\n\\n        for(int i = 1;i < v.size();){\\n            if(v[i - 1][1] >= v[i][0]){\\n                v[i - 1][1] = max(v[i][1],v[i - 1][1]);\\n                v.erase(v.begin() + i);\\n            }\\n            else i++;\\n            // why i++ in else (dry run this TC)\\n            // [0,2],[1,4],[3,5]\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end());\\n\\n        for(int i = 1;i < v.size();){\\n            if(v[i - 1][1] >= v[i][0]){\\n                v[i - 1][1] = max(v[i][1],v[i - 1][1]);\\n                v.erase(v.begin() + i);\\n            }\\n            else i++;\\n            // why i++ in else (dry run this TC)\\n            // [0,2],[1,4],[3,5]\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452633,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1){\\n            return intervals;\\n        } \\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]){\\n                output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            } \\n            else{\\n                output.push_back(intervals[i]); \\n            }\\n        }\\n        return output;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size()<=1){\\n            return intervals;\\n        } \\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        output.push_back(intervals[0]);\\n        for(int i=1; i<intervals.size(); i++) {\\n            if(output.back()[1] >= intervals[i][0]){\\n                output.back()[1] = max(output.back()[1] , intervals[i][1]);\\n            } \\n            else{\\n                output.push_back(intervals[i]); \\n            }\\n        }\\n        return output;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058812,
                "title": "simple-c-sorting-merging",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all we should sort so that we can do linear search ,otherwise we have to do it in O(n^2) because if unsorted then some intervals will be left at end some will be at begining so if we sort we will have contiguous intervals and then we can merge them in linear fashion.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just check if intervals are overlapping and if are then just merge \\nand this can be done by two operations :\\n- `min(a[1], b[1]) - max(a[0], b[0]) >= 0;` can be used to detect if some element is common between two intervals u can just take an exapmple and dry run it.\\n- `{min(a[0], b[0]), max(a[1], b[1])};` gives us the resulting merged interval.\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool doesIntervalsOverlap(vector<int>& a, vector<int>& b) {\\n        return min(a[1], b[1]) - max(a[0], b[0]) >= 0;\\n    }\\n\\n     vector<int> mergeIntervals(vector<int>& a, vector<int>& b) {\\n        return {min(a[0], b[0]), max(a[1], b[1])};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& inv) {\\n        int n=inv.size();\\n        vector<vector<int>>v;\\n        int i=0;\\n        sort(inv.begin(),inv.end());\\n        while(i<n){\\n            vector<int>curr=inv[i++];\\n            vector<int>merge=curr;\\n           while(i<n and doesIntervalsOverlap(curr,inv[i])){\\n               merge=mergeIntervals(curr,inv[i]);\\n               curr=merge;\\n               i++;\\n           }\\n           v.push_back(merge);\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool doesIntervalsOverlap(vector<int>& a, vector<int>& b) {\\n        return min(a[1], b[1]) - max(a[0], b[0]) >= 0;\\n    }\\n\\n     vector<int> mergeIntervals(vector<int>& a, vector<int>& b) {\\n        return {min(a[0], b[0]), max(a[1], b[1])};\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& inv) {\\n        int n=inv.size();\\n        vector<vector<int>>v;\\n        int i=0;\\n        sort(inv.begin(),inv.end());\\n        while(i<n){\\n            vector<int>curr=inv[i++];\\n            vector<int>merge=curr;\\n           while(i<n and doesIntervalsOverlap(curr,inv[i])){\\n               merge=mergeIntervals(curr,inv[i]);\\n               curr=merge;\\n               i++;\\n           }\\n           v.push_back(merge);\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051071,
                "title": "c-easy-solution-with-explanation",
                "content": "\\n# Approach\\nSort the given array intervals.\\nConsider a new array answer. Insert into it the first elements of intervals. Now consider the next elements of intervals. If the smaller number of next elements of intervals is less than or equal to larger number of previous elements, update the larger number of previous elements by maximum of the larger number of both elements.\\nOtherwise, simply insert the next elements in the answer.   \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        int i=0;\\n        int j=0;\\n        sort(intervals.begin(),intervals.end());\\n        ans.push_back(intervals[0]);//insert the first element\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=ans[j][1]){\\n                //update previous element\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else{\\n                //add new element to answer\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        \\n        int i=0;\\n        int j=0;\\n        sort(intervals.begin(),intervals.end());\\n        ans.push_back(intervals[0]);//insert the first element\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=ans[j][1]){\\n                //update previous element\\n                ans[j][1]=max(ans[j][1],intervals[i][1]);\\n            }\\n            else{\\n                //add new element to answer\\n                ans.push_back(intervals[i]);\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285879,
                "title": "c-easy-explanation-brute-to-optimal-interview-prep",
                "content": "# Intuition\\n- First we will check if the array of intervals given is already `sorted or not`.\\n- If not then we will `sort` it .\\n- Then we for merging we will check if the `first index of second interval is less than second index of first interval`.\\n- If the above case satisfies then we will merge them otherwise we will push that interval as it is in the result and use it for further comparison.\\n- The above logic is more explained in the approaches below.\\n# Approaches\\n## 1.Brute Force\\n- `Sorting` the intervals in ascending order.\\n- Using `2 loops` for $$iterating$$ and `linear searching of interval`.\\n- `Outer loop` is for iterating the array .\\n- `Inner Loop` is for linear search that if the any interval is overlapping with the interval of the current iteration.\\n### Code\\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& arr) {\\n    int n = arr.size(); // Get the size of the input vector\\n    sort(arr.begin(), arr.end()); // Sort the intervals based on their starting points\\n    vector<vector<int>> ans; // Initialize an empty vector to store the merged intervals\\n\\n    for (int i = 0; i < n; i++) { // Iterate through each interval\\n        int start = arr[i][0], end = arr[i][1];\\n\\n        // If the last interval in the merged intervals vector overlaps with the current interval, skip the current interval\\n        if (!ans.empty()) {\\n            if (start <= ans.back()[1]) {\\n                continue;\\n            }\\n        }\\n\\n        // Iterate through the remaining intervals and merge overlapping intervals\\n        for (int j = i + 1; j < n; j++) {\\n            if (arr[j][0] <= end) {\\n                end = max(end, arr[j][1]);\\n            }\\n        }\\n\\n        // Store the merged interval in the answer vector\\n        end = max(end, arr[i][1]);\\n        ans.push_back({start, end});\\n    }\\n\\n    return ans; // Return the merged intervals\\n}\\n```\\n### Complexity\\n- **Time Complexity** - $O(NlogN)+O(N*N). O(NlogN)$\\n- **Space Complexity** - $O(N)$\\n## 2. Optimal Approach\\n- Linearly iterate over the array if the data structure is empty insert the interval in the data structure.\\n- If the last element in the data structure overlaps with the current interval we merge the intervals by updating the last element in the data structure, and if the current interval does not overlap with the last element in the data structure simply insert it into the data structure.\\n- Since we have sorted the intervals, the intervals which will be merging are bound to be adjacent. \\n- We `kept on merging simultaneously` as we were traversing through the array and when the element was non-overlapping we simply inserted the element in our data structure.\\n### Code\\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    vector<vector<int>> mergedInterval; // Initialize an empty vector to store merged intervals\\n    if(intervals.size()==0)\\n      {\\n        return mergedInterval;\\n      }\\n    sort(intervals.begin(),intervals.end()); // Sort the input intervals based on the start time\\n\\n    vector<int> tempInterval = intervals[0]; // Initialize a temporary interval with the first interval in the sorted list\\n\\n    for(auto i:intervals)\\n    {\\n        if(i[0]<= tempInterval[1]) // If the current interval\\'s start time is less than or equal to the end time of the temporary interval\\n        {\\n            tempInterval[1]=max(i[1],tempInterval[1]); // Update the end time of the temporary interval with the maximum of the end times of current interval and the temporary interval\\n        }\\n        else\\n        {\\n            mergedInterval.push_back(tempInterval); // If the current interval\\'s start time is greater than the end time of the temporary interval, push the temporary interval into the merged intervals vector\\n            tempInterval = i; // Update the temporary interval with the current interval\\n        }\\n    }\\n    mergedInterval.push_back(tempInterval); // Push the last temporary interval into the merged intervals vector\\n    return mergedInterval; // Return the merged intervals vector\\n}\\n```\\n### Complexity\\n- **Time Complexity -** $O(NlogN) + O(N). O(NlogN)$\\n- **Space Complexity -** $O(N)$\\n\\n**Thank You!** for reading . Do upvote\\uD83D\\uDC4Dif you like the explanantion and if there is any scope of improvement do mention it in the comments  \\uD83D\\uDE01.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\nvector<vector<int>> merge(vector<vector<int>>& arr) {\\n    int n = arr.size(); // Get the size of the input vector\\n    sort(arr.begin(), arr.end()); // Sort the intervals based on their starting points\\n    vector<vector<int>> ans; // Initialize an empty vector to store the merged intervals\\n\\n    for (int i = 0; i < n; i++) { // Iterate through each interval\\n        int start = arr[i][0], end = arr[i][1];\\n\\n        // If the last interval in the merged intervals vector overlaps with the current interval, skip the current interval\\n        if (!ans.empty()) {\\n            if (start <= ans.back()[1]) {\\n                continue;\\n            }\\n        }\\n\\n        // Iterate through the remaining intervals and merge overlapping intervals\\n        for (int j = i + 1; j < n; j++) {\\n            if (arr[j][0] <= end) {\\n                end = max(end, arr[j][1]);\\n            }\\n        }\\n\\n        // Store the merged interval in the answer vector\\n        end = max(end, arr[i][1]);\\n        ans.push_back({start, end});\\n    }\\n\\n    return ans; // Return the merged intervals\\n}\\n```\n```cpp\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    vector<vector<int>> mergedInterval; // Initialize an empty vector to store merged intervals\\n    if(intervals.size()==0)\\n      {\\n        return mergedInterval;\\n      }\\n    sort(intervals.begin(),intervals.end()); // Sort the input intervals based on the start time\\n\\n    vector<int> tempInterval = intervals[0]; // Initialize a temporary interval with the first interval in the sorted list\\n\\n    for(auto i:intervals)\\n    {\\n        if(i[0]<= tempInterval[1]) // If the current interval\\'s start time is less than or equal to the end time of the temporary interval\\n        {\\n            tempInterval[1]=max(i[1],tempInterval[1]); // Update the end time of the temporary interval with the maximum of the end times of current interval and the temporary interval\\n        }\\n        else\\n        {\\n            mergedInterval.push_back(tempInterval); // If the current interval\\'s start time is greater than the end time of the temporary interval, push the temporary interval into the merged intervals vector\\n            tempInterval = i; // Update the temporary interval with the current interval\\n        }\\n    }\\n    mergedInterval.push_back(tempInterval); // Push the last temporary interval into the merged intervals vector\\n    return mergedInterval; // Return the merged intervals vector\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1755996,
                "title": "merge-intervals",
                "content": "class Solution{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a)\\n\\t{\\n         vector<vector<int>> res;\\n        \\n         if (a.size() == 0)\\n            return res;\\n        \\n        sort(a.begin(), a.end());\\n        res.push_back(a[0]);\\n        int j = 0;\\n        for (int i = 1; i < a.size(); i++)\\n        {\\n            if (res[j][1] >= a[i][0])\\n            {\\n                res[j][1] = max(res[j][1], a[i][1]);\\n            }\\n            else\\n            {\\n                res.push_back(a[i]);\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& a)\\n\\t{\\n         vector<vector<int>> res;\\n        \\n         if (a.size() == 0)\\n            return res;\\n        \\n        sort(a.begin(), a.end());\\n        res.push_back(a[0]);\\n        int j = 0;\\n        for (int i = 1; i < a.size(); i++)\\n        {\\n            if (res[j][1] >= a[i][0])\\n            {\\n                res[j][1] = max(res[j][1], a[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1660021,
                "title": "java-simple-and-clean-solution-understandable-explanation",
                "content": "1) First we sort the list based on interval[i][0];\\n2) Compare end of current to start of next -\\n\\ti) if end of current is larger than start of next then we merge the interval but not add to list to check further intervals(we track this with s,e,start and end variables)\\n\\tii) if above condition is not met then we add interval to list(start,end).\\n3. we convert list to array and return.\\n\\n```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals,(o1,o2)->Integer.compare(o1[0], o2[0]));\\n        List<int[]> ansList = new ArrayList<int[]>();\\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        int e,s;\\n        int i =0;\\n        int[] newInterval = intervals[0];\\n        while(i<intervals.length)\\n        {\\n            s = intervals[i][0];\\n            e = intervals[i][1];\\n            if(s<=end)\\n                end = Math.max(end,e);\\n            else\\n            {\\n                ansList.add(new int[]{start,end});\\n                start = s;\\n                end =  e;  \\n            }\\n            i++;\\n        }\\n        ansList.add(new int[] {start,end});\\n        return ansList.toArray(new int[ansList.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals,(o1,o2)->Integer.compare(o1[0], o2[0]));\\n        List<int[]> ansList = new ArrayList<int[]>();\\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        int e,s;\\n        int i =0;\\n        int[] newInterval = intervals[0];\\n        while(i<intervals.length)\\n        {\\n            s = intervals[i][0];\\n            e = intervals[i][1];\\n            if(s<=end)\\n                end = Math.max(end,e);\\n            else\\n            {\\n                ansList.add(new int[]{start,end});\\n                start = s;\\n                end =  e;  \\n            }\\n            i++;\\n        }\\n        ansList.add(new int[] {start,end});\\n        return ansList.toArray(new int[ansList.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067545,
                "title": "python-beats-90",
                "content": "```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not intervals or len(intervals) == 1:\\n            return intervals\\n        \\n        intervals = sorted(intervals, key=lambda x: x[0])\\n        \\n        mergedIntervals = []\\n        \\n        for interval in intervals:\\n            if not mergedIntervals or interval[0] > mergedIntervals[-1][1]:\\n                mergedIntervals.append(interval)\\n            else:\\n                mergedIntervals[-1][1] = max(interval[1], mergedIntervals[-1][1])\\n        \\n        return mergedIntervals\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        if not intervals or len(intervals) == 1:\\n            return intervals\\n        \\n        intervals = sorted(intervals, key=lambda x: x[0])\\n        \\n        mergedIntervals = []\\n        \\n        for interval in intervals:\\n            if not mergedIntervals or interval[0] > mergedIntervals[-1][1]:\\n                mergedIntervals.append(interval)\\n            else:\\n                mergedIntervals[-1][1] = max(interval[1], mergedIntervals[-1][1])\\n        \\n        return mergedIntervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940485,
                "title": "simple-o-nlogn-solution-sort-and-merge",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        intervals.sort(key=lambda x: x[0])\\n        begin, end = intervals[0][0], intervals[0][1]\\n        for interval in intervals[1:]:\\n            if interval[0] <= end:\\n                end = max(end, interval[1])\\n            else:\\n                result.append([begin, end])\\n                begin, end = interval[0], interval[1]\\n        result.append([begin, end])\\n        return result\\n```\\n\\nExplanation:-\\n```\\n1. sort the input, where key is starting time/frist value\\n2. We pick the first interval from the input and iterate over remaining intervals to see which of the following intervals can we merge with the previous interval\\n3. since intervals were sorted based on first value we try to find the overlap by comparing start value of new interval with end value of previous interval\\n4. if there is no overlapping portion, we append previous interval to the output/answer and we reset what is considered to be previous interval\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        intervals.sort(key=lambda x: x[0])\\n        begin, end = intervals[0][0], intervals[0][1]\\n        for interval in intervals[1:]:\\n            if interval[0] <= end:\\n                end = max(end, interval[1])\\n            else:\\n                result.append([begin, end])\\n                begin, end = interval[0], interval[1]\\n        result.append([begin, end])\\n        return result\\n```\n```\\n1. sort the input, where key is starting time/frist value\\n2. We pick the first interval from the input and iterate over remaining intervals to see which of the following intervals can we merge with the previous interval\\n3. since intervals were sorted based on first value we try to find the overlap by comparing start value of new interval with end value of previous interval\\n4. if there is no overlapping portion, we append previous interval to the output/answer and we reset what is considered to be previous interval\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874757,
                "title": "help-please-line-1052-char-9-runtime-error-reference-binding-to-null-pointer-of-type",
                "content": "\\nMy code is failing at the 168th test case and I\\'m getting this error, I\\'m not sure why this error is coming, this error is generally encountered due to out of bounds exception, but I don\\'t think there is any problem in my code? Can someone please help me identify the error and help me understand it. Thank you.\\n\\nExact Error: Line 1052: Char 9: runtime error: reference binding to null pointer of type \\'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type\\' (aka \\'const int\\') (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9\\n\\n\\n```\\n bool myComp(const vector<int>& v1, const vector<int>& v2) {\\n        if (v1[0] != v2[0]) {\\n            return v1[0] < v2[0];\\n        } else if (v1[1] != v2[1]) {\\n            return v1[1] < v2[1];\\n        }\\n        return true;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    \\n   \\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        \\n        \\n        if (intervals.empty()) {\\n            return intervals;\\n        }\\n        if (intervals.size() <= 1) {\\n            return intervals;\\n        }\\n        \\n         vector<vector<int>> out;\\n      \\n        sort(intervals.begin(), intervals.end(), myComp);\\n        \\n        \\n        \\n        out.push_back(intervals[0]);\\n        \\n        vector<int> currInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); i++) {\\n            \\n            \\n            if (intervals[i][0] <= currInterval[1]) {\\n                \\n                out[out.size()-1][1] = max(currInterval[1], intervals[i][1]);\\n                currInterval = out[out.size()-1];\\n                \\n            } else {\\n                out.push_back(intervals[i]);\\n                currInterval = intervals[i];\\n            }\\n            \\n        }\\n        return out;\\n        \\n        \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n bool myComp(const vector<int>& v1, const vector<int>& v2) {\\n        if (v1[0] != v2[0]) {\\n            return v1[0] < v2[0];\\n        } else if (v1[1] != v2[1]) {\\n            return v1[1] < v2[1];\\n        }\\n        return true;\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    \\n   \\n    \\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        \\n        \\n        if (intervals.empty()) {\\n            return intervals;\\n        }\\n        if (intervals.size() <= 1) {\\n            return intervals;\\n        }\\n        \\n         vector<vector<int>> out;\\n      \\n        sort(intervals.begin(), intervals.end(), myComp);\\n        \\n        \\n        \\n        out.push_back(intervals[0]);\\n        \\n        vector<int> currInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); i++) {\\n            \\n            \\n            if (intervals[i][0] <= currInterval[1]) {\\n                \\n                out[out.size()-1][1] = max(currInterval[1], intervals[i][1]);\\n                currInterval = out[out.size()-1];\\n                \\n            } else {\\n                out.push_back(intervals[i]);\\n                currInterval = intervals[i];\\n            }\\n            \\n        }\\n        return out;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590996,
                "title": "my-c-code",
                "content": "inplace\\n```\\nint cmpfunc(int** a, int** b)\\n{\\n    return (*a)[0] - (*b)[0];\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    int* temp=NULL;\\n    int i;\\n    int count = 0;\\n    \\n    if((intervals==NULL) || (intervalsSize==0))\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    qsort(intervals, intervalsSize,sizeof(int*),cmpfunc);\\n    \\n    temp = intervals[0];\\n    for(i=1;i<intervalsSize;i++)\\n    {\\n        if(temp[1] >= intervals[i][0])\\n        {\\n            temp[1] = (temp[1] > intervals[i][1])?temp[1]:intervals[i][1];\\n        }\\n        else\\n        {\\n            intervals[count][0] = temp[0];\\n            intervals[count][1] = temp[1];\\n            count++;\\n            temp = intervals[i];\\n        }\\n    }\\n    intervals[count][0] = temp[0];\\n    intervals[count][1] = temp[1];\\n    count++;\\n\\n    *returnSize = count;\\n    (*returnColumnSizes) = (int*)malloc(count*sizeof(int));\\n    for(i=0;i<count;i++)\\n    {\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    return intervals;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(int** a, int** b)\\n{\\n    return (*a)[0] - (*b)[0];\\n}\\n\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *returnColumnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){\\n    int* temp=NULL;\\n    int i;\\n    int count = 0;\\n    \\n    if((intervals==NULL) || (intervalsSize==0))\\n    {\\n        *returnSize = 0;\\n        return NULL;\\n    }\\n    qsort(intervals, intervalsSize,sizeof(int*),cmpfunc);\\n    \\n    temp = intervals[0];\\n    for(i=1;i<intervalsSize;i++)\\n    {\\n        if(temp[1] >= intervals[i][0])\\n        {\\n            temp[1] = (temp[1] > intervals[i][1])?temp[1]:intervals[i][1];\\n        }\\n        else\\n        {\\n            intervals[count][0] = temp[0];\\n            intervals[count][1] = temp[1];\\n            count++;\\n            temp = intervals[i];\\n        }\\n    }\\n    intervals[count][0] = temp[0];\\n    intervals[count][1] = temp[1];\\n    count++;\\n\\n    *returnSize = count;\\n    (*returnColumnSizes) = (int*)malloc(count*sizeof(int));\\n    for(i=0;i<count;i++)\\n    {\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    return intervals;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 365871,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals.length <= 1)\\n            return intervals;\\n        \\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n        int[] newInterval = intervals[0];\\n        result.add(newInterval);\\n        for(int[] interval : intervals){\\n            if(newInterval[1] >= interval[0])\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            else{\\n                newInterval = interval;\\n                result.add(newInterval);\\n            }\\n        }\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```\\n\\nRuntime: 38 ms, faster than 25.25% of Java online submissions for Merge Intervals.\\nMemory Usage: 37.4 MB, less than 98.55% of Java online submissions for Merge Intervals.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals.length <= 1)\\n            return intervals;\\n        \\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));\\n        \\n        List<int[]> result = new ArrayList<>();\\n        int[] newInterval = intervals[0];\\n        result.add(newInterval);\\n        for(int[] interval : intervals){\\n            if(newInterval[1] >= interval[0])\\n                newInterval[1] = Math.max(newInterval[1], interval[1]);\\n            else{\\n                newInterval = interval;\\n                result.add(newInterval);\\n            }\\n        }\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354775,
                "title": "python-short-and-easy-to-understand-solution-0-nlog-n",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x[0]):\\n            if res and i[0]<=res[-1][1]:\\n                 res[-1][1] = max(i[1], res[-1][1])\\n            else:\\n                res +=[i]\\n        return res\\n\\t\\t\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in sorted(intervals, key=lambda x:x[0]):\\n            if res and i[0]<=res[-1][1]:\\n                 res[-1][1] = max(i[1], res[-1][1])\\n            else:\\n                res +=[i]\\n        return res\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 295485,
                "title": "two-java-solutions-with-updated-input",
                "content": "The input of this question has been changed from `List<Interval>` to `int[][] intervals`. \\nHere are two solutions based on sorting the input. \\nTheoretically, both of their runtimes are `O(nlogn)` from sorting. \\nI personally like Solution1, but somehow Solution2 runs faster. \\n\\nSolution 1: \\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;   \\n        int len = intervals.length; \\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0])); // O(nlogn)\\n        int start = intervals[0][0]; \\n        int end = intervals[0][1]; \\n        \\n        List<int[]> result = new ArrayList<>(); \\n        \\n        for(int[] interval : intervals){\\n            if(interval[0] <= end){\\n                end = Math.max(end, interval[1]); \\n            }\\n            else{\\n                result.add(new int[]{start, end}); \\n                start = interval[0]; \\n                end = interval[1]; \\n            }\\n        }\\n        result.add(new int[]{start, end}); \\n\\t\\t\\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```\\n\\nSolution2: \\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;\\n        \\n        int len = intervals.length; \\n        int[] starts = new int[len]; \\n        int[] ends = new int[len]; \\n        \\n        for(int i = 0; i < len; i++){\\n            starts[i] = intervals[i][0]; \\n            ends[i] = intervals[i][1]; \\n        }\\n        \\n        Arrays.sort(starts); // O(nlogn)\\n        Arrays.sort(ends); \\n        \\n        int i = 0;   // i -> index for starts[]\\n        int j = 0;   // j -> index for ends[]\\n        List<int[]> result = new ArrayList<>(); \\n        \\n        while(j < len){   // j will be the index that travals faster. No need to worry about i here\\n            if(j == len - 1 || starts[j + 1] > ends[j]){   // if j reaches the end, add the last interval to result\\n                result.add(new int[]{starts[i], ends[j]}); \\n                i = j + 1; \\n            }\\n            j++; \\n        }\\n        \\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;   \\n        int len = intervals.length; \\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0])); // O(nlogn)\\n        int start = intervals[0][0]; \\n        int end = intervals[0][1]; \\n        \\n        List<int[]> result = new ArrayList<>(); \\n        \\n        for(int[] interval : intervals){\\n            if(interval[0] <= end){\\n                end = Math.max(end, interval[1]); \\n            }\\n            else{\\n                result.add(new int[]{start, end}); \\n                start = interval[0]; \\n                end = interval[1]; \\n            }\\n        }\\n        result.add(new int[]{start, end}); \\n\\t\\t\\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```\n```\\n    public int[][] merge(int[][] intervals) {\\n        if(intervals == null || intervals.length <= 1) return intervals;\\n        \\n        int len = intervals.length; \\n        int[] starts = new int[len]; \\n        int[] ends = new int[len]; \\n        \\n        for(int i = 0; i < len; i++){\\n            starts[i] = intervals[i][0]; \\n            ends[i] = intervals[i][1]; \\n        }\\n        \\n        Arrays.sort(starts); // O(nlogn)\\n        Arrays.sort(ends); \\n        \\n        int i = 0;   // i -> index for starts[]\\n        int j = 0;   // j -> index for ends[]\\n        List<int[]> result = new ArrayList<>(); \\n        \\n        while(j < len){   // j will be the index that travals faster. No need to worry about i here\\n            if(j == len - 1 || starts[j + 1] > ends[j]){   // if j reaches the end, add the last interval to result\\n                result.add(new int[]{starts[i], ends[j]}); \\n                i = j + 1; \\n            }\\n            j++; \\n        }\\n        \\n        return result.toArray(new int[result.size()][2]); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21241,
                "title": "swift-o-n-log-n-solution-with-inline-comments",
                "content": "Brief Swift implementation with step by step comments.\\n```\\nclass Solution {\\n    func merge(_ intervals: [Interval]) -> [Interval] {\\n        var result: [Interval] = []\\n        // sort the intervals by start so we can test for overlaps sequentially\\n        let intervalsSorted = intervals.sorted(by: {$0.start < $1.start})\\n        \\n        // iterate the intervals\\n        for interval in intervalsSorted {\\n            // does the current interval overlap the last\\n            if !result.isEmpty && interval.start <= result.last!.end {\\n                // there is overlap, rewrite the last interval with the\\n                // higher end value, the start value must be <= current\\n                // due to the prior sort\\n                result.last!.end = max(result.last!.end, interval.end)\\n            } else {\\n                // no overlap (or no last), append current interval\\n                result.append(interval)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func merge(_ intervals: [Interval]) -> [Interval] {\\n        var result: [Interval] = []\\n        // sort the intervals by start so we can test for overlaps sequentially\\n        let intervalsSorted = intervals.sorted(by: {$0.start < $1.start})\\n        \\n        // iterate the intervals\\n        for interval in intervalsSorted {\\n            // does the current interval overlap the last\\n            if !result.isEmpty && interval.start <= result.last!.end {\\n                // there is overlap, rewrite the last interval with the\\n                // higher end value, the start value must be <= current\\n                // due to the prior sort\\n                result.last!.end = max(result.last!.end, interval.end)\\n            } else {\\n                // no overlap (or no last), append current interval\\n                result.append(interval)\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21474,
                "title": "14ms-java-in-place-merge-solution",
                "content": "    public class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        int N = intervals.size();\\n        Collections.sort(intervals, new Comparator<Interval>(){\\n        \\tpublic int compare(Interval i, Interval j){\\n                    return i.end - j.end;\\n        \\t}\\n        });\\n        for(int i = N-1; i>0;i--){\\n            Interval inter1 = intervals.get(i-1);\\n\\t        Interval inter2 = intervals.get(i);\\n\\t        if(inter1.end >= inter2.start){\\n\\t            inter1.start = Math.min(inter1.start, inter2.start);\\n\\t            inter1.end = inter2.end; //inter1.end is always smaller than inter2.end because of the sort, so no need to use Math.max()\\n\\t            intervals.remove(i);\\n\\t        }\\n\\t    }\\n        return intervals;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        int N = intervals.size();\\n        Collections.sort(intervals, new Comparator<Interval>(){\\n        \\tpublic int compare(Interval i, Interval j){\\n                    return i.end - j.end;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 3432844,
                "title": "easy-python-solution-with-linear-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals=sorted(intervals)\\n        res=[intervals[0]]\\n        for start,end in intervals[1:]:\\n            lastEnd=res[-1][1]\\n            if lastEnd>=start:\\n                res[-1][1]=max(lastEnd,end)\\n            else:\\n                res.append([start,end])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals=sorted(intervals)\\n        res=[intervals[0]]\\n        for start,end in intervals[1:]:\\n            lastEnd=res[-1][1]\\n            if lastEnd>=start:\\n                res[-1][1]=max(lastEnd,end)\\n            else:\\n                res.append([start,end])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425508,
                "title": "awesome-logic-problems",
                "content": "\\n\\n# Python solutions\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x:x[0])\\n        list1=[intervals[0]]\\n        for i ,j in intervals[1:]:\\n            if list1[-1][1]>=i:\\n                list1[-1][1]=max(list1[-1][1],j)\\n            else:\\n                list1.append([i,j])\\n        return list1\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x:x[0])\\n        list1=[intervals[0]]\\n        for i ,j in intervals[1:]:\\n            if list1[-1][1]>=i:\\n                list1[-1][1]=max(list1[-1][1],j)\\n            else:\\n                list1.append([i,j])\\n        return list1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379595,
                "title": "best-o-nlogn-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort (intervals.begin(), intervals.end());\\n        vector<vector<int>> merged;\\n        for (int i = 0; i < n; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            if (!merged.empty()) {\\n                auto last = merged.back();\\n                if (end <= last[1])\\n                    continue;\\n            }  \\n            for (int j = i + 1; j < n; j++) {\\n                if (intervals[j][0] <= end) \\n                    end = max (intervals[j][1], end);\\n            }\\n            merged.push_back({start, end});\\n        }\\n        return merged;\\n    }\\n};\\n```\\n\\n# Approach 2\\nSorting\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> merged;\\n        if (intervals.size() == 0)\\n            return merged;\\n        sort (intervals.begin(), intervals.end());\\n        vector <int> cur = intervals[0];\\n        for (auto it : intervals) {\\n            if (it[0] <= cur[1]) {\\n                cur[1] = max (it[1], cur[1]);\\n            } else {\\n                merged.push_back(cur);\\n                cur = it;\\n            }\\n        }\\n        merged.push_back(cur);\\n        return merged;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort (intervals.begin(), intervals.end());\\n        vector<vector<int>> merged;\\n        for (int i = 0; i < n; i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            if (!merged.empty()) {\\n                auto last = merged.back();\\n                if (end <= last[1])\\n                    continue;\\n            }  \\n            for (int j = i + 1; j < n; j++) {\\n                if (intervals[j][0] <= end) \\n                    end = max (intervals[j][1], end);\\n            }\\n            merged.push_back({start, end});\\n        }\\n        return merged;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> merged;\\n        if (intervals.size() == 0)\\n            return merged;\\n        sort (intervals.begin(), intervals.end());\\n        vector <int> cur = intervals[0];\\n        for (auto it : intervals) {\\n            if (it[0] <= cur[1]) {\\n                cur[1] = max (it[1], cur[1]);\\n            } else {\\n                merged.push_back(cur);\\n                cur = it;\\n            }\\n        }\\n        merged.push_back(cur);\\n        return merged;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338016,
                "title": "you-got-it-in-single-sight",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>&ii) {\\n        sort(ii.begin(),ii.end());\\n        vector<vector<int>>ans;\\n        int n=ii.size();\\n        int a=ii[0][0];\\n        int b=ii[0][1];\\n        for(int i=1;i<n;i++){\\n            if(ii[i][0]<=b){\\n                b=max(b,ii[i][1]);\\n            }\\n            else{\\n                ans.push_back({a,b});\\n                a=ii[i][0];\\n                b=ii[i][1];\\n\\n            }\\n        }\\n        ans.push_back({a,b});\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>&ii) {\\n        sort(ii.begin(),ii.end());\\n        vector<vector<int>>ans;\\n        int n=ii.size();\\n        int a=ii[0][0];\\n        int b=ii[0][1];\\n        for(int i=1;i<n;i++){\\n            if(ii[i][0]<=b){\\n                b=max(b,ii[i][1]);\\n            }\\n            else{\\n                ans.push_back({a,b});\\n                a=ii[i][0];\\n                b=ii[i][1];\\n\\n            }\\n        }\\n        ans.push_back({a,b});\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321081,
                "title": "best-c-solution-using-by-reference-vector-and-implementation",
                "content": "# Intuition :\\nObserve the pattern is more clear in case of sorted vector.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : \\nImplementation based \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)+O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n      sort(intervals.begin(), intervals.end());//So that it becomes easier to merge all the smaller intervals first\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n          vector<int> &temp= ans.back();//Accessing last element fo ans vector\\n          if(temp[1]>=intervals[i][0]){\\n            //updating it . This change will also get reflected in ans vector as we have taken temp vector as by reference \\n            temp[1]=max(temp[1], intervals[i][1]);\\n          }\\n          else ans.push_back(intervals[i]);// Just push the element if condition doesn\\'t matched or satisfied\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n      sort(intervals.begin(), intervals.end());//So that it becomes easier to merge all the smaller intervals first\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n          vector<int> &temp= ans.back();//Accessing last element fo ans vector\\n          if(temp[1]>=intervals[i][0]){\\n            //updating it . This change will also get reflected in ans vector as we have taken temp vector as by reference \\n            temp[1]=max(temp[1], intervals[i][1]);\\n          }\\n          else ans.push_back(intervals[i]);// Just push the element if condition doesn\\'t matched or satisfied\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016465,
                "title": "java-solution-using-stack-and-sorting-o-nlogn",
                "content": "# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    // 8 Jaynary 2023\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a1,a2)-> a1[0]-a2[0]); // O(NlogN)\\n\\n        Stack<int[]> stack = new Stack<>(); //O(N)\\n        stack.push(intervals[0]);\\n        int i=1;\\n        while(!stack.isEmpty() && i < intervals.length){ //O(N)\\n            int[] current = stack.peek();\\n            int[] next = intervals[i++];\\n            if(current[1]>=next[0]){\\n                stack.pop();\\n                current[1] = Math.max(current[1], next[1]);\\n                stack.push(current);\\n            }else{\\n                stack.push(next);\\n            }\\n        }\\n\\n        return stack.toArray(new int[stack.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    // 8 Jaynary 2023\\n    public int[][] merge(int[][] intervals) {\\n        Arrays.sort(intervals, (a1,a2)-> a1[0]-a2[0]); // O(NlogN)\\n\\n        Stack<int[]> stack = new Stack<>(); //O(N)\\n        stack.push(intervals[0]);\\n        int i=1;\\n        while(!stack.isEmpty() && i < intervals.length){ //O(N)\\n            int[] current = stack.peek();\\n            int[] next = intervals[i++];\\n            if(current[1]>=next[0]){\\n                stack.pop();\\n                current[1] = Math.max(current[1], next[1]);\\n                stack.push(current);\\n            }else{\\n                stack.push(next);\\n            }\\n        }\\n\\n        return stack.toArray(new int[stack.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848227,
                "title": "intuitive-c-solution-tc-o-nlogn-sc-o-n-single-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf two intervals are overlapping, the new interval will start from the starting time of the first interval and end at the ending time of the maximum end time of the two intervals.\\n\\nThis approach can be generalised for n intervals: If n intervals are overlapping, the resultant interval will start at the starting time of the first interval and end at the ending time of the maximum end time of the n intervals.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the given \\'intervals\\' array. This will ensure that the interval with the lowest starting time is at the beginning.\\n\\nIterate the entire array and initialize a variable \\'maxEnd\\' as the ending value of the ith interval. Also, initialize another variable \\'j\\' with the value after the ith interval.\\n\\nNow, while j is less than the size of the array and the starting time of j is less than (or equal to) maxEnd, assign maxEnd the maximum value of maxEnd and ending time. Finally, increment j.\\n\\nOnce loop is exited (upon either or both conditions being false), pushback into the solution the starting value of i and maxEnd as the starting and ending times of the new interval respectively.\\n\\nSince i will eventually get incremented (due to it being in for loop) and j is now pointing to the new interval, re-initialize i as the value prior to j.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<vector<int>> sol;\\n\\n        sort(intervals.begin(), intervals.end());\\n\\n        for(int i=0;i<n;i++){\\n            int maxEnd=intervals[i][1];\\n            int j=i+1;\\n\\n            while((j<n)&&(intervals[j][0]<=maxEnd)){\\n                maxEnd=max(maxEnd, intervals[j][1]);\\n                j++;\\n            }\\n            sol.push_back({intervals[i][0], maxEnd});\\n            i=j-1;\\n        }   \\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy",
                    "Sort",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<vector<int>> sol;\\n\\n        sort(intervals.begin(), intervals.end());\\n\\n        for(int i=0;i<n;i++){\\n            int maxEnd=intervals[i][1];\\n            int j=i+1;\\n\\n            while((j<n)&&(intervals[j][0]<=maxEnd)){\\n                maxEnd=max(maxEnd, intervals[j][1]);\\n                j++;\\n            }\\n            sol.push_back({intervals[i][0], maxEnd});\\n            i=j-1;\\n        }   \\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567482,
                "title": "c-easy-and-fast-solution-o-nlog-n",
                "content": "\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705\\n\\t\\tsort(in.begin(),in.end());\\n        vector<vector<int>>vec; int first,last;\\n            first=in[0][0];  last=in[0][1];\\n        for(int i=1;i<in.size();i++)\\n        {\\n            if(in[i][1]<=last) continue;\\n            else if(in[i][0]<=last and last<=in[i][1]) last=in[i][1];\\n            else \\n            {\\n                vec.push_back({first,last});  \\n                first=in[i][0];  last=in[i][1];\\n            }\\n        }\\n        vec.push_back({first,last});\\n        return vec;\\n\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705\\n\\t\\tsort(in.begin(),in.end());\\n        vector<vector<int>>vec; int first,last;\\n            first=in[0][0];  last=in[0][1];\\n        for(int i=1;i<in.size();i++)\\n        {\\n            if(in[i][1]<=last) continue;\\n            else if(in[i][0]<=last and last<=in[i][1]) last=in[i][1];\\n            else \\n            {\\n                vec.push_back({first,last});  \\n                first=in[i][0];  last=in[i][1];\\n            }\\n        }\\n        vec.push_back({first,last});\\n        return vec;\\n\\t\\t//\\uD83D\\uDD25\\u2705 PLEASE UPVOTE IF YOU LIKE THIS SOLUTION\\uD83D\\uDD25\\u2705",
                "codeTag": "Unknown"
            },
            {
                "id": 2413048,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0]){\\n                ans.back()[1] = max(ans.back()[1],intervals[i][1]);\\n            }\\n            else{\\n                ans.push_back(intervals[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++){\\n            if(ans.back()[1]>=intervals[i][0]){\\n                ans.back()[1] = max(ans.back()[1],intervals[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2002088,
                "title": "easy-to-follow-javascript-solution",
                "content": "```\\nvar merge = function(intervals) {\\n    let sorted = intervals.sort((a, b) => a[0] - b[0]);\\n    let res = [sorted[0]]\\n    \\n    for (let i = 1; i < sorted.length; i++) {\\n      let currStart = sorted[i][0]\\n      let currEnd = sorted[i][1];\\n      let lastEnd = res[res.length - 1][1];\\n      \\n      if (currStart <= lastEnd) {\\n        res[res.length - 1][1] = Math.max(lastEnd, currEnd);\\n      }\\n      else {\\n        res.push(sorted[i])\\n      }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    let sorted = intervals.sort((a, b) => a[0] - b[0]);\\n    let res = [sorted[0]]\\n    \\n    for (let i = 1; i < sorted.length; i++) {\\n      let currStart = sorted[i][0]\\n      let currEnd = sorted[i][1];\\n      let lastEnd = res[res.length - 1][1];\\n      \\n      if (currStart <= lastEnd) {\\n        res[res.length - 1][1] = Math.max(lastEnd, currEnd);\\n      }\\n      else {\\n        res.push(sorted[i])\\n      }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693265,
                "title": "java-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int[][] merge(int[][] intervals) {\\n    int[] start = new int[10000];\\n    int[] end = new int[10000];\\n    List<int[]> retList = new ArrayList<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int max = 0;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < intervals.length; i++) {\\n      start[intervals[i][0]]++;\\n      end[intervals[i][1]]++;\\n      max = Math.max(max, intervals[i][1]);\\n    }\\n\\n    // Time O(n)\\n    int[] range = new int[2];\\n    for (int i = 0; i <= max; i++) {\\n      if (start[i] > 0) {\\n        if (stack.isEmpty()) {\\n          range = new int[2];\\n          range[0] = i;\\n          retList.add(range);\\n        }\\n        for (int j = 0; j < start[i]; j++) stack.push(i);\\n      }\\n      \\n      if (end[i] > 0) {\\n        for (int j = 0; j < end[i]; j++) stack.pop();\\n        if (stack.isEmpty()) {\\n          range[1] = i;\\n          retList.set(retList.size() - 1, range);\\n        }\\n      }\\n    }\\n\\n    // Time O(n)\\n    return retList.toArray(new int[retList.size()][]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int[][] merge(int[][] intervals) {\\n    int[] start = new int[10000];\\n    int[] end = new int[10000];\\n    List<int[]> retList = new ArrayList<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int max = 0;\\n    \\n    // Time O(n)\\n    for (int i = 0; i < intervals.length; i++) {\\n      start[intervals[i][0]]++;\\n      end[intervals[i][1]]++;\\n      max = Math.max(max, intervals[i][1]);\\n    }\\n\\n    // Time O(n)\\n    int[] range = new int[2];\\n    for (int i = 0; i <= max; i++) {\\n      if (start[i] > 0) {\\n        if (stack.isEmpty()) {\\n          range = new int[2];\\n          range[0] = i;\\n          retList.add(range);\\n        }\\n        for (int j = 0; j < start[i]; j++) stack.push(i);\\n      }\\n      \\n      if (end[i] > 0) {\\n        for (int j = 0; j < end[i]; j++) stack.pop();\\n        if (stack.isEmpty()) {\\n          range[1] = i;\\n          retList.set(retList.size() - 1, range);\\n        }\\n      }\\n    }\\n\\n    // Time O(n)\\n    return retList.toArray(new int[retList.size()][]);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644466,
                "title": "c-solution-using-inplace",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        if(n==0)\\n        {\\n            return {};\\n        }\\n        int j=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[j][1]>=nums[i][0])\\n            {\\n                nums[j][1]=max({nums[j][1],nums[i][1]});\\n            }\\n            else\\n            {\\n                nums[++j]=nums[i];\\n            }\\n        }\\n        return vector<vector<int>>(nums.begin(),nums.begin()+j+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) \\n    {\\n        int n=nums.size();\\n        if(n==0)\\n        {\\n            return {};\\n        }\\n        int j=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[j][1]>=nums[i][0])\\n            {\\n                nums[j][1]=max({nums[j][1],nums[i][1]});\\n            }\\n            else\\n            {\\n                nums[++j]=nums[i];\\n            }\\n        }\\n        return vector<vector<int>>(nums.begin(),nums.begin()+j+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628093,
                "title": "java-solution",
                "content": "```\\n/**\\ncases: edge overlapping, full overlapping, none\\n[[1,3],[2,4],[4,5],[6,7],[8,12],[10,11]]\\ntime: O(nlogn) - length of interval array\\nspace: O(n)\\n*/\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n            return intervals;\\n        }\\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0])); // sort by start point\\n\\n        List<int[]> result = new ArrayList<>();\\n        int[] currInterval = intervals[0]; // grab first interval to compare\\n        \\n        int i = 1;\\n        while (i < intervals.length) {\\n            if (intervals[i][0] > currInterval[1]) { // no overlap\\n                result.add(currInterval);\\n                currInterval = intervals[i]; // move to the next interval if no overlap\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            else if (currInterval[1] >= intervals[i][0]) { // if overlap\\n                currInterval[0] = Math.min(currInterval[0], intervals[i][0]);\\n                currInterval[1] = Math.max(currInterval[1], intervals[i][1]);\\n                // result.add(currInterval); // no need to add, we are just expanding interval\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][]); // convert parent List to array\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\ncases: edge overlapping, full overlapping, none\\n[[1,3],[2,4],[4,5],[6,7],[8,12],[10,11]]\\ntime: O(nlogn) - length of interval array\\nspace: O(n)\\n*/\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        if (intervals.length <= 1) {\\n            return intervals;\\n        }\\n        Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0])); // sort by start point\\n\\n        List<int[]> result = new ArrayList<>();\\n        int[] currInterval = intervals[0]; // grab first interval to compare\\n        \\n        int i = 1;\\n        while (i < intervals.length) {\\n            if (intervals[i][0] > currInterval[1]) { // no overlap\\n                result.add(currInterval);\\n                currInterval = intervals[i]; // move to the next interval if no overlap\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            else if (currInterval[1] >= intervals[i][0]) { // if overlap\\n                currInterval[0] = Math.min(currInterval[0], intervals[i][0]);\\n                currInterval[1] = Math.max(currInterval[1], intervals[i][1]);\\n                // result.add(currInterval); // no need to add, we are just expanding interval\\n                if (i == intervals.length-1) { // edge case if we hit last\\n                    result.add(currInterval);\\n                }\\n            }\\n            i++;\\n        }\\n        return result.toArray(new int[result.size()][]); // convert parent List to array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531770,
                "title": "python-using-heap",
                "content": "```\\nfrom heapq import heappop, heappush\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        heap =[]\\n        res = []\\n        intervals.sort()\\n        for i in intervals:\\n            if not heap:\\n                heapq.heappush(heap, i)\\n            elif heap[0][1]>=i[0]:\\n                    m, n = heapq.heappop(heap)\\n                    \\n                    heapq.heappush( heap, [min(m, i[0]), max(i[1], n)])\\n            else:\\n                res.append(heapq.heappop(heap))\\n                heapq.heappush(heap, i)\\n        \\n        if heap:\\n            res.extend(heap)\\n        print(res)\\n        return res\\n                    \\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappop, heappush\\nclass Solution(object):\\n    def merge(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        heap =[]\\n        res = []\\n        intervals.sort()\\n        for i in intervals:\\n            if not heap:\\n                heapq.heappush(heap, i)\\n            elif heap[0][1]>=i[0]:\\n                    m, n = heapq.heappop(heap)\\n                    \\n                    heapq.heappush( heap, [min(m, i[0]), max(i[1], n)])\\n            else:\\n                res.append(heapq.heappop(heap))\\n                heapq.heappush(heap, i)\\n        \\n        if heap:\\n            res.extend(heap)\\n        print(res)\\n        return res\\n                    \\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461378,
                "title": "c-comments-merge-intervals",
                "content": "```\\n// There can be three cases with two intervals \\n// Case 1:- No overlap\\n//  [1,           2]      [3,             4]\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n// [1,             3]      \\n//  _______________\\n// | left interval |\\n// |_______________|\\n//           [2,            4]\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n//  [1,                 4]\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//   [2,             3]\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // sort intervals on basis of start value\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n\\t\\tint left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n\\t\\t\\n        while(left<n && right<n)\\n        {\\n            if(v[left][1]<v[right][0])    // Case 1 : (No overlap )\\n            {\\n                left=right;\\n                right++;\\n            }\\n            //  overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                if(v[left][1]>=v[right][1])  // Case 3: (Full overlap)\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2: (partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n// There can be three cases with two intervals \\n// Case 1:- No overlap\\n//  [1,           2]      [3,             4]\\n//  _______________        ________________\\n// | left interval |      | right interval |\\n// |_______________|      |________________|\\n\\n//Case 2:- Partial overlap\\n// [1,             3]      \\n//  _______________\\n// | left interval |\\n// |_______________|\\n//           [2,            4]\\n//            ________________\\n//           | right interval |\\n//           |________________|\\n\\n// Case 3:- Full overlap\\n//  [1,                 4]\\n//  _____________________\\n// |    left interval    |\\n// |_____________________|\\n//   [2,             3]\\n//    ________________\\n//   | right interval |\\n//   |________________|\\n\\n\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) \\n    {\\n        // sort intervals on basis of start value\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n\\t\\tint left=0,right=1;\\n        vector<vector<int>>ans; // For storing the result\\n\\t\\t\\n        while(left<n && right<n)\\n        {\\n            if(v[left][1]<v[right][0])    // Case 1 : (No overlap )\\n            {\\n                left=right;\\n                right++;\\n            }\\n            //  overlap occurs (Case 2 or Case 3)\\n            else\\n            {\\n                if(v[left][1]>=v[right][1])  // Case 3: (Full overlap)\\n                {\\n                    // Mark the fully overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n                // Case 2: (partial overlap)\\n                else\\n                {\\n                    // Extend the end point of the left interval( by making end point of left interval=end point of right interval) so that the intervals can be merged \\n                    v[left][1]=v[right][1];\\n                    // Mark the partially overlapped interval so that it can be deleted later\\n                    v[right]={-1,-1};\\n                    right++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            // If any interval is marked then don\\'t push it to the ans vector cause after merging marked intervals can\\'t have their existence\\n            if(v[i][0]!=-1)\\n            {\\n                ans.push_back(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367823,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var merge = function(intervals) {\\n        if(intervals.length == 0) return []    // edge cases\\n        else if(intervals.length == 1) return intervals // edge cases\\n    \\n        intervals.sort((a,b) => {\\n            return a[0]-b[0];\\n        })\\n    \\n        let result = [intervals[0]]\\n    \\n        for(let interval of intervals) {\\n            let recentInterval = result[result.length-1]\\n            if(recentInterval[1] >= interval[0]) {\\n                recentInterval[1] = Math.max(recentInterval[1], interval[1])\\n            } else {\\n                result.push(interval)\\n            }\\n        }\\n        return result\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var merge = function(intervals) {\\n        if(intervals.length == 0) return []    // edge cases\\n        else if(intervals.length == 1) return intervals // edge cases\\n    \\n        intervals.sort((a,b) => {\\n            return a[0]-b[0];\\n        })\\n    \\n        let result = [intervals[0]]\\n    \\n        for(let interval of intervals) {\\n            let recentInterval = result[result.length-1]\\n            if(recentInterval[1] >= interval[0]) {\\n                recentInterval[1] = Math.max(recentInterval[1], interval[1])\\n            } else {\\n                result.push(interval)\\n            }\\n        }\\n        return result\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1261003,
                "title": "zero-bullshit-c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        sort(intervals.begin(),intervals.end());\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        sort(intervals.begin(),intervals.end());\\n        res.push_back(intervals[0]);\\n        for(int i=1;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]>res.back()[1])\\n                res.push_back(intervals[i]);\\n            else\\n                res.back()[1]=max(res.back()[1],intervals[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1246685,
                "title": "easy-to-understand-clean-well-explained-every-step-with-comments-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) \\n    {\\n        //Checking if there is only one interval\\n        if(intervals.size()<=1)return intervals;\\n        \\n        //Sorting the intervals on the basis of starting time\\n        sort(intervals.begin(),intervals.end());\\n        \\n        //Creating vector of vectors to store the intervals\\n        vector<vector<int>>ans;\\n        \\n        //Storing the 1st interval in temp vector(It will containg start time and end time)\\n        vector<int>temp=intervals[0];\\n        \\n        //It will be vector of intervals start and end time\\n        for(auto it:intervals)\\n        {\\n            //if EndTime of Ith Interval is greate than start of i+1th Interval\\n            //We\\'ll merge the interval The End Time of merged interval Will be  \\n            //Max of end time of both the ith and i+1th interval\\n            if(temp[1]>=it[0])\\n            {\\n                temp[1]=max(temp[1],it[1]);\\n                \\n            }\\n            //If Merging is not possible we\\'ll put the i+1th interval in ans\\n            //And we\\'ll update the temp with i+1th interval and repeat the process for next\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        //Putting the Last Interval in the ans array\\n        ans.push_back(temp);\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) \\n    {\\n        //Checking if there is only one interval\\n        if(intervals.size()<=1)return intervals;\\n        \\n        //Sorting the intervals on the basis of starting time\\n        sort(intervals.begin(),intervals.end());\\n        \\n        //Creating vector of vectors to store the intervals\\n        vector<vector<int>>ans;\\n        \\n        //Storing the 1st interval in temp vector(It will containg start time and end time)\\n        vector<int>temp=intervals[0];\\n        \\n        //It will be vector of intervals start and end time\\n        for(auto it:intervals)\\n        {\\n            //if EndTime of Ith Interval is greate than start of i+1th Interval\\n            //We\\'ll merge the interval The End Time of merged interval Will be  \\n            //Max of end time of both the ith and i+1th interval\\n            if(temp[1]>=it[0])\\n            {\\n                temp[1]=max(temp[1],it[1]);\\n                \\n            }\\n            //If Merging is not possible we\\'ll put the i+1th interval in ans\\n            //And we\\'ll update the temp with i+1th interval and repeat the process for next\\n            else\\n            {\\n                ans.push_back(temp);\\n                temp=it;\\n            }\\n        }\\n        //Putting the Last Interval in the ans array\\n        ans.push_back(temp);\\n         \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213592,
                "title": "easiest-and-best-c-solution-beats-99-submissions",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i = 1 ; i < intervals.size() ; i++){\\n            if(res.back()[1] >= (intervals[i])[0]){\\n                res.back()[1] = max(res.back()[1],(intervals[i])[1]);\\n            }\\n            else{\\n                res.push_back(intervals[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        if(intervals.size() == 1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(),intervals.end());\\n        vector<vector<int>> res;\\n        res.push_back(intervals[0]);\\n        for(int i = 1 ; i < intervals.size() ; i++){\\n            if(res.back()[1] >= (intervals[i])[0]){\\n                res.back()[1] = max(res.back()[1],(intervals[i])[1]);\\n            }\\n            else{\\n                res.push_back(intervals[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081743,
                "title": "clean-streaming-solution-for-followup",
                "content": "```\\n// use a balanced binary search tree to store intervals in sorted order as they come in\\n// if we add a new one, we need to iterate over all intervals and merge as needed\\n// as we iterate, if newInterval and current interval overlap, then remove currentInterval and merge\\n// keep removing and merging until we have no overlap, add merged interval back in\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        TreeSet<int[]> bbst = new TreeSet<int[]>((a, b) -> a[0]-b[0]);\\n        for(int[] interval: intervals) {\\n            Iterator<int[]> itr = bbst.iterator();\\n            while(itr.hasNext()) {\\n                int[] currInterval = itr.next();\\n                if(overlap(currInterval, interval)) {\\n                    interval = merge(currInterval, interval);\\n                    itr.remove();\\n                }\\n            }\\n            bbst.add(interval);\\n        }\\n        \\n        int size = bbst.size();\\n        int[][] res = new int[size][2];\\n        int idx = 0;\\n        for(int[] interval: bbst) {\\n            res[idx] = interval;\\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean overlap(int[] intervalA, int[] intervalB) {\\n        return Math.max(intervalA[0], intervalB[0]) <= Math.min(intervalA[1], intervalB[1]);\\n    }\\n    \\n    public int[] merge(int[] intervalA, int[] intervalB) {\\n        int start = Math.min(intervalA[0], intervalB[0]);\\n        int end = Math.max(intervalA[1], intervalB[1]);\\n        return new int[]{start, end};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// use a balanced binary search tree to store intervals in sorted order as they come in\\n// if we add a new one, we need to iterate over all intervals and merge as needed\\n// as we iterate, if newInterval and current interval overlap, then remove currentInterval and merge\\n// keep removing and merging until we have no overlap, add merged interval back in\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        TreeSet<int[]> bbst = new TreeSet<int[]>((a, b) -> a[0]-b[0]);\\n        for(int[] interval: intervals) {\\n            Iterator<int[]> itr = bbst.iterator();\\n            while(itr.hasNext()) {\\n                int[] currInterval = itr.next();\\n                if(overlap(currInterval, interval)) {\\n                    interval = merge(currInterval, interval);\\n                    itr.remove();\\n                }\\n            }\\n            bbst.add(interval);\\n        }\\n        \\n        int size = bbst.size();\\n        int[][] res = new int[size][2];\\n        int idx = 0;\\n        for(int[] interval: bbst) {\\n            res[idx] = interval;\\n            idx++;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean overlap(int[] intervalA, int[] intervalB) {\\n        return Math.max(intervalA[0], intervalB[0]) <= Math.min(intervalA[1], intervalB[1]);\\n    }\\n    \\n    public int[] merge(int[] intervalA, int[] intervalB) {\\n        int start = Math.min(intervalA[0], intervalB[0]);\\n        int end = Math.max(intervalA[1], intervalB[1]);\\n        return new int[]{start, end};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963251,
                "title": "golang-solution",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    res := make([][]int, 0)\\n    sort.Slice(intervals, func(a, b int)bool {\\n        return intervals[a][0] < intervals[b][0]\\n    })\\n    \\n    res = append(res, intervals[0])\\n    \\n    for i := 1; i < len(intervals); i++ {\\n        if intervals[i][0] <= res[len(res) - 1][1] {\\n            //update last range in result case\\n            res[len(res) - 1][1] = max(res[len(res) - 1][1], intervals[i][1])\\n        } else {\\n            //insert new range into result case\\n            res = append(res, intervals[i])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int)int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    res := make([][]int, 0)\\n    sort.Slice(intervals, func(a, b int)bool {\\n        return intervals[a][0] < intervals[b][0]\\n    })\\n    \\n    res = append(res, intervals[0])\\n    \\n    for i := 1; i < len(intervals); i++ {\\n        if intervals[i][0] <= res[len(res) - 1][1] {\\n            //update last range in result case\\n            res[len(res) - 1][1] = max(res[len(res) - 1][1], intervals[i][1])\\n        } else {\\n            //insert new range into result case\\n            res = append(res, intervals[i])\\n        }\\n    }\\n    return res\\n}\\n\\nfunc max(a, b int)int {\\n    if a > b {\\n        return a\\n    } else {\\n        return b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845362,
                "title": "java-sol-sort-and-merge-intervals",
                "content": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> res = new ArrayList<>();\\n        \\n        if (intervals == null || intervals.length == 0) {\\n            return res.toArray(new int[][] {});\\n        }\\n        \\n        // Sort intervals ascending by start value\\n        Arrays.sort(intervals, (pair1, pair2) -> {\\n            return pair1[0] - pair2[0];\\n        });\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[i][1] < end) {\\n                // Ignore current interval, it is a subset of the previous\\n                continue;\\n            }\\n            \\n            if (intervals[i][0] > end) {\\n                res.add(new int[]{ start, end });\\n                \\n                start = intervals[i][0];\\n            }\\n            \\n            end = intervals[i][1];\\n        }\\n        \\n        res.add(new int[]{ start, end });\\n        \\n        return res.toArray(new int[][] {});\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] merge(int[][] intervals) {\\n        List<int[]> res = new ArrayList<>();\\n        \\n        if (intervals == null || intervals.length == 0) {\\n            return res.toArray(new int[][] {});\\n        }\\n        \\n        // Sort intervals ascending by start value\\n        Arrays.sort(intervals, (pair1, pair2) -> {\\n            return pair1[0] - pair2[0];\\n        });\\n        \\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            if (intervals[i][1] < end) {\\n                // Ignore current interval, it is a subset of the previous\\n                continue;\\n            }\\n            \\n            if (intervals[i][0] > end) {\\n                res.add(new int[]{ start, end });\\n                \\n                start = intervals[i][0];\\n            }\\n            \\n            end = intervals[i][1];\\n        }\\n        \\n        res.add(new int[]{ start, end });\\n        \\n        return res.toArray(new int[][] {});\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578912,
                "title": "go-runtime-99-39-mem-100",
                "content": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\\n    \\n    res := [][]int{}\\n    for i, interval := range intervals {\\n        if i == 0 {\\n            res = append(res, interval)\\n            continue\\n        }\\n        \\n        r := res[len(res)-1]\\n        if interval[0] <= r[1] && r[1] < interval[1] {\\n            res[len(res)-1] = []int{r[0], interval[1]}\\n        }\\n        if r[1] < interval[0] {\\n            res = append(res, interval)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc merge(intervals [][]int) [][]int {\\n    sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] < intervals[j][0] })\\n    \\n    res := [][]int{}\\n    for i, interval := range intervals {\\n        if i == 0 {\\n            res = append(res, interval)\\n            continue\\n        }\\n        \\n        r := res[len(res)-1]\\n        if interval[0] <= r[1] && r[1] < interval[1] {\\n            res[len(res)-1] = []int{r[0], interval[1]}\\n        }\\n        if r[1] < interval[0] {\\n            res = append(res, interval)\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524522,
                "title": "python-3-simple-and-easy-solution",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0:\\n            return []\\n        \\n        sorted_intervals = sorted(intervals, key=lambda l:l[0])\\n        \\n        res = [sorted_intervals[0]]\\n        for interval in sorted_intervals[1:]:\\n            if res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if len(intervals) == 0:\\n            return []\\n        \\n        sorted_intervals = sorted(intervals, key=lambda l:l[0])\\n        \\n        res = [sorted_intervals[0]]\\n        for interval in sorted_intervals[1:]:\\n            if res[-1][1] >= interval[0]:\\n                res[-1][1] = max(res[-1][1], interval[1])\\n            else:\\n                res.append(interval)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293571,
                "title": "c-why-do-i-get-runtime-error-depending-on-whenther-sort-comp-function-is-or",
                "content": "The following fails when comp function is a[0]<=b[0]\\nrun time error is reference binding to null pointer of type \\'value_type\\' (stl_vector.h)\\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<=b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```\\nBut this comp function a[0]<b[0] solution succeeds\\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<=b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    static int comp(vector<int> a, vector<int> b){\\n        return a[0]<b[0];\\n    }\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int n=intervals.size();\\n        vector<vector<int>> merged;\\n        if (n==0) return merged;\\n        for (int i=0;i<n;i++) {\\n            if (merged.empty() || merged.back()[1]<intervals[i][0])\\n                merged.push_back(intervals[i]);\\n            else\\n                merged.back()[1]=max(merged.back()[1], intervals[i][1]);\\n        }\\n        return merged;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 21305,
                "title": "c-sort-by-start-simple-5-lines",
                "content": "Iterate over the array sorted by start and compare the start of each element to the end of the last item on your output.  Either extend the last element of the output or add a new element to the output.\\n\\n```\\n    public IList<Interval> Merge(IList<Interval> intervals) \\n    {\\n        IList<Interval> res = new List<Interval>();\\n        foreach (Interval curr in intervals.OrderBy(x => x.start))\\n        {\\n            if (res.Count == 0 || res[res.Count-1].end < curr.start) res.Add(new Interval(curr.start, curr.end));\\n            else res[res.Count-1].end = Math.Max(res[res.Count-1].end, curr.end);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<Interval> Merge(IList<Interval> intervals) \\n    {\\n        IList<Interval> res = new List<Interval>();\\n        foreach (Interval curr in intervals.OrderBy(x => x.start))\\n        {\\n            if (res.Count == 0 || res[res.Count-1].end < curr.start) res.Add(new Interval(curr.start, curr.end));\\n            else res[res.Count-1].end = Math.Max(res[res.Count-1].end, curr.end);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 21359,
                "title": "clean-treeset-solution-in-java",
                "content": "```\\npublic class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        \\n        TreeSet<Interval> tree = new TreeSet<Interval>(new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval i1, Interval i2) {\\n                if (i1.end < i2.start) return -1;\\n                else if (i1.start > i2.end) return 1;\\n                else return 0;\\n            }\\n        });\\n        \\n        for (Interval i: intervals) {\\n            while (tree.contains(i)) {\\n                Interval x = tree.ceiling(i);\\n                tree.remove(x);\\n                i = new Interval(Math.min(i.start, x.start), Math.max(i.end, x.end));\\n            }\\n            tree.add(i);\\n        }\\n        \\n        return new ArrayList<Interval>(tree);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Interval> merge(List<Interval> intervals) {\\n        \\n        TreeSet<Interval> tree = new TreeSet<Interval>(new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval i1, Interval i2) {\\n                if (i1.end < i2.start) return -1;\\n                else if (i1.start > i2.end) return 1;\\n                else return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 21485,
                "title": "concise-python-code-easy-understanding",
                "content": "\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda interval:interval.start)\\n            result = []\\n            interval, l = intervals[0], len(intervals)\\n            for i in range(1, l):\\n                interval2 = intervals[i]\\n                if interval2.start > interval.end:\\n                    result.append(interval)\\n                    interval = interval2\\n                else:\\n                    interval.end = max\\uff08interval.end, interval2.end)\\n            \\n            result.append(interval)\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n    class Solution(object):\\n        def merge(self, intervals):\\n            \"\"\"\\n            :type intervals: List[Interval]\\n            :rtype: List[Interval]\\n            \"\"\"\\n            intervals = sorted(intervals, key=lambda interval:interval.start)\\n            result = []\\n            interval, l = intervals[0], len(intervals)\\n            for i in range(1, l):\\n                interval2 = intervals[i]\\n                if interval2.start > interval.end:\\n                    result.append(interval)\\n                    interval = interval2\\n                else:\\n                    interval.end = max\\uff08interval.end, interval2.end)\\n            \\n            result.append(interval)\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 21551,
                "title": "sort-function-problems",
                "content": "I use the sort function to sort the starting points of all intervals,\\n\\n    sort(intervals.begin(),intervals.end(),compareInterval); \\n\\nHowever, when I am trying to use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<=b.start);\\n    }\\n\\nthe compiler outputs some Runtime error, however, the compiler accepts the code if I use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<b.start);\\n    }\\n\\nany genius here have some ideas?",
                "solutionTags": [],
                "code": "I use the sort function to sort the starting points of all intervals,\\n\\n    sort(intervals.begin(),intervals.end(),compareInterval); \\n\\nHowever, when I am trying to use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<=b.start);\\n    }\\n\\nthe compiler outputs some Runtime error, however, the compiler accepts the code if I use\\n\\n    bool compareInterval(Interval a, Interval b)\\n    {\\n        return (a.start<b.start);\\n    }\\n\\nany genius here have some ideas?",
                "codeTag": "Unknown"
            },
            {
                "id": 3908055,
                "title": "easy-c-solution-using-sorting-basic-approach-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n       vector<vector<int>>v;\\n       int start;\\n       int end;\\n       int i;\\n        sort(nums.begin(), nums.end(), [](const vector<int>& a, const vector<int>& b) {\\n           return a[0] < b[0];\\n       });\\n       \\n       for( i=0;i<nums.size();i++)\\n       {\\n           int start=nums[i][0];\\n           int end=nums[i][1]; \\n            while(i!=nums.size()-1 && end>=nums[i+1][0])\\n           {\\n               end= max(end,nums[i+1][1]);\\n               i++;\\n           }\\n           \\n           \\n           vector<int> temp={start,end};\\n           v.push_back(temp);\\n       } \\n       return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n       vector<vector<int>>v;\\n       int start;\\n       int end;\\n       int i;\\n        sort(nums.begin(), nums.end(), [](const vector<int>& a, const vector<int>& b) {\\n           return a[0] < b[0];\\n       });\\n       \\n       for( i=0;i<nums.size();i++)\\n       {\\n           int start=nums[i][0];\\n           int end=nums[i][1]; \\n            while(i!=nums.size()-1 && end>=nums[i+1][0])\\n           {\\n               end= max(end,nums[i+1][1]);\\n               i++;\\n           }\\n           \\n           \\n           vector<int> temp={start,end};\\n           v.push_back(temp);\\n       } \\n       return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760303,
                "title": "fast-solution-beats-99-simple-code-self-explanatory-with-comments",
                "content": "Solution:\\n\\n    class Solution(object):\\n\\n        def merge(self, intervals):\\n            \\n            #sort the intervals\\n            intervals.sort()\\n\\n            #base case \\n            if len(intervals)==1:\\n                return intervals\\n\\n            #the answer array\\n            ans = [intervals[0]]\\n            for i in range(1, len(intervals)):\\n\\n                #if the intervals are non overlapping \\n                if intervals[i][0]>ans[-1][1]:\\n                    ans.append(intervals[i])\\n\\n                #if two intervals overlap\\n                else:\\n                    new = [min(intervals[i][0], ans[-1][0]), max(intervals[i][1], ans[-1][1])]\\n                    ans.pop()\\n                    ans.append(new)\\n\\n            return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solution:\\n\\n    class Solution(object):\\n\\n        def merge(self, intervals):\\n            \\n            #sort the intervals\\n            intervals.sort()\\n\\n            #base case \\n            if len(intervals)==1:\\n                return intervals\\n\\n            #the answer array\\n            ans = [intervals[0]]\\n            for i in range(1, len(intervals)):\\n\\n                #if the intervals are non overlapping \\n                if intervals[i][0]>ans[-1][1]:\\n                    ans.append(intervals[i])\\n\\n                #if two intervals overlap\\n                else:\\n                    new = [min(intervals[i][0], ans[-1][0]), max(intervals[i][1], ans[-1][1])]\\n                    ans.pop()\\n                    ans.append(new)\\n\\n            return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2964594,
                "title": "c-easy-to-understand-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, two array will be taken arr1 for all intervals[i][0]\\nand second array arr2 for all intervals[i][1] then sortboth of them.Therefore, only one condition in for loop: if arr2[i]<arr2[i+1]...\\n\\nKindly like this solution if you are able to understand.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>>ans;\\n        vector<int>res;\\n        vector<int>arr1;\\n        vector<int>arr2;\\n        for(int i =0;i<intervals.size();i++){\\n            arr1.push_back(intervals[i][0]);\\n            arr2.push_back(intervals[i][1]);\\n        }\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n\\nres.push_back(arr1[0]);\\nfor(int i =0;i<intervals.size()-1;i++){\\nif(arr2[i]<arr1[i+1]){\\nres.push_back(arr2[i]);\\nans.push_back(res);\\nres.clear();\\nres.push_back(arr1[i+1]);\\n}\\n}\\nres.push_back(arr2[arr2.size()-1]);\\nans.push_back(res);\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>>ans;\\n        vector<int>res;\\n        vector<int>arr1;\\n        vector<int>arr2;\\n        for(int i =0;i<intervals.size();i++){\\n            arr1.push_back(intervals[i][0]);\\n            arr2.push_back(intervals[i][1]);\\n        }\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n\\nres.push_back(arr1[0]);\\nfor(int i =0;i<intervals.size()-1;i++){\\nif(arr2[i]<arr1[i+1]){\\nres.push_back(arr2[i]);\\nans.push_back(res);\\nres.clear();\\nres.push_back(arr1[i+1]);\\n}\\n}\\nres.push_back(arr2[arr2.size()-1]);\\nans.push_back(res);\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951764,
                "title": "python-simple-solution",
                "content": "# Approach\\nSort by the start of the interval. Then check if the end of an interval is equal to or greater than the start of the next interval. If yes merge it, and remove that interval, otherwise continue. Return the array after parsing through.\\n\\n# Complexity\\n- Time complexity: O(n * logn)\\n\\n- Space complexity: O(1)?\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: x[0])\\n        index = 0\\n        while index < len(intervals)-1:\\n            if intervals[index][1] >= intervals[index+1][0]:\\n                intervals[index][1] = max(intervals[index+1][1],intervals[index][1])\\n                intervals.remove(intervals[index+1])\\n            else:\\n                index += 1\\n        return intervals\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: x[0])\\n        index = 0\\n        while index < len(intervals)-1:\\n            if intervals[index][1] >= intervals[index+1][0]:\\n                intervals[index][1] = max(intervals[index+1][1],intervals[index][1])\\n                intervals.remove(intervals[index+1])\\n            else:\\n                index += 1\\n        return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856777,
                "title": "easy-and-swift-python-solution",
                "content": "- Sort the array based on the order of first element.\\n- Check if the second element of each nested array is within the range of prev array.\\n- Combine the arrays if necessary.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if intervals == []:\\n            return\\n        \\n        intervals.sort(key = lambda x: x[0])\\n        res = [intervals[0]]\\n        \\n        for i in range(1, len(intervals)):\\n\\n            if intervals[i][0] <= res[-1][1]:\\n                res[-1][1] = max(intervals[i][1], res[-1][1])\\n                continue\\n            \\n            res.append(intervals[i])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        if intervals == []:\\n            return\\n        \\n        intervals.sort(key = lambda x: x[0])\\n        res = [intervals[0]]\\n        \\n        for i in range(1, len(intervals)):\\n\\n            if intervals[i][0] <= res[-1][1]:\\n                res[-1][1] = max(intervals[i][1], res[-1][1])\\n                continue\\n            \\n            res.append(intervals[i])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773288,
                "title": "python-solution-onlogn",
                "content": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: (x[0]))\\n        mergedIntervals = []\\n        mergedIntervalIndex = 0\\n        mergedIntervals.append(intervals[0])\\n        for i in range(1,len(intervals)):\\n            currentInterval = intervals[i]\\n            currentMergedInterval = mergedIntervals[mergedIntervalIndex]\\n            if currentInterval[0] <= currentMergedInterval[1] and currentInterval[1] >= currentMergedInterval[0]:\\n                mergedIntervals[mergedIntervalIndex] = [min(currentMergedInterval[0], currentInterval[0]), max(currentInterval[1], currentMergedInterval[1])]\\n            else:\\n                mergedIntervals.append(currentInterval)\\n                mergedIntervalIndex += 1\\n        return mergedIntervals\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\\n        intervals.sort(key=lambda x: (x[0]))\\n        mergedIntervals = []\\n        mergedIntervalIndex = 0\\n        mergedIntervals.append(intervals[0])\\n        for i in range(1,len(intervals)):\\n            currentInterval = intervals[i]\\n            currentMergedInterval = mergedIntervals[mergedIntervalIndex]\\n            if currentInterval[0] <= currentMergedInterval[1] and currentInterval[1] >= currentMergedInterval[0]:\\n                mergedIntervals[mergedIntervalIndex] = [min(currentMergedInterval[0], currentInterval[0]), max(currentInterval[1], currentMergedInterval[1])]\\n            else:\\n                mergedIntervals.append(currentInterval)\\n                mergedIntervalIndex += 1\\n        return mergedIntervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726014,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n\\t\\tint n=intervals.size();\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<n;i++){\\n            if(ans[ans.size()-1][1]<intervals[i][0]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                ans[ans.size()-1][1]=max(ans[ans.size()-1][1],intervals[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n\\t\\tint n=intervals.size();\\n        vector<vector<int>>ans;\\n        ans.push_back(intervals[0]);\\n        for(int i=1;i<n;i++){\\n            if(ans[ans.size()-1][1]<intervals[i][0]){\\n                ans.push_back(intervals[i]);\\n            }\\n            else{\\n                ans[ans.size()-1][1]=max(ans[ans.size()-1][1],intervals[i][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664674,
                "title": "90-time-beats-c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intr) {\\n        sort(intr.begin(),intr.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intr[0]);\\n        for(int i = 1; i < intr.size(); i++){\\n            if(intr[i][0]>ans[ans.size()-1][1]){\\n                ans.push_back(intr[i]);\\n            }else{\\n                ans[ans.size()-1][1] = max(intr[i][1],ans[ans.size()-1][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intr) {\\n        sort(intr.begin(),intr.end());\\n        vector<vector<int>> ans;\\n        ans.push_back(intr[0]);\\n        for(int i = 1; i < intr.size(); i++){\\n            if(intr[i][0]>ans[ans.size()-1][1]){\\n                ans.push_back(intr[i]);\\n            }else{\\n                ans[ans.size()-1][1] = max(intr[i][1],ans[ans.size()-1][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538215,
                "title": "c-easy-to-understand-solution-95-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tvector<vector<int>> ans = {arr[0]};\\n\\t\\t\\tfor(int i = 0 ; i < arr.size() ; i++){\\n\\t\\t\\t\\tint s = arr[i][0] , e = arr[i][1];\\n\\t\\t\\t\\tint as = ans[ans.size()-1][0] , ae = ans[ans.size()-1][1];\\n\\t\\t\\t\\tif(as <= s and s <= ae) {\\n\\t\\t\\t\\t\\tans[ans.size()-1][1] = max(e,ae); \\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tans.push_back({s,e});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> merge(vector<vector<int>>& arr) {\\n\\t\\t\\tsort(arr.begin(),arr.end());\\n\\t\\t\\tvector<vector<int>> ans = {arr[0]}",
                "codeTag": "Java"
            },
            {
                "id": 2516355,
                "title": "c-8-line-simplest-solution-with-linear-time-complexity",
                "content": "Hey Guys,\\nHope you all are doing well!\\nIn this post, I\\'ve provided one of the easiest approach to merge all overlapping intervals in a given array.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        vector<vector<int>>ans;\\n        sort(v.begin(),v.end());\\n        for(int i=0; i<v.size(); i++){\\n            if(ans.size()==0 || v[i][0]>ans.back()[1])\\n                ans.push_back(v[i]);\\n            else ans.back()[1]=max(ans.back()[1],v[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\nHappy Coding!!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& v) {\\n        vector<vector<int>>ans;\\n        sort(v.begin(),v.end());\\n        for(int i=0; i<v.size(); i++){\\n            if(ans.size()==0 || v[i][0]>ans.back()[1])\\n                ans.push_back(v[i]);\\n            else ans.back()[1]=max(ans.back()[1],v[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375726,
                "title": "a-simple-c-solution",
                "content": "**Runtime: 24 ms, faster than 99.96% of C++ online submissions for Merge Intervals.\\nMemory Usage: 19.1 MB, less than 44.98% of C++ online submissions for Merge Intervals.**\\n```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\tsort(intervals.begin(),intervals.end());\\n\\tvector<vector<int>> ans;\\n\\tint start=intervals[0][0],end=intervals[0][1];\\n\\tfor(int i=1;i<intervals.size();i++){\\n\\t\\tif(intervals[i][0]<=end){\\n\\t\\t\\tend=max(end,intervals[i][1]);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tans.push_back({start,end});\\n\\t\\t\\tstart=intervals[i][0],end=intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\tans.push_back({start,end});\\n\\treturn ans;\\n}\\n```\\n\\nKeep Coding.\\nPlease do Upvote.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\tsort(intervals.begin(),intervals.end());\\n\\tvector<vector<int>> ans;\\n\\tint start=intervals[0][0],end=intervals[0][1];\\n\\tfor(int i=1;i<intervals.size();i++){\\n\\t\\tif(intervals[i][0]<=end){\\n\\t\\t\\tend=max(end,intervals[i][1]);\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tans.push_back({start,end});\\n\\t\\t\\tstart=intervals[i][0],end=intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\tans.push_back({start,end});\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329982,
                "title": "interview-ready-with-explanation",
                "content": "```\\nclass Solution {\\n    //Time: O(n log n) for sorting the given intervals\\n    //Space O(n) where n represent the length of given intervals\\n    public int[][] merge(int[][] intervals) {\\n\\t\\t//Edge case\\n\\t\\tif(intervals.length == 1) return intervals;\\n\\t\\n        //sort by intervals start time\\n        Arrays.sort(intervals, (a,b)-> a[0] - b[0]);\\n        \\n        //create a list of int[]\\n        List<int[]> result = new ArrayList<>();\\n        \\n        //get the first interval from intervals\\n        int aStart = intervals[0][0],\\n            aEnd = intervals[0][1];\\n        \\n        //loop through the rest of intervals\\n        for(int i = 1; i < intervals.length; i++){\\n            //if b.Start <= aEnd meaning it is overlapping\\n            if(intervals[i][0] <= aEnd){\\n                //find the new max\\n                aEnd = Math.max(aEnd, intervals[i][1]);\\n            }\\n            else{\\n                //if not add it to the result and change the a.start and a.end\\n                result.add(new int[]{aStart, aEnd});\\n                aStart = intervals[i][0];\\n                aEnd = intervals[i][1];\\n            }\\n        }\\n        \\n        //add the last values\\n        result.add(new int[]{aStart, aEnd});\\n        \\n        //return the result\\n        return result.toArray(new int[result.size()][]);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    //Time: O(n log n) for sorting the given intervals\\n    //Space O(n) where n represent the length of given intervals\\n    public int[][] merge(int[][] intervals) {\\n\\t\\t//Edge case\\n\\t\\tif(intervals.length == 1) return intervals;\\n\\t\\n        //sort by intervals start time\\n        Arrays.sort(intervals, (a,b)-> a[0] - b[0]);\\n        \\n        //create a list of int[]\\n        List<int[]> result = new ArrayList<>();\\n        \\n        //get the first interval from intervals\\n        int aStart = intervals[0][0],\\n            aEnd = intervals[0][1];\\n        \\n        //loop through the rest of intervals\\n        for(int i = 1; i < intervals.length; i++){\\n            //if b.Start <= aEnd meaning it is overlapping\\n            if(intervals[i][0] <= aEnd){\\n                //find the new max\\n                aEnd = Math.max(aEnd, intervals[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2274410,
                "title": "beginner-friendly-javascript-python-solution",
                "content": "**Time Complexity : O(n)**\\n**JavaScript**\\n```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0])\\n    let merged = [], len = 0\\n    for(let i of intervals){\\n        if(merged.length > 0 && merged[len-1][1] >= i[0]){\\n            merged[len-1][1] = Math.max(merged[len-1][1], i[1])\\n        }else{\\n            merged.push(i)\\n            len++\\n        }\\n    }\\n    return merged\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        intervals.sort()\\n        merged = []\\n        n = 0\\n        for i in intervals:\\n            if len(merged) > 0 and merged[n-1][1] >= i[0]:\\n                merged[n-1][1] = max(merged[n-1][1], i[1])\\n            else:\\n                merged.append(i)\\n                n += 1\\n        return merged\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0])\\n    let merged = [], len = 0\\n    for(let i of intervals){\\n        if(merged.length > 0 && merged[len-1][1] >= i[0]){\\n            merged[len-1][1] = Math.max(merged[len-1][1], i[1])\\n        }else{\\n            merged.push(i)\\n            len++\\n        }\\n    }\\n    return merged\\n};\\n```\n```\\nclass Solution(object):\\n    def merge(self, intervals):\\n        intervals.sort()\\n        merged = []\\n        n = 0\\n        for i in intervals:\\n            if len(merged) > 0 and merged[n-1][1] >= i[0]:\\n                merged[n-1][1] = max(merged[n-1][1], i[1])\\n            else:\\n                merged.append(i)\\n                n += 1\\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105757,
                "title": "simple-javascript",
                "content": "Hi,\\nhere is my javascript solution.\\n\\n```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0]);\\n    const results = [];\\n    for(let interval of intervals) {\\n        const prev = results.at(-1);\\n        if (!results.length || prev[1] < interval[0]) {\\n            results.push(interval);\\n        } else {\\n            prev[1] = Math.max(prev[1], interval[1])\\n        }\\n    }\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar merge = function(intervals) {\\n    intervals.sort((a,b) => a[0] - b[0]);\\n    const results = [];\\n    for(let interval of intervals) {\\n        const prev = results.at(-1);\\n        if (!results.length || prev[1] < interval[0]) {\\n            results.push(interval);\\n        } else {\\n            prev[1] = Math.max(prev[1], interval[1])\\n        }\\n    }\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2025008,
                "title": "easy-c-sorting-o-nlogn",
                "content": "***DO UPVOTE IF IT HELPS!!!!***\\n\\n\\tvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<vector<int>> ans;\\n        int n=intervals.size();\\n               \\n        int res=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<=intervals[res][1]){\\n                intervals[res][0]=min (intervals[res][0],intervals[i][0]);\\n                intervals[res][1]=max(intervals[res][1],intervals[i][1]);\\n            }\\n            else{\\n                res++;\\n                intervals[res]=intervals[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<=res;i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "***DO UPVOTE IF IT HELPS!!!!***\\n\\n\\tvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        vector<vector<int>> ans;\\n        int n=intervals.size();\\n               \\n        int res=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(intervals[i][0]<=intervals[res][1]){\\n                intervals[res][0]=min (intervals[res][0],intervals[i][0]);\\n                intervals[res][1]=max(intervals[res][1],intervals[i][1]);\\n            }\\n            else{\\n                res++;\\n                intervals[res]=intervals[i];\\n            }\\n        }\\n        \\n        for(int i=0;i<=res;i++){\\n            ans.push_back(intervals[i]);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1996645,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int lengthOfIntervals = intervals.size();\\n\\t\\tif(lengthOfIntervals == 0)return {{}};\\n\\n\\t\\tsort(intervals.begin(),intervals.end(),[](vector<int> firstInterval, vector<int> secondInterval){\\n\\t\\t\\treturn firstInterval[0]<secondInterval[0];\\n\\t\\t});\\n\\n\\t\\tvector<vector<int>> mergedIntervals;\\n\\t\\tmergedIntervals.push_back(intervals[0]);\\t\\n\\n\\t\\tfor(int i = 1;i<lengthOfIntervals;i++){\\n\\t\\t\\tvector<int> lastPushedIntervalInTheResult = mergedIntervals.back();\\n\\t\\t\\tif(intervals[i][0]>lastPushedIntervalInTheResult[1])\\n\\t\\t\\t\\tmergedIntervals.push_back(intervals[i]);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmergedIntervals.back()[1] = max(mergedIntervals.back()[1],intervals[i][1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mergedIntervals;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int lengthOfIntervals = intervals.size();\\n\\t\\tif(lengthOfIntervals == 0)return {{}};\\n\\n\\t\\tsort(intervals.begin(),intervals.end(),[](vector<int> firstInterval, vector<int> secondInterval){\\n\\t\\t\\treturn firstInterval[0]<secondInterval[0];\\n\\t\\t});\\n\\n\\t\\tvector<vector<int>> mergedIntervals;\\n\\t\\tmergedIntervals.push_back(intervals[0]);\\t\\n\\n\\t\\tfor(int i = 1;i<lengthOfIntervals;i++){\\n\\t\\t\\tvector<int> lastPushedIntervalInTheResult = mergedIntervals.back();\\n\\t\\t\\tif(intervals[i][0]>lastPushedIntervalInTheResult[1])\\n\\t\\t\\t\\tmergedIntervals.push_back(intervals[i]);\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmergedIntervals.back()[1] = max(mergedIntervals.back()[1],intervals[i][1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn mergedIntervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966180,
                "title": "c-simple-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    //compartor for sorting the intervals\\n    static bool compare(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end(),compare);\\n        // sorting the intervals\\n        vector<vector<int>> res;\\n        res.push_back(nums[0]);\\n        // pushing 1st interval to result\\n        for(int i=1;i<nums.size();i++){\\n            // checking if current interval overlaps with last interval\\n            if(res[res.size()-1][1] >= nums[i][0]){\\n\\t\\t\\t\\t// we just update out interval\\n\\t\\t\\t\\t// y here should be there larger of 2 intervals\\n                res[res.size()-1][1]=max(res[res.size()-1][1],nums[i][1]);\\n            }else{\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nUpvote if you found it helpful.",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //compartor for sorting the intervals\\n    static bool compare(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& nums) {\\n        sort(nums.begin(),nums.end(),compare);\\n        // sorting the intervals\\n        vector<vector<int>> res;\\n        res.push_back(nums[0]);\\n        // pushing 1st interval to result\\n        for(int i=1;i<nums.size();i++){\\n            // checking if current interval overlaps with last interval\\n            if(res[res.size()-1][1] >= nums[i][0]){\\n\\t\\t\\t\\t// we just update out interval\\n\\t\\t\\t\\t// y here should be there larger of 2 intervals\\n                res[res.size()-1][1]=max(res[res.size()-1][1],nums[i][1]);\\n            }else{\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846983,
                "title": "simple-kotlin-solution-with-explanation",
                "content": "Here is a simple Kotlin solution.\\nThe logic is simple.\\n1. Sort the intervals using the start value (O(NlogN))\\n2. Loop through the array of intervals (O(N))\\n3. Given an interval, \\n   1) no overlap case - if the start value is greater than end value of the last `result` interval then add the interval to `result `\\n   2) overlap case -  just get the Max end value of a) last `result` interval or b) the current interval (this covers edge case where current interval falls within the last `result` interval)\\n\\n* checking result is empty is a special case for 1) no overlap\\n\\n```kotlin\\nfun mergeIntervals2(intervals: Array<IntArray>): Array<IntArray> {\\n        intervals.sortBy{ it[0] }\\n        val result = mutableListOf<IntArray>()\\n        intervals.forEach{\\n            if(result.isEmpty() || result.last()[1] < it[0]) {\\n                result.add(it)\\n            } else {\\n                result.last()[1] = maxOf(result.last()[1], it[1])\\n            }\\n        }\\n        return result.toTypedArray()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nfun mergeIntervals2(intervals: Array<IntArray>): Array<IntArray> {\\n        intervals.sortBy{ it[0] }\\n        val result = mutableListOf<IntArray>()\\n        intervals.forEach{\\n            if(result.isEmpty() || result.last()[1] < it[0]) {\\n                result.add(it)\\n            } else {\\n                result.last()[1] = maxOf(result.last()[1], it[1])\\n            }\\n        }\\n        return result.toTypedArray()\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1573219,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1849602,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566121,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566131,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574619,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576565,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568394,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565574,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573219,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1849602,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566121,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566835,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566131,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1574619,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1576565,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568394,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565574,
                "content": [
                    {
                        "username": "criskgl",
                        "content": "# IMAGE EXPLANATION OF LEETCODE SOLUTION!!!\\n## VERY INTUITIVE AND EASY!!\\n\\n![image](https://assets.leetcode.com/users/criskgl/image_1574967731.png)\\n"
                    },
                    {
                        "username": "Adithyang",
                        "content": "[@Jayusc](/Jayusc) Hey man if u dont wanna see just dont see "
                    },
                    {
                        "username": "mouzz2005",
                        "content": "thx bro, this help me a lot to solve this question."
                    },
                    {
                        "username": "bhargav1811",
                        "content": "Enough visualization for me to solve by  myself !! Thank you !!! "
                    },
                    {
                        "username": "Jayusc",
                        "content": "plz don\\'t put solution here"
                    },
                    {
                        "username": "leet_leak",
                        "content": "The list is not sorted! Please give a clarification!"
                    },
                    {
                        "username": "dialectrical",
                        "content": "Title.\\n\\nAm I missing something in the explination of overlap?"
                    },
                    {
                        "username": "bentrizzle",
                        "content": "I\\'m having trouble understanding why returnColumnSizes is a double pointer and what format it is supposed to take? Anything I try with it causes a heap-buffer-overflow."
                    },
                    {
                        "username": "xiaoyuqian2",
                        "content": "This is a follow-up question in interviews. Does anyone have any idea?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "[@spookie886](/spookie886) follow up question https://leetcode.com/problems/insert-interval/"
                    },
                    {
                        "username": "spookie886",
                        "content": "[@DipeshKumar24](/DipeshKumar24) hi, do you happen to know the follow up to this question?"
                    },
                    {
                        "username": "DipeshKumar24",
                        "content": "This question  was asked in an Amazon SDE-1 Interview"
                    },
                    {
                        "username": "mission_2023",
                        "content": "In C# [,] represents a 2d array\\n[][] is called jagged array.\\n\\nPlease change it. Else it is getting lots of confusion."
                    },
                    {
                        "username": "Ak_15",
                        "content": "consider like a matrix with n rows and 2 column... eg\\n00 01\\n10 11\\n20 21"
                    },
                    {
                        "username": "dwijrajbhattacharyya",
                        "content": "Is it always in sorted fashion ? \\nstart of i < start of i+1 \\nfor all intervals ?"
                    },
                    {
                        "username": "neerajsanwal05",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  intervals should be non decreasing then how you got [1,0] in a valid test case?\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "no , I got a test case [ [1,0] , [0,1] ] that made the test case fail , so I just sorted the array to get it working . "
                    },
                    {
                        "username": "sjain24",
                        "content": "How do we decide if we need to sort wrt the end interval or the start interval ? I get really confused which one to do when, if anyone has any logic behind it kindly help."
                    },
                    {
                        "username": "hankoc",
                        "content": "You can sort by end or start positions - which one you choose doesnt matter as long as the intervals are sorted and your logic should change accordingly.\n\nIt was more intuitive for me to sort by end positions - and it works."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude ended up with amazon and adobe "
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think that in this problem we sort by the `start_time` of the intervals, because we are join them, so one need to know if the latter interval will start before the former one ends.\\n\\nIn other questions, we sort by the `end_time`, because we just remove intervals, and need to return the maximum possible intervals which doesnt overlap. so we want the ones with the bigger end_time(s) to be the last which we check.\\n(If we check the other way around, we can remove the maximum intervals & return the fewest intervals possible)\\nNot sure it will happen always, but it can."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "As mentioned before start interval is less than end interval, then its obvious that we have to sort inorder to starting interval.\\n"
                    },
                    {
                        "username": "MavsLee",
                        "content": "want to discuss about the FB follow up question, \"How do you add intervals and merge them for a large stream of intervals? (Facebook Follow-up Question)\" from here, https://leetcode.com/problems/merge-intervals/discuss/355318/Fully-Explained-and-Clean-Interval-Tree-for-Facebook-Follow-Up-No-Sorting \\n\\nIf this is an real world abstrcted problem, i\\'d prefer to use divide and conquer technique depends on the requirements. For example, partitioning input intervals based on interval start/end value, i.e we have 1000 buckets, inside each bucket we maintain a sorted intervals, each bucket can be in one machine or multiples buckets in one machine. then we use merge those bucket 2 by 2 until to the point each bucket contains maximum intervals. And make sure no intervals are across two buckets\\n\\nFor either endless incoming stream mentioned here or memory is too small to load all intervals, this approach should work. \\nthis BST approach is impresive but not realistic for me to write in the interview\\nhttps://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!\\n\\nHope this can help, thanks"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Connected Components\n\n  \n**Approach 2:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1573399,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1573375,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1572372,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571138,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571139,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2001699,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1758109,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1734797,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1572810,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1571140,
                "content": [
                    {
                        "username": "liurenjie",
                        "content": "Let\\'s say the test case is like [[1,3], [3, -20]]. Should the result be [[-20, 3]]?\\n\\nNow if I put in above test case, the answer is [[1,3]], which I don\\'t think is correct.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Interval is not negative. Read problem constraints "
                    },
                    {
                        "username": "harshaldhumal15",
                        "content": "In 3rd Constraints  it\\'s clearly mentioned 0 <= starti <= endi <= 10^4"
                    },
                    {
                        "username": "ajk251",
                        "content": "Not given the constraints. They say an interval should be between [0, 10\\u2074]."
                    },
                    {
                        "username": "Amit_Zerikunthe",
                        "content": "bro check out constraint first , they have clearly mentioned that start and end should be >=0 ....."
                    },
                    {
                        "username": "user9465Vr",
                        "content": "firstly you should check the constraint he clearly told that start and end should be greater or equal to 0."
                    },
                    {
                        "username": "mishra_anurag",
                        "content": "your testcase is wrong, start should be less than/equal to end interval."
                    },
                    {
                        "username": "janetzki",
                        "content": "The problem description does not state that all interval starts are less or equal than their ends. However, this is true for all test cases."
                    },
                    {
                        "username": "oscardoudou",
                        "content": "using origin comparator overwrite compare is like beat 50%\\n However using lamda  beats only 12%, it is huge difference why is that?"
                    },
                    {
                        "username": "wadephz",
                        "content": "Hi, just wondering if there is a way to do this with a faster time than O(nlogn)."
                    },
                    {
                        "username": "h12311334",
                        "content": "When I use the following code:\\n\\n    bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n    sort(intervals.begin(),intervals.end(),cmpStart);\\n\\nOJ shows me \"invalid use of non-static member function\". So, I changed the code to:\\n\\n    static bool cmpStart(Interval &a, Interval &b){return a.start<b.start;}\\n\\nAnd it is accepted.\\nSo, why must the compare function be static?\\nThank you."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Want to learn more about guidelines for this Merge Intervals ?"
                    },
                    {
                        "username": "mars_999",
                        "content": "Intuition here for merging is checking an interval with all other intervals for overlapping. But the time complexity is O(n^2)  which is brute force solution. \\nWhen we sort (O(nlogn)) intervals based on start time, then you can compare the adjacent intervals and merge if overlapping instead of checking with every interval. This is better than brute force."
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(n), since we are storing the sorted intervals and the merged intervals in separate arrays.\\n\\nThe time complexity is also O(n), since we are iterating through the intervals once to sort them and once to merge them. The sorting operation has a time complexity of O(n log n) in the average case, but since we are only sorting a small list of intervals (the number of intervals is at most the number of elements in the input array), the time complexity of the overall solution is still O(n).\\n\\nTherefore, this solution should be efficient enough for most practical purposes. However, if you need to optimize for time complexity even further, you could consider using a more efficient sorting algorithm, such as quicksort or radix sort. These algorithms have a time complexity of O(n) in the average case, which would make the overall time complexity of the solution O(n)."
                    },
                    {
                        "username": "jianminchen",
                        "content": "I like to put together a post to list all practice I can come out for this algorithm. One goal is to learn and refresh C#, another one is to share my learning through the future mock interviews. I plan to ask this common algorithm in mock interview as an interviewer. \\n\\n[C# First practice using LINQ in Feb 2017](https://leetcode.com/problems/merge-intervals/discuss/325577/C-First-practice-using-LINQ-in-Feb-2017)\\n\\n[C# IComparer class definition practice in February 2017](\\nhttps://leetcode.com/problems/merge-intervals/discuss/325614/C-IComparer-class-definition-practice-in-February-2017)\\n\\n\\n\\n"
                    },
                    {
                        "username": "woojohn911",
                        "content": "I got a runtime error when there is a long input but my browser only displays part of the \"Last executed input\". I tested locally on that part of input and it was fine. Does anybody bump into the same problem and know how to deal with this? Environment: OSX 10.8 or 10.9, Safari 6 or Chrome v35.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1567581,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2076035,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2052436,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2037298,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2037269,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2032857,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 2001692,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1980319,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1964672,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1959146,
                "content": [
                    {
                        "username": "KaziNizamul",
                        "content": "### Approach 1 : Brute Force \\n![image](https://assets.leetcode.com/users/images/b5da7e92-9e52-489f-a13a-1896bc20e1d3_1613558252.2323694.png)\\n\\n\\n###### **Please dry run this with example test case**\\n\\n<hr> <hr> <br> <br>\\n\\n### Approach 2 : single pass\\n![image](https://assets.leetcode.com/users/images/69276936-2753-4d6f-aeec-0d4bf93c11b7_1613561381.7499874.png)\\n<hr> <hr> <br> <br>\\n\\n### Approach 3 : single pass  + in place \\n(but not O(n) due to splice)\\n![image](https://assets.leetcode.com/users/images/eb95a890-83b6-4177-aa25-dca04b9e1682_1613561366.6650376.png)\\n"
                    },
                    {
                        "username": "huntxr",
                        "content": "Can this be solved in O(n) time and O(1) space?"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n     static int[][] sort(int[][] arr){\\n        if(arr.length==1){\\n            return arr;\\n        } else if (arr.length==2) {\\n            int[][] ans = new int[2][];\\n            if(arr[0][0]<arr[1][0]){\\n                ans[0]=arr[0];\\n                ans[1]=arr[1];\\n            }else{\\n                ans[0]=arr[1];\\n                ans[1]=arr[0];\\n            }\\n            return ans;\\n        }\\n        int mid = arr.length/2;\\n        int[][] arr1,arr2;\\n        if(arr.length%2!=0){\\n             arr2 = new int[(arr.length+1)/2][];\\n             arr1 = new int[mid][];\\n        }else{\\n             arr1 = new int[mid][];\\n             arr2 = new int[mid][];\\n        }\\n        for(int i=0;i<arr.length;i++){\\n            if(i<mid){\\n                arr1[i]=arr[i];\\n            }else{\\n                arr2[i-mid]=arr[i];\\n            }\\n        }\\n        arr1=sort(arr1);\\n        arr2=sort(arr2);\\n\\n        int[][] ans=new int[arr.length][];\\n        int i1=0,i2=0;\\n        int i=0;\\n        for(;i<ans.length && i1<arr1.length && i2<arr2.length;i++){\\n            if(arr1[i1][0]<arr2[i2][0]){\\n                ans[i]=arr1[i1];\\n                i1++;\\n            }else{\\n                ans[i]=arr2[i2];\\n                i2++;\\n            }\\n        }\\n        if(i1==arr1.length && i2!=arr2.length){\\n            while(i<ans.length){\\n                ans[i]=arr2[i2];\\n                i2++;\\n                i++;\\n            }\\n        } else if (i2==arr2.length && i1!=arr1.length) {\\n            while(i<ans.length){\\n                ans[i]=arr1[i1];\\n                i1++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int[][] merge(int[][] intervals) {\\n        intervals=sort(intervals);\\n        int n = intervals.length;\\n        if(n==1){\\n            return intervals;\\n        }\\n         for(int i=0;i<intervals.length-1;i++){\\n            int max1 = intervals[i][1];\\n            if(max1>=intervals[i+1][0]){\\n               while(i<intervals.length-1 && max1>=intervals[i+1][0]){\\n                   max1=Math.max(max1,intervals[i+1][1]);\\n                   n--;\\n                   i++;\\n               }\\n            }\\n        }\\n        int[][] ans = new int[n][2];\\n        int i=0,j=0;\\n        for(;i<intervals.length-1;i++,j++){\\n           int min = intervals[i][0];\\n           int max = intervals[i][1];\\n           while(i<intervals.length-1 && max>=intervals[i+1][0]){\\n               min=Math.min(min,intervals[i+1][0]);\\n               max=Math.max(max,intervals[i+1][1]);\\n               i++;\\n           }\\n           ans[j][0]=min;\\n           ans[j][1]=max;\\n        }\\n        if(j==ans.length-1 && i==intervals.length-1){\\n            ans[j]=intervals[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Asha629399",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n\\n        if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n            \\n        }\\n        \\n    return result;\\n    \\n    }\\n};\\n\\nin this code i am ran it manually and it hould give output : [[1,3],[4,7]]   for the input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but it is giving output as [[1,3],[4,6],[5,7]]  on leetcode console why ??"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Asha629399",
                        "content": "so this is my code :\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        int i;\\n        if(intervals.size()==1){\\n            return intervals;\\n        }\\n        sort(intervals.begin(), intervals.end());\\n             if(intervals[1][0]<=intervals[0][1]){\\n                if(intervals[0][1]>intervals[1][1]){\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n                }\\n                else{\\n                    result.emplace_back(vector<int>{intervals[0][0],intervals[1][1]});\\n                }\\n        }\\n        else{\\n             result.emplace_back(vector<int>{intervals[0][0],intervals[0][1]});\\n             result.emplace_back(vector<int>{intervals[1][0],intervals[1][1]});\\n        }\\n        if(intervals.size()==2){\\n            return result;\\n        }\\n        for(i=2;i<intervals.size();i++){\\n            if(intervals[i][0]<=result.front()[1]){\\n                if(intervals[i][1]>result.front()[1]){\\n                    result.front()[1]=intervals[i][1];\\n                }\\n            }\\n            else{\\n                result.emplace_back(vector<int>{intervals[i][0],intervals[i][1]});\\n            }\\n         }\\n        return result;\\n    }\\n};\\n\\nthis is my approach i ran it manually and it should give correct answer that is [[1,3],[4,7]]  for input [[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]  but on leetcode output is showing as [[1,3],[4,6],[5,7]].  can anyone take a look at my code??"
                    },
                    {
                        "username": "Metody",
                        "content": "I think the last testcase is currently broken since there is no input and no expected output."
                    },
                    {
                        "username": "onoriodeunu",
                        "content": "Greetings! Impressive priorities"
                    },
                    {
                        "username": "Shefali16",
                        "content": "If anyone  has done this question using sweep line algorithm approach then please share  the solution."
                    },
                    {
                        "username": "sonalisharma2520",
                        "content": "BRUTE FORCE\\nvector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        sort(intervals.begin(),intervals.end());\\n        int start=intervals[0][0];\\n        int end=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n           if(intervals[i][0]<=end){\\n               end=max(intervals[i][1],end);\\n           }\\n           else{\\n               ans.push_back({start,end});\\n               start=intervals[i][0];\\n               end=intervals[i][1];\\n           }\\n        }\\n        ans.push_back({start,end});\\n        return ans;\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mochiball",
                        "content": "I didn\\'t realize this but after merging, we need to update this value back into the original array. \\n\\ni.e if the merged interval also overlaps with another interval, we need to account for this.\\n\\nDrove me insane figuring this out "
                    }
                ]
            },
            {
                "id": 1952091,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1922819,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1915199,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1898059,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1887702,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1885784,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1844220,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1807815,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1807019,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1804679,
                "content": [
                    {
                        "username": "JustinAdams",
                        "content": "Edge cases here can get you. Make sure you consider what happens if an interval falls entirely within the previous interval and not just a single overlap."
                    },
                    {
                        "username": "PrateekSaikia",
                        "content": "Getting below error for longer testcases, I am using 2 for loops and also using a comparator \n\nEdit - The error is in the comparator function. can anyone explain why this error comes up? Below is my comparator code\nstatic bool compare(const vector<int>& a, const vector<int>& b) {\n        if (a[0] <= b[0]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n `Line 1052: Char 9: runtime error: reference binding to null pointer of type 'const __gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type' (aka 'const int') (stl_vector.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1061:9`"
                    },
                    {
                        "username": "krishnanmui",
                        "content": "vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n    for(int i=0;i<intervals.size();i++)\\n    {\\n        pq.push(intervals[i]);\\n    }   \\n    vector<vector<int>>ans;\\n    while(!pq.empty())\\n    {\\n        vector<int>temp = pq.top();\\n        pq.pop();\\n        vector<int>temp1 = pq.top();\\n        if(temp[1]>=temp1[0])\\n        {\\n            pq.pop();\\n            pq.push({temp[0],max(temp1[1],temp[1])});\\n        }\\n        else\\n        {\\n            ans.push_back(temp);\\n        }\\n    }   \\n    return ans;\\n}\\n\\nThis code works in my compiler but gives me run time error in LeetCode. Can someone helps me out."
                    },
                    {
                        "username": "piyush024",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int n=intervals.size(),i=1;\\n        while(i<n){\\n            vector<int>a;\\n            int j=i-1,ct=0;\\n            while(intervals[j+1][1]>=intervals[j][0] and j<intervals.size()){ \\n                j++;\\n                ct=1;\\n            }\\n            a.push_back(intervals[i-1][0]);\\n            a.push_back(intervals[j][1]);\\n            ans.push_back(a);\\n            if(ct=1)\\n                i=j+1;\\n            else \\n                i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\nI\\'m confused why this code is giving buffer overflow error. Can someone explain?\\n\\n"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "intervals: [[1,1],[2,2],[0,0],[2,3],[1,3],[3,5],[2,3],[3,5]]\\nOutput: [[0, 0], [1, 5]]\\nExplanation: Why [0,0] is in the front of output? This is because merged should be appended to right hand side!!! Something not specified in problem statement. You figure that part out via trial and error. Another example leetcode dont say everything in problem statement, verbal desc is flawed."
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "Variation of this question or you can say twist of words i was asked in an interview\\n\\nGiven a few time slots like \\n{{1012,1136} , {1137 , 1417} , {1015,1020}} \\nwhere 1012 means 10:12 \\nfind how many cars can be parked at the same time interval \\nInput  arr = {{1012,1136} , {1137 , 1417} , {1015,1020}} \\nOutput : 2 {{1012,1136} , {1137,1417}"
                    },
                    {
                        "username": "savitor",
                        "content": "Can somebody check and tell why this solution doesn\\'t work?\\n\\n ```\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        \\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b){\\n            return a[0] < b[0];\\n            });\\n        \\n        int index = 0;\\n        \\n        for(int i = 1; i<intervals.size(); i++)\\n        {\\n           if(intervals[index][1]  >= intervals[i][0]){\\n               intervals[index][1] = max(intervals[index][1],intervals[i][1]);\\n           }else{\\n               index++;\\n               intervals[index][0] = intervals[i][0];\\n               intervals[index][1] = intervals[i][1];\\n           }\\n        }\\n        \\n        return intervals;\\n    }\\n```"
                    },
                    {
                        "username": "F-said",
                        "content": "Hey everyone, so I was planning on using the merge interval pattern to solve this question in Python 2. The implementation was straight-forward: sort the list by the first index, find intervals, etc.\n\nHowever, my very first line of code that sorted this list was failing! As far as I saw, this followed correct semantics:\n\n`sorted(intervals, key=lambda x: x[0])`\n\nHowever, when attempting to sort a list of `[[1, 4], [0, 4]]` the `sorted()` function would keep this list in the same order even though `1 < 0`.\n\nI ended up using `intervals.sort(key = lamda x: x[0])` which did the trick, but what was I misunderstanding with my former `sorted()` function? Thanks for any insight."
                    },
                    {
                        "username": "Coderner",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end());\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][0]<=intervals[i-1][1])\\n            {\\n                intervals[i-1][1]=max(intervals[i][1],intervals[i-1][1]);\\n                intervals.erase(intervals.begin()+i);\\n                i--;\\n            }\\n        }\\n        return intervals;\\n    }\\n}; \\n\\nCan someone -please explain why i am getting a tle"
                    },
                    {
                        "username": "valeriya17",
                        "content": "anyone else get stuck on time limit exceeded for the last test case (170), where intervals is blank. I have an if statement for intervals.empty(), and i see no problem when I attempt it in my own test case run."
                    }
                ]
            },
            {
                "id": 1801156,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1799815,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1791113,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1791112,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1775220,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1766551,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1755485,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1742517,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1738835,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1735110,
                "content": [
                    {
                        "username": "yueayase",
                        "content": "I think we should add greedy tag in the Related Topics because the idea is similar to activity-schedule problem in CLRS"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**To merge overlapping intervals, you can follow these steps:**\\n\\n- Sort the intervals based on their start time.\\n- Initialize an empty list to hold the merged intervals.\\n- Iterate over each interval in the sorted list.\\n- If the current interval overlaps with the previous merged interval (i.e., the end time of the previous interval is greater than or equal to the start time of the current interval), merge the two intervals by updating the end time of the previous interval to the maximum of the end time of both intervals.\\n- If the current interval does not overlap with the previous merged interval, add the previous merged interval to the list of merged intervals and set the current interval as the new previous merged interval.\\n- After the loop is complete, add the final merged interval to the list of merged intervals (since it will not have been added yet)."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> res;\\n        if(intervals.size()==0)\\n        return res;\\n        sort(intervals.begin(),intervals.end(),[](vector<int>&a,vector<int>&b){\\n            return a[0]<b[0];\\n        });\\n        vector<int> curr=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(curr[1]<intervals[i][0]){\\n                res.push_back(curr);\\n                curr=intervals[i];\\n            }else\\n            curr[1]=max(curr[1],intervals[i][1]);\\n        }\\n        res.push_back(curr);\\n        return res;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "bobysinghsaini236",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "thalodsanjeev",
                        "content": "Can anyone tell what\\'s wrong with this code. It\\'s showing heap overflow\\n\\n\\nstatic bool sortcol(const vector<int>& v1, const vector<int>& v2)\\n    {\\n        return v1[0] < v2[0];\\n    }\\n    vector<vector<int>> merge(vector<vector<int>>& arr) {\\n        //Sorting Based on 0-index\\n        sort(arr.begin(),arr.end(),sortcol);\\n        vector<vector<int>>ans;\\n        int i = 0,ini;\\n        while(i < arr.size()){\\n            ini = i;\\n            if(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                while(arr[i+1][0] and arr[i][1] > arr[i+1][0]){\\n                    i++;\\n                }\\n                ans.push_back({arr[ini][0],arr[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({arr[i][0],arr[i][1]});\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "ur i index in while loop should run i<arr.size()-1 else i+1 index will go out of bound when i =arr.size()-1;"
                    },
                    {
                        "username": "kuldeepdixit96",
                        "content": "I have a doubt... a few moments ago my same code was giving TLE now it is getting accepted. Although it is beating only 5% solutions..but that doesnt matter.... I want to understand why it was giving TLE back then \nthis is the code for ref;\n```\n class Solution {\npublic:\nstatic bool comp(vector<int> a ,vector<int> b){\n    return a[0]<b[0];\n}\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), comp);\n        for(int i =0;i<intervals.size()-1;i++){\n            if(intervals[i][1]>=intervals[i+1][0]){\n                intervals[i+1][0] = intervals[i][0];\n                intervals[i+1][1] = intervals[i][1]>=intervals[i+1][1]?intervals[i][1]:intervals[i+1][1];\n                intervals.erase(intervals.begin()+i);\n                i--;\n            }\n            \n        }\n        return intervals;\n    }\n};\n```"
                    },
                    {
                        "username": "ritu7999",
                        "content": "class Solution {\\n    public int[][] merge(int[][] v) {\\n        int n=v.length;\\n        int m=v[0].length;\\n        Arrays.sort(v, (a,b)->a[0]-b[0]);\\n        ArrayList<ArrayList<Integer>>a=new ArrayList<>();\\n        \\n            for(int k=0;k<n;k++){\\n                 ArrayList<Integer>a1=new ArrayList<>(); \\n           if(a.isEmpty()||a.get(a.size() - 1).get(1) <v[k][0]){\\n                   a1.add(v[k][0]);\\n           a1.add(v[k][1]);\\n           a.add(a1); \\n                }\\n            else{\\n            a.get(a.size() - 1).set(1, Math.max(a.get(a.size() - 1).get(1),v[k][1]));\\n            }  \\n            }\\n            int[][] arr = a.stream()\\n                .map(l -> l.stream().mapToInt(Integer::intValue).toArray()).toArray(int[][]::new);\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "In java , we declare array with fixed size , but here we don\\'t know the exact size of answer array going to be ..its better to return arraylist than\\narray ! [@LeetCode](/LeetCode)"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "you have to use a different data structure like a stack to implement this, and then you can easily set the length of the matrix to be the size of stack"
                    },
                    {
                        "username": "DavalC",
                        "content": "This implementation first sorts the intervals by start time. It then iterates through the sorted intervals and keeps track of the current interval and the previous interval in the result. If the current interval overlaps with the previous interval, it merges them by updating the end time of the previous interval to the maximum of the two end times. If the current interval does not overlap with the previous interval, it adds it to the result.\\n\\nThe space complexity of the mergeIntervals function is O(n), since it stores all the intervals in the input in the result array. The time complexity is also O(n), since it iterates through the intervals once and performs a constant amount of work for each interval.\\n\\nThe sorting step of the function has a time complexity of O(n * log(n)), since it uses the built-in Swift sorted function, which uses a comparison-based sorting algorithm with a time complexity of O(n * log(n)). However, since the constant factor for this step is relatively small, it is not the dominant term in the overall time complexity."
                    },
                    {
                        "username": "Mohsin_Qureshi",
                        "content": "** Basic Aproach **\n1. Covert interval array to arraylist\n2. sort it based on interval start value\n3. loop through the list as check whether the cur and prev intervals over lap , if true remove current and previous interval and  insert the combine intervals. and decrement  loop iteration to -1;\nif false incremenet  loop iteration to +1;\n"
                    }
                ]
            },
            {
                "id": 1729146,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1720918,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1714398,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1710364,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1707869,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1707650,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1680562,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1648697,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1637633,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            },
            {
                "id": 1631126,
                "content": [
                    {
                        "username": "GeetMukherjee",
                        "content": "C++ Solution\\n\\n vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n\\n        for(int i=0; i<intervals.size();i++){\\n            if(output.empty()|| output.back()[1]<intervals[i][0]){\\n                vector<int>temp = intervals[i];\\n                output.push_back(temp);\\n            }else{\\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\\n                }\\n            }\\n            return output;\\n    }"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "Which ancient version of Kotlin does Leet use? I keep running into compilation failures because it doesn\\'t understand some legit Kotlin syntax"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin() ,intervals.end());\\n        int n = intervals.size();\\n        vector<vector<int>>ans;\\n        for(int i =0; i<n; i++)\\n        {\\n            if(ans.empty())\\n            {\\n                ans.push_back(intervals[i]);\\n            }\\n            else\\n            {\\n                vector<int>&v =ans.back();\\n                int y = v[1];\\n                // store the end value of the prev element\\n                if(intervals[i][0]<=y)\\n                //  and compare the current start time to the end time of prev element\\n                {\\n                    v[1] =max(y ,intervals[i][1]);\\n                   // {[1][4] ,[2,6]}\\n                   // {[1,6]}\\n\\n                }\\n                else\\n                {\\n                    ans.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nc++ easy and simple solution::"
                    },
                    {
                        "username": "yuany7",
                        "content": "A Super Fast Clue to solve this problem using Python:\\n\\n-> sort the interval first and then merge it. \\n\\nI sort the interval into ascending order using the sort() method. \\n\\nStore the first interval into a new variable \"answer\" as a list of list. \\n\\nThen loop through the intervals and compare the first element of the current interval to the last element of the last interval being stored in \"answer\". \\n\\nIf intervals[current][0] is smaller than answer[-1][1], use the max() and min() method to update the last interval being stored in \"answer. \\nOtherwise, append the current interval to answer.\\n\\nFinally return \"answer\"."
                    },
                    {
                        "username": "arbhav_coder",
                        "content": "can we use  space in this question \\n"
                    },
                    {
                        "username": "antripathi",
                        "content": "can someone suggest me what is wrong in my code as im not getting correct ans:\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int idx=0;\\n        int i=1;\\n\\n        for(;i<intervals.size();i++)\\n        {\\n            if(intervals[i][0]<=intervals[idx][1])\\n            {\\n                intervals[idx][1]=intervals[i][1];\\n\\n            }\\n            else\\n            idx++;\\n            intervals[idx][0]=intervals[i][0];\\n            intervals[idx][1]=intervals[i][1];\\n        }\\n        for(int j=idx+1;j<intervals.size();j++)\\n        {\\n            intervals.pop_back();\\n        }\\n        return intervals;\\n    }\\n};"
                    },
                    {
                        "username": "senalw",
                        "content": "Java Solution using Stack. \\n```class Solution {\\n    public int[][] merge(int[][] intervals) {\\n\\n        Arrays.sort(intervals, Comparator.comparingInt((int[] a) -> a[0]));\\n        Stack<int[]> stack = new Stack();\\n\\n        int previous = Integer.MIN_VALUE;\\n        for(int[] array: intervals){\\n            if(array[0] <= previous && previous < array[1]){\\n                int[] previousArr = stack.pop();\\n                previousArr[1] = array[1];\\n                previous = array[1];\\n                stack.push(previousArr);\\n            }else if(previous < array[1]){\\n                previous = array[1];\\n                stack.push(array);\\n            }\\n\\n        }\\n\\n        int[][] output = new int[stack.size()][2];\\n        int elementLen = stack.size()  -1;\\n        while(!stack.isEmpty()){\\n            if(elementLen >= 0){\\n                int[] arr = stack.pop();\\n                output[elementLen][0] = arr[0];\\n                output[elementLen][1] = arr[1];\\n                elementLen--; \\n            }\\n        }\\n\\n        return output;\\n    }\\n}\\n @```"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/merge-intervals-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "srakash37",
                        "content": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals)\n    {\n      sort(intervals.begin(),intervals.end());\n      int n=intervals.size();\n      vector<vector<int>>ans;\n      ans.push_back(intervals[0]);\n      for(int i=1;i<n;i++)\n      {\n        if(ans.back()[1]>=intervals[i][0])\n        ans.back()[1]=max(ans.back()[1],intervals[i][1]);\n        else\n        ans.push_back(intervals[i]);\n      }  \n      return ans;\n    }``\n\n    //ans.back()[0]=starting of the interval\n    //ans.back()[1]=ending of the interval\njust check  if the value at the end of one interval is greater than the next only then find out the max element and then merge the pairs\n};"
                    },
                    {
                        "username": "r4tahir2",
                        "content": "java\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Upside Down",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1575643,
                "content": [
                    {
                        "username": "elangovan911",
                        "content": "Am I missing something in this problem? the description says \"it is guaranteed that every node in the given tree has either 0 or 2 children.\" but the 3rd test case is [1,2]!!! Where is the right child and why does the root node get to have only one child? Also, there is no clear description given that says ignore the right subtree from this rearrangement. for the testcase of [1,2,3,4,5,6,7,8,9,10] i would expect 10 to become the root of 5 at the end but the final solution tree is same as original i.e. 5 is still the root of 10."
                    },
                    {
                        "username": "siulungdlaw",
                        "content": "The question is ambiguous.\n\nIn the case where the tree is \n1\n2, 3\n4,5, 6, 7\nThen what is parent of 3 after the transformation?\nOn one hand, 2 is supposed the parent because it is the right child of 1.\nOn the other hand, 6 is supposed the parent because 6 is the left child of 3.\n\n\n\n"
                    }
                ]
            },
            {
                "id": 1756545,
                "content": [
                    {
                        "username": "elangovan911",
                        "content": "Am I missing something in this problem? the description says \"it is guaranteed that every node in the given tree has either 0 or 2 children.\" but the 3rd test case is [1,2]!!! Where is the right child and why does the root node get to have only one child? Also, there is no clear description given that says ignore the right subtree from this rearrangement. for the testcase of [1,2,3,4,5,6,7,8,9,10] i would expect 10 to become the root of 5 at the end but the final solution tree is same as original i.e. 5 is still the root of 10."
                    },
                    {
                        "username": "siulungdlaw",
                        "content": "The question is ambiguous.\n\nIn the case where the tree is \n1\n2, 3\n4,5, 6, 7\nThen what is parent of 3 after the transformation?\nOn one hand, 2 is supposed the parent because it is the right child of 1.\nOn the other hand, 6 is supposed the parent because 6 is the left child of 3.\n\n\n\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Paint House",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564574,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1569675,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1576970,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1574974,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1571998,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1968722,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            },
            {
                "id": 1921476,
                "content": [
                    {
                        "username": "yuxiong",
                        "content": "Before 2014, there were less than 300 problems on Leetcode, and if you were able to solve all of them you could nail any algorithm interview in the US. Also, they didn\\'t ask many DP problems, most of the problems were related to linked lists, trees, sorting, matrix, math. I remember the hardest problem type at that time was recursion. So a problem like Paint House should be labeled as hard or at least medium back then.\\n\\nIn recent years, tech companies (especially Google) got crazy: they may ask you problems related to Priority Queue, Monotonic Stack, Bit Manipulation, Palindrome, KMP, DP, DFS, BFS, backtracking, Minimax tree,  Fenwick tree, Dijkstra, Bellman-ford, Floyd-Warshall, Floyd\\'s Tortoise and Hare......\\n\\nSo better get a job right now, imagine 10 years later the \"Easy\" problems could be: implementation of Red-Black tree, Hamiltonian cycle, Max-flow Min-cut..."
                    },
                    {
                        "username": "stefan1096",
                        "content": "The best post I have ever seen on Leetcode"
                    },
                    {
                        "username": "moodfire",
                        "content": "Love you for the nice problem!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for July, Week 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/paint-house/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute force\n\n  \n**Approach 2:** Brute force with a Recursive Tree\n\n  \n**Approach 3:** Memoization\n\n  \n**Approach 4:** Dynamic Programming\n\n  \n**Approach 5:** Dynamic Programming with Optimized Space Complexity\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "wmhlailenow",
                        "content": "What does the matrix in example 1 mean?\\nIs 17 means the cost or that?"
                    },
                    {
                        "username": "zomart",
                        "content": "This is already O(n3) . The code presented in many examples is hiding the complexity. "
                    },
                    {
                        "username": "underpaid_engineer",
                        "content": "Similar problem to minimum falling path sum.\\nHope it helps."
                    },
                    {
                        "username": "kevinmzy",
                        "content": "This problem is beam search, which is a basic method used in machine translation decoding."
                    }
                ]
            }
        ]
    },
    {
        "title": "Line Reflection",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565228,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1566501,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1572506,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1570322,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 2007950,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1820293,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 1571631,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            },
            {
                "id": 2066317,
                "content": [
                    {
                        "username": "dharaB",
                        "content": "If I have two points say (-4,1) and (-2, 6)\\nThen reflection of line is (4, 1) and (2, 6).\\n\\nSo For this problem if I have input set = [(-4,1), (-2, 6), (4, 1), (2, 6)]\\nThen it should return true. But say I've additional point on line which is\\nnot reflected then False.\\n\\nSo I'm thinking simplest O(n^2) solution first, (really didn't understand what question is!)\\n\\n1) For every point I need to find reflected point (-x, same y)\\n2) Then after grouping into two set, need to see in both group each point has same slope?\\n\\nIs my understanding of question right, if so what I think as brute-force (1) & (2) are right?"
                    },
                    {
                        "username": "michael78123",
                        "content": "According to the problem statement, \"Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points\", duplicate points on same (x, y) location should be regarded as different points.\\n\\nOne of the test cases has input \"[[16,1],[-16,1],[16,1]]\" and output \"true\"; however, it should be definitely \"false\".\\n\\nI would appreciate it if someone can kindly fix the test cases."
                    },
                    {
                        "username": "Tony_Pan",
                        "content": "I see [[-16,1],[16,1],[16,1]] is really a boring and unncecssary case which causes fail.\\nSo we have some points in the set and some of the points are actually the same point.\\nWTF is this? It doesn\\'t make any sense.\\nPlease stop posting this kind of problems. It\\'s wasting our time."
                    },
                    {
                        "username": "analyst74",
                        "content": "Given this input: [[1,1],[-1,1],[1,1]]\\n\\nThe evaluation returns True, but the reflected points is [[-1,1], [1,1], [-1,1]], which is different from the input, so correct result should be False, no?\\n\\n"
                    },
                    {
                        "username": "glard",
                        "content": "If I learn my math correctly, I thought there should be only one point on coordinate [x, y], wtf is wrong with the testcase with points =\\n[[-16,1],[16,1],[16,1]]?\\n"
                    },
                    {
                        "username": "andgorbik",
                        "content": "why [[0,0],[1,0]] -> true???"
                    },
                    {
                        "username": "dkhandu",
                        "content": "cause we can choose (1/2, 0) "
                    },
                    {
                        "username": "aaa45190",
                        "content": "With the Three points [[1,0], [1,0], [-1,0]], the answer is true. Should this correct?\\nSince it means [-1, 0] can reflect two points at the same position."
                    },
                    {
                        "username": "ltcoderrrr",
                        "content": "Should have not spending any time on this ambiguous question after reading Thumb-Down more than Thumb-Up."
                    }
                ]
            }
        ]
    },
    {
        "title": "132 Pattern",
        "question_content": "<p>Given an array of <code>n</code> integers <code>nums</code>, a <strong>132 pattern</strong> is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.</p>\n\n<p>Return <code>true</code><em> if there is a <strong>132 pattern</strong> in </em><code>nums</code><em>, otherwise, return </em><code>false</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no 132 pattern in the sequence.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,1,4,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There is a 132 pattern in the sequence: [1, 4, 2].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,3,2,0]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 94071,
                "title": "single-pass-c-o-n-space-and-time-solution-8-lines-with-detailed-explanation",
                "content": "QUESTION: To search for a subsequence (`s1,s2,s3`) such that `s1 < s3 < s2`.\\n\\nINTUITION: Suppose we want to find a `123` sequence with `s1 < s2 < s3`, we just need to find `s3`, followed by `s2` and `s1`. Now if we want to find a `132` sequence with `s1 < s3 < s2`, we need to switch up the order of searching. we want to first find `s2`, followed by `s3`, then `s1`. \\n\\nDETECTION: More precisely, we keep track of highest value of `s3` for each valid `(s2 > s3)` pair while searching for a valid `s1` candidate to the left.  Once we encounter any number on the left that is smaller than the largest `s3` we have seen so far, we know we found a valid sequence, since `s1 < s3` implies `s1 < s2`.\\n\\nALGORITHM: We can start from either side but I think starting from the right allow us to finish in a single pass. The idea is to start from end and search for valid `(s2,s3)` pairs, we just need to remember the largest valid `s3` value, using a `stack` will be effective for this purpose. A number becomes a candidate for `s3` if there is any number on the left bigger than it. \\n\\nCORRECTNESS: As we scan from right to left, we can easily keep track of the largest `s3` value of all `(s2,s3)` candidates encountered so far. Hence, each time we compare `nums[i]` with the largest candidate for `s3` within the interval `nums[i+1]...nums[n-1]` we are effectively asking the question: **Is there any 132 sequence with `s1 = nums[i]`?**  Therefore, if the function returns false, there must be no 132 sequence.\\n\\nIMPLEMENTATION: \\n1) Have a `stack`, each time we store a new number, we first `pop` out all numbers that are smaller than that number. The numbers that are `popped` out becomes candidate for `s3`.\\n2) We keep track of the `maximum` of such `s3` (which is always the most recently `popped` number from the `stack`).\\n3) Once we encounter any number smaller than `s3`, we know we found a valid sequence since `s1 < s3` implies `s1 < s2`.\\n\\nRUNTIME: Each item is `pushed` and `popped` once at most, the time complexity is therefore O(n).\\n\\nEXAMPLE: \\n`i = 6`, **nums** =  [ 9, 11, 8, 9, 10, 7, `9` ], **S1 candidate** = `9`, **S3 candidate** = `None`, **Stack** = `Empty`\\n`i = 5`, **nums** =  [ 9, 11, 8, 9, 10, `7`, 9 ], **S1 candidate** = `7`, **S3 candidate** = `None`, **Stack** = `[9]`\\n`i = 4`, **nums** =  [ 9, 11, 8, 9, `10`, 7, 9 ], **S1 candidate** = `10`, **S3 candidate** = `None`, **Stack** = `[9,7]`\\n`i = 3`, **nums** =  [ 9, 11, 8, `9`, 10, 7, 9 ], **S1 candidate** = `9`, **S3 candidate** = `9`, **Stack** = `[10]`\\n`i = 2`, **nums** =  [ 9, 11, `8`, 9, 10, 7, 9 ], **S1 candidate** = `8`, **S3 candidate** = `9`, **Stack** = `[10,9]` **We have `8<9`, sequence `(8,10,9)` found!**\\n\\nEDIT: Thanks @Pumpkin78 and @dalwise for pointing out that the maximum candidate for s3 is always the recently popped number from the stack, because if we encounter any entry smaller than the current candidate, the function would already have returned.\\nEDIT 2: Rephrased explanations and added a sketch of the correctness proof.\\n\\n```\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94089,
                "title": "java-solutions-from-o-n-3-to-o-n-for-132-pattern-updated-with-one-pass-slution",
                "content": "This is a summary of the four solutions for this problem. It starts with the `O(n^3)` naive solution, then transition to the `O(n^2)` sub-optimal solution and finally to the two optimized `O(n)` solutions (one is two-pass while the other is one-pass). \\n\\n---\\n\\n**`I. Naive O(n^3) solution`**\\n\\nThe naive `O(n^3)` solution is a no-brainer --- simply check every `(i, j, k)` combination to see if there is any `132` pattern.\\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n        for (int j = i + 1; j < nums.length; j++) {\\n            for (int k = j + 1; k < nums.length; k++) {\\n                if (nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\\nAnd of course it will get rejected due to TLE. So let's see how we can do better.\\n\\n---\\n\\n**`II. Improved O(n^2) solution`**\\n\\nTo reduce the time complexity down to `O(n^2)`, we need to do some observations. In the naive solution above, let's assume we have index `j` fixed, what should index `i` be so that it is most probable we will have a `132` pattern? Or in other words, what should `i` be so that we will be certain there is no such `132` pattern for combination `(*, j, *)` whenever there is no `132` pattern for combination of `(i, j, *)`? (Here `*` means any index before or after index `j`.)\\n\\nThe answer lies in the fact that once the first two numbers `nums[i]` and `nums[j]` are fixed, we are up to find the third number `nums[k]` which will be within the range `(nums[i], nums[j])` (the two boundaries are exclusive). Intuitively the larger the range is, the more likely there will be a number \"falling into\" it. Therefore we need to choose index `i` which will maximize the range `(nums[i], nums[j])`. Since the upper bound `nums[j]` is fixed, this is equivalent to minimizing the lower bound `nums[i]`. Thus it is clear `i` should be the index of the minimum element of the subarray `nums[0, j)` (left inclusive, right exclusive).\\n\\nSince we are scanning index `j` from the beginning of the input array `nums`, we can keep track of the minimum element of the subarray from index `0` up to `j - 1` without rescanning it. Therefore the first two loops in the naive solution can be combined into one and leads to the following `O(n^2)` solution:\\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int j = 0, min = Integer.MAX_VALUE; j < nums.length; j++) {\\n         min = Math.min(nums[j], min);\\n         if (min == nums[j]) continue;\\n         \\n         for (int k = nums.length - 1; k > j; k--) {\\n             if (min < nums[k] && nums[k] < nums[j]) return true;\\n         }\\n     }\\n     \\n     return false;\\n}\\n```\\nWhile this solution can be accepted, it runs slow. One obvious drawback is that in the second loop we are throwing away information about elements in the right part of `nums` that may be \"useful\" for later combinations. It turns out we can retain this \"useful\" information by applying the classic space-time tradeoff, which leads to the following `O(n)` time and `O(n)` space solution.\\n\\n---\\n\\n**`III. Optimized O(n) solution`**\\n\\nAs I mentioned, to further reduce the time complexity, we need to record the \"useful\" information about elements in the right part of the input array `nums`. Since these elements are located at the right part of `nums`, it will be hard to do so if we are scanning the array from the beginning. So the idea is to scan it from the end while in the meantime keep track of the \"useful\" information. But still at each index `j`, we need to know the minimum element for subarray `nums[0, j)`. This can be done by doing a pre-scan in the forward direction and memorize the results for each index in an auxiliary array (we will call the array as `arr` whose element `arr[j]` will denote the minimum element in the subarray `nums[0, j)`).\\n\\nUntil now we are kinda vague about the exact meaning of \"useful\" information, so let's try to be more specific. Assume we're currently scanning (from the end) the element with index `j`, our task is to find two elements `nums[i]` and `nums[k]` to determine if there exists a `132` pattern, with `i < j < k`. The left element `nums[i]`, as it has been shown in part `II`, will be chosen as `arr[j]`, the minimum element of subarray `nums[0, j)`. What about the right element `nums[k]`?\\n\\nThe answer to that will address the meaning of \"useful\" information. First note we are only interested in elements that are greater than `arr[j]`, so it is sensible to maintain only those elements. Second, among all these qualified elements, which one will be the most probable to fall into the range `(nums[i], nums[j])`? I would say it is the smallest one (i.e., if the smallest one is out of the range, all others will also be out of range). So to sum up, the \"useful\" information for current index `j` will be a collection of scanned elements that are greater than `arr[j]`, and `nums[k]` will be chosen as the smallest one if the collection is not empty.\\n\\nFrom the analyses above, it looks like we have to do some sorting stuff for the retained elements (or at least find a way to figure out its smallest element). Well, it turns out these elements will be sorted automatically due to the fact that `arr[j'] >= arr[j]` as long as `j' < j`. Here is how it goes, which is a proof by induction.\\n\\nAt the beginning we have an empty collection and of course it is sorted. Now suppose we are at index `j` and the corresponding collection is still sorted, let's see if it remains so at index `j - 1`. First we will check if `nums[j]` is greater than `arr[j]`. If not, we simply continue to `j - 1`. Since the collection is intact so it will be sorted at `j - 1`. Otherwise, we need to remove elements in the collection that are no greater than `arr[j]` (this is necessary because some smaller elements may be left over in the collection from previous steps). After removal, we then compare the first element in the collection with `nums[j]` to see if a `132` pattern has been found, provided the collection is not empty. If so, return true. Otherwise one of the following must be true: the collection is empty or `nums[j]` is no greater than the first element in the collection. In either case the collection is sorted. Now if we have `arr[j - 1] < nums[j]`, we need to add `nums[j]` to the collection since it is a qualified number for `arr[j - 1]`. Again in either case the collection will remain sorted after addition (if it is empty, after addition there is only one element; otherwise since the added element is no greater than the first element in the collection before addition, it will become the new first element after addition and the collection stays sorted).\\n\\nHere is the program with `O(n)` time and space complexity. There is one minor optimization based on the observation that the total number of elements in the collection will never exceed the total number of elements scanned so far. Therefore the right part of the `arr` array can be used to serve as the collection. For time complexity, each element in the input array `nums` will be pushed into and popped out from the collection (or stack to be exact) at most once, the time complexity will be `O(n)` despite of the nested loop.\\n```\\npublic boolean find132pattern(int[] nums) {\\n    int[] arr = Arrays.copyOf(nums, nums.length);\\n\\n    for (int i = 1; i < nums.length; i++) {\\n        arr[i] = Math.min(nums[i - 1], arr[i - 1]);\\n    }\\n    \\n    for (int j = nums.length - 1, top = nums.length; j >= 0; j--) {\\n        if (nums[j] <= arr[j]) continue;\\n        while (top < nums.length && arr[top] <= arr[j]) top++;\\n        if (top < nums.length && nums[j] > arr[top]) return true;\\n        arr[--top] = nums[j];\\n    }\\n        \\n    return false;\\n}\\n```\\n\\n---\\n\\n**`IV -- One-pass O(n) solution`**\\n\\nIt turned out that we don't need the `arr` array in part **`III`**, thus can get rid of the pre-scan. The idea is to do backward traversal of the input array and keep track of the maximum value (denoted as `third`) of all possible third numbers obtained so far (an element can be a candidate for the third number if and only if there is another element coming before and greater than it). This is because for two candidate third numbers `a` and `b`, if `a <= b` and there is no `132` pattern for `b`, then there must be no `132` pattern for `a` either. The idea is elaborated as follows. \\n\\nFor the current element being examined, we first check if it can be the first number by comparing it with `third`. If this is the case, a `132` pattern has been found. Otherwise, it will be treated as the second number to qualify scanned elements so far as candidate third numbers (note we are doing backward scan so the current element will always come before scanned elements). Of course we cannot do this for all scanned elements, as it will lead to an `O(n^2)` solution. Fortunately it suffices only to process scanned elements that are greater than `third`. This is because after an element is qualified to be the third number, it will only be used to update `third`. For those elements smaller than `third`, even if they are qualified to be the third number, they won't make `third` any larger and therefore can be ignored.\\n\\nSo we need to maintain a collection (stack, to be exact) for scanned elements that are greater than `third`. After the current element is done, it will be added to this collection for future processing. It can be shown by mathematical induction that elements in the collection will be sorted automatically, similar to that in part **`III`**. At the beginning the collection is empty so the base case is true. Assume the collection is sorted immediately before processing the current element, which is presumed to be `>= third` (otherwise a `132` pattern is found). We will scan the collection and pop out all elements smaller than the current element to find all qualified third numbers and update `third` accordingly. At the end, all remaining elements in the collection are no less than the current element, therefore adding the current element to the collection won't break the sorted property. So our induction assumption is also true.\\n\\nHere is the one-pass `O(n)` solution. We can also optimize the space cost to `O(1)` if the input array can act as the collection by taking advantage of the fact that size of the collection will never exceed the number of elements scanned so far.\\n\\n```\\npublic boolean find132pattern(int[] nums) {\\n    int n = nums.length, top = n, third = Integer.MIN_VALUE;\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (nums[i] < third) return true;\\n        while (top < n && nums[i] > nums[top]) third = nums[top++];\\n        nums[--top] = nums[i];\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean find132pattern(int[] nums) {\\n    for (int i = 0; i < nums.length; i++) {\\n        for (int j = i + 1; j < nums.length; j++) {\\n            for (int k = j + 1; k < nums.length; k++) {\\n                if (nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\npublic boolean find132pattern(int[] nums) {\\n    for (int j = 0, min = Integer.MAX_VALUE; j < nums.length; j++) {\\n         min = Math.min(nums[j], min);\\n         if (min == nums[j]) continue;\\n         \\n         for (int k = nums.length - 1; k > j; k--) {\\n             if (min < nums[k] && nums[k] < nums[j]) return true;\\n         }\\n     }\\n     \\n     return false;\\n}\\n```\n```\\npublic boolean find132pattern(int[] nums) {\\n    int[] arr = Arrays.copyOf(nums, nums.length);\\n\\n    for (int i = 1; i < nums.length; i++) {\\n        arr[i] = Math.min(nums[i - 1], arr[i - 1]);\\n    }\\n    \\n    for (int j = nums.length - 1, top = nums.length; j >= 0; j--) {\\n        if (nums[j] <= arr[j]) continue;\\n        while (top < nums.length && arr[top] <= arr[j]) top++;\\n        if (top < nums.length && nums[j] > arr[top]) return true;\\n        arr[--top] = nums[j];\\n    }\\n        \\n    return false;\\n}\\n```\n```\\npublic boolean find132pattern(int[] nums) {\\n    int n = nums.length, top = n, third = Integer.MIN_VALUE;\\n\\n    for (int i = n - 1; i >= 0; i--) {\\n        if (nums[i] < third) return true;\\n        while (top < n && nums[i] > nums[top]) third = nums[top++];\\n        nums[--top] = nums[i];\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906789,
                "title": "short-java-o-n-solution-with-detailed-explanation-sample-test-case-stack-100",
                "content": "*------Please **upvote** if you like the solution.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**EXPLANATION**:\\n\\n*Here, if we fix the peak, i.e. **3** in the **132 pattern**, then we can determine if any numbers on its left and right satisfy the given pattern.  We will do this with the help of a stack. Our stack implementation will take care of the **32 pattern** and then we will iterate over the array to find if any number satisfies the **1 pattern**.  See the algorithm below for better understanding*.  \\n\\n**Algorithm:**\\n\\n1. Create a stack and initialize a variable **second** with INT_MIN value.\\n2. Start traversing from the end of array.\\n3. Check if the current number is lesser than **second**. If it is, then it means our **132 pattern** is satisfied as the stack is taking care of the **32 pattern** and the current number satisfies the entire pattern. So return **true**.\\n4. If the above is not true, update the peak value in the stack. Keep popping from the stack until stack is empty OR the top value is greater than the current value.\\n5. Push the current number into the stack.\\n6. If the loop terminates, it means that the pattern was not found in the array.  So, return **false**.\\n\\n***Take the sample input as [3, 6, 4, 1, 2] and try out this algorithm using a pen & paper. You will be able to visualize the method then.***\\n\\nBasically, the **top** of stack is containing the **highest** number so far, i.e. **3** and **second** is containing the **second highest** number after the highest number, i.e. **2**.  So, this satisfies the **32 pattern**. Now, we will just keep updating **second** and **stack top** when we encounter a number which is greater than the highest number.\\n\\n```\\nclass Solution {\\n    public boolean find132pattern (int[] nums) {\\n        Stack <Integer> stack = new Stack ();\\n        int second = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums [i] < second)\\n                return true;\\n            while (!stack.isEmpty() && nums [i] > stack.peek ())\\n                second = stack.pop ();\\n            stack.push (nums [i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern (int[] nums) {\\n        Stack <Integer> stack = new Stack ();\\n        int second = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums [i] < second)\\n                return true;\\n            while (!stack.isEmpty() && nums [i] > stack.peek ())\\n                second = stack.pop ();\\n            stack.push (nums [i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94081,
                "title": "10-line-python-solution",
                "content": "```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        import sys\\n        stack = []\\n        s3 = -sys.maxint\\n        for n in nums[::-1]:\\n            if n < s3:\\n                return True\\n            while stack and stack[-1] < n:\\n                s3 = stack.pop()\\n            stack.append(n)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        import sys\\n        stack = []\\n        s3 = -sys.maxint\\n        for n in nums[::-1]:\\n            if n < s3:\\n                return True\\n            while stack and stack[-1] < n:\\n                s3 = stack.pop()\\n            stack.append(n)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94077,
                "title": "java-o-n-solution-using-stack-in-detail-explanation",
                "content": "The idea is that we can use a stack to keep track of previous min-max intervals. \\n\\nHere is the principle to maintain the stack:\\n\\nFor each number ```num``` in the array\\n\\nIf stack is empty:\\n\\n* push a new Pair of ```num``` into stack\\n\\nIf stack is not empty:\\n\\n* if ```num``` < ```stack.peek().min```,  push a new Pair of ```num``` into stack\\n\\n* if ```num```  >= ```stack.peek().min```, we first pop() out the peek element, denoted as ```last```\\n     * if  ```num```  < ```last.max```, we are done, return ```true```;\\n     \\n     * if  ```num```  >= ```last.max```, we merge ```num``` into ```last```, which means ```last.max``` = ```num```.  \\nOnce we update ```last```,  if stack is empty, we just push back ```last```. \\n**However, the crucial part is:** \\nIf stack is not empty, the updated ```last``` might:  \\n       \\n         * Entirely covered stack.peek(), i.e. ```last.min``` < ```stack.peek().min``` (which is always true) && ```last.max``` >= ```stack.peek().max```, in which case we keep popping out stack.peek().\\n         * Form a 1-3-2 pattern, we are done ,return ```true```\\n\\nSo at any time in the stack, **non-overlapping** ```Pairs``` are formed in descending order by their min value, which means the min value of peek element in the stack is always the min value globally. \\n\\n```\\n   class Pair{\\n        int min, max;\\n        public Pair(int min, int max){\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Pair> stack = new Stack();\\n        for(int n: nums){\\n            if(stack.isEmpty() || n <stack.peek().min ) stack.push(new Pair(n,n));\\n            else if(n > stack.peek().min){ \\n                Pair last = stack.pop();\\n                if(n < last.max) return true;\\n                else {\\n                    last.max = n;\\n                    while(!stack.isEmpty() && n >= stack.peek().max) stack.pop();\\n                    // At this time, n < stack.peek().max (if stack not empty)\\n                    if(!stack.isEmpty() && stack.peek().min < n) return true;\\n                    stack.push(last);\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```num```\n```num```\n```num```\n```stack.peek().min```\n```num```\n```num```\n```stack.peek().min```\n```last```\n```num```\n```last.max```\n```true```\n```num```\n```last.max```\n```num```\n```last```\n```last.max```\n```num```\n```last```\n```last```\n```last```\n```last.min```\n```stack.peek().min```\n```last.max```\n```stack.peek().max```\n```true```\n```Pairs```\n```\\n   class Pair{\\n        int min, max;\\n        public Pair(int min, int max){\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Pair> stack = new Stack();\\n        for(int n: nums){\\n            if(stack.isEmpty() || n <stack.peek().min ) stack.push(new Pair(n,n));\\n            else if(n > stack.peek().min){ \\n                Pair last = stack.pop();\\n                if(n < last.max) return true;\\n                else {\\n                    last.max = n;\\n                    while(!stack.isEmpty() && n >= stack.peek().max) stack.pop();\\n                    // At this time, n < stack.peek().max (if stack not empty)\\n                    if(!stack.isEmpty() && stack.peek().min < n) return true;\\n                    stack.push(last);\\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906876,
                "title": "python-o-n-solution-with-decreasing-stack-explained",
                "content": "Let us keep evaluate `min_list`, where `min_list[i] = min(nums[0], ..., nums[i])`.\\nAlso let us traverse our `nums` from the end and keep stack with decreasing elements, which are more than `min_list[j]` for given `j`.\\nWe will try to find `132` pattern, where `nums[j]` is middle number in this pattern.\\n\\nLet us look through the code and see what is going on:\\n1. If `nums[j] <= min_list[j]`, there is no need to put this number to stack: it means actually that `nums[j]` is less than all previous numbers and it can not be the middle element in our `132` pattern.\\n2. Now, if `nums[j] > min_list[j]`, we need to keep our stack clean: if we have numbers which are leaa or equal than `min_list[j]`, we remove them from our stack. So, we have now `stack[-1] > min_list[j]`. If it is also happen, that `stack[-1] < nums[j]`, then we are happy: we found our pattern: we choose `stack[-1]` for our `2` in pattern, `nums[j]` for our `3` and element where minumum reached: `min_list[j]` for our `1`:  we have our `1` less than `2` and `2` less than `3`. In this case we immedietly return `True`. In the end we append `nums[j]` to our stack.\\n3. If we traversed all list and did not found pattern, we return `False`.\\n\\nSo, what exaclty will be in our stack on each step? \\n1. There always be numbers more  or equal than  `nums[j]` inside\\n2. Which are going in decreasing order. \\n\\nWhy it will not change on the next step? If our next number (`nums[j-1]`) is more than top of our stack, we found our `132` pattern! If it is less, then we put it into our stack and decreasing order is satisfied (property s) and if we have top of our stack equal to `nums[j-1]`, so property `1` is also satisfied.\\n\\n**Complexty** is `O(n)`, both for time and memory, because we traverse our list twice: once in one direction and once in opposite\\n\\n\\n```\\nclass Solution:\\n    def find132pattern(self, nums):\\n        min_list = list(accumulate(nums, min))\\n        stack, n = [], len(nums)\\n        \\n        for j in range(n-1, -1, -1):\\n            if nums[j] > min_list[j]:\\n                while stack and stack[-1] <= min_list[j]:\\n                    stack.pop()\\n                if stack and stack[-1] < nums[j]:\\n                    return True\\n                stack.append(nums[j])           \\n        return False\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums):\\n        min_list = list(accumulate(nums, min))\\n        stack, n = [], len(nums)\\n        \\n        for j in range(n-1, -1, -1):\\n            if nums[j] > min_list[j]:\\n                while stack and stack[-1] <= min_list[j]:\\n                    stack.pop()\\n                if stack and stack[-1] < nums[j]:\\n                    return True\\n                stack.append(nums[j])           \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166953,
                "title": "easy-and-concise-c-solution-using-a-stack-with-explanation-very-easy-to-understand",
                "content": "This question is asking us to find \"132\" pattern in the array. This reminds me of the stack-sortable permutation, which was introduced by Knuth. Please read [the detailed explanation](https://en.wikipedia.org/wiki/Stack-sortable_permutation) at the Wikipedia first.\\n\\n**Stack-sortable permutations** are the sequence of numbers that are sortable using a stack and thus it should not contain \"231\" pattern. Once you read the article, you can easily understand why the \"231\" pattern prevents it from being sorted.\\n\\nThis question is very similar with the problem that identifies the sequence of number is stack-sortable or not. Knuth\\'s algorithm finds \"231\" pattern, but we need to find \"132\" pattern in this question.\\n\\nHere is my idea. How about reversing the input array and then trying to find \"132\" pattern in it? In other words, this question is asking whether **the reversed input array is stack-sortable or not**.\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> s;\\n        int prev = INT_MIN;\\n        \\n        for (auto it = nums.rbegin(); it != nums.rend(); it++) {\\n            while (!s.empty() && s.top() < *it) {\\n                if (prev > s.top())\\n                    return true;\\n                prev = s.top();\\n                s.pop();\\n            }\\n            \\n            s.push(*it);\\n        }\\n        \\n        return !s.empty() && prev > s.top();\\n    }\\n};\\n```\\n\\nIn my opinion, explanation in this way is much easier than the official one.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> s;\\n        int prev = INT_MIN;\\n        \\n        for (auto it = nums.rbegin(); it != nums.rend(); it++) {\\n            while (!s.empty() && s.top() < *it) {\\n                if (prev > s.top())\\n                    return true;\\n                prev = s.top();\\n                s.pop();\\n            }\\n            \\n            s.push(*it);\\n        }\\n        \\n        return !s.empty() && prev > s.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425027,
                "title": "java-simple-and-clean-o-n-solution-similar-idea-with-next-greater-element",
                "content": "The idea is the same as the problem \"find next greater element\", but here we change to find the next smaller. \\nFrom end to start, if we find nums[i] is less than the maximum element that is smaller than another, then we can say we find the pattern.\\nupdate @ 12/15/2019\\n For example [..., 4, 6, 1, 3, ...], when finding the 132 pattern from left to right, we need to find the target in the range (1, 3) and (4, 6), these are incontinuous intervals, but from right to left, we only need to check whether the number n is in range (-inf, 3), if yes, then [n, 4or6, 3] is in pattern 132.\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int max = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            while (!stack.isEmpty() && stack.peek() < nums[i]) {\\n                max = stack.pop();\\n            }\\n            if (nums[i] > max) stack.push(nums[i]);\\n            if (nums[i] < max) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stack = new Stack<>();\\n        int max = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            while (!stack.isEmpty() && stack.peek() < nums[i]) {\\n                max = stack.pop();\\n            }\\n            if (nums[i] > max) stack.push(nums[i]);\\n            if (nums[i] < max) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206575,
                "title": "previous-greater-element-stack-o-n-no-reverse",
                "content": "we will keep a variable smallest to know the smallest number to the left (index i) of the current element (index j) so that there will be higher chance we find k which k > j > i and A[j] > A[k] > A[i] (because now we already have j > i and A[j] > A[i] the only thing we need to do is find if there is a element to the right of A[j] which smaller than A[j] and greater than A[i]), each time we will pop the stack until the last number of the last element in the stack greater than the current number, if Stack[-1][0] > current element it means we  found 1 3 2 pattern (this step is exactly the same with finding previous greater element).\\n```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        smallest = float(\\'inf\\')\\n        stack = []\\n        for i in nums:\\n            while stack and i >= stack[-1][-1]:\\n                stack.pop()\\n            if stack and i > stack[-1][0]:\\n                return True\\n            stack.append((smallest,i)) \\n            smallest = min(smallest,i)\\n        return False\\n            \\n            \\n",
                "solutionTags": [],
                "code": "we will keep a variable smallest to know the smallest number to the left (index i) of the current element (index j) so that there will be higher chance we find k which k > j > i and A[j] > A[k] > A[i] (because now we already have j > i and A[j] > A[i] the only thing we need to do is find if there is a element to the right of A[j] which smaller than A[j] and greater than A[i]), each time we will pop the stack until the last number of the last element in the stack greater than the current number, if Stack[-1][0] > current element it means we  found 1 3 2 pattern (this step is exactly the same with finding previous greater element).\\n```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        smallest = float(\\'inf\\')\\n        stack = []\\n        for i in nums:\\n            while stack and i >= stack[-1][-1]:\\n                stack.pop()\\n            if stack and i > stack[-1][0]:\\n                return True\\n            stack.append((smallest,i)) \\n            smallest = min(smallest,i)\\n        return False\\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 1541296,
                "title": "o-n-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    // We need s1<s3<s2\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini[n];\\n\\t\\t//mini at any position will be our candidate for s1\\n        mini[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            mini[i]=min(mini[i-1], nums[i]);\\n        stack<int> st;\\n        for(int j=n-1;j>=0;j--){ //nums[j] will be our candidate for s2\\n            if(nums[j]>mini[j]){ //s1<s2\\n                while(!st.empty() && st.top()<=mini[j]){ //discarding all elements right to s2 which are smaller than s1 as we need s3>s1\\n                    st.pop();\\n                }\\n                if(!st.empty() && st.top()<nums[j]) //now st.top() is our candidate for s3 and we have ensured s1<s3<s2\\n                    return true;\\n                st.push(nums[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // We need s1<s3<s2\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini[n];\\n\\t\\t//mini at any position will be our candidate for s1\\n        mini[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            mini[i]=min(mini[i-1], nums[i]);\\n        stack<int> st;\\n        for(int j=n-1;j>=0;j--){ //nums[j] will be our candidate for s2\\n            if(nums[j]>mini[j]){ //s1<s2\\n                while(!st.empty() && st.top()<=mini[j]){ //discarding all elements right to s2 which are smaller than s1 as we need s3>s1\\n                    st.pop();\\n                }\\n                if(!st.empty() && st.top()<nums[j]) //now st.top() is our candidate for s3 and we have ensured s1<s3<s2\\n                    return true;\\n                st.push(nums[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906994,
                "title": "c-easy-and-o-n-stack-solution",
                "content": "if you like it pls upvote\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int> stack;\\n        int second =  -2147483648;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums [i] < second)\\n                return true;\\n            while (stack.size() >0 && nums [i] > stack.top()){\\n                second = stack.top ();\\n                stack.pop();\\n            }\\n                \\n            stack.push (nums [i]);\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int> stack;\\n        int second =  -2147483648;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums [i] < second)\\n                return true;\\n            while (stack.size() >0 && nums [i] > stack.top()){\\n                second = stack.top ();\\n                stack.pop();\\n            }\\n                \\n            stack.push (nums [i]);\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015125,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        if len(nums)<3:\\n            return False\\n      \\n        second_num = -math.inf\\n        stck = []\\n        # Try to find nums[i] < second_num < stck[-1]\\n        for i in range(len(nums) - 1, -1, -1):\\n            if nums[i] < second_num:\\n                return True\\n            # always ensure stack can be popped in increasing order\\n            while stck and stck[-1] < nums[i]:\\n\\t\\t\\t\\tsecond_num = stck.pop()  # this will ensure  second_num < stck[-1] for next iteration\\n\\n            stck.append(nums[i])\\n        return False\\n        \\n```\\n\\n**T = O(N)**\\n**S = O(N)** - needed for stack\\n\\n---\\n\\nI am adding an explanation for using `second_num`. The following was shared by [@zayne-siew](https://leetcode.com/zayne-siew) \\n\\nWe consider the largest possible `second_num` so that the `nums[i] < second_num` check has the largest possible range of values of `nums[i]` for it to return true. (We can guarantee that `second_num` is the largest possible second number for the current index since we popped it from `stck`, which is monotonically decreasing.) Consider the following example:\\n\\n```\\nnums = [ 1, 4, 3, 2 ]\\n\\nWhen idx = 3, stck = [ ], second_num = -inf\\nWhen idx = 2, stck = [2], second_num = -inf\\nWhen idx = 1, stck = [3], second_num = 2\\nWhen idx = 0, stck = [4], second_num = 3\\n\\n132 pattern found: ( 1, 4, 3 )\\n```\\nNote that `( 1, 4, 2 )` is also a valid `132` pattern, even though we discarded the `2` for the `3` when `idx = 1`. However, either way, the function will return true. Hence, **the earlier popped numbers can also be candidates for `second_num`, but we will be able to find the 132 pattern (if any) just using the largest possible `second_num`**.\\n\\nNote also that the same thing can be said for the largest number; even though `( 1, 3, 2 )` is a valid 132 pattern, the largest number `3` is popped from stck and replaced with `4` when` idx = 1`. Again, either way, the function returns true.\\n\\n----\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        if len(nums)<3:\\n            return False\\n      \\n        second_num = -math.inf\\n        stck = []\\n        # Try to find nums[i] < second_num < stck[-1]\\n        for i in range(len(nums) - 1, -1, -1):\\n            if nums[i] < second_num:\\n                return True\\n            # always ensure stack can be popped in increasing order\\n            while stck and stck[-1] < nums[i]:\\n\\t\\t\\t\\tsecond_num = stck.pop()  # this will ensure  second_num < stck[-1] for next iteration\\n\\n            stck.append(nums[i])\\n        return False\\n        \\n```\n```\\nnums = [ 1, 4, 3, 2 ]\\n\\nWhen idx = 3, stck = [ ], second_num = -inf\\nWhen idx = 2, stck = [2], second_num = -inf\\nWhen idx = 1, stck = [3], second_num = 2\\nWhen idx = 0, stck = [4], second_num = 3\\n\\n132 pattern found: ( 1, 4, 3 )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015224,
                "title": "4-approaches-bf-o-n-3-bf-o-n-2-treemap-monotonic-stack",
                "content": "[Leetcode](https://leetcode.com/) [456. 132 Pattern](https://leetcode.com/problems/132-pattern/).\\n\\n***By Frank Luo***\\n\\nHere are **4** approaches to solve this problem in Java: BF $O(n^3)$, BF $O(n^2)$, **TreeMap**, **Monotonic Stack**.\\n\\n\\n# BF O(n^3)\\n\\nIt\\'s easy to use **3 loops** to find $3$ elements which is $132$ pattern, but the time complexity is $O(n^3)$, so it wouldn\\'t accepted as **TLE**!\\n\\n```java\\n    public boolean find132pattern_bf(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < len - 2; i++) {\\n            for (int j = i + 1; j < len - 1; j++) {\\n                for (int k = j + 1; k < len; k++) {\\n                    if (nums[i] < nums[k] && nums[k] < nums[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^3)$.\\n- **Space Complexity**: $O(1)$.\\n\\n\\n# BF O(n^2)\\n\\nNoticed that $\\\\textit{nums}[j]$ is the peak of the $3$ elements, suppose the current element is $\\\\textit{nums}[j]$, we have to find the element $\\\\textit{nums}[k]$ that is smaller than $\\\\textit{nums}[j]$ after $j$, and the element $\\\\textit{nums}[i]$ that is smaller than $\\\\textit{nums}[k]$ before $j$. \\n\\n1. Scan left from $j$ to $0$, $0 \\\\le i \\\\lt j$, whether there is $\\\\textit{nums}[i] < \\\\textit{nums}[j]$, update the mininum $\\\\textit{leftMin}$;\\n\\n2. Scan right from $j$ to the end, $j + 1 \\\\le k \\\\lt len$, whether there is $\\\\textit{nums}[k] < \\\\textit{nums}[j]$, update the maxinum $\\\\textit{rightMax}$;\\n\\n3. If exists and $\\\\textit{leftMin} < \\\\textit{rightMax}$, return **true**.\\n\\n\\nLet\\'s coding it.\\n\\n```java\\n    public boolean find132pattern_bf_opt(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        for (int j = 1; j < len - 1; j++) {\\n            int leftMin = Integer.MAX_VALUE;\\n            boolean leftFlag = false;\\n            for (int i = j - 1; i >= 0; i--) {\\n                if (nums[i] < nums[j]) {\\n                    leftFlag = true;\\n                    leftMin = Math.min(leftMin, nums[i]);\\n                }\\n            }\\n\\n            int rightMax = Integer.MIN_VALUE;\\n            boolean rightFlag = false;\\n            for (int k = j + 1; k < len; k++) {\\n                if (nums[k] < nums[j]) {\\n                    rightFlag = true;\\n                    rightMax = Math.max(rightMax, nums[k]);\\n                }\\n            }\\n\\n            if (leftFlag && rightFlag && leftMin < rightMax) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$.\\n- **Space Complexity**: $O(1)$.\\n\\n\\n# TreeMap\\n\\nMethod 2 is $O(n^2)$. With extra $O(n)$ space to store the elements of the array, we can reduce the time complexity to $O(n)$.\\n\\nWe have to maintain all the values of the array in the right of $j$. As we have determined $nums[i]$ and $\\\\textit{nums}[j]$, we only need to query the smallest element $\\\\textit{nums}[k]$ in the sorted set which is strictly larger than $\\\\textit{nums}[i]$. \\n\\nThen if $\\\\textit{nums}[k] < \\\\textit{nums}[j]$, which means we have found the $3$ elements of $132$ pattern.\\n\\n```java\\n    public static boolean find132pattern_map(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        TreeMap<Integer, Integer> rightMap = new TreeMap<>();\\n        for (int i = 2; i < len; i++) {\\n            rightMap.put(nums[i], rightMap.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int leftMin = nums[0];\\n        for (int j = 1; j < len - 1; j++) {\\n            if (leftMin < nums[j]) {\\n                Integer numK = rightMap.ceilingKey(leftMin + 1);\\n                if (numK != null && numK < nums[j]) {\\n                    return true;\\n                }\\n            }\\n\\n            leftMin = Math.min(leftMin, nums[j]);\\n            rightMap.put(nums[j + 1], rightMap.get(nums[j + 1]) - 1);\\n            if (rightMap.get(nums[j + 1]) == 0) {\\n                rightMap.remove(nums[j + 1]);\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$.\\n- **Space Complexity**: $O(n)$.\\n\\n\\n# Monotonic Stack\\n\\nWe can use a stack to store the element of the array from the back to front, find $\\\\textit{nums}[k]$ in the stack, and then continue to scan forward to find $\\\\textit{nums}[i]$. \\n\\nThe stack must store elements with a larger index and a smaller value than $\\\\textit{nums}[j]$.\\n\\nThe process is like this:\\n\\n1. Scanning from the back to the front, if the current element $\\\\textit{nums}[i]$ is larger than the top of the stack, which means $\\\\textit{nums}[i]$ may be the $\\\\textit{nums}[j]$ we are looking for;\\n\\n2. Pop all the elements in the stack that are smaller than it. These elements are the the $\\\\textit{nums}[k]$, and the last pop-up is the maximum qualified $\\\\textit{nums}[k]$. \\n\\n3. If this $\\\\textit{nums}[k]$ is larger than the $\\\\textit{nums}[i]$ scanned forward, we find the answer.\\n\\n\\n```java\\n    public boolean find132pattern_stack(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        Deque<Integer> stk = new ArrayDeque<>();\\n        int k = -1;\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (k > -1 && nums[k] > nums[i]) {\\n                return true;\\n            }\\n\\n            while (!stk.isEmpty() && nums[i] > nums[stk.peek()]) {\\n                k = stk.pop();\\n            }\\n\\n            stk.push(i);\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n)$.\\n\\n----------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```java\\n    public boolean find132pattern_bf(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < len - 2; i++) {\\n            for (int j = i + 1; j < len - 1; j++) {\\n                for (int k = j + 1; k < len; k++) {\\n                    if (nums[i] < nums[k] && nums[k] < nums[j]) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    public boolean find132pattern_bf_opt(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        for (int j = 1; j < len - 1; j++) {\\n            int leftMin = Integer.MAX_VALUE;\\n            boolean leftFlag = false;\\n            for (int i = j - 1; i >= 0; i--) {\\n                if (nums[i] < nums[j]) {\\n                    leftFlag = true;\\n                    leftMin = Math.min(leftMin, nums[i]);\\n                }\\n            }\\n\\n            int rightMax = Integer.MIN_VALUE;\\n            boolean rightFlag = false;\\n            for (int k = j + 1; k < len; k++) {\\n                if (nums[k] < nums[j]) {\\n                    rightFlag = true;\\n                    rightMax = Math.max(rightMax, nums[k]);\\n                }\\n            }\\n\\n            if (leftFlag && rightFlag && leftMin < rightMax) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    public static boolean find132pattern_map(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        TreeMap<Integer, Integer> rightMap = new TreeMap<>();\\n        for (int i = 2; i < len; i++) {\\n            rightMap.put(nums[i], rightMap.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        int leftMin = nums[0];\\n        for (int j = 1; j < len - 1; j++) {\\n            if (leftMin < nums[j]) {\\n                Integer numK = rightMap.ceilingKey(leftMin + 1);\\n                if (numK != null && numK < nums[j]) {\\n                    return true;\\n                }\\n            }\\n\\n            leftMin = Math.min(leftMin, nums[j]);\\n            rightMap.put(nums[j + 1], rightMap.get(nums[j + 1]) - 1);\\n            if (rightMap.get(nums[j + 1]) == 0) {\\n                rightMap.remove(nums[j + 1]);\\n            }\\n        }\\n\\n        return false;\\n    }\\n```\n```java\\n    public boolean find132pattern_stack(int[] nums) {\\n        int len = nums.length;\\n        if (len < 3) {\\n            return false;\\n        }\\n\\n        Deque<Integer> stk = new ArrayDeque<>();\\n        int k = -1;\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (k > -1 && nums[k] > nums[i]) {\\n                return true;\\n            }\\n\\n            while (!stk.isEmpty() && nums[i] > nums[stk.peek()]) {\\n                k = stk.pop();\\n            }\\n\\n            stk.push(i);\\n        }\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 700414,
                "title": "python-detailed-explanation-stack-solution",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. We Create Minimum Array, till that position => O(n)\\n        ## 2. We start iterating from reverse of given array.\\n        ## 3. Remember we are using Stack and TopOfStack to determine, 2 in 132 pattern. ( so we have to check)\\n        ## 4. At any position, we push all elements IF greater than minimum (possible 2 in 132 pattern)\\n        ## 5. At any position, we pop all stack elements IF topOfStack is less or EQUAL to minimum (invalid element to form 132 pattern)\\n        ## 6. SATISFYING CONDITION : at any stage if min_nums[i] < stack[-1] < nums[i] we return True.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        ## EDGE CASE : While checking the conditions 4,5,6. We should perform pop operation first i.e remove invalid elements before inserting the current element into the stack.\\n        \\n        if len(set(nums)) < 3:\\n            return False\\n\\n        min_nums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            min_nums.append(min(nums[i], min_nums[-1]))\\n            \\n        stack = []  \\n        i = len(nums) - 1\\n        for i in range(len(nums)-1, -1, -1):\\n            # 4\\n            if( nums[i] > min_nums[i] ):\\n                # 5\\n                while( stack and stack[-1] <= min_nums[i] ):\\n                    stack.pop()\\n                # 6\\n                if(stack and min_nums[i] < stack[-1] < nums[i] ):\\n                    return True\\n                # 4\\n                stack.append(nums[i])\\n        return False       \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        ## RC ##\\n        ## APPROACH : STACK ##\\n        ## LOGIC ##\\n        ## 1. We Create Minimum Array, till that position => O(n)\\n        ## 2. We start iterating from reverse of given array.\\n        ## 3. Remember we are using Stack and TopOfStack to determine, 2 in 132 pattern. ( so we have to check)\\n        ## 4. At any position, we push all elements IF greater than minimum (possible 2 in 132 pattern)\\n        ## 5. At any position, we pop all stack elements IF topOfStack is less or EQUAL to minimum (invalid element to form 132 pattern)\\n        ## 6. SATISFYING CONDITION : at any stage if min_nums[i] < stack[-1] < nums[i] we return True.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n        \\n        ## EDGE CASE : While checking the conditions 4,5,6. We should perform pop operation first i.e remove invalid elements before inserting the current element into the stack.\\n        \\n        if len(set(nums)) < 3:\\n            return False\\n\\n        min_nums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            min_nums.append(min(nums[i], min_nums[-1]))\\n            \\n        stack = []  \\n        i = len(nums) - 1\\n        for i in range(len(nums)-1, -1, -1):\\n            # 4\\n            if( nums[i] > min_nums[i] ):\\n                # 5\\n                while( stack and stack[-1] <= min_nums[i] ):\\n                    stack.pop()\\n                # 6\\n                if(stack and min_nums[i] < stack[-1] < nums[i] ):\\n                    return True\\n                # 4\\n                stack.append(nums[i])\\n        return False       \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094481,
                "title": "c-o-n-solution-using-monotone-stack-easy",
                "content": "Use a decreasing stack to store the value of num[k], and use a variable third to store the value of num[j]. **All the elements in stack need to bigger than third to satisfy nums[k] < nums[j]**. Inversely traverse the array to indicate the first value. if the first value is smaller than the third than return true. if not than put it in the stack.\\n\\nSince we need to hold the monotone of the stack, if the num[i] value is bigger than the top of the stack, we let **third = stack.top() and pop out the top of stack**, which mean that we can form a bigger num[k] (nums[ptr]) and a bigger nums[j] (stack.top()),  So if the next iterate can let the first value smaller than the third more easily.\\n```\\nint third = INT_MIN;\\n        stack<int> s;\\n        for (int i = nums.size() - 1; i >= 0; -- i) {\\n            if (nums[i] < third) return true;\\n            while (!s.empty() && nums[i] > s.top()) {\\n                third = s.top(); \\n                s.pop();\\n                \\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nint third = INT_MIN;\\n        stack<int> s;\\n        for (int i = nums.size() - 1; i >= 0; -- i) {\\n            if (nums[i] < third) return true;\\n            while (!s.empty() && nums[i] > s.top()) {\\n                third = s.top(); \\n                s.pop();\\n                \\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94133,
                "title": "simple-java-accepted-well-explained-o-n-2-solution",
                "content": "```\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null || nums.length < 3) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int bigger = nums[i];    \\n            for(int j = i + 1; j < nums.length; j++) {\\n                // 1. We don't care about numbers\\n                // less than a[i]\\n                if(nums[j] <= nums[i]) continue;\\n                \\n                // 2. If num is greater than bigger\\n                // then update bigger\\n                if(nums[j] >= bigger) {\\n                    bigger = nums[j];\\n                } else {\\n                    // Now this number is greater than nums[i]\\n                    // see 1. and less than bigger, see 2.\\n                    return true;\\n                }  \\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null || nums.length < 3) {\\n            return false;\\n        }\\n        \\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int bigger = nums[i];    \\n            for(int j = i + 1; j < nums.length; j++) {\\n                // 1. We don't care about numbers\\n                // less than a[i]\\n                if(nums[j] <= nums[i]) continue;\\n                \\n                // 2. If num is greater than bigger\\n                // then update bigger\\n                if(nums[j] >= bigger) {\\n                    bigger = nums[j];\\n                } else {\\n                    // Now this number is greater than nums[i]\\n                    // see 1. and less than bigger, see 2.\\n                    return true;\\n                }  \\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015708,
                "title": "c-8-line-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       int s3 = INT_MIN;\\n       int n = nums.size();\\n        stack<int>s;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(nums[i]<s3)\\n                return true;\\n            else\\n            {\\n                while(!s.empty() && nums[i]>s.top())\\n                {\\n                    s3 = s.top();\\n                    s.pop();\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       int s3 = INT_MIN;\\n       int n = nums.size();\\n        stack<int>s;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(nums[i]<s3)\\n                return true;\\n            else\\n            {\\n                while(!s.empty() && nums[i]>s.top())\\n                {\\n                    s3 = s.top();\\n                    s.pop();\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973635,
                "title": "c-o-n-solution-stack-with-simplest-possible-explanation",
                "content": "# Brief Overview\\n**// firstly we will calculate the minimum value i.e at ith position\\n// then we fixed j and search for a value which is less then nums[j] but greater than nums[i] \\n// which is equal to nums[k]**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    bool find132pattern(vector<int> &nums)\\n    {\\n        if (nums.empty())\\n            return false;\\n        int n = nums.size();\\n        vector<int> minVal(n);\\n        minVal[0] = nums[0];\\n        stack<int> st;\\n        for (int i = 1; i < n; i++)\\n        {\\n            minVal[i] = min(minVal[i - 1], nums[i]);\\n        }\\n        for (int j = n - 1; j > 0; j--)\\n        // here j is the second element so it cannot be at 0th position\\n        {\\n            while (!st.empty() && nums[st.top()] < nums[j])\\n            {\\n                // while the stack is not empty and the top is less than nums[j], this could be our possible k\\n                // only if the if condition satisfy\\n                // i.e it should be greater than the minVal i.e nums[i]\\n                if (nums[st.top()] > minVal[j - 1])\\n                {\\n                    return true;\\n                }\\n                // else remove the position from stack\\n                st.pop();\\n            }\\n            st.push(j);\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Tried to explain in the simplest possible words, Hope it helps**\\n**Please Upvote if it helped you, your suggestions are welcome**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool find132pattern(vector<int> &nums)\\n    {\\n        if (nums.empty())\\n            return false;\\n        int n = nums.size();\\n        vector<int> minVal(n);\\n        minVal[0] = nums[0];\\n        stack<int> st;\\n        for (int i = 1; i < n; i++)\\n        {\\n            minVal[i] = min(minVal[i - 1], nums[i]);\\n        }\\n        for (int j = n - 1; j > 0; j--)\\n        // here j is the second element so it cannot be at 0th position\\n        {\\n            while (!st.empty() && nums[st.top()] < nums[j])\\n            {\\n                // while the stack is not empty and the top is less than nums[j], this could be our possible k\\n                // only if the if condition satisfy\\n                // i.e it should be greater than the minVal i.e nums[i]\\n                if (nums[st.top()] > minVal[j - 1])\\n                {\\n                    return true;\\n                }\\n                // else remove the position from stack\\n                st.pop();\\n            }\\n            st.push(j);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94076,
                "title": "share-my-easy-and-simple-solution",
                "content": "Idea: Find peak and bottom\\n\\nFor every [bottom, peak], find if there is one number `bottom<number<peak`. \\n\\n```java\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3) return false;\\n        Integer low = null, high = null;\\n        int start = 0, end = 0;\\n        while(start<nums.length-1){\\n            while(start<nums.length-1 && nums[start]>=nums[start+1]) start++;\\n            // start is lowest now\\n            int m = start+1;\\n            while(m<nums.length-1 && nums[m]<=nums[m+1]) m++;\\n            // m is highest now\\n            int j = m+1;\\n            while(j<nums.length){\\n                if(nums[j]>nums[start] && nums[j]<nums[m]) return true;\\n                j++;\\n            }\\n            start = m+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3) return false;\\n        Integer low = null, high = null;\\n        int start = 0, end = 0;\\n        while(start<nums.length-1){\\n            while(start<nums.length-1 && nums[start]>=nums[start+1]) start++;\\n            // start is lowest now\\n            int m = start+1;\\n            while(m<nums.length-1 && nums[m]<=nums[m+1]) m++;\\n            // m is highest now\\n            int j = m+1;\\n            while(j<nums.length){\\n                if(nums[j]>nums[start] && nums[j]<nums[m]) return true;\\n                j++;\\n            }\\n            start = m+1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015584,
                "title": "c-monotonic-stack",
                "content": "This implementation is based on a monotonic decreasing stack ( keeping values in decreasing order in stack / top value being the lowest among all) . We keep a track of values before a particular index in decresing order and also the minimun value before these values along with them. So for a particular index , we check if the top of stack is greater (if not we pop as we maintain a decreasing stack) , if yes , then we check if the min present with it is less than our current value (if yes we got a valid triplet , return true) .If not we push this to the stack .\\n\\n\\n```\\n        \\n        stack<pair<int,int>> s;  //*** stack with first as value at index and second as minimum value encountered before current index\\n        \\n        int mini = INT_MAX;   // keeping track of minimum value encountered before our current index\\n        \\n        for(int i = 0;i<nums.size();i++){\\n            \\n            if(s.size()!=0)\\n            mini = min(mini,s.top().first);  // since we have to keep it for a value before current , we will check it here as the value of previous index will always be there at top\\n            \\n            \\n            while(s.size()!=0 && nums[i]>s.top().first){   //**  keeping the stack in decreasing order\\n                \\n                s.pop();\\n            }\\n            \\n            \\n            if(s.size()!=0){         // find if the value we got at the top is greater than our current and also the min with that value is smaller than current value\\n                \\n            if((s.top().first > nums[i]) && (nums[i] > s.top().second))return true;\\n            }\\n            \\n            s.push({nums[i],mini});  \\n           \\n        \\n        }\\n        \\n        \\n        \\n        return false;\\n        \\n        \\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n        \\n        stack<pair<int,int>> s;  //*** stack with first as value at index and second as minimum value encountered before current index\\n        \\n        int mini = INT_MAX;   // keeping track of minimum value encountered before our current index\\n        \\n        for(int i = 0;i<nums.size();i++){\\n            \\n            if(s.size()!=0)\\n            mini = min(mini,s.top().first);  // since we have to keep it for a value before current , we will check it here as the value of previous index will always be there at top\\n            \\n            \\n            while(s.size()!=0 && nums[i]>s.top().first){   //**  keeping the stack in decreasing order\\n                \\n                s.pop();\\n            }\\n            \\n            \\n            if(s.size()!=0){         // find if the value we got at the top is greater than our current and also the min with that value is smaller than current value\\n                \\n            if((s.top().first > nums[i]) && (nums[i] > s.top().second))return true;\\n            }\\n            \\n            s.push({nums[i],mini});  \\n           \\n        \\n        }\\n        \\n        \\n        \\n        return false;\\n        \\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908889,
                "title": "bst-o-nlogn-solution-thought-process",
                "content": "Below is my thought process to arrive at a solution using a self-balancing binary search tree. \\n\\nThe time complexity is `~O(N logN)` and a space complexity is `~O(N)`, where `N` is the length of the input.\\n\\nAs stated in the official solution, we can start from the brute force solution that takes `~O(N^2)` time.\\n\\n```java\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) {\\n            return false;\\n        }\\n        \\n        int min_i = Integer.MAX_VALUE;\\n        for (int j = 0; j < n; j++) {\\n            min_i = Math.min(min_i, nums[j]);\\n            for (int k = j + 1; k < n; k++) {\\n                if (nums[k] < nums[j] && nums[k] > min_i) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nThe above solution iterates through a possible `nums[j]`, while keeping track of the minimum `nums[i]` encountered so far. For the rest of the array `nums[j+1...]`, we iterate through the values one by one to find `nums[k]` such that:\\n\\n* `nums[k] < nums[j]` and\\n* `nums[k] > min_i`\\n\\n## What is the bottleneck?\\n\\nA possible bottleneck is that,  for each value of `j`, we keep iterating through the rest of the array to check for an existence of a suitable `nums[k]`. Let\\'s see if we can do better.\\n\\nWhy do we have to iterate through the rest of the array? The goal is to find `nums[k]` such that `min_i < nums[k] < nums[j]`, as stated above. Is there a better way to search for such element that falls withtin the desired range?\\n\\n## Improvement\\n\\n**Binary search tree** supports range query in time proportional to its height, because it keeps the elements in a certain order. Concretely, for each node, no child on the left subtree is greater than the node, and no child on the right subtree is less than the node.\\n\\nFor self-balancing BST such as Red-Black trees, it is possible to support all ordered operations in logarithmic time. In Java, `TreeMap` is an implementation of a Red-Black tree. Let us use that to keep each value, and their counts. Since there might be dupliate numbers, we need to keep track of the counts. Otherwise, we could have also used `TreeSet`.\\n\\n```java\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n\\t\\t\\n\\t\\t// impossible\\n        if (n < 3) {\\n            return false;\\n        }\\n        \\n\\t\\t// a self-balancing BST to keep track of numbers and their counts.\\n        TreeMap<Integer, Integer> t = new TreeMap();\\n        for (int i = 1; i < n; i++) {\\n            t.put(nums[i], t.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        int min_i = Integer.MAX_VALUE;\\n        for (int j = 1; j < n; j++) {\\n            min_i = Math.min(min_i, nums[j-1]);\\n\\t\\t\\t\\n\\t\\t\\t// exclude the current nums[j] from the search space\\n\\t\\t\\t// if the count is 0, simply discard the node from the BST.\\n            t.put(nums[j], t.get(nums[j]) - 1);\\n            if (t.get(nums[j]) == 0) {\\n                t.remove(nums[j]);\\n            }\\n            \\n            if (nums[j] < min_i) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// check if a number, nums[k], exists in the current search space\\n\\t\\t\\t// such that min_i < nums[k] < nums[j].\\n            if (t.subMap(min_i, false, nums[j], false).size() > 0) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nBy using the right data structure, we obviated the need for continued iteration throughout the rest of the array. Instead of iterating for find a suitable `nums[k]`, we can simply rely on the ordered operation on a BST whose height is guaranteed to be `~O(logN)`.",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) {\\n            return false;\\n        }\\n        \\n        int min_i = Integer.MAX_VALUE;\\n        for (int j = 0; j < n; j++) {\\n            min_i = Math.min(min_i, nums[j]);\\n            for (int k = j + 1; k < n; k++) {\\n                if (nums[k] < nums[j] && nums[k] > min_i) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n\\t\\t\\n\\t\\t// impossible\\n        if (n < 3) {\\n            return false;\\n        }\\n        \\n\\t\\t// a self-balancing BST to keep track of numbers and their counts.\\n        TreeMap<Integer, Integer> t = new TreeMap();\\n        for (int i = 1; i < n; i++) {\\n            t.put(nums[i], t.getOrDefault(nums[i], 0) + 1);\\n        }\\n        \\n        int min_i = Integer.MAX_VALUE;\\n        for (int j = 1; j < n; j++) {\\n            min_i = Math.min(min_i, nums[j-1]);\\n\\t\\t\\t\\n\\t\\t\\t// exclude the current nums[j] from the search space\\n\\t\\t\\t// if the count is 0, simply discard the node from the BST.\\n            t.put(nums[j], t.get(nums[j]) - 1);\\n            if (t.get(nums[j]) == 0) {\\n                t.remove(nums[j]);\\n            }\\n            \\n            if (nums[j] < min_i) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t// check if a number, nums[k], exists in the current search space\\n\\t\\t\\t// such that min_i < nums[k] < nums[j].\\n            if (t.subMap(min_i, false, nums[j], false).size() > 0) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902824,
                "title": "c-stack-o-n-solution-explained",
                "content": "Runtime: 20 ms, faster than 99.71% of C++ online submissions for 132 Pattern.\\nMemory Usage: 12.9 MB, less than 10.09% of C++ online submissions for 132 Pattern.\\n\\n```\\nGiven array nums, find nums[i] < nums[k] < nums[j] such that i < j < k\\n\\nFor tracking nums[i] we can use minValue array where ith value stores \\nmin value in range 0 to i-1 index\\n\\nNow we can loop from end to start and store the next greater number \\nof minValue[x] in the stack and check if stack.top < nums[x] then return true\\n    \\nminValue[x] (nums[i]) < stack.top (nums[k]) < nums[x] (nums[j])\\n\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // no 132 pattern possible\\n        if(n<3) return false;\\n        \\n        // track min value in range 0 to i-1\\n        vector<int>minValues(n,INT_MAX);\\n        \\n        // store min values\\n        for(int i=1;i<n;i++)\\n            minValues[i] = min(minValues[i-1],nums[i-1]);\\n        \\n        stack<int>stak;\\n        \\n        // Loop through end to start\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            // pop numbers from stack which are less or equal to minValue[i]\\n            // find next greater number of minValue[i]\\n            while(!stak.empty() && stak.top()<=minValues[i])\\n                stak.pop();\\n            \\n            // stack.top < nums[i] then it is a 132 pattern as stack.top > minValue[i]\\n            if(!stak.empty() && stak.top()< nums[i]) return true;\\n            \\n            stak.push(nums[i]);\\n        }\\n        \\n        return false;\\n\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nGiven array nums, find nums[i] < nums[k] < nums[j] such that i < j < k\\n\\nFor tracking nums[i] we can use minValue array where ith value stores \\nmin value in range 0 to i-1 index\\n\\nNow we can loop from end to start and store the next greater number \\nof minValue[x] in the stack and check if stack.top < nums[x] then return true\\n    \\nminValue[x] (nums[i]) < stack.top (nums[k]) < nums[x] (nums[j])\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // no 132 pattern possible\\n        if(n<3) return false;\\n        \\n        // track min value in range 0 to i-1\\n        vector<int>minValues(n,INT_MAX);\\n        \\n        // store min values\\n        for(int i=1;i<n;i++)\\n            minValues[i] = min(minValues[i-1],nums[i-1]);\\n        \\n        stack<int>stak;\\n        \\n        // Loop through end to start\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            // pop numbers from stack which are less or equal to minValue[i]\\n            // find next greater number of minValue[i]\\n            while(!stak.empty() && stak.top()<=minValues[i])\\n                stak.pop();\\n            \\n            // stack.top < nums[i] then it is a 132 pattern as stack.top > minValue[i]\\n            if(!stak.empty() && stak.top()< nums[i]) return true;\\n            \\n            stak.push(nums[i]);\\n        }\\n        \\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015153,
                "title": "easy-and-simple-code-with-3-aproaches",
                "content": "***APROACH 1: BRUTE FORCE {TLE}***\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        for(int i = 0; i < nums.length - 2; ++i){\\n            if(nums[i] >= nums[i + 1]){\\n                continue;\\n            }\\n            for(int j = i + 1; j < nums.length - 1; ++j){\\n                if(nums[j] <= nums[j + 1]){\\n                    continue;\\n                }\\n                for(int k = j + 1; k < nums.length; ++k){\\n                    if(nums[k] >= nums[j] || nums[k] <= nums[i]){\\n                        continue;\\n                    }\\n                    return true;\\n                }\\n                \\n                i = j;\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n}\\n```\\n***APROACH 2 : USING STACK***\\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        if(n < 3){\\n            return false;\\n        }\\n        int[] mins = new int[n];\\n        // make list of mins at num index\\n        mins[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            mins[i] = Math.min(mins[i-1],nums[i]);\\n        }\\n        Stack<Integer> stack = new Stack<>(); // keep track of potential k\\'s in decreasing order\\n        for(int i=n-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(nums[i]);\\n            };\\n            while(!stack.isEmpty() && stack.peek() <= mins[i]){ // while potential k is smaller than i\\n                stack.pop();\\n            }\\n            if(stack.isEmpty()){ // no more potential k\\'s\\n                stack.push(nums[i]);\\n                continue;\\n            }\\n            if(stack.peek() >= nums[i]){ // bigger than j\\n                stack.push(nums[i]);\\n            }else if(stack.peek() > mins[i]){ // between i and j\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n***APROACH 3: GREEDY {WITHOUT STACK}***\\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        int[] rmax = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            rmax[i] = i + 1 < nums.length ? Math.max(rmax[i + 1], nums[i]) : nums[i];\\n        }\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (min > nums[i - 2] && (rmax[i] <= min || nums[i - 1] >= max)) {\\n                min = nums[i - 2];\\n                max = nums[i - 1];\\n            } else {\\n\\t\\t\\t\\tmax = Math.max(nums[i - 1], max);\\n\\t\\t\\t}\\n            if (min < nums[i] && nums[i] < max) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        for(int i = 0; i < nums.length - 2; ++i){\\n            if(nums[i] >= nums[i + 1]){\\n                continue;\\n            }\\n            for(int j = i + 1; j < nums.length - 1; ++j){\\n                if(nums[j] <= nums[j + 1]){\\n                    continue;\\n                }\\n                for(int k = j + 1; k < nums.length; ++k){\\n                    if(nums[k] >= nums[j] || nums[k] <= nums[i]){\\n                        continue;\\n                    }\\n                    return true;\\n                }\\n                \\n                i = j;\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        if(n < 3){\\n            return false;\\n        }\\n        int[] mins = new int[n];\\n        // make list of mins at num index\\n        mins[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            mins[i] = Math.min(mins[i-1],nums[i]);\\n        }\\n        Stack<Integer> stack = new Stack<>(); // keep track of potential k\\'s in decreasing order\\n        for(int i=n-1;i>=0;i--){\\n            if(stack.isEmpty()){\\n                stack.push(nums[i]);\\n            };\\n            while(!stack.isEmpty() && stack.peek() <= mins[i]){ // while potential k is smaller than i\\n                stack.pop();\\n            }\\n            if(stack.isEmpty()){ // no more potential k\\'s\\n                stack.push(nums[i]);\\n                continue;\\n            }\\n            if(stack.peek() >= nums[i]){ // bigger than j\\n                stack.push(nums[i]);\\n            }else if(stack.peek() > mins[i]){ // between i and j\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        int[] rmax = new int[nums.length];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            rmax[i] = i + 1 < nums.length ? Math.max(rmax[i + 1], nums[i]) : nums[i];\\n        }\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (min > nums[i - 2] && (rmax[i] <= min || nums[i - 1] >= max)) {\\n                min = nums[i - 2];\\n                max = nums[i - 1];\\n            } else {\\n\\t\\t\\t\\tmax = Math.max(nums[i - 1], max);\\n\\t\\t\\t}\\n            if (min < nums[i] && nums[i] < max) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525914,
                "title": "java-count-from-end-and-use-max-stack",
                "content": "1, count from n-1 to 0;\\n2, use mid to store the mid value;\\n3, maintain a max stack to find the max mid.\\n4, find any next num that is lower than mid\\n```\\npublic boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int mid = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < mid) return true;\\n            while (!st.isEmpty() && nums[i] > st.peek()) {\\n                mid = st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int mid = Integer.MIN_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < mid) return true;\\n            while (!st.isEmpty() && nums[i] > st.peek()) {\\n                mid = st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94090,
                "title": "python-o-n-solution-using-stack",
                "content": "Scan `nums` only once. The `stack` maintains a list of disjoint intervals (except the end point)  where the lower  and upper bound of each interval denote the minimum and maximum in the '132' pattern respectively. Thus any subsequent number which is strictly contained in any intervals in the `stack` will form a '132' pattern.\\n The order of intervals in the `stack` are maintained in a way such that if the right end of interval `A`  is less than or equal to the left end of interval `B`, then `A` is above `B` in the `stack`. The time complexity is O(N), since each number will at most be pushed and popped once. \\n```\\n    def find132pattern(self, nums):\\n        if len(set(nums)) < 3:\\n            return False\\n        stack = [[nums[0], nums[0]]]\\n        current_min = nums[0]\\n        for i in range(1, len(nums)):\\n            curr = nums[i]\\n            if curr >= stack[0][1]:  # curr >= max(nums[:i])\\n                stack = [[current_min, curr]]\\n            elif curr < current_min:  # curr < min(nums[:i])\\n                stack.append([curr, curr])\\n                current_min = curr\\n            elif curr == current_min:\\n                continue\\n            else:\\n                while stack and curr > stack[-1][0]:\\n                    if curr < stack[-1][1]:\\n                        return True\\n                    else:\\n                        stack.pop()\\n                stack.append([current_min, curr])\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n    def find132pattern(self, nums):\\n        if len(set(nums)) < 3:\\n            return False\\n        stack = [[nums[0], nums[0]]]\\n        current_min = nums[0]\\n        for i in range(1, len(nums)):\\n            curr = nums[i]\\n            if curr >= stack[0][1]:  # curr >= max(nums[:i])\\n                stack = [[current_min, curr]]\\n            elif curr < current_min:  # curr < min(nums[:i])\\n                stack.append([curr, curr])\\n                current_min = curr\\n            elif curr == current_min:\\n                continue\\n            else:\\n                while stack and curr > stack[-1][0]:\\n                    if curr < stack[-1][1]:\\n                        return True\\n                    else:\\n                        stack.pop()\\n                stack.append([current_min, curr])\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3686808,
                "title": "python-3-strictly-monotonic-decreasing-stack-not-reversed",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack, minVal = [], float(\\'inf\\')\\n\\n        for n in nums:\\n            while stack and stack[-1][0] <= n:\\n                stack.pop()\\n\\n            if stack and stack[-1][1] < n:\\n                return True\\n            \\n            minVal = min(minVal, n)\\n            stack.append([n, minVal])\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack, minVal = [], float(\\'inf\\')\\n\\n        for n in nums:\\n            while stack and stack[-1][0] <= n:\\n                stack.pop()\\n\\n            if stack and stack[-1][1] < n:\\n                return True\\n            \\n            minVal = min(minVal, n)\\n            stack.append([n, minVal])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466905,
                "title": "java-o-n-2-solution-o-n-solution-easy-to-understand",
                "content": "O(n^2) Solution\\n```\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) {\\n         if(nums.length < 3)\\n            return false;\\n        \\n         for(int i=1;i<nums.length-1;i++)\\n         {\\n             int min1 = Integer.MAX_VALUE;//min2 = Integer.MAX_VALUE;\\n             for(int j = 0;j<i;j++)\\n                min1 = Math.min(min1,nums[j]);\\n             for(int j = i+1;j<nums.length;j++)\\n             {\\n                 if(min1 < nums[j] && nums[j] < nums[i])\\n                     return true;\\n             }\\n            \\n         }\\n        \\n        return false;\\n     }\\n}\\n```\\nO(n^2 ) will fail for last test case.\\n\\nO(n) solution\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[0] = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)\\n            min[i] = Math.min(min[i-1],nums[i]);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int j=nums.length-1;j>=0;j--)\\n        {\\n            while(st.size()>0 && st.peek() <= min[j])\\n                st.pop();\\n            if(st.size() > 0 && st.peek() < nums[j])\\n                return true;\\n            st.push(nums[j]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) {\\n         if(nums.length < 3)\\n            return false;\\n        \\n         for(int i=1;i<nums.length-1;i++)\\n         {\\n             int min1 = Integer.MAX_VALUE;//min2 = Integer.MAX_VALUE;\\n             for(int j = 0;j<i;j++)\\n                min1 = Math.min(min1,nums[j]);\\n             for(int j = i+1;j<nums.length;j++)\\n             {\\n                 if(min1 < nums[j] && nums[j] < nums[i])\\n                     return true;\\n             }\\n            \\n         }\\n        \\n        return false;\\n     }\\n}\\n```\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[0] = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)\\n            min[i] = Math.min(min[i-1],nums[i]);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int j=nums.length-1;j>=0;j--)\\n        {\\n            while(st.size()>0 && st.peek() <= min[j])\\n                st.pop();\\n            if(st.size() > 0 && st.peek() < nums[j])\\n                return true;\\n            st.push(nums[j]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123741,
                "title": "c-stack-easy-with-explanation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo the Idea behind this approach is :\\n- First we gonna talk about Brute force that will be done by using three loops checking every triplet and if any triplet satisfy the condtion we gonna return true. (But --> $$O(N^3)$$\\uD83D\\uDE14)\\n- Second little better brute force that can be checking using two loops only whether  \\n    - checking frist two two elemnts through i and jth loop and third can be chekced from a map which stores elemnts one by one from back and we have to check if arr[i]<arr[j] and maps biggest elemnt >arr[i] and <arr[j] . \\n    - Or we can have a mini variable  in ith loop (i.e left hand side) and we check  arr[i]<arr[j] and arr[i]>mini beacsue mini is in front so we can do this using two loops.\\n    \\n- **Now coming to the beast O(N)**:\\n- So the idea behind that appraoch is since traversing from back will be more handy in this case so try to imagine that way . If we somehow can check what gonna be our arr[k] our work is done because then we have to only find a number less than it and our answer will be true. That is because if we take an example e.g 9 3 6 5 4 3\\n- so here traversing from back side first we will take 3 but we are not confirm if it gonna be our arr[k] , but we take so after we check if some elemnt is greater than it if yes we gonna now need only arr[i] now if our arr[k]>arr[i] we gonna return true so \\n- take 3 i.e arr[k] now 4 is greter than 3 i.e arr[j] so now 5 but want less than 3 we can\\'t find so the thing is we are not sure of selecting arr[k] , arr[j] can be biggest in array and arr[i] can smallest in array but not sure about arr[k] so we somehow have to first take and untake that after some condition so we are gonna use **stack** beacuse we can pop earlier values and focus on new .That was the idea why we will use stack\\n- So the idea is first initialze **kth with INT_MIN** then start the loop from back and check if current element is less than k return true else check in stack if st.top is lesser than curr it can be taken as arr[j] and rest all will be popped and top can be taken as k and also keep pushing the elements in stack at the end as well. Now if next elemnt is less than k return true or if not check if its bigger than st.top again pop elemnts and take kth  as st.top.\\n-  we are doing this beacuse we want the kth element  lesser than jth but enough bigger tha ith . So once an element is less than kth we will return true.\\n- Also if we observe on thing until some elemnt is not bigger than our st.top our k will not be intilaized until that\\n-  so in this way in the given example first our k is 3 then 4 then 5 then 3 will come which less than 5 so will return true .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo in Nutshell keep stack in a way that our k should be maximized and we also check if its less than some elemnt also beacsue we need the jth > kth . once out jth is going biggr n bigger we change our k gradually  with that so it should have more possiblity to be greater than ith.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& arr) {\\n        int n=arr.size();\\n        int kth=INT_MIN;\\n        stack<int>st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]<kth)return true;\\n            else {\\n                while(!st.empty() and arr[i]>st.top()){\\n                    kth=st.top();\\n                    st.pop();\\n                }\\n            }\\n            st.push(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& arr) {\\n        int n=arr.size();\\n        int kth=INT_MIN;\\n        stack<int>st;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arr[i]<kth)return true;\\n            else {\\n                while(!st.empty() and arr[i]>st.top()){\\n                    kth=st.top();\\n                    st.pop();\\n                }\\n            }\\n            st.push(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015333,
                "title": "o-n-3-o-n-2-o-n-how-to-solve-a-problem-step-by-step-one-pass",
                "content": "\\n\\n\\n**1st and 2nd solution gives TLE\\nthis sol gives idea how to solve a problem o(n^3)-->o(n^2)\\nTime Complexity :- BigO(N^3)\\nSpace Complexity :- BigO(1)**\\n```\\n\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(nums[k]<nums[j] && nums[k]>nums[i])return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n2nd solution\\n\\nTime Complexity :- BigO(N^2)\\n\\nSpace Complexity :- BigO(1)\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int m=nums[0];\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int k=j+1;k<n;k++)\\n            {\\n                if(nums[k]>m && nums[j]>nums[k])return true;\\n                m=min(m,nums[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\nsol 3\\n\\n.firstly take a stack st.\\n.than we add a new number  \\nfirstly we pop out all the number that are small that number \\nin this way last elemnt pop than become s3 \\n. we find maximum  s3(recently poped number)\\n\\n Time Complexity :- BigO(N)\\nSpace Complexity :- BigO(N)\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(nums[k]<nums[j] && nums[k]>nums[i])return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int m=nums[0];\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int k=j+1;k<n;k++)\\n            {\\n                if(nums[k]>m && nums[j]>nums[k])return true;\\n                m=min(m,nums[j]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718263,
                "title": "c-solution-with-complete-explanation",
                "content": "This question is variation of the question NEXT GREATEST ELEMENT, So the first intuition comes to optimize it is using stack somehow in our solution.\\n\\n \\n\\nIs it possible to find three indexes, i,j,k where i<j<k and arr[i]<arr[k] and arr[k]<arr[j], if there exist the conditions return true or false.\\n\\n \\n\\nNow, how we approach this question, I presume you\\'re familiar with NEXT GREATEST INTEGER/ELEMENT, if not, I strongly suggest you to go and do it first before proceeding with this question since it will be a lot easier to understand then. Before we go to stack, let\\'s have a vector which will store our minimums on the left side of each and every index, WHY??. We will use this information, in our stack and we are marking that at every index i, the minimum calculated will be referred to as building 1 or i. \\n\\n \\n\\nNow after we have our vector ready of all minimums to the left, we will now create a stack and proceed forward with the algorithm, Here I\\'ll show how the calculation of minimum vector has saved us for all chaos.\\n\\n \\n\\nNow, you have created a vector, now we will iterate on original array from the back, WHY?? Because iterating from back will help us be sure that every iterative element will the 2rd building  or the j index building, Now we will have 2 conditions that this index must SATISFY,\\n\\n \\n\\nIF THE VECTOR WHICH HOLDS ALL MINIMUM SHOULD HAVE THIS Min(INDEX VALUE) \\u2265 STACK TOP, well this pretty my signifies that the 1st building i.e. the i-th building height is greater than K-th building or the 3rd building, because top will always consist of last element and hence 3rd building  . Remember I told you while calculating minimum we will use it, If this is the case its invalid, since according to question we need to have 3rd building or the k-th building larger than the 1st building or the i-th building, so we pop element from this stack till the condition becomes invalid\\nAfter we come out of while loop, we either have exhausted our stack which means this is not an answer so we continue iterating in the array, and if the stack is not empty check if the min[index]<arr[i] (it means building i < building j , which is true and check if arr[i]>s.top() , which means building j is greater than building k. If these all conditions satisfy return true,\\nElse run the iteration till index 0 and if true answer is still not returned return false.\\n \\n\\nMathematically, what we did here:-\\n\\n \\n\\nAssuming  three indexes for \\n\\ni=Building 1 , j=Building 2 and k=Building 3,\\n\\nAccording to Question,\\n\\n indexes should be in increasing order and hence\\n\\n                       i<j<k \\n\\nand their values should be  satisfying\\n\\n                  |i|<|k|   &&  |j|>|k|\\n\\nHence we can say that j is greatest of all, i,e,\\n\\n                             |i|<|k|<|j|\\n\\t\\t\\t\\t\\t\\t\\t \\n``\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini[n];\\n        mini[0]=nums[0];\\n        \\n        for(int i = 1; i<n ; i++){\\n            mini[i] = min(mini[i-1],nums[i]); \\n        }\\n        stack<int> st;\\n        for(int j = n-1 ; j>=0 ; j--){\\n            if(nums[j]>mini[j]){\\n                while(!st.empty() && st.top()<=mini[j])\\n                    st.pop();\\n                \\n                if(!st.empty() && st.top()<nums[j])\\n                    return true;\\n                st.push(nums[j]);\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini[n];\\n        mini[0]=nums[0];\\n        \\n        for(int i = 1; i<n ; i++){\\n            mini[i] = min(mini[i-1],nums[i]); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2387128,
                "title": "very-easy-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 2 ms, faster than 98.34% of Java online submissions for 132 Pattern.\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min = Integer.MIN_VALUE;\\n        int peak = nums.length;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            // We find a \"132\" pattern if nums[i] < min, so return true...\\n            if (nums[i] < min)\\n                return true;\\n            // If peak < nums.length & nums[i] is greater than the peak element...\\n            while (peak < nums.length && nums[i] > nums[peak])\\n                min = nums[peak++];\\n            // Now we have nums[i] <= nums[peak]\\n            // We push nums[i] to the \"stack\"            \\n            peak--;\\n            nums[peak] = nums[i];\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n# **C++ Solution (Using Stack):**\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        // Initialise a empty stack \"s\"...\\n        stack<int> s;\\n        // To keep track of minimum element...\\n        int min = INT_MIN;\\n        // Run a Loop from last to first index...\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            // If min is greater than nums[i], return true...\\n            if (nums[i] < min)\\n                return true;\\n            // If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            while (!s.empty() && nums[i] > s.top()) {\\n                min = s.top();\\n                s.pop();\\n            }\\n            // Otherwise, push nums[i] into stack...\\n            s.push(nums[i]);\\n        }\\n        // If the condition is not satisfied, return false.\\n        return false;\\n    }\\n};\\n```\\n\\n# **Python Solution (Using Stack):**\\n```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        # Base Condition...\\n        if len(nums) < 3:\\n            return False\\n        m = float(\\'-inf\\')\\n        # Initialise a empty stack...\\n        stack = []\\n        # Run a Loop from last to first index...\\n        for i in range(len(nums)-1, -1, -1):\\n            # If m is greater than nums[i], return true...\\n            if nums[i] < m:\\n                return True\\n            # If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    m = stack.pop()\\n            # Otherwise, append nums[i] into stack...\\n            stack.append(nums[i])\\n        # If the condition is not satisfied, return false.\\n        return False\\n```\\n        \\n# **JavaScript Solution (Using Stack):**\\n```\\nvar find132pattern = function(nums) {\\n    let m = -Infinity\\n    // Initialise a empty stack...\\n    const stack = []\\n    // Run a Loop from last to first index...\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        // If nums[i] is greater than the top element of stack, then pop the element...\\n        while (nums[i] > stack[stack.length - 1]) {\\n            m = stack.pop()\\n        }\\n        // If m is greater than nums[i], return true...\\n        if (nums[i] < m) {\\n            return true\\n        }\\n        // Otherwise, push nums[i] into stack...\\n        stack.push(nums[i])\\n    }\\n    // If the condition is not satisfied, return false.\\n    return false\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool find132pattern(int* nums, int numsSize){\\n    int peak = numsSize, min = INT_MIN;\\n    for (int i = numsSize - 1; i > -1; i--) {\\n        if (nums[i] < min)\\n            return true;\\n        while (peak < numsSize && nums[i] > nums[peak]) {\\n            min = nums[peak];\\n            peak++;\\n        }\\n        peak--;\\n        nums[peak] = nums[i];\\n    }\\n    return false;\\n}\\n```\\n\\n# **Python3 Solution (Using Stack):**\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        # Base Condition...\\n        if len(nums) < 3:\\n            return False\\n        # To keep track of minimum element...\\n        mini = float(\\'-inf\\')\\n        # Initialise a empty stack...\\n        stack = []\\n        # Run a Loop from last to first index...\\n        for i in range(len(nums)-1, -1, -1):\\n            # If min is greater than nums[i], return true...\\n            if nums[i] < mini:\\n                return True\\n            # If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    mini = stack.pop()\\n            # Otherwise, append nums[i] into stack...\\n            stack.append(nums[i])\\n        # If the condition is not satisfied, return false.\\n        return False\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min = Integer.MIN_VALUE;\\n        int peak = nums.length;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            // We find a \"132\" pattern if nums[i] < min, so return true...\\n            if (nums[i] < min)\\n                return true;\\n            // If peak < nums.length & nums[i] is greater than the peak element...\\n            while (peak < nums.length && nums[i] > nums[peak])\\n                min = nums[peak++];\\n            // Now we have nums[i] <= nums[peak]\\n            // We push nums[i] to the \"stack\"            \\n            peak--;\\n            nums[peak] = nums[i];\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        // Initialise a empty stack \"s\"...\\n        stack<int> s;\\n        // To keep track of minimum element...\\n        int min = INT_MIN;\\n        // Run a Loop from last to first index...\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            // If min is greater than nums[i], return true...\\n            if (nums[i] < min)\\n                return true;\\n            // If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            while (!s.empty() && nums[i] > s.top()) {\\n                min = s.top();\\n                s.pop();\\n            }\\n            // Otherwise, push nums[i] into stack...\\n            s.push(nums[i]);\\n        }\\n        // If the condition is not satisfied, return false.\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        # Base Condition...\\n        if len(nums) < 3:\\n            return False\\n        m = float(\\'-inf\\')\\n        # Initialise a empty stack...\\n        stack = []\\n        # Run a Loop from last to first index...\\n        for i in range(len(nums)-1, -1, -1):\\n            # If m is greater than nums[i], return true...\\n            if nums[i] < m:\\n                return True\\n            # If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    m = stack.pop()\\n            # Otherwise, append nums[i] into stack...\\n            stack.append(nums[i])\\n        # If the condition is not satisfied, return false.\\n        return False\\n```\n```\\nvar find132pattern = function(nums) {\\n    let m = -Infinity\\n    // Initialise a empty stack...\\n    const stack = []\\n    // Run a Loop from last to first index...\\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        // If nums[i] is greater than the top element of stack, then pop the element...\\n        while (nums[i] > stack[stack.length - 1]) {\\n            m = stack.pop()\\n        }\\n        // If m is greater than nums[i], return true...\\n        if (nums[i] < m) {\\n            return true\\n        }\\n        // Otherwise, push nums[i] into stack...\\n        stack.push(nums[i])\\n    }\\n    // If the condition is not satisfied, return false.\\n    return false\\n};\\n```\n```\\nbool find132pattern(int* nums, int numsSize){\\n    int peak = numsSize, min = INT_MIN;\\n    for (int i = numsSize - 1; i > -1; i--) {\\n        if (nums[i] < min)\\n            return true;\\n        while (peak < numsSize && nums[i] > nums[peak]) {\\n            min = nums[peak];\\n            peak++;\\n        }\\n        peak--;\\n        nums[peak] = nums[i];\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        # Base Condition...\\n        if len(nums) < 3:\\n            return False\\n        # To keep track of minimum element...\\n        mini = float(\\'-inf\\')\\n        # Initialise a empty stack...\\n        stack = []\\n        # Run a Loop from last to first index...\\n        for i in range(len(nums)-1, -1, -1):\\n            # If min is greater than nums[i], return true...\\n            if nums[i] < mini:\\n                return True\\n            # If stack is not empty &  nums[i] is greater than the top element of stack, then pop the element...\\n            else:\\n                while stack and stack[-1] < nums[i]:\\n                    mini = stack.pop()\\n            # Otherwise, append nums[i] into stack...\\n            stack.append(nums[i])\\n        # If the condition is not satisfied, return false.\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016943,
                "title": "o-n-2-o-nlogn-thinking-solution-with-comments",
                "content": "**Please note in this post i have covered thought process for building a solution in 30 minutes, I could not reach O(N) in 30 minutes and feel free to ignore this post incase you are interested in best solution for this problem. This is only for helping someone who is stuck building thought process**\\n\\n\\n**Solution1**\\n*Thought process*\\n1. Lets suppose we traverse the array taking one element at a time. The element we are on says, I am the greatest element among three elements we have to find i.e. I am j.\\n2. Now for saying that this element is greatest among 3 we have to select. There should be atleast one element smaller than this in left. This gave me a idea while I am traversing array I will keep track of what was minimum so far. Keeping track of minimum so far is not a big deal I will maintain one minElement so far. This minElement can be our ith element.\\n3. Now we know we got i and j. For k we will go to every element in right of j and find one element which is greater than minElement we have so far and less than current element i.e. nums[j]\\n4. If we found any such element in right. Congratulations we reached the solution and return true. If we didn\\'t got any k in right for sure this element can not be j.\\n5. In the end if we dont find any possible j. Return false.\\n\\n````\\nint minElement=nums[0]\\nfor(int j=1;j<nums.size()-1;j++){ \\n//why nums.size()-1 I am j. There should be k in right so j cannot be last atleast. Definitely going till last element -1 makes sense and going till end doesn\\'t\\n\\tfor(int k=j+1;k<nums.size();k++){\\n\\t   if(nums[k]>minElement && nums[k]<nums[j]){\\n\\t\\t return true;\\n      }\\n   }\\n   minElement=min(minElement, nums[j]);\\n}\\nreturn false;\\n````\\n\\n**Time Complexity** O(N^2)\\n**Space Complexity** O(1)\\n\\n\\nCan we do something better in above apporach ?\\nThink for a while. \\n\\nIf you are not able to think, take this hint and think again.\\nHint: The only part bothering us is for every j we have to check every element in its right hand side which is greater than minElement so far i.e. our ith element and smaller than jth element i.e. current element in loop.\\n\\n\\nWhat if we maintain list of all elements after j in sorted order, and then search for lower_bound of minElement+1. If the element we got is less than element at jth index. Yay we got the solution.  We can acheive this with set definitely. \\n\\nWhy search for lower_bound(minElement+1)?\\nBecuase among all the elements present after j. We have to find an element just greater than minElement so far. It is therefore minElement+1. Now the lowerBound we got there can be two scenarios:\\na. Lower bound we got is the element which is greater than nums[j]. We are not interested in it then.\\nb. Lower bound we got is the element which is less than nums[j]. We are interested. Why?? Because its what we wanted. We got a pair.\\n\\n\\nBased on above intution only i tried submitting my code it again gave me TLE and errors as well since i used Set to maintain sorted list. Set contains unique element where as there can be duplicate elements as well.\\n\\nMy solution\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int sz=nums.size();\\n        if(sz<3){\\n            return false;\\n        }\\n        \\n        int minFront = nums[0];\\n        map<int, int> numToHash; // I am using this map to keep track of number of occurrenes of elements\\n        set<int> back; // A set which contains all the elements after j\\n        for(int j=sz-1;j>=2;j--){\\n            back.insert(nums[j]);\\n            numToHash[nums[j]]++;\\n        }        \\n        \\n        \\n        for(int j=1;j<sz-1;j++){\\n            set<int>::iterator it = lower_bound(back.begin(), back.end(), minFront+1);\\n            if(it!=back.end() && nums[j]>minFront && *it>minFront && nums[j]>*it){\\n                return true;\\n            }\\n            minFront=min(minFront, nums[j]);\\n            numToHash[nums[j+1]]--;\\n            if(numToHash[nums[j+1]]==0){\\n\\t\\t\\t//Remember set contains all elements which are after j in sorted order ...\\n\\t\\t\\t//so when we move forward remove the next element as after moving it became jth element. Whereas we have to keep track of elements after j.\\n                back.erase(nums[j+1]);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n\\nBased on same intution instead of set now i used min heap. Since set alone is not possible as there can be duplicates as well. \\nUsing min heap it got submitted. Not writing the complete answer again using min heap, Intution is same.\\n\\nCode\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int sz=nums.size();\\n        if(sz<3){\\n            return false;\\n        }\\n        \\n        int minFront[sz];//Keeps track of minimum element so far starting from 0\\n        int minimum=nums[0];\\n        for(int i=1;i<sz;i++){\\n            minFront[i]=minimum;\\n            minimum=min(minimum, nums[i]);\\n        }\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        pq.push(nums[sz-1]);\\n        \\n        for(int i=sz-2;i>=1;i--){\\n            while(pq.size() && pq.top()<=minFront[i]){\\n                pq.pop();\\n            }\\n            \\n            if(pq.size() && pq.top()<nums[i]){\\n                return true;\\n            }else{\\n                pq.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Time Complexity** O(NLogN)\\n**Space Complexity** O(N) \\n\\nI completely understand priority queue solution is not explained. See based on above intuition now if you can approach the problem in NlogN. \\n\\n*Remember the motive of this post was just to explain how to build thought process. Please upvote in case you find my thought process useful, It motivates me.*",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "````\\nint minElement=nums[0]\\nfor(int j=1;j<nums.size()-1;j++){ \\n//why nums.size()-1 I am j. There should be k in right so j cannot be last atleast. Definitely going till last element -1 makes sense and going till end doesn\\'t\\n\\tfor(int k=j+1;k<nums.size();k++){\\n\\t   if(nums[k]>minElement && nums[k]<nums[j]){\\n\\t\\t return true;\\n      }\\n   }\\n   minElement=min(minElement, nums[j]);\\n}\\nreturn false;\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int sz=nums.size();\\n        if(sz<3){\\n            return false;\\n        }\\n        \\n        int minFront = nums[0];\\n        map<int, int> numToHash; // I am using this map to keep track of number of occurrenes of elements\\n        set<int> back; // A set which contains all the elements after j\\n        for(int j=sz-1;j>=2;j--){\\n            back.insert(nums[j]);\\n            numToHash[nums[j]]++;\\n        }        \\n        \\n        \\n        for(int j=1;j<sz-1;j++){\\n            set<int>::iterator it = lower_bound(back.begin(), back.end(), minFront+1);\\n            if(it!=back.end() && nums[j]>minFront && *it>minFront && nums[j]>*it){\\n                return true;\\n            }\\n            minFront=min(minFront, nums[j]);\\n            numToHash[nums[j+1]]--;\\n            if(numToHash[nums[j+1]]==0){\\n\\t\\t\\t//Remember set contains all elements which are after j in sorted order ...\\n\\t\\t\\t//so when we move forward remove the next element as after moving it became jth element. Whereas we have to keep track of elements after j.\\n                back.erase(nums[j+1]);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int sz=nums.size();\\n        if(sz<3){\\n            return false;\\n        }\\n        \\n        int minFront[sz];//Keeps track of minimum element so far starting from 0\\n        int minimum=nums[0];\\n        for(int i=1;i<sz;i++){\\n            minFront[i]=minimum;\\n            minimum=min(minimum, nums[i]);\\n        }\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        pq.push(nums[sz-1]);\\n        \\n        for(int i=sz-2;i>=1;i--){\\n            while(pq.size() && pq.top()<=minFront[i]){\\n                pq.pop();\\n            }\\n            \\n            if(pq.size() && pq.top()<nums[i]){\\n                return true;\\n            }else{\\n                pq.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534094,
                "title": "python-3-stack-o-n",
                "content": "The num which is larger than the `third` and before `third` is stored in the \\'`stack`\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        stack, third = [], float(\\'-inf\\')\\n        for i in range(n-1,-1,-1):\\n            if nums[i]< third: return True\\n            while stack and nums[i]>stack[-1]:\\n                third = stack.pop()\\n            stack.append(nums[i])\\n        return False\\n            \\n```\\n\\n\\n***\\nCheck on my [repo](https://github.com/zengtian006/LeetCode) to get Leetcode solution(Python) with classification: https://github.com/zengtian006/LeetCode\\n***",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        stack, third = [], float(\\'-inf\\')\\n        for i in range(n-1,-1,-1):\\n            if nums[i]< third: return True\\n            while stack and nums[i]>stack[-1]:\\n                third = stack.pop()\\n            stack.append(nums[i])\\n        return False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 94092,
                "title": "c-o-n-greedy-solution-using-stack",
                "content": "Since, it is 132 pattern. The smallest of the three is in front of the other two. We'd better scan from back to front. In this way, we can maintain a pair of biggest numbers (S3 and S2) and looking for S1 which is smaller than S2 (S1 < S2). Otherwise, we pop numbers in stack and update S2 accordingly.\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int s2 = INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < s2)\\n                return true;\\n            \\n            while (!stk.empty() && stk.top() < nums[i]) {\\n                s2 = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int s2 = INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < s2)\\n                return true;\\n            \\n            while (!stk.empty() && stk.top() < nums[i]) {\\n                s2 = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044567,
                "title": "c-intuitive-solution-with-stack-explained",
                "content": "This was a really good question. It can be solved using brute force but even its **brute force** would be difficult. As we have to find two numbers, one in left, another in right and with the condition that k>j and i>k>j. To achieve this, we will have to run three nested loops taking the complexity to **O(N^3)**\\nInstead, a little knowledge of stack, more specifically monotonic stack, would help a lot in this problem. In case you don\\'t know what a monotonic stack is, please watch *[this video](https://www.youtube.com/watch?v=j313ttNJjo0)*. He has explained it beautifully. To practice a few questions, please solve *[this](https://leetcode.com/problems/daily-temperatures/)*\\n\\nAfter you have a sufficient amount of knowlede of monotonic stacks, you can have some intuition of this problem too. \\nLets first see what this question demands. It want us to find three numbers, let\\'s name them `i, j, k`, such that` j>k>i`. \\nTo achieve that, we can maintain a ***monotonically decreasing*** stack. \\n***Why decreasing?*** Well, if we will have a decreasing stack, we would have two numbers,` j` and `k`, and our task will reduce to finding an `i` such that `i<k<j,` and its in the left of `j`. Our stack will always ensure that `j>k` and `k` is in the right of `j. `\\nTo find a suitable `i`, what we can do is we can have a **prefix array, that stores the minimum element on the left so far**. Now having that data with us, in each iteration, we can now check if our stack has some elements, and if it does, we check if the prefix (`minimum_so_far`) element is smaller than stack top, ie `k`. If we get that, we return `true`.\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack <pair<int,int>> st;\\n        vector<int> prefix(nums.size(), INT_MAX);\\n\\n        int mini = INT_MAX;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            prefix[i] = mini;\\n            mini = min(mini, nums[i]);    \\n        }\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            if(st.empty()) st.push({nums[i],i});\\n            else{\\n                while(!st.empty() and nums[i]>=st.top().first) st.pop();\\n\\n                if(!st.empty() and prefix[st.top().second]<nums[i]) return true;\\n                \\n                st.push({nums[i],i});\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack <pair<int,int>> st;\\n        vector<int> prefix(nums.size(), INT_MAX);\\n\\n        int mini = INT_MAX;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            prefix[i] = mini;\\n            mini = min(mini, nums[i]);    \\n        }\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            if(st.empty()) st.push({nums[i],i});\\n            else{\\n                while(!st.empty() and nums[i]>=st.top().first) st.pop();\\n\\n                if(!st.empty() and prefix[st.top().second]<nums[i]) return true;\\n                \\n                st.push({nums[i],i});\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016584,
                "title": "java-stack-sollution-o-n-space-and-time-with-required-explanation",
                "content": "Algorithm:\\n\\n* Create a stack and initialize a variable second with Integer.MIN_VALUE value.\\n* Start traversing from the right to left of teh array to maintain the Next greater Element like stack.\\n* Check if the current number is lesser than second. If it is, then it means our 132 pattern is satisfied as the stack is taking care of the 32 pattern and the current number satisfies the entire pattern. So return true.\\n* If the above is not true, update the top/peak value of the stack. Pop the element from the stack until stack becoms empty OR current element less then top/peek value.\\n* Push the current number into the stack.(To maintain the highest number in stack like from \"132\", \"3\" remains in stack)\\n* If the loop ends, it means that the pattern was not found in the array. So, return false.\\n\\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        //length of the array.\\n        int n = nums.length;\\n        //stack to maintain \"3 2\" pattern from \"1 3 2\"\\n        Stack<Integer> st = new Stack<>();\\n        //second represent second highest number i.e, 2 from \"1 3 2\"\\n        int second = Integer.MIN_VALUE;\\n        \\n        //Now, we are finding 1 as nums[i], stack will contain pattern 32 and we havee to find nums[i] which is less then second so it will also less then st.peek()\\n        for(int i = n-1; i >= 0; i--){\\n            if(nums[i] < second)\\n                return true;\\n            while(!st.isEmpty() && nums[i] > st.peek()){\\n                second = st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nUpvote if you like it ;)",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        //length of the array.\\n        int n = nums.length;\\n        //stack to maintain \"3 2\" pattern from \"1 3 2\"\\n        Stack<Integer> st = new Stack<>();\\n        //second represent second highest number i.e, 2 from \"1 3 2\"\\n        int second = Integer.MIN_VALUE;\\n        \\n        //Now, we are finding 1 as nums[i], stack will contain pattern 32 and we havee to find nums[i] which is less then second so it will also less then st.peek()\\n        for(int i = n-1; i >= 0; i--){\\n            if(nums[i] < second)\\n                return true;\\n            while(!st.isEmpty() && nums[i] > st.peek()){\\n                second = st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277353,
                "title": "456-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create an empty stack and a variable s3 initialized to negative infinity.\\n2. Traverse the input array nums from right to left using a loop:\\na. If the current element nums[i] is less than s3, return True as the 132 pattern exists.\\nb. While the stack is not empty and the top element of the stack is less than nums[i], pop the top element from the stack and set it as s3.\\nc. Push the current element nums[i] onto the stack.\\n3. If the loop completes without finding a 132 pattern, return False.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        s3 = float(\\'-inf\\')\\n        \\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] < s3:\\n                return True\\n            while stack and stack[-1] < nums[i]:\\n                s3 = stack.pop()\\n            stack.append(nums[i])\\n        \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        s3 = float(\\'-inf\\')\\n        \\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] < s3:\\n                return True\\n            while stack and stack[-1] < nums[i]:\\n                s3 = stack.pop()\\n            stack.append(nums[i])\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445517,
                "title": "javascript-solution-w-explanation-stack",
                "content": "### The idea\\n1. Iterate left to right to find N1 candidates (the smallest #)\\n2. Create a stack for N2 candidates, the top number will be the smallest potential N2\\n3. Iterate the array from the right for N3\\n4. For N2 stack, \\n\\t`pop` candidates that are smaller than N1\\n\\t`push` candidates that greater than N1 & smaller than the smallest N2 candidate\\n5. Notice that the reason we can ensure the N2 stack is sorted such that the top value will always be smallest is because we are only pushing in values that is smaller than the smallest N2 value. A smallest N2 possible gives us the best possibility of forming a 132 pattern. If given the smallest N2, we still can\\'t find a 132 pattern, that means we have another smaller N2 candidate.\\n*Hope my explanation worked out for you, leave comments if not. \\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n    // sanity check\\n    if (nums.length < 3) return false;\\n\\n    let N2 = []; // potential candidates, number 2\\n    let N1 = [nums[0]]; // the smallest number, number 3\\n\\n    for (let i=1;i<nums.length;i++) { \\n        N1.push(Math.min(N1[N1.length-1], nums[i]));\\n    }\\n\\n    for (let i=nums.length-1;i>=0;i--) { // number 3\\n        if (nums[i] > N1[i]) {\\n            // remove useless N2 candidates\\n            while (N2.length!=0 && N2[N2.length-1] <= N1[i]) N2.pop();\\n            // found a pattern\\n            if (N2.length!=0 && N2[N2.length-1] < nums[i]) return true;\\n            N2.push(nums[i]);\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n    // sanity check\\n    if (nums.length < 3) return false;\\n\\n    let N2 = []; // potential candidates, number 2\\n    let N1 = [nums[0]]; // the smallest number, number 3\\n\\n    for (let i=1;i<nums.length;i++) { \\n        N1.push(Math.min(N1[N1.length-1], nums[i]));\\n    }\\n\\n    for (let i=nums.length-1;i>=0;i--) { // number 3\\n        if (nums[i] > N1[i]) {\\n            // remove useless N2 candidates\\n            while (N2.length!=0 && N2[N2.length-1] <= N1[i]) N2.pop();\\n            // found a pattern\\n            if (N2.length!=0 && N2[N2.length-1] < nums[i]) return true;\\n            N2.push(nums[i]);\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 94086,
                "title": "python-solution-in-o-nlogn",
                "content": "I tried multiple O(n^2) solutions and it seems only O(nlogn) is accepted for Python.\\n\\nFirst we make the ```left``` list that maintains the min value up to index ```i```. \\nThen we make the ```right``` list backward that maintains the smallest number that is larger than ```left[i]``` up to ```i``` using a heap.\\nFinally we iterate through ```nums``` and check if ```left[i] < right[i] < num```.\\n\\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums:\\n            return False\\n        left = [nums[0]]\\n        for num in nums[1:]:\\n            left.append(min(left[-1], num))\\n        q = []\\n        right = [None] * len(nums)\\n        for i, num in enumerate(nums[::-1]):\\n            heapq.heappush(q, num)\\n            while q and q[0] <= left[len(nums) - i - 1]:\\n                heapq.heappop(q)\\n            if q:\\n                right[len(nums) - i - 1] = q[0]\\n        for i, num in enumerate(nums):\\n            if right and left[i] < right[i] < num:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```left```\n```i```\n```right```\n```left[i]```\n```i```\n```nums```\n```left[i] < right[i] < num```\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        if not nums:\\n            return False\\n        left = [nums[0]]\\n        for num in nums[1:]:\\n            left.append(min(left[-1], num))\\n        q = []\\n        right = [None] * len(nums)\\n        for i, num in enumerate(nums[::-1]):\\n            heapq.heappush(q, num)\\n            while q and q[0] <= left[len(nums) - i - 1]:\\n                heapq.heappop(q)\\n            if q:\\n                right[len(nums) - i - 1] = q[0]\\n        for i, num in enumerate(nums):\\n            if right and left[i] < right[i] < num:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016703,
                "title": "c-o-n-time-best-optimized-approach-using-stack",
                "content": "****upvote if you find it helpfull and easy****\\n\\n\\t\\tstack<int> st;\\n        int second = INT_MIN;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if(nums[i]<second) return true; // this will tell if c<a \\n            while(!st.empty() && nums[i]>st.top()){  // this while loop will tell wheater a>b; then about condition will return true;\\n                second = st.top(), st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "****upvote if you find it helpfull and easy****\\n\\n\\t\\tstack<int> st;\\n        int second = INT_MIN;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if(nums[i]<second) return true; // this will tell if c<a \\n            while(!st.empty() && nums[i]>st.top()){  // this while loop will tell wheater a>b; then about condition will return true;\\n                second = st.top(), st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 2016302,
                "title": "c-easy-short-comments-added-daily-leetcoding-challenge-may-day-7",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        // we wre going to use stack here for solving this problem\\n        // basically we need 3 values right ? and all that threes are follwing a order\\n        // so just need to find the 3 values \\n        // in stack we are going to save previous value and the whole stack min value \\n        // and we will compare these values with the current value according to the need of question\\n        // means if our current value is between betweeen the previos and min then return true else false\\n        \\n        // creating the stack\\n        stack<pair<int,int>> st;           // (previos,min)\\n        int mn = INT_MAX;                  // it will storing the mn value\\n        \\n        // iterating over the whole given array\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // just finding the min value if our stack is not empty\\n            if(!st.empty())\\n                mn = min(mn, st.top().first);\\n            \\n            // just popping all the greater value from the current \\n            // because we need mid value between the previous and min\\n            while(!st.empty() && nums[i]>st.top().first) \\n                st.pop();\\n            \\n            // now cheking our condition nums[i] < nums[k] < nums[j] that is there pattern avaliable or not\\n            if((!st.empty()) && (st.top().second < nums[i]) && (nums[i] < st.top().first)) \\n                return true;\\n            \\n            // after each iteration just pushing the values with mn into our stack\\n            st.push({nums[i],mn});\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        // we wre going to use stack here for solving this problem\\n        // basically we need 3 values right ? and all that threes are follwing a order\\n        // so just need to find the 3 values \\n        // in stack we are going to save previous value and the whole stack min value \\n        // and we will compare these values with the current value according to the need of question\\n        // means if our current value is between betweeen the previos and min then return true else false\\n        \\n        // creating the stack\\n        stack<pair<int,int>> st;           // (previos,min)\\n        int mn = INT_MAX;                  // it will storing the mn value\\n        \\n        // iterating over the whole given array\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // just finding the min value if our stack is not empty\\n            if(!st.empty())\\n                mn = min(mn, st.top().first);\\n            \\n            // just popping all the greater value from the current \\n            // because we need mid value between the previous and min\\n            while(!st.empty() && nums[i]>st.top().first) \\n                st.pop();\\n            \\n            // now cheking our condition nums[i] < nums[k] < nums[j] that is there pattern avaliable or not\\n            if((!st.empty()) && (st.top().second < nums[i]) && (nums[i] < st.top().first)) \\n                return true;\\n            \\n            // after each iteration just pushing the values with mn into our stack\\n            st.push({nums[i],mn});\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016063,
                "title": "python-simple-effective",
                "content": "```\\n\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        num = float(\\'-inf\\')\\n        for n in nums[::-1]:\\n            if n < num:\\n                return True\\n            while stack and stack[-1] < n:\\n                num = stack.pop()\\n            stack.append(n)\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        num = float(\\'-inf\\')\\n        for n in nums[::-1]:\\n            if n < num:\\n                return True\\n            while stack and stack[-1] < n:\\n                num = stack.pop()\\n            stack.append(n)\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015991,
                "title": "c-o-n-solution-using-stack-with-line-by-line-explanation",
                "content": "The idea behind this approach is to carefully observe what is being asked in the question.\\n\\nIt is given for i < j < k\\nwe need to check if there exists arr[i] < arr[k] < arr[j]\\nNow for the k index element we need previous element greater than it and minimum element less than it\\nSo all we need to do is just maintain a stack with top element being the greatest and a minimum element\\nRest of the things are explained in the comments\\n\\n```\\nbool find132pattern(vector<int>& nums) {\\n        stack<pair<int , int>> st; //we make a stack to store elements in monotonic decreasing order and also store minimum value\\n        int currMin = nums[0]; // to store the min element \\n        for(int i=1;i<nums.size();i++) // traversing the given vector from index 1 as index 0 is already concidered in currMin \\n        {\\n            while(!st.empty() && nums[i]>=st.top().first) // keep removing all greater and equal elements \\n                st.pop();\\n            if(!st.empty() && nums[i]>st.top().second) // and if the stack still non-empty this means that our current element is less \\n\\t\\t\\t//than the top of the stack , So now we check if this element is greater than the minimum value in the stack\\n                return true; // if condition satisfies return true\\n            st.push({nums[i],currMin}); // push current element and previous minimum\\n            currMin = min(currMin,nums[i]); // update the minimum element\\n        }\\n        return false; // If the condition never became true it means we shall return false\\n    }\\n```\\n\\nIf you liked the explanation please upvote",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nbool find132pattern(vector<int>& nums) {\\n        stack<pair<int , int>> st; //we make a stack to store elements in monotonic decreasing order and also store minimum value\\n        int currMin = nums[0]; // to store the min element \\n        for(int i=1;i<nums.size();i++) // traversing the given vector from index 1 as index 0 is already concidered in currMin \\n        {\\n            while(!st.empty() && nums[i]>=st.top().first) // keep removing all greater and equal elements \\n                st.pop();\\n            if(!st.empty() && nums[i]>st.top().second) // and if the stack still non-empty this means that our current element is less \\n\\t\\t\\t//than the top of the stack , So now we check if this element is greater than the minimum value in the stack\\n                return true; // if condition satisfies return true\\n            st.push({nums[i],currMin}); // push current element and previous minimum\\n            currMin = min(currMin,nums[i]); // update the minimum element\\n        }\\n        return false; // If the condition never became true it means we shall return false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1505735,
                "title": "easy-c-code-using-stack",
                "content": "```\\nclass Solution {\\n    public:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if (n < 3) \\n            return false;\\n        \\n        int minn[n];\\n        minn[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            minn[i] = min(nums[i], minn[i - 1]);\\n        \\n        stack<int> s;\\n        for (int j = n - 1; j >= 0; j--) \\n        {\\n            while (!s.empty() && s.top() < nums[j]) \\n            {\\n                if (s.top() > minn[j])\\n                    return true;\\n                s.pop();\\n            }\\n            s.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if (n < 3) \\n            return false;\\n        \\n        int minn[n];\\n        minn[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n            minn[i] = min(nums[i], minn[i - 1]);\\n        \\n        stack<int> s;\\n        for (int j = n - 1; j >= 0; j--) \\n        {\\n            while (!s.empty() && s.top() < nums[j]) \\n            {\\n                if (s.top() > minn[j])\\n                    return true;\\n                s.pop();\\n            }\\n            s.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418970,
                "title": "c-solution-using-ordered-set-and-binary-search-time-o-nlogn",
                "content": "Left min array is used to find whether an element to the left of nums[i] that is lesser than nums[i] exists and we use binary search to find whether an element that is greater than left_min[i] exists on the right side of nums[i]. We also check whether that element is lesser than nums[i].\\nTime Complexity : O(nlogn) Space Complexity : O(n)\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return false;\\n        set<int> st;\\n        vector<int> left_min(n+1);\\n        left_min[0] = nums[0];\\n            \\n        for(int i = 1 ; i < n ; ++i )\\n            left_min[i] = min(left_min[i-1] , nums[i]);\\n        \\n        st.insert(nums[n-1]);\\n        for(int i = n - 2 ; i >= 1 ; --i)\\n        {\\n            int mn = left_min[i-1];\\n            if(nums[i] > mn)\\n            {\\n                auto it = st.upper_bound(mn);\\n                if(it != st.end())\\n                {\\n                    if(*it < nums[i])\\n                        return true;\\n                }\\n            }\\n            st.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return false;\\n        set<int> st;\\n        vector<int> left_min(n+1);\\n        left_min[0] = nums[0];\\n            \\n        for(int i = 1 ; i < n ; ++i )\\n            left_min[i] = min(left_min[i-1] , nums[i]);\\n        \\n        st.insert(nums[n-1]);\\n        for(int i = n - 2 ; i >= 1 ; --i)\\n        {\\n            int mn = left_min[i-1];\\n            if(nums[i] > mn)\\n            {\\n                auto it = st.upper_bound(mn);\\n                if(it != st.end())\\n                {\\n                    if(*it < nums[i])\\n                        return true;\\n                }\\n            }\\n            st.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215922,
                "title": "easy-to-understand-java-code",
                "content": "This problem is based on next greater element so if you have done next greater element , code is self explanatory \\n\\nMETHOD 1 : \\n\\n```\\n\\n// i<j<k\\n//nums[i]<nums[k]<nums[j]\\n// TC : O(N)  SC : O(N)\\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n         int numsk = Integer.MIN_VALUE;\\n         Stack<Integer> st = new Stack();\\n         for(int idx = nums.length-1;idx>=0;idx--){\\n             if(nums[idx]<numsk) return true;  // nums[i] < nums[k] , and nums[j] (potential) was chosen in previous iteration so given condition reached \\n              while(!st.isEmpty()&&nums[idx]>st.peek()){//nums[idx] = nums[j] (potential) \\n                 numsk = st.pop(); // always bigger than previous numsk \\n             }\\n             st.push(nums[idx]);\\n         }\\n        return false;\\n    }\\n}\\n```\\n\\nEDIT : another easy to understand implementation with stack : \\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min[] = new int[nums.length];\\n        min[0] = nums[0];\\n        for(int i =1;i<nums.length;i++) min[i] = Math.min(min[i-1],nums[i]); // maintain minimum so far \\n        Stack<Integer> st = new Stack();\\n        for(int j = nums.length-1;j>=0;j--){\\n            while(!st.isEmpty()&&st.peek()<=min[j]) st.pop(); // st.peek() --> nums[k] , min[j] -->  possible nums[i] which should be smaller than st.peek();\\n            if(!st.isEmpty()&&st.peek()<nums[j]){ // if stack is not empty and we have exited the while loop above then that means nums[i] < nums [k] so check if nums[k] < nums[j] if yes return true \\n                return true;\\n            }\\n            st.push(nums[j]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nMETHOD 2 : \\n\\n```\\n// same concept as previous solution but use nums[] as stack\\n// TC : O(N) SC : O(1) \\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n         int numsk = Integer.MIN_VALUE;\\n         int stackIdx = nums.length;\\n         for(int idx = nums.length-1;idx>=0;idx--){\\n             if(nums[idx]<numsk) return true;\\n              while(stackIdx<nums.length&&nums[idx]>nums[stackIdx]){\\n                 numsk = nums[stackIdx];\\n                 stackIdx++;\\n             }\\n             stackIdx--;\\n             nums[stackIdx] = nums[idx];\\n         }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\n// i<j<k\\n//nums[i]<nums[k]<nums[j]\\n// TC : O(N)  SC : O(N)\\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n         int numsk = Integer.MIN_VALUE;\\n         Stack<Integer> st = new Stack();\\n         for(int idx = nums.length-1;idx>=0;idx--){\\n             if(nums[idx]<numsk) return true;  // nums[i] < nums[k] , and nums[j] (potential) was chosen in previous iteration so given condition reached \\n              while(!st.isEmpty()&&nums[idx]>st.peek()){//nums[idx] = nums[j] (potential) \\n                 numsk = st.pop(); // always bigger than previous numsk \\n             }\\n             st.push(nums[idx]);\\n         }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min[] = new int[nums.length];\\n        min[0] = nums[0];\\n        for(int i =1;i<nums.length;i++) min[i] = Math.min(min[i-1],nums[i]); // maintain minimum so far \\n        Stack<Integer> st = new Stack();\\n        for(int j = nums.length-1;j>=0;j--){\\n            while(!st.isEmpty()&&st.peek()<=min[j]) st.pop(); // st.peek() --> nums[k] , min[j] -->  possible nums[i] which should be smaller than st.peek();\\n            if(!st.isEmpty()&&st.peek()<nums[j]){ // if stack is not empty and we have exited the while loop above then that means nums[i] < nums [k] so check if nums[k] < nums[j] if yes return true \\n                return true;\\n            }\\n            st.push(nums[j]);\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n// same concept as previous solution but use nums[] as stack\\n// TC : O(N) SC : O(1) \\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n         int numsk = Integer.MIN_VALUE;\\n         int stackIdx = nums.length;\\n         for(int idx = nums.length-1;idx>=0;idx--){\\n             if(nums[idx]<numsk) return true;\\n              while(stackIdx<nums.length&&nums[idx]>nums[stackIdx]){\\n                 numsk = nums[stackIdx];\\n                 stackIdx++;\\n             }\\n             stackIdx--;\\n             nums[stackIdx] = nums[idx];\\n         }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016132,
                "title": "c-solve-using-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        //storing previous value and mini value available in the stack i.e. {nums[j], nums[i]}\\n        stack<pair<int, int>> st;\\n        int mini = INT_MAX; //store minimum value \\n        \\n        //iterate over nums array\\n        for(int k=0; k<nums.size(); k++)\\n        {\\n            //if stack is not empty then we find mini value present in the stack\\n            if(!st.empty())\\n                mini = min(mini, st.top().first);\\n            \\n            //till nums[k] is greater than top element of stack i.e. nums[j], we pop the element\\n            while(!st.empty() && nums[k]>st.top().first) \\n                st.pop();\\n            \\n            //we check the conditon nums[i]<nums[k]<nums[j] if it exists return true\\n            if(!st.empty())\\n            {\\n                //if top mini value is less than nums[k] and nums[k] is less than top value of stack, returns true\\n                if((st.top().second < nums[k]) && (nums[k] < st.top().first)) return true;\\n            }\\n            \\n            //store current value and minimum value in the stack\\n            st.push({nums[k], mini});\\n        }\\n        //if pattern not exists return false;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        //storing previous value and mini value available in the stack i.e. {nums[j], nums[i]}\\n        stack<pair<int, int>> st;\\n        int mini = INT_MAX; //store minimum value \\n        \\n        //iterate over nums array\\n        for(int k=0; k<nums.size(); k++)\\n        {\\n            //if stack is not empty then we find mini value present in the stack\\n            if(!st.empty())\\n                mini = min(mini, st.top().first);\\n            \\n            //till nums[k] is greater than top element of stack i.e. nums[j], we pop the element\\n            while(!st.empty() && nums[k]>st.top().first) \\n                st.pop();\\n            \\n            //we check the conditon nums[i]<nums[k]<nums[j] if it exists return true\\n            if(!st.empty())\\n            {\\n                //if top mini value is less than nums[k] and nums[k] is less than top value of stack, returns true\\n                if((st.top().second < nums[k]) && (nums[k] < st.top().first)) return true;\\n            }\\n            \\n            //store current value and minimum value in the stack\\n            st.push({nums[k], mini});\\n        }\\n        //if pattern not exists return false;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015560,
                "title": "python3-monotonic-stack-with-detailed-explanation-time-o-n-space-o-n",
                "content": "\\n        s3 = float(\\'-inf\\')\\n        s3_candidates = []\\n        \\n        for i in range(len(nums) - 1, -1, -1):\\n            if nums[i] < s3:\\n                return True\\n            # When s3 is not -inf, meaning we have a valid s2, s3 pair. We first let nums[i]\\n            # act as s1, the smallest number among the three. If nums[i] is smaller than s3, \\n            # we find a 132 pattern and return True.\\n            \\n            while s3_candidates and nums[i] > s3_candidates[-1]:\\n                s3 = s3_candidates.pop()\\n                # Else, we assume that nums[i] now is s2 for the next iteraton. If numbers \\n                # in s3_candidates is smaller than nums[i], we find a valid s2, s3 pair.\\n            s3_candidates.append(nums[i])\\n            # Additionally, this while loop removes all numbers in stack that smaller than \\n            # nums[i], then push nums[i] into the stack, making sure that the stack keeps a \\n            # deceasing order. Therefore, the last popped num from this stack will always be \\n            # the maximun s3 and will not miss possible s1.\\n        return False",
                "solutionTags": [],
                "code": "\\n        s3 = float(\\'-inf\\')\\n        s3_candidates = []\\n        \\n        for i in range(len(nums) - 1, -1, -1):\\n            if nums[i] < s3:\\n                return True\\n            # When s3 is not -inf, meaning we have a valid s2, s3 pair. We first let nums[i]\\n            # act as s1, the smallest number among the three. If nums[i] is smaller than s3, \\n            # we find a 132 pattern and return True.\\n            \\n            while s3_candidates and nums[i] > s3_candidates[-1]:\\n                s3 = s3_candidates.pop()\\n                # Else, we assume that nums[i] now is s2 for the next iteraton. If numbers \\n                # in s3_candidates is smaller than nums[i], we find a valid s2, s3 pair.\\n            s3_candidates.append(nums[i])\\n            # Additionally, this while loop removes all numbers in stack that smaller than \\n            # nums[i], then push nums[i] into the stack, making sure that the stack keeps a \\n            # deceasing order. Therefore, the last popped num from this stack will always be \\n            # the maximun s3 and will not miss possible s1.\\n        return False",
                "codeTag": "Unknown"
            },
            {
                "id": 2015405,
                "title": "c-set-map-short-solution-o-n-ufff-finally-did-it-feeling",
                "content": "Hllo there , so in this we are making 3 data stores :-\\n**1. SET** :-  to store the distinct values  from left to the point where we are currently there\\n**2. MAP** :- to simply store the count of every number \\n**3. MINV** :- to simply store the minimum   number  from the point where we are from starting (i.e. on the left)\\n**UPPER BOUND function is a gift to all of us as it simply returns the just upper value in the given set** .\\nWhile traversing the array we see that if the just above value of the minv in the right hand side is smaller than current value or not : if yes then return true else move to next  and remove the current value of its count is 0 . *(read it again)* \\nFOR EX :- \\n                                       TEST CASE :- 3, 5, 0, 3, 4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   i=1 \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ->we are at 5; minv =3 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ->just above value =4 ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   ->4<5 return true ;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   CASE CLOSED :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        set<int> s;\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            s.insert(nums[i]);\\n            m[nums[i]]++;\\n        }\\n        int minv=nums[0];\\n        m[nums[0]]--;\\n        if(m[nums[0]]==0)\\n        s.erase(minv);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s.upper_bound(minv)!=s.end() && nums[i]>*(s.upper_bound(minv)) && *(s.upper_bound(minv))!=minv)\\n            {\\n                return true;\\n            }\\n             m[nums[i]]--;\\n             if(m[nums[i]]==0)\\n            s.erase(nums[i]);\\n            \\n            if(nums[i]<minv)\\n            {\\n                minv=nums[i];\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\nP.S. :- Did it in 7 submission xd (reason for posting the soln)\\n(Pls upvote kabhi kabhi to soln dalta hun :) )",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        set<int> s;\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            s.insert(nums[i]);\\n            m[nums[i]]++;\\n        }\\n        int minv=nums[0];\\n        m[nums[0]]--;\\n        if(m[nums[0]]==0)\\n        s.erase(minv);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(s.upper_bound(minv)!=s.end() && nums[i]>*(s.upper_bound(minv)) && *(s.upper_bound(minv))!=minv)\\n            {\\n                return true;\\n            }\\n             m[nums[i]]--;\\n             if(m[nums[i]]==0)\\n            s.erase(nums[i]);\\n            \\n            if(nums[i]<minv)\\n            {\\n                minv=nums[i];\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982091,
                "title": "132-pattern-problem",
                "content": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int  n=nums.size();\\n        \\n        int mx=INT_MIN,mn=INT_MAX,mxi,mni;\\n        \\n        int arrmin[n] ;\\n        \\n        stack<int>st;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<mn)\\n            {\\n                arrmin[i]=nums[i];\\n                mn=nums[i];\\n            }\\n            else\\n            {\\n                arrmin[i]=mn;\\n            }\\n            \\n            \\n            \\n        }\\n        \\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(arrmin[i]<nums[i])\\n            {\\n                \\n                  while(!(st.empty())  &&  st.top()<=arrmin[i] )\\n                {\\n                    \\n                    st.pop();\\n                    \\n                    \\n                }\\n                   \\n                \\n                \\n                 if(!(st.empty()) && st.top()>arrmin[i] && st.top()<nums[i])\\n                    {\\n                        return true;\\n                    }\\n                   \\n                \\n                \\n              \\n                \\n                  st.push(nums[i]);\\n    \\n            }\\n            \\n      }\\n        return false;\\n    }\\n};\\n\\n\\n\\n**please upvote.....................................................** ---------> it is 100% free for you.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int  n=nums.size();\\n        \\n        int mx=INT_MIN,mn=INT_MAX,mxi,mni;\\n        \\n        int arrmin[n] ;\\n        \\n        stack<int>st;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<mn)\\n            {\\n                arrmin[i]=nums[i];\\n                mn=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1849910,
                "title": "c-simple-code-explained-tc-o-n-sc-o-n",
                "content": "##### Upvote if it helps\\u2B06\\uFE0F\\n```\\nbool find132pattern(vector<int>& nums) {\\n        int secondmax = -1e9 , n = nums.size();\\n\\t\\tstack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() and nums[i] > s.top()){\\n                secondmax = max(secondmax,s.top());\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n            if(nums[i] < secondmax and s.empty() == false) return true; \\n            // stack is not empty means we have highest\\n            // element in our stack basically we have 3 in 132 pattern \\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "##### Upvote if it helps\\u2B06\\uFE0F\\n```\\nbool find132pattern(vector<int>& nums) {\\n        int secondmax = -1e9 , n = nums.size();\\n\\t\\tstack<int> s;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            while(!s.empty() and nums[i] > s.top()){\\n                secondmax = max(secondmax,s.top());\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n            if(nums[i] < secondmax and s.empty() == false) return true; \\n            // stack is not empty means we have highest\\n            // element in our stack basically we have 3 in 132 pattern \\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1322785,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> minArray(n);\\n        \\n        minArray[0]=nums[0];\\n        for(int i=1;i<n;++i){\\n            minArray[i]=min(minArray[i-1],nums[i]);\\n        }\\n        \\n        stack<int> stk;\\n        for(int i=n-1;i>=0;--i){\\n            if(nums[i]>minArray[i]){\\n                while(!stk.empty() && stk.top()<=minArray[i]) stk.pop();\\n                if(!stk.empty() && stk.top()<nums[i]) return true;\\n                stk.push(nums[i]);\\n            } \\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> minArray(n);\\n        \\n        minArray[0]=nums[0];\\n        for(int i=1;i<n;++i){\\n            minArray[i]=min(minArray[i-1],nums[i]);\\n        }\\n        \\n        stack<int> stk;\\n        for(int i=n-1;i>=0;--i){\\n            if(nums[i]>minArray[i]){\\n                while(!stk.empty() && stk.top()<=minArray[i]) stk.pop();\\n                if(!stk.empty() && stk.top()<nums[i]) return true;\\n                stk.push(nums[i]);\\n            } \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296419,
                "title": "easy-understanding-solution-with-comments-python-stack",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        mi = [nums[0]]\\n        \\n        n=len(nums)\\n        \\n        # making a min stack which store the minimum element till the current index from left\\n        for j in range(1,n):\\n            mi.append( min(mi[-1],nums[j]) )\\n            \\n            \\n        stack=[]\\n        \\n        \\n        for j in range(n-1,-1,-1):\\n            \\n            # makeing stack for the nums[k]\\n            \\n            while stack and stack[-1]<=mi[j]:\\n                stack.pop()\\n            if len(stack)>0:\\n                if mi[j]<stack[-1]<nums[j]:\\n                    return True\\n            stack.append(nums[j])\\n        \\n        return False\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        mi = [nums[0]]\\n        \\n        n=len(nums)\\n        \\n        # making a min stack which store the minimum element till the current index from left\\n        for j in range(1,n):\\n            mi.append( min(mi[-1],nums[j]) )\\n            \\n            \\n        stack=[]\\n        \\n        \\n        for j in range(n-1,-1,-1):\\n            \\n            # makeing stack for the nums[k]\\n            \\n            while stack and stack[-1]<=mi[j]:\\n                stack.pop()\\n            if len(stack)>0:\\n                if mi[j]<stack[-1]<nums[j]:\\n                    return True\\n            stack.append(nums[j])\\n        \\n        return False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 907505,
                "title": "a-few-solutions",
                "content": "Since we are searching for `A[k]` which is in between `A[i]...A[j]` non-inclusive, we can simply track the minimum `A[j]` seen so far in place of `A[i]` to improve upon a naive brute-force search of all `i, j, k` candidates with runtime O(N<sup>3</sup>).  Thus, perform a linear scan of the input array `A` for each candidate index `j` and `k` while simultaneously tracking the minimum value seen so far as the `first` candidate at some arbitrary index `i`, ie. `A[i]`, such that `i < j < k`.  Return `true` if and only if we can find candidate indices `j` and `k` such that `first < A[k] < A[j]`.\\n\\n---\\n\\n**Runtime:** O(N<sup>2</sup>)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun find132pattern(A: IntArray): Boolean {\\n        var N = A.size\\n        var first = A[0]\\n        for (j in 1 until N) {\\n            first = Math.min(first, A[j])  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for (k in j + 1 until N)\\n                if (first < A[k] && A[k] < A[j])\\n                    return true\\n        }\\n        return false\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet find132pattern = A => {\\n    let N = A.length,\\n        first = A[0];\\n    for (let j = 1; j < N; ++j) {\\n        first = Math.min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n        for (let k = j + 1; k < N; ++k)\\n            if (first < A[k] && A[k] < A[j])\\n                return true;\\n    }\\n    return false;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def find132pattern(self, A: List[int]) -> bool:\\n        N = len(A)\\n        first = A[0]\\n        for j in range(1, N):\\n            first = min(first, A[j])  # \\u2B50\\uFE0F minimum A[i] seen so far\\n            for k in range(j + 1, N):\\n                if first < A[k] < A[j]:\\n                    return True\\n        return False\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn find132pattern(A: Vec<i32>) -> bool {\\n        let N = A.len();\\n        let mut first = A[0];\\n        for j in 1..N {\\n            first = min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for k in j + 1..N {\\n                if first < A[k] && A[k] < A[j] {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool find132pattern(VI& A) {\\n        int N = A.size(),\\n            first = A[0];\\n        for (auto j{ 1 }; j < N; ++j) {\\n            first = min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for (auto k{ j + 1 }; k < N; ++k)\\n                if (first < A[k] && A[k] < A[j])\\n                    return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun find132pattern(A: IntArray): Boolean {\\n        var N = A.size\\n        var first = A[0]\\n        for (j in 1 until N) {\\n            first = Math.min(first, A[j])  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for (k in j + 1 until N)\\n                if (first < A[k] && A[k] < A[j])\\n                    return true\\n        }\\n        return false\\n    }\\n}\\n```\n```\\nlet find132pattern = A => {\\n    let N = A.length,\\n        first = A[0];\\n    for (let j = 1; j < N; ++j) {\\n        first = Math.min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n        for (let k = j + 1; k < N; ++k)\\n            if (first < A[k] && A[k] < A[j])\\n                return true;\\n    }\\n    return false;\\n};\\n```\n```\\nclass Solution:\\n    def find132pattern(self, A: List[int]) -> bool:\\n        N = len(A)\\n        first = A[0]\\n        for j in range(1, N):\\n            first = min(first, A[j])  # \\u2B50\\uFE0F minimum A[i] seen so far\\n            for k in range(j + 1, N):\\n                if first < A[k] < A[j]:\\n                    return True\\n        return False\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn find132pattern(A: Vec<i32>) -> bool {\\n        let N = A.len();\\n        let mut first = A[0];\\n        for j in 1..N {\\n            first = min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for k in j + 1..N {\\n                if first < A[k] && A[k] < A[j] {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool find132pattern(VI& A) {\\n        int N = A.size(),\\n            first = A[0];\\n        for (auto j{ 1 }; j < N; ++j) {\\n            first = min(first, A[j]);  // \\u2B50\\uFE0F minimum A[i] seen so far\\n            for (auto k{ j + 1 }; k < N; ++k)\\n                if (first < A[k] && A[k] < A[j])\\n                    return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 554441,
                "title": "c-8-lines-o-n-stack-solution-with-explanation",
                "content": "```\\n    bool find132pattern(vector<int>& nums) { //O(n) Time & Space -> Stack\\n        if(nums.size() < 3) return false;\\n        stack<int> s3;\\n        int s2 = INT_MIN;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if(nums[i] < s2) return true;\\n            else while(!s3.empty() && nums[i]>s3.top()) {\\n                s2 = s3.top(), s3.pop(); \\n            }\\n            s3.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```\\nIdea : Move from right to left. For every upward moving slope from the end, s2 will be the 2nd highest element of that upward slope and s3 will ofcourse be the top most element of that slope. Thus, S2 gets updates from INT_MIN to its new value, we now know that 3>2 comination exists. Now we need to check if there exists a combination of 1<2. Since 2 is no more INT_MIN, we can easily check for 1<2 by checking if nums[i]<s2. Also, s3 is a stack to find the highest peak i.e s3 and make s2 as 2nd highest peak a.k.a next num after peak. \\n\\n\\nInspired from : https://leetcode.com/problems/132-pattern/discuss/94071/Single-pass-C%2B%2B-O(n)-space-and-time-solution-(8-lines)-with-detailed-explanation.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n    bool find132pattern(vector<int>& nums) { //O(n) Time & Space -> Stack\\n        if(nums.size() < 3) return false;\\n        stack<int> s3;\\n        int s2 = INT_MIN;\\n        for(int i=nums.size()-1; i>=0; i--) {\\n            if(nums[i] < s2) return true;\\n            else while(!s3.empty() && nums[i]>s3.top()) {\\n                s2 = s3.top(), s3.pop(); \\n            }\\n            s3.push(nums[i]);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2319644,
                "title": "clean-and-crisp-c-solution-with-explanation",
                "content": "**Step 1:** Let\\'s start by finding the nums[j] first, we know it\\'s the greatest among the other two elements.\\nWe can do that by maintaining the greater elements on the top of the stack. Such that stack\\'s top will be our nums[j].\\n**Step 2:** We\\'ll also keep track of the mininum element found so far that appeared before nums[j].\\nTo do that we\\'ll make a stack of pair, where the pair.first = nums[j] and pair.second = min element before j.\\n**Step 3:** Now let\\'s start looking for nums[k]\\nWe can do that easily because we know stack\\'s top(nums[j]) contains an element that\\'s bigger than nums[k]\\nNow, we only need to make sure that the nums[k] is also greater than any one element that came before nums[j], to find that, we\\'re already keeping track of the minimum element found so far before j.\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<pair<int, int>>st;\\n        int cur_min = nums[0];\\n        st.push({nums[0], cur_min});\\n\\n        for (int k = 1; k < nums.size(); ++k) {\\n//Step 1: We maintain a decreasing monotonic stack.\\n            while (!st.empty() && st.top().first <= nums[k]) st.pop();\\n//Step 3: Looking for nums[k].\\n            if (!st.empty() && nums[k] > st.top().second) return true;\\n//Step 2: Maintaining a minimum so far.\\n            st.push({nums[k], cur_min});\\n            cur_min = min(cur_min, nums[k]);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```\\n\\t\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<pair<int, int>>st;\\n        int cur_min = nums[0];\\n        st.push({nums[0], cur_min});\\n\\n        for (int k = 1; k < nums.size(); ++k) {\\n//Step 1: We maintain a decreasing monotonic stack.\\n            while (!st.empty() && st.top().first <= nums[k]) st.pop();\\n//Step 3: Looking for nums[k].\\n            if (!st.empty() && nums[k] > st.top().second) return true;\\n//Step 2: Maintaining a minimum so far.\\n            st.push({nums[k], cur_min});\\n            cur_min = min(cur_min, nums[k]);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016840,
                "title": "super-simple-c-solution-nlog-n-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        int n=nums.size(),mini=nums[0];\\n        \\n        unordered_map<int,int>h;\\n        set<int>st;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n            h[nums[i]]++;\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            h[nums[i]]--;\\n            if(h[nums[i]]==0)st.erase(nums[i]);\\n            auto it=st.lower_bound(nums[i]);\\n            \\n            if(it!=st.end() || it!=st.begin())it--;\\n            if(it!=st.end() && *it>mini && *it<nums[i])return true;\\n            mini=min(mini,nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) \\n    {\\n        int n=nums.size(),mini=nums[0];\\n        \\n        unordered_map<int,int>h;\\n        set<int>st;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            st.insert(nums[i]);\\n            h[nums[i]]++;\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            h[nums[i]]--;\\n            if(h[nums[i]]==0)st.erase(nums[i]);\\n            auto it=st.lower_bound(nums[i]);\\n            \\n            if(it!=st.end() || it!=st.begin())it--;\\n            if(it!=st.end() && *it>mini && *it<nums[i])return true;\\n            mini=min(mini,nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015550,
                "title": "c-solution-with-explanation",
                "content": "First, how we start to process this problem?\\n- nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].\\n\\nSo in comparation of value, may like 1 < 3 < 2\\nIf we start from first, we may need to remeber first and second to check is third between them.\\nIf we start from tail, after we confirm any is bigger than 2, then we only need to find another one before that index and lower than two.\\n\\nwe use a stack to save all nums we process, and due to first in last out, we can get the most close number easiler.\\nAs description above, middle value means the nums[j] in the problem, if we find a valid middle value, then we only need to find a value lower than that.(end rule)\\n\\nAnd do we need to update the middle value? yes, when another easiler pair of [num[j], nums[k]] exist, we should.\\nWhat does easiler pair means? We hope middle value(nums[k]) is as big as possiable, so we can find first(nums[i]) easiler -> only when a bigger nums[j], nums[k] can be bigger. \\n```\\n public bool Find132pattern(int[] nums)\\n{\\n\\tvar stack = new Stack<int>();\\n\\tvar middleValue = int.MinValue;\\n\\tfor(int i = nums.Length - 1; i >= 0; i--)\\n\\t{\\n\\t\\tif(middleValue > nums[i])\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\twhile(stack.Count > 0 && nums[i] > stack.Peek())\\n\\t\\t{\\n\\t\\t\\tmiddleValue = Math.Max(middleValue, stack.Pop());\\n\\t\\t}\\n\\n\\t\\tstack.Push(nums[i]);\\n\\t}\\n\\n\\treturn false;\\n}\\n```\\n\\n* this solution is refer from https://leetcode.com/problems/132-pattern/discuss/345066/C-increasing-stack , and add what I thought about this problem.",
                "solutionTags": [],
                "code": "```\\n public bool Find132pattern(int[] nums)\\n{\\n\\tvar stack = new Stack<int>();\\n\\tvar middleValue = int.MinValue;\\n\\tfor(int i = nums.Length - 1; i >= 0; i--)\\n\\t{\\n\\t\\tif(middleValue > nums[i])\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\twhile(stack.Count > 0 && nums[i] > stack.Peek())\\n\\t\\t{\\n\\t\\t\\tmiddleValue = Math.Max(middleValue, stack.Pop());\\n\\t\\t}\\n\\n\\t\\tstack.Push(nums[i]);\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015240,
                "title": "simple-c-solution-with-nlog-n-complexity",
                "content": "Idea: We will divide the condition i < j < k & nums[i] < nums[k] < nums[j] into two parts. \\n* Part one: j < k and nums[k] > nums[j]\\n* Part two: i < j and nums[i] < nums[j]\\n\\nFor part one, we\\'ll iterate the array from last to the first position. And for each i (i = n-1 to 0), we\\'ll store the maximum value less than nums[i] in the range (i +1 to n - 1).\\n\\nFor part two, we have to store the minimum values for each prefix of nums. To do this, we\\'ll iterate from the first position of the array to the last position and store the minimum for each prefix and we can solve the part two by nums[i-1] < nums[i] formula.\\n\\nTime Complexity: O(n log n)\\nSpace Complexity: O(n)\\n\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    int dp[200011];\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n<3) return false;\\n        \\n        dp[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i] = min(dp[i-1], nums[i]);\\n        }\\n        \\n        set<int>myset;\\n        myset.insert(nums[n-1]);\\n        for(int i=n-2;i>0;i--){\\n\\n            auto fs = myset.begin();\\n            auto ls = myset.end();\\n            ls--;\\n            if( (*fs) < nums[i] ){\\n                if( (*ls) < nums[i] ){\\n                    if(dp[i-1] < (*ls)){\\n                        return true;\\n                    }\\n                }\\n                else{\\n                    auto it = myset.lower_bound(nums[i]);\\n                    it--;\\n                    if(dp[i-1] < (*it)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            myset.insert(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[200011];\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        if(n<3) return false;\\n        \\n        dp[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i] = min(dp[i-1], nums[i]);\\n        }\\n        \\n        set<int>myset;\\n        myset.insert(nums[n-1]);\\n        for(int i=n-2;i>0;i--){\\n\\n            auto fs = myset.begin();\\n            auto ls = myset.end();\\n            ls--;\\n            if( (*fs) < nums[i] ){\\n                if( (*ls) < nums[i] ){\\n                    if(dp[i-1] < (*ls)){\\n                        return true;\\n                    }\\n                }\\n                else{\\n                    auto it = myset.lower_bound(nums[i]);\\n                    it--;\\n                    if(dp[i-1] < (*it)){\\n                        return true;\\n                    }\\n                }\\n            }\\n            \\n            myset.insert(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707505,
                "title": "c-easy",
                "content": "Approach: Using stack\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int k = INT_MIN;\\n        \\n        stack<int> s;\\n        \\n        for(int i = nums.size() - 1; i >= 0; i--) {\\n            \\n            if(nums[i] < k) {\\n                return true;\\n            }\\n            \\n            while(s.empty() == false and nums[i] > s.top()) {\\n                k = s.top();\\n                s.pop();\\n            }\\n            \\n            s.push(nums[i]);\\n        }\\n        \\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int k = INT_MIN;\\n        \\n        stack<int> s;\\n        \\n        for(int i = nums.size() - 1; i >= 0; i--) {\\n            \\n            if(nums[i] < k) {\\n                return true;\\n            }\\n            \\n            while(s.empty() == false and nums[i] > s.top()) {\\n                k = s.top();\\n                s.pop();\\n            }\\n            \\n            s.push(nums[i]);\\n        }\\n        \\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640069,
                "title": "python3-solution-100-faster",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        s2 = float(\\'-inf\\')\\n        for i in nums[::-1]:\\n            if i<s2: return True\\n            while stack and i>stack[-1]: \\n                s2 = stack.pop()\\n            stack.append(i)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        stack = []\\n        s2 = float(\\'-inf\\')\\n        for i in nums[::-1]:\\n            if i<s2: return True\\n            while stack and i>stack[-1]: \\n                s2 = stack.pop()\\n            stack.append(i)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625924,
                "title": "c-456-132-pattern",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int prev = INT_MIN; \\n        stack<int> stk; \\n        for (int i = nums.size()-1; i >= 0; --i) {\\n            if (nums[i] < prev) return true; \\n            while (stk.size() && stk.top() < nums[i]) {\\n                prev = max(prev, stk.top()); \\n                stk.pop(); \\n            }\\n            stk.push(nums[i]); \\n        }\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int prev = INT_MIN; \\n        stack<int> stk; \\n        for (int i = nums.size()-1; i >= 0; --i) {\\n            if (nums[i] < prev) return true; \\n            while (stk.size() && stk.top() < nums[i]) {\\n                prev = max(prev, stk.top()); \\n                stk.pop(); \\n            }\\n            stk.push(nums[i]); \\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392016,
                "title": "best-beginner-9-lines-approx-fully-explained-solution-only-for-me",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<3) return false; // atleast 3 nums reqd\\n        \\n        vector<int>preMin(n,INT_MAX); // track min value in range 0 to i-1\\n        for(int i=1;i<n;i++)\\n            preMin[i] = min(preMin[i-1],nums[i-1]);// store prefix min values\\n        \\n        stack<int>stk;\\n        \\n        for(int i=n-1;i>=0;i--){// Loop through end to start to store the next greater number\\n            while(!stk.empty() && stk.top()<=preMin[i]) // as we are finding next greater number than preMin[i], pop numbers from stack which are less or equal to preMin[i]\\n                stk.pop();\\n            \\n            if(!stk.empty() && stk.top()< nums[i]) return true;// if stack.top < nums[i] then it is a 132 pattern as stack.top > preMin[i] therefore there exists a num in nums[i] which is smaller than both nums[i] and stk.top()\\n            \\n            stk.push(nums[i]);\\n        }\\n        return false;//if nothing is found\\n    }\\n};\\n//Regarding Time Complexity, we are iterating every element twice, once during findind premin array and second during the main loop, therefore overall O(N)\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<3) return false; // atleast 3 nums reqd\\n        \\n        vector<int>preMin(n,INT_MAX); // track min value in range 0 to i-1\\n        for(int i=1;i<n;i++)\\n            preMin[i] = min(preMin[i-1],nums[i-1]);// store prefix min values\\n        \\n        stack<int>stk;\\n        \\n        for(int i=n-1;i>=0;i--){// Loop through end to start to store the next greater number\\n            while(!stk.empty() && stk.top()<=preMin[i]) // as we are finding next greater number than preMin[i], pop numbers from stack which are less or equal to preMin[i]\\n                stk.pop();\\n            \\n            if(!stk.empty() && stk.top()< nums[i]) return true;// if stack.top < nums[i] then it is a 132 pattern as stack.top > preMin[i] therefore there exists a num in nums[i] which is smaller than both nums[i] and stk.top()\\n            \\n            stk.push(nums[i]);\\n        }\\n        return false;//if nothing is found\\n    }\\n};\\n//Regarding Time Complexity, we are iterating every element twice, once during findind premin array and second during the main loop, therefore overall O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219878,
                "title": "java-easy-stack",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        int minPrefix[] = new int [arr.length];\\n        minPrefix[0] = arr[0];\\n       \\n       for(int i=1;i<arr.length;i++){\\n         minPrefix[i] = Math.min(minPrefix[i-1],arr[i]);\\n       }\\n      \\n       for(int i=arr.length-1;i>=0;i--){\\n         while(stack.size() > 0 && minPrefix[i]>=stack.peek()){\\n           stack.pop();\\n         }\\n         if(stack.size()>0 && stack.peek()<arr[i]) return true;\\n         stack.push(arr[i]);\\n       }\\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        int minPrefix[] = new int [arr.length];\\n        minPrefix[0] = arr[0];\\n       \\n       for(int i=1;i<arr.length;i++){\\n         minPrefix[i] = Math.min(minPrefix[i-1],arr[i]);\\n       }\\n      \\n       for(int i=arr.length-1;i>=0;i--){\\n         while(stack.size() > 0 && minPrefix[i]>=stack.peek()){\\n           stack.pop();\\n         }\\n         if(stack.size()>0 && stack.peek()<arr[i]) return true;\\n         stack.push(arr[i]);\\n       }\\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907488,
                "title": "java-approach-explained-o-n-2-greedy-choose-minimum-in-left-half",
                "content": "**Please upvote if helpful!!**\\n\\nIntuition : Fix a middle element j  i.e. (3 in 132 pattern) in the array. Then try to find the lowest value from start of array to \\nmiddle element - 1; we find the lowest so that we increase our range of finding 132 pattern. \\nif the lowest in left half found is less than middle element; search in middle + 1 to end of array element which lies inbetwen the the range of lowest and highest i.e. i and j as per the question. i.e. nums[i] < nums[k] < nums[j]\\n\\nEg: if middle element is\\n6 , lowest in the left of array is 1 , then we need to find the k element from middle element + 1 to end of array, choosing lowest\\nvalue in left half of middle element gives us more values to choose in the range of [1,6].\\n\\nPS: The stack solution; i have still not understood even after reading various posts. This approach seems intuitive to me.!! \\n\\n```\\npublic boolean find132patternBruteForceCustom(int[] nums) {\\n\\n        if (nums == null || nums.length < 3) return false;\\n\\n        for (int j = 1; j < nums.length; j++) {\\n            int numJ = nums[j];\\n\\n            int lowestInLeft = Integer.MAX_VALUE;\\n            for (int i = 0; i < j; i++) {\\n                lowestInLeft = Math.min(lowestInLeft, nums[i]);\\n            }\\n\\n            if (lowestInLeft < numJ) {\\n\\n                for (int k = j + 1; k < nums.length; k++) {\\n\\n                    if (nums[k] < numJ && lowestInLeft < nums[k]) {\\n                        return true;\\n                    }\\n\\n                }\\n\\n            }\\n\\n        }\\n        return false;\\n\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic boolean find132patternBruteForceCustom(int[] nums) {\\n\\n        if (nums == null || nums.length < 3) return false;\\n\\n        for (int j = 1; j < nums.length; j++) {\\n            int numJ = nums[j];\\n\\n            int lowestInLeft = Integer.MAX_VALUE;\\n            for (int i = 0; i < j; i++) {\\n                lowestInLeft = Math.min(lowestInLeft, nums[i]);\\n            }\\n\\n            if (lowestInLeft < numJ) {\\n\\n                for (int k = j + 1; k < nums.length; k++) {\\n\\n                    if (nums[k] < numJ && lowestInLeft < nums[k]) {\\n                        return true;\\n                    }\\n\\n                }\\n\\n            }\\n\\n        }\\n        return false;\\n\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907065,
                "title": "python3-intuitive-binary-search-nlog-n",
                "content": "Funny thing is, this code beat 97% in time\\n\\nthe idea is say we look at nums[j], \\nthen we need cur_min = min(nums[:j])\\nand tmp = sorted(nums[j+1:]).\\nthen we check position of  nums[j] and cur_min in tmp by\\nidx = bisect_left(tmp,nums[j])\\nidx_min = bisect_right(tmp,cur_min)\\nif(idx>idx_min), then we find 132 pattern\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        cur_min = nums[0]\\n        nums = nums[1:]\\n        tmp = sorted(nums)\\n        nums = deque(nums)\\n        while(tmp):\\n            t = nums.popleft()\\n            idx = bisect_left(tmp,t)\\n            del tmp[idx]\\n            idx_min = bisect_right(tmp,cur_min)\\n            if(idx>idx_min):\\n                return True\\n            cur_min = min(cur_min,t)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        cur_min = nums[0]\\n        nums = nums[1:]\\n        tmp = sorted(nums)\\n        nums = deque(nums)\\n        while(tmp):\\n            t = nums.popleft()\\n            idx = bisect_left(tmp,t)\\n            del tmp[idx]\\n            idx_min = bisect_right(tmp,cur_min)\\n            if(idx>idx_min):\\n                return True\\n            cur_min = min(cur_min,t)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835751,
                "title": "python3-solution",
                "content": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n        stack=[]\\n        k=float(\"-inf\")\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[i]<k:\\n                return True\\n            while stack and stack[-1] < nums[i]:\\n                k=stack.pop()\\n            stack.append(nums[i])\\n        return False",
                "solutionTags": [],
                "code": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n        stack=[]\\n        k=float(\"-inf\")\\n        for i in range(len(nums)-1,-1,-1):\\n            if nums[i]<k:\\n                return True\\n            while stack and stack[-1] < nums[i]:\\n                k=stack.pop()\\n            stack.append(nums[i])\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 575712,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        stack<int>stk;\\n        int prev = INT_MIN;\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            if (nums[i] < prev)\\n                return true;\\n            while (!stk.empty() && nums[i] > stk.top()) {\\n                prev = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        stack<int>stk;\\n        int prev = INT_MIN;\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            if (nums[i] < prev)\\n                return true;\\n            while (!stk.empty() && nums[i] > stk.top()) {\\n                prev = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497377,
                "title": "using-stack-o-n-with-explaination",
                "content": "Suppose we have `a`,`b`,`c` and we want to ensure `a < b > c` and `a < c` .\\nThe idea is to keep on checking `a < c` while (we already know for some `b` ,`b > c`);\\n\\nSuppose `b` is the top most element in the stack.\\n\\nNow, for some index, `i` if  we find `nums[i] > stack.top()`, that element (`nums[i]`) is potential candidate for our b. so  `c` becomes `stack.top()` and we pop our stack . (This also mean that stack would contain elements in increasing order from top to bottom).\\n\\nNow traversing towards left, if we find some element in the array such that `nums[i] < c` we are done.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484439,
                "title": "stack-o-n-with-explanation",
                "content": "So after I read a lot of posts about the stack solution and still couldn\\'t understand any of them. \\nI decided to wirte a post on my own and break down every single detials of it. \\n\\nBefore you start reading it, I have to tell you this post is about the stack solution. There exists many other solutions in the solution tab of the problem. However, this post only focus on the stack solution. \\nAnd I am going to use c++ terms like `vector` or `stack<int> ` incase you don\\'t know what I am talking about. \\n\\nOk, let\\'s get started. \\n\\nSo after first observation of the problem one could come up with a O(n^3) solution right?\\nIf there exists a solution `ai, aj, ak` for which `aj > ak > ai`, then `aj` must exists in the nums vector, right?` 1 3 2` `aj `means the biggest one. \\n\\nSo we can go through this vector nums, for every `nums[i] `we check if it is a `aj`. We look to the left of `nums[i]` looking for the smallest one as `ai`, and we look into the right of `aj`looking for a number which is smaller than `aj` and bigger than `ai`, if we succeed in finding such numbers, then `nums[i]` is indeed a `aj`, otherwise, after we go through the entire vector and still could not find any, then there doesn\\'t exists such pattern. \\nThis is a O(n^2) solution. \\n\\nHow can we do better than that?\\n\\none little optimization is to go through the vector from left to right first and store the smallest item so far as a `min_vector`. For every` min_vector[i]` is the smallest number found from `nums[0] `to `nums[i]`\\n\\nSo we don\\'t need to look into the left any more, simply check the `min_vector[i] `to get the smallest number. This will take O(n) space, yet still haven\\'t changed the time complexicity. \\n\\n\\n**Just hear me out. The next bit is very important. \\n**\\n\\nWhen we look to the right and looking for the `ak`, if we search from the end to the start\\nlike `for(j= n-1;j>=0;j--)`every time we check if `nums[j]`is bigger than `min_vector[i]` if so, we print the `nums[j] `to the screen, we are going to see a very interesting pattern. The numbers printed to the screen are in descending order, if there exists a number that destroy the descending pattern, then these two numbers along with the `min_vector[i]` form a solution to the problem, regardless the state of `nums[i]`. \\n\\nPlease allow me to elaborate on that. For the `nums[i]` to become `aj`it must be bigger than `ai`. For `nums[j]`to become `ak`then it must also be bigger than `ai` other wise it is not a 132 pattern. So when we look to the right of `nums[i]`we only care about the ones bigger than `min_vector[i]`. For all the numbers to the right of `nums[i]`that are bigger than `min_vector[i]`we only need to check if these numbers are in ascending order. If they are not in ascending order, then there exists a solution. the function return true. till now, the time complexicity is still not changed. \\n\\nIf we now take a closer look at `nums[i] `and `nums[i+1]`for `nums[i]`we go through all the element on the right to see if there exists a solution by check if the sequence is in ascending order. and for nums[i+1]we went throught all the numbers on the right to see if they are in ascending order. For these two numbers, we don\\'t need to go through the numbers twice. If for` nums[i+1]` the numbers are in ascending order. we only need to check if from `nums[i] `to `nums[i+1]` is in ascending order and all the numbers on the right are automatically in ascending order. Becauese otherwise we have found a solution already and the function has returned. This operation takes O(1) time. \\n\\nHaHa, we now we have reduced the time complexicity from O(n^2) to O(n), right?\\n\\nNot exactly, there is small thing one is likely to overlook that is min_vector[i] min_vector[i+1]. \\nThe `min_vector` is in descending order from left to right. So, for all the number to the right of `nums[i]`that are greater than `min_vector[i]` are a little different from the numbers to the right of `nums[i+1]` that are greater than `min_vector[i+1]`. becase `min_vector[i]` is >= `min_vector[i+1]`\\n\\nThis poses problems, right? Here is where the stack comes in. When we were processing from end all the way to `nums[i+1]`we can push all the numbers to a stack. For this particular stack. The top one is the smallest, all the way to bottom, the numbers are getting bigger. When the `nums[j+1]`failed and we move to the `nums[j]`the stack is basically the same. we only need to pop out all the numbers that are smaller than `min_vector[i]`and check if `nums[i]` is smaller than top of the stack. If so, that means nums[i] is not what we are looking for, we push nums[i] to the stack assuming it is bigger than min_vector[i] then we continue to i-1 . If not, we have found a solution and the function return true. \\n\\nHence, this is how we can reduce the time complexicity from o(n^2) to O(n) with the use of stack. \\n\\nP.S. This is longer than I originally thought. Thank you so much for reading all of it. \\nIf you found any thing not very easy to understand please comment below, I will come back from time to time to update it. Thanks.",
                "solutionTags": [],
                "code": "So after I read a lot of posts about the stack solution and still couldn\\'t understand any of them. \\nI decided to wirte a post on my own and break down every single detials of it. \\n\\nBefore you start reading it, I have to tell you this post is about the stack solution. There exists many other solutions in the solution tab of the problem. However, this post only focus on the stack solution. \\nAnd I am going to use c++ terms like `vector` or `stack<int> ` incase you don\\'t know what I am talking about. \\n\\nOk, let\\'s get started. \\n\\nSo after first observation of the problem one could come up with a O(n^3) solution right?\\nIf there exists a solution `ai, aj, ak` for which `aj > ak > ai`, then `aj` must exists in the nums vector, right?` 1 3 2` `aj `means the biggest one. \\n\\nSo we can go through this vector nums, for every `nums[i] `we check if it is a `aj`. We look to the left of `nums[i]` looking for the smallest one as `ai`, and we look into the right of `aj`looking for a number which is smaller than `aj` and bigger than `ai`, if we succeed in finding such numbers, then `nums[i]` is indeed a `aj`, otherwise, after we go through the entire vector and still could not find any, then there doesn\\'t exists such pattern. \\nThis is a O(n^2) solution. \\n\\nHow can we do better than that?\\n\\none little optimization is to go through the vector from left to right first and store the smallest item so far as a `min_vector`. For every` min_vector[i]` is the smallest number found from `nums[0] `to `nums[i]`\\n\\nSo we don\\'t need to look into the left any more, simply check the `min_vector[i] `to get the smallest number. This will take O(n) space, yet still haven\\'t changed the time complexicity. \\n\\n\\n**Just hear me out. The next bit is very important. \\n**\\n\\nWhen we look to the right and looking for the `ak`, if we search from the end to the start\\nlike `for(j= n-1;j>=0;j--)`every time we check if `nums[j]`is bigger than `min_vector[i]` if so, we print the `nums[j] `to the screen, we are going to see a very interesting pattern. The numbers printed to the screen are in descending order, if there exists a number that destroy the descending pattern, then these two numbers along with the `min_vector[i]` form a solution to the problem, regardless the state of `nums[i]`. \\n\\nPlease allow me to elaborate on that. For the `nums[i]` to become `aj`it must be bigger than `ai`. For `nums[j]`to become `ak`then it must also be bigger than `ai` other wise it is not a 132 pattern. So when we look to the right of `nums[i]`we only care about the ones bigger than `min_vector[i]`. For all the numbers to the right of `nums[i]`that are bigger than `min_vector[i]`we only need to check if these numbers are in ascending order. If they are not in ascending order, then there exists a solution. the function return true. till now, the time complexicity is still not changed. \\n\\nIf we now take a closer look at `nums[i] `and `nums[i+1]`for `nums[i]`we go through all the element on the right to see if there exists a solution by check if the sequence is in ascending order. and for nums[i+1]we went throught all the numbers on the right to see if they are in ascending order. For these two numbers, we don\\'t need to go through the numbers twice. If for` nums[i+1]` the numbers are in ascending order. we only need to check if from `nums[i] `to `nums[i+1]` is in ascending order and all the numbers on the right are automatically in ascending order. Becauese otherwise we have found a solution already and the function has returned. This operation takes O(1) time. \\n\\nHaHa, we now we have reduced the time complexicity from O(n^2) to O(n), right?\\n\\nNot exactly, there is small thing one is likely to overlook that is min_vector[i] min_vector[i+1]. \\nThe `min_vector` is in descending order from left to right. So, for all the number to the right of `nums[i]`that are greater than `min_vector[i]` are a little different from the numbers to the right of `nums[i+1]` that are greater than `min_vector[i+1]`. becase `min_vector[i]` is >= `min_vector[i+1]`\\n\\nThis poses problems, right? Here is where the stack comes in. When we were processing from end all the way to `nums[i+1]`we can push all the numbers to a stack. For this particular stack. The top one is the smallest, all the way to bottom, the numbers are getting bigger. When the `nums[j+1]`failed and we move to the `nums[j]`the stack is basically the same. we only need to pop out all the numbers that are smaller than `min_vector[i]`and check if `nums[i]` is smaller than top of the stack. If so, that means nums[i] is not what we are looking for, we push nums[i] to the stack assuming it is bigger than min_vector[i] then we continue to i-1 . If not, we have found a solution and the function return true. \\n\\nHence, this is how we can reduce the time complexicity from o(n^2) to O(n) with the use of stack. \\n\\nP.S. This is longer than I originally thought. Thank you so much for reading all of it. \\nIf you found any thing not very easy to understand please comment below, I will come back from time to time to update it. Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 345066,
                "title": "c-increasing-stack",
                "content": "```\\npublic class Solution {\\n    public bool Find132pattern(int[] nums) {\\n        var n = nums.Length;\\n\\n        var stack = new Stack<int>();\\n\\n        var middleValue = int.MinValue;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            var curNum = nums[i];\\n\\n            if (curNum < middleValue) return true;\\n            else {\\n                while (stack.Any() && curNum > stack.Peek()) {\\n                    middleValue = Math.Max(middleValue, stack.Pop());\\n                }\\n            }\\n\\n            stack.Push(curNum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool Find132pattern(int[] nums) {\\n        var n = nums.Length;\\n\\n        var stack = new Stack<int>();\\n\\n        var middleValue = int.MinValue;\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            var curNum = nums[i];\\n\\n            if (curNum < middleValue) return true;\\n            else {\\n                while (stack.Any() && curNum > stack.Peek()) {\\n                    middleValue = Math.Max(middleValue, stack.Pop());\\n                }\\n            }\\n\\n            stack.Push(curNum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 94107,
                "title": "o-n-logn-treemap-explanation",
                "content": "The idea is to try to fix the nums[i] as a maximum value. The next step is to find minimum from our prefix. Then try to find if there exists the value in suffix which is greater than minimum and less than nums[i]. To find that value fast we can use tree map to count each number's occurrences and use it's lower() function.\\n```\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if (nums.length<=2) return false;\\n        TreeMap<Integer, Integer> counts = getCounts(nums);\\n        decrease(counts, nums[0], -1);\\n        int min = nums[0];\\n        \\n        for (int i=1; i<nums.length; i++) {\\n            decrease(counts, nums[i], -1);\\n            Integer lower = counts.lowerKey(nums[i]);\\n            if (lower!=null && lower>min) return true;\\n            min = Math.min(min, nums[i]);\\n        }\\n        return false;\\n    }\\n    \\n    private void decrease(TreeMap<Integer, Integer> counts, int key, int adder) {\\n        if (counts.containsKey(key)) {\\n            counts.put(key, counts.get(key)+adder);\\n            if (counts.get(key)<=0) counts.remove(key);\\n        }\\n    }\\n    \\n    private TreeMap<Integer, Integer> getCounts(int nums[]) {\\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\\n        for (int val: nums) {\\n            counts.put(val, counts.getOrDefault(val,0) + 1);\\n        }\\n        return counts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if (nums.length<=2) return false;\\n        TreeMap<Integer, Integer> counts = getCounts(nums);\\n        decrease(counts, nums[0], -1);\\n        int min = nums[0];\\n        \\n        for (int i=1; i<nums.length; i++) {\\n            decrease(counts, nums[i], -1);\\n            Integer lower = counts.lowerKey(nums[i]);\\n            if (lower!=null && lower>min) return true;\\n            min = Math.min(min, nums[i]);\\n        }\\n        return false;\\n    }\\n    \\n    private void decrease(TreeMap<Integer, Integer> counts, int key, int adder) {\\n        if (counts.containsKey(key)) {\\n            counts.put(key, counts.get(key)+adder);\\n            if (counts.get(key)<=0) counts.remove(key);\\n        }\\n    }\\n    \\n    private TreeMap<Integer, Integer> getCounts(int nums[]) {\\n        TreeMap<Integer, Integer> counts = new TreeMap<>();\\n        for (int val: nums) {\\n            counts.put(val, counts.getOrDefault(val,0) + 1);\\n        }\\n        return counts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538634,
                "title": "456-132-pattern",
                "content": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n       int n = nums.size();\\n        stack<int>s;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(nums[i]<s3)\\n                return true;\\n            else\\n            {\\n                while(!s.empty() && nums[i]>s.top())\\n                {\\n                    s3 = s.top();\\n                    s.pop();\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n       int n = nums.size();\\n        stack<int>s;\\n        for(int i = n-1;i>=0;i--)\\n        {\\n            if(nums[i]<s3)\\n                return true;\\n            else\\n            {\\n                while(!s.empty() && nums[i]>s.top())\\n                {\\n                    s3 = s.top();\\n                    s.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3067815,
                "title": "java-c-100-solution-using-monotonic-stack-132-pattern",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int thirdElement=INT_MIN;\\n        \\n        for(int i = nums.size()-1;i>=0;--i)\\n        {\\n            if(thirdElement>nums[i])\\n                return true;\\n            while(!stk.empty() && stk.top()<nums[i])\\n            {\\n                thirdElement = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        int thirdElement = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] < thirdElement)\\n                return true;\\n            while(!st.isEmpty() && st.peek() < nums[i]) \\n                thirdElement = st.pop();\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> stk;\\n        int thirdElement=INT_MIN;\\n        \\n        for(int i = nums.size()-1;i>=0;--i)\\n        {\\n            if(thirdElement>nums[i])\\n                return true;\\n            while(!stk.empty() && stk.top()<nums[i])\\n            {\\n                thirdElement = stk.top();\\n                stk.pop();\\n            }\\n            stk.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        \\n        int thirdElement = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] < thirdElement)\\n                return true;\\n            while(!st.isEmpty() && st.peek() < nums[i]) \\n                thirdElement = st.pop();\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604990,
                "title": "simplest-fastest-quickest-java-solution-via-stack-all-himself-by-lord-noddy",
                "content": "```\\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int x=Integer.MIN_VALUE;\\n         int largest_num=0;\\n        Stack<Integer> s=new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--)\\n      {\\n            largest_num=nums[i];\\n            if(nums[i]<x)\\n                return true;\\n            while(!s.isEmpty() && nums[i]>s.peek())\\n            {\\n                 x=s.peek();\\n                largest_num=Math.max(largest_num,s.peek());\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int x=Integer.MIN_VALUE;\\n         int largest_num=0;\\n        Stack<Integer> s=new Stack<>();\\n        for(int i=nums.length-1;i>=0;i--)\\n      {\\n            largest_num=nums[i];\\n            if(nums[i]<x)\\n                return true;\\n            while(!s.isEmpty() && nums[i]>s.peek())\\n            {\\n                 x=s.peek();\\n                largest_num=Math.max(largest_num,s.peek());\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597677,
                "title": "c-stack-with-comments",
                "content": "\\nHere is my solution using stack and with comments!\\nIf any doubt ping me!\\n\\n\\n\\nAnd if you like it PLEASE UPVOTE!\\n\\n///\\nclass Solution {\\npublic:\\n\\n    bool find132pattern(vector<int>& nums) {\\n        vector<int> minimum(nums.size());  // to get the minimum value befor that value\\n        minimum[0] = nums[0];            \\n        for(int i = 1 ; i < nums.size() ; i++)\\n            minimum[i] = min(minimum[i-1],nums[i]);\\n        \\n        // Now after getting the minimum value at each index we\\'ll iterate from back side and push/ignore accordingly\\n        \\n        stack<int> st; //To have the potential answer i.e potential candidate for nums[k]\\n        bool flag = false;\\n        for(int j = nums.size() - 1 ; j >= 0 ; --j)\\n        {       \\n            while(st.size() > 0 && st.top() <= minimum[j]) // if the element of stack is smaller than minimum element i.e nums[i] < nums[k]\\n                st.pop();\\n            if(!st.empty() && st.top() < nums[j])  // if element of stack is smaller than nums[j] i.e nums[k] < nums[j] \\n            {\\n                flag = true;\\n                break; // as soon as we get the answer we\\'ll break and stop the further search\\n            }\\n            st.push(nums[j]);\\n        }\\n        return flag;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool find132pattern(vector<int>& nums) {\\n        vector<int> minimum(nums.size());  // to get the minimum value befor that value\\n        minimum[0] = nums[0];            \\n        for(int i = 1 ; i < nums.size() ; i++)\\n            minimum[i] = min(minimum[i-1],nums[i]);\\n        \\n        // Now after getting the minimum value at each index we\\'ll iterate from back side and push/ignore accordingly\\n        \\n        stack<int> st; //To have the potential answer i.e potential candidate for nums[k]\\n        bool flag = false;\\n        for(int j = nums.size() - 1 ; j >= 0 ; --j)\\n        {       \\n            while(st.size() > 0 && st.top() <= minimum[j]) // if the element of stack is smaller than minimum element i.e nums[i] < nums[k]\\n                st.pop();\\n            if(!st.empty() && st.top() < nums[j])  // if element of stack is smaller than nums[j] i.e nums[k] < nums[j] \\n            {\\n                flag = true;\\n                break; // as soon as we get the answer we\\'ll break and stop the further search\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2017677,
                "title": "solution-using-multiset-in-c-nlogn-complexity-209ms",
                "content": "So we have to find i , j , k such that    **(nums[i]<nums[j]>nums[k])     where i<j<k.**\\n\\nThe   approach is to  **fix i and j such that we could find a k which satisfies the above condition,**\\nto fix i and j the approach is  we will loop through the nums array  the current element of the array will be nums[j] now according to the condtion we need to find an element in the prefix of the nums array from current element which is smaller the current element.\\nfor eg - > nums = [ 1,2,3,4,6,5] and we are at 4 so our nums[j] is 4 now we need to find an element in [1,2,3] that is prefix of that array from current position which is smaller than 4.\\nto do this we will just maintan the smallest element till now.\\nso now our i and j are fixed we need to find k .\\nto do this we just put the suffix of nums fromt current position into a multiset and tried to find an element that is larger than nums[i] but smaller the nums[j] using upper bound on the multiset \\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int mn;\\n        int n = nums.size();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        multiset<int> ms(nums.begin() , nums.end());    \\n        mn = nums[0];\\n        ms.erase(ms.find(nums[0]));\\n        for(int i = 1; i+1 < n ; i++)\\n        {\\n            ms.erase(ms.find(nums[i]));\\n            auto  y = ms.upper_bound(mn);\\n            if(y == ms.end())\\n            {\\n                mn = min(mn , nums[i]);\\n                continue;\\n            }\\n            int z = *y;\\n            if(z>mn && z<nums[i])\\n            {\\n                return 1;\\n            }\\n            mn = min(mn , nums[i]);\\n        }\\n        return 0;\\n    }\\n};\\n```\\nI know  it is slower than the best approach that is using stack but this is just another approach that could run in the timelimit and give you an ac.\\n**Any changes or advice will great .\\nthanks ;}**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int mn;\\n        int n = nums.size();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        multiset<int> ms(nums.begin() , nums.end());    \\n        mn = nums[0];\\n        ms.erase(ms.find(nums[0]));\\n        for(int i = 1; i+1 < n ; i++)\\n        {\\n            ms.erase(ms.find(nums[i]));\\n            auto  y = ms.upper_bound(mn);\\n            if(y == ms.end())\\n            {\\n                mn = min(mn , nums[i]);\\n                continue;\\n            }\\n            int z = *y;\\n            if(z>mn && z<nums[i])\\n            {\\n                return 1;\\n            }\\n            mn = min(mn , nums[i]);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017175,
                "title": "all-three-approaches-o-n-3-o-n-2-o-n",
                "content": "Hello If you were able to understand from my explanation please do give a upvote.\\nLets start with the Brute force approach\\nHere we need to find the three subsequence in an array such that  i < j < k and nums[i] < nums[k] < nums[j]. So,  we goona use 3 pointers to find elements.\\nSo we will run three loops our first loop will start form i=0, second from j=i+1 and last loop from k=j+1 and all will run till n and If we goona check this condition nums[i] < nums[k] < nums[j] and if found return true;\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n      int n=nums.size();\\n      for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              for(int k=j+1;k<n;k++)\\n              {\\n                  if(nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n              }\\n          }\\n      }\\n        return false;\\n    }\\n};\\nSince we are running three loops. Hence time Complexity O(n^3) and ofcourse TLE :(\\n```\\n\\nNow we will try to optimize. Here will we choose and first element as first=nums[i] to keeptrack of the minimum element from left to right .We will run two loop First one from i=1 to n and second one from i+1 to n and check the condition first < nums[k] < nums[j] holds true return true else assign first=min(nums[i],first).\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       \\n        int temp=nums[0];\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                      if(nums[j]>temp && nums[j]<nums[i])\\n                          return true;\\n                }\\n                temp=min(temp,nums[i]);\\n            \\n              \\n        }\\n        return false;\\n    }\\n};\\nSince we are running two loops. Hence time Complexity O(n^2) and ofcourse TLE again :(\\n\\n```\\n\\nFinally we will now try to optimize to O(n).\\nNow as we notice we need the middle number as largest than both no and last number is less than largest but greater than the first. \\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack<int> s;\\n        int n=nums.size();\\n        int var2=INT_MIN;\\n        for(int i=n-1;i>=0;i--){\\n            if(var2>nums[i]) return true;\\n            while(!s.empty() && nums[i]>s.top()){\\n                var2=s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n      int n=nums.size();\\n      for(int i=0;i<n;i++){\\n          for(int j=i+1;j<n;j++){\\n              for(int k=j+1;k<n;k++)\\n              {\\n                  if(nums[i] < nums[k] && nums[k] < nums[j]) return true;\\n              }\\n          }\\n      }\\n        return false;\\n    }\\n};\\nSince we are running three loops. Hence time Complexity O(n^3) and ofcourse TLE :(\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n       \\n        int temp=nums[0];\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                      if(nums[j]>temp && nums[j]<nums[i])\\n                          return true;\\n                }\\n                temp=min(temp,nums[i]);\\n            \\n              \\n        }\\n        return false;\\n    }\\n};\\nSince we are running two loops. Hence time Complexity O(n^2) and ofcourse TLE again :(\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack<int> s;\\n        int n=nums.size();\\n        int var2=INT_MIN;\\n        for(int i=n-1;i>=0;i--){\\n            if(var2>nums[i]) return true;\\n            while(!s.empty() && nums[i]>s.top()){\\n                var2=s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016872,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        if( n < 3 ) return false;\\n        \\n        int mins[n];\\n        mins[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            mins[i] = min(mins[i-1], nums[i]);\\n        }\\n        \\n        stack<int> st;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            while( st.empty()==false && st.top() <= mins[i] ) st.pop();\\n\\n            if( st.empty()==false && st.top() < nums[i] ) return true;\\n\\n            st.push(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        if( n < 3 ) return false;\\n        \\n        int mins[n];\\n        mins[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            mins[i] = min(mins[i-1], nums[i]);\\n        }\\n        \\n        stack<int> st;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            while( st.empty()==false && st.top() <= mins[i] ) st.pop();\\n\\n            if( st.empty()==false && st.top() < nums[i] ) return true;\\n\\n            st.push(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016218,
                "title": "easiest-python-solution-with-stack",
                "content": "***Code with approach***\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n\\t\"\"\" Monotonic decreasing stack \"\"\"\\n        st=[] \\n\\t\\t\"\"\" Assume first element as minimum\"\"\"\\n        minn=nums[0]\\n        for i in nums[1:]:\\n\\t\\t\\t\"\"\" We try to maintain the highest value at the top of the stacksuch that it is greater than i too .\"\"\"\\n            while st and i>=st[-1][0]:\\n                st.pop()\\n\\t\\t\\t\"\"\" Below statement defines i>st[-1][1] i.e.,  we have founded a value (i) which is greater than st[-1][1]\\n\\t\\t\\t(minimum) and and smaller than st[-1][0] . Here in this below statement i acts as k (given in question) as it \\n\\t\\t\\tis greater than st[-1][1] and less than st[-1][0] . st[-1][1] acts as i(in question) and st[-1][0] acts as j(in \\n\\t\\t\\tquestion) as it has highest value among all.\"\"\"\\n            if st and i>st[-1][1]:\\n                return True\\n\\t\\t\\t\"\"\" Appending value and minimum value in stack. Here minn acts as i for the given question i.e., i<j<k \"\"\"\\n            st.append([i,minn])\\n\\t\\t\\t\"\"\" Updating minimum value \"\"\"\\n            minn=min(minn,i)\\n        return False\\n```\\n\\n***Full Code Implementation***\\n\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        st=[]\\n        minn=nums[0]\\n        for i in nums[1:]:\\n            while st and i>=st[-1][0]:\\n                st.pop()\\n            if st and i>st[-1][1]:\\n                return True\\n            st.append([i,minn])\\n            minn=min(minn,i)\\n        return False\\n```\\nIf you still have doubt just solve [3,5,0,3,4] test case with pen and paper. It makes easier you to visualise the implementation.\\n**Please Upvote if it helps.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n\\t\"\"\" Monotonic decreasing stack \"\"\"\\n        st=[] \\n\\t\\t\"\"\" Assume first element as minimum\"\"\"\\n        minn=nums[0]\\n        for i in nums[1:]:\\n\\t\\t\\t\"\"\" We try to maintain the highest value at the top of the stacksuch that it is greater than i too .\"\"\"\\n            while st and i>=st[-1][0]:\\n                st.pop()\\n\\t\\t\\t\"\"\" Below statement defines i>st[-1][1] i.e.,  we have founded a value (i) which is greater than st[-1][1]\\n\\t\\t\\t(minimum) and and smaller than st[-1][0] . Here in this below statement i acts as k (given in question) as it \\n\\t\\t\\tis greater than st[-1][1] and less than st[-1][0] . st[-1][1] acts as i(in question) and st[-1][0] acts as j(in \\n\\t\\t\\tquestion) as it has highest value among all.\"\"\"\\n            if st and i>st[-1][1]:\\n                return True\\n\\t\\t\\t\"\"\" Appending value and minimum value in stack. Here minn acts as i for the given question i.e., i<j<k \"\"\"\\n            st.append([i,minn])\\n\\t\\t\\t\"\"\" Updating minimum value \"\"\"\\n            minn=min(minn,i)\\n        return False\\n```\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        st=[]\\n        minn=nums[0]\\n        for i in nums[1:]:\\n            while st and i>=st[-1][0]:\\n                st.pop()\\n            if st and i>st[-1][1]:\\n                return True\\n            st.append([i,minn])\\n            minn=min(minn,i)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016038,
                "title": "c-100-34ms-o-n-optimized-monotonic-stack",
                "content": "From the core logic this is like any other monotonic stack based solution, but I have added two optimizations:\\n\\n  * Use a ```vector<>``` instead of ```stack<>``` so we can call ```reserve()``` on it, to avoid re-allocation. We could have used a something like that to use the stack interface: \\n``` \\n\\t\\tvector<pair<int, int>> st_c;\\n        st_c.reserve(size(nums) + 1);\\n        stack<pair<int, int>, vector<pair<int,int>>> st(std::move(st_c));\\n```\\n  * Insert a sentinel (dummy) value at bottom of the stack to avoid calls to ```empty()```.\\n\\n```\\n  bool find132pattern(vector<int>& nums) {\\n        if (size(nums) < 3) return false;\\n        \\n        int cur_min = numeric_limits<int>::max();\\n        vector<pair<int, int>> st;\\n        st.reserve(size(nums) + 1);  // avoid re-allocations\\n        st.push_back({cur_min, cur_min});  // dummy value, to avoid check for empty(st)\\n        for (int num : nums) {\\n            while (st.back().first <= num) st.pop_back();\\n            \\n            if (st.back().second < num) return true;\\n            \\n            st.push_back({num, cur_min});\\n            cur_min = min(cur_min, num);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```vector<>```\n```stack<>```\n```reserve()```\n``` \\n\\t\\tvector<pair<int, int>> st_c;\\n        st_c.reserve(size(nums) + 1);\\n        stack<pair<int, int>, vector<pair<int,int>>> st(std::move(st_c));\\n```\n```empty()```\n```\\n  bool find132pattern(vector<int>& nums) {\\n        if (size(nums) < 3) return false;\\n        \\n        int cur_min = numeric_limits<int>::max();\\n        vector<pair<int, int>> st;\\n        st.reserve(size(nums) + 1);  // avoid re-allocations\\n        st.push_back({cur_min, cur_min});  // dummy value, to avoid check for empty(st)\\n        for (int num : nums) {\\n            while (st.back().first <= num) st.pop_back();\\n            \\n            if (st.back().second < num) return true;\\n            \\n            st.push_back({num, cur_min});\\n            cur_min = min(cur_min, num);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015987,
                "title": "daily-leetcoding-cahllenge-easy-python-solution",
                "content": "\\n\\t def find132pattern(self, nums: List[int]) -> bool:\\n        stk = []\\n        m = nums[0]\\n\\n        for n in nums[1:]:\\n            while stk and n >= stk[-1][0]:\\n                stk.pop()\\n            \\n            if stk and n > stk[-1][1]:\\n                return True\\n            \\n            stk.append([n,m])\\n            m = min(m,n)\\n            \\n        return False\\n\\t\\t\\n\\t\\t #please up vote \\uD83E\\uDD17\\uD83E\\uDD17",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "\\n\\t def find132pattern(self, nums: List[int]) -> bool:\\n        stk = []\\n        m = nums[0]\\n\\n        for n in nums[1:]:\\n            while stk and n >= stk[-1][0]:\\n                stk.pop()\\n            \\n            if stk and n > stk[-1][1]:\\n                return True\\n            \\n            stk.append([n,m])\\n            m = min(m,n)\\n            \\n        return False\\n\\t\\t\\n\\t\\t #please up vote \\uD83E\\uDD17\\uD83E\\uDD17",
                "codeTag": "Python3"
            },
            {
                "id": 2015332,
                "title": "132-pattern-java-solution-full-explanation",
                "content": "**Second approach is the accepted solution...**\\nApproach 1: Brute Force. Just iterate through the array and generate all triplets of i<j<k and check for the condition.\\n```\\nclass Solution \\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            for(int j=i+1;j<nums.length-1;j++)\\n            {\\n                for(int k=j+1;k<nums.length;k++)\\n                {\\n                    if(nums[i]<nums[k] && nums[i]<nums[j] && nums[k]<nums[j])\\n                    {\\n                        return true;   \\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n**Approach 2: Using Stack**\\n```\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        if(nums == null || nums.length < 3) \\n            return false;\\n        \\n        \\n         int num = Integer.MIN_VALUE;\\n         Stack<Integer> stk = new Stack();\\n         for(int i = nums.length-1;i>=0;i--)\\n         {\\n             if(nums[i]<num) \\n                 return true;  // nums[i] < nums[k] , and nums[j] was chosen in previous iteration so given condition reached \\n              while(!stk.isEmpty() && nums[i]>stk.peek())\\n              {//nums[i] = nums[j]\\n                 num = stk.pop(); // always bigger than previous num\\n             }\\n             stk.push(nums[i]);\\n         }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            for(int j=i+1;j<nums.length-1;j++)\\n            {\\n                for(int k=j+1;k<nums.length;k++)\\n                {\\n                    if(nums[i]<nums[k] && nums[i]<nums[j] && nums[k]<nums[j])\\n                    {\\n                        return true;   \\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        if(nums == null || nums.length < 3) \\n            return false;\\n        \\n        \\n         int num = Integer.MIN_VALUE;\\n         Stack<Integer> stk = new Stack();\\n         for(int i = nums.length-1;i>=0;i--)\\n         {\\n             if(nums[i]<num) \\n                 return true;  // nums[i] < nums[k] , and nums[j] was chosen in previous iteration so given condition reached \\n              while(!stk.isEmpty() && nums[i]>stk.peek())\\n              {//nums[i] = nums[j]\\n                 num = stk.pop(); // always bigger than previous num\\n             }\\n             stk.push(nums[i]);\\n         }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015200,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& v) {\\n        \\n        multiset<int> s,ss(v.begin(),v.end());\\n        for(int i=0; i<v.size(); ++i)\\n        {\\n            ss.erase(ss.find(v[i]));\\n            auto ix = s.upper_bound(v[i]-1);\\n            auto ixx = ss.upper_bound(v[i]-1);\\n            if(ix!=s.begin() && ixx!=ss.begin()){\\n                ixx--;\\n                if(*s.begin()<*ixx)\\n                    return 1;\\n            }\\n            \\n            s.insert(v[i]);\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& v) {\\n        \\n        multiset<int> s,ss(v.begin(),v.end());\\n        for(int i=0; i<v.size(); ++i)\\n        {\\n            ss.erase(ss.find(v[i]));\\n            auto ix = s.upper_bound(v[i]-1);\\n            auto ixx = ss.upper_bound(v[i]-1);\\n            if(ix!=s.begin() && ixx!=ss.begin()){\\n                ixx--;\\n                if(*s.begin()<*ixx)\\n                    return 1;\\n            }\\n            \\n            s.insert(v[i]);\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015175,
                "title": "c-hashmap-easy-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2) return false;\\n        \\n        int mn = nums[0];\\n        \\n        map<int, int> m;\\n\\t\\t//i starts from 2 as 0 given to mn(i.e nums[i]) and 1 will be given to nums[j] (as prescribed in question)\\n        for(int i=2; i<n; i++) m[nums[i]]++;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n\\t\\t\\t//read this after reading the below two cases\\n\\t\\t\\t//ith element is removed from hashmap as it is used as nums[j] element specified in question (if it is used)\\n            m[nums[i]]--;\\n\\t\\t\\t\\n\\t\\t\\t//remove the element from hashmap inorder to get the right results when finding the upper bound\\n            if(m[nums[i]] == 0) m.erase(nums[i]);\\n\\t\\t\\t\\n\\t\\t\\t//we just have to look in the right side of the array for a number which follow\\'s nums[k] criteria as specified in question\\n            if(nums[i] > mn)\\n            {\\n                auto el = m.upper_bound(mn);\\n                \\n                if(el != m.end() && el->first < nums[i]) return true;\\n            }\\n\\t\\t\\t//store minimum in mn traversed till now\\n            else \\n            {\\n                mn = min(mn, nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2) return false;\\n        \\n        int mn = nums[0];\\n        \\n        map<int, int> m;\\n\\t\\t//i starts from 2 as 0 given to mn(i.e nums[i]) and 1 will be given to nums[j] (as prescribed in question)\\n        for(int i=2; i<n; i++) m[nums[i]]++;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n\\t\\t\\t//read this after reading the below two cases\\n\\t\\t\\t//ith element is removed from hashmap as it is used as nums[j] element specified in question (if it is used)\\n            m[nums[i]]--;\\n\\t\\t\\t\\n\\t\\t\\t//remove the element from hashmap inorder to get the right results when finding the upper bound\\n            if(m[nums[i]] == 0) m.erase(nums[i]);\\n\\t\\t\\t\\n\\t\\t\\t//we just have to look in the right side of the array for a number which follow\\'s nums[k] criteria as specified in question\\n            if(nums[i] > mn)\\n            {\\n                auto el = m.upper_bound(mn);\\n                \\n                if(el != m.end() && el->first < nums[i]) return true;\\n            }\\n\\t\\t\\t//store minimum in mn traversed till now\\n            else \\n            {\\n                mn = min(mn, nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749921,
                "title": "easy-and-different-than-editorial-stack-java-o-n-iterate-from-1st-to-last",
                "content": "Please **upvote** if you find it usefull.\\n```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        \\n        int len = nums.length;\\n        \\n        // For each element, store the minimum element that exists on left side.\\n        int[] min = new int[len];\\n        min[0] = nums[0];\\n        for (int i = 1; i < len; i++) {\\n            min[i] = Math.min(min[i - 1], nums[i]);\\n        }\\n        \\n        Stack<Integer> stack = new Stack();\\n        for (int k = 0; k < len; ) {\\n            if (stack.size() == 0) {\\n                stack.add(k++);\\n            }\\n            else if (nums[stack.peek()] > nums[k]) { \\n                // Top element is greater than cur element => top = j, cur = k\\n                \\n                // If there exists i for the top element then we found a triplet.\\n                if (min[stack.peek()] < nums[k]) {\\n                    return true;\\n                }\\n                \\n                // Add cur to stack(stack will always have elements in dec order).\\n                stack.add(k++);\\n            }\\n            else {\\n                /* \\n                    If top element is smaller, thus indicating that \\n                    there is no element on left side that is greater \\n                    than cur element.\\n                    \\n                    Now, we will remove all elements from stack\\n                    that are smaller than cur. \\n                    \\n                    As they will not contribute to any future cur element as j.\\n                    Because we just found a new element that is larger than\\n                    all of them and can be used for j for future cur\\'s.\\n                */\\n                while (stack.size() > 0 && nums[stack.peek()] <= nums[k]) {\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean find132pattern(int[] nums) {\\n        \\n        int len = nums.length;\\n        \\n        // For each element, store the minimum element that exists on left side.\\n        int[] min = new int[len];\\n        min[0] = nums[0];\\n        for (int i = 1; i < len; i++) {\\n            min[i] = Math.min(min[i - 1], nums[i]);\\n        }\\n        \\n        Stack<Integer> stack = new Stack();\\n        for (int k = 0; k < len; ) {\\n            if (stack.size() == 0) {\\n                stack.add(k++);\\n            }\\n            else if (nums[stack.peek()] > nums[k]) { \\n                // Top element is greater than cur element => top = j, cur = k\\n                \\n                // If there exists i for the top element then we found a triplet.\\n                if (min[stack.peek()] < nums[k]) {\\n                    return true;\\n                }\\n                \\n                // Add cur to stack(stack will always have elements in dec order).\\n                stack.add(k++);\\n            }\\n            else {\\n                /* \\n                    If top element is smaller, thus indicating that \\n                    there is no element on left side that is greater \\n                    than cur element.\\n                    \\n                    Now, we will remove all elements from stack\\n                    that are smaller than cur. \\n                    \\n                    As they will not contribute to any future cur element as j.\\n                    Because we just found a new element that is larger than\\n                    all of them and can be used for j for future cur\\'s.\\n                */\\n                while (stack.size() > 0 && nums[stack.peek()] <= nums[k]) {\\n                    stack.pop();\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156350,
                "title": "c-code-using-stack-in-o-n",
                "content": "```\\nApproach: Put the minimum of all the elemnts from left to right in an array and consider every element of original array as middle of the pattern and then compare it ,\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini[n];\\n        mini[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            mini[i]=min(mini[i-1],nums[i]);\\n        }\\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(nums[i]>mini[i])\\n            {\\n                while(s.empty()==false && s.top()<=mini[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.empty()==false && s.top()<nums[i])\\n                {\\n                    return 1;\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nApproach: Put the minimum of all the elemnts from left to right in an array and consider every element of original array as middle of the pattern and then compare it ,\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        int mini[n];\\n        mini[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            mini[i]=min(mini[i-1],nums[i]);\\n        }\\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(nums[i]>mini[i])\\n            {\\n                while(s.empty()==false && s.top()<=mini[i])\\n                {\\n                    s.pop();\\n                }\\n                if(s.empty()==false && s.top()<nums[i])\\n                {\\n                    return 1;\\n                }\\n            }\\n            s.push(nums[i]);\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151665,
                "title": "java-stack-and-left-greatest-approach-o-n",
                "content": "class Solution {\\n    public boolean find132pattern(int[] nums) {\\n\\t\\n        if(nums.length<3)\\n            return false;\\n        \\n        int min=Integer.MAX_VALUE;\\n        int leftSmallest[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            min=Math.min(min,nums[i]);\\n            leftSmallest[i]=min;\\n        }\\n            \\n        Stack<Integer> stk=new Stack<>();\\n        stk.push(nums[nums.length-1]);\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            int val=nums[i];\\n            int leftSmall=leftSmallest[i];\\n            if(val!=leftSmall)\\n            {\\n                while(stk.size()>0 && val>stk.peek())\\n                {\\n                    int v3=stk.pop();\\n                    if(leftSmall<v3 && v3<val)\\n                        return true;\\n                }   \\n            }\\n                stk.push(val);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean find132pattern(int[] nums) {\\n\\t\\n        if(nums.length<3)\\n            return false;\\n        \\n        int min=Integer.MAX_VALUE;\\n        int leftSmallest[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            min=Math.min(min,nums[i]);\\n            leftSmallest[i]=min;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 974226,
                "title": "can-someone-please-explain-to-me-why-my-code-is-failing-for-this-testcase",
                "content": "\\'\\'\\'\\n\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3)return false;\\n        int var1=0,var2=0,var3=0,len=0;\\n        Stack <Integer> st=new Stack<> ();\\n        for(int i=0;i<nums.length;++i)\\n        {\\n            st.push(nums[i]);\\n            var1=var2;\\n            var2=var3;\\n            var3=nums[i];\\n            len++;\\n            st.push(var3);\\n            if((len>=3)&&(var1<var3)&&(var3<var2))return true;\\n        }\\n         return false;\\n    }\\n\\'\\'\\'\\n\\n\\nThe test case number is 84/101\\n and it is as follows\\n nums=[3,5,0,3,4] and output is expected to be true\\n but my code gives answer as false and it should be false since the only 3 sequences for 132 pattern are [3,0,5],[5,3,0],[0,4,3] and all give answers false for nums[i]<nums[k]<nums[j] and so it should be false but it gives true output in expected section of this testcase.**Please Guide Me if I am wrong**",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length<3)return false;\\n        int var1=0,var2=0,var3=0,len=0;\\n        Stack <Integer> st=new Stack<> ();\\n        for(int i=0;i<nums.length;++i)\\n        {\\n            st.push(nums[i]);\\n            var1=var2;\\n            var2=var3;\\n            var3=nums[i];\\n            len++;\\n            st.push(var3);\\n            if((len>=3)&&(var1<var3)&&(var3<var2))return true;\\n        }\\n         return false;\\n    }\\n\\'\\'\\'\\n\\n\\nThe test case number is 84/101\\n and it is as follows\\n nums=[3,5,0,3,4] and output is expected to be true\\n but my code gives answer as false and it should be false since the only 3 sequences for 132 pattern are [3,0,5],[5,3,0],[0,4,3] and all give answers false for nums[i]<nums[k]<nums[j] and so it should be false but it gives true output in expected section of this testcase.**Please Guide Me if I am wrong**",
                "codeTag": "Unknown"
            },
            {
                "id": 910630,
                "title": "c-132-pattern",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int s3 = INT_MIN;\\n        stack<int> st;\\n        for( int i = nums.size()-1; i >= 0; i -- ){\\n            if( nums[i] < s3 ) return true;\\n            else while( !st.empty() && nums[i] > st.top() ){ \\n              s3 = st.top(); st.pop(); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 907508,
                "title": "python-solution-explained-video-code",
                "content": "[](https://www.youtube.com/watch?v=xV-QDXn9Brc)\\nhttps://www.youtube.com/watch?v=xV-QDXn9Brc\\n```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        # i , j, k\\n        # i -> get val from min_list\\n        # j -> iterate through nums for each j val : nums[indx]\\n        # k -> get vals using stack\\n        min_list = []\\n        stack = []\\n        \\n        # Building Min list\\n        min_list.append(nums[0])\\n        \\n        for i in range(1,len(nums)):\\n            min_list.append(min(nums[:i]))\\n        \\n        # checking for valid patterns\\n        for j in range(len(nums) - 1, -1, -1):\\n            if nums[j] > min_list[j]:\\n                \\n                while stack and stack[-1] <= min_list[j]:\\n                    stack.pop()\\n                \\n                if stack and stack[-1] < nums[j]:\\n                    return True\\n                \\n                stack.append(nums[j])\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        # i , j, k\\n        # i -> get val from min_list\\n        # j -> iterate through nums for each j val : nums[indx]\\n        # k -> get vals using stack\\n        min_list = []\\n        stack = []\\n        \\n        # Building Min list\\n        min_list.append(nums[0])\\n        \\n        for i in range(1,len(nums)):\\n            min_list.append(min(nums[:i]))\\n        \\n        # checking for valid patterns\\n        for j in range(len(nums) - 1, -1, -1):\\n            if nums[j] > min_list[j]:\\n                \\n                while stack and stack[-1] <= min_list[j]:\\n                    stack.pop()\\n                \\n                if stack and stack[-1] < nums[j]:\\n                    return True\\n                \\n                stack.append(nums[j])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907407,
                "title": "c-solution-o-n-97-runtime-stack-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& a) {\\n        int n=a.size();\\n        stack<int> s;\\n        vector<int> m(n);\\n        m[0]=a[0];\\n        for(int i=1;i<n;i++){\\n            m[i]=min(m[i-1],a[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]>m[i]){\\n                while(s.size()&&s.top()<=m[i])s.pop();\\n                if(s.size()&&s.top()<a[i])return 1;\\n                s.push(a[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& a) {\\n        int n=a.size();\\n        stack<int> s;\\n        vector<int> m(n);\\n        m[0]=a[0];\\n        for(int i=1;i<n;i++){\\n            m[i]=min(m[i-1],a[i]);\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(a[i]>m[i]){\\n                while(s.size()&&s.top()<=m[i])s.pop();\\n                if(s.size()&&s.top()<a[i])return 1;\\n                s.push(a[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907323,
                "title": "easy-c-o-nlogn-solution-using-set-and-prefix-array",
                "content": "Since I found most of the solutions using stack so I thought of adding my solution here in which I have used set:\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        \\n        int *prefix = new int[n]();\\n        \\n        prefix[0] = nums[0];\\n        \\n        \\n        for(int i = 1 ;i<n ; i++){\\n            \\n            prefix[i] = min(prefix[i - 1] , nums[i]);\\n        }\\n        \\n        \\n        set<int> s;\\n        \\n        s.insert(nums[n - 1]);\\n        \\n        for(int i = n - 2 ; i >=0  ; i--){\\n            \\n            auto it = s.lower_bound(nums[i]);\\n            \\n            if(it!= s.begin()){\\n                \\n                it--;\\n                if(*it > prefix[i]){\\n                    return true;\\n                }\\n            }\\n            \\n            s.insert(nums[i]);\\n            \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        \\n        int *prefix = new int[n]();\\n        \\n        prefix[0] = nums[0];\\n        \\n        \\n        for(int i = 1 ;i<n ; i++){\\n            \\n            prefix[i] = min(prefix[i - 1] , nums[i]);\\n        }\\n        \\n        \\n        set<int> s;\\n        \\n        s.insert(nums[n - 1]);\\n        \\n        for(int i = n - 2 ; i >=0  ; i--){\\n            \\n            auto it = s.lower_bound(nums[i]);\\n            \\n            if(it!= s.begin()){\\n                \\n                it--;\\n                if(*it > prefix[i]){\\n                    return true;\\n                }\\n            }\\n            \\n            s.insert(nums[i]);\\n            \\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767733,
                "title": "java-short-stack-solution",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length < 3) return false;\\n        Stack<Integer> stack = new Stack<>();\\n        int second = -Integer.MAX_VALUE;\\n        \\n        for(int i=nums.length-1; i>-1; i--){\\n            if(nums[i] < second) return true;\\n            while(stack.size() > 0 && nums[i] > stack.peek()){\\n                second = stack.pop();\\n            }\\n            stack.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums.length < 3) return false;\\n        Stack<Integer> stack = new Stack<>();\\n        int second = -Integer.MAX_VALUE;\\n        \\n        for(int i=nums.length-1; i>-1; i--){\\n            if(nums[i] < second) return true;\\n            while(stack.size() > 0 && nums[i] > stack.peek()){\\n                second = stack.pop();\\n            }\\n            stack.push(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699373,
                "title": "nlogn-treeset-solution-in-java",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        \\n        //define data structures\\n        int[] left_min = new int[nums.length];\\n        \\n        //expand from center\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++){\\n            left_min[i] = min;\\n            min = Math.min(min, nums[i]);\\n        }\\n        \\n        \\n        //find 132 pattern\\n        TreeSet right_max = new TreeSet();\\n        for (int k = nums.length-1; k >= 0; k--){\\n            Integer max = (Integer)right_max.lower(nums[k]);\\n            if (max != null && max > left_min[k]){\\n                return true;\\n            }\\n            right_max.add(nums[k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        \\n        //define data structures\\n        int[] left_min = new int[nums.length];\\n        \\n        //expand from center\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++){\\n            left_min[i] = min;\\n            min = Math.min(min, nums[i]);\\n        }\\n        \\n        \\n        //find 132 pattern\\n        TreeSet right_max = new TreeSet();\\n        for (int k = nums.length-1; k >= 0; k--){\\n            Integer max = (Integer)right_max.lower(nums[k]);\\n            if (max != null && max > left_min[k]){\\n                return true;\\n            }\\n            right_max.add(nums[k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546136,
                "title": "456-132-pattern-python3",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        if len(set(nums)) < 3:\\n            return False\\n\\n        min_nums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            min_nums.append(min(nums[i], min_nums[-1]))\\n            \\n        stack = []\\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] > min_nums[i]:\\n                while stack and stack[-1] <= min_nums[i]:\\n                    stack.pop()\\n                if stack and stack[-1] < nums[i]:\\n                    return True\\n                else:\\n                    stack.append(nums[i])\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        if len(set(nums)) < 3:\\n            return False\\n\\n        min_nums = [nums[0]]\\n        for i in range(1, len(nums)):\\n            min_nums.append(min(nums[i], min_nums[-1]))\\n            \\n        stack = []\\n        for i in range(len(nums)-1, -1, -1):\\n            if nums[i] > min_nums[i]:\\n                while stack and stack[-1] <= min_nums[i]:\\n                    stack.pop()\\n                if stack and stack[-1] < nums[i]:\\n                    return True\\n                else:\\n                    stack.append(nums[i])\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507036,
                "title": "monotonic-stack",
                "content": "this problem can be solved by monotonic stack\\nalso see the monotonic queue, e.g. sliding window max\\n        \\nwe use a stack \\nthe stack is monotonically decreased from front to end (left to right)\\n        \\nwe visit the nums from right to left\\ngiven nums[i], we assume it is the \"3\" in \"132\" pattern\\n        \\nwhen we push an element, and the element is small than the end, we push it in\\nHowever, if the element is large than the end, we pop the end, and repeat the process until we push the element in the stack\\n        \\nthe last poped out value is the \"2\" in the \"132\" pattern\\nwhen we visit nums[i-1], we compare if it is the \"1\" by comparing it with the last poped out value\\n\\n```python\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t\\n        deq = collections.deque()\\n        num2 = None\\n        \\n        for n in nums[::-1]:\\n            if num2 is not None and n < num2:\\n                return True\\n            while deq and deq[-1] < n:\\n                num2 = deq.pop()\\n            deq.append(n)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t\\n        deq = collections.deque()\\n        num2 = None\\n        \\n        for n in nums[::-1]:\\n            if num2 is not None and n < num2:\\n                return True\\n            while deq and deq[-1] < n:\\n                num2 = deq.pop()\\n            deq.append(n)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431675,
                "title": "c-easy-to-understand-o-n-solution-using-stack",
                "content": "1) Use stack to keep the track of largest element in the array starting from right. At the same time whenever we see a element larger than the top of the stack we pop all the elements in the stack and make a_k (3 element in 132 pattern) equal to maximum of all the popped element. What this basically does is that at any point stack top will have the largest element, a_k will have the second largest element and if we find a number such that a_k > nums[i], we have found the 132 pattern.\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int a_k = INT_MIN;\\n        stack<int> stk;\\n        \\n        for(int i = nums.size()-1; i >= 0; i--) {\\n            while(!stk.empty() && stk.top() < nums[i]) {\\n                a_k = max(a_k,stk.top());\\n                stk.pop();\\n            }\\n            \\n            if(a_k != INT_MIN && a_k > nums[i]) return true;\\n            \\n            stk.push(nums[i]);\\n        }\\n    \\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int a_k = INT_MIN;\\n        stack<int> stk;\\n        \\n        for(int i = nums.size()-1; i >= 0; i--) {\\n            while(!stk.empty() && stk.top() < nums[i]) {\\n                a_k = max(a_k,stk.top());\\n                stk.pop();\\n            }\\n            \\n            if(a_k != INT_MIN && a_k > nums[i]) return true;\\n            \\n            stk.push(nums[i]);\\n        }\\n    \\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352457,
                "title": "c-maintain-a-stack-and-a3",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int a3 = INT_MIN;\\n        stack<int> stk;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < a3) {\\n                return true;\\n            }\\n            while (!stk.empty() && nums[stk.top()] < nums[i]) {\\n                int cur = stk.top();\\n                stk.pop();\\n                a3 = max(a3, nums[cur]);\\n            }\\n            stk.push(i);\\n        }\\n        return false;\\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int a3 = INT_MIN;\\n        stack<int> stk;\\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            if (nums[i] < a3) {\\n                return true;\\n            }\\n            while (!stk.empty() && nums[stk.top()] < nums[i]) {\\n                int cur = stk.top();\\n                stk.pop();\\n                a3 = max(a3, nums[cur]);\\n            }\\n            stk.push(i);\\n        }\\n        return false;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229710,
                "title": "python-using-stack",
                "content": "```\\ndef find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        j ,stack  = float(\"-inf\"), []\\n        for num in nums[::-1]:\\n            if num < j: return True\\n            while stack and stack[-1] < num: j = stack.pop()\\n            stack.append(num)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef find132pattern(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        j ,stack  = float(\"-inf\"), []\\n        for num in nums[::-1]:\\n            if num < j: return True\\n            while stack and stack[-1] < num: j = stack.pop()\\n            stack.append(num)\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3811136,
                "title": "java-solution-very-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n\\n\\t\\t\\t\\tint thirdEle = Integer.MIN_VALUE;\\n\\n\\t\\t\\t\\tfor(int i = nums.length - 1; i >= 0; i--){\\n\\t\\t\\t\\t\\tif(nums[i] < thirdEle) return true;\\n\\n\\t\\t\\t\\t\\twhile(!st.isEmpty() && nums[i] > st.peek()){\\n\\t\\t\\t\\t\\t\\tthirdEle = st.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.push(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n\\n\\t\\t\\t\\tint thirdEle = Integer.MIN_VALUE;\\n\\n\\t\\t\\t\\tfor(int i = nums.length - 1; i >= 0; i--){\\n\\t\\t\\t\\t\\tif(nums[i] < thirdEle) return true;\\n\\n\\t\\t\\t\\t\\twhile(!st.isEmpty() && nums[i] > st.peek()){\\n\\t\\t\\t\\t\\t\\tthirdEle = st.pop();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tst.push(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046487,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find if there is a subsequence of integers in the given vector that follows the pattern 1-3-2, where the integers in the subsequence are in strictly increasing order. The first integer is referred as 1, the second integer as 3 and the third as 2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken in this solution is to first find the minimum element up to each index in the given vector, and store it in a separate vector called min. Then, the solution iterates through the given vector in reverse order, and for each element, checks if it is greater than the minimum element up to that index. If it is, the solution uses a stack to check if there is a number that is smaller than the current element and greater than the minimum element up to that index, which would satisfy the 1-3-2 pattern.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 3) return false;\\n        vector<int> min(n);\\n        min[0] = nums[0];\\n        for (int i = 1; i < n; ++i) {\\n            min[i] = min[i - 1] < nums[i] ? min[i - 1] : nums[i];\\n        }\\n        stack<int> s;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (nums[i] > min[i]) {\\n                while (!s.empty() && s.top() <= min[i]) {\\n                    s.pop();\\n                }\\n                if (!s.empty() && s.top() < nums[i]) {\\n                    return true;\\n                }\\n                s.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 3) return false;\\n        vector<int> min(n);\\n        min[0] = nums[0];\\n        for (int i = 1; i < n; ++i) {\\n            min[i] = min[i - 1] < nums[i] ? min[i - 1] : nums[i];\\n        }\\n        stack<int> s;\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (nums[i] > min[i]) {\\n                while (!s.empty() && s.top() <= min[i]) {\\n                    s.pop();\\n                }\\n                if (!s.empty() && s.top() < nums[i]) {\\n                    return true;\\n                }\\n                s.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917552,
                "title": "java-stack-clean-and-simple",
                "content": "# Please Upvote :D\\n\\n``` java []\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int secondMax = Integer.MIN_VALUE;\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < secondMax) {\\n                return true;\\n            }\\n            while (!st.isEmpty() && nums[i] > st.peek()) {\\n                secondMax = Math.max(secondMax, st.pop());\\n            }\\n            st.push(nums[i]);\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)`",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> st = new Stack<>();\\n        int secondMax = Integer.MIN_VALUE;\\n\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            if (nums[i] < secondMax) {\\n                return true;\\n            }\\n            while (!st.isEmpty() && nums[i] > st.peek()) {\\n                secondMax = Math.max(secondMax, st.pop());\\n            }\\n            st.push(nums[i]);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673883,
                "title": "stack-easy-simple-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> s;\\n        int x = INT_MIN;\\n        for(int i = nums.size()-1; i>=0; i--){\\n            if(nums[i]<x){\\n                return true;\\n            }\\n            while(!s.empty() && nums[i]>s.top()){\\n                x = s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> s;\\n        int x = INT_MIN;\\n        for(int i = nums.size()-1; i>=0; i--){\\n            if(nums[i]<x){\\n                return true;\\n            }\\n            while(!s.empty() && nums[i]>s.top()){\\n                x = s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529025,
                "title": "single-pass-c-o-n-space-and-time-solution-8-lines-with-detailed-explanation",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int>s;\\n        int n=nums.size();\\n        int second =INT_MIN;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(nums[i]<second)\\n            {\\n                return true;\\n            }\\n            while(!s.empty() && nums[i]>s.top())\\n            {\\n                second=s.top();\\n                s.pop();\\n            }\\n            s.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267348,
                "title": "c-monotonic-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        int middle = INT_MIN;\\n        stack<int> st;\\n        for(int i=n-1; i>=0; i--){\\n            if(nums[i] < middle) return true;\\n            else {\\n                while(!st.empty() && st.top()<nums[i]){\\n                    middle = max(middle,st.top());\\n                    st.pop();\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        int middle = INT_MIN;\\n        stack<int> st;\\n        for(int i=n-1; i>=0; i--){\\n            if(nums[i] < middle) return true;\\n            else {\\n                while(!st.empty() && st.top()<nums[i]){\\n                    middle = max(middle,st.top());\\n                    st.pop();\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267347,
                "title": "98-tc-and-60-sc-easy-python-solution-using-stack",
                "content": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n\\tmid = -float(\\'inf\\')\\n\\ts = []\\n\\tfor i in nums[::-1]:\\n\\t\\tif(i < mid):\\n\\t\\t\\treturn 1\\n\\t\\twhile(s and s[-1] < i):\\n\\t\\t\\tmid = s.pop()\\n\\t\\ts.append(i)\\n\\treturn 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n\\tmid = -float(\\'inf\\')\\n\\ts = []\\n\\tfor i in nums[::-1]:\\n\\t\\tif(i < mid):\\n\\t\\t\\treturn 1\\n\\t\\twhile(s and s[-1] < i):\\n\\t\\t\\tmid = s.pop()\\n\\t\\ts.append(i)\\n\\treturn 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2215626,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> s = new Stack<>();\\n        int mid = Integer.MIN_VALUE;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int n = nums[i];\\n            if(mid>n)\\n                return true;\\n            while(!s.isEmpty() && s.peek()<n){\\n                mid = s.pop();\\n            }\\n            s.push(n);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        Stack<Integer> s = new Stack<>();\\n        int mid = Integer.MIN_VALUE;\\n        for(int i=nums.length-1;i>=0;i--){\\n            int n = nums[i];\\n            if(mid>n)\\n                return true;\\n            while(!s.isEmpty() && s.peek()<n){\\n                mid = s.pop();\\n            }\\n            s.push(n);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029851,
                "title": "132-pattern-all-the-three-solutions-o-n-3-o-n-2-o-n-stack-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // // Method: 1 O(n^3)\\n        // for (int i = 0; i < n - 2; i++)\\n        // {\\n        //     for (int j = i + 1; j < n - 1; j++)\\n        //     {\\n        //         for (int k = j + 1; k < n; k++)\\n        //         {\\n        //             if (nums[i] < nums[k] && nums[k] < nums[j])\\n        //                 return true;\\n        //         }\\n        //     }\\n        // }\\n        // return false;\\n        \\n        // // Method: 2 O(n^2)\\n        // int mini = nums[0];\\n        // for (int j = 1; j < n - 1; j++)\\n        // {\\n        //     for (int k = j + 1; k < n; k++)\\n        //     {\\n        //         if (mini < nums[k] && nums[k] < nums[j])\\n        //             return true;\\n        //         mini = min(mini, nums[j]);\\n        //     }\\n        // }\\n        // return false;\\n        \\n        // Method: 3\\n        int third = INT_MIN;\\n        stack<int> st;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int ce = nums[i]; // First element\\n            if (ce < third)\\n                return true;\\n            else\\n            {\\n                while(!st.empty() && st.top() < ce)\\n                {\\n                    third = st.top(); // Keeping the minimium elem for third\\n                    st.pop();\\n                }\\n                st.push(ce);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // // Method: 1 O(n^3)\\n        // for (int i = 0; i < n - 2; i++)\\n        // {\\n        //     for (int j = i + 1; j < n - 1; j++)\\n        //     {\\n        //         for (int k = j + 1; k < n; k++)\\n        //         {\\n        //             if (nums[i] < nums[k] && nums[k] < nums[j])\\n        //                 return true;\\n        //         }\\n        //     }\\n        // }\\n        // return false;\\n        \\n        // // Method: 2 O(n^2)\\n        // int mini = nums[0];\\n        // for (int j = 1; j < n - 1; j++)\\n        // {\\n        //     for (int k = j + 1; k < n; k++)\\n        //     {\\n        //         if (mini < nums[k] && nums[k] < nums[j])\\n        //             return true;\\n        //         mini = min(mini, nums[j]);\\n        //     }\\n        // }\\n        // return false;\\n        \\n        // Method: 3\\n        int third = INT_MIN;\\n        stack<int> st;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            int ce = nums[i]; // First element\\n            if (ce < third)\\n                return true;\\n            else\\n            {\\n                while(!st.empty() && st.top() < ce)\\n                {\\n                    third = st.top(); // Keeping the minimium elem for third\\n                    st.pop();\\n                }\\n                st.push(ce);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021091,
                "title": "java-stack-o-n-small-and-easily-understandable-code-with-explanation",
                "content": "```\\nsee u should find such a point where it is like it greater then 2 nos i & k and [i]<[k] that means u have to find a index nums[i]<nums[j]<nums[k] what that means if u find  a point where nums[j]>nums[k] &&  nums[k]>nums[i] ur work is done \\nhow will u find that it is simple just put every thing into a stack \\nYour questions arises why to use stack?\\nSee here first of all u have to compare the current element from the previous element continuously and also update the those element to see the pattern 132\\n\\nfor example if it is like [3,1,4,2,5] so what u can do is first put 5 into the stack \\nelements in the stack:5\\nthen comes 2 2<5 no need to pop the element becuse u have to find nums[j]>nums[k] not nums[k]<nums[j] so \\nelements in the stack:2 5\\nnow 4 comes in the game \\n4>2 so might be a possibility of getting nums[j]>nums[k] so put second element =4  and third element =4 and pop the 2 and as 4<5 add 4 into the stack\\nthen comes 1 <third element && 1<second element so 1<4<2\\n```\\n```\\nclass Solution \\n{\\n    public boolean find132pattern(int[] nums)\\n    {\\n          Stack<Integer> st=new Stack<Integer>();\\n          int k=Integer.MIN_VALUE;\\n        int n=nums.length;\\n          for(int i=n-1;i>=0;i--)\\n          {\\n              if(nums[i]<k)\\n              {\\n                  return true;\\n              }\\n              while(st.isEmpty()==false && st.peek()<nums[i])\\n              {\\n                  k=st.pop();\\n              }\\n              st.add(nums[i]);\\n          }\\n        return false;\\n \\n    }\\n}\\n```\\n\\n\\n**PLS UPVOTE IF U LIKE THE SOLUTION**",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nsee u should find such a point where it is like it greater then 2 nos i & k and [i]<[k] that means u have to find a index nums[i]<nums[j]<nums[k] what that means if u find  a point where nums[j]>nums[k] &&  nums[k]>nums[i] ur work is done \\nhow will u find that it is simple just put every thing into a stack \\nYour questions arises why to use stack?\\nSee here first of all u have to compare the current element from the previous element continuously and also update the those element to see the pattern 132\\n\\nfor example if it is like [3,1,4,2,5] so what u can do is first put 5 into the stack \\nelements in the stack:5\\nthen comes 2 2<5 no need to pop the element becuse u have to find nums[j]>nums[k] not nums[k]<nums[j] so \\nelements in the stack:2 5\\nnow 4 comes in the game \\n4>2 so might be a possibility of getting nums[j]>nums[k] so put second element =4  and third element =4 and pop the 2 and as 4<5 add 4 into the stack\\nthen comes 1 <third element && 1<second element so 1<4<2\\n```\n```\\nclass Solution \\n{\\n    public boolean find132pattern(int[] nums)\\n    {\\n          Stack<Integer> st=new Stack<Integer>();\\n          int k=Integer.MIN_VALUE;\\n        int n=nums.length;\\n          for(int i=n-1;i>=0;i--)\\n          {\\n              if(nums[i]<k)\\n              {\\n                  return true;\\n              }\\n              while(st.isEmpty()==false && st.peek()<nums[i])\\n              {\\n                  k=st.pop();\\n              }\\n              st.add(nums[i]);\\n          }\\n        return false;\\n \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017102,
                "title": "intuition-explaination-java-solution",
                "content": "Notations:\\n* Let I, J, K represent the numbers that satisfy our condition and are our answer\\n\\t* I = 1\\n\\t* J = 3\\n\\t* K = 2\\n* So condition 132 can be represented as\\n\\t* I < K < J\\n\\n# Brute Force\\nThis is similar to 3-Sum problem. \\n* I --> 0 TO n-1\\n\\t*  J --> I+1 TO n-1\\n\\t\\t*  K  --> J +1 TO n-1\\n\\t\\t\\t*  Test the condition ==> nums[I] < nums[K] < nums[J]\\n\\nTC: O(n cube) because of 3 loops\\nSC: O(1)\\n\\n# Brute Force improved\\nI see that element I could be minimum element encountered till now. Do I need a loop to get minimum element? No, I can just keep it in variable.\\nSo my logic changes to\\n* I = 0\\n* J = 1 to n-1\\n\\t* K = J+1 to n-1\\n\\t\\t* test the condition ==> nums[I] < nums[K] < nums[J]\\n\\t* I = J if nums[J] < nums[I]. This is needed to make sure I hold minimum element until J.\\n\\nTC: O(n squared). We just removed one loop.\\nSC: O(1)\\n\\n# Using a BST\\nIn brute force enhancement, we skipped I loop.\\nCan we somehow skip another loop - either J or K?\\n\\nFor a J, we just need to know if there exists a K satisfying the condition.\\nA BST can help if we have all elements after J in a BST. Search for an element smaller than elementJ, but larger than elementI would take only O(log n) time. Yep, that works.\\nBut for this we need to have all elements in BST that come after J.\\nWe could keep all elements in BST. We could remove element-I and element-J from BST. And then do our search.\\n\\nSo logic looks like this:\\n* dump all elements in BST\\n* elementI = nums[0]. So remove it from BST.\\n* J --> 1 to n-1\\n\\t* remove elementJ from BST\\n\\t* Now find an element in BST that is greater than element-I but less than element-J\\n\\t\\t* If we find, this is answer. Return true.\\n\\nTC: \\n* O(n log n) to populate BST.\\n* O(n) for J loop. And O(log n) to find K in BST. So total O(n log n) in J loop.\\n* Net Tc: O(n log n)\\n\\nSC: O(n) because we are storing the BST\\n\\nJava code:\\nI utilized a TreeMap to keep elements in BST and using a counter - because input has duplicates. Remove each element from TM using counter.\\n```\\n    public boolean find132pattern(int[] nums) {\\n        TreeMap<Integer, Integer> tm = new TreeMap();\\n        for(int num: nums) {\\n            tm.put(num, tm.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int elementI = nums[0];\\n        remove(elementI, tm);\\n        \\n        for(int j = 1; j < nums.length; j++) {\\n            int elementJ = nums[j];\\n            remove(elementJ, tm);\\n            Integer elementK = tm.floorKey(elementJ-1);\\n            if(elementK != null && elementI < elementK) {\\n                return true;\\n            }\\n            elementI = Integer.min(elementI, elementJ);\\n        }\\n        return false;\\n    }\\n\\n\\tprivate void remove(int num, TreeMap<Integer, Integer> tm) {\\n        tm.put(num, tm.get(num)-1);\\n        if(tm.get(num) == 0) {\\n            tm.remove(num);\\n        }\\n    }\\n```\\n\\n# Using monotonic stack\\nWell, I couldn\\'t think of this as an answer. \\nUsing BST my time taken was very high compared to others. So I looked at others code and wow. This answer would never come to me.\\nSo here I try to explain it.\\n\\nTC: amortized O(n). O(n squared) for increasing sequence.\\nWhile BST took 200ms, this solution took just 40ms.\\n\\nWhat is monotonic stack?\\nA stack whose elements are strictly increasing or decreasing.\\n\\nOur monotonic stack implementation keep smallest element on top, largest element on bottom. Like a pyramid.\\n\\nStack top represents J.\\nThe element just smaller than J will be ideal candidate for K - because then it can work for any I.\\nSince stack is monotonic, if we get an element > top, we will pop it. And since this element is less than element, its a good candidate for K. Just make sure that actual K is largest among all the candidates\\n\\nLogic:\\n* element-K = negative infinity\\n* I = n-1 to 0\\n\\t* IF element-I < element-K\\n\\t\\t* then this is the answer. Wait, what about J? Well, K is already less than J.\\n\\t* Pop all elements smaller than element-I from stack, and put element-I on top of stack. This is now our element-J.\\n\\t\\t* popped elements are candidates for element-K. So element-K is max among popped elements and itself.\\n\\nI know its difficult to understand. It was for me too. So lets take an example.\\nInput: 3,5,0,1,4\\n\\nLoop I is from last to first element.\\n\\n* element-K = negative infinity\\n* Loop: I = 4.\\n\\t* element-I = 4\\n\\t* element-I is not less than element-K\\n\\t* stack is empty. So no poping.\\n\\t* dump element-I on stack.\\n\\t* Finally\\n\\t\\t* Stack: 4\\n\\t\\t* element-K = negative infinity\\n* Loop: I = 3.\\n\\t* element-I = 1\\n\\t* element-I is not less than element-K\\n\\t* stack top is not less than element-I. So no poping.\\n\\t* dump element-I on stack.\\n\\t* Finally\\n\\t\\t* Stack: 4, 1\\n\\t\\t* element-K = negative infinity\\n* Loop: I = 2.\\n\\t* element-I = 0\\n\\t* element-I is not less than element-K\\n\\t* stack top is not less than element-I. So no poping.\\n\\t* dump element-I on stack.\\n\\t* Finally\\n\\t\\t* Stack: 4, 1, 0\\n\\t\\t* element-K = negative infinity\\n* Loop: I = 1.\\n\\t* element-I = 5\\n\\t* element-I is not less than element-K\\n\\t* stack top is less than element-I. So pop all elements from stack that are less than 5. All popped elements are candidate to be element-K\\n\\t* element-K is 4 since it was largest one on stack.\\n\\t* dump element-I on stack.\\n\\t* Finally\\n\\t\\t* Stack: 5\\n\\t\\t* element-K = 4\\n* Loop: I = 0.\\n\\t* element-I = 3\\n\\t* element-I is less than element-K\\n\\t\\t* condition is satisfied\\n\\nCode is here:\\n```\\n    public boolean find132pattern_fastest(int[] nums) {\\n        Stack<Integer> stack = new Stack();      // stack to keep elements with biggest on base, smallest on top.\\n                                                    // element on top of stack represents elementJ\\n                                                    // elementJ = stack.peek() at any given time.\\n        int elementK = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--) {\\n            int elementI = nums[i];\\n            \\n            // Test the condition that elementI < elementK < elementJ\\n            if(elementI < elementK) {   // then it is implicit that elementI < elementJ\\n                return true;\\n            }\\n            \\n            // okay, elementI >= elementK. So lets try to put it on stack - may be it is actually elementJ\\n            // since stack is a min stack - smallest element on top, biggest on bottom, lets try to pop all elements less than me. \\n            // Once I pop an elemnet - it means that is less than element. So they are candidate for elementK if they are greater than elementK.\\n            while(!stack.isEmpty() && elementI > stack.peek()) {\\n                int elementKCandidate = stack.pop();\\n                elementK = Integer.max(elementK, elementKCandidate);\\n            }\\n            \\n            stack.push(elementI);\\n        }\\n        return false;\\n    }\\n```\\n\\nI know I could have made code concise. But I made it to be elaborate to explain myself better.",
                "solutionTags": [],
                "code": "```\\n    public boolean find132pattern(int[] nums) {\\n        TreeMap<Integer, Integer> tm = new TreeMap();\\n        for(int num: nums) {\\n            tm.put(num, tm.getOrDefault(num, 0) + 1);\\n        }\\n        \\n        int elementI = nums[0];\\n        remove(elementI, tm);\\n        \\n        for(int j = 1; j < nums.length; j++) {\\n            int elementJ = nums[j];\\n            remove(elementJ, tm);\\n            Integer elementK = tm.floorKey(elementJ-1);\\n            if(elementK != null && elementI < elementK) {\\n                return true;\\n            }\\n            elementI = Integer.min(elementI, elementJ);\\n        }\\n        return false;\\n    }\\n\\n\\tprivate void remove(int num, TreeMap<Integer, Integer> tm) {\\n        tm.put(num, tm.get(num)-1);\\n        if(tm.get(num) == 0) {\\n            tm.remove(num);\\n        }\\n    }\\n```\n```\\n    public boolean find132pattern_fastest(int[] nums) {\\n        Stack<Integer> stack = new Stack();      // stack to keep elements with biggest on base, smallest on top.\\n                                                    // element on top of stack represents elementJ\\n                                                    // elementJ = stack.peek() at any given time.\\n        int elementK = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--) {\\n            int elementI = nums[i];\\n            \\n            // Test the condition that elementI < elementK < elementJ\\n            if(elementI < elementK) {   // then it is implicit that elementI < elementJ\\n                return true;\\n            }\\n            \\n            // okay, elementI >= elementK. So lets try to put it on stack - may be it is actually elementJ\\n            // since stack is a min stack - smallest element on top, biggest on bottom, lets try to pop all elements less than me. \\n            // Once I pop an elemnet - it means that is less than element. So they are candidate for elementK if they are greater than elementK.\\n            while(!stack.isEmpty() && elementI > stack.peek()) {\\n                int elementKCandidate = stack.pop();\\n                elementK = Integer.max(elementK, elementKCandidate);\\n            }\\n            \\n            stack.push(elementI);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2016698,
                "title": "time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        int thirdElement = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] < thirdElement) return true;\\n            while(!st.isEmpty() && st.peek() < nums[i]) thirdElement = st.pop();\\n            st.push(nums[i]);\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        int thirdElement = Integer.MIN_VALUE;\\n        \\n        for(int i = nums.length - 1; i >= 0; i--){\\n            if(nums[i] < thirdElement) return true;\\n            while(!st.isEmpty() && st.peek() < nums[i]) thirdElement = st.pop();\\n            st.push(nums[i]);\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016581,
                "title": "c-stack-detailed-explanation",
                "content": "# Approach\\n1. We create an increasing order stack (from top to bottom) traversing from back of the array.\\n2. If nums[i] is less than top of stack then we simply push it into the stack maintining its monotonicity. \\n3. If nums[i] is greater than the stack, then this could be our possible contender for J. \\n4. We find out the number just smaller than nums[i] in the stack. This will act as our K. And push nums[i] into the stack.\\n4. Now if at any point if nums[i] < K then we know that, there exist a value greater than K in the stack and now we have a value lesser than K. So we have our triplet. \\n\\n![image](https://assets.leetcode.com/users/images/15922eba-a83a-463c-b416-e2900f49b27c_1651931149.840722.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int i, sk = INT_MIN;\\n        stack<int> st;\\n        int n = nums.size();\\n        \\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(st.empty() || nums[i] < st.top())\\n                st.push(nums[i]);\\n            else if(nums[i] > st.top())\\n            {\\n                while(!st.empty() && nums[i] > st.top())\\n                {\\n                    sk = st.top();\\n                    st.pop();\\n                }\\n                st.push(nums[i]);\\n            }\\n            if(nums[i] < sk)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n**Please upvote if you liked the explanation.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        int i, sk = INT_MIN;\\n        stack<int> st;\\n        int n = nums.size();\\n        \\n        for(i=n-1;i>=0;i--)\\n        {\\n            if(st.empty() || nums[i] < st.top())\\n                st.push(nums[i]);\\n            else if(nums[i] > st.top())\\n            {\\n                while(!st.empty() && nums[i] > st.top())\\n                {\\n                    sk = st.top();\\n                    st.pop();\\n                }\\n                st.push(nums[i]);\\n            }\\n            if(nums[i] < sk)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016518,
                "title": "easy-to-understand-c-stack-solution",
                "content": "##### The biggest num will always stay in the stack and second one will stay on my second int ,if I can find nums[i] smaller than second than I can return true because I am searching from right to left\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> st;\\n        int s3 = INT_MIN;\\n        for(int i= nums.size()-1 ; i>=0; --i){\\n            if(nums[i]< s3) return true;\\n            else while(!st.empty() && nums[i] > st.top()){\\n                s3 = st.top();\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        stack<int> st;\\n        int s3 = INT_MIN;\\n        for(int i= nums.size()-1 ; i>=0; --i){\\n            if(nums[i]< s3) return true;\\n            else while(!st.empty() && nums[i] > st.top()){\\n                s3 = st.top();\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016426,
                "title": "javascript-very-easy-solution",
                "content": "/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n    let arr = []\\n    \\n    let negative = -Infinity;\\n    \\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] < negative) {\\n            return true\\n        }\\n        \\n        \\n        while(arr.length > 0 && nums[i] > arr[arr.length - 1]) {\\n            negative = arr.pop()\\n        }\\n        \\n        arr.push(nums[i])\\n    }\\n    \\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n    let arr = []\\n    \\n    let negative = -Infinity;\\n    \\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        if (nums[i] < negative) {\\n            return true\\n        }\\n        \\n        \\n        while(arr.length > 0 && nums[i] > arr[arr.length - 1]) {\\n            negative = arr.pop()\\n        }\\n        \\n        arr.push(nums[i])\\n    }\\n    \\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2016402,
                "title": "monotonic-stack-java-easy-solution",
                "content": "\\'\\'\\'\\n\\n\\n\\n\\nclass Solution\\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        if(nums == null || nums.length < 3) \\n            return false;\\n        \\n        \\n         int s3 = Integer.MIN_VALUE; // to compare and update everytime we found new max     //after traverasing from back\\n         Stack<Integer> stk = new Stack();\\n         for(int i = nums.length-1;i>=0;i--)\\n         {\\n             if(nums[i]<s3) \\n                 return true;  \\n              while(!stk.isEmpty() && nums[i]>stk.peek())\\n              {\\n                 s3 = stk.pop(); // we have to pop that num and change s3 to that no.\\n             }\\n             stk.push(nums[i]);\\n         }\\n        return false;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "class Solution\\n{\\n    public boolean find132pattern(int[] nums) \\n    {\\n        if(nums == null || nums.length < 3) \\n            return false;\\n        \\n        \\n         int s3 = Integer.MIN_VALUE; // to compare and update everytime we found new max     //after traverasing from back\\n         Stack<Integer> stk = new Stack();\\n         for(int i = nums.length-1;i>=0;i--)\\n         {\\n             if(nums[i]<s3) \\n                 return true;  \\n              while(!stk.isEmpty() && nums[i]>stk.peek())\\n              {\\n                 s3 = stk.pop(); // we have to pop that num and change s3 to that no.\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2016089,
                "title": "c-an-overkill-solution-using-fenwick-tree",
                "content": "```\\n\\n#include <cassert>\\n#include <vector>\\n\\n\\n#include <cassert>\\n#include <numeric>\\n#include <type_traits>\\n\\nnamespace atcoder {\\n\\nnamespace internal {\\n\\n#ifndef _MSC_VER\\ntemplate <class T>\\nusing is_signed_int128 =\\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\\n                                  std::is_same<T, __int128>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int128 =\\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\\n                                  std::is_same<T, unsigned __int128>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing make_unsigned_int128 =\\n    typename std::conditional<std::is_same<T, __int128_t>::value,\\n                              __uint128_t,\\n                              unsigned __int128>;\\n\\ntemplate <class T>\\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\\n                                                  is_signed_int128<T>::value ||\\n                                                  is_unsigned_int128<T>::value,\\n                                              std::true_type,\\n                                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\\n                                                 std::is_signed<T>::value) ||\\n                                                    is_signed_int128<T>::value,\\n                                                std::true_type,\\n                                                std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int =\\n    typename std::conditional<(is_integral<T>::value &&\\n                               std::is_unsigned<T>::value) ||\\n                                  is_unsigned_int128<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing to_unsigned = typename std::conditional<\\n    is_signed_int128<T>::value,\\n    make_unsigned_int128<T>,\\n    typename std::conditional<std::is_signed<T>::value,\\n                              std::make_unsigned<T>,\\n                              std::common_type<T>>::type>::type;\\n\\n#else\\n\\ntemplate <class T> using is_integral = typename std::is_integral<T>;\\n\\ntemplate <class T>\\nusing is_signed_int =\\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int =\\n    typename std::conditional<is_integral<T>::value &&\\n                                  std::is_unsigned<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\\n                                              std::make_unsigned<T>,\\n                                              std::common_type<T>>::type;\\n\\n#endif\\n\\ntemplate <class T>\\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\\n\\ntemplate <class T>\\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\\n\\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\\n\\n}  // namespace internal\\n\\n}  // namespace atcoder\\n\\n\\nnamespace atcoder {\\n\\ntemplate <class T> struct fenwick_tree {\\n    using U = internal::to_unsigned_t<T>;\\n\\n  public:\\n    fenwick_tree() : _n(0) {}\\n    fenwick_tree(int n) : _n(n), data(n) {}\\n\\n    void add(int p, T x) {\\n        assert(0 <= p && p < _n);\\n        p++;\\n        while (p <= _n) {\\n            data[p - 1] += U(x);\\n            p += p & -p;\\n        }\\n    }\\n\\n    T sum(int l, int r) {\\n        assert(0 <= l && l <= r && r <= _n);\\n        return sum(r) - sum(l);\\n    }\\n\\n  private:\\n    int _n;\\n    std::vector<U> data;\\n\\n    U sum(int r) {\\n        U s = 0;\\n        while (r > 0) {\\n            s += data[r - 1];\\n            r -= r & -r;\\n        }\\n        return s;\\n    }\\n};\\n\\n}  // namespace atcoder\\n\\nusing namespace atcoder;\\n\\nclass Solution {\\npublic:\\n  bool find132pattern(vector<int>& a) {\\n    \\n    int n = a.size();\\n    int idx = 0;\\n    map<int,int> mp;\\n    for (auto x : a) mp[x] = 0;\\n    for (auto &[k,v] : mp) v = idx++;\\n    for (auto &x : a) x = mp[x];\\n    \\n    fenwick_tree<int> fw(idx);\\n    for (auto x : a) fw.add(x,1);\\n    \\n    int lo = 1e9;\\n    int hi = -1;\\n    \\n    bool ret = false;\\n    \\n    for (auto x : a) {\\n      if (x < lo) {\\n        lo = x;\\n        hi = x;\\n      }\\n      else if (x > hi) hi = x;\\n\\n      fw.add(x,-1);\\n      if (lo + 1 < hi) {\\n        if (fw.sum(lo+1,hi) > 0) ret = true;\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n};\\n```\\n\\n```lo``` is the minimum of ```nums``` so far while we iterate through the array ```nums```. ```hi``` is the maximum of ```nums``` since the current ```lo``` is updated. Essentially ```lo``` is ```nums[i]``` and ```hi``` is ```nums[j]```. we\\'re looking for an existence of ```k``` such that ```lo < nums[k] < hi``` (```i<j<k```) using Fenwick tree and coordinate compression. If ```fw.sum(lo+1,hi) > 0``` we know there exists a such ```k```.\\n\\nI know it\\'s an overkill. Just wanted to share.",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\n#include <cassert>\\n#include <vector>\\n\\n\\n#include <cassert>\\n#include <numeric>\\n#include <type_traits>\\n\\nnamespace atcoder {\\n\\nnamespace internal {\\n\\n#ifndef _MSC_VER\\ntemplate <class T>\\nusing is_signed_int128 =\\n    typename std::conditional<std::is_same<T, __int128_t>::value ||\\n                                  std::is_same<T, __int128>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int128 =\\n    typename std::conditional<std::is_same<T, __uint128_t>::value ||\\n                                  std::is_same<T, unsigned __int128>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing make_unsigned_int128 =\\n    typename std::conditional<std::is_same<T, __int128_t>::value,\\n                              __uint128_t,\\n                              unsigned __int128>;\\n\\ntemplate <class T>\\nusing is_integral = typename std::conditional<std::is_integral<T>::value ||\\n                                                  is_signed_int128<T>::value ||\\n                                                  is_unsigned_int128<T>::value,\\n                                              std::true_type,\\n                                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_signed_int = typename std::conditional<(is_integral<T>::value &&\\n                                                 std::is_signed<T>::value) ||\\n                                                    is_signed_int128<T>::value,\\n                                                std::true_type,\\n                                                std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int =\\n    typename std::conditional<(is_integral<T>::value &&\\n                               std::is_unsigned<T>::value) ||\\n                                  is_unsigned_int128<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing to_unsigned = typename std::conditional<\\n    is_signed_int128<T>::value,\\n    make_unsigned_int128<T>,\\n    typename std::conditional<std::is_signed<T>::value,\\n                              std::make_unsigned<T>,\\n                              std::common_type<T>>::type>::type;\\n\\n#else\\n\\ntemplate <class T> using is_integral = typename std::is_integral<T>;\\n\\ntemplate <class T>\\nusing is_signed_int =\\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing is_unsigned_int =\\n    typename std::conditional<is_integral<T>::value &&\\n                                  std::is_unsigned<T>::value,\\n                              std::true_type,\\n                              std::false_type>::type;\\n\\ntemplate <class T>\\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\\n                                              std::make_unsigned<T>,\\n                                              std::common_type<T>>::type;\\n\\n#endif\\n\\ntemplate <class T>\\nusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\\n\\ntemplate <class T>\\nusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\\n\\ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\\n\\n}  // namespace internal\\n\\n}  // namespace atcoder\\n\\n\\nnamespace atcoder {\\n\\ntemplate <class T> struct fenwick_tree {\\n    using U = internal::to_unsigned_t<T>;\\n\\n  public:\\n    fenwick_tree() : _n(0) {}\\n    fenwick_tree(int n) : _n(n), data(n) {}\\n\\n    void add(int p, T x) {\\n        assert(0 <= p && p < _n);\\n        p++;\\n        while (p <= _n) {\\n            data[p - 1] += U(x);\\n            p += p & -p;\\n        }\\n    }\\n\\n    T sum(int l, int r) {\\n        assert(0 <= l && l <= r && r <= _n);\\n        return sum(r) - sum(l);\\n    }\\n\\n  private:\\n    int _n;\\n    std::vector<U> data;\\n\\n    U sum(int r) {\\n        U s = 0;\\n        while (r > 0) {\\n            s += data[r - 1];\\n            r -= r & -r;\\n        }\\n        return s;\\n    }\\n};\\n\\n}  // namespace atcoder\\n\\nusing namespace atcoder;\\n\\nclass Solution {\\npublic:\\n  bool find132pattern(vector<int>& a) {\\n    \\n    int n = a.size();\\n    int idx = 0;\\n    map<int,int> mp;\\n    for (auto x : a) mp[x] = 0;\\n    for (auto &[k,v] : mp) v = idx++;\\n    for (auto &x : a) x = mp[x];\\n    \\n    fenwick_tree<int> fw(idx);\\n    for (auto x : a) fw.add(x,1);\\n    \\n    int lo = 1e9;\\n    int hi = -1;\\n    \\n    bool ret = false;\\n    \\n    for (auto x : a) {\\n      if (x < lo) {\\n        lo = x;\\n        hi = x;\\n      }\\n      else if (x > hi) hi = x;\\n\\n      fw.add(x,-1);\\n      if (lo + 1 < hi) {\\n        if (fw.sum(lo+1,hi) > 0) ret = true;\\n      }\\n    }\\n    \\n    return ret;\\n  }\\n};\\n```\n```lo```\n```nums```\n```nums```\n```hi```\n```nums```\n```lo```\n```lo```\n```nums[i]```\n```hi```\n```nums[j]```\n```k```\n```lo < nums[k] < hi```\n```i<j<k```\n```fw.sum(lo+1,hi) > 0```\n```k```",
                "codeTag": "C++"
            },
            {
                "id": 2016045,
                "title": "all-3-possible-approaches-from-o-n-n-n-to-o-n-easytounderstand",
                "content": "plz upvote if uh like\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& a) {\\n        //O(n*n*n) S(1) TLE(as expected)\\n        // int n=a.size();\\n        // for(int i=0;i<n-2;i++)\\n        //     for(int j=i+1;j<n-1;j++)\\n        //         for(int k=j+1;k<n;k++)\\n        //             if(a[i]<a[j]&&a[k]<a[j] && a[i]<a[k]){\\n        //                 cout<<a[i]<<a[k]<<a[j];\\n        //                 return 1;\\n        //             }\\n        // return 0;\\n        \\n        // O(n*n) S(n) TLE(not expecting that...sad)\\n        // int n=a.size();\\n        // int pre[n];\\n        // pre[0]=a[0];\\n        // for(int i=1;i<a.size();i++)pre[i]=min(pre[i-1],a[i]);\\n        // int j=1;\\n        // while(j<n-1){\\n        //     int k=j;\\n        //     while((++k)<n)\\n        //         if(pre[j-1]<a[j]&&a[k]<a[j] && pre[j-1]<a[k])return 1; \\n        //     j++;\\n        // }\\n        // return 0;\\n        \\n        //O(n) S(n) now we are talking, using stack\\n        stack<pair<int,int> > st;\\n        int n=a.size();\\n        int currMin=a[0];\\n        for(int i=1;i<n;i++){\\n                while(!st.empty() && st.top().first<=a[i])\\n                    st.pop();\\n                if(!st.empty() && st.top().second < a[i] )\\n                    return 1;\\n                st.push( { a[i], currMin} );\\n                currMin=min(a[i],currMin);\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& a) {\\n        //O(n*n*n) S(1) TLE(as expected)\\n        // int n=a.size();\\n        // for(int i=0;i<n-2;i++)\\n        //     for(int j=i+1;j<n-1;j++)\\n        //         for(int k=j+1;k<n;k++)\\n        //             if(a[i]<a[j]&&a[k]<a[j] && a[i]<a[k]){\\n        //                 cout<<a[i]<<a[k]<<a[j];\\n        //                 return 1;\\n        //             }\\n        // return 0;\\n        \\n        // O(n*n) S(n) TLE(not expecting that...sad)\\n        // int n=a.size();\\n        // int pre[n];\\n        // pre[0]=a[0];\\n        // for(int i=1;i<a.size();i++)pre[i]=min(pre[i-1],a[i]);\\n        // int j=1;\\n        // while(j<n-1){\\n        //     int k=j;\\n        //     while((++k)<n)\\n        //         if(pre[j-1]<a[j]&&a[k]<a[j] && pre[j-1]<a[k])return 1; \\n        //     j++;\\n        // }\\n        // return 0;\\n        \\n        //O(n) S(n) now we are talking, using stack\\n        stack<pair<int,int> > st;\\n        int n=a.size();\\n        int currMin=a[0];\\n        for(int i=1;i<n;i++){\\n                while(!st.empty() && st.top().first<=a[i])\\n                    st.pop();\\n                if(!st.empty() && st.top().second < a[i] )\\n                    return 1;\\n                st.push( { a[i], currMin} );\\n                currMin=min(a[i],currMin);\\n        }\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2015854,
                "title": "132-pattern-o-n-test-case-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        // here i<j<k\\n        //132\\n        // nums[i] < nums[j]< nums[k]\\n        stack<int>st;\\n        \\n        int mini = INT_MIN;\\n        \\n        for(int i = nums.size()-1;i>=0;i--){\\n            \\n            if(nums[i]<mini) return true;\\n            \\n            while(!st.empty() && st.top() < nums[i]){\\n                mini = st.top();\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n            \\n            // TC2: 3 1 4 2\\n            // i= 3\\n            // st = 2\\n            // mini = INT_MIN\\n            \\n            // i=2\\n            // mini = 2\\n            // st = 4\\n            \\n            // i=1\\n            // 4 < 1 return true;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        // here i<j<k\\n        //132\\n        // nums[i] < nums[j]< nums[k]\\n        stack<int>st;\\n        \\n        int mini = INT_MIN;\\n        \\n        for(int i = nums.size()-1;i>=0;i--){\\n            \\n            if(nums[i]<mini) return true;\\n            \\n            while(!st.empty() && st.top() < nums[i]){\\n                mini = st.top();\\n                st.pop();\\n            }\\n            st.push(nums[i]);\\n            \\n            // TC2: 3 1 4 2\\n            // i= 3\\n            // st = 2\\n            // mini = INT_MIN\\n            \\n            // i=2\\n            // mini = 2\\n            // st = 4\\n            \\n            // i=1\\n            // 4 < 1 return true;\\n            \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015779,
                "title": "clean-java-solution-single-pass-beats-99-77",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        int third = Integer.MIN_VALUE;\\n        int top = n;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            // Assumes that third is already smaller than some element nums[j] where j is between i and third\\'s index\\n            // We find a \"132\" pattern if nums[i] < third\\n            if (nums[i] < third) return true;\\n            \\n            // Now we have nums[i] >= third\\n            \\n            // We now view nums[i] as the second element, and increase third as much as possible, but keep third < nums[i].\\n            // We do this because we want to maximize the chance of finding a \"132\" pattern in a future iteration.\\n            // Note that {nums[top], ..., nums[n-1]} is a stack has the following property:\\n            // nums[top] <= nums[top+1] <= ... <= nums[n-1]\\n            while (top < n && nums[i] > nums[top]) third = nums[top++];\\n            \\n            // Now we have nums[i] <= nums[top] (which indicates that the stack is monotonical)\\n            // We push nums[i] to the \"stack\"            \\n            top--;\\n            nums[top] = nums[i];\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nDon\\'t forget to upvote if it helps!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int n = nums.length;\\n        int third = Integer.MIN_VALUE;\\n        int top = n;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            // Assumes that third is already smaller than some element nums[j] where j is between i and third\\'s index\\n            // We find a \"132\" pattern if nums[i] < third\\n            if (nums[i] < third) return true;\\n            \\n            // Now we have nums[i] >= third\\n            \\n            // We now view nums[i] as the second element, and increase third as much as possible, but keep third < nums[i].\\n            // We do this because we want to maximize the chance of finding a \"132\" pattern in a future iteration.\\n            // Note that {nums[top], ..., nums[n-1]} is a stack has the following property:\\n            // nums[top] <= nums[top+1] <= ... <= nums[n-1]\\n            while (top < n && nums[i] > nums[top]) third = nums[top++];\\n            \\n            // Now we have nums[i] <= nums[top] (which indicates that the stack is monotonical)\\n            // We push nums[i] to the \"stack\"            \\n            top--;\\n            nums[top] = nums[i];\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015648,
                "title": "c-solution-with-detailed-explanation",
                "content": "\\tthe intuitive thing to understand is that for a given j, the best candidate for i would be the minimum one before j\\n    because it opens up maximum number of possibilities for the element k\\n\\n\\n    Min[j] represents the smallest element in the range [0...j] {we will see in a moment what happens when nums[j] == Min[j]}\\n    we are considering all possibilities for the element nums[j] by iterating over the array in reverse direction\\n    in the stack we are maintain an increasing order from top to bottom\\n\\n    as soon as you arrive at the element j, pop out all the elements from the stack which are smaller than or equal to  Min[j] {remember the stack is increasing from top to bottom, so as \\n    we keep on popping, the elements will keep increasing}\\n\\n    while(!stk.empty() && stk.top() <= Min[j]) stk.pop();   ---- (1)\\n\\n    this pops out all the elements from the stack which are smaller than or equal to Min[j] \\n    now after we are done with the popping, the element at the top will be the element which is just greater than Min[j]\\n\\n    Now there are a Few Cases (after we have performed the popping)\\n\\n    Case 1 - the stack is empty\\n             in this case, we have no option but to just push the element j into the stack and continue\\n\\n    Case 2 - The stack is not empty\\n            Case 2.1 - the top  of the stack is smaller than nums[j] (stk.top() < nums[j])\\n                        this is the exact condition we are looking for, so simply return true\\n            \\n            Case 2.2 - the top of the stack is greater than equal to nums[j] (stk.top() >= nums[j])\\n                       Case 2.2.1 - the top of the stack is greater than nums[j]\\n                                    this is not a 132 pattern, so simply push nums[j] and continue (remember this still maintain a non decreasing order from top to bottom)\\n\\n                        Case 2.2.2 - the top of the stack is equal to nums[j]\\n                                     this also means that 132 pattern is not satisfied and we will simply push nums[j] and continue (this still maintain a non decreasing order from top to bottom)\\n        \\n    Now what happens when nums[j] == Min[j]\\n    Remember as soon as we arrived at the element j, we pooped out all the elements which were lesser than or equal to nums[j], so there is no way that Case 2.1 will be satisfied, so there is no problem \\uD83D\\uDE03\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> Min(n, INT_MAX);\\n        Min[0] = nums[0];\\n        for(int i = 1; i < n; i++) {\\n            Min[i] = min(Min[i - 1], nums[i]);\\n        }\\n        \\n        stack<int> stk;\\n        for(int j = n - 1; j >= 0; j--) {\\n            while(!stk.empty() && stk.top() <= Min[j]) stk.pop();\\n            if(!stk.empty() && stk.top() < nums[j]) return true;\\n            stk.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> Min(n, INT_MAX);\\n        Min[0] = nums[0];\\n        for(int i = 1; i < n; i++) {\\n            Min[i] = min(Min[i - 1], nums[i]);\\n        }\\n        \\n        stack<int> stk;\\n        for(int j = n - 1; j >= 0; j--) {\\n            while(!stk.empty() && stk.top() <= Min[j]) stk.pop();\\n            if(!stk.empty() && stk.top() < nums[j]) return true;\\n            stk.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015601,
                "title": "python-monotonic-stack-o-n",
                "content": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        \\n        stack = []\\n        minVal = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n\\t\\t\\t# stack should be monotonic decreasing\\n            while stack and nums[i]>=stack[-1][0]:\\n                stack.pop()\\n            \\n            if stack and nums[i] > stack[-1][1]:\\n                return True \\n            \\n            stack.append([nums[i],minVal])\\n\\t\\t\\t\\n\\t\\t\\t# get the minimum value before the current index value\\n            minVal = min(minVal,nums[i])\\n            \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def find132pattern(self, nums: List[int]) -> bool:\\n        \\n        stack = []\\n        minVal = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n\\t\\t\\t# stack should be monotonic decreasing\\n            while stack and nums[i]>=stack[-1][0]:\\n                stack.pop()\\n            \\n            if stack and nums[i] > stack[-1][1]:\\n                return True \\n            \\n            stack.append([nums[i],minVal])\\n\\t\\t\\t\\n\\t\\t\\t# get the minimum value before the current index value\\n            minVal = min(minVal,nums[i])\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015318,
                "title": "java-o-1-space-o-n-time-solution-keep-track-of-range",
                "content": "**Intution:**\\n* Left element should be smallest element among three\\n* Middle element should be largest element among three\\n* Right element should be in range from left to middle\\n\\n**Approach:**\\nIf we take any element as middle then:\\n1. we need to find if there is smaller element than that to the left of it.\\n\\t\\t-> This we can find by checking the smallest element till now is less than middle or not. (if yes      then present else not)\\n2. we need element in range from left to middle in the right side of middle\\n\\t\\t-> For this we can take two variables (max_of_range) and (min_of_range) and store the current range in these to check if we can find some element within the range in future (i.e. traversing to the right)\\n\\t\\t\\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min_of_range = Integer.MAX_VALUE; \\n        int max_of_range = Integer.MIN_VALUE;\\n        int left = nums[0]; // left of three elements\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            if(i != nums.length -1 && nums[i] >= min_of_range && nums[i] <= max_of_range) \\n                return true;\\n            \\n            int middle = nums[i];\\n            \\n            // we need to find right in range [left+1, right-1] (inclusive) \\n            if(left + 1 <= middle - 1) { // atleast one element is there to be right \\n                if(left+1 < min_of_range) min_of_range = left+1;\\n                if(middle-1 > max_of_range) max_of_range = middle-1;   \\n            }\\n            \\n            left = Math.min(left, nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int min_of_range = Integer.MAX_VALUE; \\n        int max_of_range = Integer.MIN_VALUE;\\n        int left = nums[0]; // left of three elements\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            if(i != nums.length -1 && nums[i] >= min_of_range && nums[i] <= max_of_range) \\n                return true;\\n            \\n            int middle = nums[i];\\n            \\n            // we need to find right in range [left+1, right-1] (inclusive) \\n            if(left + 1 <= middle - 1) { // atleast one element is there to be right \\n                if(left+1 < min_of_range) min_of_range = left+1;\\n                if(middle-1 > max_of_range) max_of_range = middle-1;   \\n            }\\n            \\n            left = Math.min(left, nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015269,
                "title": "go-stack-easy-to-understand",
                "content": "```\\nfunc find132pattern(nums []int) bool {\\n\\t// init stack\\n\\tstack := []int{}\\n\\tsecond := math.MinInt // Init the second element\\n\\tfor i := len(nums) - 1; i >= 0; i-- {\\n\\t\\tif nums[i] < second { // In this case, nums[i] is the first element\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tfor len(stack) > 0 && nums[i] > stack[len(stack)-1] {\\n\\t\\t\\tsecond = stack[len(stack)-1] // Override second by Top stack\\n\\t\\t\\tstack = stack[:len(stack)-1] // Pop stack\\n\\t\\t}\\n\\t\\tstack = append(stack, nums[i]) // Push nums[i] to stack\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc find132pattern(nums []int) bool {\\n\\t// init stack\\n\\tstack := []int{}\\n\\tsecond := math.MinInt // Init the second element\\n\\tfor i := len(nums) - 1; i >= 0; i-- {\\n\\t\\tif nums[i] < second { // In this case, nums[i] is the first element\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tfor len(stack) > 0 && nums[i] > stack[len(stack)-1] {\\n\\t\\t\\tsecond = stack[len(stack)-1] // Override second by Top stack\\n\\t\\t\\tstack = stack[:len(stack)-1] // Pop stack\\n\\t\\t}\\n\\t\\tstack = append(stack, nums[i]) // Push nums[i] to stack\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015265,
                "title": "java-easy-to-understand-using-stack-beginner-friendly",
                "content": "```\\nclass Solution {\\n\\n    public boolean find132pattern(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[0] = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)\\n            min[i] = Math.min(min[i-1],nums[i]);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int j=nums.length-1;j>=0;j--)\\n        {\\n            while(st.size()>0 && st.peek() <= min[j])\\n                st.pop();\\n            if(st.size() > 0 && st.peek() < nums[j])\\n                return true;\\n            st.push(nums[j]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean find132pattern(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[0] = nums[0];\\n        \\n        for(int i=1;i<nums.length;i++)\\n            min[i] = Math.min(min[i-1],nums[i]);\\n        \\n        Stack<Integer> st = new Stack<>();\\n        \\n        for(int j=nums.length-1;j>=0;j--)\\n        {\\n            while(st.size()>0 && st.peek() <= min[j])\\n                st.pop();\\n            if(st.size() > 0 && st.peek() < nums[j])\\n                return true;\\n            st.push(nums[j]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015075,
                "title": "easy-java-solution-beat-100-in-time-and-93-9-in-space",
                "content": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int second=Integer.MIN_VALUE;\\n        int index=nums.length; //using nums itself as the stack (bottom on the right end)\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]<second) return true;\\n            else while(index<nums.length && nums[i]>nums[index]) second=nums[index++];\\n            nums[--index]=nums[i];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int second=Integer.MIN_VALUE;\\n        int index=nums.length; //using nums itself as the stack (bottom on the right end)\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i]<second) return true;\\n            else while(index<nums.length && nums[i]>nums[index]) second=nums[index++];\\n            nums[--index]=nums[i];\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011483,
                "title": "easy-c-solution-time-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> minval(n);\\n        minval[0] = nums[0];\\n        for(int i = 1; i<n; i++){\\n           minval[i] = min(nums[i], minval[i-1]);  \\n        }\\n        stack<int> st;\\n        for(int j = n - 1; j>=0; j--){\\n            while(!st.empty() && st.top() <= minval[j]) st.pop();\\n            if(!st.empty() && st.top() < nums[j]){\\n                return true;\\n            }\\n            st.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> minval(n);\\n        minval[0] = nums[0];\\n        for(int i = 1; i<n; i++){\\n           minval[i] = min(nums[i], minval[i-1]);  \\n        }\\n        stack<int> st;\\n        for(int j = n - 1; j>=0; j--){\\n            while(!st.empty() && st.top() <= minval[j]) st.pop();\\n            if(!st.empty() && st.top() < nums[j]){\\n                return true;\\n            }\\n            st.push(nums[j]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984301,
                "title": "c-132-pattern-easy-and-simple-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        //prefix min\\n        \\n        vector<int> premn(nums.size());\\n        premn[0]=nums[0];\\n        \\n        \\n        \\n        //finding prefix min\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<premn[i-1]){\\n                premn[i]=nums[i];\\n            }else{\\n                premn[i]=premn[i-1];\\n            }\\n        }\\n        \\n        //stack to hold large value\\n        stack<int> stk;\\n        stk.push(0);\\n        for(int i =1; i<nums.size(); i++) {\\n            while(!stk.empty() && nums[stk.top()] <= nums[i]) {\\n                stk.pop();\\n            }\\n            if(!stk.empty()) { //exist a larger element nums[j]\\n                if(premn[stk.top()] < nums[i]) {\\n                    return true;\\n                }\\n            }\\n            stk.push(i);\\n        }\\n        return false;\\n    }\\n};\\n```\\n### if you like it upvote it",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        //prefix min\\n        \\n        vector<int> premn(nums.size());\\n        premn[0]=nums[0];\\n        \\n        \\n        \\n        //finding prefix min\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<premn[i-1]){\\n                premn[i]=nums[i];\\n            }else{\\n                premn[i]=premn[i-1];\\n            }\\n        }\\n        \\n        //stack to hold large value\\n        stack<int> stk;\\n        stk.push(0);\\n        for(int i =1; i<nums.size(); i++) {\\n            while(!stk.empty() && nums[stk.top()] <= nums[i]) {\\n                stk.pop();\\n            }\\n            if(!stk.empty()) { //exist a larger element nums[j]\\n                if(premn[stk.top()] < nums[i]) {\\n                    return true;\\n                }\\n            }\\n            stk.push(i);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793939,
                "title": "cpp-code-with-o-n-aux-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int> stack;\\n        int mini =  INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums [i] < mini)\\n                return true;\\n            while (stack.size() >0 && nums [i] > stack.top()){\\n                mini = stack.top ();\\n                stack.pop();\\n            }\\n                \\n            stack.push (nums [i]);\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        stack <int> stack;\\n        int mini =  INT_MIN;\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            if (nums [i] < mini)\\n                return true;\\n            while (stack.size() >0 && nums [i] > stack.top()){\\n                mini = stack.top ();\\n                stack.pop();\\n            }\\n                \\n            stack.push (nums [i]);\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427513,
                "title": "easy-c-solution-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& arr) {\\n        \\n        bool flag=false;\\n        \\n        int n=arr.size();\\n        \\n        vector<int>prefixMini(n);\\n        prefixMini[0]=arr[0];\\n        \\n        for(int i=1;i<n;i++) prefixMini[i]=min(prefixMini[i-1],arr[i]);\\n        \\n        stack<int>s;\\n        \\n        for(int j=n-1;j>=0;j--){\\n            \\n            while(s.size() > 0 && s.top() <= prefixMini[j])  // its  basically i\\n                s.pop();\\n            \\n            if(s.size() > 0  && s.top() < arr[j]) flag=true; //this is for k\\n            \\n            s.push(arr[j]);\\n        }\\n        \\n        return flag;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool find132pattern(vector<int>& arr) {\\n        \\n        bool flag=false;\\n        \\n        int n=arr.size();\\n        \\n        vector<int>prefixMini(n);\\n        prefixMini[0]=arr[0];\\n        \\n        for(int i=1;i<n;i++) prefixMini[i]=min(prefixMini[i-1],arr[i]);\\n        \\n        stack<int>s;\\n        \\n        for(int j=n-1;j>=0;j--){\\n            \\n            while(s.size() > 0 && s.top() <= prefixMini[j])  // its  basically i\\n                s.pop();\\n            \\n            if(s.size() > 0  && s.top() < arr[j]) flag=true; //this is for k\\n            \\n            s.push(arr[j]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1426801,
                "title": "stack-java-solution-detail-explanation",
                "content": "Hello,\\nSo , The main idea is that we want to find three elements with `nums[i] < nums[k] < nums[ j] ` the one thing is ith element will be less than the kth and jth elements.\\n\\nSo we create a min array to store minimum untill whatever the current position in our array.\\n\\nWe start from the end of array and we take pointer j (you can take anything) then check if elements present in stack are less than the minimum element upto that jth element then we simply remove them because that element can never statisfy our main condition. Now we compare the element remaining in stack with the jth element and if its less than jth element that means it is greater than the minimum elment upto jth element and less then current jth element so our condition is satisfied as the stack element is the kth element  and we return true otherwise we simply push it in our stack. \\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int length = nums.length;\\n        \\n        // for creating the min array\\n        int[] min_arr = new int[length];\\n        min_arr[0] = nums[0];\\n        for(int i = 1;i<length;i++){\\n            min_arr[i] = Math.min( min_arr[i-1] , nums[i] );\\n        }\\n        \\n        \\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for( int j = length-1; j>=0 ; j--){\\n            int val = nums[j];\\n            \\n            // values in stack smaller than min values till current j pointer are useless as they are never going to become larger.\\n            while( !stack.isEmpty() && stack.peek() <= min_arr[j] ){\\n                stack.pop();\\n            }\\n            \\n            // there are still values larger than the minimum at the current j and now we check if the current value is greater than stacks peek value which are nothing but k and current is j.\\n            if( !stack.isEmpty()  && stack.peek() < val ) return true;\\n            \\n            stack.push( val );\\n            \\n        }\\n        \\n        // at the very end we simply return false;\\n        return false;\\n    }\\n}\\n```\\n\\nHope this helps\\n\\nThank You",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        int length = nums.length;\\n        \\n        // for creating the min array\\n        int[] min_arr = new int[length];\\n        min_arr[0] = nums[0];\\n        for(int i = 1;i<length;i++){\\n            min_arr[i] = Math.min( min_arr[i-1] , nums[i] );\\n        }\\n        \\n        \\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for( int j = length-1; j>=0 ; j--){\\n            int val = nums[j];\\n            \\n            // values in stack smaller than min values till current j pointer are useless as they are never going to become larger.\\n            while( !stack.isEmpty() && stack.peek() <= min_arr[j] ){\\n                stack.pop();\\n            }\\n            \\n            // there are still values larger than the minimum at the current j and now we check if the current value is greater than stacks peek value which are nothing but k and current is j.\\n            if( !stack.isEmpty()  && stack.peek() < val ) return true;\\n            \\n            stack.push( val );\\n            \\n        }\\n        \\n        // at the very end we simply return false;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226405,
                "title": "stack-js-solution",
                "content": "```\\n/*\\nAt each index i, we want to find if (1) there is a smaller element on the left \\n(2) there is a smaller element on the right (3) the smaller element on the right is greater than the smaller element on the left.\\n\\nHence, for each i, pattern[i] = left[i] !== null && right[i] !== null && left[i] < right[i]\\n\\nleft[i] = the minimum element less than nums[i] on the left \\nright[i] = the maximum element less than nums[i] on the right\\n\\nif there is no element less than nums[i] on the left, left[i] = null\\nif there is no element less than nums[i] on the right, right[i] = null\\n\\nWe can fill left[] easily by keeping track of minimum value from start of array.\\nWe will fill right[] using Stack.\\n*/\\nvar find132pattern = function(nums) {\\n    if (nums === null || nums.length === 0) {\\n        return false;\\n    }\\n    let n = nums.length;\\n    let left = new Array(n).fill(null), min = Infinity;\\n    let right = new Array(n).fill(null);\\n    // fill left[]\\n    for (let i = 0; i < nums.length; i++) {\\n        min = Math.min(min, nums[i]);\\n        if (nums[i] > min) {\\n            left[i] = min;\\n        }\\n    }\\n    // fill right[]\\n    let stack = [];\\n    for (let i = n-1; i >= 0; i--) {\\n        let elem = null;\\n        // we keep a decreasing stack\\n        // this means that this while loop allows us to go through all numbers less than\\n        // current number on the right and hence we can get the maximum less number\\n        while (stack.length > 0 && nums[i] > stack[stack.length-1]) {\\n            if (!elem) elem = stack.pop();\\n            else elem = Math.max(elem, stack.pop());\\n        }\\n        right[i] = elem;\\n        stack.push(nums[i]);\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (left[i] !== null && right[i] !== null && left[i] < right[i]) {\\n            return true;\\n        }\\n    }\\n    return false;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nAt each index i, we want to find if (1) there is a smaller element on the left \\n(2) there is a smaller element on the right (3) the smaller element on the right is greater than the smaller element on the left.\\n\\nHence, for each i, pattern[i] = left[i] !== null && right[i] !== null && left[i] < right[i]\\n\\nleft[i] = the minimum element less than nums[i] on the left \\nright[i] = the maximum element less than nums[i] on the right\\n\\nif there is no element less than nums[i] on the left, left[i] = null\\nif there is no element less than nums[i] on the right, right[i] = null\\n\\nWe can fill left[] easily by keeping track of minimum value from start of array.\\nWe will fill right[] using Stack.\\n*/\\nvar find132pattern = function(nums) {\\n    if (nums === null || nums.length === 0) {\\n        return false;\\n    }\\n    let n = nums.length;\\n    let left = new Array(n).fill(null), min = Infinity;\\n    let right = new Array(n).fill(null);\\n    // fill left[]\\n    for (let i = 0; i < nums.length; i++) {\\n        min = Math.min(min, nums[i]);\\n        if (nums[i] > min) {\\n            left[i] = min;\\n        }\\n    }\\n    // fill right[]\\n    let stack = [];\\n    for (let i = n-1; i >= 0; i--) {\\n        let elem = null;\\n        // we keep a decreasing stack\\n        // this means that this while loop allows us to go through all numbers less than\\n        // current number on the right and hence we can get the maximum less number\\n        while (stack.length > 0 && nums[i] > stack[stack.length-1]) {\\n            if (!elem) elem = stack.pop();\\n            else elem = Math.max(elem, stack.pop());\\n        }\\n        right[i] = elem;\\n        stack.push(nums[i]);\\n    }\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        if (left[i] !== null && right[i] !== null && left[i] < right[i]) {\\n            return true;\\n        }\\n    }\\n    return false;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1184090,
                "title": "c-from-n-2-to-nlogn-all-three-solutions-from-1624ms-to-20ms",
                "content": "```\\n// O(NlogN) Solution Using lower_bound 20ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        set<int> s;\\n        set<int>::iterator it;\\n        for (int i = size - 1; i >= 0; i--) {\\n            s.insert(nums[i]);\\n            it = s.lower_bound(nums[i]);\\n            if (it != s.begin()) {\\n                it--;\\n                nextGreatestSmaller[i] = *it;\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right\\n        int minSoFar = nums[0];\\n        for (int i = 0; i < size - 2; i++) {\\n            minSoFar = min(minSoFar, nums[i]);\\n            if (minSoFar < nextGreatestSmaller[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// O(N^2) + O(N) Solution 792ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        for (int i = 0; i < size; i++) {\\n            int upperBound = nums[i], maxElem = INT_MIN;\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[j] < upperBound && nums[j] > maxElem) {\\n                    maxElem = nums[j];\\n                    nextGreatestSmaller[i] = maxElem;\\n                }\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right\\n        int minSoFar = nums[0];\\n        for (int i = 0; i < size - 2; i++) {\\n            minSoFar = min(minSoFar, nums[i]);\\n            if (minSoFar < nextGreatestSmaller[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// 2*O(N^2) Solution by checking 32 pattern 1624ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        for (int i = 0; i < size; i++) {\\n            int upperBound = nums[i], maxElem = INT_MIN;\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[j] < upperBound && nums[j] > maxElem) {\\n                    maxElem = nums[j];\\n                    nextGreatestSmaller[i] = maxElem;\\n                }\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right in O(N^2) time\\n        for (int i = 0; i < size - 2; i++) {\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[i] < nextGreatestSmaller[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n// O(NlogN) Solution Using lower_bound 20ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        set<int> s;\\n        set<int>::iterator it;\\n        for (int i = size - 1; i >= 0; i--) {\\n            s.insert(nums[i]);\\n            it = s.lower_bound(nums[i]);\\n            if (it != s.begin()) {\\n                it--;\\n                nextGreatestSmaller[i] = *it;\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right\\n        int minSoFar = nums[0];\\n        for (int i = 0; i < size - 2; i++) {\\n            minSoFar = min(minSoFar, nums[i]);\\n            if (minSoFar < nextGreatestSmaller[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// O(N^2) + O(N) Solution 792ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        for (int i = 0; i < size; i++) {\\n            int upperBound = nums[i], maxElem = INT_MIN;\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[j] < upperBound && nums[j] > maxElem) {\\n                    maxElem = nums[j];\\n                    nextGreatestSmaller[i] = maxElem;\\n                }\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right\\n        int minSoFar = nums[0];\\n        for (int i = 0; i < size - 2; i++) {\\n            minSoFar = min(minSoFar, nums[i]);\\n            if (minSoFar < nextGreatestSmaller[i + 1]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// 2*O(N^2) Solution by checking 32 pattern 1624ms\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size < 3) {\\n            return false;\\n        }\\n        // Find the biggest element smaller than current (32 pattern) in O(N^2) time\\n        vector<int> nextGreatestSmaller(size, INT_MIN);\\n        for (int i = 0; i < size; i++) {\\n            int upperBound = nums[i], maxElem = INT_MIN;\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[j] < upperBound && nums[j] > maxElem) {\\n                    maxElem = nums[j];\\n                    nextGreatestSmaller[i] = maxElem;\\n                }\\n            }\\n        }\\n        // Find if there exists any 32 pattern on my right in O(N^2) time\\n        for (int i = 0; i < size - 2; i++) {\\n            for (int j = i + 1; j < size; j++) {\\n                if (nums[i] < nextGreatestSmaller[j]) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172255,
                "title": "python-o-n-solution-detailed-explanation",
                "content": "**Problem Setup:**\\n\\nLet low index (low_i), mid index (mid_i), top index (top_i) define the indicies in the input array nums where low_i < mid_i < top_i\\n\\nLet low = nums[low_i], top = nums[top_i], mid = nums[mid_i]\\n\\nWe then want to find a condition where, low < top < mid or a 132 sequence\\n\\n**Intution:**\\nIf we first find the condition top < mid.  More specifically, we want to find the place where top is at a maximum given this condition because we need to also satisify the condition low < top.  The maximum top gives us the largest range of candidates for low.\\n\\n**Implementation:**\\nWe start from the end of the array and work backward, to find the condition where top < mid.\\n\\nWe will use a stack to keep track of all of the elements seen.  We look for the condition where the current element is larger than the top element in the stack, which indicates the top < mid condition (since values in the stack contain values with indicies greater than the current element).  \\nTo ensure that we get the element where top < mid AND mid is as big as possible, we will conntinually pop the stack until the top of the stack is no longer less than the current element.  We then set the last value popped to the variable top.\\n\\nWe then append the current value to the stack.  In this way our stack is always in decreasing order (since we\\'ve popped all elements which are less than that put stop short of when the top of the stack is equal to or greater than the current element).\\n\\nWe then continue on comparing this value found to new elements at the beginning of nums.  If we find a value that is lower than top, then the property low < top holds, we also know that top < mid hold as demonstrated above. Therefore we have found the place where low < top < mid. The 132 sequence.\\n\\n\\n```\\nclass Solution:\\n    \\n    def find132pattern(self, nums) -> bool:\\n        stk = []\\n        top = -float(\"inf\")\\n        \\n        for i in range(len(nums) -1, -1, -1):\\n            if top > nums[i]:\\n                return True\\n            \\n            while(len(stk) and nums[i] > stk[len(stk) -1]):\\n                top = stk.pop()\\n            stk.append(nums[i])\\n        return False",
                "solutionTags": [],
                "code": "**Problem Setup:**\\n\\nLet low index (low_i), mid index (mid_i), top index (top_i) define the indicies in the input array nums where low_i < mid_i < top_i\\n\\nLet low = nums[low_i], top = nums[top_i], mid = nums[mid_i]\\n\\nWe then want to find a condition where, low < top < mid or a 132 sequence\\n\\n**Intution:**\\nIf we first find the condition top < mid.  More specifically, we want to find the place where top is at a maximum given this condition because we need to also satisify the condition low < top.  The maximum top gives us the largest range of candidates for low.\\n\\n**Implementation:**\\nWe start from the end of the array and work backward, to find the condition where top < mid.\\n\\nWe will use a stack to keep track of all of the elements seen.  We look for the condition where the current element is larger than the top element in the stack, which indicates the top < mid condition (since values in the stack contain values with indicies greater than the current element).  \\nTo ensure that we get the element where top < mid AND mid is as big as possible, we will conntinually pop the stack until the top of the stack is no longer less than the current element.  We then set the last value popped to the variable top.\\n\\nWe then append the current value to the stack.  In this way our stack is always in decreasing order (since we\\'ve popped all elements which are less than that put stop short of when the top of the stack is equal to or greater than the current element).\\n\\nWe then continue on comparing this value found to new elements at the beginning of nums.  If we find a value that is lower than top, then the property low < top holds, we also know that top < mid hold as demonstrated above. Therefore we have found the place where low < top < mid. The 132 sequence.\\n\\n\\n```\\nclass Solution:\\n    \\n    def find132pattern(self, nums) -> bool:\\n        stk = []\\n        top = -float(\"inf\")\\n        \\n        for i in range(len(nums) -1, -1, -1):\\n            if top > nums[i]:\\n                return True\\n            \\n            while(len(stk) and nums[i] > stk[len(stk) -1]):\\n                top = stk.pop()\\n            stk.append(nums[i])\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1163466,
                "title": "java-using-stack-4ms",
                "content": "```\\nclass Solution {\\n     public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stk = new Stack<>();\\n        int var = Integer.MIN_VALUE;\\n         \\n        for(int i = nums.length-1; i >= 0; i--){\\n            if(nums[i] < var) return true;\\n            \\n            while(!stk.isEmpty() && stk.peek() < nums[i]){\\n                var = stk.pop();\\n            }\\n            \\n            stk.push(nums[i]);\\n        } \\n         \\n        return false; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public boolean find132pattern(int[] nums) {\\n        Stack<Integer> stk = new Stack<>();\\n        int var = Integer.MIN_VALUE;\\n         \\n        for(int i = nums.length-1; i >= 0; i--){\\n            if(nums[i] < var) return true;\\n            \\n            while(!stk.isEmpty() && stk.peek() < nums[i]){\\n                var = stk.pop();\\n            }\\n            \\n            stk.push(nums[i]);\\n        } \\n         \\n        return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954237,
                "title": "easy-stack-solution-video-explanation",
                "content": "Link to Video:-\\n\\n\\n\\n```\\n bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> leftMin(n);\\n        leftMin[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            leftMin[i] = min(leftMin[i-1],nums[i]);\\n        }\\n        \\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i] > leftMin[i]){\\n                while(!s.empty() && s.top() <= leftMin[i]) s.pop();\\n                if(!s.empty() && s.top() < nums[i]){\\n                    return true;\\n                }\\n                s.push(nums[i]);\\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> leftMin(n);\\n        leftMin[0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            leftMin[i] = min(leftMin[i-1],nums[i]);\\n        }\\n        \\n        stack<int> s;\\n        for(int i=n-1;i>=0;i--){\\n            if(nums[i] > leftMin[i]){\\n                while(!s.empty() && s.top() <= leftMin[i]) s.pop();\\n                if(!s.empty() && s.top() < nums[i]){\\n                    return true;\\n                }\\n                s.push(nums[i]);\\n            }\\n            \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 908152,
                "title": "c-array-based-solution-100-time-faster-code-submitted-10-space",
                "content": "This is a nice, albeit tricky problem, since it is not super-easy to spot that it boils down to one of those interval-based problems you might have already solved.\\n\\nIn order to have a proper perspective, you need to parse through the vector linearly and gradually build your own interval(s), then return when you find a value that would fit in - it would be the `3` between your `1` (beginning/minimum of the interval) and the `2` (the end/maximum of the interval).\\n\\nNow, the difficult part is to get this information down; you might create another support data structure, like an array of `<value, position>` pairs to be sorted, but that is a bit more complex than just going linearly and storing info as we go; and then more magic later, but one step at a time.\\n\\nFirst of all, recap of the variables we will need, provided the input is long at least `3` elements (otherwise we just return `false`):\\n* `len` will store the aforementioned length of the input vector;\\n* `minValues` and `s`, arrays to store our minimum and on going relative maximum;\\n* `pos` , a variable that will allow us to use `s` as a much more efficient stack.\\n\\nFirst of all we are going to populate `minValues` with all the minimum values encountered so far, proceeding from the left, so that for example, given as an input `[3,4,6,7,8,2,1,3]` your array will be `{3, 3, 3, 3, 3, 2, 1, 1}`. This is going to be our `1` into a `132` pattern.\\n\\nNow, for the hard part: we will start hunting for our `3` and then `2` in the `132` pattern, this time starting from the right and, only if the current number `nums[i]` is greater than the stored minimum `minValues[i]`, we proceed like this:\\n* for each number, we will remove all the previous numbers in our \"stack\" that are smaller than the matching local minimum at index `i`, provided we have any number stored at all - notice that since we use an array for this, we will just have to check if `pos` is `!= 0` (ie: we have numbers in stack) and in case decrease it as a cheap equivalent to popping;\\n* if by then we will still have at least one element in stack, it will mean that we encountered a number bigger than our current one - that implies that the number in the stack is going to be our `2` and the current one is our `3`: if our `3` is also bigger than the minimum to this point, we are set - but we know that from the very beginning, since we checked in our `if` statement that `nums[i] > minValues[i]`;\\n* otherwise, we push the current value in our \"stack\" and move on.\\n\\nIn the previous case, we will have again `[3,4,6,7,8,2,1,3]` as an input and `{3, 3, 3, 3, 3, 2, 1, 1}` in `minValues`.\\n\\nWe start looping and since our \"stack\" is empty, nothing we can remove and we put `3` there.\\n\\nThe following `1` is not greater than the value stored in the matching position in `minValues`, so we do nothing and same for `2`.\\n\\n`8` instead will help us proceed: we remove the previous top of the \"stack\", `3`, and store `8` there.\\n\\nFinally we move to `7`, which is both greater than the matching minimm (`3`) and less than the top of the stack (`8`), so we can return `true` :)\\n\\nIf we reach the end of the loop, clearly no number matched our need and we return `false` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if (nums.size() < 3) return false;\\n        // support variables\\n        int len = nums.size(), minValues[len], s[len], pos = 0;\\n        minValues[0] = nums[0];\\n        // populating minValues\\n        for(int i = 1; i < len; i++) minValues[i] = min(minValues[i - 1], nums[i]);\\n        // parsing the vector again from the left to store values v > minValues[i] and v < nums[i]\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (nums[i] > minValues[i]) {\\n                // clearing the \"stack\" from smaller values\\n                while (pos && s[pos - 1] <= minValues[i]) pos--;\\n                if (pos && s[pos - 1] < nums[i]) return true;\\n                s[pos++] = nums[i];\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if (nums.size() < 3) return false;\\n        // support variables\\n        int len = nums.size(), minValues[len], s[len], pos = 0;\\n        minValues[0] = nums[0];\\n        // populating minValues\\n        for(int i = 1; i < len; i++) minValues[i] = min(minValues[i - 1], nums[i]);\\n        // parsing the vector again from the left to store values v > minValues[i] and v < nums[i]\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (nums[i] > minValues[i]) {\\n                // clearing the \"stack\" from smaller values\\n                while (pos && s[pos - 1] <= minValues[i]) pos--;\\n                if (pos && s[pos - 1] < nums[i]) return true;\\n                s[pos++] = nums[i];\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907447,
                "title": "java-solution-using-stack-easy",
                "content": "```\\npublic boolean find132pattern(int[] nums) {\\n        \\n        if(nums.length < 3)\\n            return false;\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int minValue = Integer.MIN_VALUE;\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i] < minValue)\\n                return true;\\n            while(!stack.isEmpty() && nums[i] > stack.peek())\\n                minValue = stack.pop();\\n            \\n            stack.push(nums[i]);\\n        }\\n\\n        return false;\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean find132pattern(int[] nums) {\\n        \\n        if(nums.length < 3)\\n            return false;\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int minValue = Integer.MIN_VALUE;\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums[i] < minValue)\\n                return true;\\n            while(!stack.isEmpty() && nums[i] > stack.peek())\\n                minValue = stack.pop();\\n            \\n            stack.push(nums[i]);\\n        }\\n\\n        return false;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 907168,
                "title": "need-help-c-my-bad-1500ms-t-o-nlogn-s-o-n-solution-based-on-binary-search",
                "content": "Please give me some advice to boost it.\\nI dont get it why it costs ~1500ms though its complexity is T:O(nlogn) :(\\n```\\n/*\\n    Use a stack to record ascending order and a local min.\\n    See if the incoming num is in the range of [local min, s.top()]\\n    T:O(n)/S:O(n)\\n    FAIL case: [3,5,0,3,4]\\n    -----\\n    AC, record every ascending region and binary search on these regions\\n    T(n) = log1 + ... + log(n/2) = O(nlogn)\\n    S: O(n)\\n*/\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        if (n<=2) return false;\\n        set<vector<int>> regions;\\n        vector<int> region{nums[0],nums[0]};\\n        auto cmp = [](int val, auto r){\\n            return r[0]<val;\\n        };\\n        auto cmp2 = [](auto r, int val){\\n            return r[1]<val;\\n        };\\n        for (int i=1; i<n; ++i) {\\n            if (nums[i]>=region[1]) region[1]=nums[i];\\n            else {\\n                if (region[0]<region[1]) regions.insert(region);\\n                region[0]=region[1]=nums[i];\\n            }\\n            auto it=upper_bound(regions.begin(),regions.end(),nums[i],cmp);\\n            if(it!=regions.end()) it=next(it,1);\\n            it=lower_bound(regions.begin(),it,nums[i],cmp2);\\n            if (it!=regions.end()&&nums[i]<(*it)[1]&&nums[i]>(*it)[0])\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Use a stack to record ascending order and a local min.\\n    See if the incoming num is in the range of [local min, s.top()]\\n    T:O(n)/S:O(n)\\n    FAIL case: [3,5,0,3,4]\\n    -----\\n    AC, record every ascending region and binary search on these regions\\n    T(n) = log1 + ... + log(n/2) = O(nlogn)\\n    S: O(n)\\n*/\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        if (n<=2) return false;\\n        set<vector<int>> regions;\\n        vector<int> region{nums[0],nums[0]};\\n        auto cmp = [](int val, auto r){\\n            return r[0]<val;\\n        };\\n        auto cmp2 = [](auto r, int val){\\n            return r[1]<val;\\n        };\\n        for (int i=1; i<n; ++i) {\\n            if (nums[i]>=region[1]) region[1]=nums[i];\\n            else {\\n                if (region[0]<region[1]) regions.insert(region);\\n                region[0]=region[1]=nums[i];\\n            }\\n            auto it=upper_bound(regions.begin(),regions.end(),nums[i],cmp);\\n            if(it!=regions.end()) it=next(it,1);\\n            it=lower_bound(regions.begin(),it,nums[i],cmp2);\\n            if (it!=regions.end()&&nums[i]<(*it)[1]&&nums[i]>(*it)[0])\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906945,
                "title": "python-stack-of-intervals-o-n-98",
                "content": "The idea is to keep track of non-overlapping intervals, such that each next interval ends before the start of the previous one.\\nEach next value in an array might either add a new interval when the value is smallest seen so far, or update an interval already in stack.\\nWe maintain consistency of a stack, and compress it while also checking if the solution was found:\\n```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n\\tif len(nums) < 3: return False  # impossible\\n\\tranges = [[nums[0], None]]\\n\\n\\tdef compress_and_check():\\n\\t\\t\\'\\'\\'will try to compress the ranges, return True if the pattern is found\\'\\'\\'\\n\\t\\tlast_x, last_y = ranges.pop()\\n\\t\\twhile ranges:\\n\\t\\t\\tprev_x, prev_y = ranges[-1]\\n\\t\\t\\tif prev_x > last_y: break\\n\\t\\t\\tif prev_x == last_y: \\n\\t\\t\\t\\tranges[-1][0] = last_x\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif last_y < prev_y:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tranges.pop()\\n\\n\\t\\tranges.append([last_x, last_y])\\n\\t\\treturn False\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tv = nums[i]\\n\\n\\t\\tif ranges[-1][1] is None:  # last range is open (only min value present)\\n\\t\\t\\tif v > ranges[-1][0]: \\n\\t\\t\\t\\tranges[-1][1] = v\\n\\t\\t\\t\\tif compress_and_check(): return True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tranges[-1][0] = v\\n\\t\\telse:\\n\\t\\t\\tif v in ranges[-1]: continue  # on the border => ignore\\n\\t\\t\\telif v < ranges[-1][0]: ranges.append([v, None])  # new range\\n\\t\\t\\telif v < ranges[-1][1]: return True  # solution found\\n\\t\\t\\telse:  # update the range, compress\\n\\t\\t\\t\\tranges[-1][1] = v\\n\\t\\t\\t\\tif compress_and_check(): return True\\n\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n\\tif len(nums) < 3: return False  # impossible\\n\\tranges = [[nums[0], None]]\\n\\n\\tdef compress_and_check():\\n\\t\\t\\'\\'\\'will try to compress the ranges, return True if the pattern is found\\'\\'\\'\\n\\t\\tlast_x, last_y = ranges.pop()\\n\\t\\twhile ranges:\\n\\t\\t\\tprev_x, prev_y = ranges[-1]\\n\\t\\t\\tif prev_x > last_y: break\\n\\t\\t\\tif prev_x == last_y: \\n\\t\\t\\t\\tranges[-1][0] = last_x\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tif last_y < prev_y:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tranges.pop()\\n\\n\\t\\tranges.append([last_x, last_y])\\n\\t\\treturn False\\n\\n\\tfor i in range(1, len(nums)):\\n\\t\\tv = nums[i]\\n\\n\\t\\tif ranges[-1][1] is None:  # last range is open (only min value present)\\n\\t\\t\\tif v > ranges[-1][0]: \\n\\t\\t\\t\\tranges[-1][1] = v\\n\\t\\t\\t\\tif compress_and_check(): return True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tranges[-1][0] = v\\n\\t\\telse:\\n\\t\\t\\tif v in ranges[-1]: continue  # on the border => ignore\\n\\t\\t\\telif v < ranges[-1][0]: ranges.append([v, None])  # new range\\n\\t\\t\\telif v < ranges[-1][1]: return True  # solution found\\n\\t\\t\\telse:  # update the range, compress\\n\\t\\t\\t\\tranges[-1][1] = v\\n\\t\\t\\t\\tif compress_and_check(): return True\\n\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 747871,
                "title": "c-using-set",
                "content": "Maintaining a prefix array of smallest number so far.\\n```c++\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return false;\\n        vector<int> preSmall(n);\\n        preSmall[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            preSmall[i]=min(preSmall[i-1],nums[i]);\\n        set<int> s;\\n        s.insert(nums[n-1]);\\n        for(int i=n-2;i>=1;i--)\\n        {\\n            auto it=s.upper_bound(preSmall[i-1]);\\n            if(it!=s.end() and *it<nums[i])\\n                return true;\\n            s.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return false;\\n        vector<int> preSmall(n);\\n        preSmall[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            preSmall[i]=min(preSmall[i-1],nums[i]);\\n        set<int> s;\\n        s.insert(nums[n-1]);\\n        for(int i=n-2;i>=1;i--)\\n        {\\n            auto it=s.upper_bound(preSmall[i-1]);\\n            if(it!=s.end() and *it<nums[i])\\n                return true;\\n            s.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739438,
                "title": "js-easy-understand-elegant-solution",
                "content": "### Idea\\n> **\\u601D\\u8DEF\\u6BD4\\u8F83\\u5DE7\\u5999\\u3002\\u7EF4\\u62A4\\u4E00\\u4E2A\\u53D8\\u91CF\\u7528\\u4E8E\\u5B58\\u50A8\\u7B2C\\u4E8C\\u5927\\u7684\\u6570 secondNum\\uFF1Bif\\u62E5\\u6709\\u5224\\u65AD\\u662F\\u5426\\u5F53\\u524Dnums[i]\\u5C0F\\u4E8EsecondNum\\uFF0Celse \\u7528\\u4E8E\\u5224\\u65AD\\u66F4\\u65B0 secondNum**\\n- **\\u4E3E\\u4F8B1**\\uFF1Aconst nums = [3, 1, 4, 2]\\n- \\u4E00\\u5F00\\u59CBsecondNum = -Infinity, stack = []\\n- i = 3, nums[i] = 2, \\u653E\\u8FDBstack => stack = [2]\\n- i = 2, nums[i] = 4, \\u8FDB\\u5165else\\u4E2D, \\u6EE1\\u8DB3stack\\u4E2D\\u5B58\\u5728\\u503C && stack[stack.length - 1] = 2 \\u5C0F\\u4E8E nums[i] = 4\\uFF0C\\u66F4\\u65B0secondNum = 2, stack.pop => stack = []\\n- i = 1, nums[i] = 1, \\u8FDB\\u5165if\\u8BED\\u53E5\\uFF0C\\u6EE1\\u8DB3nums[i] < secondNum\\uFF0C\\u8FD4\\u56DEtrue\\n\\n- **\\u4E3E\\u4F8B2**\\uFF1Aconst nums = [1, 2, 3, 4]\\n- i = 3, nums[i] = 4, \\u653E\\u5165stack => stack = [4]\\n- i = 2, nums[i] = 3, \\u4E0D\\u6EE1\\u8DB3if\\u3001else\\u7684\\u6761\\u4EF6\\uFF0C\\u76F4\\u63A5\\u653E\\u5165stack => stack = [4, 3]\\n- i = 1, nums[i] = 2, \\u4E0D\\u6EE1\\u8DB3if\\u3001else\\u7684\\u6761\\u4EF6\\uFF0C\\u76F4\\u63A5\\u653E\\u5165stack => stack = [4, 3, 2]\\n- i = 0, nums[i] = 1, \\u4E0D\\u6EE1\\u8DB3if\\u3001else\\u7684\\u6761\\u4EF6\\uFF0C\\u76F4\\u63A5\\u653E\\u5165stack => stack = [4, 3, 2, 1]\\n- \\u8FD4\\u56DEfalse\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n  if (nums.length < 3) return false\\n  \\n  let secondNum = -Infinity\\n  let stack = []\\n  const len = nums.length\\n  \\n  for (let i = len - 1; i > -1; i--) {\\n    if (nums[i] < secondNum) return true\\n    else {\\n      while (stack.length && stack[stack.length - 1] < nums[i]) {\\n        secondNum = stack.pop()\\n      }\\n    }\\n    stack.push(nums[i])\\n  }\\n  \\n  return false\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar find132pattern = function(nums) {\\n  if (nums.length < 3) return false\\n  \\n  let secondNum = -Infinity\\n  let stack = []\\n  const len = nums.length\\n  \\n  for (let i = len - 1; i > -1; i--) {\\n    if (nums[i] < secondNum) return true\\n    else {\\n      while (stack.length && stack[stack.length - 1] < nums[i]) {\\n        secondNum = stack.pop()\\n      }\\n    }\\n    stack.push(nums[i])\\n  }\\n  \\n  return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736499,
                "title": "java-solution-using-treeset-o-nlogn-time-o-n-space",
                "content": "After having gone through the different solutions posted I didn\\'t see anyone use this so posting this just in case it is easier for someone to understand this.\\n\\nThe idea I came up with is to use a self balancing tree which stores the elements to the right of the current number `(j)` which is our `(k)`. Also instead of creating a min array we can update it on the fly by using a min variable `valPrev` which serves as `(i)` .\\n```\\n    public boolean find132pattern(int[] nums) {\\n        int n  = nums.length;\\n        if (n < 3) return false;\\n        \\n        TreeSet<Integer> ts = new TreeSet<>();\\n        ts.add(nums[n - 1]);\\n        int[] greatestSmallerNext = new int[n];\\n        for (int i = n - 2; i > 0; i--) {            \\n            Integer lower = ts.lower(nums[i]);\\n            if (lower != null) greatestSmallerNext[i] = lower;\\n            else greatestSmallerNext[i] = nums[i];\\n            ts.add(nums[i]);\\n        }\\n        \\n        int valPrev = nums[0];\\n        for (int i = 1; i < n - 1; i++) {\\n            valPrev = nums[i] < valPrev ? nums[i] : valPrev;\\n            if (valPrev < greatestSmallerNext[i] && nums[i] > greatestSmallerNext[i]) {\\n                return true;\\n            }\\n        }        \\n        return false;\\n    }\\n```\\n\\n**Time complexity:** O(nlogn) since retreival from treeset takes log(n) time.\\n**Space complexity:** O(n). We are only using array of size `n` to store the next greatest smaller element.",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\n    public boolean find132pattern(int[] nums) {\\n        int n  = nums.length;\\n        if (n < 3) return false;\\n        \\n        TreeSet<Integer> ts = new TreeSet<>();\\n        ts.add(nums[n - 1]);\\n        int[] greatestSmallerNext = new int[n];\\n        for (int i = n - 2; i > 0; i--) {            \\n            Integer lower = ts.lower(nums[i]);\\n            if (lower != null) greatestSmallerNext[i] = lower;\\n            else greatestSmallerNext[i] = nums[i];\\n            ts.add(nums[i]);\\n        }\\n        \\n        int valPrev = nums[0];\\n        for (int i = 1; i < n - 1; i++) {\\n            valPrev = nums[i] < valPrev ? nums[i] : valPrev;\\n            if (valPrev < greatestSmallerNext[i] && nums[i] > greatestSmallerNext[i]) {\\n                return true;\\n            }\\n        }        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 715558,
                "title": "simple-c-single-stack-solution",
                "content": "Data Structures Used :\\n-> Stack : to keep the values higher than the present val \\n-> vector(array) : to keep the most min value seen till now \\n\\n```\\nbool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        stack<int> S;\\n        vector<int> Min;\\n        int min_now=INT_MAX;\\n        for(int i=0;i<nums.size();++i){\\n            min_now=min(min_now,nums[i]);              // create the min array/vector\\n            Min.push_back(min_now);\\n        }\\n        for(int i=nums.size()-1;i>=0;--i){\\n            if(nums[i]>Min[i])                  // possible i j pair\\n            {\\n\\t\\t\\t\\twhile(!S.empty()&& S.top()<nums[i])          // if stack is not empty and its top value is smaller than the j val\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(S.top()>Min[i])                           // if top val is also smaller than the min val then this is the perfect i j k triplet hence return \\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\tS.pop();                                       // if not then pop the stack to see the next element \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n             S.push(nums[i]);                      // if top of stack is not smaller than j val then just push the j val onto stack \\n            }\\n        }\\n        return false; \\n    }",
                "solutionTags": [],
                "code": "Data Structures Used :\\n-> Stack : to keep the values higher than the present val \\n-> vector(array) : to keep the most min value seen till now \\n\\n```\\nbool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return false;\\n        stack<int> S;\\n        vector<int> Min;\\n        int min_now=INT_MAX;\\n        for(int i=0;i<nums.size();++i){\\n            min_now=min(min_now,nums[i]);              // create the min array/vector\\n            Min.push_back(min_now);\\n        }\\n        for(int i=nums.size()-1;i>=0;--i){\\n            if(nums[i]>Min[i])                  // possible i j pair\\n            {\\n\\t\\t\\t\\twhile(!S.empty()&& S.top()<nums[i])          // if stack is not empty and its top value is smaller than the j val\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(S.top()>Min[i])                           // if top val is also smaller than the min val then this is the perfect i j k triplet hence return \\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\tS.pop();                                       // if not then pop the stack to see the next element \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n             S.push(nums[i]);                      // if top of stack is not smaller than j val then just push the j val onto stack \\n            }\\n        }\\n        return false; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 654329,
                "title": "easy-to-understand-version-with-readable-variables",
                "content": "Simple logic, readable variables. It\\'s not to compete who writes the less lines of code....also confusing variable naming is very bad, which will waste the reader lots of time to understand the problem.\\n\\nLogic\\n1.  define data structure:   int a2, stack a3 and try to find a1.\\n2.  iterate from the end to start, the stack always has the largest number from the current position. So we only need to find the condition that a1 < a2, and a3 is for storing the largest number.\\n\\n```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null  || nums.length <= 2) return false;\\n        Stack<Integer> a3Stack = new Stack<>();\\n        \\n        int a2 = Integer.MIN_VALUE;\\n        for(int i = nums.length-1; i >= 0; i--) {\\n\\t    \\t// current nums[i] could be the candidate of (a1,a3), that\\'s depends on the comparation of a2\\n            if(nums[i] > a2) { // nums[i] is a candidate of a3.\\n\\t\\t\\t    // fine the largest possible value of a2.\\n                while(!a3Stack.isEmpty() && nums[i] > a3Stack.peek()) {\\n                    a2 = a3Stack.pop();\\n                }\\n                // push the current largest number in the a3Stack.\\n                a3Stack.push(nums[i]);\\n            } else if(nums[i] == a2) {\\n                continue;\\n            } else {\\n                //nums[i] < a2; nums[i] is a1 at this moment.\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean find132pattern(int[] nums) {\\n        if(nums == null  || nums.length <= 2) return false;\\n        Stack<Integer> a3Stack = new Stack<>();\\n        \\n        int a2 = Integer.MIN_VALUE;\\n        for(int i = nums.length-1; i >= 0; i--) {\\n\\t    \\t// current nums[i] could be the candidate of (a1,a3), that\\'s depends on the comparation of a2\\n            if(nums[i] > a2) { // nums[i] is a candidate of a3.\\n\\t\\t\\t    // fine the largest possible value of a2.\\n                while(!a3Stack.isEmpty() && nums[i] > a3Stack.peek()) {\\n                    a2 = a3Stack.pop();\\n                }\\n                // push the current largest number in the a3Stack.\\n                a3Stack.push(nums[i]);\\n            } else if(nums[i] == a2) {\\n                continue;\\n            } else {\\n                //nums[i] < a2; nums[i] is a1 at this moment.\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616590,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size(), mn = INT_MAX;\\n        for (int j = 0; j < n; ++j) {\\n            mn = min(mn, nums[j]);\\n            if (mn == nums[j]) continue;\\n            for (int k = n - 1; k > j; --k) {\\n                if (mn < nums[k] && nums[j] > nums[k]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        int n = nums.size(), mn = INT_MAX;\\n        for (int j = 0; j < n; ++j) {\\n            mn = min(mn, nums[j]);\\n            if (mn == nums[j]) continue;\\n            for (int k = n - 1; k > j; --k) {\\n                if (mn < nums[k] && nums[j] > nums[k]) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613848,
                "title": "o-n-forward-iterating-solution-with-no-stack",
                "content": "Similar idea to stack-based solutions, but noting the fact that we only need to use a \"current\" and \"previous\" max S2 value:\\n\\n```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3) return(false);\\n        int i=nums[0], j=INT_MIN, icand=INT_MAX, jcand=INT_MIN;\\n        \\n        for(int p=1;p<nums.size();p++){\\n            if(nums[p]<i) {\\n                icand=min(icand,i);\\n                jcand=max(jcand,j);\\n                i=nums[p];\\n                j=INT_MIN;\\n            }\\n            else if((nums[p]<j && nums[p]>i) || (nums[p]<jcand && nums[p]>icand)){\\n                return(true);\\n            }\\n            else if(nums[p]>i){                \\n                j=max(j,nums[p]);\\n            }            \\n        }\\n        return(false);        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        if(nums.size()<3) return(false);\\n        int i=nums[0], j=INT_MIN, icand=INT_MAX, jcand=INT_MIN;\\n        \\n        for(int p=1;p<nums.size();p++){\\n            if(nums[p]<i) {\\n                icand=min(icand,i);\\n                jcand=max(jcand,j);\\n                i=nums[p];\\n                j=INT_MIN;\\n            }\\n            else if((nums[p]<j && nums[p]>i) || (nums[p]<jcand && nums[p]>icand)){\\n                return(true);\\n            }\\n            else if(nums[p]>i){                \\n                j=max(j,nums[p]);\\n            }            \\n        }\\n        return(false);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556821,
                "title": "easy-to-understand-javascript-code-with-comments",
                "content": "```\\nvar find132pattern = function(nums) {\\n    /*\\n    nums = [1,3,2,4,5]\\n    Idea is to find a number that has min left and 2nd higest min on right of that number\\n    Iterate numbers from the right\\n    Use stack to find 2nd highest min(compare previous number to number in stack - if the previous num is higher then pop() the last value of stack) Ex: pop 2 as 3 > 2 \\n    Compare that 2nd highest min to the num before it, and if that is less than 2nd highest min return true Ex: compare 2 (2nd highest min) to 1. 1< 2 return truw\\n    If none of above onditions meet return false\\n    */\\n    var stack=[], \\n    min = -Infinity;\\n    for(var i=nums.length-1; i>=0; i--){\\n        //Compare that 2nd highest min to the num before it, and if that is less than 2nd highest min return true\\n        if(nums[i] < min) \\n            return true;\\n        else{\\n            //Use stack to find 2nd highest min(compare previous number to number in stack - if the previous num is higher then pop() the last value of stack)\\n            while(stack.length>0 && nums[i]> stack[stack.length-1]){\\n            min = stack.pop();\\n            }\\n            stack.push(nums[i]);\\n        } \\n    }\\n    return false;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar find132pattern = function(nums) {\\n    /*\\n    nums = [1,3,2,4,5]\\n    Idea is to find a number that has min left and 2nd higest min on right of that number\\n    Iterate numbers from the right\\n    Use stack to find 2nd highest min(compare previous number to number in stack - if the previous num is higher then pop() the last value of stack) Ex: pop 2 as 3 > 2 \\n    Compare that 2nd highest min to the num before it, and if that is less than 2nd highest min return true Ex: compare 2 (2nd highest min) to 1. 1< 2 return truw\\n    If none of above onditions meet return false\\n    */\\n    var stack=[], \\n    min = -Infinity;\\n    for(var i=nums.length-1; i>=0; i--){\\n        //Compare that 2nd highest min to the num before it, and if that is less than 2nd highest min return true\\n        if(nums[i] < min) \\n            return true;\\n        else{\\n            //Use stack to find 2nd highest min(compare previous number to number in stack - if the previous num is higher then pop() the last value of stack)\\n            while(stack.length>0 && nums[i]> stack[stack.length-1]){\\n            min = stack.pop();\\n            }\\n            stack.push(nums[i]);\\n        } \\n    }\\n    return false;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 432266,
                "title": "python-different-approach-explained-array-heap-o-n-log-n",
                "content": "In three easy steps:\\n1. Traverse the array starting from the left and for each position of the array store the minimum value seen so far.\\n2. Traverse the array starting from the right storing each seen value in a min_heap. \\n\\t1. While min_heap.top < min[x]: min_heap.pop.\\n\\t2. If at any point min[x] < min_heap.top < nums[x] return True\\n3. Return False if we finished traversing the array\\n\\nLonger explanation:\\nAs the description says we need to find three numbers (i,j,k) on the array that fullfill the next conditions i < j < k and array[i] < array[k] < array[j]. If we focus on the position j we need to find two numbers which have a lower value than the one at position j, being one bigger than the other and, one apearing on before position j and the other one appearing after position j. To compute the lowest value that appears before position j we can use an array to cache the minimum value that appears before position j, that will give us the position i part of the solution. Now, we have to compute another value lower than the one at position j but bigger than the one we set for position i. For that we can use a min heap, if we use use a min_heap traversing the array from right to left we can keep a list of possible candidates of the lowest element bigger than the minimum that appears after position j. \\n\\n```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n            \\n        mins = [float(\\'inf\\')] * len(nums)\\n        mins[0] = nums[0]\\n        for x in range(1, len(nums)):\\n            mins[x] = min(mins[x-1], nums[x])\\n            \\n        min_heap = []\\n        for x in range(len(nums)-1, 0, -1):\\n            heapq.heappush(min_heap, nums[x])\\n            \\n            while min_heap and (min_heap[0] <= mins[x]):\\n                heapq.heappop(min_heap)\\n            \\n            if min_heap and mins[x] < min_heap[0] < nums[x]:\\n                return True\\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef find132pattern(self, nums: List[int]) -> bool:\\n        if not nums:\\n            return False\\n            \\n        mins = [float(\\'inf\\')] * len(nums)\\n        mins[0] = nums[0]\\n        for x in range(1, len(nums)):\\n            mins[x] = min(mins[x-1], nums[x])\\n            \\n        min_heap = []\\n        for x in range(len(nums)-1, 0, -1):\\n            heapq.heappush(min_heap, nums[x])\\n            \\n            while min_heap and (min_heap[0] <= mins[x]):\\n                heapq.heappop(min_heap)\\n            \\n            if min_heap and mins[x] < min_heap[0] < nums[x]:\\n                return True\\n            \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 400774,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Solution1**\\n`minOnLeft[j]` indicates minimum on the left side of `j` (inclusive). [**this will be our a<sub>i</sub>**]\\nWhat we need is some smaller value on left of `j`  (i.e. `minOnLeft[j]`) and some smaller value on right of `j`  but higher than `minOnLeft[j]`.\\n\\nSo we can scan from the back and maintain a stack which just throws away unwanted values i.e. the values that are smaller than even `minOnLeft[j-1]`, then at each `j` [**this will be our a<sub>j</sub>**] we can see if anything remaining on its right in the stack and see if the peek [**this will be our a<sub>k</sub>**] is smaller than `a[j]`\\n\\nTime = `O(n)`\\n\\n```\\npublic boolean find132pattern(int[] a) {\\n        int n = a.length;\\n        if(n < 3) return false;\\n        int[] minOnLeft = new int[n];\\n        minOnLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            minOnLeft[i] = Math.min(a[i], minOnLeft[i-1]);\\n        Stack<Integer> s = new Stack<>();\\n        for(int j=n-1; j > 0; j--){\\n            if(minOnLeft[j-1] < a[j]){\\n                while(!s.isEmpty() && a[s.peek()] <= minOnLeft[j-1])\\n                    s.pop();\\n                if(!s.isEmpty() && a[s.peek()] < a[j])\\n                    return true;\\n                s.push(j);\\n            }\\n        }\\n        return false;\\n    }\\n```\\n**Solution2**\\n`minOnLeft[j]` indicates minimum on the left side of `j` (inclusive).\\nNow, if we mantain a `bst` coming from right, we can search for an element bigger than `minOnLeft[j-1]` in the sorted numbers from bst after `a[j]`.\\n\\nTime = `O(n lgn)`\\n\\n```\\npublic boolean find132pattern(int[] a) {\\n        int n = a.length;\\n        if(n < 3) return false;\\n        int[] minOnLeft = new int[n];\\n        TreeSet<Integer> bst = new TreeSet<>();\\n        minOnLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            minOnLeft[i] = Math.min(a[i], minOnLeft[i-1]);\\n        bst.add(a[n-1]);\\n        for(int j=n-2; j > 0; j--){\\n            TreeSet<Integer> tSet = (TreeSet<Integer>)bst.headSet(a[j]);\\n            if(!tSet.isEmpty() && tSet.higher(minOnLeft[j-1]) != null)\\n                return true;\\n            bst.add(a[j]);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean find132pattern(int[] a) {\\n        int n = a.length;\\n        if(n < 3) return false;\\n        int[] minOnLeft = new int[n];\\n        minOnLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            minOnLeft[i] = Math.min(a[i], minOnLeft[i-1]);\\n        Stack<Integer> s = new Stack<>();\\n        for(int j=n-1; j > 0; j--){\\n            if(minOnLeft[j-1] < a[j]){\\n                while(!s.isEmpty() && a[s.peek()] <= minOnLeft[j-1])\\n                    s.pop();\\n                if(!s.isEmpty() && a[s.peek()] < a[j])\\n                    return true;\\n                s.push(j);\\n            }\\n        }\\n        return false;\\n    }\\n```\n```\\npublic boolean find132pattern(int[] a) {\\n        int n = a.length;\\n        if(n < 3) return false;\\n        int[] minOnLeft = new int[n];\\n        TreeSet<Integer> bst = new TreeSet<>();\\n        minOnLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            minOnLeft[i] = Math.min(a[i], minOnLeft[i-1]);\\n        bst.add(a[n-1]);\\n        for(int j=n-2; j > 0; j--){\\n            TreeSet<Integer> tSet = (TreeSet<Integer>)bst.headSet(a[j]);\\n            if(!tSet.isEmpty() && tSet.higher(minOnLeft[j-1]) != null)\\n                return true;\\n            bst.add(a[j]);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565792,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1565780,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1571713,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1566219,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1566573,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1568699,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1771012,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1569170,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1576745,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1576719,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1565792,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1565780,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1571713,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1566219,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1566573,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1568699,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1771012,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1569170,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1576745,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1576719,
                "content": [
                    {
                        "username": "vyshnavkr",
                        "content": "**Update**:\\nQuestion now seems easy after having practising many problmes with \"**element contrubution approach**\" and \"**fix 1 or 2 ends approach**\".\\n* **element contribution:** see if each element can be the middle element (the 3 in 132 pattern). To be 3, the element needs a smaller element (1 in 132 pattern) to left of it. Immediate implementation coming to mind is a min auxillary array from left to right. After all taking min on left instead of any smaller on left doesn\\'t hurt, instead seems more beneficial considering we have the best smaller possible value.\\n* The above **indirectly makes us fix 2 ends** our problem (All this should come in mind in 2 minutes). Remaining is finding 2 of 132 pattern. Either **for each 3, we can search for a valid 2** (ie, search on right for an element smaller than current but greater than current\\'s min.) This makes it O(n) search for each 3. \\n* Repeated search on right can be replaced by finding a valid 2 on the fly by **traversing from right**. How is this O(1) search for each 3: we just need an element on right between current min and current. Elements smaller than current min are invalid - **the tricky elimination case**, while elements bigger than current are possible 2s for other 3s. Use a stack for this. View LC gif.\\n* Summary:\\n\\t* element contrubution approach\\n\\t* fix start/end/middle approach\\n\\t* traverse from right approach\\n\\t* elimnate invalid case: observe keenly for this\\n\\n**Original**:\\nA Hard Medium! A combo of: min[], think from right for optmizing recomputation, and Next Greater Element pattern. (Whenever the requirement of finding the next greater element or previous smaller element for current element comes OR an increasing/decreasing sequence on an int input array happens - this signals to use NGE pattern. And NGE is done using stack/queue/deque. Stacks are used only for parentheses problems, or FIFO problems or NGE problems)\\n\\nDuring interview, the only way to come up with the Stack approach is (as explained well in  LC) by starting from O(n^3) (3 pointers) to O(n^2) (min variable - for a better range - and to reduce to 2 pointers) to O(n) (to avoid recomputation between 2 pointers, think from right end. This mandates a min[] from left end) and an extra DS.\\n\\nWhile traversing from right, the problem reduces to the Next Greater Element pattern (searching to the left). NGE usually uses stack/queue/deque. Here the insertion and deletion happens only at 1 end - so stack.\\n\\nSome powerful observations when traversing from right;\\n- if stack top element is lower than current min, we no longer need that top element. Because: we will never have a better (lower) min to the left. Min might only increase if not the same min until left end. So a lower top element can never be the \\'2\\' of 132 pattern.\\n- if stack top element is greater than current element, we now have to find NGE for this element. So add it to stack\\n- if stack top element is lower than current element (32 pattern), (and obviously current element should be greater than current min (13 pattern). Else they should be equal (11 pattern) in which case we would already skip the computation for this current element - Another observation), we got the answer 132 pattern.\\n- Current element should be greater than current min. Else they should be equal in which case we should already skip the computation for this current element. Coz we dont get the 13 pattern. It would be 11 pattern.\\n\\n\\n"
                    },
                    {
                        "username": "Petersburg",
                        "content": "Other stack based questions like this are hard (ie the trapping rain water and maximum rectangle in a histogram)"
                    },
                    {
                        "username": "dchug",
                        "content": "My code fails in this test case: \\n\\n[3,5,0,3,4]\\nExpected output: true\\n\\nCan someone show me the 132 pattern in this test case? \\nIf there is none then how can I report it?"
                    },
                    {
                        "username": "tdo1",
                        "content": "[@sb012](/sb012) the condition is i < j < k and i, j, k don\\'t have to be consecutive. "
                    },
                    {
                        "username": "aryan1113",
                        "content": "We have to check for a subsequence, which may or may not be consecutive, so we get 3, then 5, skip on 0 and snip on 3, and get 4.\\n\\nIn this way we get 3 5 4  "
                    },
                    {
                        "username": "k_palod",
                        "content": "[@sb012](/sb012)  They don\\'t necessarily need to be successive. Hope you got it. "
                    },
                    {
                        "username": "sb012",
                        "content": "[@gauravkh](/gauravkh) what do you mean by 3, 5, 4 there are no subsequent elements in that particular order"
                    },
                    {
                        "username": "gauravkh",
                        "content": "3,5,4  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/132-pattern/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 6 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Searching Intervals\n\n  \n**Approach 4:** Stack\n\n  \n**Approach 5:** Binary Search\n\n  \n**Approach 6:** Using Array as a Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AyoubOmari",
                        "content": "I share my whole thinking process that leads to the stack solution in this [article](https://medium.com/brain-framework/132-pattern-1b890c763bd5). Hope it helps !"
                    },
                    {
                        "username": "Ashwin_4u",
                        "content": "I do not understand the point of these kind of questions..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "This question should be marked as hard.... because of the time complexity constraint as well.... The O(nlogn) approach also dont work.."
                    },
                    {
                        "username": "WorldHello",
                        "content": "In the following scenario, the expected output should be TRUE right ? Because of  \" 0, 1, -4 \" sequence.\\n\\nInput:\\n[1,0,1,-4,-3]\\nMy Output:\\ntrue\\nExpected Output:\\nfalse"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "here -4 is not greater than 0, so expected output is false"
                    },
                    {
                        "username": "Nitesh987",
                        "content": "nums[i ]should be less than nums[j]"
                    },
                    {
                        "username": "dkashi",
                        "content": "nums[k] should lie between nums[i] and nums[j]. In this case -4(nums[k] is less than 0(nums[i]) "
                    },
                    {
                        "username": "peace4world",
                        "content": "# Why is the monotonic stack solution correct?\\nWhy is this solution correct?\\nFirst thing first, thank you for all the great contents. Very impressed by the amount of effort that you are putting into this.\\n\\nI\\'m still trying to grasp how to use the monotonic stack to solve such problems. I wish you could elaborate more on the algorithmic part of the solution. The explanation is great for the implementation part. It wasn\\'t clear to me \"why this solution is correct?\"\\n\\nBelow are some questions that I wanted to know the answer for. I am also adding the answers that I came up with. (I like to get other\\'s opinions on my thoughts.)\\n\\n1. Is the current element in the loop \"potential nums[j]\" or \"potential nums[k]\"? The latter. (It took me a while to figure this out! ;-) )\\n\\n2. Meanwhile we are using a decreasing monotonic stack to keep track of *some* intervals. What is the rational behind choosing this data structure? What intervals exactly is this data structure keeping track of? My understanding is that these are the intervals that a valid nums[k] should fall in. That\\'s why I added this condition \"if min_left<n:\" for appending any interval to the stack. My code with this tweak passed all the test cases. Without this condition we were adding some irrelevant items into stack just to throw them away later.\\n\\nif min_left<n:\\n    stack.append([n,min_left])\\n\\n3. It\\'s clear that the start of the interval should be the min_left (which is potential nums[i]) and the end of interval is potential nums[j]. But why we care about *some* intervals and keep them in the stack, but we through away others? I see that whenever we come across an interval which can be merged with the interval on top of the stack, we pop the top interval and add the wider interval instead if we haven\\'t found the 132-pattern yet. \\n\\n4. How \"decreasing monotonic stack\" helps here? It\\'s doing the job of merging overlapping intervals besides keeping track of the intervals. But how? Left-to-right decreasing monotonic stack has the ability to find the larger number in the right for any elements in the array, that\\'s what it does. So we use that to expand the intervals from right side as we go to the right, and when we encounter this situation the global minimum on the left can be lower-bound of the wider interval.\\n\\n\\n5. Next, let\\'s depict the discussion above with an example.\\n\\n\\tEX - [1,0,1,-4,-3,2,0]\\n\\tPUSH: Parsing nums[2]=1, we add interval [0 , 1] to the stack.\\n\\tPUSH: Parsing nums[4]=-3, we add interval [-4 , -3] to the stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [-4 , -3] from our stack.\\n\\tPOP: nums[5]=2 is larger than top interval\\'s upper-bound, so we can pop [0 , 1] from our stack.\\n\\tPUSH: Parsing nums[5]=2, we add interval [-4 , 2] to the stack.\\n\\tFOUND:  -4 2 0\\n\\n6. So processing one element can have different outcomes:\\n   a. Updating the min, as we see in processing nums[1] and nums[3] in the example.\\n   b. Adding a new interval which happens when the new min is smaller than the previous one and the intervals don\\'t overlap. It happened processing nums[2] and nums[4].\\n   c. Finding a wider interval that includes some of the previous ones. We saw that processing nums[5]\\n   d. Finding the 132-pattern, as it happened processing nums[6]=0\\n\\nI hope this note provokes some discussion around \"why\" this algorithm is correct and how/why/when we are using monotonic stacks."
                    },
                    {
                        "username": "aaolson817",
                        "content": "[3,5,0,3,4] is test case 85/102\\nand it is supposed to evaluate to True, but I don\\'t understand why.\\n\\n![image](https://assets.leetcode.com/users/images/eace7afd-8abd-4632-931f-f99536eca5a3_1651897292.5660925.png)\\n\\n\\nWhat the the 132 sequence here?\\n\\n3,5,0 is wrong because 3 is greater than 0\\n\\n5,0,3 is wrong because 5 is greater than 0 and 3\\n\\n0, 3, 4 is wrong because 3 is greater than 4\\n\\nafter that we are out of numbers."
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "345"
                    },
                    {
                        "username": "Mani0305",
                        "content": "{3,5,4} forms a 132 pattern for the above prblm\\n"
                    },
                    {
                        "username": "sugreem",
                        "content": "3,5,4 true"
                    }
                ]
            },
            {
                "id": 1750935,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1735582,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1574515,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1573720,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1571714,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 2028105,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1973111,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1930386,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1831094,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            },
            {
                "id": 1742918,
                "content": [
                    {
                        "username": "thisannie",
                        "content": "what is 132 pattern in this case [1,4,0,-1,-2,-3,-1,-2] ?"
                    },
                    {
                        "username": "thisannie",
                        "content": "now got it... its [-3 -1 -2]"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Please recommend me similar question to have better grip over the concept. It is like mess for me\\n"
                    },
                    {
                        "username": "Limbobo",
                        "content": "More tasks on Monotonic Stack topic:\\nhttps://leetcode.com/problems/daily-temperatures/\\nhttps://leetcode.com/problems/shortest-unsorted-continuous-subarray/\\nhttps://leetcode.com/problems/next-greater-element-i/\\nhttps://leetcode.com/problems/next-greater-element-ii/\\nhttps://leetcode.com/problems/online-stock-span/\\nhttps://leetcode.com/problems/sum-of-subarray-minimums/\\nhttps://leetcode.com/problems/largest-rectangle-in-histogram/"
                    },
                    {
                        "username": "tonghuikang",
                        "content": "Instead of 132 pattern, how do we solve a problem that asks for 312 pattern, 135246 pattern or permutations from anywhere as short as two numbers to almost as long as the string?"
                    },
                    {
                        "username": "blue_jerry",
                        "content": "can you please suggest some good source to learn ``advance data structures.``\\nThanks in ``advance``"
                    },
                    {
                        "username": "JennyWren",
                        "content": "I was wondering what is the 132 pattern in this test case?\\nThanks"
                    },
                    {
                        "username": "Aditya_Gupta11",
                        "content": "my code fails in this testcase\\n\\nnums =\\n[1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,0,0,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,1,0,1,1,0,1,1,1,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,1,1,1,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0]"
                    },
                    {
                        "username": "pushpak_raj",
                        "content": "93/102 vibes passed but cant find \\n[-2,1,2,-2,1,2]"
                    },
                    {
                        "username": "LakshmanNallam",
                        "content": "-2 2 1"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Can someone help me decreasing its time complexity. 100/102 test cases are getting passed and its showing TLE error for 2 test cases.\\n\\n\\n`\\nclass Solution {\\npublic:\\n    bool find132pattern(vector<int>& nums) {\\n        \\n        if(nums.size()<3)\\n        {\\n            return false;\\n        }\\n        \\n        int flag =0;\\n        for(int i=nums.size()-1;i>0;i--)\\n        {\\n            int uh=0;\\n            flag= 0;\\n            stack<long> lol;\\n\\n            for(int j=i-1;j>=0;j--)\\n            {   \\n                if(lol.empty() && nums[j]>nums[i])\\n                {\\n                    flag++;\\n                    lol.push(j);\\n                }\\n                else if(!lol.empty() && nums[j]>nums[i] && nums[j]>nums[lol.top()] )\\n                {\\n                \\n                    lol.pop();\\n                    lol.push(j);\\n                }\\n                \\n            else if(!lol.empty() && nums[j]<nums[i] && nums[j]<nums[lol.top()] && nums[i]<nums[lol.top()])\\n                {\\n                    lol.pop();\\n                    uh = 1;\\n                }\\n\\n            }\\n    \\n          \\n          \\n          if(lol.empty() && flag!=0)\\n            {\\n                return true;\\n            }\\n          if(uh==1)\\n            {\\n                return true;\\n            }\\n           \\n        }\\n        return false;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "This is def a hard question to come up on your own, but the solution once you get it is pretty satisfying "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "[3,5,0,3,4]\\nWhy is this case False 3,5,4 could be a pattern"
                    }
                ]
            }
        ]
    },
    {
        "title": "Next Greater Element III",
        "question_content": "<p>Given a positive integer <code>n</code>, find <em>the smallest integer which has exactly the same digits existing in the integer</em> <code>n</code> <em>and is greater in value than</em> <code>n</code>. If no such positive integer exists, return <code>-1</code>.</p>\n\n<p><strong>Note</strong> that the returned integer should fit in <strong>32-bit integer</strong>, if there is a valid answer but it does not fit in <strong>32-bit integer</strong>, return <code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> n = 12\n<strong>Output:</strong> 21\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> n = 21\n<strong>Output:</strong> -1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 101824,
                "title": "simple-java-solution-4ms-with-explanation",
                "content": "This solution is just a java version derived from this [post](http://www.geeksforgeeks.org/find-next-greater-number-set-digits/).\\n\\nAt first, lets look at the edge cases -\\n1. If all digits sorted in descending order, then output is always \\u201cNot Possible\\u201d. For example, 4321.\\n2) If all digits are sorted in ascending order, then we need to swap last two digits. For example, 1234.\\n3) For other cases, we need to process the number from rightmost side (why? because we need to find the smallest of all greater numbers)\\n\\nNow the main algorithm works in following steps -\\n\\nI) Traverse the given number from rightmost digit, keep traversing till you find a digit which is smaller than the previously traversed digit. For example, if the input number is \\u201c534976\\u201d, we stop at 4 because 4 is smaller than next digit 9. If we do not find such a digit, then output is \\u201cNot Possible\\u201d.\\n\\nII) Now search the right side of above found digit \\u2018d\\u2019 for the smallest digit greater than \\u2018d\\u2019. For \\u201c53**4**976\\u2033, the right side of 4 contains \\u201c976\\u201d. The smallest digit greater than 4 is **6**.\\n\\nIII) Swap the above found two digits, we get 53**6**97**4** in above example.\\n\\nIV) Now sort all digits from position next to \\u2018d\\u2019 to the end of number. The number that we get after sorting is the output. For above example, we sort digits in bold 536**974**. We get \\u201c536**479**\\u201d which is the next greater number for input 534976.\\n\\n```\\npublic class Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] number = (n + \"\").toCharArray();\\n        \\n        int i, j;\\n        // I) Start from the right most digit and \\n        // find the first digit that is\\n        // smaller than the digit next to it.\\n        for (i = number.length-1; i > 0; i--)\\n            if (number[i-1] < number[i])\\n               break;\\n\\n        // If no such digit is found, its the edge case 1.\\n        if (i == 0)\\n            return -1;\\n            \\n         // II) Find the smallest digit on right side of (i-1)'th \\n         // digit that is greater than number[i-1]\\n        int x = number[i-1], smallest = i;\\n        for (j = i+1; j < number.length; j++)\\n            if (number[j] > x && number[j] <= number[smallest])\\n                smallest = j;\\n        \\n        // III) Swap the above found smallest digit with \\n        // number[i-1]\\n        char temp = number[i-1];\\n        number[i-1] = number[smallest];\\n        number[smallest] = temp;\\n        \\n        // IV) Sort the digits after (i-1) in ascending order\\n        Arrays.sort(number, i, number.length);\\n        \\n        long val = Long.parseLong(new String(number));\\n        return (val <= Integer.MAX_VALUE) ? (int) val : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] number = (n + \"\").toCharArray();\\n        \\n        int i, j;\\n        // I) Start from the right most digit and \\n        // find the first digit that is\\n        // smaller than the digit next to it.\\n        for (i = number.length-1; i > 0; i--)\\n            if (number[i-1] < number[i])\\n               break;\\n\\n        // If no such digit is found, its the edge case 1.\\n        if (i == 0)\\n            return -1;\\n            \\n         // II) Find the smallest digit on right side of (i-1)'th \\n         // digit that is greater than number[i-1]\\n        int x = number[i-1], smallest = i;\\n        for (j = i+1; j < number.length; j++)\\n            if (number[j] > x && number[j] <= number[smallest])\\n                smallest = j;\\n        \\n        // III) Swap the above found smallest digit with \\n        // number[i-1]\\n        char temp = number[i-1];\\n        number[i-1] = number[smallest];\\n        number[smallest] = temp;\\n        \\n        // IV) Sort the digits after (i-1) in ascending order\\n        Arrays.sort(number, i, number.length);\\n        \\n        long val = Long.parseLong(new String(number));\\n        return (val <= Integer.MAX_VALUE) ? (int) val : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983076,
                "title": "python-o-m-solution-explained",
                "content": "Let us start from example and see how our algorithm should work.\\nImaigne `n = 234157641`. Our goal is to find next number with the same digits, which is greater than given one and which is the smallest one. It makes sense to try to take our number as close to original one as possible. Let us try to do it: can it start from `2......`, yes, for example `24...`. Can it start with `2341...`? Yes, it can be `23417...`. Can it start with `23415...`? No, it can not, and the reason, that the rest what we have `7641` already biggest number given digits `7, 6, 4, 1`. \\nSo, we can see now, how our algorithm should work:\\n1. Start from the end and look for increasing pattern, it our case `7641`.\\n2. If it happen, that all number has increasing pattern, there is no bigger number with the same digits, so we can return `-1`.\\n3. Now, we need to find the first digit in our ending, which is less or equal to `digits[i-1]`: we have ending `5 7641` and we are looking for the next number with the same digits. What can go instead of `5`: it is `6`! Let us change these two digits, so we have `6 7541` now. Finally, we need to reverse last ditits to get `6 1457` as our ending.\\n\\n**Complexity**: time complexity is `O(m)`, where `m` is number of digits in our number, space complexity `O(m)` as well.\\n\\n**PS** see also problem **31. Next Permutation**, which uses exactly the same idea.\\n\\n```\\nclass Solution:\\n    def nextGreaterElement(self, n):\\n        digits = list(str(n))\\n        i = len(digits) - 1\\n        while i-1 >= 0 and digits[i] <= digits[i-1]:\\n            i -= 1\\n            \\n        if i == 0: return -1\\n        \\n        j = i\\n        while j+1 < len(digits) and digits[j+1] > digits[i-1]:\\n            j += 1\\n        \\n        digits[i-1], digits[j] = digits[j], digits[i-1]\\n        digits[i:] = digits[i:][::-1]\\n        ret = int(\\'\\'.join(digits))\\n        \\n        return ret if ret < 1<<31 else -1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n):\\n        digits = list(str(n))\\n        i = len(digits) - 1\\n        while i-1 >= 0 and digits[i] <= digits[i-1]:\\n            i -= 1\\n            \\n        if i == 0: return -1\\n        \\n        j = i\\n        while j+1 < len(digits) and digits[j+1] > digits[i-1]:\\n            j += 1\\n        \\n        digits[i-1], digits[j] = digits[j], digits[i-1]\\n        digits[i:] = digits[i:][::-1]\\n        ret = int(\\'\\'.join(digits))\\n        \\n        return ret if ret < 1<<31 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101815,
                "title": "c-4-lines-next-permutation",
                "content": "```\\nint nextGreaterElement(int n) {\\n    auto digits = to_string(n);\\n    next_permutation(begin(digits), end(digits));\\n    auto res = stoll(digits);\\n    return (res > INT_MAX || res <= n) ? -1 : res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint nextGreaterElement(int n) {\\n    auto digits = to_string(n);\\n    next_permutation(begin(digits), end(digits));\\n    auto res = stoll(digits);\\n    return (res > INT_MAX || res <= n) ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101825,
                "title": "c-solution-with-explanation",
                "content": "```\\n/**\\n * 1. a max number has the property of decreasing in every digit: 9876\\n * 2. find the first non-max substring from the right; ex. in 1234(59876), 59876 is the first non-max substring from the right\\n * 3. sort the max part of 5(9876), by reverse, becames 5(6789);\\n * 4. flip 5,6, becames 65789; because 6 is the next smallest digit than 5, in 56789;\\n * 5. incase of 66789, you got flip 6 with 7 to make it 76689, to make it bigger.\\n */\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        if (s.length() == 1) {\\n            return -1;\\n        }\\n        /* find the first decreasing digit from the right, eg: 59876, 5 is the first decreasing digit */\\n        int i = s.length() - 2; // 21 -> i = 0; 59876 -> i = 3\\n        for (; i >= 0 && s[i] >= s[i + 1]; i--) { }\\n        if (i == -1) {  // if a decreasing digit cannot be find, the number cannot be larger.\\n            return -1;\\n        }\\n        reverse(s.begin() + i + 1, s.end());\\n        for (int j = i + 1; j < s.length(); j++) {\\n            if (s[j] > s[i]) {\\n                swap(s[i], s[j]);\\n                break;\\n            }\\n        }\\n        long next = stol(s);\\n        return next == n || next > INT_MAX ? -1 : next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * 1. a max number has the property of decreasing in every digit: 9876\\n * 2. find the first non-max substring from the right; ex. in 1234(59876), 59876 is the first non-max substring from the right\\n * 3. sort the max part of 5(9876), by reverse, becames 5(6789);\\n * 4. flip 5,6, becames 65789; because 6 is the next smallest digit than 5, in 56789;\\n * 5. incase of 66789, you got flip 6 with 7 to make it 76689, to make it bigger.\\n */\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        if (s.length() == 1) {\\n            return -1;\\n        }\\n        /* find the first decreasing digit from the right, eg: 59876, 5 is the first decreasing digit */\\n        int i = s.length() - 2; // 21 -> i = 0; 59876 -> i = 3\\n        for (; i >= 0 && s[i] >= s[i + 1]; i--) { }\\n        if (i == -1) {  // if a decreasing digit cannot be find, the number cannot be larger.\\n            return -1;\\n        }\\n        reverse(s.begin() + i + 1, s.end());\\n        for (int j = i + 1; j < s.length(); j++) {\\n            if (s[j] > s[i]) {\\n                swap(s[i], s[j]);\\n                break;\\n            }\\n        }\\n        long next = stol(s);\\n        return next == n || next > INT_MAX ? -1 : next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983063,
                "title": "c-easy-solution-without-builtin-for-permutations-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool nextPermutation(string& nums) {\\n        int i = nums.size()-1;\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        if (i == 0) return false;\\n        \\n        int j = nums.size()-1;\\n        while (j > 0 && nums[j] <= nums[i-1]) j--;\\n        swap(nums[j], nums[i-1]);\\n        reverse(nums.begin()+i, nums.end());\\n        return true;\\n    }\\n    \\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        bool res = nextPermutation(num);\\n        size_t ans = stoll(num);\\n        return (!res || ans > INT_MAX) ? -1 : ans;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool nextPermutation(string& nums) {\\n        int i = nums.size()-1;\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        if (i == 0) return false;\\n        \\n        int j = nums.size()-1;\\n        while (j > 0 && nums[j] <= nums[i-1]) j--;\\n        swap(nums[j], nums[i-1]);\\n        reverse(nums.begin()+i, nums.end());\\n        return true;\\n    }\\n    \\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        bool res = nextPermutation(num);\\n        size_t ans = stoll(num);\\n        return (!res || ans > INT_MAX) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407530,
                "title": "java-0ms-solution-easy-to-understand-with-explanation",
                "content": "Explanation :-\\nConsider number 6537421 , firstly we convert this number to char array and check from right end \\nif numbers are in increasing order from right side then it means we cannot create a number more than given number because the left number\\'s place value is always more than right one.\\nif there exist a number in array such that it is less than the right value , then we swap the  position of number less than right value , with the number just bigger than that :-\\nhere 6 5 3 7 4 2 1 :- 3 is the first number which is less than right values so swap 3 , 4\\nnow the number becomes 6 5 4 7 3 2 1 :- but this is not the least number , to get least number we reverse the numbers from 7 to 1 ie 7 3 2 1 -> 1 2 3 7 and we add this to existing ans:-\\nfinal answer 6 5 4 1 2 3 7\\n\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char arr[] = (Integer.toString(n)).toCharArray();\\n        \\n        int i=arr.length-2;\\n        StringBuilder ans = new StringBuilder();\\n        while(i>=0 && arr[i] >= arr[i+1])\\n            i--;\\n        \\n        if(i == -1)\\n            return -1;\\n        \\n        int k = arr.length-1;\\n        \\n        while(arr[k] <= arr[i])\\n            k--;\\n        \\n        swap(arr,i,k);\\n        \\n        for(int j=0;j<=i;j++)\\n            ans.append(arr[j]);\\n        \\n        for(int j=arr.length-1;j>i;j--)\\n            ans.append(arr[j]);\\n        \\n        long ans_ = Long.parseLong(ans.toString());\\n        \\n        return (ans_ > Integer.MAX_VALUE) ? -1 : (int)ans_;\\n        \\n        \\n    }\\n    void swap(char[] arr,int i,int j)\\n    {\\n        char temp = arr[j];\\n        arr[j] = arr[i];\\n        arr[i] = temp;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char arr[] = (Integer.toString(n)).toCharArray();\\n        \\n        int i=arr.length-2;\\n        StringBuilder ans = new StringBuilder();\\n        while(i>=0 && arr[i] >= arr[i+1])\\n            i--;\\n        \\n        if(i == -1)\\n            return -1;\\n        \\n        int k = arr.length-1;\\n        \\n        while(arr[k] <= arr[i])\\n            k--;\\n        \\n        swap(arr,i,k);\\n        \\n        for(int j=0;j<=i;j++)\\n            ans.append(arr[j]);\\n        \\n        for(int j=arr.length-1;j>i;j--)\\n            ans.append(arr[j]);\\n        \\n        long ans_ = Long.parseLong(ans.toString());\\n        \\n        return (ans_ > Integer.MAX_VALUE) ? -1 : (int)ans_;\\n        \\n        \\n    }\\n    void swap(char[] arr,int i,int j)\\n    {\\n        char temp = arr[j];\\n        arr[j] = arr[i];\\n        arr[i] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117208,
                "title": "easy-python3-beats-100",
                "content": "```\nclass Solution:\n    def nextGreaterElement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        s = list(map(int, str(n)))\n        i = len(s)-1\n        while i-1>=0 and s[i]<=s[i-1]:\n            i -= 1\n            \n        if i==0:\n            return -1\n        \n        j = i\n        while j+1<len(s) and s[j+1]>s[i-1]:\n            j += 1\n        \n        s[i-1], s[j] = s[j], s[i-1]\n        s[i:] = reversed(s[i:])\n        ret = int(''.join(map(str, s)))\n        \n        return ret if ret<=((1<<31)-1) else -1",
                "solutionTags": [],
                "code": "class Solution:\n    def nextGreaterElement(self, n):\n        s = list(map(int, str(n)))\n        i = len(s)-1\n        while i-1>=0 and s[i]<=s[i-1]:\n            i -= 1\n        if i==0:\n        j = i\n        while j+1<len(s) and s[j+1]>s[i-1]:\n            j += 1\n        s[i-1], s[j] = s[j], s[i-1]\n        s[i:] = reversed(s[i:])\n        ret = int(''.join(map(str, s)))\n        return ret if ret<=((1<<31)-1) else -1",
                "codeTag": "Java"
            },
            {
                "id": 983241,
                "title": "c-no-built-in-solution-explained-100-time-20-space",
                "content": "This is a problem that left me intrigued years ago, so much I even decided to build [a rather successful kata out of it](https://www.codewars.com/kata/55983863da40caa2c900004e/).\\n\\nWhat we need to learn here, IMHO, it is not to go too deep into algorithms and pre-learnt concepts but to ask ourselves how we would solve it as humans.\\n\\nThe trick is to proceed reading digits from the right, until you find a digit which is decreasing: that is where you should act, replacing it with the first previous digit greater than that and then sorting the remaining ones.\\n\\nLet\\'s help ourselves with an example: `12443322`.\\n\\nThe leftmost `2` is the first digit, reading from right, that is not in increasing order, so we replace it with the first previous digit immediately greater than it and then sort all the previously seen digits:\\n\\n```cpp\\n13443222 // after the swap\\n13222344 // after the sorting - hey, that is our solution!\\n```\\n\\nWe do so since that is how you get a lexicographic order of `x` different elements: once all elements up to `y` are sorted in increasing order (reading from the right), that is our last possible permutation with `y` elements, so we need to use more elements to get new permutations. When `x == y`, it means all our elements are already set in the last lexicographic permutation and there is no further option for us to explore, so in this problem we have to return `-1`.\\n\\nLet\\'s check the code to do so; first of all we will declare a support variable, `digits`, to store the digits as we go and conveniently pushed in reversed order (ie: the rightmost digit of the original input `n` will also be the first element in `digits`) and so on.\\n\\nOnce we have reduced `n` to `0` (ie: no more digits to extract from it), we can then start looping from the first element of `digits` and look. for the first element which is followed by a greater one.\\n\\nIf we find it:\\n* we set `j = 0` and use this second pointer to find the first element `> digits [i]`;\\n* we swap `digits[j]` and `digits[i]`;\\n* we sort all the elements up to `i` in increasing order (which would become decreasing once we reform the number);\\n* reassemble the new `n` with a process specular to how we extra the digits;\\n* while we do so, we also look for potential overflows, when our current value is already `> INT_MAX / 10` and we still have digits to parse, in which case we return `-1`;\\n* otherwise, we return `n`.\\n\\nIf we exit the loop without any such match, then we know our elements are already sorted in the highest possible lexicographic permutation as discussed above, so we can safely return `-1`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int nextGreaterElement(long n) {\\n        // support variables\\n        vector<int> digits;\\n        // extracting digits\\n        while (n) {\\n            digits.push_back(n % 10);\\n            n /= 10;\\n        }\\n        // from right of the original number, looking for the first not decreasing occurrence\\n        for (int i = 1, j, len = digits.size(), lmt = INT_MAX / 10; i < len; i++) {\\n            if (digits[i - 1] > digits[i]) {\\n                // if found, we look for the first number so far > digits[i]...\\n                j = 0;\\n                while (digits[j] <= digits[i]) j++;\\n                // ...then we swap numbers...\\n                swap(digits[j], digits[i]);\\n                // ...sort all the elements up to here...\\n                sort(begin(digits), begin(digits) + i, greater<int>());\\n                // ... recompose n\\n                while (digits.size()) {\\n                    n = n * 10 + digits.back();\\n                    digits.pop_back();\\n                    // edge cases: exceeding 32 bits\\n                    if (n >= lmt && digits.size()) return -1;\\n                }\\n                return n;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Probability and Statistics"
                ],
                "code": "```cpp\\n13443222 // after the swap\\n13222344 // after the sorting - hey, that is our solution!\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int nextGreaterElement(long n) {\\n        // support variables\\n        vector<int> digits;\\n        // extracting digits\\n        while (n) {\\n            digits.push_back(n % 10);\\n            n /= 10;\\n        }\\n        // from right of the original number, looking for the first not decreasing occurrence\\n        for (int i = 1, j, len = digits.size(), lmt = INT_MAX / 10; i < len; i++) {\\n            if (digits[i - 1] > digits[i]) {\\n                // if found, we look for the first number so far > digits[i]...\\n                j = 0;\\n                while (digits[j] <= digits[i]) j++;\\n                // ...then we swap numbers...\\n                swap(digits[j], digits[i]);\\n                // ...sort all the elements up to here...\\n                sort(begin(digits), begin(digits) + i, greater<int>());\\n                // ... recompose n\\n                while (digits.size()) {\\n                    n = n * 10 + digits.back();\\n                    digits.pop_back();\\n                    // edge cases: exceeding 32 bits\\n                    if (n >= lmt && digits.size()) return -1;\\n                }\\n                return n;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186425,
                "title": "c-easy-to-understand-o-n-time",
                "content": "```\\n// ref: https://www.geeksforgeeks.org/find-next-greater-number-set-digits/\\n// Time: O(n), n is the length of the digits\\nint nextGreaterElement(int n) {\\n    string s = to_string(n);\\n    int i = s.size() - 2;\\n    // start from right\\n    // find the number x which is smaller than the next one\\n    for(; i >= 0; i--){\\n        if(s[i] < s[i + 1]) break;\\n    }\\n    // if it doesn\\'t exist, return -1\\n    if(i < 0) return -1;\\n    // find the number x\\' in the right side which is just greater than x\\n    for(int j = s.size() - 1; j > i; j--){\\n        if(s[j] > s[i]){\\n            swap(s[i], s[j]);\\n            break;\\n        }\\n    }\\n    // reverse right side to make it in increasing order\\n    reverse(s.begin() + i + 1, s.end());\\n    long res = stol(s);\\n    return res > INT_MAX? -1 : res; // check if the result is longer than 32-bits\\n```",
                "solutionTags": [],
                "code": "```\\n// ref: https://www.geeksforgeeks.org/find-next-greater-number-set-digits/\\n// Time: O(n), n is the length of the digits\\nint nextGreaterElement(int n) {\\n    string s = to_string(n);\\n    int i = s.size() - 2;\\n    // start from right\\n    // find the number x which is smaller than the next one\\n    for(; i >= 0; i--){\\n        if(s[i] < s[i + 1]) break;\\n    }\\n    // if it doesn\\'t exist, return -1\\n    if(i < 0) return -1;\\n    // find the number x\\' in the right side which is just greater than x\\n    for(int j = s.size() - 1; j > i; j--){\\n        if(s[j] > s[i]){\\n            swap(s[i], s[j]);\\n            break;\\n        }\\n    }\\n    // reverse right side to make it in increasing order\\n    reverse(s.begin() + i + 1, s.end());\\n    long res = stol(s);\\n    return res > INT_MAX? -1 : res; // check if the result is longer than 32-bits\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250047,
                "title": "python-solution-complete-explanation",
                "content": "**Introducion :**\\n1. If all digits sorted in descending order, then output is always -1. For example, 321.\\n2. For other cases, we need to process the number from rightmost side (why? because we need to find the smallest of all greater numbers)\\n\\n**Algorithm:**\\n1. Traverse the given number from rightmost digit, keep traversing till you find a digit which is smaller than the previously traversed digit. For example, if the input number is **\\u201C534976\\u201D**, we stop at 4 because 4 is smaller than next digit 9. If we do not find such a digit, then output is \\u201CNot Possible\\u201D.\\n\\n2. Now search the right side of above found digit \\u2018d\\u2019 for the smallest digit greater than \\u2018d\\u2019. For **\\u201C534976\\u2033**, the right side of 4 contains \\u201C976\\u201D. The smallest digit greater than 4 is 6.\\n\\n3. Swap the above found two digits, we get **536974** in above example.\\n\\n4. Now sort all digits from position next to \\u2018d\\u2019 to the end of number. The number that we get after sorting is the output. Finally, for above example, We get \\u201C536479\\u201D which is the next greater number for input 534976.\\n\\n5. In last step we should check weather the result is a 32-bit number or not. \\n\\n\\n**Code:**\\n```\\nclass Solution(object):\\n    def nextGreaterElement(self, n):\\n        \\n        n=list(str(n))\\n        N=len(n)\\n        i=None\\n        \\n        for x in range(N-1,0,-1):\\n            if n[x]>n[x-1]:\\n                i=x-1\\n                break\\n        else:\\n            return -1\\n        \\n        swap=i+1\\n        pos=i\\n        \\n        for x in range(swap,N):\\n            if n[pos]<n[x]<n[swap]:\\n                swap=x\\n                \\n        n[pos],n[swap]=n[swap],n[pos]\\n                 \\n        ans=int(\\'\\'.join(n[:pos+1])+\\'\\'.join(sorted(n[pos+1:])))\\n        \\n        return ans if len(bin(ans)[2:])<32 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextGreaterElement(self, n):\\n        \\n        n=list(str(n))\\n        N=len(n)\\n        i=None\\n        \\n        for x in range(N-1,0,-1):\\n            if n[x]>n[x-1]:\\n                i=x-1\\n                break\\n        else:\\n            return -1\\n        \\n        swap=i+1\\n        pos=i\\n        \\n        for x in range(swap,N):\\n            if n[pos]<n[x]<n[swap]:\\n                swap=x\\n                \\n        n[pos],n[swap]=n[swap],n[pos]\\n                 \\n        ans=int(\\'\\'.join(n[:pos+1])+\\'\\'.join(sorted(n[pos+1:])))\\n        \\n        return ans if len(bin(ans)[2:])<32 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197421,
                "title": "python-100-solution-same-logic-behind-next-permutation",
                "content": "```\\nclass Solution:\\n    def nextGreaterElement(self, n):\\n        digits = list(str(n))\\n        length = len(digits)\\n        \\n        i, j = length-2, length-1\\n        while i >= 0 and digits[i+1] <= digits[i]:\\n            i -= 1\\n        \\n        if i == -1: return -1\\n\\n        while digits[j] <= digits[i]:\\n            j -= 1\\n        \\n        digits[i], digits[j] = digits[j], digits[i]\\n\\n        res = int(\\'\\'.join(digits[:i+1] + digits[i+1:][::-1]))\\n        if res >= 2**31 or res == n:\\n            return -1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n):\\n        digits = list(str(n))\\n        length = len(digits)\\n        \\n        i, j = length-2, length-1\\n        while i >= 0 and digits[i+1] <= digits[i]:\\n            i -= 1\\n        \\n        if i == -1: return -1\\n\\n        while digits[j] <= digits[i]:\\n            j -= 1\\n        \\n        digits[i], digits[j] = digits[j], digits[i]\\n\\n        res = int(\\'\\'.join(digits[:i+1] + digits[i+1:][::-1]))\\n        if res >= 2**31 or res == n:\\n            return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982991,
                "title": "c-4-lines-0ms-easy-solution-using-next-permutation-function",
                "content": "1. C++ next_permutation function will give the next greater permutation which we want in this case\\n2. Make sure the result is within the required range (<= MAX_INT)\\n3. If it is outside range return -1\\n**Please upvote if you like it**\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        if (next_permutation(num.begin(), num.end())) {\\n            long res = stol(num);\\n            return res > INT_MAX ? -1 : res;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        if (next_permutation(num.begin(), num.end())) {\\n            long res = stol(num);\\n            return res > INT_MAX ? -1 : res;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721356,
                "title": "100-faster-c-easy-to-understand-full-explanation",
                "content": "The logic that i used in this question is same we use in the leetcode question number 31 i.e; Next Permutation.\\n##### ***Approach*** :- split the question in 5 parts.\\n**1st part**:-  Extraxt the element from the n and put them in a vector so that we can use them.\\n**2nd part**:- Now from here we will use the same logic we use in next permutation question. Iterate from the last and check if n[i]<n[i+1] this statement will help us to find the index of 3 in the array {2,3,6,5,4} ,once we reach the position where 3<6 then use break and store the index.\\n**3rd part**;-  now again iterate the vector from the last and find a number that is greater than the number at which we broke out of the condition in the last step and store the index.\\n**4th part**:- now swap those elements.\\n**5th part**:- and at last reverse the elements from the index from which we broke out of the if condition in the third step to the last.\\nQuestion solved.\\nP.S.- watch the edge case. {5,4,3,2,1} , for this return -1;\\n\\nattaching the code , have a look and try to code it yourself ;)\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int temp=n;\\n        vector<int> nums;\\n        while (temp){                               \\n            nums.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        reverse(nums.begin(),nums.end());\\n        temp=nums.size();\\n        int k,m;\\n        for (k=temp-2;k>=0;k--){\\n            if (nums[k]<nums[k+1]) break;\\n        }\\n        if (k<0) return -1;\\n        else{\\n            for (m=temp-1;m>k;m--){\\n                if (nums[m]>nums[k]) break;\\n            }\\n            swap(nums[m],nums[k]);\\n            reverse(nums.begin()+k+1,nums.end());\\n        }\\n        long long int res=0;\\n        for (int i=0;i<temp;i++){\\n            res=res*10+nums[i];\\n        }\\n        if (res>INT_MAX) return -1;\\n        return res;\\n    }\\n};\\nDo Upvote if you find it useful.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int temp=n;\\n        vector<int> nums;\\n        while (temp){                               \\n            nums.push_back(temp%10);\\n            temp=temp/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1386682,
                "title": "c-100-0ms-5-3mb-with-comments-and-explanation",
                "content": "\\n#### **Intution: For getting the number just greater number than given number, we need to jumble the digits thoughtfully. **\\n    \\n**We need to jumble a lesser significant digit with a just greater number to its right**\\n For example: 545610... We start with the last but one digit (1)\\n \\n* 1 doesnt have any right-side digit greater than itself\\n* Same with the case of 6\\n* But 5 has 6 to its right side..(Lets assume the index of 5 as temp).\\n..So we swap them --> 546510\\n    \\n* Next Step: \\nWe sort the substring after temp(\\'510\\').. --> 546\\'015\\'\\nThis is the answer we need\\n* If we havent found any digit greater than itself on the right side, we return -1\\n    Examples: 54321, 21\\n        \\n  int nextGreaterElement(int num) {\\n        \\n        string s = to_string(num);\\n        int n = s.length();\\n        \\n        //Using two pointers.. You can also use a monotonic stack\\n        int right = n-1, left = n-2;\\n        \\n        int index;\\n        \\n        //For finding the greater digit on the right\\n        while(left>=0){\\n            if(s[left]>=s[right]){\\n                left--;\\n                right--;\\n            }\\n            else{\\n                index = right;\\n                while(right<n){\\n                    if(s[right]>s[left])\\n                        index = right;\\n                    right++;\\n                }\\n                break; //If found, break the while loop\\n            }\\n            \\n        }\\n        \\n        //If not found, retrun -1\\n        if(left==-1) return -1;\\n        \\n        //Swap the digits (in the example: 5 and 6)\\n        swap(s[left], s[index]);\\n        \\n        //Sort the substring (in the example: \\'510\\')\\n        sort(s.begin()+left+1, s.end());\\n        \\n        //For checking if the answer is goint out of bounds\\n        long long ans = stoll(s);\\n        \\n        if(ans<=pow(2, 31)-1) return stoi(s);\\n        else return -1;\\n\\n\\n    }\\n    \\n    \\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n#### **Intution: For getting the number just greater number than given number, we need to jumble the digits thoughtfully. **\\n    \\n**We need to jumble a lesser significant digit with a just greater number to its right**\\n For example: 545610... We start with the last but one digit (1)\\n \\n* 1 doesnt have any right-side digit greater than itself\\n* Same with the case of 6\\n* But 5 has 6 to its right side..(Lets assume the index of 5 as temp).\\n..So we swap them --> 546510\\n    \\n* Next Step: \\nWe sort the substring after temp(\\'510\\').. --> 546\\'015\\'\\nThis is the answer we need\\n* If we havent found any digit greater than itself on the right side, we return -1\\n    Examples: 54321, 21\\n        \\n  int nextGreaterElement(int num) {\\n        \\n        string s = to_string(num);\\n        int n = s.length();\\n        \\n        //Using two pointers.. You can also use a monotonic stack\\n        int right = n-1, left = n-2;\\n        \\n        int index;\\n        \\n        //For finding the greater digit on the right\\n        while(left>=0){\\n            if(s[left]>=s[right]){\\n                left--;\\n                right--;\\n            }\\n            else{\\n                index = right;\\n                while(right<n){\\n                    if(s[right]>s[left])\\n                        index = right;\\n                    right++;\\n                }\\n                break; //If found, break the while loop\\n            }\\n            \\n        }\\n        \\n        //If not found, retrun -1\\n        if(left==-1) return -1;\\n        \\n        //Swap the digits (in the example: 5 and 6)\\n        swap(s[left], s[index]);\\n        \\n        //Sort the substring (in the example: \\'510\\')\\n        sort(s.begin()+left+1, s.end());\\n        \\n        //For checking if the answer is goint out of bounds\\n        long long ans = stoll(s);\\n        \\n        if(ans<=pow(2, 31)-1) return stoi(s);\\n        else return -1;\\n\\n\\n    }\\n    \\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2138321,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Find The Next Permutation***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int num) {\\n        \\n        string str = to_string(num);\\n        \\n        int n = str.size();\\n        \\n        int i = n - 2;\\n        \\n        while(i >= 0 && str[i] >= str[i + 1])\\n        {\\n            i--;\\n        }\\n        \\n        if(i < 0)\\n        {\\n            return -1;\\n        }\\n        \\n        int j = n - 1;\\n        \\n        while(j >= 0)\\n        {\\n            if(str[j] > str[i])\\n            {\\n                break;\\n            }\\n            \\n            j--;\\n        }\\n        \\n        swap(str[i], str[j]);\\n        \\n        reverse(str.begin() + i + 1, str.end());\\n        \\n        long long res = stol(str);\\n        \\n        if(res > INT_MAX || res < INT_MIN)\\n            return -1;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int num) {\\n        \\n        string str = to_string(num);\\n        \\n        int n = str.size();\\n        \\n        int i = n - 2;\\n        \\n        while(i >= 0 && str[i] >= str[i + 1])\\n        {\\n            i--;\\n        }\\n        \\n        if(i < 0)\\n        {\\n            return -1;\\n        }\\n        \\n        int j = n - 1;\\n        \\n        while(j >= 0)\\n        {\\n            if(str[j] > str[i])\\n            {\\n                break;\\n            }\\n            \\n            j--;\\n        }\\n        \\n        swap(str[i], str[j]);\\n        \\n        reverse(str.begin() + i + 1, str.end());\\n        \\n        long long res = stol(str);\\n        \\n        if(res > INT_MAX || res < INT_MIN)\\n            return -1;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 101843,
                "title": "java-solution-like-next-permutation-problem-o-n",
                "content": "```\\npublic class Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] a=(\"\"+n).toCharArray();\\n        int i = a.length - 2;\\n        while (i >= 0 && a[i + 1] <= a[i]) {\\n            i--;\\n        }\\n        if(i<0)\\n            return -1;\\n        int j = a.length - 1;\\n        while (j >= 0 && a[j] <= a[i]) {\\n            j--;\\n        }\\n        swap(a, i, j);\\n        reverse(a, i + 1);\\n        try{\\n           return Integer.parseInt(new String(a));\\n        }\\n        catch(Exception e){\\n           return -1;\\n        }\\n    }\\n    private void reverse(char[] a, int start) {\\n        int i = start, j = a.length - 1;\\n        while (i < j) {\\n            swap(a, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    private void swap(char[] a, int i, int j) {\\n        char temp = a[i];\\n        a[i] = a[j];\\n        a[j] = temp;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] a=(\"\"+n).toCharArray();\\n        int i = a.length - 2;\\n        while (i >= 0 && a[i + 1] <= a[i]) {\\n            i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 101834,
                "title": "java-5ms-find-swap-sort-solution",
                "content": "From right to left, the idea is to find the number greater than `num[i]`, swap it, and sort the rest of the elements to the right.\\n\\n    public int nextGreaterElement(int n) {\\n        char[] num = (n + \"\").toCharArray();\\n        for(int i = num.length-2; i >= 0; i--) {\\n            // find min number greater than num(i)\\n            int minIdx = i;\\n            for(int j = i+1; j < num.length; j++) {\\n                minIdx = num[j] > num[i] ? j : minIdx;\\n            }\\n            if(minIdx != i) {\\n                char temp = num[i]; //swap minIdx and i;\\n                num[i] = num[minIdx];\\n                num[minIdx] = temp;\\n                \\n                Arrays.sort(num, i+1, num.length);\\n\\n                long val = Long.parseLong(new String(num));\\n                return (val <= Integer.MAX_VALUE) ? (int) val : -1;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "From right to left, the idea is to find the number greater than `num[i]`, swap it, and sort the rest of the elements to the right.\\n\\n    public int nextGreaterElement(int n) {\\n        char[] num = (n + \"\").toCharArray();\\n        for(int i = num.length-2; i >= 0; i--) {\\n            // find min number greater than num(i)\\n            int minIdx = i;\\n            for(int j = i+1; j < num.length; j++) {\\n                minIdx = num[j] > num[i] ? j : minIdx;\\n            }\\n            if(minIdx != i) {\\n                char temp = num[i]; //swap minIdx and i;\\n                num[i] = num[minIdx];\\n                num[minIdx] = temp;\\n                \\n                Arrays.sort(num, i+1, num.length);\\n\\n                long val = Long.parseLong(new String(num));\\n                return (val <= Integer.MAX_VALUE) ? (int) val : -1;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 983648,
                "title": "heavily-commented-javascript-solution",
                "content": "Played around a little with **1234** and **4321**\\n        \\nYou immediately notice **4321** is maxed out. Why is that?\\nIt\\'s because it\\'s sorted descending. \\n\\nSo if we find no spots where the number increases, it\\'s a -1\\n\\nif we do, we have work to do\\n\\n**1234** increases every step, so we should swap 3 and 4 \\n\\n**1243** now with this number we see we can\\'t just swap the last increase\\nthat\\'d be **1423** and that\\'s not right.\\n\\nIt\\'s not even the case that I can swap it with the lowest afterwards\\nthat\\'d be **1342** and obviously **1324** is smaller\\n\\nSo what\\'s the general formula? \\n\\n* Find the last increasing step, \\n* swap with the lowest number coming after that\\n* sort the remainder after our swapped number\\n\\nThat would work for **1243**:\\n1->2 increase\\n2->4 increase\\n4->3 decrease, so 2->4 was the last increase, so **2** is our swapping candidate\\n\\nSo we mark **2** for swapping (at lastIncreasePosition in the code ) \\nof the remaining numbers, 3 is the lowest (at smallestToSwapWithPosition in the code)\\nso we swap 2 and 3 and get \\n\\n**1342**\\n\\nnow we sort after the position 2 was in and we get\\n\\n**1324**\\n\\n-- It\\'s an idea so let\\'s try it out! coding.... --\\n\\nIt works on **1243**. I will test with some larger numbers and\\ncheck that 32bit integer edge too\\n\\nI then added a 32 bit check, i think we should be good now.. submitting!\\n\\nERROR! There\\'s a bug!\\nInput:\\n\\t**230241**\\nOutput:\\n\\t**230124**\\nExpected:\\n\\t**230412**\\n\\nAha! I swapped 2 with the lowest number after it, (1) but that was lower\\nthan 2, and thus illegal, I should check for that.\\n\\nI expanded the if statement above the \\n```smallestToSwapWithPosition = i;``` line\\nand that works, I am done!\\n\\n```\\n\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nextGreaterElement = function(n) {\\n    \\n    var numbers = (\"\" + n).split(\\'\\').map(n=>parseInt(n));\\n    var lastIncreasePosition = null;\\n    var smallestToSwapWithPosition;\\n    var i, l;\\n    \\n    for (i = 0, l = numbers.length; i < l; i++) {\\n        \\n        // Find the last increase to pin point which number needs to be increased\\n        // for the next lowest number\\n        if (numbers[i] < numbers[i + 1] && i + 1 < l) {\\n            \\n            // Save the position where we found that last increasing step\\n            lastIncreasePosition = i;\\n            \\n            // Our first candidate to swap with is simply the next number\\n            smallestToSwapWithPosition = i + 1;\\n        } else if (lastIncreasePosition !== null) {\\n            \\n            // Check if there is a better (smaller) number to swap with\\n            // Only numbers larger that the one we are swapping with are elligible\\n            if (numbers[smallestToSwapWithPosition] > numbers[i] && numbers[i] > numbers[lastIncreasePosition]) {\\n                smallestToSwapWithPosition = i;\\n            }\\n        }\\n    }\\n\\n    // Check if we\\'re not already at the maximum value (like 4321)\\n    if (lastIncreasePosition === null) {\\n        return -1;\\n    }\\n    \\n    // Do the swap. This will get us from 1243 to 1342\\n    let temp = numbers[lastIncreasePosition];\\n    numbers[lastIncreasePosition] = numbers[smallestToSwapWithPosition];\\n    numbers[smallestToSwapWithPosition] = temp\\n    \\n    // We\\'re not done, we have to sort everything after lastIncreasePosition \\n    // to get from 1342 to 1324\\n    // Slice up the part that is done and the part that needs sorting\\n    var sorted = numbers.slice(0, lastIncreasePosition + 1)\\n    var unsorted = numbers.slice(lastIncreasePosition + 1);\\n    \\n    unsorted = unsorted.sort((a,b) => a - b);\\n    // put em back together\\n    numbers = [...sorted, ...unsorted];\\n    \\n    // convert back to a number\\n    n = parseInt(numbers.join(\\'\\'));\\n        \\n    // 32 bit int check\\n    if (n > 2147483647) {\\n        return -1;\\n    }\\n    \\n    return n;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```smallestToSwapWithPosition = i;```\n```\\n\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nextGreaterElement = function(n) {\\n    \\n    var numbers = (\"\" + n).split(\\'\\').map(n=>parseInt(n));\\n    var lastIncreasePosition = null;\\n    var smallestToSwapWithPosition;\\n    var i, l;\\n    \\n    for (i = 0, l = numbers.length; i < l; i++) {\\n        \\n        // Find the last increase to pin point which number needs to be increased\\n        // for the next lowest number\\n        if (numbers[i] < numbers[i + 1] && i + 1 < l) {\\n            \\n            // Save the position where we found that last increasing step\\n            lastIncreasePosition = i;\\n            \\n            // Our first candidate to swap with is simply the next number\\n            smallestToSwapWithPosition = i + 1;\\n        } else if (lastIncreasePosition !== null) {\\n            \\n            // Check if there is a better (smaller) number to swap with\\n            // Only numbers larger that the one we are swapping with are elligible\\n            if (numbers[smallestToSwapWithPosition] > numbers[i] && numbers[i] > numbers[lastIncreasePosition]) {\\n                smallestToSwapWithPosition = i;\\n            }\\n        }\\n    }\\n\\n    // Check if we\\'re not already at the maximum value (like 4321)\\n    if (lastIncreasePosition === null) {\\n        return -1;\\n    }\\n    \\n    // Do the swap. This will get us from 1243 to 1342\\n    let temp = numbers[lastIncreasePosition];\\n    numbers[lastIncreasePosition] = numbers[smallestToSwapWithPosition];\\n    numbers[smallestToSwapWithPosition] = temp\\n    \\n    // We\\'re not done, we have to sort everything after lastIncreasePosition \\n    // to get from 1342 to 1324\\n    // Slice up the part that is done and the part that needs sorting\\n    var sorted = numbers.slice(0, lastIncreasePosition + 1)\\n    var unsorted = numbers.slice(lastIncreasePosition + 1);\\n    \\n    unsorted = unsorted.sort((a,b) => a - b);\\n    // put em back together\\n    numbers = [...sorted, ...unsorted];\\n    \\n    // convert back to a number\\n    n = parseInt(numbers.join(\\'\\'));\\n        \\n    // 32 bit int check\\n    if (n > 2147483647) {\\n        return -1;\\n    }\\n    \\n    return n;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 983461,
                "title": "simple-python-solution-easy-to-understand-reading-backwards-from-the-end",
                "content": "### Simple Python Solution (read backwards from the end)\\n![image](https://assets.leetcode.com/users/images/9e214132-03bf-4f92-8277-7e9828511660_1608742652.8712633.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        m=list(str(n))                       ## n = 257761\\n        l = len(m)                           ## l = 6\\n        d = {}\\n        res = str(n)\\n        \\n        ## reading character backwards: 1->6->7->7->5 break\\n        for i,c in enumerate(m[::-1]): \\n            if not d:\\n                d[c]=1                       ## d = {\\'1\\':1}\\n            else:\\n                if all(c >= x for x in d):\\n                    d[c]=d.get(c,0)+1        ## d = {\\'1\\':1,\\'6\\':1,\\'7\\':2} \\n                else:\\n                    d[c]=d.get(c,0)+1        ## d = {\\'1\\':1,\\'5\\':1,\\'6\\':1,\\'7\\':2}\\n                    res = \\'\\'.join(m[:l-1-i])        ## res = \\'2\\'\\n                    stock = sorted(list(d.keys()))  ## stock = [\\'1\\',\\'5\\',\\'6\\',\\'7\\']\\n                    cplus = stock[stock.index(c)+1] ## cplus = \\'6\\' just > \\'5\\'\\n                    res += cplus                    ## res = \\'26\\'\\n                    d[cplus] -= 1                   ## d = {\\'1\\':1,\\'5\\':1,\\'6\\':0,\\'7\\':2}\\n                    res += \\'\\'.join([x * d[x] for x in stock]) \\n\\t\\t\\t\\t\\t                                ## res = \\'26\\' + \\'1577\\'\\n                    break\\n        \\n        return int(res) if n < int(res) < (2**31-1) else -1\\n```\\n\\nThis solution is quite self-explanatory.  The general idea is to read the number backwards from right to left, and you are waiting for an opportunity that the newly-appeared digit is less than at least one of the stocked digits in the dictionary Counter built along the way. Replace that digit with the next available digit, then reverse the direction back towards right and fill with a smallest number that can be formed by the remaining digits in stock.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        m=list(str(n))                       ## n = 257761\\n        l = len(m)                           ## l = 6\\n        d = {}\\n        res = str(n)\\n        \\n        ## reading character backwards: 1->6->7->7->5 break\\n        for i,c in enumerate(m[::-1]): \\n            if not d:\\n                d[c]=1                       ## d = {\\'1\\':1}\\n            else:\\n                if all(c >= x for x in d):\\n                    d[c]=d.get(c,0)+1        ## d = {\\'1\\':1,\\'6\\':1,\\'7\\':2} \\n                else:\\n                    d[c]=d.get(c,0)+1        ## d = {\\'1\\':1,\\'5\\':1,\\'6\\':1,\\'7\\':2}\\n                    res = \\'\\'.join(m[:l-1-i])        ## res = \\'2\\'\\n                    stock = sorted(list(d.keys()))  ## stock = [\\'1\\',\\'5\\',\\'6\\',\\'7\\']\\n                    cplus = stock[stock.index(c)+1] ## cplus = \\'6\\' just > \\'5\\'\\n                    res += cplus                    ## res = \\'26\\'\\n                    d[cplus] -= 1                   ## d = {\\'1\\':1,\\'5\\':1,\\'6\\':0,\\'7\\':2}\\n                    res += \\'\\'.join([x * d[x] for x in stock]) \\n\\t\\t\\t\\t\\t                                ## res = \\'26\\' + \\'1577\\'\\n                    break\\n        \\n        return int(res) if n < int(res) < (2**31-1) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109871,
                "title": "simple-c-plz-upvote",
                "content": "```\\n\\n\\nint nextGreaterElement(int n) {\\n    auto digits = to_string(n);\\n    next_permutation(begin(digits), end(digits));\\n    auto res = stoll(digits);\\n    return (res > INT_MAX || res <= n) ? -1 : res;\\n\\t\\n\\t****\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint nextGreaterElement(int n) {\\n    auto digits = to_string(n);\\n    next_permutation(begin(digits), end(digits));\\n    auto res = stoll(digits);\\n    return (res > INT_MAX || res <= n) ? -1 : res;\\n\\t\\n\\t****\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1156839,
                "title": "beats-100-0ms-java-most-efficient-solution",
                "content": "\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        //Converting integer to an array of digits\\n        String s = Integer.toString(n);\\n        int arr[] = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            arr[i] = s.charAt(i) - \\'0\\';\\n        }\\n        \\n        //Finding the first decreasing element(i-1) from behind\\n        int i = arr.length - 1;\\n        while(i > 0 && arr[i-1] >= arr[i]){\\n            i--;\\n        }\\n        //If no element is decreasing and the array is all increasing from behind then return -1 as no solution possible\\n        if(i-1 < 0) return -1;\\n        \\n        //Finding the next bigger element(j) than (i-1) from behind\\n        int j = arr.length-1;\\n        while(j > (i-1) && arr[j] <= arr[i-1]){\\n            j--;\\n        }\\n        \\n        //Swap the elements\\n        swap(arr, i-1, j);\\n        //Reverse the array from i to end\\n        reverse(arr, i);\\n        \\n        //Convert the array to an integer but make sure to check that if does not exceed the 32 bit integer as mentioned in the question\\n        int ans = 0;\\n        for(i=0;i<arr.length;i++){\\n            if(ans > Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 && arr[i] > 7))\\n                return -1;\\n            if(ans < Integer.MIN_VALUE / 10 || (ans == Integer.MIN_VALUE / 10 && arr[i] < -8))\\n                return -1;\\n            ans = ans * 10 + arr[i];\\n        }\\n        //If the same integer is formed then return -1\\n        return ans == n ? -1 : ans;\\n    }\\n    \\n    //Helper function to reverse\\n    private void reverse(int[] arr, int i){\\n        int j = arr.length - 1;\\n        while(i < j){\\n            swap(arr, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    //Helper function to swap the elements\\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        //Converting integer to an array of digits\\n        String s = Integer.toString(n);\\n        int arr[] = new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            arr[i] = s.charAt(i) - \\'0\\';\\n        }\\n        \\n        //Finding the first decreasing element(i-1) from behind\\n        int i = arr.length - 1;\\n        while(i > 0 && arr[i-1] >= arr[i]){\\n            i--;\\n        }\\n        //If no element is decreasing and the array is all increasing from behind then return -1 as no solution possible\\n        if(i-1 < 0) return -1;\\n        \\n        //Finding the next bigger element(j) than (i-1) from behind\\n        int j = arr.length-1;\\n        while(j > (i-1) && arr[j] <= arr[i-1]){\\n            j--;\\n        }\\n        \\n        //Swap the elements\\n        swap(arr, i-1, j);\\n        //Reverse the array from i to end\\n        reverse(arr, i);\\n        \\n        //Convert the array to an integer but make sure to check that if does not exceed the 32 bit integer as mentioned in the question\\n        int ans = 0;\\n        for(i=0;i<arr.length;i++){\\n            if(ans > Integer.MAX_VALUE / 10 || (ans == Integer.MAX_VALUE / 10 && arr[i] > 7))\\n                return -1;\\n            if(ans < Integer.MIN_VALUE / 10 || (ans == Integer.MIN_VALUE / 10 && arr[i] < -8))\\n                return -1;\\n            ans = ans * 10 + arr[i];\\n        }\\n        //If the same integer is formed then return -1\\n        return ans == n ? -1 : ans;\\n    }\\n    \\n    //Helper function to reverse\\n    private void reverse(int[] arr, int i){\\n        int j = arr.length - 1;\\n        while(i < j){\\n            swap(arr, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    //Helper function to swap the elements\\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983439,
                "title": "next-greater-element-iii-python-implementing-next-permutation",
                "content": "This solution is based on the protocol of [C++ `next_permutation()`](https://en.cppreference.com/w/cpp/algorithm/next_permutation), which permutes the array into the next permutation in lexicographical order with respect to `<`. It returns `True` if such a next permutation exists. \\n\\n[@Ritik26](https://leetcode.com/Ritik26) has a good explaination on how `next_permutation()` works in [this post](https://leetcode.com/discuss/explore/december-leetcoding-challenge/983321/Next-Greater-Element-III-U-will-get-understand-in-one-look). The code below is a more condensed implementation of the same idea, where `i` is where the first element smaller than the right, `j == i + 1`, `k` is where `l[k]` is \"just greater than\" `l[i]`. We don\\'t need to sort but just reverse `l[j:]` because we know it is already in descending order.\\n\\n```python\\ndef next_permutation(l):\\n    \"\"\"implementing C++ <algorithm> next_permutation().\"\"\"\\n    n = len(l)\\n    if n <= 1:\\n        return False\\n    i = n - 1\\n    while True:\\n        j = i\\n        i -= 1  \\n        if l[i] < l[j]:\\n            k = n - 1\\n            while not (l[i] < l[k]):  \\n                k -= 1\\n            l[i], l[k] = l[k], l[i]\\n            l[j:] = reversed(l[j:])\\n            return True\\n        if i == 0:  \\n                l.reverse()\\n                return False \\n\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        l = list(str(n))\\n        has_next = next_permutation(l)\\n        ans = int(\\'\\'.join(l))\\n        return ans if has_next and ans < 2 ** 31 else -1\\n```\\n\\n---\\nIf you find this helpful, please consider **upvote**. Thank you! \\uD83E\\uDD17",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef next_permutation(l):\\n    \"\"\"implementing C++ <algorithm> next_permutation().\"\"\"\\n    n = len(l)\\n    if n <= 1:\\n        return False\\n    i = n - 1\\n    while True:\\n        j = i\\n        i -= 1  \\n        if l[i] < l[j]:\\n            k = n - 1\\n            while not (l[i] < l[k]):  \\n                k -= 1\\n            l[i], l[k] = l[k], l[i]\\n            l[j:] = reversed(l[j:])\\n            return True\\n        if i == 0:  \\n                l.reverse()\\n                return False \\n\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        l = list(str(n))\\n        has_next = next_permutation(l)\\n        ans = int(\\'\\'.join(l))\\n        return ans if has_next and ans < 2 ** 31 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951464,
                "title": "most-comprehensive-solution-line-by-line-easy-to-understand-simple-easiest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int x = n;\\n        string num = to_string(n);\\n\\n        //finding first value that has to be swaped\\n        int i = num.size() - 2;\\n        while(i>= 0 && num[i]>=num[i+1]) {\\n            i--;\\n        }\\n\\n        //means num is inself maximum\\n        if(i==-1) return -1;\\n\\n        //finding int just greater than num[i]\\n        int k = num.size() -1;\\n        while(num[i]>=num[k]) k--;\\n\\n        \\n        //swap ith and kth num\\n        swap(num[i], num[k]);\\n\\n        //reversing rest end digits to make the number just greater than the number\\n        reverse(num.begin() + i+1, num.end());\\n        long ans = stol(num);\\n        if(ans>INT_MAX) return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int x = n;\\n        string num = to_string(n);\\n\\n        //finding first value that has to be swaped\\n        int i = num.size() - 2;\\n        while(i>= 0 && num[i]>=num[i+1]) {\\n            i--;\\n        }\\n\\n        //means num is inself maximum\\n        if(i==-1) return -1;\\n\\n        //finding int just greater than num[i]\\n        int k = num.size() -1;\\n        while(num[i]>=num[k]) k--;\\n\\n        \\n        //swap ith and kth num\\n        swap(num[i], num[k]);\\n\\n        //reversing rest end digits to make the number just greater than the number\\n        reverse(num.begin() + i+1, num.end());\\n        long ans = stol(num);\\n        if(ans>INT_MAX) return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297104,
                "title": "556-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Convert the input number n into a list of digits.\\n2. Traverse the list from right to left to find the first decreasing digit i-1.\\n3. If there is no such digit, the input number is already the largest possible permutation, so return -1.\\n4. Traverse the list again from right to left to find the smallest digit j greater than i-1.\\n5. Swap i-1 with j.\\n6. Reverse the sublist from i to the end of the list to obtain the smallest possible permutation greater than the original number.\\n7. If the resulting permutation is greater than 2^31 - 1, return -1. Otherwise, return the permutation as an integer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        nums = list(str(n))\\n        i = len(nums) - 1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:\\n            return -1\\n        j = len(nums) - 1\\n        while j > i-1 and nums[j] <= nums[i-1]:\\n            j -= 1\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        nums[i:] = nums[i:][::-1]\\n        res = int(\\'\\'.join(nums))\\n        return res if res < 2**31 else -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        nums = list(str(n))\\n        i = len(nums) - 1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:\\n            return -1\\n        j = len(nums) - 1\\n        while j > i-1 and nums[j] <= nums[i-1]:\\n            j -= 1\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        nums[i:] = nums[i:][::-1]\\n        res = int(\\'\\'.join(nums))\\n        return res if res < 2**31 else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787268,
                "title": "c-using-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s=to_string(n);\\n        vector<int>v;\\n        next_permutation(s.begin(),s.end());\\n        string a=s;\\n        \\n        prev_permutation(a.begin(),a.end());\\n        if(s<=a)\\n            return -1;\\n        long long ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans=ans+pow(10,s.size()-i-1)*(s[i]-\\'0\\');\\n        }\\n        if(ans>INT_MAX or ans<INT_MIN)\\n            return -1;\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s=to_string(n);\\n        vector<int>v;\\n        next_permutation(s.begin(),s.end());\\n        string a=s;\\n        \\n        prev_permutation(a.begin(),a.end());\\n        if(s<=a)\\n            return -1;\\n        long long ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ans=ans+pow(10,s.size()-i-1)*(s[i]-\\'0\\');\\n        }\\n        if(ans>INT_MAX or ans<INT_MIN)\\n            return -1;\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597736,
                "title": "0ms-java-solution-100-with-explanation",
                "content": "Algorithm : - (upvote if you like the solution !!)\\n\\n1. find the first element from the right which is less than its adjacent right element. ( why from the right - since we need to give next greater element swapping which takes places at the end will give us the small result eg. 5667 -> both 5 & 6 are less than 7 but 5676 is better than 7665 so we are taking the first element from right)\\n\\n2. but in the case of 54753 -> the first element from right which is less than its adj right is 4, but we are not going to swap with 7 (adjacent right) instead lets find from last to the adj right element [3,5,7] for the first element which is > than 4 which is 5 so swap it with 5 -> it becomes now 55743\\n\\n3. now you can see that elements after that swapped index that is after 5, all are in decresing order to make the overall result less we can reverse it as -> 347 thats is 55347.\\n\\nwe are taking care of overflow problem  by checking before hand itself if that operation will exceed max int value as below :- (can also be done by try-catch while doing parseInt of string)\\n\\nif ((Integer.MAX_VALUE-arr[i])/10<res) return -1;\\n            res = res*10 + arr[i]; \\n\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = String.valueOf(n);\\n        int arr[] = new int[s.length()];\\n        int i=0;\\n        for(char c: s.toCharArray()) {\\n            arr[i++] = c - \\'0\\';\\n        }\\n        int index=-1;\\n        for(i=arr.length-1;i>0;i--) {\\n            if(arr[i-1]<arr[i]) {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        if(index == -1) return -1;\\n        for(i=arr.length-1;i>index;i--) {\\n            if (arr[i]>arr[index]) {\\n                int temp = arr[index];\\n                arr[index] = arr[i];\\n                arr[i] = temp;\\n                break;\\n            } \\n        }\\n        int l = index+1, r=arr.length-1;\\n        while(l<r) {\\n            int temp = arr[l];\\n            arr[l++] = arr[r];\\n            arr[r--] = temp;\\n        }\\n        int res = 0;\\n        for(i=0;i<arr.length;i++) {\\n            if ((Integer.MAX_VALUE-arr[i])/10<res) return -1;\\n            res = res*10 + arr[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = String.valueOf(n);\\n        int arr[] = new int[s.length()];\\n        int i=0;\\n        for(char c: s.toCharArray()) {\\n            arr[i++] = c - \\'0\\';\\n        }\\n        int index=-1;\\n        for(i=arr.length-1;i>0;i--) {\\n            if(arr[i-1]<arr[i]) {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        if(index == -1) return -1;\\n        for(i=arr.length-1;i>index;i--) {\\n            if (arr[i]>arr[index]) {\\n                int temp = arr[index];\\n                arr[index] = arr[i];\\n                arr[i] = temp;\\n                break;\\n            } \\n        }\\n        int l = index+1, r=arr.length-1;\\n        while(l<r) {\\n            int temp = arr[l];\\n            arr[l++] = arr[r];\\n            arr[r--] = temp;\\n        }\\n        int res = 0;\\n        for(i=0;i<arr.length;i++) {\\n            if ((Integer.MAX_VALUE-arr[i])/10<res) return -1;\\n            res = res*10 + arr[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143445,
                "title": "simple-c-code-o-n-100-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vector<int> ans;\\n        stack<int> st;\\n        while(n != 0)\\n        {\\n            ans.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        int i = ans.size()-1;\\n        int mx = ans[i];\\n        i--;\\n        while(i >= 0)\\n        {\\n            if(mx > ans[i])\\n            {\\n                mx = i;\\n                break;\\n            }\\n            else\\n            {\\n                mx = ans[i];\\n                i--;\\n            }\\n        }\\n        if(i == -1)\\n            return i;\\n        int j = ans.size()-1;\\n        while(j >= 0)\\n        {\\n            if(ans[j] > ans[mx])\\n            {\\n                swap(ans[mx], ans[j]);\\n                break;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        //int x = n - mx;\\n        long int output = 0;\\n        reverse(ans.begin()+mx+1, ans.end());\\n        for(int i = 0; i < ans.size(); i++)\\n        {\\n            output = output *10 + ans[i];\\n        }\\n        if(output > INT_MAX || output < INT_MIN)\\n            return -1;\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vector<int> ans;\\n        stack<int> st;\\n        while(n != 0)\\n        {\\n            ans.push_back(n%10);\\n            n = n/10;\\n        }\\n        reverse(ans.begin(), ans.end());\\n        int i = ans.size()-1;\\n        int mx = ans[i];\\n        i--;\\n        while(i >= 0)\\n        {\\n            if(mx > ans[i])\\n            {\\n                mx = i;\\n                break;\\n            }\\n            else\\n            {\\n                mx = ans[i];\\n                i--;\\n            }\\n        }\\n        if(i == -1)\\n            return i;\\n        int j = ans.size()-1;\\n        while(j >= 0)\\n        {\\n            if(ans[j] > ans[mx])\\n            {\\n                swap(ans[mx], ans[j]);\\n                break;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        //int x = n - mx;\\n        long int output = 0;\\n        reverse(ans.begin()+mx+1, ans.end());\\n        for(int i = 0; i < ans.size(); i++)\\n        {\\n            output = output *10 + ans[i];\\n        }\\n        if(output > INT_MAX || output < INT_MIN)\\n            return -1;\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461743,
                "title": "0ms-100-faster-c",
                "content": "You can also use the predefined next permutation method of strings as well.\\n```\\nstring nextPermutation(string str) // Function to calculate the next permutation of the number\\n{\\n    int n = str.length();\\n    int idx1 = -1;\\n\\n    for (int i = n - 2; i >= 0; i--)\\n        if (str[i + 1] > str[i])\\n        {\\n            idx1 = i;\\n            break;\\n        }\\n    if (idx1 == -1)  return str; // If there is no permutation possible which is greater than the current one, return same string\\n\\t\\n    int pos = idx1, idx2 = 0;\\n\\n    for (int i = n - 1; i > idx1; i--)\\n        if (str[i] > str[idx1])\\n        {\\n            idx2 = i;\\n            break;\\n        }\\n\\n    swap(str[idx1], str[idx2]);\\n    int i = idx1 + 1, j = n - 1;\\n\\n    while (i < j)\\n    {\\n        swap(str[i], str[j]);\\n        i++;\\n        j--;\\n    }\\n    return str;\\n}\\n\\nint nextGreaterElement(int num)\\n{\\n    string str = to_string(num);\\n    str = nextPermutation(str);\\n    auto ans = stol(str);\\n    return (ans > INT_MAX || ans <= num) ? -1 : (int)ans;\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nstring nextPermutation(string str) // Function to calculate the next permutation of the number\\n{\\n    int n = str.length();\\n    int idx1 = -1;\\n\\n    for (int i = n - 2; i >= 0; i--)\\n        if (str[i + 1] > str[i])\\n        {\\n            idx1 = i;\\n            break;\\n        }\\n    if (idx1 == -1)  return str; // If there is no permutation possible which is greater than the current one, return same string\\n\\t\\n    int pos = idx1, idx2 = 0;\\n\\n    for (int i = n - 1; i > idx1; i--)\\n        if (str[i] > str[idx1])\\n        {\\n            idx2 = i;\\n            break;\\n        }\\n\\n    swap(str[idx1], str[idx2]);\\n    int i = idx1 + 1, j = n - 1;\\n\\n    while (i < j)\\n    {\\n        swap(str[i], str[j]);\\n        i++;\\n        j--;\\n    }\\n    return str;\\n}\\n\\nint nextGreaterElement(int num)\\n{\\n    string str = to_string(num);\\n    str = nextPermutation(str);\\n    auto ans = stol(str);\\n    return (ans > INT_MAX || ans <= num) ? -1 : (int)ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 983034,
                "title": "python-super-duper-short-easy-solution",
                "content": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        all_nums_of_same_digits = [int(\\'\\'.join(i)) for i in set(permutations(str(n)))]\\n        all_nums_of_same_digits.sort()\\n        i = all_nums_of_same_digits.index(n)\\n        try:\\n            return all_nums_of_same_digits[i + 1] if all_nums_of_same_digits[i + 1] <= 2**31 else -1\\n        except:\\n            return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        all_nums_of_same_digits = [int(\\'\\'.join(i)) for i in set(permutations(str(n)))]\\n        all_nums_of_same_digits.sort()\\n        i = all_nums_of_same_digits.index(n)\\n        try:\\n            return all_nums_of_same_digits[i + 1] if all_nums_of_same_digits[i + 1] <= 2**31 else -1\\n        except:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896546,
                "title": "o-n-js-solution-with-explanation",
                "content": "```\\n/*\\nI will consider the given number as a sequence of numbers.\\n\\nFirst thing to note is that for any sequence that is in descending order, there is no larger permutation.\\n\\n1. Convert given number into an array of digits.\\n2. Iterate through the array from the back. We want to find the pivot point.\\nThe pivot point is arr[i-1] where arr[i-1] < arr[i]. At this point, arr[i...end]\\nis in descending order because arr[i-1] is the first point where it is less than arr[i].\\n\\nHence, by rearranging arr[i...end], it isn\\'t possible to find a greater number.\\nWe should include the pivot point as well. Since we want to find the number just greater than given number, we will iterate from (end to i) and find the first number greater than pivot point.\\nWe swap these two numbers. Now, we have a greater number. But, it isn\\'t the next greater number yet because arr[i...end] is still in descending order.\\nIn order to find the number just greater than given number, we have to turn this subarray\\narr[i..end] into ascending order. We can do it by simply reversing it.\\n\\nThat\\'s it!\\n\\nNow, Convert the array back into number and return it.\\n*/\\n\\nvar nextGreaterElement = function(n) {\\n    let arr = n.toString().split(\"\");\\n    let pivot = -1;\\n    for (let i = arr.length-1; i > 0; i--) {\\n        if (arr[i-1] < arr[i]) {\\n            pivot = i-1;\\n            break;\\n        }\\n    }\\n    if (pivot === -1) return -1; // array is in descending order\\n    \\n    for (let i = arr.length-1; i > pivot; i--) {\\n        if (arr[i] > arr[pivot]) {\\n            [arr[pivot], arr[i]] = [arr[i], arr[pivot]]; // swap\\n            break;\\n        }\\n    }\\n    let left = arr.slice(0, pivot+1);\\n    let right = arr.slice(pivot+1);\\n    right.reverse();\\n    let res = Number(left.join(\"\") + right.join(\"\"));\\n    return res > Math.pow(2,31)-1 ? -1 : res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nI will consider the given number as a sequence of numbers.\\n\\nFirst thing to note is that for any sequence that is in descending order, there is no larger permutation.\\n\\n1. Convert given number into an array of digits.\\n2. Iterate through the array from the back. We want to find the pivot point.\\nThe pivot point is arr[i-1] where arr[i-1] < arr[i]. At this point, arr[i...end]\\nis in descending order because arr[i-1] is the first point where it is less than arr[i].\\n\\nHence, by rearranging arr[i...end], it isn\\'t possible to find a greater number.\\nWe should include the pivot point as well. Since we want to find the number just greater than given number, we will iterate from (end to i) and find the first number greater than pivot point.\\nWe swap these two numbers. Now, we have a greater number. But, it isn\\'t the next greater number yet because arr[i...end] is still in descending order.\\nIn order to find the number just greater than given number, we have to turn this subarray\\narr[i..end] into ascending order. We can do it by simply reversing it.\\n\\nThat\\'s it!\\n\\nNow, Convert the array back into number and return it.\\n*/\\n\\nvar nextGreaterElement = function(n) {\\n    let arr = n.toString().split(\"\");\\n    let pivot = -1;\\n    for (let i = arr.length-1; i > 0; i--) {\\n        if (arr[i-1] < arr[i]) {\\n            pivot = i-1;\\n            break;\\n        }\\n    }\\n    if (pivot === -1) return -1; // array is in descending order\\n    \\n    for (let i = arr.length-1; i > pivot; i--) {\\n        if (arr[i] > arr[pivot]) {\\n            [arr[pivot], arr[i]] = [arr[i], arr[pivot]]; // swap\\n            break;\\n        }\\n    }\\n    let left = arr.slice(0, pivot+1);\\n    let right = arr.slice(pivot+1);\\n    right.reverse();\\n    let res = Number(left.join(\"\") + right.join(\"\"));\\n    return res > Math.pow(2,31)-1 ? -1 : res;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486373,
                "title": "java-find-pivot-swap-sort-return",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = Integer.toString(n);\\n        int[] arr = new int[s.length()];\\n        for(int i = 0; i < s.length(); i++) {\\n            arr[i] = (int) (s.charAt(i) - \\'0\\');\\n        }\\n        \\n        int pivot = arr.length - 2;\\n        while(pivot >= 0 && arr[pivot] >= arr[pivot + 1]) {\\n            pivot --;\\n        }\\n        if(pivot == -1) return -1;\\n        \\n        for(int i = arr.length - 1; i >= 0; i--) {\\n            if(arr[i] > arr[pivot]) {\\n                int temp = arr[i];\\n                arr[i] = arr[pivot];\\n                arr[pivot] = temp;\\n                break;\\n            }\\n        }\\n        \\n        Arrays.sort(arr, pivot + 1, arr.length);\\n        long res = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            res *= 10;\\n            res += arr[i];\\n        }\\n        return res > Integer.MAX_VALUE ? -1 : (int) res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = Integer.toString(n);\\n        int[] arr = new int[s.length()];\\n        for(int i = 0; i < s.length(); i++) {\\n            arr[i] = (int) (s.charAt(i) - \\'0\\');\\n        }\\n        \\n        int pivot = arr.length - 2;\\n        while(pivot >= 0 && arr[pivot] >= arr[pivot + 1]) {\\n            pivot --;\\n        }\\n        if(pivot == -1) return -1;\\n        \\n        for(int i = arr.length - 1; i >= 0; i--) {\\n            if(arr[i] > arr[pivot]) {\\n                int temp = arr[i];\\n                arr[i] = arr[pivot];\\n                arr[pivot] = temp;\\n                break;\\n            }\\n        }\\n        \\n        Arrays.sort(arr, pivot + 1, arr.length);\\n        long res = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            res *= 10;\\n            res += arr[i];\\n        }\\n        return res > Integer.MAX_VALUE ? -1 : (int) res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798336,
                "title": "python-3-monotonic-stack-with-comments-beats-98",
                "content": "```python3 []\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(map(int, str(n)))\\n        stack, L = [], len(digits)\\n        for i in reversed(range(L)):\\n            # because need to find smallest highest than n, need to work from the end\\n            # do, while not be found any number less than exists in the stack\\n            # stack is mono increasing, so on the top is always max number (compare with top)\\n            # for n = 230[2]41 the smallest highest value is 23041[2]\\n            # we need to find 2 on this step, 2 < 4 (top of the stack), stack = [1, 4]\\n            if not stack or digits[stack[-1]] <= digits[i]:\\n                stack.append(i)\\n                continue\\n\\n            # find in the stack the index of the lowest biggest value than current digit, for 2 it\\'s 4\\n            # stack is sorted in asc order => can be used binary search\\n            # notice, than in stack indexes, not values, so use lambda to compare values\\n            swapIndex = stack[bisect_right(stack, digits[i], key = lambda x: digits[x])]\\n            # after swap 2 with 4 we have [2, 3, 0, 4, [2], 1]\\n            digits[i], digits[swapIndex] = digits[swapIndex], digits[i]\\n            # sort all values after i index, in our case it\\'s subarray [2, 1]\\n            # [2, 3, 0, 4, 1, 2] after sorting, but often part after index i will be already sorted\\n            digits[i+1:L] = sorted(digits[i+1:L])\\n            break\\n        # instead of comparison lenghts you can use flag and change it for True in else block\\n        # also check that final number less than 2**31, for example 2147483486 should return -1\\n        nextN = int(\\'\\'.join(map(str, digits)))\\n        \\n        return nextN if len(stack) < len(digits) and nextN < 2**31 else -1\\n```\\n```python []\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(map(int, str(n)))\\n        stack, L = [], len(digits)\\n        for i in reversed(range(L)):\\n            if not stack or digits[stack[-1]] <= digits[i]:\\n                stack.append(i)\\n                continue\\n            swapIndex = stack[bisect_right(stack, digits[i], key = lambda x: digits[x])]\\n            digits[i], digits[swapIndex] = digits[swapIndex], digits[i]\\n            digits[i+1:L] = sorted(digits[i+1:L])\\n            break\\n\\n        nextN = int(\\'\\'.join(map(str, digits)))\\n        \\n        return nextN if len(stack) < len(digits) and nextN < 2**31 else -1\\n```\\n![Screenshot 2023-08-04 at 21.25.52.png](https://assets.leetcode.com/users/images/dae0a336-a95c-44fb-8a80-7cdf6a39a05f_1691173689.8688965.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Monotonic Stack"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(map(int, str(n)))\\n        stack, L = [], len(digits)\\n        for i in reversed(range(L)):\\n            # because need to find smallest highest than n, need to work from the end\\n            # do, while not be found any number less than exists in the stack\\n            # stack is mono increasing, so on the top is always max number (compare with top)\\n            # for n = 230[2]41 the smallest highest value is 23041[2]\\n            # we need to find 2 on this step, 2 < 4 (top of the stack), stack = [1, 4]\\n            if not stack or digits[stack[-1]] <= digits[i]:\\n                stack.append(i)\\n                continue\\n\\n            # find in the stack the index of the lowest biggest value than current digit, for 2 it\\'s 4\\n            # stack is sorted in asc order => can be used binary search\\n            # notice, than in stack indexes, not values, so use lambda to compare values\\n            swapIndex = stack[bisect_right(stack, digits[i], key = lambda x: digits[x])]\\n            # after swap 2 with 4 we have [2, 3, 0, 4, [2], 1]\\n            digits[i], digits[swapIndex] = digits[swapIndex], digits[i]\\n            # sort all values after i index, in our case it\\'s subarray [2, 1]\\n            # [2, 3, 0, 4, 1, 2] after sorting, but often part after index i will be already sorted\\n            digits[i+1:L] = sorted(digits[i+1:L])\\n            break\\n        # instead of comparison lenghts you can use flag and change it for True in else block\\n        # also check that final number less than 2**31, for example 2147483486 should return -1\\n        nextN = int(\\'\\'.join(map(str, digits)))\\n        \\n        return nextN if len(stack) < len(digits) and nextN < 2**31 else -1\\n```\n```python []\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(map(int, str(n)))\\n        stack, L = [], len(digits)\\n        for i in reversed(range(L)):\\n            if not stack or digits[stack[-1]] <= digits[i]:\\n                stack.append(i)\\n                continue\\n            swapIndex = stack[bisect_right(stack, digits[i], key = lambda x: digits[x])]\\n            digits[i], digits[swapIndex] = digits[swapIndex], digits[i]\\n            digits[i+1:L] = sorted(digits[i+1:L])\\n            break\\n\\n        nextN = int(\\'\\'.join(map(str, digits)))\\n        \\n        return nextN if len(stack) < len(digits) and nextN < 2**31 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879748,
                "title": "beats-100-cpp",
                "content": "class Solution {\\npublic:\\n\\n    int nextGreaterElement(int n) {\\n        string s=to_string(n);\\n        next_permutation(s.begin(), s.end());\\n        long long t;\\n        t=stol(s);\\n        if(t>INT_MAX or t<=n)return -1;\\n        return t;    \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int nextGreaterElement(int n) {\\n        string s=to_string(n);\\n        next_permutation(s.begin(), s.end());\\n        long long t;\\n        t=stol(s);\\n        if(t>INT_MAX or t<=n)return -1;\\n        return t;    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2709211,
                "title": "0-ms-100-faster-easy-to-understand-with-algorithm-and-explaination-c",
                "content": "**ALGORITHM**\\n* Convert the given number to string\\n* Iterate from back and find out the point where the number decreases\\n* Mark it as first swapping index\\n* Find out the number which is just greater than first swapping index and mark it as second swapping index\\n* Swap the nos.\\n* Sort the substring from right of first swapping index till the end\\n* Return the ans\\n\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int num) {\\n        string str = to_string(num);\\n        int n = str.length();\\n        int deflection = n-1;\\n        // calculate the deflection point where string decreases from the back\\n        while(deflection > 0){\\n            if(str[deflection] > str[deflection - 1]){\\n                break;\\n            }\\n            deflection--;\\n        }\\n        if(deflection == 0) return -1;\\n        int firstSwapIndex = deflection - 1;\\n        int secondSwapIndex = n - 1;\\n        // calculate second swap index\\n        while(firstSwapIndex <= secondSwapIndex){\\n            if(str[secondSwapIndex] > str[firstSwapIndex]){\\n                break;\\n            }\\n            secondSwapIndex--;\\n        }\\n        // swap the indexes\\n        swap(str[firstSwapIndex],str[secondSwapIndex]);\\n       // cout<<str;\\n        // sort the substring\\n        sort(str.begin() + firstSwapIndex + 1,str.end());\\n        long long ans = stoll(str);\\n        // check if our ans is going out of bounds\\n        if (ans <= pow(2, 31) - 1)\\n            return stoi(str);\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int num) {\\n        string str = to_string(num);\\n        int n = str.length();\\n        int deflection = n-1;\\n        // calculate the deflection point where string decreases from the back\\n        while(deflection > 0){\\n            if(str[deflection] > str[deflection - 1]){\\n                break;\\n            }\\n            deflection--;\\n        }\\n        if(deflection == 0) return -1;\\n        int firstSwapIndex = deflection - 1;\\n        int secondSwapIndex = n - 1;\\n        // calculate second swap index\\n        while(firstSwapIndex <= secondSwapIndex){\\n            if(str[secondSwapIndex] > str[firstSwapIndex]){\\n                break;\\n            }\\n            secondSwapIndex--;\\n        }\\n        // swap the indexes\\n        swap(str[firstSwapIndex],str[secondSwapIndex]);\\n       // cout<<str;\\n        // sort the substring\\n        sort(str.begin() + firstSwapIndex + 1,str.end());\\n        long long ans = stoll(str);\\n        // check if our ans is going out of bounds\\n        if (ans <= pow(2, 31) - 1)\\n            return stoi(str);\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2252388,
                "title": "short-python-solution",
                "content": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(str(n))\\n        if digits == sorted(digits, reverse=True):\\n            return -1\\n        \\n        x = max(i for i in range(len(digits)-1) if digits[i] < digits[i+1])\\n        y = max(i for i in range(x+1, len(digits)) if digits[i] > digits[x])\\n        \\n        digits[x], digits[y] = digits[y], digits[x]\\n        digits[x+1:] = sorted(digits[x+1:])\\n        \\n        nxt = int(\\'\\'.join(digits))\\n        \\n        return nxt if nxt < 2**31 else -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(str(n))\\n        if digits == sorted(digits, reverse=True):\\n            return -1\\n        \\n        x = max(i for i in range(len(digits)-1) if digits[i] < digits[i+1])\\n        y = max(i for i in range(x+1, len(digits)) if digits[i] > digits[x])\\n        \\n        digits[x], digits[y] = digits[y], digits[x]\\n        digits[x+1:] = sorted(digits[x+1:])\\n        \\n        nxt = int(\\'\\'.join(digits))\\n        \\n        return nxt if nxt < 2**31 else -1",
                "codeTag": "Java"
            },
            {
                "id": 1763772,
                "title": "c-100-faster-solution",
                "content": "*\\tNaive- We can create a permutation array and just return the next number in our array and \\n\\tIf it is the last number in array return -1*\\n\\t\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint nextGreaterElement(int n) {\\n\\t\\t\\t\\t string s=to_string(n);\\n\\t\\t\\t\\t int idx1=-1,idx2=-1;\\n\\t\\t\\t\\tfor(int i=s.length()-2;i>=0;i--){\\n\\t\\t\\t\\t\\tif(s[i]<s[i+1]){\\n\\t\\t\\t\\t\\t\\tidx1=i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(idx1==-1) return -1;\\n\\n\\t\\t\\t\\tfor(int i=s.length()-1;i>=0;i--){\\n\\t\\t\\t\\t\\tif(s[i]>s[idx1]){\\n\\t\\t\\t\\t\\t\\tidx2=i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(idx2==-1) return -1;\\n\\t\\t\\t\\t swap(s[idx1],s[idx2]);\\n\\t\\t\\t\\treverse(s.begin()+idx1+1,s.end());\\n\\t\\t\\t\\treturn stoll(s)>INT_MAX?-1:stoll(s);\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint nextGreaterElement(int n) {\\n\\t\\t\\t\\t string s=to_string(n);\\n\\t\\t\\t\\t int idx1=-1,idx2=-1;\\n\\t\\t\\t\\tfor(int i=s.length()-2;i>=0;i--){\\n\\t\\t\\t\\t\\tif(s[i]<s[i+1]){\\n\\t\\t\\t\\t\\t\\tidx1=i;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1650790,
                "title": "2-approaches-simple-easy-c",
                "content": "Implementation\\n\\nQuestion is same as finding the next permutation of a number\\n\\n**Time Complexity = O(N), Space Complexity = O(1)**\\n```\\nclass Solution {\\npublic:    \\n    int nextGreaterElement(int n) {        \\n        // converting number digits into string, not in array bcz of the memory overflow issue\\n        string str = to_string(n);\\n        \\n        // traversing from back and checking if any index is having element lesser than the its index+1         // i.e => 6,5,3,7,4,2,1 => on index 2 we are getting smaller element\\n        int itr = str.size()-2;\\n        while(itr >= 0 && str[itr] >= str[itr+1]){            \\n            itr--;\\n        }\\n        \\n        // it means number is already max\\n        // means number is in decreasing order\\n        // i.e => 3,2,1\\n        if(itr == -1) return -1;\\n        \\n        // finding the next greater element of str[itr] from end        \\n        int jtr = str.size()-1;\\n        while(str[itr] >= str[jtr]){\\n            jtr--;\\n        }\\n        \\n        // after getting, we will swap the itr and jtr position element\\n        swap(str[itr], str[jtr]);\\n        \\n        // reverse all the elements from itr+1 to end;\\n        reverse(str.begin()+itr+1, str.end());\\n        \\n        // convert back into long(not in int bcz of the memory overflow issue)\\n        long res = stol(str);\\n\\n        // if its more than INT_MAX or its equal to n means no change, then return -1, otherwise res\\n        return (res > INT_MAX || res == n) ? -1 : res;\\n    }\\n};\\n```\\n\\n**Using C++ STL function(next_permutation)**\\n**Another approach**\\n```\\nclass Solution {\\npublic:    \\n    int nextGreaterElement(int n) {  \\n        // converting number digits into string\\n        string str = to_string(n);\\n        \\n        // C++ STL function used to get the next permutation of a number\\n        next_permutation(begin(str), end(str));\\n                \\n        // convert back into long(not in int bcz of the memory overflow issue)\\n        long res = stol(str);\\n        \\n        // if its more than INT_MAX or its equal to n means no change, then return -1, otherwise res\\n        return (res > INT_MAX || res <= n) ? -1 : res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int nextGreaterElement(int n) {        \\n        // converting number digits into string, not in array bcz of the memory overflow issue\\n        string str = to_string(n);\\n        \\n        // traversing from back and checking if any index is having element lesser than the its index+1         // i.e => 6,5,3,7,4,2,1 => on index 2 we are getting smaller element\\n        int itr = str.size()-2;\\n        while(itr >= 0 && str[itr] >= str[itr+1]){            \\n            itr--;\\n        }\\n        \\n        // it means number is already max\\n        // means number is in decreasing order\\n        // i.e => 3,2,1\\n        if(itr == -1) return -1;\\n        \\n        // finding the next greater element of str[itr] from end        \\n        int jtr = str.size()-1;\\n        while(str[itr] >= str[jtr]){\\n            jtr--;\\n        }\\n        \\n        // after getting, we will swap the itr and jtr position element\\n        swap(str[itr], str[jtr]);\\n        \\n        // reverse all the elements from itr+1 to end;\\n        reverse(str.begin()+itr+1, str.end());\\n        \\n        // convert back into long(not in int bcz of the memory overflow issue)\\n        long res = stol(str);\\n\\n        // if its more than INT_MAX or its equal to n means no change, then return -1, otherwise res\\n        return (res > INT_MAX || res == n) ? -1 : res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int nextGreaterElement(int n) {  \\n        // converting number digits into string\\n        string str = to_string(n);\\n        \\n        // C++ STL function used to get the next permutation of a number\\n        next_permutation(begin(str), end(str));\\n                \\n        // convert back into long(not in int bcz of the memory overflow issue)\\n        long res = stol(str);\\n        \\n        // if its more than INT_MAX or its equal to n means no change, then return -1, otherwise res\\n        return (res > INT_MAX || res <= n) ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430431,
                "title": "c-beats-100-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vector<int> num;\\n        while(n) {\\n            num.push_back(n % 10);\\n            n /= 10;\\n        }\\n        if(num.size() == 1) return -1;\\n        reverse(num.begin(), num.end());\\n        bool flag = false;\\n        n = num.size();\\n        for(int i = n - 1; i > 0; i--) {\\n            if(num[i] > num[i - 1]) {\\n                flag = true;\\n                int point = n - 1;\\n                for(int j = i; j < n; j++) {\\n                    if(num[j] <= num[i - 1]) {\\n                        point = j - 1;\\n                        break;\\n                    }\\n                }\\n                swap(num[point], num[i - 1]);\\n                reverse(num.begin() + i, num.end());\\n                break;\\n            }\\n        }\\n        if(!flag) return -1;\\n        long long ans = 0;\\n        for(int i : num) {\\n            ans = ans * 10LL + (long long)i;\\n        }\\n        if(ans > ((1LL << 31) - 1)) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vector<int> num;\\n        while(n) {\\n            num.push_back(n % 10);\\n            n /= 10;\\n        }\\n        if(num.size() == 1) return -1;\\n        reverse(num.begin(), num.end());\\n        bool flag = false;\\n        n = num.size();\\n        for(int i = n - 1; i > 0; i--) {\\n            if(num[i] > num[i - 1]) {\\n                flag = true;\\n                int point = n - 1;\\n                for(int j = i; j < n; j++) {\\n                    if(num[j] <= num[i - 1]) {\\n                        point = j - 1;\\n                        break;\\n                    }\\n                }\\n                swap(num[point], num[i - 1]);\\n                reverse(num.begin() + i, num.end());\\n                break;\\n            }\\n        }\\n        if(!flag) return -1;\\n        long long ans = 0;\\n        for(int i : num) {\\n            ans = ans * 10LL + (long long)i;\\n        }\\n        if(ans > ((1LL << 31) - 1)) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725311,
                "title": "java-with-explaination-0ms-100-faster-without-sorting",
                "content": "\\n1.\\tWe will start searching element from right to left until elements are increasing.\\n2.\\tIf index reaches 0. It means next greater element is not possible and return -1.\\n3.\\tElse index-1 is the desired index. after that index we need to find the element from right to left till index whose value is greater than element present at index.\\n4.\\tNow just swap the two elements present at index-1 and j.\\n5.\\tReverse the array after the swapped index location i.\\n6. at last just to check out of range convert string to long and check int range.\\n\\n\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n\\t\\tchar[] num = String.valueOf(n).toCharArray();\\n\\t\\tint i=num.length-1;\\n        while(i>0 && num[i]<=num[i-1]) {\\n            i--;\\n        }\\n        if(i==0){\\n            return -1;\\n        }\\n        i--;\\n        int j=num.length-1;\\n        while(num[j]<=num[i]){\\n            j--;\\n        }\\n        swap(num,i,j);\\n        reverse(num,i+1);\\n\\t\\tlong val = Long.parseLong(String.valueOf(num));\\n\\t\\treturn val > Integer.MAX_VALUE ? -1 : (int) val;\\n\\t}\\n    \\n    private void reverse(char[] num, int l) {\\n       int h=num.length-1;\\n        while(l<h) {\\n            swap(num,l++,h--);\\n        }\\n    }\\n    \\n    private void swap(char[] num,int i,int j){\\n        num[i] ^= num[j];\\n\\t\\tnum[j] ^= num[i];\\n\\t\\tnum[i] ^= num[j];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n\\t\\tchar[] num = String.valueOf(n).toCharArray();\\n\\t\\tint i=num.length-1;\\n        while(i>0 && num[i]<=num[i-1]) {\\n            i--;\\n        }\\n        if(i==0){\\n            return -1;\\n        }\\n        i--;\\n        int j=num.length-1;\\n        while(num[j]<=num[i]){\\n            j--;\\n        }\\n        swap(num,i,j);\\n        reverse(num,i+1);\\n\\t\\tlong val = Long.parseLong(String.valueOf(num));\\n\\t\\treturn val > Integer.MAX_VALUE ? -1 : (int) val;\\n\\t}\\n    \\n    private void reverse(char[] num, int l) {\\n       int h=num.length-1;\\n        while(l<h) {\\n            swap(num,l++,h--);\\n        }\\n    }\\n    \\n    private void swap(char[] num,int i,int j){\\n        num[i] ^= num[j];\\n\\t\\tnum[j] ^= num[i];\\n\\t\\tnum[i] ^= num[j];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724120,
                "title": "python3-solution-same-as-next-permutation",
                "content": "```\\nclass Solution:\\n        \\n    def nextGreaterElement(self, n: int) -> int:\\n        arr = list(str(n))\\n        length = len(arr)\\n        index = None\\n        for i in range(length-2,-1,-1):\\n            if arr[i]<arr[i+1]:\\n                index = i\\n                break\\n        if index==None:\\n            return -1\\n        x = arr[index]\\n        smallest = None\\n        for i in range(index,length):\\n            if smallest==None and arr[i]>x:\\n                smallest = i\\n            elif arr[i] > x and arr[i] < arr[smallest]: \\n                smallest = i\\n        arr[index],arr[smallest] = arr[smallest],arr[index]\\n        arr = arr[:index+1] + list(sorted(arr[index+1:]))\\n        res = int(\"\".join(arr))\\n        return -1 if res > 2147483647 else res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n        \\n    def nextGreaterElement(self, n: int) -> int:\\n        arr = list(str(n))\\n        length = len(arr)\\n        index = None\\n        for i in range(length-2,-1,-1):\\n            if arr[i]<arr[i+1]:\\n                index = i\\n                break\\n        if index==None:\\n            return -1\\n        x = arr[index]\\n        smallest = None\\n        for i in range(index,length):\\n            if smallest==None and arr[i]>x:\\n                smallest = i\\n            elif arr[i] > x and arr[i] < arr[smallest]: \\n                smallest = i\\n        arr[index],arr[smallest] = arr[smallest],arr[index]\\n        arr = arr[:index+1] + list(sorted(arr[index+1:]))\\n        res = int(\"\".join(arr))\\n        return -1 if res > 2147483647 else res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619654,
                "title": "concise-javascript-solution",
                "content": "```\\nconst nextGreaterElement = n => {\\n    let arr = Array.from(`${n}`, Number)\\n    let max = -Infinity, idx = -1\\n    for(let i = arr.length-1; i >= 0; i--){\\n        if(arr[i] < max){\\n            idx = i\\n            break\\n        }\\n        max = Math.max(max, arr[i])\\n    }\\n    if(idx === -1)return -1\\n    let secondHalf = arr.splice(idx+1).sort((a,b) => a - b)\\n    for(let i = 0; i < secondHalf.length; i++)\\n        if(secondHalf[i] > arr[idx]){\\n            [arr[idx], secondHalf[i]] = [secondHalf[i], arr[idx]]\\n            break\\n        }\\n    let result = +arr.concat(secondHalf).join``\\n    let max32BitInt = 2147483647\\n    return result > max32BitInt ? -1 : result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst nextGreaterElement = n => {\\n    let arr = Array.from(`${n}`, Number)\\n    let max = -Infinity, idx = -1\\n    for(let i = arr.length-1; i >= 0; i--){\\n        if(arr[i] < max){\\n            idx = i\\n            break\\n        }\\n        max = Math.max(max, arr[i])\\n    }\\n    if(idx === -1)return -1\\n    let secondHalf = arr.splice(idx+1).sort((a,b) => a - b)\\n    for(let i = 0; i < secondHalf.length; i++)\\n        if(secondHalf[i] > arr[idx]){\\n            [arr[idx], secondHalf[i]] = [secondHalf[i], arr[idx]]\\n            break\\n        }\\n    let result = +arr.concat(secondHalf).join``\\n    let max32BitInt = 2147483647\\n    return result > max32BitInt ? -1 : result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387468,
                "title": "easy-peasy-python-comments-linear-python-solution",
                "content": "\\tdef nextGreaterElement(self, n: int) -> int:\\n        if n == 0:\\n            return -1\\n        \\n        nums = list(str(n))\\n        ln = len(nums)\\n        i = ln-1\\n        # find the first non increasing sequence from the right\\n        while i > 0:\\n            if nums[i-1] < nums[i]:\\n                break\\n            i -= 1\\n        \\n        #this is the number to be replaced as it is smaller\\n        # than any other element on the right of it\\n        i -= 1  \\n        \\n        if i < 0:\\n            return -1\\n\\n        # look for the min largest number greater than nums[i]\\n        # and swap it and sort the rest\\n        temp = ln-1\\n        while temp > i:\\n            if nums[i] < nums[temp]:\\n                break\\n            temp -= 1\\n        \\n        nums[i], nums[temp] = nums[temp], nums[i]\\n        \\n        #sort rest of the stuff from [i+1, ln-1]\\n        nums[i+1:] = sorted(nums[i+1:]) \\n        res = int(\"\".join(nums))\\n        return  res if (res > n and res <= (2**31-1)) else -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Probability and Statistics"
                ],
                "code": "\\tdef nextGreaterElement(self, n: int) -> int:\\n        if n == 0:\\n            return -1\\n        \\n        nums = list(str(n))\\n        ln = len(nums)\\n        i = ln-1\\n        # find the first non increasing sequence from the right\\n        while i > 0:\\n            if nums[i-1] < nums[i]:\\n                break\\n            i -= 1\\n        \\n        #this is the number to be replaced as it is smaller\\n        # than any other element on the right of it\\n        i -= 1  \\n        \\n        if i < 0:\\n            return -1\\n\\n        # look for the min largest number greater than nums[i]\\n        # and swap it and sort the rest\\n        temp = ln-1\\n        while temp > i:\\n            if nums[i] < nums[temp]:\\n                break\\n            temp -= 1\\n        \\n        nums[i], nums[temp] = nums[temp], nums[i]\\n        \\n        #sort rest of the stuff from [i+1, ln-1]\\n        nums[i+1:] = sorted(nums[i+1:]) \\n        res = int(\"\".join(nums))\\n        return  res if (res > n and res <= (2**31-1)) else -1",
                "codeTag": "Python3"
            },
            {
                "id": 289065,
                "title": "java-0ms-solution-which-beats-100-with-explanation",
                "content": "This problem is similar to [738. Monotone Increasing Digits](https://leetcode.com/problems/monotone-increasing-digits/). The key word of such problems is **monotonicity**, i.e., we need to judge the monotonicity of digits appearing in the given number. \\n\\nIn this problem, if the digit is monotone decreasing, then we cannot find the next greater number. Otherwise, we can solve it with the following steps:\\n1. At first, we use a list to represent the given number N where list.get(0) is the highest number.\\n2. Then, we **backwardly** traverse from list.size() - 1 to 1 to find the **first** i that list[i] > list[i - 1]. Record the i as pivot.\\n3. Next\\uFF0Cwe **backwardly** traverse from list.size() - 1 to **i** to find the first j that list[j] > list[**i** - 1].\\n4. At last, we swap list[i - 1] and list[j] and reverse list[i] to list[size - 1]\\n\\nFor example, if n = 1387543, the algorithm works as following:\\n* After step two, we get 13 87543\\n* After step three, we get 13 875**4**3\\n* After swap, we get 14 87533\\n* After reverse, we get the final result 1433578 \\n\\n```\\npublic int nextGreaterElement(int n) {\\n    List<Integer> numList = new ArrayList<Integer>();\\n    while( n != 0 ) {\\n        numList.add(0, n % 10);\\n        n /= 10;\\n    }\\n    int pivot = -1;\\n    for(int i = numList.size() - 1; i >= 0; i--) {\\n        if( i == 0 ) // The digit in n is monotone decreasing\\n            return -1;\\n        if( numList.get(i) > numList.get(i - 1) ) { // find the pivot\\n            pivot = i;\\n            for(int j = numList.size() - 1; j >= i; j--) {\\n                if( numList.get(j) > numList.get(i - 1) ) { // swap operation\\n                    int temp = numList.get(i - 1);\\n                    numList.set(i - 1, numList.get(j));\\n                    numList.set(j, temp);\\n                    break;\\n                }\\n            }\\n            break;\\n        }\\n    }\\n    long num = 0;\\n    for(int i = 0; i <= pivot - 1; i++)\\n        num = num * 10 + numList.get(i);\\n    for(int i = numList.size() - 1; i >= pivot; i--) // reverse from pivot to the end of list\\n        num = num * 10 + numList.get(i);\\n    return num > Integer.MAX_VALUE ? -1 : (int)num;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\npublic int nextGreaterElement(int n) {\\n    List<Integer> numList = new ArrayList<Integer>();\\n    while( n != 0 ) {\\n        numList.add(0, n % 10);\\n        n /= 10;\\n    }\\n    int pivot = -1;\\n    for(int i = numList.size() - 1; i >= 0; i--) {\\n        if( i == 0 ) // The digit in n is monotone decreasing\\n            return -1;\\n        if( numList.get(i) > numList.get(i - 1) ) { // find the pivot\\n            pivot = i;\\n            for(int j = numList.size() - 1; j >= i; j--) {\\n                if( numList.get(j) > numList.get(i - 1) ) { // swap operation\\n                    int temp = numList.get(i - 1);\\n                    numList.set(i - 1, numList.get(j));\\n                    numList.set(j, temp);\\n                    break;\\n                }\\n            }\\n            break;\\n        }\\n    }\\n    long num = 0;\\n    for(int i = 0; i <= pivot - 1; i++)\\n        num = num * 10 + numList.get(i);\\n    for(int i = numList.size() - 1; i >= pivot; i--) // reverse from pivot to the end of list\\n        num = num * 10 + numList.get(i);\\n    return num > Integer.MAX_VALUE ? -1 : (int)num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101871,
                "title": "concise-java-solution-equivalent-to-next-greater-permutation",
                "content": "```\\npublic int nextGreaterElement(int num) {\\n    String n = Integer.toString(num);\\n    for (int i=n.length()-2;i>=0;i--) {\\n        if (n.charAt(i) >= n.charAt(i+1)) continue;\\n        for (int j=n.length()-1;j>i;j--) {\\n            if (n.charAt(i) >= n.charAt(j)) continue;\\n            try {\\n                return Integer.parseInt(n.substring(0,i) + n.charAt(j) \\n                       + new StringBuilder(n.substring(i+1, j) + n.charAt(i) + n.substring(j+1)).reverse().toString()); \\n            } catch(Exception e) { return -1; }\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int nextGreaterElement(int num) {\\n    String n = Integer.toString(num);\\n    for (int i=n.length()-2;i>=0;i--) {\\n        if (n.charAt(i) >= n.charAt(i+1)) continue;\\n        for (int j=n.length()-1;j>i;j--) {\\n            if (n.charAt(i) >= n.charAt(j)) continue;\\n            try {\\n                return Integer.parseInt(n.substring(0,i) + n.charAt(j) \\n                       + new StringBuilder(n.substring(i+1, j) + n.charAt(i) + n.substring(j+1)).reverse().toString()); \\n            } catch(Exception e) { return -1; }\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998834,
                "title": "my-c-code-without-string-stl",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used simple mathematics and STL\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n       vector<int>vec;\\n       int temp = n;\\n        while(n>0){\\n            int r = n%10;\\n            vec.push_back(r);\\n            n /= 10; \\n        }\\n        sort(vec.begin(),vec.end());\\n        do{\\n            int num=0;\\n            long j=0;\\n            int s = vec.size()-1;\\n            long i = pow(10,s);\\n            while(i>0)\\n           {\\n            num += i*vec[j++];\\n            i /= 10;\\n           }\\n              if(num>temp)\\n                 return num;\\n    \\n        } while(next_permutation(vec.begin(),vec.end()));\\n       return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n       vector<int>vec;\\n       int temp = n;\\n        while(n>0){\\n            int r = n%10;\\n            vec.push_back(r);\\n            n /= 10; \\n        }\\n        sort(vec.begin(),vec.end());\\n        do{\\n            int num=0;\\n            long j=0;\\n            int s = vec.size()-1;\\n            long i = pow(10,s);\\n            while(i>0)\\n           {\\n            num += i*vec[j++];\\n            i /= 10;\\n           }\\n              if(num>temp)\\n                 return num;\\n    \\n        } while(next_permutation(vec.begin(),vec.end()));\\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126399,
                "title": "c-o-n-100-solution-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void next_permutation(string &nums)\\n    {\\n        int k =-1;\\n        int l;\\n        int n = nums.size();\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i] < nums[i+1])\\n            {\\n                k = i;\\n                break;\\n            }\\n        }\\n        if(k<0)\\n        {\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else\\n        {\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                if(nums[i] > nums[k])\\n                {\\n                    l = i;\\n                    break;\\n                }\\n            }\\n            swap(nums[k],nums[l]);\\n            reverse(nums.begin()+k+1,nums.end());\\n        }\\n        \\n    }\\n    int nextGreaterElement(int n) {\\n        string temp = to_string(n);\\n        next_permutation(temp);\\n        long long int ans = stoll(temp);\\n        // cout << ans << endl;\\n        return (ans > INT_MAX || (ans <= n)) ? -1 : ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void next_permutation(string &nums)\\n    {\\n        int k =-1;\\n        int l;\\n        int n = nums.size();\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i] < nums[i+1])\\n            {\\n                k = i;\\n                break;\\n            }\\n        }\\n        if(k<0)\\n        {\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else\\n        {\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                if(nums[i] > nums[k])\\n                {\\n                    l = i;\\n                    break;\\n                }\\n            }\\n            swap(nums[k],nums[l]);\\n            reverse(nums.begin()+k+1,nums.end());\\n        }\\n        \\n    }\\n    int nextGreaterElement(int n) {\\n        string temp = to_string(n);\\n        next_permutation(temp);\\n        long long int ans = stoll(temp);\\n        // cout << ans << endl;\\n        return (ans > INT_MAX || (ans <= n)) ? -1 : ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1993221,
                "title": "java-faster-than-100",
                "content": "```class Solution {\\n    public int nextGreaterElement(int n) {\\n     \\n        int index1=-1;\\n        char []ch=String.valueOf(n).toCharArray();\\n        int len=ch.length;\\n        int i=len-1;\\n        while(i>0){\\n            if(ch[i]>ch[i-1]){\\n                index1=i-1;\\n                break;\\n            }\\n            i--;\\n        }\\n        if(index1==-1)\\n            return -1;\\n        int index2=-1;\\n        i=len-1;\\n        while(i>index1){\\n            if(ch[i]>ch[index1]){\\n                index2=i;\\n                break;\\n            }\\n            i--;\\n        }\\n        char temp=ch[index1];\\n        ch[index1]=ch[index2];\\n        ch[index2]=temp;\\n        \\n        \\n        StringBuilder result=new StringBuilder();\\n        for(i=0;i<=index1;i++){\\n            result.append(ch[i]);\\n        }\\n        for(i=len-1;i>index1;i--){\\n            result.append(ch[i]);\\n        }\\n        \\n        //Long conversion due to failure of a test case (read note in question)\\n        return Long.parseLong(result.toString())>Integer.MAX_VALUE?-1:\\n        Integer.parseInt(result.toString());\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int nextGreaterElement(int n) {\\n     \\n        int index1=-1;\\n        char []ch=String.valueOf(n).toCharArray();\\n        int len=ch.length;\\n        int i=len-1;\\n        while(i>0){\\n            if(ch[i]>ch[i-1]){\\n                index1=i-1;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1874594,
                "title": "java-o-n-solution-with-explanation",
                "content": "#### Explanation:\\n \\n The smallest `n` should be in increasing order, e.g. (`1234`, `12`,` 456`).\\n\\nAnd as we know the next greater element of an increasing order `n` is to swap the largest digit with the second largest.\\n- `1234` -> `1243`\\n- `12` -> `21`\\n- `456` -> `465`\\n\\nBut what if:\\n- `1243` -> `1324`\\n- `3391` -> `3913`\\n- `4382931` -> `4383129`\\n\\nIf `n` is not in increasing order, we need to find the first decreasing element from the right. The goal here is to perform the swap to get a greater `n`, but not the greatest of `n`. So we only look for the first digit from right that\\'s greater. (only looking at the right side because swaping with the left side will make the value smaller, but get the greater element from right will get us a greater `n`)\\n\\nAnd swap with any element that\\'s the first greater \\n- `1243`, first decreasing is `2`, first greater `2` is `3`. -> `1342`\\n- `3391`, first decreasing is `3`, first greater `3` is `9`. -> `3931`\\n- `4382931`, first decreasing is `2`, first greater than `2` is `3` -> `4383921`\\n\\nHowever, it\\'s still not the next greater, it\\'s greater than the next greater. Since we already swap the first decreasing with a bigger digit to the front, we know that it\\'s already greater `n`. \\n\\n\\n**To find the next greater but not too far off.** \\n\\nWe know that an increasing order `n` is the smallest and we already found out that the right part is in decreasing order and after the swap it\\'s still decreasing. Then, we can reverse the right part to get an increasing order of elements so it becomes the smallest.\\n\\nTherefore,\\n\\t- Originally `1242`, then `1342` -> `1324`\\n\\t- Originally `3391`, then `3931` -> `3913`\\n\\t- Originally `4382931`, then `4383921` -> `4383129`\\n\\n<br>\\n\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        // similar to next permutation\\n        String s = String.valueOf(n);\\n        int[] arr = new int[s.length()];\\n        int len = s.length();\\n        \\n        for (int i = 0; i < len; i++) \\n            arr[i] = (int) (s.charAt(i) - \\'0\\');\\n        \\n        // get the first decreasing element from the right\\n        int i = len-1;\\n        while (i > 0 && arr[i-1] >= arr[i]) \\n            i--;\\n        \\n        // if all elements are in decreasing order from left\\n        // it\\'s the greatest combination, we can\\'t get a greater combination\\n        \\n        if (i == 0)\\n            return -1;\\n        \\n        int pivot = i;\\n        \\n        // find the first greater from the right\\n        i = len-1;\\n        while (i >= 0 && arr[i] <= arr[pivot-1])\\n            i--;\\n        \\n        // swap the with first decreasing with first greater\\n        int temp = arr[pivot-1];\\n        arr[pivot-1] = arr[i];\\n        arr[i] = temp;\\n        \\n        // reverse all elements starting from pivot\\n        i = len-1;\\n        while (pivot < i) {\\n            temp = arr[pivot];\\n            arr[pivot] = arr[i];\\n            arr[i] = temp;\\n            \\n            pivot++;\\n            i--;\\n        }\\n        \\n        // convert back to integer \\n        long ans = 0;\\n        for (int a: arr) {\\n            ans = ans*10 + a;\\n        }\\n            \\n        if (ans > Integer.MAX_VALUE)\\n            return -1;\\n        return (int) ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        // similar to next permutation\\n        String s = String.valueOf(n);\\n        int[] arr = new int[s.length()];\\n        int len = s.length();\\n        \\n        for (int i = 0; i < len; i++) \\n            arr[i] = (int) (s.charAt(i) - \\'0\\');\\n        \\n        // get the first decreasing element from the right\\n        int i = len-1;\\n        while (i > 0 && arr[i-1] >= arr[i]) \\n            i--;\\n        \\n        // if all elements are in decreasing order from left\\n        // it\\'s the greatest combination, we can\\'t get a greater combination\\n        \\n        if (i == 0)\\n            return -1;\\n        \\n        int pivot = i;\\n        \\n        // find the first greater from the right\\n        i = len-1;\\n        while (i >= 0 && arr[i] <= arr[pivot-1])\\n            i--;\\n        \\n        // swap the with first decreasing with first greater\\n        int temp = arr[pivot-1];\\n        arr[pivot-1] = arr[i];\\n        arr[i] = temp;\\n        \\n        // reverse all elements starting from pivot\\n        i = len-1;\\n        while (pivot < i) {\\n            temp = arr[pivot];\\n            arr[pivot] = arr[i];\\n            arr[i] = temp;\\n            \\n            pivot++;\\n            i--;\\n        }\\n        \\n        // convert back to integer \\n        long ans = 0;\\n        for (int a: arr) {\\n            ans = ans*10 + a;\\n        }\\n            \\n        if (ans > Integer.MAX_VALUE)\\n            return -1;\\n        return (int) ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838598,
                "title": "c-100-faster-solution-same-as-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s=to_string(n);\\n        int i;\\n        for(i=s.length()-1;i>=1;i--)\\n            if(s[i-1]<s[i])\\n                break;\\n        if(i==0)\\n            return -1;\\n        sort(s.begin()+i,s.end());\\n        int j;\\n        for(j=i;j<s.length();j++)\\n            if(s[j]>s[i-1])\\n                break;\\n        swap(s[j],s[i-1]);\\n        long int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            res*=10;\\n            res+=s[i]-\\'0\\';\\n        }\\n        return (res>INT_MAX)?-1:res;\\n                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s=to_string(n);\\n        int i;\\n        for(i=s.length()-1;i>=1;i--)\\n            if(s[i-1]<s[i])\\n                break;\\n        if(i==0)\\n            return -1;\\n        sort(s.begin()+i,s.end());\\n        int j;\\n        for(j=i;j<s.length();j++)\\n            if(s[j]>s[i-1])\\n                break;\\n        swap(s[j],s[i-1]);\\n        long int res=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            res*=10;\\n            res+=s[i]-\\'0\\';\\n        }\\n        return (res>INT_MAX)?-1:res;\\n                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627852,
                "title": "swift-self-explainable-o-n-next-permutation",
                "content": "```\\nclass Solution {\\n    func nextGreaterElement(_ n: Int) -> Int {\\n        var nArray = Array(String(n))\\n        guard nArray.count >= 2 else {\\n            return -1\\n        }\\n        var prevIdx = nArray.count - 1\\n        for currIdx in stride(from: nArray.count - 2, through: 0, by: -1) {\\n            prevIdx = currIdx + 1\\n            if nArray[prevIdx] > nArray[currIdx] {\\n                var swapIdx = nArray.count - 1\\n                while swapIdx > currIdx {\\n                    if nArray[currIdx] < nArray[swapIdx] {\\n                        nArray.swapAt(swapIdx, currIdx)\\n                        nArray = Array(nArray[0...currIdx]) + Array(nArray[prevIdx..<nArray.count]).reversed()\\n                        let result = Int(nArray.map { String($0) }.reduce(\"\") { $0 + $1 })!\\n                        if result <= Int32.max {\\n                            return result\\n                        } else {\\n                            return -1\\n                        }\\n                    } else {\\n                        swapIdx -= 1\\n                    }\\n                }\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func nextGreaterElement(_ n: Int) -> Int {\\n        var nArray = Array(String(n))\\n        guard nArray.count >= 2 else {\\n            return -1\\n        }\\n        var prevIdx = nArray.count - 1\\n        for currIdx in stride(from: nArray.count - 2, through: 0, by: -1) {\\n            prevIdx = currIdx + 1\\n            if nArray[prevIdx] > nArray[currIdx] {\\n                var swapIdx = nArray.count - 1\\n                while swapIdx > currIdx {\\n                    if nArray[currIdx] < nArray[swapIdx] {\\n                        nArray.swapAt(swapIdx, currIdx)\\n                        nArray = Array(nArray[0...currIdx]) + Array(nArray[prevIdx..<nArray.count]).reversed()\\n                        let result = Int(nArray.map { String($0) }.reduce(\"\") { $0 + $1 })!\\n                        if result <= Int32.max {\\n                            return result\\n                        } else {\\n                            return -1\\n                        }\\n                    } else {\\n                        swapIdx -= 1\\n                    }\\n                }\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544937,
                "title": "java-0ms-must-watch-efficient",
                "content": "class Solution {\\n    public int nextGreaterElement(int n) {\\n        \\n        String str = Integer.toString(n);\\n        char [] arr = str.toCharArray();\\n        \\n        // To find the dip             //45132 - At pos: of 1 dip occurs\\n        int i = arr.length - 2;\\n        while(i >= 0 && arr[i] >= arr[i + 1]){\\n            i--;\\n        }\\n        \\n        if(i == -1)\\n            return -1;\\n            \\n        //To Find the index of greater element than at idx i\\n        int j = arr.length - 1;\\n        while(arr[i] >= arr[j]){\\n            j--;\\n        }\\n        \\n        //Swaping\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;          //45231\\n        \\n        \\n        Arrays.sort(arr, i+1, arr.length);           //45213\\n        \\n        \\n        //Result Concat in String\\n        String res = new String(arr);\\n        \\n\\n        // To long\\n        long sol = Long.parseLong(res);\\n        \\n        \\n        if(sol <= Integer.MAX_VALUE)\\n            return (int) sol;\\n\\n        return -1;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int nextGreaterElement(int n) {\\n        \\n        String str = Integer.toString(n);\\n        char [] arr = str.toCharArray();\\n        \\n        // To find the dip             //45132 - At pos: of 1 dip occurs\\n        int i = arr.length - 2;\\n        while(i >= 0 && arr[i] >= arr[i + 1]){\\n            i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1316789,
                "title": "easy-to-understand-python-solution-beats-95",
                "content": "The problem is similar to Next Permutation. Here we should also check if the answer is less than 2 power 31\\n\\n\\n\\n```\\n def nextGreaterElement(self, n: int) -> int:\\n        s = list(str(n))\\n        \\n        \\n        fst = -1\\n        for i in range(len(s)-2,-1,-1):\\n            if s[i]<s[i+1]:\\n                fst = i\\n                break\\n        if fst==-1 :\\n            return -1\\n        \\n        scd = -1\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]>s[fst]:\\n                scd = i\\n                break\\n        \\n        s[fst],s[scd]=s[scd],s[fst]\\n        \\n        s[fst+1:]=s[fst+1:][::-1]\\n        \\n        ans = int(\\'\\'.join(s))\\n        \\n        return ans if ans < 2147483648 else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n def nextGreaterElement(self, n: int) -> int:\\n        s = list(str(n))\\n        \\n        \\n        fst = -1\\n        for i in range(len(s)-2,-1,-1):\\n            if s[i]<s[i+1]:\\n                fst = i\\n                break\\n        if fst==-1 :\\n            return -1\\n        \\n        scd = -1\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]>s[fst]:\\n                scd = i\\n                break\\n        \\n        s[fst],s[scd]=s[scd],s[fst]\\n        \\n        s[fst+1:]=s[fst+1:][::-1]\\n        \\n        ans = int(\\'\\'.join(s))\\n        \\n        return ans if ans < 2147483648 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 983488,
                "title": "python-o-n-cool-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef nextGreaterElement(self, n: int) -> int:\\n\\t\\t\\tdigits = list(str(n))\\n\\t\\t\\tindex = len(digits) - 1\\n\\t\\t\\twhile index - 1 >= 0 and digits[index] <= digits[index - 1]:\\n\\t\\t\\t\\tindex -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\tif index == 0:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\n\\t\\t\\tgreater = index\\n\\t\\t\\t\\n\\t\\t\\twhile greater + 1 < len(digits) and digits[greater + 1] > digits [index - 1]:\\n\\t\\t\\t\\tgreater += 1\\n\\t\\t\\t\\n\\t\\t\\tdigits[greater], digits[index - 1] = digits[index - 1], digits[greater]\\n\\t\\t\\tdigits[index :] = digits[index :][::-1]\\n\\t\\t\\t\\n\\t\\t\\tdigits = int(\"\".join(digits))\\n\\t\\t\\t\\n\\t\\t\\treturn digits if digits < 1 << 31 else -1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef nextGreaterElement(self, n: int) -> int:\\n\\t\\t\\tdigits = list(str(n))\\n\\t\\t\\tindex = len(digits) - 1\\n\\t\\t\\twhile index - 1 >= 0 and digits[index] <= digits[index - 1]:\\n\\t\\t\\t\\tindex -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\tif index == 0:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\n\\t\\t\\tgreater = index\\n\\t\\t\\t\\n\\t\\t\\twhile greater + 1 < len(digits) and digits[greater + 1] > digits [index - 1]:\\n\\t\\t\\t\\tgreater += 1\\n\\t\\t\\t\\n\\t\\t\\tdigits[greater], digits[index - 1] = digits[index - 1], digits[greater]\\n\\t\\t\\tdigits[index :] = digits[index :][::-1]\\n\\t\\t\\t\\n\\t\\t\\tdigits = int(\"\".join(digits))\\n\\t\\t\\t\\n\\t\\t\\treturn digits if digits < 1 << 31 else -1",
                "codeTag": "Java"
            },
            {
                "id": 983321,
                "title": "next-greater-element-iii-u-will-get-understand-in-one-look",
                "content": "**Algorithm**\\n1. Traverse the given number from rightmost digit, till u get smaller than the previously traversed digit. For example, if the input number is `721632` ,  stop at 1 .Do not find such a digit, then output is -1\\n2. At the right side of digit 1 find digit just greater than 1. For  `721632` , the right side of 1 contains \\u201C632\\u201D. ans digit is 2\\n3. Swap them ` 722631 `\\n4.  sort all digits 631  ` 722136 `.\\n\\n```\\n public int nextGreaterElement(int n) {\\n        Integer[] dig=convertDig(n); //convert to number int int array\\n\\t\\t\\n        int i=0;\\n        for(i=dig.length-1;i>0;i--)\\n            if(dig[i-1]<dig[i]) // find the first element greater then prev traversed\\n                break;\\n        if(i==0) return -1;\\n\\t\\t\\n        Integer val=dig[i-1],idx=i; \\n        for (int j = i+1; j < dig.length; j++)  //now from right of that element find just next greater element \\n            if (dig[j] > val && dig[j] <= dig[idx])\\n                idx = j;\\n\\t\\t\\t\\t\\n        val=dig[idx];   //swap \\n        dig[idx]=dig[i-1];\\n        dig[i-1]=val;\\n\\t\\t\\n        Arrays.sort(dig,i,dig.length);  //sort\\n\\t\\t\\n        StringBuilder sb=new StringBuilder();\\n        for(int cc:dig) //convert to string to convert to int \\n            sb.append(cc);\\n\\t\\t\\t\\n        long ans = Long.parseLong(sb.toString());\\n\\t\\t\\treturn (ans <= Integer.MAX_VALUE) ? (int) ans : -1;// value shouldnot be greater then MAX\\n    }\\n    public Integer[] convertDig(int n){\\n        ArrayList<Integer> arr=new ArrayList<>(); \\n        while(n!=0){\\n            arr.add(n%10);  //extracting digits\\n            n/=10;       \\n        }\\n        Collections.reverse(arr);   //reverse \\n        return arr.toArray(new Integer[arr.size()]);    //ArrayList to int array\\n    }\\n```\\n**Any question let me know. If you like the post please upvote**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int nextGreaterElement(int n) {\\n        Integer[] dig=convertDig(n); //convert to number int int array\\n\\t\\t\\n        int i=0;\\n        for(i=dig.length-1;i>0;i--)\\n            if(dig[i-1]<dig[i]) // find the first element greater then prev traversed\\n                break;\\n        if(i==0) return -1;\\n\\t\\t\\n        Integer val=dig[i-1],idx=i; \\n        for (int j = i+1; j < dig.length; j++)  //now from right of that element find just next greater element \\n            if (dig[j] > val && dig[j] <= dig[idx])\\n                idx = j;\\n\\t\\t\\t\\t\\n        val=dig[idx];   //swap \\n        dig[idx]=dig[i-1];\\n        dig[i-1]=val;\\n\\t\\t\\n        Arrays.sort(dig,i,dig.length);  //sort\\n\\t\\t\\n        StringBuilder sb=new StringBuilder();\\n        for(int cc:dig) //convert to string to convert to int \\n            sb.append(cc);\\n\\t\\t\\t\\n        long ans = Long.parseLong(sb.toString());\\n\\t\\t\\treturn (ans <= Integer.MAX_VALUE) ? (int) ans : -1;// value shouldnot be greater then MAX\\n    }\\n    public Integer[] convertDig(int n){\\n        ArrayList<Integer> arr=new ArrayList<>(); \\n        while(n!=0){\\n            arr.add(n%10);  //extracting digits\\n            n/=10;       \\n        }\\n        Collections.reverse(arr);   //reverse \\n        return arr.toArray(new Integer[arr.size()]);    //ArrayList to int array\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 982989,
                "title": "next-greater-element-iii-c-4-lines-0ms-easy-solution-using-next-permutation-function",
                "content": "1. C++ next_permutation function will give the next greater permutation which we want in this case\\n2. Make sure the result is within the required range (<= MAX_INT)\\n3. If it is outside range return -1\\n**Please upvote if you like it**\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        if (next_permutation(num.begin(), num.end())) {\\n            long res = stol(num);\\n            return res > INT_MAX ? -1 : res;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        if (next_permutation(num.begin(), num.end())) {\\n            long res = stol(num);\\n            return res > INT_MAX ? -1 : res;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775606,
                "title": "c-next-permutation-logic-with-comments-and-time-space-complexity",
                "content": "class Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        \\n        //same as next permutation but we need to convert n to string\\n        string str = to_string(n);\\n        int index = str.size() - 2;\\n        \\n        while(index >= 0 && str[index] >= str[index + 1])\\n        {\\n            index--;\\n        }\\n        //no such greater element exists\\n        if(index == -1)\\n            return -1;\\n        \\n        //find val greater than str[index] and swap\\n        for(int i = str.size() - 1; i > index; i--)\\n        {\\n            if(str[i] > str[index])\\n            {\\n                char temp = str[index];\\n                str[index] = str[i];\\n                str[i] = temp;\\n                break;\\n            }\\n        }\\n        //reverse the part after index\\n        reverse(str.begin() + index + 1, str.end());\\n        \\n        //if not in 32bit range return -1 otherwise covert string to int \\n        return stoll(str) > INT_MAX ? -1 : stoi(str);\\n    }\\n};\\n\\n//Time complexity is O(n)\\n//Space complexity is O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        \\n        //same as next permutation but we need to convert n to string\\n        string str = to_string(n);\\n        int index = str.size() - 2;\\n        \\n        while(index >= 0 && str[index] >= str[index + 1])\\n        {\\n            index--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 101818,
                "title": "my-java-solution-with-explanation-in-comments-3ms",
                "content": "```\\n    public int nextGreaterElement(int n) {\\n\\n        char[] cArr = String.valueOf(n).toCharArray();\\n\\n        // i is the leftmost digit that should be exchanged\\n        int i = cArr.length - 1;\\n        while (i > 0 && cArr[i] <= cArr[i-1]) i--;\\n\\n        if (i <= 0) return -1;\\n\\n        // j is the digit that should be exchanged with digit at i\\n        int j = cArr.length - 1;\\n        while (j >= i && cArr[j] <= cArr[i-1]) j--;\\n\\n        // Exchange the digits at location i and j\\n        char tmp = cArr[j];\\n        cArr[j] = cArr[i-1];\\n        cArr[i-1] = tmp;\\n\\n        // Sort the digits from location i to the end\\n        Arrays.sort(cArr, i, cArr.length);\\n\\n        try {\\n           return Integer.parseInt(String.valueOf(cArr));\\n        } catch (Exception e) {\\n            // Intentionally left blank\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int nextGreaterElement(int n) {\\n\\n        char[] cArr = String.valueOf(n).toCharArray();\\n\\n        // i is the leftmost digit that should be exchanged\\n        int i = cArr.length - 1;\\n        while (i > 0 && cArr[i] <= cArr[i-1]) i--;\\n\\n        if (i <= 0) return -1;\\n\\n        // j is the digit that should be exchanged with digit at i\\n        int j = cArr.length - 1;\\n        while (j >= i && cArr[j] <= cArr[i-1]) j--;\\n\\n        // Exchange the digits at location i and j\\n        char tmp = cArr[j];\\n        cArr[j] = cArr[i-1];\\n        cArr[i-1] = tmp;\\n\\n        // Sort the digits from location i to the end\\n        Arrays.sort(cArr, i, cArr.length);\\n\\n        try {\\n           return Integer.parseInt(String.valueOf(cArr));\\n        } catch (Exception e) {\\n            // Intentionally left blank\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101841,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution(object):\\n    def nextGreaterElement(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        num = str(n)\\n        for i in range(len(num)-2, -1, -1):\\n            if num[i] < num[i+1]:\\n                t = list(num[i:])\\n                for j in range(len(t)-1, 0, -1):\\n                    if t[j]>t[0]:\\n                        first = t.pop(j)\\n                        rest = sorted(t)\\n                        res = int(num[:i] + first + ''.join(rest)) \\n                        return res if res <= (2**31-1) else -1 \\n                #print t\\n                #raise ValueError('Error: cannot find bigger value!')\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextGreaterElement(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        num = str(n)\\n        for i in range(len(num)-2, -1, -1):\\n            if num[i] < num[i+1]:\\n                t = list(num[i:])\\n                for j in range(len(t)-1, 0, -1):\\n                    if t[j]>t[0]:\\n                        first = t.pop(j)\\n                        rest = sorted(t)\\n                        res = int(num[:i] + first + ''.join(rest)) \\n                        return res if res <= (2**31-1) else -1 \\n                #print t\\n                #raise ValueError('Error: cannot find bigger value!')\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663289,
                "title": "easy-code-c-faang-code-basic-level-understanding-beats-100-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool nextPermutation(string& nums) {\\n        int i = nums.size()-1;\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        if (i == 0) return false;\\n        \\n        int j = nums.size()-1;\\n        while (j > 0 && nums[i-1]>=nums[j]) j--;\\n        swap(nums[j], nums[i-1]);\\n        reverse(nums.begin()+i, nums.end());\\n        return true;\\n    }\\n    \\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        bool res = nextPermutation(num);\\n        size_t ans = stoll(num);\\n        return (!res || ans > INT_MAX) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool nextPermutation(string& nums) {\\n        int i = nums.size()-1;\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        if (i == 0) return false;\\n        \\n        int j = nums.size()-1;\\n        while (j > 0 && nums[i-1]>=nums[j]) j--;\\n        swap(nums[j], nums[i-1]);\\n        reverse(nums.begin()+i, nums.end());\\n        return true;\\n    }\\n    \\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        bool res = nextPermutation(num);\\n        size_t ans = stoll(num);\\n        return (!res || ans > INT_MAX) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662708,
                "title": "next-greater-element-iii-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        string t = s;\\n        next_permutation(t.begin(),t.end());\\n        if(t<=s)\\n            return -1;\\n        auto res = stoll(t);\\n        return (res > INT_MAX || res <= n) ? -1 : res;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/e748d137-70df-4590-9d6d-ee9dfa93c743_1687283533.4526136.jpeg)\\n\\nplease upvote! if you like.\\nComment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        string t = s;\\n        next_permutation(t.begin(),t.end());\\n        if(t<=s)\\n            return -1;\\n        auto res = stoll(t);\\n        return (res > INT_MAX || res <= n) ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186172,
                "title": "python-implementation-of-c-s-next-permutation-explanation-comments",
                "content": "Approach is similar to using next_permutation in C++.\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def nextPermutation(self, num: List[str]):\\n        \"\"\"\\n        returns next permutation of num greater than num.\\n        Rearranges num in place and returns a True if permutation exists.\\n        Otherwise returns False\\n        \"\"\"\\n\\n        # 1. Find partition point: first non-increasing digit from last\\n        # i = (pos of first non-increasing digit) + 1\\n        i = len(num) - 1\\n        while i > 0 and num[i-1] >= num[i]:\\n            i -= 1\\n\\n        if i == 0:\\n            return False\\n\\n        # 2. Find digit to swap with in the sorted section\\n        # again j = (position of digit to be swapped) + 1\\n        j = i\\n        while j < len(num) and num[j] > num[i-1]:\\n            j += 1\\n\\n        # 3. Swap\\n        num[i-1], num[j-1] = num[j-1], num[i-1]\\n        \\n        # 4. Arrange digits after partition point in reverse sorted order to get min value.\\n        num[i:] = reversed(num[i:])\\n        return True\\n\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(str(n))\\n\\n        if self.nextPermutation(digits):\\n            num = int(\\'\\'.join(digits))\\n            \\n            # Check for 32 bit integer range\\n            if num <= 0x7FFFFFFF:\\n                return num\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def nextPermutation(self, num: List[str]):\\n        \"\"\"\\n        returns next permutation of num greater than num.\\n        Rearranges num in place and returns a True if permutation exists.\\n        Otherwise returns False\\n        \"\"\"\\n\\n        # 1. Find partition point: first non-increasing digit from last\\n        # i = (pos of first non-increasing digit) + 1\\n        i = len(num) - 1\\n        while i > 0 and num[i-1] >= num[i]:\\n            i -= 1\\n\\n        if i == 0:\\n            return False\\n\\n        # 2. Find digit to swap with in the sorted section\\n        # again j = (position of digit to be swapped) + 1\\n        j = i\\n        while j < len(num) and num[j] > num[i-1]:\\n            j += 1\\n\\n        # 3. Swap\\n        num[i-1], num[j-1] = num[j-1], num[i-1]\\n        \\n        # 4. Arrange digits after partition point in reverse sorted order to get min value.\\n        num[i:] = reversed(num[i:])\\n        return True\\n\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(str(n))\\n\\n        if self.nextPermutation(digits):\\n            num = int(\\'\\'.join(digits))\\n            \\n            # Check for 32 bit integer range\\n            if num <= 0x7FFFFFFF:\\n                return num\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842177,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-inbuilt-functions-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        next_permutation(s.begin(),s.end());\\n        string temp = s;\\n        prev_permutation(temp.begin(),temp.end());\\n        if(s<=temp) return -1;\\n        long long ans = stoll(s,nullptr,10);\\n        return (ans>INT_MAX || ans<INT_MIN)?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        next_permutation(s.begin(),s.end());\\n        string temp = s;\\n        prev_permutation(temp.begin(),temp.end());\\n        if(s<=temp) return -1;\\n        long long ans = stoll(s,nullptr,10);\\n        return (ans>INT_MAX || ans<INT_MIN)?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666055,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public int nextGreaterElement(int n) {\\n        \\n       String str=String.valueOf(n);\\n       char[] arr = str.toCharArray();\\n       \\n       int i = arr.length -2;\\n       while(i >= 0 &&  arr[i] >= arr[i+1]){\\n          i-- ;\\n       }\\n       if(i == -1){\\n        return -1 ;\\n       }\\n       // finding greater element than ith index isiliye peeche s ek baar fir traverse krenge \\n       int k = arr.length -1 ;\\n       while(arr[i] >= arr[k]){\\n        k-- ;\\n       }\\n      // we swap i and k place \\n       char temp = arr[i];\\n       arr[i] = arr[k];\\n        arr[k] = temp;\\n      \\n       String s = \"\";  // ek empty string bnayenge jisme starting k value daal denge till ith index \\n       for(int j =0 ; j <= i ; j++){\\n          s += arr[j]; \\n       }\\n       \\n      for(int j = arr.length -1 ; j > i; j--){\\n         s += arr[j];\\n      }\\n      \\n    \\n       try{\\n            int ans=Integer.parseInt(s);\\n            return ans;\\n        }catch(Exception e){\\n            return -1;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int nextGreaterElement(int n) {\\n        \\n       String str=String.valueOf(n);\\n       char[] arr = str.toCharArray();\\n       \\n       int i = arr.length -2;\\n       while(i >= 0 &&  arr[i] >= arr[i+1]){\\n          i-- ;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2610361,
                "title": "c-100-faster-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vector<int> v;\\n        long next=n;\\n        while(next){\\n            v.push_back(next%10);\\n            next/=10;\\n        }\\n        reverse(v.begin(), v.end());\\n        next_permutation(v.begin(), v.end());\\n        next=0;\\n        for(auto a:v) next=(next*10)+a;\\n        if(next<=n or next>INT_MAX) return -1;\\n        return next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vector<int> v;\\n        long next=n;\\n        while(next){\\n            v.push_back(next%10);\\n            next/=10;\\n        }\\n        reverse(v.begin(), v.end());\\n        next_permutation(v.begin(), v.end());\\n        next=0;\\n        for(auto a:v) next=(next*10)+a;\\n        if(next<=n or next>INT_MAX) return -1;\\n        return next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545788,
                "title": "0-ms-100-faster-using-string-c-soln",
                "content": "```\\nclass Solution {\\n   public:\\n    int nextGreaterElement(int num) {\\n        string s = to_string(num);\\n        int n = s.length();\\n\\n        // Using two pointers\\n        int right = n - 1, left = n - 2;\\n        int index;\\n\\n        // For finding the greater digit on the right\\n        while (left >= 0) {\\n            if (s[left] >= s[right]) {\\n                left--;\\n                right--;\\n            } else {\\n                index = right;\\n                while (right < n) {\\n                    if (s[right] > s[left]) index = right;\\n                    right++;\\n                }\\n                break;  // If found, break the while loop\\n            }\\n        }\\n\\n        // If not found, retrun -1\\n        if (left == -1) return -1;\\n\\n        // Swap the digits (in the example: 5 and 6)\\n        swap(s[left], s[index]);\\n\\n        // Sort the substring (in the example: \\'510\\')\\n        sort(s.begin() + left + 1, s.end());\\n\\n        // For checking if the answer is goint out of bounds\\n        long long ans = stoll(s);\\n\\n        if (ans <= pow(2, 31) - 1)\\n            return stoi(s);\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int nextGreaterElement(int num) {\\n        string s = to_string(num);\\n        int n = s.length();\\n\\n        // Using two pointers\\n        int right = n - 1, left = n - 2;\\n        int index;\\n\\n        // For finding the greater digit on the right\\n        while (left >= 0) {\\n            if (s[left] >= s[right]) {\\n                left--;\\n                right--;\\n            } else {\\n                index = right;\\n                while (right < n) {\\n                    if (s[right] > s[left]) index = right;\\n                    right++;\\n                }\\n                break;  // If found, break the while loop\\n            }\\n        }\\n\\n        // If not found, retrun -1\\n        if (left == -1) return -1;\\n\\n        // Swap the digits (in the example: 5 and 6)\\n        swap(s[left], s[index]);\\n\\n        // Sort the substring (in the example: \\'510\\')\\n        sort(s.begin() + left + 1, s.end());\\n\\n        // For checking if the answer is goint out of bounds\\n        long long ans = stoll(s);\\n\\n        if (ans <= pow(2, 31) - 1)\\n            return stoi(s);\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511422,
                "title": "c-clean-code-explained-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    /*\\n    To find the next greater integer with exactly the same digits, we can try to traverse the digits and swap some pair of the\\n    digits and then get our ans.\\n    \\n    To find the pair of digits we need to swap, we can traverse the digits from right to left, since the next greater element should \\n    be as small as possible and it is intuitive to traverse from least significant bit to the most significant bit to find the pair.\\n    \\n    We can determine how to find the pairs by reexamining the condition that must be satisfied:\\n    1.The integer should be greater after the digits swap, so if we are going to swap two digits i and j, and i > j, then we must have\\n    encountered i when we encounter j.\\n    2.The integer should be as small as possible, so we should find such pair that satisfies condition 1 as soon as possible.\\n    \\n    \\n    So j should be the digit that is smaller than the adjacent one on the right, and i is the smallest digit that is greater than j and\\n    on the right of j.\\n    \\n    Also after the swap, we need to make sure all digits that come after i are arranged so that they are the smallest, based on our algorithm \\n    searching for i and j, we can easily deduce that the digits come after i are in descending order, we just need to reverse thoes digits,\\n    and that would generate our answer.\\n    */\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        int len = s.size();\\n        for (int k = len - 2; k >= 0; k--) {\\n            if (s[k] < s[k + 1]) {\\n                int i = k + 1;\\n                while (i < len - 1 && s[i + 1] > s[k]) i++;\\n                swap(s[k], s[i]);\\n                reverse(s.begin() + k + 1, s.end());\\n                return (len == 10 && s > \"2147483647\") ? -1 : stoi(s);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    To find the next greater integer with exactly the same digits, we can try to traverse the digits and swap some pair of the\\n    digits and then get our ans.\\n    \\n    To find the pair of digits we need to swap, we can traverse the digits from right to left, since the next greater element should \\n    be as small as possible and it is intuitive to traverse from least significant bit to the most significant bit to find the pair.\\n    \\n    We can determine how to find the pairs by reexamining the condition that must be satisfied:\\n    1.The integer should be greater after the digits swap, so if we are going to swap two digits i and j, and i > j, then we must have\\n    encountered i when we encounter j.\\n    2.The integer should be as small as possible, so we should find such pair that satisfies condition 1 as soon as possible.\\n    \\n    \\n    So j should be the digit that is smaller than the adjacent one on the right, and i is the smallest digit that is greater than j and\\n    on the right of j.\\n    \\n    Also after the swap, we need to make sure all digits that come after i are arranged so that they are the smallest, based on our algorithm \\n    searching for i and j, we can easily deduce that the digits come after i are in descending order, we just need to reverse thoes digits,\\n    and that would generate our answer.\\n    */\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        int len = s.size();\\n        for (int k = len - 2; k >= 0; k--) {\\n            if (s[k] < s[k + 1]) {\\n                int i = k + 1;\\n                while (i < len - 1 && s[i + 1] > s[k]) i++;\\n                swap(s[k], s[i]);\\n                reverse(s.begin() + k + 1, s.end());\\n                return (len == 10 && s > \"2147483647\") ? -1 : stoi(s);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484547,
                "title": "1ms-simple-java-solution-with-explanation-2-pointer-approach",
                "content": "**The trick here is to find the first smallest dip traversing from right most index Example [ 7, 3, 6, 5, 1]\\nHere 3 is the first non increasing value or the dip**\\n\\n **Next step is to find the least value and its index to be swaped with the dip element \\'3\\' towards right. Hence we are looping from i+1 to length-1. So we are almost there. Swap the found value **\\n\\n**Now our array looks like : [ 7 5 6 3 1]. But wait? this doesnt look like the ans! Thats why we need to sort the remaining portion is ascending order. Congrats you got the final ans**\\nNote : If the array is sorted in decreasing [ 5 4 3 2 1] there is no ans.\\n\\n```\\nclass Solution {\\n   \\n    // 7 3 6 5 1\\n    public int nextGreaterElement(int n) {\\n        char[] number = (n + \"\").toCharArray();\\n        \\n       int i = number.length - 1,j = number.length-1 ;\\n        while(i>=0){\\n            if(i+1 < number.length && number[i]<number[i+1]){\\n                int min = Integer.MAX_VALUE,minIndex=0;\\n                \\n                for(int k=i+1;k<number.length;k++){\\n                    if(number[k]<min && number[k]>number[i] ){\\n                        min = number[k];\\n                        minIndex = k;\\n                    }\\n                }\\n                //Swap\\n                char temp = number[i];\\n                number[i] = (char)min;\\n                number[minIndex] = temp;\\n                break;\\n            }\\n            i--;\\n        }\\n        //if not found return\\n        if(i == -1)\\n            return -1;\\n        \\n        Arrays.sort(number,i+1,number.length);\\n        long ans = Long.parseLong(new String(number));\\n        return ans>Integer.MAX_VALUE?-1:(int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n   \\n    // 7 3 6 5 1\\n    public int nextGreaterElement(int n) {\\n        char[] number = (n + \"\").toCharArray();\\n        \\n       int i = number.length - 1,j = number.length-1 ;\\n        while(i>=0){\\n            if(i+1 < number.length && number[i]<number[i+1]){\\n                int min = Integer.MAX_VALUE,minIndex=0;\\n                \\n                for(int k=i+1;k<number.length;k++){\\n                    if(number[k]<min && number[k]>number[i] ){\\n                        min = number[k];\\n                        minIndex = k;\\n                    }\\n                }\\n                //Swap\\n                char temp = number[i];\\n                number[i] = (char)min;\\n                number[minIndex] = temp;\\n                break;\\n            }\\n            i--;\\n        }\\n        //if not found return\\n        if(i == -1)\\n            return -1;\\n        \\n        Arrays.sort(number,i+1,number.length);\\n        long ans = Long.parseLong(new String(number));\\n        return ans>Integer.MAX_VALUE?-1:(int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477468,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        List<Integer> nm=new ArrayList<>();\\n        String k=String.valueOf(n);\\n        for(int i=0;i<k.length();i++)\\n        {\\n            nm.add(k.charAt(i)-\\'0\\');\\n        }\\n        int i=nm.size()-1;\\n        while(i>0 && nm.get(i) <= nm.get(i-1))\\n        {\\n            i--;\\n        }\\n        if(i==0)\\n            return -1;\\n        i--;\\n        int j=nm.size()-1;\\n        while(nm.get(j) <= nm.get(i))\\n        {\\n            j--;\\n        }\\n        swap(nm,i,j);\\n        task(nm,i+1);\\n        k=\"\";\\n        for(int ii=0;ii<nm.size();ii++)\\n        {\\n            k+=nm.get(ii);\\n        }\\n        if(Long.parseLong(k)>Integer.MAX_VALUE)\\n            return -1;\\n        else\\n            return Integer.parseInt(k);\\n    }\\n    public void swap(List<Integer> nm, int i, int j)\\n    {\\n        int d=nm.get(i);\\n        nm.add(i,nm.get(j));\\n        nm.remove(i+1);\\n        nm.add(j,d);\\n        nm.remove(j+1);\\n    }\\n    public void task(List<Integer> nm, int i)\\n    {\\n        int k=nm.size()-1;\\n        for(int j=i;j<k;j++)\\n        {\\n            swap(nm,j,k);\\n            k--;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int nextGreaterElement(int n) {\\n        List<Integer> nm=new ArrayList<>();\\n        String k=String.valueOf(n);\\n        for(int i=0;i<k.length();i++)\\n        {\\n            nm.add(k.charAt(i)-\\'0\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2337662,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n \\n\\n       \\n       //1.finfd first dip \\n        \\n        //skipping last \\n      \\n       //Jab tak age wala bda ho piche wala se incresing sequence ho tb tk i--\\n        \\n        \\n           //limit crossed koi number nhi mila return -1\\n        //find just next greater \\n       //chlo abhi find krenge just next greater elemnt that previously find dip element \\n\\n        \\n   //swap krdo i j ko\\n   \\n      // i to j concatenate \\n       \\n            \\n        \\n        ///piche se concatenate kro cause reverse is needed \\n\\n      \\n    \\n     int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        if (next_permutation(num.begin(), num.end())) {\\n            long res = stol(num);\\n            return res > INT_MAX ? -1 : res;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n \\n\\n       \\n       //1.finfd first dip \\n        \\n        //skipping last \\n      \\n       //Jab tak age wala bda ho piche wala se incresing sequence ho tb tk i--\\n        \\n        \\n           //limit crossed koi number nhi mila return -1\\n        //find just next greater \\n       //chlo abhi find krenge just next greater elemnt that previously find dip element \\n\\n        \\n   //swap krdo i j ko\\n   \\n      // i to j concatenate \\n       \\n            \\n        \\n        ///piche se concatenate kro cause reverse is needed \\n\\n      \\n    \\n     int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        if (next_permutation(num.begin(), num.end())) {\\n            long res = stol(num);\\n            return res > INT_MAX ? -1 : res;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300301,
                "title": "c-easy-approach-0ms-6-1mb-100-understandable-have-a-nice-day",
                "content": "0ms, 6.1mb approach..\\n\\nStep 1: Actually, we are using the approach of Next Permutation problem. Where we need to print the next permutation of a string, but here in this case we are given a number so we have to convert this number into a string or vector for better implementation of the approach. So we are using vector in this case, finding a case when we find a number which is smaller than its next one like 3 in the example : 8938654, here 3 is not in increasing order when traversing from right to left. So keep its index aside, if we found no value like this, means the answer doesnt exist.\\nStep 2: we are finding a value which is just greater than the last smaller number we obtained before. we will always have this number to be swapped with its greater number on the rightmost.\\nStep 3: after swapping, all the digits after the swapped number must be reversed so that it comes in the least lexiograpical order, which means nearest greater to the provided number.\\n\\nAt last we are simply reversing the array and converting this digit vector to a number.\\nIf it helped you, pls upvote, if any suggestions or improvements, pls comment. \\n\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        //Creating a vector, which will store all our digits of the given number.\\n        vector<int> digits;\\n        long long finalAns=0;\\n        //Storing digits into the vector.\\n        while(n){\\n            digits.insert(digits.begin(),n%10);\\n            n=n/10;\\n        }\\n        \\n        //Step 1.\\n        int r=digits.size()-1;\\n        while(r>=1){\\n            if(digits[r-1]<digits[r])\\n                break;\\n            r--;\\n        }\\n        if(r==0)\\n          return -1;\\n       \\n        //Step 2.\\n      int  r1=digits.size()-1;\\n        while(r1>=0){\\n            if(digits[r1]>digits[r-1]){\\n                // cout<<\"We found greater value at index : \"<<r1<<\" value : \"<<digits[r1]<<endl;\\n                swap(digits[r1],digits[r-1]);\\n                break;\\n            }\\n            r1--;\\n        }\\n        //Step 3.\\n        reverse(digits.begin()+r,digits.end());\\n        reverse(digits.begin(),digits.end());\\n        \\n        //Converting number back to integer.\\n        for(int i=0;i<=digits.size()-1;i++){\\n            finalAns=finalAns+digits[i]*pow(10,i);\\n        }\\n        \\n        //Checking if it overflows, return -1, else return the desired number.\\n        cout<<finalAns<<endl;\\n        if(finalAns<=2147483647)\\n        return finalAns;\\n        else\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        //Creating a vector, which will store all our digits of the given number.\\n        vector<int> digits;\\n        long long finalAns=0;\\n        //Storing digits into the vector.\\n        while(n){\\n            digits.insert(digits.begin(),n%10);\\n            n=n/10;\\n        }\\n        \\n        //Step 1.\\n        int r=digits.size()-1;\\n        while(r>=1){\\n            if(digits[r-1]<digits[r])\\n                break;\\n            r--;\\n        }\\n        if(r==0)\\n          return -1;\\n       \\n        //Step 2.\\n      int  r1=digits.size()-1;\\n        while(r1>=0){\\n            if(digits[r1]>digits[r-1]){\\n                // cout<<\"We found greater value at index : \"<<r1<<\" value : \"<<digits[r1]<<endl;\\n                swap(digits[r1],digits[r-1]);\\n                break;\\n            }\\n            r1--;\\n        }\\n        //Step 3.\\n        reverse(digits.begin()+r,digits.end());\\n        reverse(digits.begin(),digits.end());\\n        \\n        //Converting number back to integer.\\n        for(int i=0;i<=digits.size()-1;i++){\\n            finalAns=finalAns+digits[i]*pow(10,i);\\n        }\\n        \\n        //Checking if it overflows, return -1, else return the desired number.\\n        cout<<finalAns<<endl;\\n        if(finalAns<=2147483647)\\n        return finalAns;\\n        else\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2217064,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    private void swap(char[] arr, int i, int j){\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    private void reverse(char[] arr, int i, int j){\\n        while(i<j)\\n            swap(arr, i++, j--);\\n    }\\n    public int nextGreaterElement(int c) {\\n        char[] arr = (\"\"+c).toCharArray();\\n        \\n        int n = arr.length;\\n        int i = n-2;\\n        while(i >= 0 && arr[i+1] <= arr[i])\\n            i--;\\n        \\n        if(i<0)\\n            return -1;\\n        \\n        int j = n-1;\\n        while(j>=0 && arr[j] <= arr[i]){\\n            j--;\\n        }\\n        \\n        swap(arr, i, j);\\n        \\n        reverse(arr, i+1, n-1);\\n        \\n        long result = Long.parseLong(new String(arr));\\n        \\n        return result > Integer.MAX_VALUE ? -1 : (int) result;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    private void swap(char[] arr, int i, int j){\\n        char temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    private void reverse(char[] arr, int i, int j){\\n        while(i<j)\\n            swap(arr, i++, j--);\\n    }\\n    public int nextGreaterElement(int c) {\\n        char[] arr = (\"\"+c).toCharArray();\\n        \\n        int n = arr.length;\\n        int i = n-2;\\n        while(i >= 0 && arr[i+1] <= arr[i])\\n            i--;\\n        \\n        if(i<0)\\n            return -1;\\n        \\n        int j = n-1;\\n        while(j>=0 && arr[j] <= arr[i]){\\n            j--;\\n        }\\n        \\n        swap(arr, i, j);\\n        \\n        reverse(arr, i+1, n-1);\\n        \\n        long result = Long.parseLong(new String(arr));\\n        \\n        return result > Integer.MAX_VALUE ? -1 : (int) result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075098,
                "title": "c-easy-0-ms-faster-than-100-without-using-builtin-function-for-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int number) {\\n        \\n        string str = to_string(number);\\n        int n = str.length();\\n        vector<int> v(n);\\n        \\n        for(int i = 0; i < n; i++)\\n            v[i] = str[i] - \\'0\\';\\n        \\n\\t\\t//procedure for find next permutation of vector v\\n\\t\\t\\n        int i,j;\\n\\t\\t\\n        // find position from where next greater element exist\\n        for(i = n-2; i >= 0; i--)\\n        {  \\n            if(v[i] < v[i+1])\\n                break;\\n        }\\n\\t\\t\\n        // no number exists which is greater than given number\\n        if(i<0)\\n            return -1;\\n        \\n\\t\\t// find next smallest greater element\\n        for(j = n-1; j > i; j--)\\n        {\\n            if(v[i] < v[j])\\n                break;\\n        }\\n        \\n        swap(v[i],v[j]);\\n        reverse(v.begin()+i+1,v.end());\\n        \\n\\t\\t//convert vector into number\\n\\t\\t\\n        long long num = 0;\\n        for(auto &val : v)\\n            num = num*10 + val;\\n        \\n        return (num > INT_MAX) ? -1 : num;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int number) {\\n        \\n        string str = to_string(number);\\n        int n = str.length();\\n        vector<int> v(n);\\n        \\n        for(int i = 0; i < n; i++)\\n            v[i] = str[i] - \\'0\\';\\n        \\n\\t\\t//procedure for find next permutation of vector v\\n\\t\\t\\n        int i,j;\\n\\t\\t\\n        // find position from where next greater element exist\\n        for(i = n-2; i >= 0; i--)\\n        {  \\n            if(v[i] < v[i+1])\\n                break;\\n        }\\n\\t\\t\\n        // no number exists which is greater than given number\\n        if(i<0)\\n            return -1;\\n        \\n\\t\\t// find next smallest greater element\\n        for(j = n-1; j > i; j--)\\n        {\\n            if(v[i] < v[j])\\n                break;\\n        }\\n        \\n        swap(v[i],v[j]);\\n        reverse(v.begin()+i+1,v.end());\\n        \\n\\t\\t//convert vector into number\\n\\t\\t\\n        long long num = 0;\\n        for(auto &val : v)\\n            num = num*10 + val;\\n        \\n        return (num > INT_MAX) ? -1 : num;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846762,
                "title": "python-two-pointers-the-most-standard-template-for-two-pointers",
                "content": "Please also check 31.\\xA0Next Permutation using the same method.\\n\\n**Brief interpretation:**\\n\\nExample = 23654.\\n\\n1, change to nums = [\"2\", \"3\", \"6\", \"5\", \"4\"].\\n\\n2, find the head of non-increasing subseq from the end, that is, 4 -> 5 -> 6.\\nThen we get the non-increasing subseq is 654, the head is 6.\\n\\n3, set pivot in the position of (head - 1), which is 3. Then following the order 4 -> 5 -> 6 \\nto find the first number which is > 3, that is, 4. Swap 3 and 4, which gives \\n24653 now.\\n\\n4, finally, we reverse the subseq from 653 to 356, then get the result 24356.\\n\\n**Simply whole picture:** 23654 -> 24653 -> 24356.\\n\\n```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        \\n        def reverse(i, j):\\n            \\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n            \\n                i += 1\\n                j -= 1\\n            \\n        \\n        MOD = 2 ** 31 - 1\\n        \\n        nums = list(str(n))\\n                    \\n        \\n        # find the head of the non-increasing subseq\\n        right = len(nums) - 1\\n        \\n        while 1 <= right < len(nums):\\n            \\n            if int(nums[right-1]) >= int(nums[right]):\\n                right -= 1\\n            \\n            else:\\n                break\\n        \\n        # now right is the head of the non-increasing seq\\n        # pivot is right-1\\n        # judge if right == 0, which means the whole seq is non-increasing\\n        # in this case, we return -1\\n        if right == 0:\\n            return -1\\n        \\n        pivot = right - 1\\n        \\n        # find the smallest element in the non-increasing subseq to replace with pivot from end\\n        for i in range(len(nums)-1, pivot, -1):\\n            \\n            if int(nums[i]) > int(nums[pivot]):\\n                nums[pivot], nums[i] = nums[i], nums[pivot]\\n                break\\n        \\n        # reverse the previous subseq after substituting\\n        reverse(right, len(nums)-1)\\n        \\n        res = int(\"\".join(nums))\\n        if res > MOD:\\n            return -1\\n        else:\\n            return res\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        \\n        def reverse(i, j):\\n            \\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n            \\n                i += 1\\n                j -= 1\\n            \\n        \\n        MOD = 2 ** 31 - 1\\n        \\n        nums = list(str(n))\\n                    \\n        \\n        # find the head of the non-increasing subseq\\n        right = len(nums) - 1\\n        \\n        while 1 <= right < len(nums):\\n            \\n            if int(nums[right-1]) >= int(nums[right]):\\n                right -= 1\\n            \\n            else:\\n                break\\n        \\n        # now right is the head of the non-increasing seq\\n        # pivot is right-1\\n        # judge if right == 0, which means the whole seq is non-increasing\\n        # in this case, we return -1\\n        if right == 0:\\n            return -1\\n        \\n        pivot = right - 1\\n        \\n        # find the smallest element in the non-increasing subseq to replace with pivot from end\\n        for i in range(len(nums)-1, pivot, -1):\\n            \\n            if int(nums[i]) > int(nums[pivot]):\\n                nums[pivot], nums[i] = nums[i], nums[pivot]\\n                break\\n        \\n        # reverse the previous subseq after substituting\\n        reverse(right, len(nums)-1)\\n        \\n        res = int(\"\".join(nums))\\n        if res > MOD:\\n            return -1\\n        else:\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729484,
                "title": "python-next-permutation-concept-easy-approach",
                "content": "\\t# Concept of Next Permutation Problem!\\n\\tclass Solution:\\n\\t\\tdef nextGreaterElement(self, n: int) -> int:\\n\\t\\t\\tdigts = list(str(n))\\n\\t\\t\\tn = len(digts)\\n\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\ti = n-2\\n\\t\\t\\twhile i >= 0 and digts[i] >= digts[i+1]:\\n\\t\\t\\t\\ti -= 1\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\tdigts[:] = digts[::-1]\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tj = n-1\\n\\t\\t\\t\\twhile digts[j] <= digts[i]:\\n\\t\\t\\t\\t\\tj -= 1\\n\\n\\t\\t\\t\\tdigts[i], digts[j] = digts[j], digts[i]\\n\\n\\t\\t\\t\\tdigts[i+1:] = sorted(digts[i+1:])\\n\\t\\t\\tans = int(\"\".join(digts))\\n\\t\\t\\treturn ans if ans < 1 << 31 else -1\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t# Concept of Next Permutation Problem!\\n\\tclass Solution:\\n\\t\\tdef nextGreaterElement(self, n: int) -> int:\\n\\t\\t\\tdigts = list(str(n))\\n\\t\\t\\tn = len(digts)\\n\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\ti = n-2\\n\\t\\t\\twhile i >= 0 and digts[i] >= digts[i+1]:\\n\\t\\t\\t\\ti -= 1\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\tdigts[:] = digts[::-1]\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tj = n-1\\n\\t\\t\\t\\twhile digts[j] <= digts[i]:\\n\\t\\t\\t\\t\\tj -= 1\\n\\n\\t\\t\\t\\tdigts[i], digts[j] = digts[j], digts[i]\\n\\n\\t\\t\\t\\tdigts[i+1:] = sorted(digts[i+1:])\\n\\t\\t\\tans = int(\"\".join(digts))\\n\\t\\t\\treturn ans if ans < 1 << 31 else -1\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1651610,
                "title": "simple-java-solution-beats-100-time-complexity",
                "content": "```\\nclass Solution {\\n    /*\\n\\t- What this problem wants is finding the next permutation of n\\n\\t- Steps to find the next permuation: \\n    find largest index k such that inp[k] < inp[k+1];\\n        if k == -1: return -1\\n        else:\\n            look for largest index l such that inp[l] > inp[k]\\n            swap the two index\\n            reverse from k+1 to n.length\\n    */\\n    public int nextGreaterElement(int n) {\\n        char[] inp = String.valueOf(n).toCharArray();\\n\\t\\t\\n\\t\\t//Find k\\n        int k = -1;\\n        for(int i = inp.length - 2; i >= 0; i--) {\\n            if(inp[i] < inp[i+1]) {\\n                k = i;\\n                break;\\n            }\\n        }\\n        if(k == -1) return -1;\\n\\t\\t\\n\\t\\t//Find l\\n        int largerIdx = inp.length - 1;\\n        for(int i = inp.length - 1; i >= 0; i--) {\\n            if(inp[i] > inp[k]) {\\n                largerIdx = i;\\n                break;\\n            }\\n        }\\n        swap(inp, k, largerIdx);\\n        reverse(inp, k+1, inp.length - 1);\\n\\t\\t\\n\\t\\t//Build result\\n        int ret = 0;\\n        for(int i = 0; i < inp.length; i++) {\\n            int digit = inp[i] - \\'0\\';\\n\\t\\t\\t//Handle the case if ret > Integer.MAX_VALUE - This idea is borrowed from problem  8. String to Integer (atoi)\\n            if(ret > Integer.MAX_VALUE/10 || (ret == Integer.MAX_VALUE/10 && digit > Integer.MAX_VALUE % 10)) {\\n                return -1;\\n            }\\n            ret = ret * 10 + (inp[i] - \\'0\\');\\n        }\\n        return ret;\\n    }\\n    public void swap(char[] inp, int i, int j) {\\n        char temp = inp[i];\\n        inp[i] = inp[j];\\n        inp[j] = temp;\\n    }\\n    public void reverse(char[] inp, int start, int end) {\\n        while(start < end) {\\n            char temp = inp[start];\\n            inp[start] = inp[end];\\n            inp[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n\\t- What this problem wants is finding the next permutation of n\\n\\t- Steps to find the next permuation: \\n    find largest index k such that inp[k] < inp[k+1];\\n        if k == -1: return -1\\n        else:\\n            look for largest index l such that inp[l] > inp[k]\\n            swap the two index\\n            reverse from k+1 to n.length\\n    */\\n    public int nextGreaterElement(int n) {\\n        char[] inp = String.valueOf(n).toCharArray();\\n\\t\\t\\n\\t\\t//Find k\\n        int k = -1;\\n        for(int i = inp.length - 2; i >= 0; i--) {\\n            if(inp[i] < inp[i+1]) {\\n                k = i;\\n                break;\\n            }\\n        }\\n        if(k == -1) return -1;\\n\\t\\t\\n\\t\\t//Find l\\n        int largerIdx = inp.length - 1;\\n        for(int i = inp.length - 1; i >= 0; i--) {\\n            if(inp[i] > inp[k]) {\\n                largerIdx = i;\\n                break;\\n            }\\n        }\\n        swap(inp, k, largerIdx);\\n        reverse(inp, k+1, inp.length - 1);\\n\\t\\t\\n\\t\\t//Build result\\n        int ret = 0;\\n        for(int i = 0; i < inp.length; i++) {\\n            int digit = inp[i] - \\'0\\';\\n\\t\\t\\t//Handle the case if ret > Integer.MAX_VALUE - This idea is borrowed from problem  8. String to Integer (atoi)\\n            if(ret > Integer.MAX_VALUE/10 || (ret == Integer.MAX_VALUE/10 && digit > Integer.MAX_VALUE % 10)) {\\n                return -1;\\n            }\\n            ret = ret * 10 + (inp[i] - \\'0\\');\\n        }\\n        return ret;\\n    }\\n    public void swap(char[] inp, int i, int j) {\\n        char temp = inp[i];\\n        inp[i] = inp[j];\\n        inp[j] = temp;\\n    }\\n    public void reverse(char[] inp, int start, int end) {\\n        while(start < end) {\\n            char temp = inp[start];\\n            inp[start] = inp[end];\\n            inp[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581000,
                "title": "java-clean-clear-code-four-steps",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = String.valueOf(n);\\n        char[] array = s.toCharArray();\\n        int len = s.length();\\n        int i = len - 2, j = len - 1;\\n        \\n        // find the first element before the decreasing sequence\\n        while (i >= 0 && s.charAt(i) >= s.charAt(i + 1)) {\\n            i--;\\n        }\\n        if (i < 0) {\\n            return -1;\\n        }\\n        \\n        // find the element greater than the above element\\n        while (j >= 0 && s.charAt(j) <= s.charAt(i)) {\\n            j--;\\n        }\\n        \\n        // swap\\n        if (i >= 0) {\\n            swap(array, i, j);\\n        }\\n        \\n        // reverse the last part\\n        int l = i + 1, r = len - 1;\\n        while (l < r) {\\n            swap(array, l++, r--);\\n        }\\n        \\n\\t\\t// edge case\\n        long val = Long.valueOf(String.valueOf(array));\\n        return val <= Integer.MAX_VALUE ? (int) val : -1;\\n    }\\n    \\n    private void swap(char[] array, int i, int j) {\\n        char tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = String.valueOf(n);\\n        char[] array = s.toCharArray();\\n        int len = s.length();\\n        int i = len - 2, j = len - 1;\\n        \\n        // find the first element before the decreasing sequence\\n        while (i >= 0 && s.charAt(i) >= s.charAt(i + 1)) {\\n            i--;\\n        }\\n        if (i < 0) {\\n            return -1;\\n        }\\n        \\n        // find the element greater than the above element\\n        while (j >= 0 && s.charAt(j) <= s.charAt(i)) {\\n            j--;\\n        }\\n        \\n        // swap\\n        if (i >= 0) {\\n            swap(array, i, j);\\n        }\\n        \\n        // reverse the last part\\n        int l = i + 1, r = len - 1;\\n        while (l < r) {\\n            swap(array, l++, r--);\\n        }\\n        \\n\\t\\t// edge case\\n        long val = Long.valueOf(String.valueOf(array));\\n        return val <= Integer.MAX_VALUE ? (int) val : -1;\\n    }\\n    \\n    private void swap(char[] array, int i, int j) {\\n        char tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566069,
                "title": "python3-solution-99-75-faster",
                "content": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(str(n))\\n        j = i = len(digits)-1\\n        while i and digits[i] <= digits[i-1]: i-=1\\n        if i == 0: return -1\\n        while digits[j] <= digits[i-1]: j-=1\\n        digits[j],digits[i-1] = digits[i-1],digits[j]\\n        digits[i:] = digits[i:][::-1]\\n        res = \\'\\'.join(digits)\\n        return res if int(res) < 2**31 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = list(str(n))\\n        j = i = len(digits)-1\\n        while i and digits[i] <= digits[i-1]: i-=1\\n        if i == 0: return -1\\n        while digits[j] <= digits[i-1]: j-=1\\n        digits[j],digits[i-1] = digits[i-1],digits[j]\\n        digits[i:] = digits[i:][::-1]\\n        res = \\'\\'.join(digits)\\n        return res if int(res) < 2**31 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554949,
                "title": "c-simple-solution",
                "content": "```\\ntypedef long long ll;\\ntypedef long double ld;\\n\\ntypedef pair<int, int> pii;\\n#define F first\\n#define S second\\n#define mp make_pair\\n\\n#define vt vector\\n#define eb emplace_back\\n#define pb push_back\\n#define sz(x) (int)(x).size()\\n#define all(x) (x).begin(), (x).end()\\n\\n#define rep(i, k, n) for(int i = k; i < n; i++)\\n#define repr(i, n, k) for(int i = n-1; i >= k; i--)\\n\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vt<int> digits;\\n        while(n > 0) {\\n            digits.eb(n % 10);\\n            n /= 10;\\n        }\\n        if(is_sorted(all(digits))) return -1;\\n        \\n        std::reverse(all(digits));\\n        std::next_permutation(all(digits));\\n        \\n        int ans = 0;\\n        rep(i, 0, sz(digits)) {\\n            if(ans>INT_MAX/10 || (ans==INT_MAX/10 && digits[i]>7)) return -1;\\n            ans = ans * 10 + digits[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\ntypedef long double ld;\\n\\ntypedef pair<int, int> pii;\\n#define F first\\n#define S second\\n#define mp make_pair\\n\\n#define vt vector\\n#define eb emplace_back\\n#define pb push_back\\n#define sz(x) (int)(x).size()\\n#define all(x) (x).begin(), (x).end()\\n\\n#define rep(i, k, n) for(int i = k; i < n; i++)\\n#define repr(i, n, k) for(int i = n-1; i >= k; i--)\\n\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vt<int> digits;\\n        while(n > 0) {\\n            digits.eb(n % 10);\\n            n /= 10;\\n        }\\n        if(is_sorted(all(digits))) return -1;\\n        \\n        std::reverse(all(digits));\\n        std::next_permutation(all(digits));\\n        \\n        int ans = 0;\\n        rep(i, 0, sz(digits)) {\\n            if(ans>INT_MAX/10 || (ans==INT_MAX/10 && digits[i]>7)) return -1;\\n            ans = ans * 10 + digits[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463866,
                "title": "js-solution-with-explanation",
                "content": "```\\nvar nextGreaterElement = function(n) {\\n    const MAX_NUM = 2147483647;\\n    const stack = [];\\n    let rem = 0, prev;\\n\\t\\n\\t// iterate the number from right to left and check if the next remainder value (when divided by 10)\\n\\t// is less than the previous remainder value. If yes, break from the loop.\\n\\t// meanwhile keep adding the remainders in an array, as they will be required to construct the next greater element\\n    while(n) {\\n        rem = n % 10;\\n        n = Math.floor(n / 10);\\n        if(prev && rem < prev) {\\n            break;\\n        }\\n        stack.push(rem);\\n        prev = rem;\\n    }\\n\\t// if value of n is 0 and current remainder is still greater than the previous remainder, that means there is no greater element\\n\\t// Ex. 54321, at the end n will be 0, and rem = 5, prev = 5\\n    if(!n && rem >= prev) {\\n        return -1;\\n    }\\n\\t// in the previous steps we found the position from where the number will change to construct the next greater element\\n\\t// loop through the array and find the next greater number to the current remainder value\\n\\t// then we add it to the number and replace the value in the array\\n\\t// take notice, the numbers in array are sorted from left to right in ascending order\\n    for(let idx = 0; idx < stack.length; ++idx) {\\n        if(stack[idx] > rem) {\\n            n = n * 10 + stack[idx];\\n            stack[idx] = rem;\\n            break;\\n        }\\n    }\\n\\t// now basically we need to iterate the array from left to right and keep on adding the numbers to construct the next greater element\\n    for(let idx = 0; idx < stack.length; ++idx) {\\n        n = n * 10 + stack[idx];\\n    }\\n\\t// this is a spacial case, if the next element is greater than the MAX NUM, return -1, else return the element\\n    return n > MAX_NUM ? -1 : n;\\n};\\n```\\nTime Complexity = O(m) (m is the length of the number, which will be constant)\\nSpace Complexity = O(m) (array - again constant)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextGreaterElement = function(n) {\\n    const MAX_NUM = 2147483647;\\n    const stack = [];\\n    let rem = 0, prev;\\n\\t\\n\\t// iterate the number from right to left and check if the next remainder value (when divided by 10)\\n\\t// is less than the previous remainder value. If yes, break from the loop.\\n\\t// meanwhile keep adding the remainders in an array, as they will be required to construct the next greater element\\n    while(n) {\\n        rem = n % 10;\\n        n = Math.floor(n / 10);\\n        if(prev && rem < prev) {\\n            break;\\n        }\\n        stack.push(rem);\\n        prev = rem;\\n    }\\n\\t// if value of n is 0 and current remainder is still greater than the previous remainder, that means there is no greater element\\n\\t// Ex. 54321, at the end n will be 0, and rem = 5, prev = 5\\n    if(!n && rem >= prev) {\\n        return -1;\\n    }\\n\\t// in the previous steps we found the position from where the number will change to construct the next greater element\\n\\t// loop through the array and find the next greater number to the current remainder value\\n\\t// then we add it to the number and replace the value in the array\\n\\t// take notice, the numbers in array are sorted from left to right in ascending order\\n    for(let idx = 0; idx < stack.length; ++idx) {\\n        if(stack[idx] > rem) {\\n            n = n * 10 + stack[idx];\\n            stack[idx] = rem;\\n            break;\\n        }\\n    }\\n\\t// now basically we need to iterate the array from left to right and keep on adding the numbers to construct the next greater element\\n    for(let idx = 0; idx < stack.length; ++idx) {\\n        n = n * 10 + stack[idx];\\n    }\\n\\t// this is a spacial case, if the next element is greater than the MAX NUM, return -1, else return the element\\n    return n > MAX_NUM ? -1 : n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461196,
                "title": "c-0ms-beats-100-submissions",
                "content": "```\\nclass Solution\\n{public: \\n//finds next permutation of the string passed\\n    string nextPermutation(string s)\\n    {   int flag = 0;\\n        int right = s.length() - 1;\\n        int pos, pos2;\\n        for (int index = right; index > 0; index--)\\n            if (s[index] > s[index - 1])\\n            {\\n                pos = index - 1;\\n                flag = 1;\\n                break;\\n            }\\n        if (flag == 1)\\n        {\\n            int index;\\n            for (index = right; index > pos; index--)\\n             if (s[index] > s[pos])\\n                {\\n                    pos2 = index;\\n                    break;\\n                }\\n            \\n\\t\\t\\tswap(s[pos], s[pos2]);\\n            reverse(s.begin() + pos + 1, s.end());\\n        }\\n        return s;\\n    }\\n\\n    int nextGreaterElement(int n)\\n    {\\n        if (n < 10 || n == INT_MAX)\\n            return -1;\\n\\t\\t\\t\\n        string s = to_string(n);\\n        s = nextPermutation(s);\\n        int ans = stoll(s);\\n        return (ans > INT_MAX || ans <= n) ? -1 : (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution\\n{public: \\n//finds next permutation of the string passed\\n    string nextPermutation(string s)\\n    {   int flag = 0;\\n        int right = s.length() - 1;\\n        int pos, pos2;\\n        for (int index = right; index > 0; index--)\\n            if (s[index] > s[index - 1])\\n            {\\n                pos = index - 1;\\n                flag = 1;\\n                break;\\n            }\\n        if (flag == 1)\\n        {\\n            int index;\\n            for (index = right; index > pos; index--)\\n             if (s[index] > s[pos])\\n                {\\n                    pos2 = index;\\n                    break;\\n                }\\n            \\n\\t\\t\\tswap(s[pos], s[pos2]);\\n            reverse(s.begin() + pos + 1, s.end());\\n        }\\n        return s;\\n    }\\n\\n    int nextGreaterElement(int n)\\n    {\\n        if (n < 10 || n == INT_MAX)\\n            return -1;\\n\\t\\t\\t\\n        string s = to_string(n);\\n        s = nextPermutation(s);\\n        int ans = stoll(s);\\n        return (ans > INT_MAX || ans <= n) ? -1 : (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433608,
                "title": "c-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        \\n        int i=0;\\n        for(i=s.size()-1; i>0; i--){\\n            if(s[i]>s[i-1]){\\n                break;\\n            }\\n        }\\n        if(i==0){ return -1;} //couldnt find bigger number\\n        \\n        //finding smaller number than above\\n        int x=s[i-1], small=i;\\n        for(int j=i+1; j<s.size(); j++){\\n            if((s[j]>x)&&(s[j]<=s[small])){\\n                small=j;\\n            }\\n        }\\n        //replacing\\n       swap(s[i-1],s[small]);\\n\\n        sort(s.begin() + i, s.end());\\n        cout<<s;\\n        \\n        long res = stol(s);\\n        \\n        if((res>INT_MAX) || (res<n)) return -1;\\n        else return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        \\n        int i=0;\\n        for(i=s.size()-1; i>0; i--){\\n            if(s[i]>s[i-1]){\\n                break;\\n            }\\n        }\\n        if(i==0){ return -1;} //couldnt find bigger number\\n        \\n        //finding smaller number than above\\n        int x=s[i-1], small=i;\\n        for(int j=i+1; j<s.size(); j++){\\n            if((s[j]>x)&&(s[j]<=s[small])){\\n                small=j;\\n            }\\n        }\\n        //replacing\\n       swap(s[i-1],s[small]);\\n\\n        sort(s.begin() + i, s.end());\\n        cout<<s;\\n        \\n        long res = stol(s);\\n        \\n        if((res>INT_MAX) || (res<n)) return -1;\\n        else return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1368761,
                "title": "c-stl-100-faster",
                "content": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Next Greater Element III.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n\\t//main function\\n    int nextGreaterElement(int n) {\\n\\t\\t//convert n to string\\n        string number = to_string(n);\\n\\t\\t\\n\\t\\t//check if next permutation exists\\n        if(next_permutation(number.begin(),number.end())){\\n\\t\\t\\t//if yes convert it to long number\\n            long long num = stoll(number);\\n\\t\\t\\t//return num if it\\'s in range\\n            if(num <= INT_MAX and num >= INT_MIN)\\n                return num;\\n        }\\n\\t\\t//return -1\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Next Greater Element III.\\n```\n```\\nclass Solution {\\npublic:\\n\\t//main function\\n    int nextGreaterElement(int n) {\\n\\t\\t//convert n to string\\n        string number = to_string(n);\\n\\t\\t\\n\\t\\t//check if next permutation exists\\n        if(next_permutation(number.begin(),number.end())){\\n\\t\\t\\t//if yes convert it to long number\\n            long long num = stoll(number);\\n\\t\\t\\t//return num if it\\'s in range\\n            if(num <= INT_MAX and num >= INT_MIN)\\n                return num;\\n        }\\n\\t\\t//return -1\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357548,
                "title": "python-100-faster-next-permutation",
                "content": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        if n>=2**31-1:\\n            return -1\\n        a=list(str(n))\\n        temp=None\\n        for i in range(len(a)-1,0,-1):\\n            if a[i]>a[i-1]:\\n                temp=a[i-1]\\n                idx=i-1\\n                break\\n        if not temp:\\n            return -1\\n        for i in range(len(a)-1,-1,-1):\\n            if a[i]>temp:\\n                a[i],a[idx]=a[idx],a[i]\\n                break\\n        res=int(\"\".join(a[:idx+1]+sorted(a[idx+1:])))\\n        if res>2**31-1:\\n            return -1\\n        else:\\n            return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        if n>=2**31-1:\\n            return -1\\n        a=list(str(n))\\n        temp=None\\n        for i in range(len(a)-1,0,-1):\\n            if a[i]>a[i-1]:\\n                temp=a[i-1]\\n                idx=i-1\\n                break\\n        if not temp:\\n            return -1\\n        for i in range(len(a)-1,-1,-1):\\n            if a[i]>temp:\\n                a[i],a[idx]=a[idx],a[i]\\n                break\\n        res=int(\"\".join(a[:idx+1]+sorted(a[idx+1:])))\\n        if res>2**31-1:\\n            return -1\\n        else:\\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214016,
                "title": "java-beats-100-0ms-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char nums[]=Integer.toString(n).toCharArray();\\n        \\n        int i=nums.length-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        if(i==-1) return -1;\\n        \\n        int j=nums.length-1;\\n        while(j>=0 && nums[j]<=nums[i]) j--;\\n        \\n        swap(nums,i,j);\\n        reverse(nums,i+1);\\n        \\n        try{\\n            return Integer.valueOf(new String(nums));\\n        }\\n        catch(Exception e){\\n            return -1;\\n        }\\n    }\\n    \\n    public void swap(char nums[],int i,int j){\\n        char temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    \\n    public void reverse(char nums[],int i){\\n        int j=nums.length-1;\\n        \\n        while(i<j){\\n            char temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char nums[]=Integer.toString(n).toCharArray();\\n        \\n        int i=nums.length-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        if(i==-1) return -1;\\n        \\n        int j=nums.length-1;\\n        while(j>=0 && nums[j]<=nums[i]) j--;\\n        \\n        swap(nums,i,j);\\n        reverse(nums,i+1);\\n        \\n        try{\\n            return Integer.valueOf(new String(nums));\\n        }\\n        catch(Exception e){\\n            return -1;\\n        }\\n    }\\n    \\n    public void swap(char nums[],int i,int j){\\n        char temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    \\n    public void reverse(char nums[],int i){\\n        int j=nums.length-1;\\n        \\n        while(i<j){\\n            char temp=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146065,
                "title": "python-100-less-memory-explained-with-example",
                "content": "*Runtime: 32 ms, faster than 48.05% of Python3 online submissions for Next Greater Element III.\\nMemory Usage: 13.9 MB, less than 100.00% of Python3 online submissions for Next Greater Element III.*\\n\\n**Explaination**\\n\\nSteps:\\n1. Create a list of numbers so that each digit can be accessed seperately.\\n2. Loop : \\nFind decreasing sequence in the given no. Store the index of the no to be swapped. \\nIf index = -1, that means the given no is in decreasing sequence and thus, there is no possible combination that could yield the result.\\n3. Loop : \\nFind the no in the right sequence that is just greater than the no to be swapped.\\n4. Swap the nos.\\n5. Since the right part of the sequence found in Step - 1 will always be a decreasing sequence, reverse the sequence to get the smallest possible no.\\n6. Store the result.\\n7. Check the result for 32-bit integer and return it.\\n\\n**For eg. : Let n = 14951**\\n\\nSteps:\\n1. List = [1,4,9,5,1]\\n2. Decreasing sequence : 951 and index = 3 (i.e. index of digit 4).\\n3. no just greater than 4 in the decreasing seq = 5\\n4. Swap : List = [1,5,9,4,1]\\n5. Reverse the decreasing sequence i.e. [9,4,1] to [1,4,9]\\n6. result = 15149\\n7. Since result is a 32-bit int, return the result.\\n\\n```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        \\n\\t\\t#Step - 1\\n        nums = list(map(int, str(n)))\\n        \\n\\t\\t#Step - 2\\n        indx = len(nums) - 2\\n        while indx >= 0 and nums[indx] >= nums[indx + 1]:\\n            indx -= 1\\n        if indx == -1:\\n\\t\\t\\treturn -1               #If no is a decreasing sequence (eg. 5421)\\n        \\n\\t\\t#Step - 3\\n        indx2 = len(nums) - 1\\n        while nums[indx2] <= nums[indx]:\\n            indx2 -= 1\\n        \\n\\t\\t#Step - 4\\n        nums[indx], nums[indx2] = nums[indx2], nums[indx]\\n\\t\\t\\n\\t\\t#Step - 5\\n        nums[indx+1 :] = reversed(nums[indx+1 :])\\n        \\n\\t\\t#Step - 6\\n        res = \\'\\'\\n        for n in nums:\\n            res += str(n)\\n        res = int(res)\\n        \\n\\t\\t#Step - 7\\n        return res if res <= 2 ** 31 - 1 else -1\\n```\\n\\nPlease feel free to drop in any queries!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        \\n\\t\\t#Step - 1\\n        nums = list(map(int, str(n)))\\n        \\n\\t\\t#Step - 2\\n        indx = len(nums) - 2\\n        while indx >= 0 and nums[indx] >= nums[indx + 1]:\\n            indx -= 1\\n        if indx == -1:\\n\\t\\t\\treturn -1               #If no is a decreasing sequence (eg. 5421)\\n        \\n\\t\\t#Step - 3\\n        indx2 = len(nums) - 1\\n        while nums[indx2] <= nums[indx]:\\n            indx2 -= 1\\n        \\n\\t\\t#Step - 4\\n        nums[indx], nums[indx2] = nums[indx2], nums[indx]\\n\\t\\t\\n\\t\\t#Step - 5\\n        nums[indx+1 :] = reversed(nums[indx+1 :])\\n        \\n\\t\\t#Step - 6\\n        res = \\'\\'\\n        for n in nums:\\n            res += str(n)\\n        res = int(res)\\n        \\n\\t\\t#Step - 7\\n        return res if res <= 2 ** 31 - 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108893,
                "title": "next-permutation",
                "content": "1. this question is same as of [next permutaion](https://leetcode.com/problems/next-permutation/) but the key thing here is if we swap and now convert that array into new number there is a chance that it can exceed the integer max value. so keeping that in mind let\\'s proceed with the solution.\\n\\n   we want next permutaion(or next greater value) so we will try to swap the least significant digit . so run a loop from arr.length-1 and find the first idx where a swap is possible.\\nBasically arr[idx]< arr[idx+1] . now we are sure that a next greater exist we have a idx that this idx value we have to swap with some greater value in right and we are sure that greater value exist in right. but we want to swap with the just greater value bcz we want just next for eg :  197441  here 1<9 so next greater exist but we are not going to swap 1 and 9 . we will  look for value that is just greater than 1  . which here is 4 \\nnow which 4 we have to choose. 1st 4 or last 4 ?  497141 or 497411 we will choose last 4 and will reverse the number from idx+1 to arr.length because we want next greater. 411479 is next greater.\\n\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        //1.convert integer into array\\n        String s=Integer.toString(n);\\n        int[] arr=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            arr[i]=(int)(s.charAt(i)-\\'0\\');\\n        }\\n        \\n        //2. first job is to find the value with smaller value than of its right\\n        int idx=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            if(arr[i]<arr[i+1]){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        \\n        //3.It means that next greater doesn\\'t exist eg:21\\n        if(idx==-1) return -1;\\n        \\n        int val=arr[idx];\\n        int j=idx+1;\\n        int jm=arr[idx+1]; //just max\\n        \\n        //4. find just greater value in right most (<=jm 444 will choose rightmost 4) \\n        for(int i=idx+1;i<arr.length;i++){\\n            if(arr[i]>val && arr[i]<=jm){\\n                jm=arr[i];\\n                j=i;\\n            }\\n        }\\n         \\n        \\n        swap(arr,idx,j);\\n        //5. number from idx+1 are in increasing order reverse them\\n        reverse(arr,idx+1,arr.length-1);\\n        \\n        int ans=0;\\n    \\n        long a=0;\\n        int mult=1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            a+=(long)arr[i]*mult;\\n            mult=mult*10;\\n        }\\n        \\n         //6.final check have we croosed the integer max value or not\\n          return a>Integer.MAX_VALUE?-1:(int)a;\\n    }\\n    \\n    public static void swap(int[] arr,int i,int j){\\n        int temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n    }\\n    \\n    public static void reverse(int[] arr,int l,int r){\\n        while(l<r){\\n            swap(arr,l,r);\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```\\n\\nTime : O(N) && SPACE :(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        //1.convert integer into array\\n        String s=Integer.toString(n);\\n        int[] arr=new int[s.length()];\\n        for(int i=0;i<s.length();i++){\\n            arr[i]=(int)(s.charAt(i)-\\'0\\');\\n        }\\n        \\n        //2. first job is to find the value with smaller value than of its right\\n        int idx=-1;\\n        for(int i=arr.length-2;i>=0;i--){\\n            if(arr[i]<arr[i+1]){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        \\n        //3.It means that next greater doesn\\'t exist eg:21\\n        if(idx==-1) return -1;\\n        \\n        int val=arr[idx];\\n        int j=idx+1;\\n        int jm=arr[idx+1]; //just max\\n        \\n        //4. find just greater value in right most (<=jm 444 will choose rightmost 4) \\n        for(int i=idx+1;i<arr.length;i++){\\n            if(arr[i]>val && arr[i]<=jm){\\n                jm=arr[i];\\n                j=i;\\n            }\\n        }\\n         \\n        \\n        swap(arr,idx,j);\\n        //5. number from idx+1 are in increasing order reverse them\\n        reverse(arr,idx+1,arr.length-1);\\n        \\n        int ans=0;\\n    \\n        long a=0;\\n        int mult=1;\\n        for(int i=arr.length-1;i>=0;i--){\\n            a+=(long)arr[i]*mult;\\n            mult=mult*10;\\n        }\\n        \\n         //6.final check have we croosed the integer max value or not\\n          return a>Integer.MAX_VALUE?-1:(int)a;\\n    }\\n    \\n    public static void swap(int[] arr,int i,int j){\\n        int temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n    }\\n    \\n    public static void reverse(int[] arr,int l,int r){\\n        while(l<r){\\n            swap(arr,l,r);\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028079,
                "title": "c-simple-solution-only-int-type-check-boundary-condition-when-interviewing",
                "content": "We check if num exceeds INT_MAX or not, not using any built-in function and LONG type\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        int len = num.size(), idx = len;\\n        for (int i = len-1; i >= 1; --i) {\\n            if (num[i] > num[i-1]) {\\n                idx = i-1;\\n                break;\\n            }\\n        }\\n        if (idx == len) {\\n            return -1;\\n        }\\n        int maxidx;\\n        for (int i = idx+1; i < len; ++i) {\\n            if (num[i] > num[idx]) {\\n                maxidx = i;\\n            }\\n        }\\n        swap(num[idx], num[maxidx]);\\n        reverse(num.begin()+idx+1, num.end());\\n        int sum = 0;\\n        for (int i = 0; i < num.size(); ++i) {\\n            if (sum > INT_MAX/10 || sum == INT_MAX/10 && num[i] > \\'7\\') {\\n                return -1;\\n            }\\n            sum = sum*10 + (num[i]-\\'0\\');\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string num = to_string(n);\\n        int len = num.size(), idx = len;\\n        for (int i = len-1; i >= 1; --i) {\\n            if (num[i] > num[i-1]) {\\n                idx = i-1;\\n                break;\\n            }\\n        }\\n        if (idx == len) {\\n            return -1;\\n        }\\n        int maxidx;\\n        for (int i = idx+1; i < len; ++i) {\\n            if (num[i] > num[idx]) {\\n                maxidx = i;\\n            }\\n        }\\n        swap(num[idx], num[maxidx]);\\n        reverse(num.begin()+idx+1, num.end());\\n        int sum = 0;\\n        for (int i = 0; i < num.size(); ++i) {\\n            if (sum > INT_MAX/10 || sum == INT_MAX/10 && num[i] > \\'7\\') {\\n                return -1;\\n            }\\n            sum = sum*10 + (num[i]-\\'0\\');\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001458,
                "title": "c-solution-with-100-faster",
                "content": "## 1. Solution using in-built function next_permutation\\n```\\nint nextGreaterElement(int n) {   \\n    string s=  to_string(n);\\n    string maxi = to_string(INT_MAX);\\n    if(next_permutation(s.begin(),s.end())){\\n        if(s.length() >= maxi.length() && maxi.compare(s) < 0)\\n            return -1;\\n        return stoi(s);\\n    }\\n    return -1;\\n}\\n```\\n\\n## 2. Solution using writing own function for next_permutation\\n```\\nstring nextPermutation(string s){\\n    int n = s.size();\\n    int i=n-2;\\n    for(;i>=0;i--){\\n        if(s[i]<s[i+1])\\n            break;\\n    }\\n\\n    if(i==-1)\\n        return \"-1\";\\n\\n    char maxi = \\'#\\';\\n    int pos = -1;\\n\\n    for(int j=n-1;j>i;j--){\\n        if(s[j]>s[i]){\\n            if(maxi == \\'#\\'){\\n                maxi = s[j];\\n                pos = j;\\n            }else if(maxi > s[j]){\\n                maxi = s[j];\\n                pos = j;\\n            }\\n        }\\n    }\\n\\n    swap(s[i],s[pos]);\\n    reverse(s.begin()+i+1,s.end());\\n\\n    return s;\\n}\\n\\nint nextGreaterElement(int n) {   \\n        string s=  to_string(n);\\n        string maxi = to_string(INT_MAX);\\n        s = nextPermutation(s);\\n        if(s!=\"-1\"){\\n            if(s.length() >= maxi.length() && maxi.compare(s) < 0)\\n                return -1;\\n            return stoi(s);\\n        }\\n        return -1;\\n    }\\n```\\n\\n### To understand Solution better you can refer to [https://www.youtube.com/watch?v=quAS1iydq7U]",
                "solutionTags": [],
                "code": "```\\nint nextGreaterElement(int n) {   \\n    string s=  to_string(n);\\n    string maxi = to_string(INT_MAX);\\n    if(next_permutation(s.begin(),s.end())){\\n        if(s.length() >= maxi.length() && maxi.compare(s) < 0)\\n            return -1;\\n        return stoi(s);\\n    }\\n    return -1;\\n}\\n```\n```\\nstring nextPermutation(string s){\\n    int n = s.size();\\n    int i=n-2;\\n    for(;i>=0;i--){\\n        if(s[i]<s[i+1])\\n            break;\\n    }\\n\\n    if(i==-1)\\n        return \"-1\";\\n\\n    char maxi = \\'#\\';\\n    int pos = -1;\\n\\n    for(int j=n-1;j>i;j--){\\n        if(s[j]>s[i]){\\n            if(maxi == \\'#\\'){\\n                maxi = s[j];\\n                pos = j;\\n            }else if(maxi > s[j]){\\n                maxi = s[j];\\n                pos = j;\\n            }\\n        }\\n    }\\n\\n    swap(s[i],s[pos]);\\n    reverse(s.begin()+i+1,s.end());\\n\\n    return s;\\n}\\n\\nint nextGreaterElement(int n) {   \\n        string s=  to_string(n);\\n        string maxi = to_string(INT_MAX);\\n        s = nextPermutation(s);\\n        if(s!=\"-1\"){\\n            if(s.length() >= maxi.length() && maxi.compare(s) < 0)\\n                return -1;\\n            return stoi(s);\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 983693,
                "title": "c-0ms-realisation-with-vector-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vector<int> tab;\\n        int m=n;//we need a copy for n\\n        //let\\'s convert this int to a list\\n        for(int i=0;n>0;i++){\\n            tab.insert(tab.begin(),n%10);\\n            n/=10;\\n        }\\n        //looking for the best permutation\\n        int aux,index=0;\\n        for(int i=tab.size()-1;i>0;i--){\\n            if(tab[i]>tab[i-1]){\\n                int ind=i;\\n                for(int j=i+1;j<tab.size();j++){\\n                    if(tab[j]>tab[i-1] && tab[j]<tab[ind] ){\\n                        ind=j;\\n                    }\\n                }\\n                //permutation\\n                aux=tab[ind];\\n                tab[ind]=tab[i-1];\\n                tab[i-1]=aux;\\n                index=i;//save the index from which we will sort the rest\\n                break;\\n            }\\n        }\\n        sort(tab.begin()+index,tab.end());// sorting the rest\\n        long long res=0;\\n        //preparing the result in int and testing if it fit in 32-bit integer\\n        for(int i=0;i<tab.size();i++){\\n            res*=10;\\n            res+=tab[i];\\n            if(res>INT_MAX)return -1;\\n        }\\n        //last test if the number doesn\\'t change \\n        if(res>m)return res;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        vector<int> tab;\\n        int m=n;//we need a copy for n\\n        //let\\'s convert this int to a list\\n        for(int i=0;n>0;i++){\\n            tab.insert(tab.begin(),n%10);\\n            n/=10;\\n        }\\n        //looking for the best permutation\\n        int aux,index=0;\\n        for(int i=tab.size()-1;i>0;i--){\\n            if(tab[i]>tab[i-1]){\\n                int ind=i;\\n                for(int j=i+1;j<tab.size();j++){\\n                    if(tab[j]>tab[i-1] && tab[j]<tab[ind] ){\\n                        ind=j;\\n                    }\\n                }\\n                //permutation\\n                aux=tab[ind];\\n                tab[ind]=tab[i-1];\\n                tab[i-1]=aux;\\n                index=i;//save the index from which we will sort the rest\\n                break;\\n            }\\n        }\\n        sort(tab.begin()+index,tab.end());// sorting the rest\\n        long long res=0;\\n        //preparing the result in int and testing if it fit in 32-bit integer\\n        for(int i=0;i<tab.size();i++){\\n            res*=10;\\n            res+=tab[i];\\n            if(res>INT_MAX)return -1;\\n        }\\n        //last test if the number doesn\\'t change \\n        if(res>m)return res;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983525,
                "title": "java-0ms-linear-time-and-space-next-permutation",
                "content": "This solution is based on [31. Next Permutation](https://leetcode.com/problems/next-permutation/).\\n\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        int len = digits.length;\\n        int inversionPoint = len - 2;\\n        while (inversionPoint >= 0 && digits[inversionPoint] >= digits[inversionPoint + 1]) {\\n            inversionPoint--;\\n        }\\n        if (inversionPoint < 0) {\\n            return -1;\\n        }\\n        \\n        for (int i = len - 1; i > inversionPoint; i--) {\\n            if (digits[i] > digits[inversionPoint]) {\\n                swap(digits, i, inversionPoint);\\n                break;\\n            }\\n        }\\n        \\n        reverse(digits, inversionPoint + 1, len);\\n        long result = Long.parseLong(new String(digits));\\n        \\n        return result > Integer.MAX_VALUE ? -1 : (int) result;  // check for int overflow.\\n    }\\n    \\n    private void swap(char[] digits, int i, int j) {\\n        char tmp = digits[i];\\n        digits[i] = digits[j];\\n        digits[j] = tmp;\\n    }\\n    \\n    private void reverse(char[] digits, int from, int to) {\\n        for (int i = from, j = to - 1; i < j; i++, j--) {\\n            swap(digits, i, j);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] digits = String.valueOf(n).toCharArray();\\n        int len = digits.length;\\n        int inversionPoint = len - 2;\\n        while (inversionPoint >= 0 && digits[inversionPoint] >= digits[inversionPoint + 1]) {\\n            inversionPoint--;\\n        }\\n        if (inversionPoint < 0) {\\n            return -1;\\n        }\\n        \\n        for (int i = len - 1; i > inversionPoint; i--) {\\n            if (digits[i] > digits[inversionPoint]) {\\n                swap(digits, i, inversionPoint);\\n                break;\\n            }\\n        }\\n        \\n        reverse(digits, inversionPoint + 1, len);\\n        long result = Long.parseLong(new String(digits));\\n        \\n        return result > Integer.MAX_VALUE ? -1 : (int) result;  // check for int overflow.\\n    }\\n    \\n    private void swap(char[] digits, int i, int j) {\\n        char tmp = digits[i];\\n        digits[i] = digits[j];\\n        digits[j] = tmp;\\n    }\\n    \\n    private void reverse(char[] digits, int from, int to) {\\n        for (int i = from, j = to - 1; i < j; i++, j--) {\\n            swap(digits, i, j);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 929893,
                "title": "c-solution-using-next-permutation-stol-stoi-beats-100-2-lines",
                "content": "Same idea as most posts, however, the code can be more succinct if we use the `next_permutation`.\\n1. We know that `next_permutation(str.begin(), str.end())` gives the next greater `str` (if not, `next_permutation` returns `false`). Therefore, we can convert the number to a string and take advantage of this `STL` function.\\n2. We also need to check whether the next greater string is actually a valid representation for a 32-bit integer by checking `stol(s) <= INT_MAX`.\\n```\\nclass Solution {\\npublic:\\n  int nextGreaterElement(int n) {\\n    string s = to_string(n);\\n    return next_permutation(s.begin(), s.end()) && stol(s) <= INT_MAX ? stoi(s) : -1;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int nextGreaterElement(int n) {\\n    string s = to_string(n);\\n    return next_permutation(s.begin(), s.end()) && stol(s) <= INT_MAX ? stoi(s) : -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884013,
                "title": "python3-swap-reverse-o-logn",
                "content": "Algo\\nThis is the same as [31. Next Permutation](https://leetcode.com/problems/next-permutation/discuss/462777/Python3-linear-scan-(94.52)).\\n\\nImplementation\\n```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        ss = list(str(n))\\n        for i in reversed(range(len(ss)-1)):\\n            if ss[i] < ss[i+1]: break \\n        else: return -1 # no break encounter \\n        \\n        for ii in reversed(range(i+1, len(ss))):\\n            if ss[i] < ss[ii]: break \\n        ss[i], ss[ii] = ss[ii], ss[i] # swap \\n\\n        i, j = i+1, len(ss)-1 # reverse \\n        while i < j: \\n            ss[i], ss[j] = ss[j], ss[i]\\n            i += 1\\n            j -= 1\\n        ans = int(\"\".join(ss))\\n        return ans if ans < 2**31 else -1 \\n```\\n\\nAnalysis\\nTime complexity `O(logN)`\\nSpace complexity `O(logN)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        ss = list(str(n))\\n        for i in reversed(range(len(ss)-1)):\\n            if ss[i] < ss[i+1]: break \\n        else: return -1 # no break encounter \\n        \\n        for ii in reversed(range(i+1, len(ss))):\\n            if ss[i] < ss[ii]: break \\n        ss[i], ss[ii] = ss[ii], ss[i] # swap \\n\\n        i, j = i+1, len(ss)-1 # reverse \\n        while i < j: \\n            ss[i], ss[j] = ss[j], ss[i]\\n            i += 1\\n            j -= 1\\n        ans = int(\"\".join(ss))\\n        return ans if ans < 2**31 else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 562020,
                "title": "javascript-solution-beats-92-73-with-explanation-same-as-next-permutation",
                "content": "```\\nvar nextGreaterElement = function(n) {\\n    \\n    // SAME AS NEXT PERMUTATION\\n    \\n    // First we convert the integer to integer array\\n    let arr = Array.from(String(n), Number)\\n    \\n    let l = arr.length-1, p=-1, pVal=0\\n    \\n    // Start from right most and find the first decreasing number\\n    // For example if number is 2,3,6,5,4,1. Start from 4 and compare prev and find first decreasing number\\n    for (let i = l-1;i >= 0;i--){\\n        if (arr[i] < arr[i+1]){\\n            pVal = arr[i]\\n            p = i\\n            break\\n        }\\n    }\\n    // Now we would have found 3. So 3 is stored in pVal and its index 1 is stored in p\\n    \\n    // If p and pVal is not found, then return -1.\\n    if (p === -1){\\n        return -1\\n    }\\n    \\n    // If p and pVal is found then again start from right most point in arr and find the first value greater than pVal which is 3 and we will find \\n    // 4. Now swap 4 and 3 and break out of loop\\n    \\n    for (let i=l;i>=0;i--){\\n        if (arr[i]>pVal){\\n            swap(arr,p,i)\\n            break\\n        }\\n    }\\n    \\n    //Now reverse the array from position p+1. That is from the numbers after we found 3 (which got swapped with 4) \\n    reverse(arr,p+1,l)\\n    let res = arr.join(\\'\\')\\n    \\n    //If res is greater then Max int or lesser than input val then return -1\\n    if (res > Math.pow(2,31) || res <= n) return -1\\n    \\n    return res\\n    \\n};\\n\\n\\nfunction reverse(arr,i,j){\\n\\n    while (i<j){\\n        swap(arr,i,j)\\n        i++\\n        j--\\n    }\\n}\\n\\nfunction swap(arr,i,j){\\n    let temp = arr[i]\\n    arr[i] = arr[j]\\n    arr[j] = temp\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar nextGreaterElement = function(n) {\\n    \\n    // SAME AS NEXT PERMUTATION\\n    \\n    // First we convert the integer to integer array\\n    let arr = Array.from(String(n), Number)\\n    \\n    let l = arr.length-1, p=-1, pVal=0\\n    \\n    // Start from right most and find the first decreasing number\\n    // For example if number is 2,3,6,5,4,1. Start from 4 and compare prev and find first decreasing number\\n    for (let i = l-1;i >= 0;i--){\\n        if (arr[i] < arr[i+1]){\\n            pVal = arr[i]\\n            p = i\\n            break\\n        }\\n    }\\n    // Now we would have found 3. So 3 is stored in pVal and its index 1 is stored in p\\n    \\n    // If p and pVal is not found, then return -1.\\n    if (p === -1){\\n        return -1\\n    }\\n    \\n    // If p and pVal is found then again start from right most point in arr and find the first value greater than pVal which is 3 and we will find \\n    // 4. Now swap 4 and 3 and break out of loop\\n    \\n    for (let i=l;i>=0;i--){\\n        if (arr[i]>pVal){\\n            swap(arr,p,i)\\n            break\\n        }\\n    }\\n    \\n    //Now reverse the array from position p+1. That is from the numbers after we found 3 (which got swapped with 4) \\n    reverse(arr,p+1,l)\\n    let res = arr.join(\\'\\')\\n    \\n    //If res is greater then Max int or lesser than input val then return -1\\n    if (res > Math.pow(2,31) || res <= n) return -1\\n    \\n    return res\\n    \\n};\\n\\n\\nfunction reverse(arr,i,j){\\n\\n    while (i<j){\\n        swap(arr,i,j)\\n        i++\\n        j--\\n    }\\n}\\n\\nfunction swap(arr,i,j){\\n    let temp = arr[i]\\n    arr[i] = arr[j]\\n    arr[j] = temp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405540,
                "title": "go-beat-100",
                "content": "```go\\nfunc nextGreaterElement(n int) int {\\n\\tdigits := make([]int, 0)\\n\\tfor n != 0 {\\n\\t\\tdigits = append(digits, n%10)\\n\\t\\tn /= 10\\n\\t}\\n\\tfor i := 1; i < len(digits); i++ {\\n\\t\\tif digits[i] >= digits[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tindex, diff := 0, 10\\n\\t\\tfor j := 0; j < i; j++ {\\n\\t\\t\\tcurDiff := digits[j] - digits[i]\\n\\t\\t\\tif curDiff > 0 && curDiff < diff {\\n\\t\\t\\t\\tdiff = curDiff\\n\\t\\t\\t\\tindex = j\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdigits[i], digits[index] = digits[index], digits[i]\\n\\t\\tsort.Sort(sort.Reverse(sort.IntSlice(digits[:i])))\\n\\n\\t\\tdest := 0\\n\\t\\tfor index, value := range digits {\\n\\t\\t\\tdest += value * int(math.Pow10(index))\\n\\t\\t}\\n        if dest <= math.MaxInt32 {\\n            return dest\\n        }\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc nextGreaterElement(n int) int {\\n\\tdigits := make([]int, 0)\\n\\tfor n != 0 {\\n\\t\\tdigits = append(digits, n%10)\\n\\t\\tn /= 10\\n\\t}\\n\\tfor i := 1; i < len(digits); i++ {\\n\\t\\tif digits[i] >= digits[i-1] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tindex, diff := 0, 10\\n\\t\\tfor j := 0; j < i; j++ {\\n\\t\\t\\tcurDiff := digits[j] - digits[i]\\n\\t\\t\\tif curDiff > 0 && curDiff < diff {\\n\\t\\t\\t\\tdiff = curDiff\\n\\t\\t\\t\\tindex = j\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdigits[i], digits[index] = digits[index], digits[i]\\n\\t\\tsort.Sort(sort.Reverse(sort.IntSlice(digits[:i])))\\n\\n\\t\\tdest := 0\\n\\t\\tfor index, value := range digits {\\n\\t\\t\\tdest += value * int(math.Pow10(index))\\n\\t\\t}\\n        if dest <= math.MaxInt32 {\\n            return dest\\n        }\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258183,
                "title": "java-simple-code-1ms-beats-100",
                "content": "````\\n\\tpublic int nextGreaterElement(int num) {\\n        char[] cs = Integer.toString(num).toCharArray();\\n        int n = cs.length, i = n-2;\\n        \\n        //- find the first digit from the right that is smaller than the previous digit\\n        while (i >= 0 && cs[i] >= cs[i+1]) i--;\\n        if (i < 0) return -1;\\n        \\n        //- find the smallest digit from the right that is greater than cs[i]\\n        int j = i+1;\\n        while (j < n && cs[j] > cs[i]) j++;\\n        \\n        swap(cs, i, j-1);\\n        reverse(cs, i+1, n-1);\\n        return toInt(cs);\\n    }\\n\\n    private void swap(char[] cs, int i, int j) {\\n        if (i==j) return;\\n        char tmp = cs[i];\\n        cs[i] = cs[j];\\n        cs[j] = tmp;\\n    }\\n\\n    private void reverse(char[] cs, int i, int j) {\\n        for (int k = 0; k < (j-i+1)/2; k++) {\\n            swap(cs, i+k, j-k);\\n        }\\n    }\\n\\n    private int toInt(char[] cs) {\\n        long res = 0;\\n        for (int i = 0; i < cs.length; i++) {\\n            res = res * 10 + cs[i]-\\'0\\';\\n            if (res > Integer.MAX_VALUE) return -1;\\n        }\\n        return (int)res;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int nextGreaterElement(int num) {\\n        char[] cs = Integer.toString(num).toCharArray();\\n        int n = cs.length, i = n-2;\\n        \\n        //- find the first digit from the right that is smaller than the previous digit\\n        while (i >= 0 && cs[i] >= cs[i+1]) i--;\\n        if (i < 0) return -1;\\n        \\n        //- find the smallest digit from the right that is greater than cs[i]\\n        int j = i+1;\\n        while (j < n && cs[j] > cs[i]) j++;\\n        \\n        swap(cs, i, j-1);\\n        reverse(cs, i+1, n-1);\\n        return toInt(cs);\\n    }\\n\\n    private void swap(char[] cs, int i, int j) {\\n        if (i==j) return;\\n        char tmp = cs[i];\\n        cs[i] = cs[j];\\n        cs[j] = tmp;\\n    }\\n\\n    private void reverse(char[] cs, int i, int j) {\\n        for (int k = 0; k < (j-i+1)/2; k++) {\\n            swap(cs, i+k, j-k);\\n        }\\n    }\\n\\n    private int toInt(char[] cs) {\\n        long res = 0;\\n        for (int i = 0; i < cs.length; i++) {\\n            res = res * 10 + cs[i]-\\'0\\';\\n            if (res > Integer.MAX_VALUE) return -1;\\n        }\\n        return (int)res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 101870,
                "title": "java-solution-with-in-line-explanation",
                "content": "The same problem with https://leetcode.com/problems/next-permutation\\n\\n```\\npublic class Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] chars = (n + \"\").toCharArray();\\n        \\n        int l = chars.length;\\n        if (l < 2) return -1;\\n        int[] nums = new int[l];\\n        \\n        for (int i = 0; i < l; i++) nums[i] = chars[i] - '0';\\n        \\n        //Start from its last element, traverse backward to find the first one with index i that satisfy\\n       // nums[i-1] < nums[i]. So, elements from nums[i] to nums[l-1] is reversely sorted.\\n        int index = l - 1;\\n        while (index > 0) {\\n            if (nums[index - 1] < nums[index]) break;\\n            index--;\\n        }\\n        \\n        //To find the next permutation, we have to swap some numbers at different positions, \\n        //to minimize the increased amount, we have to make the highest changed position\\n        // as high as possible. Notice that index larger than or equal to i is not possible as\\n        // nums[i,l-1] is reversely sorted. So, we want to increase the number at index i-1,\\n        // clearly, swap it with the smallest number between nums[i,l-1] that is larger than nums[i-1].\\n        // For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7.\\n        if (index == 0) {\\n            return -1;\\n        }\\n        else {\\n            //The last step is to make the remaining higher position part as small as possible,\\n           // we just have to reversely sort the nums[i,l-1]\\n            int val = nums[index - 1];\\n            int j = l - 1;\\n            while (j >= index){\\n                if (nums[j] > val) break;\\n                j--;\\n            }\\n            swap(nums, j, index - 1);\\n            \\n            reverse(nums, index, l - 1);\\n        }\\n        \\n        long result = 0;\\n        for (int i = 0; i < l; i++) {\\n            result = result * 10 + nums[i];\\n        }\\n        \\n        return result <= Integer.MAX_VALUE ? (int)result : -1;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end){   \\n        if (start > end) return;\\n        for (int i = start; i <= (end + start) / 2; i++)\\n            swap(nums, i, start + end - i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] chars = (n + \"\").toCharArray();\\n        \\n        int l = chars.length;\\n        if (l < 2) return -1;\\n        int[] nums = new int[l];\\n        \\n        for (int i = 0; i < l; i++) nums[i] = chars[i] - '0';\\n        \\n        //Start from its last element, traverse backward to find the first one with index i that satisfy\\n       // nums[i-1] < nums[i]. So, elements from nums[i] to nums[l-1] is reversely sorted.\\n        int index = l - 1;\\n        while (index > 0) {\\n            if (nums[index - 1] < nums[index]) break;\\n            index--;\\n        }\\n        \\n        //To find the next permutation, we have to swap some numbers at different positions, \\n        //to minimize the increased amount, we have to make the highest changed position\\n        // as high as possible. Notice that index larger than or equal to i is not possible as\\n        // nums[i,l-1] is reversely sorted. So, we want to increase the number at index i-1,\\n        // clearly, swap it with the smallest number between nums[i,l-1] that is larger than nums[i-1].\\n        // For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7.\\n        if (index == 0) {\\n            return -1;\\n        }\\n        else {\\n            //The last step is to make the remaining higher position part as small as possible,\\n           // we just have to reversely sort the nums[i,l-1]\\n            int val = nums[index - 1];\\n            int j = l - 1;\\n            while (j >= index){\\n                if (nums[j] > val) break;\\n                j--;\\n            }\\n            swap(nums, j, index - 1);\\n            \\n            reverse(nums, index, l - 1);\\n        }\\n        \\n        long result = 0;\\n        for (int i = 0; i < l; i++) {\\n            result = result * 10 + nums[i];\\n        }\\n        \\n        return result <= Integer.MAX_VALUE ? (int)result : -1;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int start, int end){   \\n        if (start > end) return;\\n        for (int i = start; i <= (end + start) / 2; i++)\\n            swap(nums, i, start + end - i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935179,
                "title": "100-beats",
                "content": "# Approach\\nUse blind brute Force\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nConstant Space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        int k = s.length();\\n        if(k == 1) return -1;\\n        if(s[k - 1] > s[k - 2]){\\n            swap(s[k - 1], s[k - 2]);\\n            // we use stoi to convert a string to int it may\\n            //happen that the string after swapping is greater than\\n            //INT_MAX value so we use stoll to convert string to           //long  long int\\n            long long c = stoll(s);\\n            if(c > INT_MAX) return -1;\\n            return (int)c;\\n\\n        }\\n        for(int i = k - 2; i >= 0; i--){\\n            //sort the remaining part\\n            sort(s.begin() + i + 1, s.end());\\n            //The below for loop is to check which is the first\\n            //element greater than s[i]\\n            for(int j = i + 1; j < k; j++){\\n                if(s[j] > s[i]){\\n                    swap(s[j], s[i]);\\n                    long long result = stoll(s);\\n                    if(result > INT_MAX) return -1;\\n                    return (int)result;\\n                    // a way to convert any other datatype to int\\n                    // result is int long but return type is int so\\n                    //so we need to do typecasting\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        int k = s.length();\\n        if(k == 1) return -1;\\n        if(s[k - 1] > s[k - 2]){\\n            swap(s[k - 1], s[k - 2]);\\n            // we use stoi to convert a string to int it may\\n            //happen that the string after swapping is greater than\\n            //INT_MAX value so we use stoll to convert string to           //long  long int\\n            long long c = stoll(s);\\n            if(c > INT_MAX) return -1;\\n            return (int)c;\\n\\n        }\\n        for(int i = k - 2; i >= 0; i--){\\n            //sort the remaining part\\n            sort(s.begin() + i + 1, s.end());\\n            //The below for loop is to check which is the first\\n            //element greater than s[i]\\n            for(int j = i + 1; j < k; j++){\\n                if(s[j] > s[i]){\\n                    swap(s[j], s[i]);\\n                    long long result = stoll(s);\\n                    if(result > INT_MAX) return -1;\\n                    return (int)result;\\n                    // a way to convert any other datatype to int\\n                    // result is int long but return type is int so\\n                    //so we need to do typecasting\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925335,
                "title": "detailed-approach",
                "content": "# Steps : \\n1. Convert the number n into a string.\\n1. Traverse the string from right to left, finding the first position i such that s[i] < s[i+1].\\n1. If such a position doesn\\'t exist, the number is the largest permutation of its digits and we should return -1.\\n1. Next, traverse the string from right to left again, finding the first position j such that s[j] > s[i].\\n1. Swap the characters at positions i and j.\\n1. Reverse the sub-string starting from position i+1 till the end. This ensures we get the smallest possible number.\\n1. Convert the string back to a number. If it\\'s larger than the 32-bit integer limit, return -1.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Not Easy Approach\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        \\n        int i, j;\\n        \\n        // Step 2: Traverse from right and find the first character that increases\\n        for (i = s.size() - 2; i >= 0; i--) {\\n            if (s[i] < s[i+1]) break;\\n        }\\n        \\n        // Step 3: If no such character is found, return -1\\n        if (i == -1) return -1;\\n\\n        // Step 4: Traverse from right and find the first character that is greater than s[i]\\n        for (j = s.size() - 1; j > i; j--) {\\n            if (s[j] > s[i]) break;\\n        }\\n\\n        // Step 5: Swap s[i] and s[j]\\n        swap(s[i], s[j]);\\n\\n        // Step 6: Reverse the substring from i+1\\n        reverse(s.begin() + i + 1, s.end());\\n        \\n        // Convert the string to a 64-bit integer first to check for overflow\\n        long long res = stoll(s);\\n\\n        // Step 7: Check for overflow\\n        if (res > INT_MAX) return -1;\\n\\n        // Step 8: Return the answer\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Not Easy Approach\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        \\n        int i, j;\\n        \\n        // Step 2: Traverse from right and find the first character that increases\\n        for (i = s.size() - 2; i >= 0; i--) {\\n            if (s[i] < s[i+1]) break;\\n        }\\n        \\n        // Step 3: If no such character is found, return -1\\n        if (i == -1) return -1;\\n\\n        // Step 4: Traverse from right and find the first character that is greater than s[i]\\n        for (j = s.size() - 1; j > i; j--) {\\n            if (s[j] > s[i]) break;\\n        }\\n\\n        // Step 5: Swap s[i] and s[j]\\n        swap(s[i], s[j]);\\n\\n        // Step 6: Reverse the substring from i+1\\n        reverse(s.begin() + i + 1, s.end());\\n        \\n        // Convert the string to a 64-bit integer first to check for overflow\\n        long long res = stoll(s);\\n\\n        // Step 7: Check for overflow\\n        if (res > INT_MAX) return -1;\\n\\n        // Step 8: Return the answer\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580067,
                "title": "java-best-solution-0-ms-beats-100-linear-time-comeplexity",
                "content": "# Intuition \\nWe have to find the next greater element of an given integer.\\nFor example, \\n1. 1245 -> 1254 \\n2. 12451 -> 12514\\n((Observe here, 4 has been swapped with 5 and rest elements has been in ascending order, like 12451 -> 12541 -> 12514))\\n3. 125431 -> 131245\\n(Observe here, 2 has been swapped with 3 and rest elements has been in ascending order, like 125431 -> 135421 -> 131245)\\n4. 5431 -> -1 (as there is no greater element can be formed using the numbers present)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Convert integer n to a character array\\n2. Find out the deflection Point (It is the point where element need to be swapped/ the number will be changed)\\n3. Check untill deflectionPoint > 0, if number at deflectionPoint is greater than number at deflectionPoint - 1, break the loop. We have to find the rightmost deflection point.\\n4. If deflection point is 0, then simply return -1, means we can\\'t find any greater element.\\n5. Find two index for swapping. So, the 1st swap index will be deflectionpoint - 1. Initialize 2nd swap index as array length - 1 and then check if the element at 1st swp index is less than element at 2nd swap index ot not.\\n6. Now, we have two swap index. Swap the elements\\n7. Now, we have to reverse the rest element.\\n8. After reverse the rest elements conver the char array to string and then string to integer. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] str = (n + \"\").toCharArray();\\n        int deflectionPoint = str.length - 1;\\n        //find out the deflection point\\n        while (deflectionPoint > 0) {\\n            if (str[deflectionPoint] > str[deflectionPoint - 1]) {\\n                break;\\n            }\\n            deflectionPoint--;\\n        }\\n\\n        //if deflection point is 0 return -1\\n        if (deflectionPoint == 0) return -1;\\n\\n        //find out 1st and 2nd swapping index\\n        int firstSwappingIndex = deflectionPoint - 1;\\n        int secondSwappingIndex = str.length - 1;\\n\\n        while (firstSwappingIndex <= secondSwappingIndex) {\\n            if (str[firstSwappingIndex] < str[secondSwappingIndex]) {\\n                break;\\n            }\\n            secondSwappingIndex--;\\n        }\\n\\n        //swap two elements\\n        char temp = str[firstSwappingIndex];\\n        str[firstSwappingIndex] = str[secondSwappingIndex];\\n        str[secondSwappingIndex] = temp;\\n\\n        //reverse the rest element at point of deflection\\n        reverseChar(str, deflectionPoint);\\n\\n        //convert the string to long and check Integer.MAX_VALUE and then return\\n        long result = Long.parseLong(new String(str));\\n        if (result > Integer.MAX_VALUE) return -1;\\n        return (int) result;\\n    }\\n\\n    static void reverseChar(char[] str, int i) {\\n        int start = i;\\n        int end = str.length - 1;\\n        while (start <= end) {\\n            char temp = str[start];\\n            str[start] = str[end];\\n            str[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n## (Please upvote if you like \\uD83D\\uDE0A)\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char[] str = (n + \"\").toCharArray();\\n        int deflectionPoint = str.length - 1;\\n        //find out the deflection point\\n        while (deflectionPoint > 0) {\\n            if (str[deflectionPoint] > str[deflectionPoint - 1]) {\\n                break;\\n            }\\n            deflectionPoint--;\\n        }\\n\\n        //if deflection point is 0 return -1\\n        if (deflectionPoint == 0) return -1;\\n\\n        //find out 1st and 2nd swapping index\\n        int firstSwappingIndex = deflectionPoint - 1;\\n        int secondSwappingIndex = str.length - 1;\\n\\n        while (firstSwappingIndex <= secondSwappingIndex) {\\n            if (str[firstSwappingIndex] < str[secondSwappingIndex]) {\\n                break;\\n            }\\n            secondSwappingIndex--;\\n        }\\n\\n        //swap two elements\\n        char temp = str[firstSwappingIndex];\\n        str[firstSwappingIndex] = str[secondSwappingIndex];\\n        str[secondSwappingIndex] = temp;\\n\\n        //reverse the rest element at point of deflection\\n        reverseChar(str, deflectionPoint);\\n\\n        //convert the string to long and check Integer.MAX_VALUE and then return\\n        long result = Long.parseLong(new String(str));\\n        if (result > Integer.MAX_VALUE) return -1;\\n        return (int) result;\\n    }\\n\\n    static void reverseChar(char[] str, int i) {\\n        int start = i;\\n        int end = str.length - 1;\\n        while (start <= end) {\\n            char temp = str[start];\\n            str[start] = str[end];\\n            str[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400051,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        auto digits = to_string(n);\\n        nextPermutation(begin(digits), end(digits));\\n        auto result = stoll(digits);\\n        return (result > numeric_limits<int>::max() || result <= n) ? -1 : result;\\n    }\\nprivate:\\n    template<typename BidiIt>\\n    bool nextPermutation(BidiIt begin, BidiIt end) {\\n        const auto rbegin = reverse_iterator<BidiIt>(end);\\n        const auto rend = reverse_iterator<BidiIt>(begin);\\n        \\n        auto pivot = next(rbegin);\\n        while (pivot != rend && *pivot >= *prev(pivot)) {\\n            ++pivot;\\n        }\\n        bool is_greater = true;\\n        if (pivot != rend) {\\n            auto change = find_if(rbegin, pivot, bind1st(less<int>(), *pivot));\\n            swap(*change, *pivot);\\n        } else {\\n            is_greater = false;\\n        }\\n        reverse(rbegin, pivot);\\n        return is_greater;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        s = list(str(n))\\n        flag = False\\n        for i in range(len(s)-1, 0, -1):\\n            if s[i-1] < s[i]:\\n                j = -1\\n                while s[i-1] >= s[j]:\\n                    j -= 1\\n                s[i-1], s[j] = s[j], s[i-1]\\n                s[i:] = sorted(s[i:])\\n                flag = True\\n                break\\n        m = int(\\'\\'.join(s))\\n        if m >= 2**31 or m < 1 or not flag: \\n            return -1\\n        else: \\n            return m\\n```\\n\\n```Java []\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = String.valueOf(n);\\n        int arr[] = new int[s.length()];\\n        int i=0;\\n        for(char c: s.toCharArray()) {\\n            arr[i++] = c - \\'0\\';\\n        }\\n        int index=-1;\\n        for(i=arr.length-1;i>0;i--) {\\n            if(arr[i-1]<arr[i]) {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        if(index == -1) return -1;\\n        for(i=arr.length-1;i>index;i--) {\\n            if (arr[i]>arr[index]) {\\n                int temp = arr[index];\\n                arr[index] = arr[i];\\n                arr[i] = temp;\\n                break;\\n            } \\n        }\\n        int l = index+1, r=arr.length-1;\\n        while(l<r) {\\n            int temp = arr[l];\\n            arr[l++] = arr[r];\\n            arr[r--] = temp;\\n        }\\n        int res = 0;\\n        for(i=0;i<arr.length;i++) {\\n            if ((Integer.MAX_VALUE-arr[i])/10<res) return -1;\\n            res = res*10 + arr[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        auto digits = to_string(n);\\n        nextPermutation(begin(digits), end(digits));\\n        auto result = stoll(digits);\\n        return (result > numeric_limits<int>::max() || result <= n) ? -1 : result;\\n    }\\nprivate:\\n    template<typename BidiIt>\\n    bool nextPermutation(BidiIt begin, BidiIt end) {\\n        const auto rbegin = reverse_iterator<BidiIt>(end);\\n        const auto rend = reverse_iterator<BidiIt>(begin);\\n        \\n        auto pivot = next(rbegin);\\n        while (pivot != rend && *pivot >= *prev(pivot)) {\\n            ++pivot;\\n        }\\n        bool is_greater = true;\\n        if (pivot != rend) {\\n            auto change = find_if(rbegin, pivot, bind1st(less<int>(), *pivot));\\n            swap(*change, *pivot);\\n        } else {\\n            is_greater = false;\\n        }\\n        reverse(rbegin, pivot);\\n        return is_greater;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        s = list(str(n))\\n        flag = False\\n        for i in range(len(s)-1, 0, -1):\\n            if s[i-1] < s[i]:\\n                j = -1\\n                while s[i-1] >= s[j]:\\n                    j -= 1\\n                s[i-1], s[j] = s[j], s[i-1]\\n                s[i:] = sorted(s[i:])\\n                flag = True\\n                break\\n        m = int(\\'\\'.join(s))\\n        if m >= 2**31 or m < 1 or not flag: \\n            return -1\\n        else: \\n            return m\\n```\n```Java []\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String s = String.valueOf(n);\\n        int arr[] = new int[s.length()];\\n        int i=0;\\n        for(char c: s.toCharArray()) {\\n            arr[i++] = c - \\'0\\';\\n        }\\n        int index=-1;\\n        for(i=arr.length-1;i>0;i--) {\\n            if(arr[i-1]<arr[i]) {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        if(index == -1) return -1;\\n        for(i=arr.length-1;i>index;i--) {\\n            if (arr[i]>arr[index]) {\\n                int temp = arr[index];\\n                arr[index] = arr[i];\\n                arr[i] = temp;\\n                break;\\n            } \\n        }\\n        int l = index+1, r=arr.length-1;\\n        while(l<r) {\\n            int temp = arr[l];\\n            arr[l++] = arr[r];\\n            arr[r--] = temp;\\n        }\\n        int res = 0;\\n        for(i=0;i<arr.length;i++) {\\n            if ((Integer.MAX_VALUE-arr[i])/10<res) return -1;\\n            res = res*10 + arr[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264233,
                "title": "simple-java-solution-beats-100-please-upvote-if-you-find-this-useful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        int[]nums=new int[counted(n)];\\n        for(int i=nums.length-1;i>=0;i--){\\n            nums[i]=n%10;\\n            n=n/10;\\n        }\\n        int p=0;\\n\\tfor (int i =nums.length-2;i>=0; i--) {\\n\\t\\tif(nums[i]<nums[i+1]) {\\n\\t\\t\\tp=i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint q=0;\\n\\tfor (int i = nums.length-1; i >p; i--) {\\n\\t\\tif(nums[i]>nums[p]) {\\n\\t\\tq=i;\\n\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(p==0&&q==0) {\\n\\t\\treverse(nums,0,nums.length-1);\\n\\t\\treturn -1;\\n\\t}\\n\\t//swapping\\n\\tint temp=nums[p];\\n\\tnums[p]=nums[q];\\n\\tnums[q]=temp;\\n\\treverse(nums,p+1,nums.length-1);\\n    long ans=0;\\n    for(int i=0;i<nums.length;i++){\\n        ans=ans*10+nums[i];\\n    }\\n    if(ans>Integer.MAX_VALUE){\\n        return -1;\\n    }else{\\n        return (int)ans;\\n    }\\n\\t\\n    }\\n    public static void reverse(int []nums,int i,int j){\\n    \\n    while(i<j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n        i++;\\n        j--;\\n    }\\n}\\npublic static int counted(int n){\\n    int count=0;\\n    while(n!=0){\\n        int rem=n%10;\\n        count++;\\n        n=n/10;\\n    }\\n    return count;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        int[]nums=new int[counted(n)];\\n        for(int i=nums.length-1;i>=0;i--){\\n            nums[i]=n%10;\\n            n=n/10;\\n        }\\n        int p=0;\\n\\tfor (int i =nums.length-2;i>=0; i--) {\\n\\t\\tif(nums[i]<nums[i+1]) {\\n\\t\\t\\tp=i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint q=0;\\n\\tfor (int i = nums.length-1; i >p; i--) {\\n\\t\\tif(nums[i]>nums[p]) {\\n\\t\\tq=i;\\n\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(p==0&&q==0) {\\n\\t\\treverse(nums,0,nums.length-1);\\n\\t\\treturn -1;\\n\\t}\\n\\t//swapping\\n\\tint temp=nums[p];\\n\\tnums[p]=nums[q];\\n\\tnums[q]=temp;\\n\\treverse(nums,p+1,nums.length-1);\\n    long ans=0;\\n    for(int i=0;i<nums.length;i++){\\n        ans=ans*10+nums[i];\\n    }\\n    if(ans>Integer.MAX_VALUE){\\n        return -1;\\n    }else{\\n        return (int)ans;\\n    }\\n\\t\\n    }\\n    public static void reverse(int []nums,int i,int j){\\n    \\n    while(i<j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n        i++;\\n        j--;\\n    }\\n}\\npublic static int counted(int n){\\n    int count=0;\\n    while(n!=0){\\n        int rem=n%10;\\n        count++;\\n        n=n/10;\\n    }\\n    return count;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125979,
                "title": "easy-c-beat100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int num) \\n    {\\n\\n      vector<int>v;\\n\\n      while(num>0)\\n      {\\n          v.push_back(num%10);\\n          num/=10;\\n      } \\n       \\n      reverse(v.begin(),v.end());\\n\\n      int n=v.size();\\n    \\n\\n      int i=n-1;\\n     while(i>=1 && v[i-1]>=v[i] )\\n     {\\n      i--;\\n     }\\n\\n      if(i==0)\\n         return -1;\\n       int m=INT_MAX;\\n       int index=0;\\n\\n       for(int j=i-1;j<n;j++)\\n       {\\n           if(v[j]>v[i-1] )\\n           {\\n                  index=j;\\n           }\\n       }\\n     \\n\\n      swap(v[i-1],v[index]);\\n\\n      sort(v.begin()+i,v.end());\\n\\n      long long ans=0;\\n\\n \\n      for(int ind=0;ind<n;ind++)\\n      {\\n        ans*=10;\\n        ans+=v[ind];\\n\\n      }\\n      cout<<ans;\\n//2147483647\\n\\n       if(ans>INT_MAX)\\n        return -1;\\n\\n\\n        return (int)ans;\\n\\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int num) \\n    {\\n\\n      vector<int>v;\\n\\n      while(num>0)\\n      {\\n          v.push_back(num%10);\\n          num/=10;\\n      } \\n       \\n      reverse(v.begin(),v.end());\\n\\n      int n=v.size();\\n    \\n\\n      int i=n-1;\\n     while(i>=1 && v[i-1]>=v[i] )\\n     {\\n      i--;\\n     }\\n\\n      if(i==0)\\n         return -1;\\n       int m=INT_MAX;\\n       int index=0;\\n\\n       for(int j=i-1;j<n;j++)\\n       {\\n           if(v[j]>v[i-1] )\\n           {\\n                  index=j;\\n           }\\n       }\\n     \\n\\n      swap(v[i-1],v[index]);\\n\\n      sort(v.begin()+i,v.end());\\n\\n      long long ans=0;\\n\\n \\n      for(int ind=0;ind<n;ind++)\\n      {\\n        ans*=10;\\n        ans+=v[ind];\\n\\n      }\\n      cout<<ans;\\n//2147483647\\n\\n       if(ans>INT_MAX)\\n        return -1;\\n\\n\\n        return (int)ans;\\n\\n\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3079805,
                "title": "next-greater-element-iii-c-easy-approach-stl-fastest-100",
                "content": "**IF YOU LIKE, PLEASE UPVOTE. IT HELPS.\\u2764\\uFE0F\\u2764\\uFE0F**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) \\n    {\\n        string s= to_string(n);\\n\\n        do\\n        { \\n            if(stol(s)>2147483647)  \\n            {\\n                return -1;\\n            }\\n            if(stol(s)>n)   \\n            {\\n                return stol(s);\\n            }  \\n        }\\n        while(next_permutation(s.begin(), s.end()));\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) \\n    {\\n        string s= to_string(n);\\n\\n        do\\n        { \\n            if(stol(s)>2147483647)  \\n            {\\n                return -1;\\n            }\\n            if(stol(s)>n)   \\n            {\\n                return stol(s);\\n            }  \\n        }\\n        while(next_permutation(s.begin(), s.end()));\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079636,
                "title": "easy-solution-two-nested-loop-beats-97-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nConverting number to array and starting from end of string to begining check if there is two digit next to each other which left is smaller than right. If there is we can switch them. if not then check index , index-2 and so one. when I find two digits which left is smaller than right, I will put the first smallest number which is not equal current left on left. and sort the rest on right.\\n\\n# Complexity\\n- Complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot 2023-01-20 at 9.17.10 PM.png](https://assets.leetcode.com/users/images/3e53680d-d725-4160-9eba-fed44306fa18_1674278270.0902636.png)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NextGreaterElement(int n) {\\n        var arr=($\"{n}\").ToArray();\\n        var l=arr.Length;\\n        for(int i=1;i<l;i++){\\n            for(int j=l-1;j-i>=0;j--){\\n                if(arr[j]>arr[j-i]){\\n                    var sub=arr.Skip(j-i).Take(l-j+i).OrderBy(p=>p).ToList();\\n                    var mid=sub.Where(p=>p>arr[j-i]).FirstOrDefault();\\n                    sub.Remove(mid);\\n                    arr=arr.Take(j-i).ToArray();\\n                    var str=$\"{new string(arr)}{mid}{new string(sub.ToArray())}\";\\n                    return Int32.TryParse(str,out int result)?result:-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NextGreaterElement(int n) {\\n        var arr=($\"{n}\").ToArray();\\n        var l=arr.Length;\\n        for(int i=1;i<l;i++){\\n            for(int j=l-1;j-i>=0;j--){\\n                if(arr[j]>arr[j-i]){\\n                    var sub=arr.Skip(j-i).Take(l-j+i).OrderBy(p=>p).ToList();\\n                    var mid=sub.Where(p=>p>arr[j-i]).FirstOrDefault();\\n                    sub.Remove(mid);\\n                    arr=arr.Take(j-i).ToArray();\\n                    var str=$\"{new string(arr)}{mid}{new string(sub.ToArray())}\";\\n                    return Int32.TryParse(str,out int result)?result:-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066437,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nextGreaterElement = function(n) {\\n    //\\uCD5C\\uC18C\\uAC12\\uC744 \\uB9AC\\uD134\\uD574\\uC57C \\uD55C\\uB2E4. \\n    //\\uC624\\uB978\\uCABD \\uB05D\\uC5D0\\uC11C \\uC2DC\\uC791\\uD574 digit \\uBCF4\\uB2E4 \\uD06C\\uAC70\\uB098 \\uAC19\\uC740 \\uAC12\\uACFC \\uAD50\\uD658. \\n    \\n    let N = String(n).split(\"\");\\n    let i=N.length-1, j = i-1;\\n    let min = Infinity;\\n    while(i>=0){\\n        console.log(min)\\n        if(j < 0) {i--;j= i-1;}\\n        let temp;\\n        if(N[i] >= N[j]){\\n            temp = N[i];\\n            N[i] = N[j];\\n            N[j] = temp;\\n            temp = N.splice(j+1).sort((a,b)=>a-b)\\n            N = N.concat(temp);\\n\\n            if((temp =Number(N.join(\"\"))) > n) {\\n                \\n                min = Math.min(min, temp);  \\n                N = String(n).split(\"\");\\n            }else{\\n                N = String(n).split(\"\")\\n                i--;\\n                j = i;\\n            }\\n        }\\n       j--\\n    }\\n    if(min > 2**31-1) return -1\\n    return min;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar nextGreaterElement = function(n) {\\n    //\\uCD5C\\uC18C\\uAC12\\uC744 \\uB9AC\\uD134\\uD574\\uC57C \\uD55C\\uB2E4. \\n    //\\uC624\\uB978\\uCABD \\uB05D\\uC5D0\\uC11C \\uC2DC\\uC791\\uD574 digit \\uBCF4\\uB2E4 \\uD06C\\uAC70\\uB098 \\uAC19\\uC740 \\uAC12\\uACFC \\uAD50\\uD658. \\n    \\n    let N = String(n).split(\"\");\\n    let i=N.length-1, j = i-1;\\n    let min = Infinity;\\n    while(i>=0){\\n        console.log(min)\\n        if(j < 0) {i--;j= i-1;}\\n        let temp;\\n        if(N[i] >= N[j]){\\n            temp = N[i];\\n            N[i] = N[j];\\n            N[j] = temp;\\n            temp = N.splice(j+1).sort((a,b)=>a-b)\\n            N = N.concat(temp);\\n\\n            if((temp =Number(N.join(\"\"))) > n) {\\n                \\n                min = Math.min(min, temp);  \\n                N = String(n).split(\"\");\\n            }else{\\n                N = String(n).split(\"\")\\n                i--;\\n                j = i;\\n            }\\n        }\\n       j--\\n    }\\n    if(min > 2**31-1) return -1\\n    return min;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2894586,
                "title": "go-golang-monotonic-stack-time-complexity-o-n-space-complexity-o-n",
                "content": "# Intuition\\n1. Iterate from right to left searching the first occurancy or the decreasing digit (named as \"rogue\" below)). Add everything to the stack on the way.\\n2. Permutate the \"rogue\" element with the first element in the stack, which is greater that the \"rogue\" element.\\n3. Append stack contents to the tail.\\n\\n# Approach\\nMonotonic stack\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc nextGreaterElement(n int) int {\\n    if n < 10 {\\n        return -1\\n    }\\n    stack := []int{}\\n    digits := intToDigitsSlice(n)\\n    for i := len(digits) - 1; i > 0; i-- {\\n        stack = append(stack, digits[i])\\n        if digits[i-1] < digits[i] {\\n            resSlice := make([]int, 0)\\n            resSlice = digits[0:i-1]\\n            rogue := digits[i-1]\\n\\n            for i,v := range(stack) {\\n                if rogue < v {\\n                    rogue, stack[i] = stack[i], rogue\\n                    break\\n                }\\n            }\\n            resSlice = append(resSlice, rogue)\\n\\n            for _,v := range(stack) {\\n                resSlice = append(resSlice, v)\\n            }\\n\\n            res := digitsSliceToint(resSlice)\\n            \\n            if res == n || res > int(math.Pow(2, 31)) - 1  {\\n                return -1\\n            }\\n            return res\\n        }\\n    }\\n    return -1\\n}\\n\\nfunc digitsSliceToint(digits []int) int {\\n    res := 0\\n    for i := len(digits); i > 0; i-- {\\n        res += digits[i-1] * int(math.Pow(10, float64(len(digits) - i)))\\n    }\\n    return res\\n}\\n\\nfunc intToDigitsSlice(n int) []int {\\n    digits := []int{}\\n    for n > 0 {\\n        digit := n % 10\\n        digits = append(digits, digit)\\n         n /= 10\\n    }\\n    reverse(digits)\\n    return digits\\n}\\n\\nfunc reverse(digits []int) {\\n    for i,j := 0, len(digits) - 1; i < j; i,j = i+1, j-1 {\\n        digits[i], digits[j] = digits[j], digits[i]\\n    } \\n}\\n\\n// time O(n)\\n// space O(n)\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc nextGreaterElement(n int) int {\\n    if n < 10 {\\n        return -1\\n    }\\n    stack := []int{}\\n    digits := intToDigitsSlice(n)\\n    for i := len(digits) - 1; i > 0; i-- {\\n        stack = append(stack, digits[i])\\n        if digits[i-1] < digits[i] {\\n            resSlice := make([]int, 0)\\n            resSlice = digits[0:i-1]\\n            rogue := digits[i-1]\\n\\n            for i,v := range(stack) {\\n                if rogue < v {\\n                    rogue, stack[i] = stack[i], rogue\\n                    break\\n                }\\n            }\\n            resSlice = append(resSlice, rogue)\\n\\n            for _,v := range(stack) {\\n                resSlice = append(resSlice, v)\\n            }\\n\\n            res := digitsSliceToint(resSlice)\\n            \\n            if res == n || res > int(math.Pow(2, 31)) - 1  {\\n                return -1\\n            }\\n            return res\\n        }\\n    }\\n    return -1\\n}\\n\\nfunc digitsSliceToint(digits []int) int {\\n    res := 0\\n    for i := len(digits); i > 0; i-- {\\n        res += digits[i-1] * int(math.Pow(10, float64(len(digits) - i)))\\n    }\\n    return res\\n}\\n\\nfunc intToDigitsSlice(n int) []int {\\n    digits := []int{}\\n    for n > 0 {\\n        digit := n % 10\\n        digits = append(digits, digit)\\n         n /= 10\\n    }\\n    reverse(digits)\\n    return digits\\n}\\n\\nfunc reverse(digits []int) {\\n    for i,j := 0, len(digits) - 1; i < j; i,j = i+1, j-1 {\\n        digits[i], digits[j] = digits[j], digits[i]\\n    } \\n}\\n\\n// time O(n)\\n// space O(n)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2662582,
                "title": "c-0ms-o-n-proper-explanation-using-stack-100-faster",
                "content": "# Intuition\\n```\\nCode block\\n```\\n```\\nCode block\\n```\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse stack to find first non increasing element in n by modulo operation. \\neg. 9876 we are not getting bigger no from this because there is no non increasing element from end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter getting first non increasing element find next greater element of it to replace non increasing element position and then sort the elements.\\neg. 6519832 -> 65(19832) -> 2(1983) -> 2(sorted) -> 2(1389) ->65(21389)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int g_max=INT_MIN;\\n        stack<int> st;\\n        int ct=0,f=0,flag=0;\\n        vector<int> v;\\n        int res = n;\\n        while(n>0)\\n        {\\n            int p = n%10;\\n            if(st.empty() == true || st.top() <=p)\\n            {\\n                st.push(p);\\n                ct++;\\n            }\\n            else\\n            {\\n                flag=1;\\n                v.push_back(p);\\n                while(st.empty() == false)\\n                {\\n                    if(f==1)\\n                    {\\n                        v.push_back(st.top());\\n                        st.pop();\\n                        continue;\\n                    }\\n                    if(g_max < 0)\\n                        g_max = st.top();\\n                    else\\n                    {\\n                        v.push_back(g_max);\\n                        g_max = st.top();\\n                    }\\n                    st.pop();\\n                    if(st.empty()==true)\\n                        break;\\n\\n                    if(st.top()<=p)\\n                        f=1;\\n\\n                }\\n                n=n/10;\\n                break;\\n            }\\n            n = n/10;\\n        }\\n        if(flag==0)\\n           return -1;\\n\\n        string s1,s2,str;\\n        s1 = to_string(n);\\n        long add=0;\\n        sort(v.begin(),v.end());\\n        add += g_max*pow(10,ct);\\n        ct--;\\n\\n        for(int i=0;i<v.size();++i)\\n        {\\n            add += v[i]*pow(10,ct);\\n            ct--;\\n        }\\n        s2 = to_string(add);\\n\\n        if(s1.empty()==false)\\n            str = s1+s2;\\n        else\\n            str = s2;\\n        \\n       \\n        long ans = stol(str);\\n        if(ans>INT_MAX)\\n            return -1;\\n        else if(add !=0 )\\n            return ans;\\n        else\\n            return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nCode block\\n```\n```\\nCode block\\n```\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int g_max=INT_MIN;\\n        stack<int> st;\\n        int ct=0,f=0,flag=0;\\n        vector<int> v;\\n        int res = n;\\n        while(n>0)\\n        {\\n            int p = n%10;\\n            if(st.empty() == true || st.top() <=p)\\n            {\\n                st.push(p);\\n                ct++;\\n            }\\n            else\\n            {\\n                flag=1;\\n                v.push_back(p);\\n                while(st.empty() == false)\\n                {\\n                    if(f==1)\\n                    {\\n                        v.push_back(st.top());\\n                        st.pop();\\n                        continue;\\n                    }\\n                    if(g_max < 0)\\n                        g_max = st.top();\\n                    else\\n                    {\\n                        v.push_back(g_max);\\n                        g_max = st.top();\\n                    }\\n                    st.pop();\\n                    if(st.empty()==true)\\n                        break;\\n\\n                    if(st.top()<=p)\\n                        f=1;\\n\\n                }\\n                n=n/10;\\n                break;\\n            }\\n            n = n/10;\\n        }\\n        if(flag==0)\\n           return -1;\\n\\n        string s1,s2,str;\\n        s1 = to_string(n);\\n        long add=0;\\n        sort(v.begin(),v.end());\\n        add += g_max*pow(10,ct);\\n        ct--;\\n\\n        for(int i=0;i<v.size();++i)\\n        {\\n            add += v[i]*pow(10,ct);\\n            ct--;\\n        }\\n        s2 = to_string(add);\\n\\n        if(s1.empty()==false)\\n            str = s1+s2;\\n        else\\n            str = s2;\\n        \\n       \\n        long ans = stol(str);\\n        if(ans>INT_MAX)\\n            return -1;\\n        else if(add !=0 )\\n            return ans;\\n        else\\n            return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662369,
                "title": "c-0ms-o-n-proper-explanation-using-stack-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse stack to find first non increasing element in n by modulo operation. \\neg. 9876 we are not getting bigger no from this because there is no non increasing element from end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter getting first non increasing element find next greater element of it to replace non increasing element position and then sort the elements.\\neg. 6519832 -> 65(19832) -> 2(1983) -> 2(sorted) -> 2(1389) ->65(21389)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int g_max=INT_MIN;\\n        stack<int> st;\\n        int ct=0,f=0,flag=0;\\n        vector<int> v;\\n        int res = n;\\n        while(n>0)\\n        {\\n            int p = n%10;\\n            if(st.empty() == true || st.top() <=p)\\n            {\\n                st.push(p);\\n                ct++;\\n            }\\n            else\\n            {\\n                flag=1;\\n                v.push_back(p);\\n                while(st.empty() == false)\\n                {\\n                    if(f==1)\\n                    {\\n                        v.push_back(st.top());\\n                        st.pop();\\n                        continue;\\n                    }\\n                    if(g_max < 0)\\n                    {    \\n                        g_max = st.top();\\n                    }\\n                    else\\n                    {\\n                        v.push_back(g_max);\\n                        g_max = st.top();\\n                    }\\n                    st.pop();\\n                    if(st.empty()==true)\\n                        break;\\n\\n                    if(st.top()<=p)\\n                        f=1;\\n\\n                }\\n                n=n/10;\\n                break;\\n            }\\n           n = n/10;\\n        }\\n        if(flag==0)\\n        return -1;\\n        string s1,s2,str;\\n        s1 = to_string(n);\\n        long add=0;\\n        sort(v.begin(),v.end());\\n        add += g_max*pow(10,ct);\\n        ct--;\\n\\n        for(int i=0;i<v.size();++i)\\n        {\\n            add += v[i]*pow(10,ct);\\n            ct--;\\n        }\\n        s2 = to_string(add);\\n        if(s1.empty()==false)\\n        str = s1+s2;\\n        else\\n        str = s2;\\n        \\n       \\n        long ans = stol(str);\\n        if(ans>INT_MAX)\\n        return -1;\\n        else if(add !=0 )\\n        return ans;\\n        else\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int g_max=INT_MIN;\\n        stack<int> st;\\n        int ct=0,f=0,flag=0;\\n        vector<int> v;\\n        int res = n;\\n        while(n>0)\\n        {\\n            int p = n%10;\\n            if(st.empty() == true || st.top() <=p)\\n            {\\n                st.push(p);\\n                ct++;\\n            }\\n            else\\n            {\\n                flag=1;\\n                v.push_back(p);\\n                while(st.empty() == false)\\n                {\\n                    if(f==1)\\n                    {\\n                        v.push_back(st.top());\\n                        st.pop();\\n                        continue;\\n                    }\\n                    if(g_max < 0)\\n                    {    \\n                        g_max = st.top();\\n                    }\\n                    else\\n                    {\\n                        v.push_back(g_max);\\n                        g_max = st.top();\\n                    }\\n                    st.pop();\\n                    if(st.empty()==true)\\n                        break;\\n\\n                    if(st.top()<=p)\\n                        f=1;\\n\\n                }\\n                n=n/10;\\n                break;\\n            }\\n           n = n/10;\\n        }\\n        if(flag==0)\\n        return -1;\\n        string s1,s2,str;\\n        s1 = to_string(n);\\n        long add=0;\\n        sort(v.begin(),v.end());\\n        add += g_max*pow(10,ct);\\n        ct--;\\n\\n        for(int i=0;i<v.size();++i)\\n        {\\n            add += v[i]*pow(10,ct);\\n            ct--;\\n        }\\n        s2 = to_string(add);\\n        if(s1.empty()==false)\\n        str = s1+s2;\\n        else\\n        str = s2;\\n        \\n       \\n        long ans = stol(str);\\n        if(ans>INT_MAX)\\n        return -1;\\n        else if(add !=0 )\\n        return ans;\\n        else\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518293,
                "title": "java-0ms-fastest-solution",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        int[] count = new int[10];\\n        while (n>0) {\\n            int lastDigit = n%10;\\n            n = n/10;\\n            count[lastDigit]++;\\n            int digit = largerDigitInRightSide(lastDigit, count);\\n            if (digit > 0) {\\n                return nextNumber(n, digit, count);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int largerDigitInRightSide(int lastDigit, int[] count) {\\n        for (int i=lastDigit+1; i<=9; i++) {\\n            if (count[i] > 0) return i;\\n        }\\n        return 0;\\n    }\\n    \\n    private int nextNumber(long n, int digit, int[] count) {\\n        n = n*10 + digit;\\n        count[digit]--;\\n        \\n        for (int i=0; i<=9; i++) {\\n            for (int c=0; c<count[i]; c++) {\\n                n = n*10 + i;\\n            }\\n        }\\n        if (n < (1L<<31)) return (int)n;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        int[] count = new int[10];\\n        while (n>0) {\\n            int lastDigit = n%10;\\n            n = n/10;\\n            count[lastDigit]++;\\n            int digit = largerDigitInRightSide(lastDigit, count);\\n            if (digit > 0) {\\n                return nextNumber(n, digit, count);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int largerDigitInRightSide(int lastDigit, int[] count) {\\n        for (int i=lastDigit+1; i<=9; i++) {\\n            if (count[i] > 0) return i;\\n        }\\n        return 0;\\n    }\\n    \\n    private int nextNumber(long n, int digit, int[] count) {\\n        n = n*10 + digit;\\n        count[digit]--;\\n        \\n        for (int i=0; i<=9; i++) {\\n            for (int c=0; c<count[i]; c++) {\\n                n = n*10 + i;\\n            }\\n        }\\n        if (n < (1L<<31)) return (int)n;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485291,
                "title": "simplest-java-solution-east-to-understand",
                "content": "\\n    \\n    public int nextGreaterElement(int n) {\\n\\t\\n\\tString temp = Integer.toString(n);\\n    int[] arr = new int[temp.length()];\\n    \\n    for (int i = 0; i < temp.length(); i++)\\n        arr[i] = temp.charAt(i) - \\'0\\';\\n        \\n    int len = temp.length();\\n    int baseIndex = -1;\\n    \\n    for(int i=len-2;i>=0;i--){\\n        if(arr[i]<arr[i+1]){\\n            baseIndex = i;\\n            break;\\n        }\\n    }\\n    if(baseIndex == -1)\\n        return -1;\\n\\n    int NGE = -1;\\n    int NGI = -1;\\n    \\n    for(int i=baseIndex+1;i<len;i++){\\n        if(arr[i]>arr[baseIndex]){\\n            if(NGE==-1 || NGE>arr[i]){\\n                NGE = arr[i];\\n                NGI = i;\\n            }\\n        }\\n    }\\n    \\n    int temp1 = arr[NGI];\\n    arr[NGI] = arr[baseIndex];\\n    arr[baseIndex] = temp1;\\n    Arrays.sort(arr,baseIndex+1,len);\\n    \\n    long res=0;\\n    for(int i=0;i<len;i++) {\\n         res=res*10+arr[i];\\n    }\\n    \\n    if(res>(long)2147483647)\\n        return -1;\\n    return (int)res;\\n}",
                "solutionTags": [
                    "Stack",
                    "Queue"
                ],
                "code": "\\n    \\n    public int nextGreaterElement(int n) {\\n\\t\\n\\tString temp = Integer.toString(n);\\n    int[] arr = new int[temp.length()];\\n    \\n    for (int i = 0; i < temp.length(); i++)\\n        arr[i] = temp.charAt(i) - \\'0\\';\\n        \\n    int len = temp.length();\\n    int baseIndex = -1;\\n    \\n    for(int i=len-2;i>=0;i--){\\n        if(arr[i]<arr[i+1]){\\n            baseIndex = i;\\n            break;\\n        }\\n    }\\n    if(baseIndex == -1)\\n        return -1;\\n\\n    int NGE = -1;\\n    int NGI = -1;\\n    \\n    for(int i=baseIndex+1;i<len;i++){\\n        if(arr[i]>arr[baseIndex]){\\n            if(NGE==-1 || NGE>arr[i]){\\n                NGE = arr[i];\\n                NGI = i;\\n            }\\n        }\\n    }\\n    \\n    int temp1 = arr[NGI];\\n    arr[NGI] = arr[baseIndex];\\n    arr[baseIndex] = temp1;\\n    Arrays.sort(arr,baseIndex+1,len);\\n    \\n    long res=0;\\n    for(int i=0;i<len;i++) {\\n         res=res*10+arr[i];\\n    }\\n    \\n    if(res>(long)2147483647)\\n        return -1;\\n    return (int)res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2439669,
                "title": "simple-python-solution-for-next-greater-element-with-code-as-documentation",
                "content": "example: \\nn = 1387982\\n\\nexplanation of logic:\\nwe initially figure out the first decreasing number from the last number.\\n\\tn = 1  3  8  7  9  8  2    \\nwe see that 8>2 so we continue to the hiher placement numbers, 9>8 we still conitinue, 7<9 so the value 7 needs to be replaced with the next higher number from its rightside i.e lower placement value which is 8. now the value becomes n = 1388972 which is not the just next highest value, inorder to get it we sort the  value from the next index of the decent value i.e here it is 9 , so we need to sort 972 which becomes 279. therefore the result becomes 1388279.\\n\\n```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        value = list(str(n))\\n        length = len(value)\\n        i = length - 1                        #starts from the last cell of the list\\n        maxvalue_of_32_bit_integer = math.pow(2,31)-1\\n        \\n        while i > 0:\\n            if value[i-1] < value[i]:\\n                minval = value[i]                #initializing minimum number of value[i-1] as value[i] \\n                minval_index = i                 # assigning corresponding index for minimumvalue\\n                for x in range(i+1,length):      #to figure out the just next greater number than value[i-1]\\n                    if value[i-1] < value[x] < minval:\\n                        minval_index = x\\n                        minval = value[x]\\n                        \\n                \"\"\" after the above for loop u will have the next greater number than value[i-1] \"\"\"\\n                \"\"\" after which swap both minimum value and value at i-1 \"\"\"\\n                value[i-1],value[minval_index] = value[minval_index],value[i-1]\\n                \\n                \"\"\" the sorting is done as to minimum number is for any m digit number would be asscending order sort\\n                    so we sort numbers from value from index i to end of the list so as to get the next bigger number\"\"\"\\n                value[i:] = sorted(value[i:])\\n                result = int(\"\".join(value))\\n                return  result if maxvalue_of_32_bit_integer >= result else -1 # return only result which is less than max value of 32 bit integer\\n            i -= 1\\n        return -1\\n                        \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        value = list(str(n))\\n        length = len(value)\\n        i = length - 1                        #starts from the last cell of the list\\n        maxvalue_of_32_bit_integer = math.pow(2,31)-1\\n        \\n        while i > 0:\\n            if value[i-1] < value[i]:\\n                minval = value[i]                #initializing minimum number of value[i-1] as value[i] \\n                minval_index = i                 # assigning corresponding index for minimumvalue\\n                for x in range(i+1,length):      #to figure out the just next greater number than value[i-1]\\n                    if value[i-1] < value[x] < minval:\\n                        minval_index = x\\n                        minval = value[x]\\n                        \\n                \"\"\" after the above for loop u will have the next greater number than value[i-1] \"\"\"\\n                \"\"\" after which swap both minimum value and value at i-1 \"\"\"\\n                value[i-1],value[minval_index] = value[minval_index],value[i-1]\\n                \\n                \"\"\" the sorting is done as to minimum number is for any m digit number would be asscending order sort\\n                    so we sort numbers from value from index i to end of the list so as to get the next bigger number\"\"\"\\n                value[i:] = sorted(value[i:])\\n                result = int(\"\".join(value))\\n                return  result if maxvalue_of_32_bit_integer >= result else -1 # return only result which is less than max value of 32 bit integer\\n            i -= 1\\n        return -1\\n                        \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430939,
                "title": "next-permutation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        int i, j;\\n        \\n        for(i=s.size() - 2; i>=0; i--) if(s[i] < s[i + 1]) break;\\n        if(i == -1) return -1;\\n        \\n        for(j=s.size()-1; j>i; j--) if(s[j] > s[i]) break;\\n        swap(s[i], s[j]);\\n        reverse(s.begin() + i + 1, s.end());\\n        \\n        return stol(s) > INT_MAX ? -1 : stol(s);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        int i, j;\\n        \\n        for(i=s.size() - 2; i>=0; i--) if(s[i] < s[i + 1]) break;\\n        if(i == -1) return -1;\\n        \\n        for(j=s.size()-1; j>i; j--) if(s[j] > s[i]) break;\\n        swap(s[i], s[j]);\\n        reverse(s.begin() + i + 1, s.end());\\n        \\n        return stol(s) > INT_MAX ? -1 : stol(s);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345074,
                "title": "c-faster-than-100-less-than-93-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void check(string& temp, int place, char bef){\\n        vector<char> v;\\n        char r = temp[place];\\n        for(int i = place+1; i<temp.length(); i++){\\n            if(temp[i]<r && temp[i]>bef){\\n                char c = temp[place];\\n                temp[place] = temp[i];\\n                temp[i] = c;\\n                r = temp[i];\\n            }\\n        }\\n        for(int i = place+1; i<temp.length(); i++){\\n            v.push_back(temp[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i = 0; i<v.size(); i++){\\n            temp[place+i+1] = v[i];\\n        }\\n    }\\n    int nextGreaterElement(int n) {\\n        int t = n;\\n        string temp = to_string(t);\\n        int place = -1;\\n        for(int i = 0; i<temp.length()-1; i++){\\n            if(temp[i]<temp[i+1])\\n                place = i;\\n        }\\n        if(place != -1){\\n            char c = temp[place];\\n            temp[place] = temp[place+1];\\n            temp[place+1] = c;\\n            check(temp, place, temp[place+1]);\\n            long long te = stol(temp);\\n            if(te>INT_MAX)\\n                return -1;\\n            \\n            return (int)te;\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(string& temp, int place, char bef){\\n        vector<char> v;\\n        char r = temp[place];\\n        for(int i = place+1; i<temp.length(); i++){\\n            if(temp[i]<r && temp[i]>bef){\\n                char c = temp[place];\\n                temp[place] = temp[i];\\n                temp[i] = c;\\n                r = temp[i];\\n            }\\n        }\\n        for(int i = place+1; i<temp.length(); i++){\\n            v.push_back(temp[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i = 0; i<v.size(); i++){\\n            temp[place+i+1] = v[i];\\n        }\\n    }\\n    int nextGreaterElement(int n) {\\n        int t = n;\\n        string temp = to_string(t);\\n        int place = -1;\\n        for(int i = 0; i<temp.length()-1; i++){\\n            if(temp[i]<temp[i+1])\\n                place = i;\\n        }\\n        if(place != -1){\\n            char c = temp[place];\\n            temp[place] = temp[place+1];\\n            temp[place+1] = c;\\n            check(temp, place, temp[place+1]);\\n            long long te = stol(temp);\\n            if(te>INT_MAX)\\n                return -1;\\n            \\n            return (int)te;\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320301,
                "title": "c-100-faster-0-ms-runtime-next-permutation-simple",
                "content": "Similar to this question -> [Next Permutation](https://leetcode.com/problems/next-permutation/)\\nJust follow the comments XD\\n\\n\\u2B06\\uFE0F UPVOTE IF HELPFUL\\n\\n```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int a) {\\n        int b = a;\\n        \\n        // Storing given digits of number in vector\\n        vector<int> nums;\\n        while(a>0){\\n            nums.push_back(a%10);\\n            a /= 10;\\n        }\\n        reverse(nums.begin(), nums.end());\\n        \\n        // Next permutation of nums\\n        int n=nums.size();\\n        int l,r;\\n        for(l=n-2;l>=0;l--){\\n            if(nums[l]<nums[l+1]) break;\\n        }\\n        if(l<0) reverse(nums.begin(),nums.end());\\n        else{\\n            for(r=n-1;r>l;r--){\\n                if(nums[r]>nums[l]) break;\\n            }\\n            swap(nums[l],nums[r]);\\n            reverse(nums.begin()+l+1,nums.end());\\n        }\\n        \\n        // Converting nums from vector to integer\\n        long long int ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(ans*10 + nums[i] > INT_MAX) return -1;\\n            else{ ans = ans*10 + nums[i]; }\\n        }\\n        return ans > b ? ans : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int a) {\\n        int b = a;\\n        \\n        // Storing given digits of number in vector\\n        vector<int> nums;\\n        while(a>0){\\n            nums.push_back(a%10);\\n            a /= 10;\\n        }\\n        reverse(nums.begin(), nums.end());\\n        \\n        // Next permutation of nums\\n        int n=nums.size();\\n        int l,r;\\n        for(l=n-2;l>=0;l--){\\n            if(nums[l]<nums[l+1]) break;\\n        }\\n        if(l<0) reverse(nums.begin(),nums.end());\\n        else{\\n            for(r=n-1;r>l;r--){\\n                if(nums[r]>nums[l]) break;\\n            }\\n            swap(nums[l],nums[r]);\\n            reverse(nums.begin()+l+1,nums.end());\\n        }\\n        \\n        // Converting nums from vector to integer\\n        long long int ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(ans*10 + nums[i] > INT_MAX) return -1;\\n            else{ ans = ans*10 + nums[i]; }\\n        }\\n        return ans > b ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313281,
                "title": "python-stack-binary-search-faster-than-90",
                "content": "We implement a Montonically Incerasing Stack `st`.\\nWe iterate through the digits from the end and when we come across the 1st decreasing value `x` , we find the smallest digit greater than `x`.\\nSince the values in the stack are in sorted order, we can use Binary Search to find the position of the smallest greater element  i.e  `pos = bisect_right(st,x)` \\n```py\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        nums = list(map(int,str(n)))\\n        st = []\\n        for i,x in enumerate(reversed(nums),1):\\n            if st and st[-1]>x:\\n                pos = bisect_right(st,x) \\n                if pos<len(st):\\n                    ele, st[pos] = st[pos], x\\n                    sol = int(\"\".join(map(str, nums[:-i] + [ele] + st )))\\n                    return sol if (sol<=(1<<31)-1) else -1\\n            st.append(x)\\n        return -1\\n```\\n![image](https://assets.leetcode.com/users/images/5d8b8751-a5dd-4918-8202-4be61cfbb322_1658409992.2545571.png)\\n\\n\\n**Happy Coding !!**\\n\\nIn case of doubts, feel free to ask .",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Monotonic Stack",
                    "Binary Tree"
                ],
                "code": "```py\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        nums = list(map(int,str(n)))\\n        st = []\\n        for i,x in enumerate(reversed(nums),1):\\n            if st and st[-1]>x:\\n                pos = bisect_right(st,x) \\n                if pos<len(st):\\n                    ele, st[pos] = st[pos], x\\n                    sol = int(\"\".join(map(str, nums[:-i] + [ele] + st )))\\n                    return sol if (sol<=(1<<31)-1) else -1\\n            st.append(x)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279910,
                "title": "c-faster-than-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        if(!next_permutation(s.begin(), s.end())) return -1;\\n        long n1= stol(s);\\n        if(n1>INT_MAX) return -1;\\n        else{\\n            return n1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string s = to_string(n);\\n        if(!next_permutation(s.begin(), s.end())) return -1;\\n        long n1= stol(s);\\n        if(n1>INT_MAX) return -1;\\n        else{\\n            return n1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225565,
                "title": "similar-to-next-permutation",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        List<Long> list = new ArrayList<>();\\n        while(n != 0) {\\n            list.add(0, (long)n%10);\\n            n /= 10;\\n        }\\n        \\n        int i = list.size()-2;\\n        while(i >= 0 && list.get(i) >= list.get(i+1)) i--;\\n        if(i == -1) return -1;\\n\\n        int j = list.size() - 1;\\n        while(j > i && list.get(j) <= list.get(i)) j--;\\n        \\n        swap(list, i, j);\\n        int start = i+1;\\n        int end = list.size()-1;\\n        while(start < end) {\\n            swap(list, start++, end--);\\n        }\\n        \\n        long result = 0;\\n        for(long num: list) {\\n            result = result*10 + num;\\n        }\\n        \\n        return result > Integer.MAX_VALUE ? -1 : (int) result;\\n    }\\n    \\n    private void swap(List<Long> list, int i, int j) {\\n        long tempI = list.get(i);\\n        long tempJ = list.get(j);\\n        list.set(j, tempI);\\n        list.set(i, tempJ);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        List<Long> list = new ArrayList<>();\\n        while(n != 0) {\\n            list.add(0, (long)n%10);\\n            n /= 10;\\n        }\\n        \\n        int i = list.size()-2;\\n        while(i >= 0 && list.get(i) >= list.get(i+1)) i--;\\n        if(i == -1) return -1;\\n\\n        int j = list.size() - 1;\\n        while(j > i && list.get(j) <= list.get(i)) j--;\\n        \\n        swap(list, i, j);\\n        int start = i+1;\\n        int end = list.size()-1;\\n        while(start < end) {\\n            swap(list, start++, end--);\\n        }\\n        \\n        long result = 0;\\n        for(long num: list) {\\n            result = result*10 + num;\\n        }\\n        \\n        return result > Integer.MAX_VALUE ? -1 : (int) result;\\n    }\\n    \\n    private void swap(List<Long> list, int i, int j) {\\n        long tempI = list.get(i);\\n        long tempJ = list.get(j);\\n        list.set(j, tempI);\\n        list.set(i, tempJ);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218967,
                "title": "c-100-faster-93-less-memory-usage-next-permutation-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n    string s = to_string(n);\\n\\t// Check if next greater possible\\n    bool val = next_permutation(s.begin(), s.end());\\n    if(!val)return -1; // If not return -1\\n\\t\\n\\t// stoll() is used for long int. If greater than integer max, return -1\\n    else if(stoll(s)>INT_MAX)return -1; \\n\\t\\n\\t// Else return by converting from string to int using stoi\\n    else return stoi(s);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3d7c8184-073c-44ea-82b7-aa08a38aa1e6_1656603978.1185935.png)\\n\\nUnfair advantage of C++",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n    string s = to_string(n);\\n\\t// Check if next greater possible\\n    bool val = next_permutation(s.begin(), s.end());\\n    if(!val)return -1; // If not return -1\\n\\t\\n\\t// stoll() is used for long int. If greater than integer max, return -1\\n    else if(stoll(s)>INT_MAX)return -1; \\n\\t\\n\\t// Else return by converting from string to int using stoi\\n    else return stoi(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213810,
                "title": "python-solution-96ms-with-comments",
                "content": "\\n        arr=[]\\n        \\n        #convert interger to array  \\n        def intToArr(n):\\n            if n==0:\\n                return \\n            intToArr(n//10)\\n            arr.append(n%10)\\n            \\n        intToArr(n)\\n        \\n        \\n        i=j=len(arr)-1\\n        \\n        #Finding last peak where arr[i-1] >= arr[i]\\n        while i > 0 and arr[i-1] >= arr[i]:\\n            i-=1\\n        \\n        #if we cant find peak that means no such positive interger exists\\n        if i==0:\\n            return -1\\n        \\n        k=i-1\\n        \\n        #find smallest(next) greater number for k = i-1\\n        while arr[k] >= arr[j]:\\n            j-=1\\n        \\n        #swap k with smallest greater number j\\n        arr[k], arr[j] = arr[j], arr[k]\\n        \\n        \\n        #reverse remaining part of array\\n        l=i\\n        r=len(arr)-1\\n        while l <= r:\\n            arr[l], arr[r] = arr[r] ,arr[l]\\n            l+=1\\n            r-=1\\n        \\n        #convert array to int\\n        ans=0\\n        \\n        for i in range(len(arr)):\\n            ans=ans*10+arr[i]\\n        \\n\\n        return  ans if ans<1<<31 else -1",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n        arr=[]\\n        \\n        #convert interger to array  \\n        def intToArr(n):\\n            if n==0:\\n                return \\n            intToArr(n//10)\\n            arr.append(n%10)\\n            \\n        intToArr(n)\\n        \\n        \\n        i=j=len(arr)-1\\n        \\n        #Finding last peak where arr[i-1] >= arr[i]\\n        while i > 0 and arr[i-1] >= arr[i]:\\n            i-=1\\n        \\n        #if we cant find peak that means no such positive interger exists\\n        if i==0:\\n            return -1\\n        \\n        k=i-1\\n        \\n        #find smallest(next) greater number for k = i-1\\n        while arr[k] >= arr[j]:\\n            j-=1\\n        \\n        #swap k with smallest greater number j\\n        arr[k], arr[j] = arr[j], arr[k]\\n        \\n        \\n        #reverse remaining part of array\\n        l=i\\n        r=len(arr)-1\\n        while l <= r:\\n            arr[l], arr[r] = arr[r] ,arr[l]\\n            l+=1\\n            r-=1\\n        \\n        #convert array to int\\n        ans=0\\n        \\n        for i in range(len(arr)):\\n            ans=ans*10+arr[i]\\n        \\n\\n        return  ans if ans<1<<31 else -1",
                "codeTag": "Python3"
            },
            {
                "id": 2182683,
                "title": "simple-c-solution-next-permutation-beats-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    string nextperm(string str)\\n    {\\n        int ind = -1;\\n        for(int i=str.length()-2;i>=0;i--)\\n        {\\n            if(str[i]<str[i+1])\\n            {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        if(ind==-1)\\n        {\\n\\t\\t   // this is the case when the number string is strictly decreasing so next permutation doesnt exist.\\n            return \"-1\";\\n        }\\n        int ind2 = -1;\\n        for(int i=str.length()-1;i>=0;i--)\\n        {\\n            if(str[i]>str[ind])\\n            {\\n                ind2 = i;\\n                break;\\n            }\\n        }\\n        \\n        swap(str[ind],str[ind2]);\\n        reverse(str.begin()+ind+1,str.end());\\n        return str;\\n    }\\n\\t\\n    int nextGreaterElement(int n) {\\n        \\n        long long x = stol(nextperm(to_string(n)));\\n\\t\\t// for cases when x exceeds maximum INT limit.\\n        if(x>INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return x;\\n    }\\n};\\n```\\nTime Complexity - O(M) where M is the length of the integer.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string nextperm(string str)\\n    {\\n        int ind = -1;\\n        for(int i=str.length()-2;i>=0;i--)\\n        {\\n            if(str[i]<str[i+1])\\n            {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        if(ind==-1)\\n        {\\n\\t\\t   // this is the case when the number string is strictly decreasing so next permutation doesnt exist.\\n            return \"-1\";\\n        }\\n        int ind2 = -1;\\n        for(int i=str.length()-1;i>=0;i--)\\n        {\\n            if(str[i]>str[ind])\\n            {\\n                ind2 = i;\\n                break;\\n            }\\n        }\\n        \\n        swap(str[ind],str[ind2]);\\n        reverse(str.begin()+ind+1,str.end());\\n        return str;\\n    }\\n\\t\\n    int nextGreaterElement(int n) {\\n        \\n        long long x = stol(nextperm(to_string(n)));\\n\\t\\t// for cases when x exceeds maximum INT limit.\\n        if(x>INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158305,
                "title": "100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        int max = Integer.MAX_VALUE;\\n        int arr[] = new int[12];\\n        int size = 0;\\n        while(n!=0){\\n            arr[size++] = n%10;\\n            n/=10;\\n        }\\n        for(int i = 1 ; i<size ; i++){\\n            if(arr[i]<arr[i-1]){\\n                int j = i-1;\\n                while(j!=0 && arr[j-1]>arr[i]){   \\n                    j--;\\n                }\\n                swap(arr,i,j);\\n                int low = 0, high = i-1;\\n                while(low<high){\\n                    swap(arr,low,high);\\n                    low++;\\n                    high--;\\n                }\\n                return createNumber(arr,size);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int createNumber(int arr[], int size){\\n        int res=0, max = Integer.MAX_VALUE;\\n        int mul = 1;\\n        for(int i = 0; i<size ; i++){\\n            if(arr[i]>(max-res)/mul)  return -1;\\n            res = arr[i]*mul + res;\\n            mul*=10;\\n        }\\n        return res;\\n    }\\n    \\n    void swap(int arr[], int low, int high){\\n        int temp = arr[low];\\n        arr[low] = arr[high];\\n        arr[high] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        int max = Integer.MAX_VALUE;\\n        int arr[] = new int[12];\\n        int size = 0;\\n        while(n!=0){\\n            arr[size++] = n%10;\\n            n/=10;\\n        }\\n        for(int i = 1 ; i<size ; i++){\\n            if(arr[i]<arr[i-1]){\\n                int j = i-1;\\n                while(j!=0 && arr[j-1]>arr[i]){   \\n                    j--;\\n                }\\n                swap(arr,i,j);\\n                int low = 0, high = i-1;\\n                while(low<high){\\n                    swap(arr,low,high);\\n                    low++;\\n                    high--;\\n                }\\n                return createNumber(arr,size);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int createNumber(int arr[], int size){\\n        int res=0, max = Integer.MAX_VALUE;\\n        int mul = 1;\\n        for(int i = 0; i<size ; i++){\\n            if(arr[i]>(max-res)/mul)  return -1;\\n            res = arr[i]*mul + res;\\n            mul*=10;\\n        }\\n        return res;\\n    }\\n    \\n    void swap(int arr[], int low, int high){\\n        int temp = arr[low];\\n        arr[low] = arr[high];\\n        arr[high] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143298,
                "title": "next-greater-element-iii-java-easy-0ms-100",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String str=String.valueOf(n);\\n        char []ch=str.toCharArray();\\n        \\n        int i=ch.length-2;\\n        \\n        while(i>=0 && ch[i+1]<=ch[i]){\\n            i--;\\n        }\\n        \\n        if(i==-1){\\n            return -1;\\n        }\\n        \\n        int j=ch.length-1;\\n        \\n        while(ch[j]<=ch[i]){\\n            j--;\\n        }\\n        \\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n        \\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int k=0;k<=i;k++){\\n            sb.append(ch[k]);\\n        }\\n        \\n        for(int k=ch.length-1;k>i;k--){\\n            sb.append(ch[k]);\\n        }\\n        \\n        str=sb.toString();\\n        try{\\n            int ans=Integer.parseInt(str);\\n            return ans;\\n        }catch(Exception e){\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        String str=String.valueOf(n);\\n        char []ch=str.toCharArray();\\n        \\n        int i=ch.length-2;\\n        \\n        while(i>=0 && ch[i+1]<=ch[i]){\\n            i--;\\n        }\\n        \\n        if(i==-1){\\n            return -1;\\n        }\\n        \\n        int j=ch.length-1;\\n        \\n        while(ch[j]<=ch[i]){\\n            j--;\\n        }\\n        \\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n        \\n        StringBuilder sb=new StringBuilder();\\n        \\n        for(int k=0;k<=i;k++){\\n            sb.append(ch[k]);\\n        }\\n        \\n        for(int k=ch.length-1;k>i;k--){\\n            sb.append(ch[k]);\\n        }\\n        \\n        str=sb.toString();\\n        try{\\n            int ans=Integer.parseInt(str);\\n            return ans;\\n        }catch(Exception e){\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090237,
                "title": "very-simple-solution-with-explanation-java",
                "content": "- Firstly, find rightmost digit which has a digit greater than itself on it\\'s right. Why so ? in that case we can swap those two digits and get a greater number. If you cannot find any such digit then no answer is possible.\\n- After finding such a digit, swap it with smallest digit to right greater than the number itself.\\n- Sort the remaining digits to the right to get the smallest number possible.\\n\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        \\n        char[] num = Integer.toString(n).toCharArray();\\n        \\n\\t\\t// Find rightmost digit which has a digit greater than itself on it\\'s right\\n        char max = \\'0\\';\\n        boolean possible = false;\\n        int i = 0;\\n        for(i = num.length - 1; i >= 0; i--){\\n            if(max > num[i]){\\n                possible = true;\\n                break;\\n            }\\n            if(num[i] > max)\\n                max = num[i];\\n        }\\n        \\n        if(!possible){\\n\\t\\t// If you cannot find any such digit then no answer is possible.\\n            return -1;\\n        }\\n        \\n        int ans = -1;\\n        \\n\\t\\t//Find smallest digit to right greater than the number itself.\\n        for(int j = i + 1; j < num.length; j++){\\n            if(num[j] > num[i]){\\n                if(ans == -1 || num[j] < num[ans])\\n                    ans = j;\\n            }\\n        }\\n        \\n\\t\\t//swap\\n        char temp = num[i];\\n        num[i] = num[ans];\\n        num[ans] = temp;\\n\\t\\t\\n\\t\\t//Sort the remaining digits to the right to get the smallest number possible\\n        Arrays.sort(num, i+1, num.length);\\n\\t\\t\\n        long val = Long.parseLong(new String(num));\\n        return val > Integer.MAX_VALUE ? -1 : (int)val ;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        \\n        char[] num = Integer.toString(n).toCharArray();\\n        \\n\\t\\t// Find rightmost digit which has a digit greater than itself on it\\'s right\\n        char max = \\'0\\';\\n        boolean possible = false;\\n        int i = 0;\\n        for(i = num.length - 1; i >= 0; i--){\\n            if(max > num[i]){\\n                possible = true;\\n                break;\\n            }\\n            if(num[i] > max)\\n                max = num[i];\\n        }\\n        \\n        if(!possible){\\n\\t\\t// If you cannot find any such digit then no answer is possible.\\n            return -1;\\n        }\\n        \\n        int ans = -1;\\n        \\n\\t\\t//Find smallest digit to right greater than the number itself.\\n        for(int j = i + 1; j < num.length; j++){\\n            if(num[j] > num[i]){\\n                if(ans == -1 || num[j] < num[ans])\\n                    ans = j;\\n            }\\n        }\\n        \\n\\t\\t//swap\\n        char temp = num[i];\\n        num[i] = num[ans];\\n        num[ans] = temp;\\n\\t\\t\\n\\t\\t//Sort the remaining digits to the right to get the smallest number possible\\n        Arrays.sort(num, i+1, num.length);\\n\\t\\t\\n        long val = Long.parseLong(new String(num));\\n        return val > Integer.MAX_VALUE ? -1 : (int)val ;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066250,
                "title": "100-fast-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    long long constoi(string s){long long res=0;int i=0;while(s[i]==0&&i<s.length())i++;for(i;i<s.length();i++){int x;if(s[i]==0)x=10;else x=s[i]-\\'0\\';res=res*10+x;}return res;}\\n\\n    int nextGreaterElement(int n) {\\n        string s=to_string(n);\\n        string k=s;next_permutation(k.begin(),k.end());\\n        if(k<=s||constoi(k)>INT_MAX) return -1;\\n        else\\n            return constoi(k);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    long long constoi(string s){long long res=0;int i=0;while(s[i]==0&&i<s.length())i++;for(i;i<s.length();i++){int x;if(s[i]==0)x=10;else x=s[i]-\\'0\\';res=res*10+x;}",
                "codeTag": "Java"
            },
            {
                "id": 2048326,
                "title": "python-straight-forward",
                "content": "```\\nnums = [int(i) for i in str(n)]\\n        \\n        for i in range(len(nums)-1,0,-1):\\n            if nums[i] > nums[i-1]:\\n                nums[i:] = list(sorted(nums[i:]))\\n                \\n                j = i\\n                while nums[j] <= nums[i-1]:\\n                    j += 1\\n                    \\n                nums[j],nums[i-1] = nums[i-1],nums[j]\\n                \\n                st = \"\".join([str(i) for i in nums])\\n                \\n                if int(st) > 2147483647:\\n                    return -1\\n                return st\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nnums = [int(i) for i in str(n)]\\n        \\n        for i in range(len(nums)-1,0,-1):\\n            if nums[i] > nums[i-1]:\\n                nums[i:] = list(sorted(nums[i:]))\\n                \\n                j = i\\n                while nums[j] <= nums[i-1]:\\n                    j += 1\\n                    \\n                nums[j],nums[i-1] = nums[i-1],nums[j]\\n                \\n                st = \"\".join([str(i) for i in nums])\\n                \\n                if int(st) > 2147483647:\\n                    return -1\\n                return st\\n            \\n        return -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043812,
                "title": "java-solution-which-i-got-while-solving-with-pen-and-paper-0ms-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/94bedf76-af5f-47ab-be35-cfc73b8eed71_1652679158.990696.png)\\n\\n\\n\\tpublic class NextGreaterElementIII {\\n\\n    public static void main(String[] args) {\\n        System.out.println(Integer.MAX_VALUE);\\n        //Test case: 230241, 12411\\n        int ans = nextGreaterElement3(12411);\\n\\n        System.out.println(ans);\\n    }\\n\\n\\n\\n    // all test cases passed\\n    public static int nextGreaterElement3(int num) {\\n        char[] arr = String.valueOf(num).toCharArray();\\n        int n = arr.length;\\n        char[] helper = new char[n];\\n        int x = 0;\\n        boolean isFound = false;\\n        for (int i = n - 1; i >= 0; i--) {\\n            helper[x++] = arr[i]; // start from righmost index and keep all values in helper array till you find first adjacent smaller\\n            if (i-1>=0 && arr[i - 1] < arr[i]) {\\n                isFound = true;\\n                char toReplace = findSmallLargestFromHelperAndSwap(helper, arr[i - 1]);\\n                arr[i - 1] = toReplace;\\n\\n                /*above steps explained:\\n                eg 12411. first adjacent smallest is 2 when iterating from right to left bcz 2 is smaller then 4\\n                helper: 1,1,4\\n                now find in helper smallest greator then value 2 which is 4.\\n                helper now becomes 1,1,2 after swapping and 4 is returned\\n                arr[i-1]=4\\n                arr[]=1,4,1,1,2\\n                now helper already would have elements in ascending order(bcz we were searching for adjacent smaller while creating helper)\\n                now from index i to n-1 replace all arr elements with helper elements as in line 43 to 45\\n                * */\\n\\n                int j = 0;\\n                for (int k = i; k < n; k++) {\\n                    arr[k] = helper[j++];\\n                }\\n                break;\\n            }\\n        }\\n\\n        if (isFound) {\\n            long l = Long.parseLong(new String(arr)); // to check overflow in integer\\n            if (l <= Integer.MAX_VALUE) {\\n                return (int) l;\\n            } else {\\n                return -1;\\n            }\\n        } else {\\n            return -1;\\n        }\\n\\n    }\\n\\n    private static char findSmallLargestFromHelperAndSwap(char[] helper, char c) {\\n        for (int i = 0; i < helper.length; i++) {\\n            if (helper[i] > c) {\\n                char value = helper[i];\\n                helper[i] = c;\\n                return value;\\n            }\\n        }\\n        return \\'\\\\0\\';\\n\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/94bedf76-af5f-47ab-be35-cfc73b8eed71_1652679158.990696.png)\\n\\n\\n\\tpublic class NextGreaterElementIII {\\n\\n    public static void main(String[] args) {\\n        System.out.println(Integer.MAX_VALUE);\\n        //Test case: 230241, 12411\\n        int ans = nextGreaterElement3(12411);\\n\\n        System.out.println(ans);\\n    }\\n\\n\\n\\n    // all test cases passed\\n    public static int nextGreaterElement3(int num) {\\n        char[] arr = String.valueOf(num).toCharArray();\\n        int n = arr.length;\\n        char[] helper = new char[n];\\n        int x = 0;\\n        boolean isFound = false;\\n        for (int i = n - 1; i >= 0; i--) {\\n            helper[x++] = arr[i]; // start from righmost index and keep all values in helper array till you find first adjacent smaller\\n            if (i-1>=0 && arr[i - 1] < arr[i]) {\\n                isFound = true;\\n                char toReplace = findSmallLargestFromHelperAndSwap(helper, arr[i - 1]);\\n                arr[i - 1] = toReplace;\\n\\n                /*above steps explained:\\n                eg 12411. first adjacent smallest is 2 when iterating from right to left bcz 2 is smaller then 4\\n                helper: 1,1,4\\n                now find in helper smallest greator then value 2 which is 4.\\n                helper now becomes 1,1,2 after swapping and 4 is returned\\n                arr[i-1]=4\\n                arr[]=1,4,1,1,2\\n                now helper already would have elements in ascending order(bcz we were searching for adjacent smaller while creating helper)\\n                now from index i to n-1 replace all arr elements with helper elements as in line 43 to 45\\n                * */\\n\\n                int j = 0;\\n                for (int k = i; k < n; k++) {\\n                    arr[k] = helper[j++];\\n                }\\n                break;\\n            }\\n        }\\n\\n        if (isFound) {\\n            long l = Long.parseLong(new String(arr)); // to check overflow in integer\\n            if (l <= Integer.MAX_VALUE) {\\n                return (int) l;\\n            } else {\\n                return -1;\\n            }\\n        } else {\\n            return -1;\\n        }\\n\\n    }\\n\\n    private static char findSmallLargestFromHelperAndSwap(char[] helper, char c) {\\n        for (int i = 0; i < helper.length; i++) {\\n            if (helper[i] > c) {\\n                char value = helper[i];\\n                helper[i] = c;\\n                return value;\\n            }\\n        }\\n        return \\'\\\\0\\';\\n\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 2033102,
                "title": "java-o-n-simple-solution",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        while (n > 0) {\\n            list.add(n % 10);\\n            n /= 10;\\n        }\\n        \\n        if (list.size() == 1) {\\n            return -1;\\n        }\\n        \\n        int prev = list.get(0);\\n        \\n        int i = 1;\\n        // find first element which is smaller than previous\\n        while (list.get(i-1) <= list.get(i)) {\\n            i++;\\n            if (i == list.size()) {\\n                // all elements sorted in ascending order already\\n                // not possible to build next higher permutation\\n                return - 1;\\n            }\\n        }\\n        \\n        // find min element which is higher than i\\n        // list up to i is sorted in ascending order\\n        int j = 0;\\n        while (list.get(j) <= list.get(i)) {\\n            j++;\\n        }\\n        \\n        // swap i with j\\n        int tmp = list.get(i);\\n        list.set(i, list.get(j));\\n        list.set(j, tmp);\\n        \\n        // reverse in ascending order all elements up to i\\n        Collections.reverse(list.subList(0,i));\\n        \\n        // build result\\n        long res = 0;\\n        \\n        int m = 1;\\n        for (int num : list) {\\n            res += (long)num*m;\\n            m*= 10;\\n        }\\n        \\n        return (res > Integer.MAX_VALUE) ? -1 : (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        while (n > 0) {\\n            list.add(n % 10);\\n            n /= 10;\\n        }\\n        \\n        if (list.size() == 1) {\\n            return -1;\\n        }\\n        \\n        int prev = list.get(0);\\n        \\n        int i = 1;\\n        // find first element which is smaller than previous\\n        while (list.get(i-1) <= list.get(i)) {\\n            i++;\\n            if (i == list.size()) {\\n                // all elements sorted in ascending order already\\n                // not possible to build next higher permutation\\n                return - 1;\\n            }\\n        }\\n        \\n        // find min element which is higher than i\\n        // list up to i is sorted in ascending order\\n        int j = 0;\\n        while (list.get(j) <= list.get(i)) {\\n            j++;\\n        }\\n        \\n        // swap i with j\\n        int tmp = list.get(i);\\n        list.set(i, list.get(j));\\n        list.set(j, tmp);\\n        \\n        // reverse in ascending order all elements up to i\\n        Collections.reverse(list.subList(0,i));\\n        \\n        // build result\\n        long res = 0;\\n        \\n        int m = 1;\\n        for (int num : list) {\\n            res += (long)num*m;\\n            m*= 10;\\n        }\\n        \\n        return (res > Integer.MAX_VALUE) ? -1 : (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993950,
                "title": "easy-solution-java",
                "content": "```\\nclass Solution {\\n    public int getSize(int n)\\n    {\\n        int count = 0;\\n        while(n>0)\\n        {\\n            count++;\\n            n = n/10;\\n        }\\n        return count;\\n    }\\n    public int[] numToAr(int n)\\n    {\\n        int sz = getSize(n);\\n        int[] ar = new int[sz];\\n        int i =  sz-1;\\n        while(i>=0)\\n        {\\n            ar[i--] = n%10;\\n            n = n/10;\\n        }\\n        return ar;\\n    }\\n    public long arToNumber(int[] arr)\\n    {\\n        long num = 0;\\n        int idx = 0;\\n        while(idx<arr.length)\\n        {\\n            num = num*10 + arr[idx];\\n            idx++;\\n        }\\n        return num;\\n    }\\n    public int nextGreaterElement(int n) {\\n        int[] ar = numToAr(n);\\n        \\n        // checking next greater \\n        \\n        int pc = ar.length-2;\\n        while(pc>=0 && ar[pc] >= ar[pc+1])\\n            pc--;\\n        \\n        if(pc == -1)\\n            return -1;\\n        \\n        // finding next greater element\\n        int j = ar.length-1;\\n        while(j>=0 && ar[j] <= ar[pc])\\n            j--;\\n        \\n        if(j == -1)\\n            return -1;\\n        \\n        // swapping\\n        int temp = ar[j];\\n        ar[j] = ar[pc];\\n        ar[pc] = temp;\\n\\n        // reversing\\n        int i=pc+1, k = ar.length-1;\\n        while(i<=k)\\n        {\\n            int tp = ar[i];\\n            ar[i] = ar[k];\\n            ar[k] = tp;\\n            i++;\\n            k--;\\n        }\\n        for(int val : ar)\\n            System.out.print(val+\" \");\\n     \\n        long finalans = arToNumber(ar);\\n        if(finalans > (int)2e31)\\n            return -1;\\n        else\\n               return (int)finalans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int getSize(int n)\\n    {\\n        int count = 0;\\n        while(n>0)\\n        {\\n            count++;\\n            n = n/10;\\n        }\\n        return count;\\n    }\\n    public int[] numToAr(int n)\\n    {\\n        int sz = getSize(n);\\n        int[] ar = new int[sz];\\n        int i =  sz-1;\\n        while(i>=0)\\n        {\\n            ar[i--] = n%10;\\n            n = n/10;\\n        }\\n        return ar;\\n    }\\n    public long arToNumber(int[] arr)\\n    {\\n        long num = 0;\\n        int idx = 0;\\n        while(idx<arr.length)\\n        {\\n            num = num*10 + arr[idx];\\n            idx++;\\n        }\\n        return num;\\n    }\\n    public int nextGreaterElement(int n) {\\n        int[] ar = numToAr(n);\\n        \\n        // checking next greater \\n        \\n        int pc = ar.length-2;\\n        while(pc>=0 && ar[pc] >= ar[pc+1])\\n            pc--;\\n        \\n        if(pc == -1)\\n            return -1;\\n        \\n        // finding next greater element\\n        int j = ar.length-1;\\n        while(j>=0 && ar[j] <= ar[pc])\\n            j--;\\n        \\n        if(j == -1)\\n            return -1;\\n        \\n        // swapping\\n        int temp = ar[j];\\n        ar[j] = ar[pc];\\n        ar[pc] = temp;\\n\\n        // reversing\\n        int i=pc+1, k = ar.length-1;\\n        while(i<=k)\\n        {\\n            int tp = ar[i];\\n            ar[i] = ar[k];\\n            ar[k] = tp;\\n            i++;\\n            k--;\\n        }\\n        for(int val : ar)\\n            System.out.print(val+\" \");\\n     \\n        long finalans = arToNumber(ar);\\n        if(finalans > (int)2e31)\\n            return -1;\\n        else\\n               return (int)finalans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949566,
                "title": "c-using-simple-iteration",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n         string s = to_string(n);\\n        \\n        int i;\\n        for(i = s.length()-2; i >= 0; i--){\\n            if(s[i] >= s[i+1])     \\n                continue;\\n            else\\n                break;\\n        }\\n        int j;\\n        if(i < 0)\\n            return -1;\\n        for(j = s.length()-1; j > i; j--)\\n        {\\n            if(s[j] > s[i]){\\n                swap(s[i], s[j]);\\n                break;\\n            }\\n        }\\n        reverse(s.begin()+i+1, s.end());\\n        long long result=stoll(s);\\n        return (result>INT_MAX || result<=n)? -1:result; \\n    }\\n};\\nIf Helpful Please Like And Upvoke\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n         string s = to_string(n);\\n        \\n        int i;\\n        for(i = s.length()-2; i >= 0; i--){\\n            if(s[i] >= s[i+1])     \\n                continue;\\n            else\\n                break;\\n        }\\n        int j;\\n        if(i < 0)\\n            return -1;\\n        for(j = s.length()-1; j > i; j--)\\n        {\\n            if(s[j] > s[i]){\\n                swap(s[i], s[j]);\\n                break;\\n            }\\n        }\\n        reverse(s.begin()+i+1, s.end());\\n        long long result=stoll(s);\\n        return (result>INT_MAX || result<=n)? -1:result; \\n    }\\n};\\nIf Helpful Please Like And Upvoke\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929403,
                "title": "python",
                "content": "\\n    def nextGreaterElement(self, n):\\n        ans = list(str(n))\\n        \\n        i = j = len(ans)-1\\n        \\n        while i and ans[i] <= ans[i-1]:\\n            i -= 1\\n            \\n        if i == 0:\\n            return -1\\n        \\n        while ans[j] <= ans[i-1]:\\n            j -= 1\\n            \\n        ans[i-1], ans[j] = ans[j], ans[i-1]\\n        \\n        ans[i:] = ans[i:][::-1]\\n        \\n        res = \"\".join(ans)\\n        \\n        return res if int(res) < 2**31 else -1",
                "solutionTags": [],
                "code": "\\n    def nextGreaterElement(self, n):\\n        ans = list(str(n))\\n        \\n        i = j = len(ans)-1\\n        \\n        while i and ans[i] <= ans[i-1]:\\n            i -= 1\\n            \\n        if i == 0:\\n            return -1\\n        \\n        while ans[j] <= ans[i-1]:\\n            j -= 1\\n            \\n        ans[i-1], ans[j] = ans[j], ans[i-1]\\n        \\n        ans[i:] = ans[i:][::-1]\\n        \\n        res = \"\".join(ans)\\n        \\n        return res if int(res) < 2**31 else -1",
                "codeTag": "Python3"
            },
            {
                "id": 1917558,
                "title": "c-explained-every-line-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string limit = \"2147483647\"; // Answer cannot be greater than 2^31 - 1\\n        string number = to_string(n); //convert n into string\\n        next_permutation(number.begin(),number.end()); //use next permutation to find the next greater\\n        if(number.length() == 10 and number>limit) return -1; // check next greater is larger than limit\\n        int ans = stoi(number); //convert next greater to int\\n        return  ans<=n ? -1 : ans; //check it is less than or equal to n\\n    }\\n};\\n```\\nFeel free to comment if you dont get anything properly.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string limit = \"2147483647\"; // Answer cannot be greater than 2^31 - 1\\n        string number = to_string(n); //convert n into string\\n        next_permutation(number.begin(),number.end()); //use next permutation to find the next greater\\n        if(number.length() == 10 and number>limit) return -1; // check next greater is larger than limit\\n        int ans = stoi(number); //convert next greater to int\\n        return  ans<=n ? -1 : ans; //check it is less than or equal to n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898271,
                "title": "python-faster-than-95-insertion-sort-approach",
                "content": "```\\ndef nextGreaterElement(self, n: int) -> int:\\n        num = [i for i in str(n)]\\n        l = len(num)\\n        for i in range(l - 2, -1, -1):\\n            j = i + 1\\n            while(j < l):\\n                if(num[j] > num[i]):\\n                    num[j], num[i] = num[i], num[j]\\n                    n = int(\\'\\'.join(num)) \\n                    return n if n < 2 ** 31 else -1\\n                j += 1\\n                \\n            j = i + 1\\n            val = num[i]\\n            while(j < l and val > num[j]):\\n                num[j - 1] = num[j]\\n                j += 1\\n            j -= 1\\n            num[j] = val\\n\\n        return -1",
                "solutionTags": [],
                "code": "```\\ndef nextGreaterElement(self, n: int) -> int:\\n        num = [i for i in str(n)]\\n        l = len(num)\\n        for i in range(l - 2, -1, -1):\\n            j = i + 1\\n            while(j < l):\\n                if(num[j] > num[i]):\\n                    num[j], num[i] = num[i], num[j]\\n                    n = int(\\'\\'.join(num)) \\n                    return n if n < 2 ** 31 else -1\\n                j += 1\\n                \\n            j = i + 1\\n            val = num[i]\\n            while(j < l and val > num[j]):\\n                num[j - 1] = num[j]\\n                j += 1\\n            j -= 1\\n            num[j] = val\\n\\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 1896192,
                "title": "java-fast-heavily-commented",
                "content": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        \\n        //Convert Integer to String.\\n        StringBuilder str = new StringBuilder(n + \"\");\\n        \\n        \\n        //find the dip (dip is the index when the value of starts to fall while traversing from right -> left. )\\n        int i = str.length()-1;\\n        while(i > 0) {\\n            if(str.charAt(i-1) >= str.charAt(i)) {\\n                i--;\\n            }\\n            else {\\n                //dip\\n                break;\\n            }\\n        }\\n        \\n        if(i == 0) {\\n            //no dip\\n            return -1;\\n        }\\n        \\n        int j = i-1;\\n        int jl = -1;\\n        \\n        \\n        //Again traverse from last index to the dip and find the immediate greater element than the dip.\\n        for(int k = str.length()-1; k >= j+1;k--) {\\n            if(str.charAt(k) > str.charAt(j)) {\\n                jl = k;\\n                break;\\n            }\\n        }\\n        \\n        //Swap the dip and the just greater element than the dip.\\n        swap(str,j,jl);\\n        \\n        \\n        //append the part before the dip as it is and the reverse(and then append) the part after the dip\\n        StringBuilder sb = new StringBuilder(\"\");\\n        sb.append(str.substring(0,j+1));\\n        \\n        for(int k = str.length()-1; k >= j+1;k--) {\\n            sb.append(str.charAt(k));\\n        }\\n        \\n        long res =  Long.parseLong(sb.toString());\\n        \\n        if(res > Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        \\n        return (int)(res);\\n    }\\n    \\n    \\n    //defining the swap\\n    public static void swap(StringBuilder str, int i,int j) {\\n        char chi = str.charAt(i);\\n        char chj = str.charAt(j);\\n        \\n        str.setCharAt(i,chj);\\n        str.setCharAt(j,chi);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        \\n        //Convert Integer to String.\\n        StringBuilder str = new StringBuilder(n + \"\");\\n        \\n        \\n        //find the dip (dip is the index when the value of starts to fall while traversing from right -> left. )\\n        int i = str.length()-1;\\n        while(i > 0) {\\n            if(str.charAt(i-1) >= str.charAt(i)) {\\n                i--;\\n            }\\n            else {\\n                //dip\\n                break;\\n            }\\n        }\\n        \\n        if(i == 0) {\\n            //no dip\\n            return -1;\\n        }\\n        \\n        int j = i-1;\\n        int jl = -1;\\n        \\n        \\n        //Again traverse from last index to the dip and find the immediate greater element than the dip.\\n        for(int k = str.length()-1; k >= j+1;k--) {\\n            if(str.charAt(k) > str.charAt(j)) {\\n                jl = k;\\n                break;\\n            }\\n        }\\n        \\n        //Swap the dip and the just greater element than the dip.\\n        swap(str,j,jl);\\n        \\n        \\n        //append the part before the dip as it is and the reverse(and then append) the part after the dip\\n        StringBuilder sb = new StringBuilder(\"\");\\n        sb.append(str.substring(0,j+1));\\n        \\n        for(int k = str.length()-1; k >= j+1;k--) {\\n            sb.append(str.charAt(k));\\n        }\\n        \\n        long res =  Long.parseLong(sb.toString());\\n        \\n        if(res > Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        \\n        return (int)(res);\\n    }\\n    \\n    \\n    //defining the swap\\n    public static void swap(StringBuilder str, int i,int j) {\\n        char chi = str.charAt(i);\\n        char chj = str.charAt(j);\\n        \\n        str.setCharAt(i,chj);\\n        str.setCharAt(j,chi);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891936,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int nextGreaterElement(int n) {\\n        int k=String.valueOf(n).length();\\n        int i=k-2;\\n        StringBuilder nm=new StringBuilder(String.valueOf(n));\\n        while(i>=0 && nm.charAt(i)>=nm.charAt(i+1))\\n        {\\n            i--;\\n        }\\n        if(i==-1)\\n            return i;\\n        int j=k-1;\\n        while(j>=i && nm.charAt(i)>=nm.charAt(j))\\n        {\\n            j--;\\n        }\\n        String g=task(nm,i,j);\\n        g=task1(g,i+1,k-1);\\n        nm.setLength(0);\\n        nm=new StringBuilder(g);\\n        long f=Long.parseLong(nm.toString());\\n        if(f>Integer.MAX_VALUE)\\n            return -1;\\n        else\\n            return Integer.parseInt(nm.toString());\\n    }\\n    static String task(StringBuilder nm ,  int i , int j)\\n    {\\n        char c[] = nm.toString().toCharArray();\\n        char d=c[i];\\n        c[i]=c[j];\\n        c[j]=d;\\n        return String.valueOf(c);\\n    }\\n    static String task1(String s , int i , int j)\\n    {\\n        char c[] = s.toCharArray();\\n        while(i<=j)\\n        {\\n            char d=c[i];\\n            c[i]=c[j];\\n            c[j]=d;\\n            i++;\\n            j--;\\n        }\\n        return String.valueOf(c);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\n    public int nextGreaterElement(int n) {\\n        int k=String.valueOf(n).length();\\n        int i=k-2;\\n        StringBuilder nm=new StringBuilder(String.valueOf(n));\\n        while(i>=0 && nm.charAt(i)>=nm.charAt(i+1))\\n        {\\n            i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1888916,
                "title": "c-easy-and-understandable-approach-using-end-pointer",
                "content": "```\\nint nextGreaterElement(int n) {\\n        string str = to_string(n);\\n        int i = str.size()-2;\\n\\t\\t//if we get digits(i.e. ASCII value of character) in ascending order when moving end to begin we reduce the value of i\\n        while(i>=0 and str[i] >= str[i+1]){\\n            i--;\\n        }\\n\\t\\t\\n\\t\\t// if i==-1 that means all the digits are in increasing order so just greatest number is not possible from using same digits\\n        if(i==-1) return -1;\\n\\t\\t\\n\\t\\t//if we get somewhere dip then swap that (ith)digits with digit just greater than that ith digit. \\n        else{\\n            for(int j = str.size()-1;j>i;j--){\\n                if(str[j] > str[i]){\\n                    swap(str[j],str[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        i++;\\n\\t\\t//so now sort all the element at after ith index so that we come up with just greatest elements.\\n        sort(str.begin()+i,str.end());\\n        return stoll(str)>INT_MAX?-1:stoi(str);\\n    }\\n```\\n**Guys if you got the concept then please give an upvote for me.**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint nextGreaterElement(int n) {\\n        string str = to_string(n);\\n        int i = str.size()-2;\\n\\t\\t//if we get digits(i.e. ASCII value of character) in ascending order when moving end to begin we reduce the value of i\\n        while(i>=0 and str[i] >= str[i+1]){\\n            i--;\\n        }\\n\\t\\t\\n\\t\\t// if i==-1 that means all the digits are in increasing order so just greatest number is not possible from using same digits\\n        if(i==-1) return -1;\\n\\t\\t\\n\\t\\t//if we get somewhere dip then swap that (ith)digits with digit just greater than that ith digit. \\n        else{\\n            for(int j = str.size()-1;j>i;j--){\\n                if(str[j] > str[i]){\\n                    swap(str[j],str[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        i++;\\n\\t\\t//so now sort all the element at after ith index so that we come up with just greatest elements.\\n        sort(str.begin()+i,str.end());\\n        return stoll(str)>INT_MAX?-1:stoi(str);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882326,
                "title": "simple-code-with-explanation",
                "content": "Approach : I have used the idea that first get the lexicographically occurring next permutation of the given number .if that exist than we have our result if not we do not have any result and return -1 . because we know that next lexicographically occurring permutation is always greater than the previous one. \\nfor example let us consider the permutations of \"123\"  . total number of permutations will be 3!\\n1. \"1 2 3\"\\n2. \"1 3 2\"\\n3. \"2 1 3\"\\n4. \"2 3 1\"\\n5. \"3 1 2\"\\n6. \"3 2 1\"\\nIf you notice that next permutations of every number is always greater than the previous one. Hence we return the next permutation by using this simple idea.\\n```\\nint nextGreaterElement(int n) {\\n        string num=to_string(n);\\n        bool possible=next_permutation(num.begin(),num.end());\\n        \\n        long val=stol(num);\\n        if(possible && val<=INT_MAX){\\n            return stoi(num);\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Approach : I have used the idea that first get the lexicographically occurring next permutation of the given number .if that exist than we have our result if not we do not have any result and return -1 . because we know that next lexicographically occurring permutation is always greater than the previous one. \\nfor example let us consider the permutations of \"123\"  . total number of permutations will be 3!\\n1. \"1 2 3\"\\n2. \"1 3 2\"\\n3. \"2 1 3\"\\n4. \"2 3 1\"\\n5. \"3 1 2\"\\n6. \"3 2 1\"\\nIf you notice that next permutations of every number is always greater than the previous one. Hence we return the next permutation by using this simple idea.\\n```\\nint nextGreaterElement(int n) {\\n        string num=to_string(n);\\n        bool possible=next_permutation(num.begin(),num.end());\\n        \\n        long val=stol(num);\\n        if(possible && val<=INT_MAX){\\n            return stoi(num);\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1872967,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public void swap(int[] a,int i,int j){\\n        int t=a[i];\\n        a[i]=a[j];\\n        a[j]=t;\\n    }\\n    public int nextGreaterElement(int n) {\\n        int m=n;\\n        int d=0;\\n        while(m>0){\\n            d++;\\n            m=m/10;\\n        }\\n        int[] a=new int[d];\\n        m=n;\\n        for(int i=d-1;i>=0;i--){\\n            a[i]=m%10;\\n            m=m/10;\\n        }\\n        int idx=-1;\\n        for(int i=d-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        if(idx==-1)\\n            return -1;\\n        for(int i=d-1;i>idx;i--){\\n            if(a[i]>a[idx]){\\n                swap(a,i,idx);\\n                break;\\n            }\\n        }\\n        int p=idx+1;int q=d-1;\\n        while(p<q){\\n            swap(a,p,q);\\n            p++;\\n            q--;\\n        }\\n        long res=0;\\n        for(int i=0;i<d;i++){\\n            res=(res*10)+a[i];\\n        }\\n        if(res>(long)Integer.MAX_VALUE)\\n            return -1;\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void swap(int[] a,int i,int j){\\n        int t=a[i];\\n        a[i]=a[j];\\n        a[j]=t;\\n    }\\n    public int nextGreaterElement(int n) {\\n        int m=n;\\n        int d=0;\\n        while(m>0){\\n            d++;\\n            m=m/10;\\n        }\\n        int[] a=new int[d];\\n        m=n;\\n        for(int i=d-1;i>=0;i--){\\n            a[i]=m%10;\\n            m=m/10;\\n        }\\n        int idx=-1;\\n        for(int i=d-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                idx=i;\\n                break;\\n            }\\n        }\\n        if(idx==-1)\\n            return -1;\\n        for(int i=d-1;i>idx;i--){\\n            if(a[i]>a[idx]){\\n                swap(a,i,idx);\\n                break;\\n            }\\n        }\\n        int p=idx+1;int q=d-1;\\n        while(p<q){\\n            swap(a,p,q);\\n            p++;\\n            q--;\\n        }\\n        long res=0;\\n        for(int i=0;i<d;i++){\\n            res=(res*10)+a[i];\\n        }\\n        if(res>(long)Integer.MAX_VALUE)\\n            return -1;\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822797,
                "title": "100-faster-c-solution",
                "content": "class Solution {\\npublic:\\n    int nextGreaterElement(long n) {\\n\\t\\n\\tint rem;\\n\\tlist<int> v;\\n\\tlist<int> nums;\\n\\twhile (n != 0) \\n\\t{                     \\n\\t\\trem = n % 10;\\n\\t\\tif (rem < nums.back())\\n\\t\\t\\tbreak;\\n        n /= 10; \\n\\t\\tnums.push_back(rem);\\n\\t}\\n\\tif(n==0)return -1;\\n        n /= 10;\\n\\twhile (!nums.empty())\\n\\t{\\n\\t\\tif (nums.front() > rem)\\n\\t\\t{\\n\\t\\t\\tn = n * 10 + nums.front();\\n\\t\\t\\tnums.pop_front();\\n\\t\\t\\twhile (!v.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tn = n * 10 + v.front();\\n\\t\\t\\t\\tv.pop_front();\\n\\t\\t\\t}\\n\\t\\t\\tn = n * 10 + rem;\\n\\t\\t\\twhile (!nums.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tn = n * 10 + nums.front();\\n\\t\\t\\t\\tnums.pop_front();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tv.push_back(nums.front());\\n\\t\\t\\tnums.pop_front();\\n\\t\\t}\\n\\t}\\n        if(n>2147483647)return -1;\\n        return n;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int nextGreaterElement(long n) {\\n\\t\\n\\tint rem;\\n\\tlist<int> v;\\n\\tlist<int> nums;\\n\\twhile (n != 0) \\n\\t{                     \\n\\t\\trem = n % 10;\\n\\t\\tif (rem < nums.back())\\n\\t\\t\\tbreak;\\n        n /= 10; \\n\\t\\tnums.push_back(rem);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1798755,
                "title": "using-to-string-stoi-function-100",
                "content": "Runtime: 0 ms\\nMemory Usage: 6.4 MB\\n\\n***Upvote if you find this helpful.***\\n\\n\\n\\'\\'\\'\\n\\n    int nextGreaterElement(int n) {\\n        \\n        string inp = to_string(n);\\n        //find the deep\\n        int deep = inp.size()-2;\\n        while(deep >= 0 && inp[deep] >= inp[deep+1]){\\n            deep--;\\n        }\\n        //if no such element is present return -1 \\n        if(deep == -1) return -1;\\n        \\n        //find the just smaller element of inp[deep] and swap it with inp[deep] because that will give the just greater element\\n        int k = inp.size()-1;\\n        while(inp[deep] >= inp[k]){\\n            k--;\\n        }\\n        swap(inp[k], inp[deep]);\\n        \\n        //concat from starting to inp[deep] just like that\\n        string res = \"\";\\n        for(int i = 0; i<=deep; i++){\\n            res+=inp[i];\\n        }\\n        //From the end of the string till inp[deep] reverse the elements in order to find the just greater element\\n        for(int i = inp.size()-1; i>deep; i--){\\n            res+=inp[i];\\n        }\\n        //finally return the integer form of that string\\n        try{\\n            return stoi(res);\\n        }\\n        //use try catch because for the cases integer value crosses INT_MAX it should return -1\\n        catch(exception e){\\n            return -1;\\n        }\\n      \\n    }\\n\\t\\n\\t\\n\\tHappy Coding\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "Runtime: 0 ms\\nMemory Usage: 6.4 MB\\n\\n***Upvote if you find this helpful.***\\n\\n\\n\\'\\'\\'\\n\\n    int nextGreaterElement(int n) {\\n        \\n        string inp = to_string(n);\\n        //find the deep\\n        int deep = inp.size()-2;\\n        while(deep >= 0 && inp[deep] >= inp[deep+1]){\\n            deep--;\\n        }\\n        //if no such element is present return -1 \\n        if(deep == -1) return -1;\\n        \\n        //find the just smaller element of inp[deep] and swap it with inp[deep] because that will give the just greater element\\n        int k = inp.size()-1;\\n        while(inp[deep] >= inp[k]){\\n            k--;\\n        }\\n        swap(inp[k], inp[deep]);\\n        \\n        //concat from starting to inp[deep] just like that\\n        string res = \"\";\\n        for(int i = 0; i<=deep; i++){\\n            res+=inp[i];\\n        }\\n        //From the end of the string till inp[deep] reverse the elements in order to find the just greater element\\n        for(int i = inp.size()-1; i>deep; i--){\\n            res+=inp[i];\\n        }\\n        //finally return the integer form of that string\\n        try{\\n            return stoi(res);\\n        }\\n        //use try catch because for the cases integer value crosses INT_MAX it should return -1\\n        catch(exception e){\\n            return -1;\\n        }\\n      \\n    }\\n\\t\\n\\t\\n\\tHappy Coding\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1796243,
                "title": "100-faster-c-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int number = INT_MIN;\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            if(nums[i]>=number) number = nums[i];\\n            else\\n            {\\n                sort(nums.begin()+i+1, nums.end());\\n                int j = upper_bound(nums.begin()+i, nums.end(),nums[i])-nums.begin();\\n                if(j<n) //if greater value doesn\\'t exists\\n                {\\n                    swap(nums[i],nums[j]);\\n                    sort(nums.begin()+i+1, nums.end());\\n                    return;\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int nextGreaterElement(int n) {\\n        string comp = \"2147483647\";\\n        vector<int> nums;\\n        string str = to_string(n);\\n        for(int i =0; i<str.length(); i++) nums.push_back(str[i]-\\'0\\');\\n        vector<int> dummy = nums;\\n        sort(dummy.rbegin(), dummy.rend());\\n        if(dummy == nums) return -1;\\n        solve(nums);\\n        string s=\"\";\\n        for(int i=0; i<str.length(); i++)\\n        {\\n            char c = \\'0\\' + nums[i];\\n            s += c;\\n        }\\n        long d = stol(s);\\n        return (d > INT_MAX)? -1 : d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int number = INT_MIN;\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            if(nums[i]>=number) number = nums[i];\\n            else\\n            {\\n                sort(nums.begin()+i+1, nums.end());\\n                int j = upper_bound(nums.begin()+i, nums.end(),nums[i])-nums.begin();\\n                if(j<n) //if greater value doesn\\'t exists\\n                {\\n                    swap(nums[i],nums[j]);\\n                    sort(nums.begin()+i+1, nums.end());\\n                    return;\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    int nextGreaterElement(int n) {\\n        string comp = \"2147483647\";\\n        vector<int> nums;\\n        string str = to_string(n);\\n        for(int i =0; i<str.length(); i++) nums.push_back(str[i]-\\'0\\');\\n        vector<int> dummy = nums;\\n        sort(dummy.rbegin(), dummy.rend());\\n        if(dummy == nums) return -1;\\n        solve(nums);\\n        string s=\"\";\\n        for(int i=0; i<str.length(); i++)\\n        {\\n            char c = \\'0\\' + nums[i];\\n            s += c;\\n        }\\n        long d = stol(s);\\n        return (d > INT_MAX)? -1 : d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791541,
                "title": "java-easy-understanding-code-o-nlogn-time-complexity",
                "content": "\\tpublic int arrayToInt(int[] digits){\\n        String[] dig = Arrays.stream(digits)\\n                                .mapToObj(String::valueOf)\\n                                .toArray(String[]::new);\\n        String res = \"\";\\n        for(String a: dig)\\n            res += a;\\n         long tmp = Long.parseLong(res);\\n         if(tmp <= Integer.MAX_VALUE && tmp > (Integer.MIN_VALUE + 1))\\n             return (int)tmp;\\n         else\\n             return -1;\\n    }\\n    public void swap(int[] digits, int i, int j){\\n        int t = digits[j];\\n        digits[j] = digits[i];\\n        digits[i] = t;\\n    }\\n    public int nextGreaterElement(int n) {\\n        // System.out.println(Integer.MIN_VALUE);\\n        if(n >= Integer.MAX_VALUE)\\n            return -1;\\n        int[] digits = Integer.toString(n).chars().map(c -> c-\\'0\\').toArray();\\n        int s = digits.length;\\n        int i;\\n        for(i = s-1; i > 0; i--)\\n            if(digits[i] > digits[i-1])\\n                break;\\n        \\n        if(i != 0){\\n            int x = digits[i-1], min = i;\\n            for(int j=i+1; j<s; j++){\\n                if(digits[j] > x && digits[j] < digits[min])\\n                    min = j;\\n            }\\n            \\n            swap(digits, i-1, min);\\n            Arrays.sort(digits, i, s);\\n            return arrayToInt(digits);\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int arrayToInt(int[] digits){\\n        String[] dig = Arrays.stream(digits)\\n                                .mapToObj(String::valueOf)\\n                                .toArray(String[]::new);\\n        String res = \"\";\\n        for(String a: dig)\\n            res += a;\\n         long tmp = Long.parseLong(res);\\n         if(tmp <= Integer.MAX_VALUE && tmp > (Integer.MIN_VALUE + 1))\\n             return (int)tmp;\\n         else\\n             return -1;\\n    }\\n    public void swap(int[] digits, int i, int j){\\n        int t = digits[j];\\n        digits[j] = digits[i];\\n        digits[i] = t;\\n    }\\n    public int nextGreaterElement(int n) {\\n        // System.out.println(Integer.MIN_VALUE);\\n        if(n >= Integer.MAX_VALUE)\\n            return -1;\\n        int[] digits = Integer.toString(n).chars().map(c -> c-\\'0\\').toArray();\\n        int s = digits.length;\\n        int i;\\n        for(i = s-1; i > 0; i--)\\n            if(digits[i] > digits[i-1])\\n                break;\\n        \\n        if(i != 0){\\n            int x = digits[i-1], min = i;\\n            for(int j=i+1; j<s; j++){\\n                if(digits[j] > x && digits[j] < digits[min])\\n                    min = j;\\n            }\\n            \\n            swap(digits, i-1, min);\\n            Arrays.sort(digits, i, s);\\n            return arrayToInt(digits);\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1766029,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    private void swap(char[] chars, int i, int j){\\n        char ch = chars[i];\\n        chars[i] = chars[j];\\n        chars[j] = ch;\\n    }\\n    \\n    private void reverse(char [] chars, int i, int j){\\n        while( i < j) {\\n            swap(chars, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public int nextGreaterElement(int n) {\\n        if(n <= 10)\\n            return -1;\\n        String str = \"\" + n;\\n        char [] chars = str.toCharArray();\\n        int j = chars.length-2;\\n        while(j >= 0 && chars[j]-\\'0\\' >= chars[j+1]-\\'0\\'){\\n            j--;\\n        }\\n        if(j >= 0){\\n            int i = chars.length-1;\\n            while(i >= 0 && chars[j]-\\'0\\' >= chars[i]-\\'0\\'){\\n                i--;\\n            }\\n            swap(chars, j, i);\\n            reverse(chars, j+1, chars.length-1);\\n            long val = Long.parseLong(new String(chars));\\n        return val > Integer.MAX_VALUE ? -1 : new Long(val).intValue();\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private void swap(char[] chars, int i, int j){\\n        char ch = chars[i];\\n        chars[i] = chars[j];\\n        chars[j] = ch;\\n    }\\n    \\n    private void reverse(char [] chars, int i, int j){\\n        while( i < j) {\\n            swap(chars, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public int nextGreaterElement(int n) {\\n        if(n <= 10)\\n            return -1;\\n        String str = \"\" + n;\\n        char [] chars = str.toCharArray();\\n        int j = chars.length-2;\\n        while(j >= 0 && chars[j]-\\'0\\' >= chars[j+1]-\\'0\\'){\\n            j--;\\n        }\\n        if(j >= 0){\\n            int i = chars.length-1;\\n            while(i >= 0 && chars[j]-\\'0\\' >= chars[i]-\\'0\\'){\\n                i--;\\n            }\\n            swap(chars, j, i);\\n            reverse(chars, j+1, chars.length-1);\\n            long val = Long.parseLong(new String(chars));\\n        return val > Integer.MAX_VALUE ? -1 : new Long(val).intValue();\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764939,
                "title": "c-100-faster-and-beats-93-97-memory-usage",
                "content": "class Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int k=n%10;\\n        string a=to_string(n);\\n        int s=-1;\\n        stack<pair<int,int>> st;\\n        for(int i=a.size()-1;i>=0;i--){\\n            while(!st.empty()&&a[i]-\\'0\\'<st.top().first){\\n                s=st.top().second;\\n                st.pop();\\n            }\\n            if(s!=-1){ \\n                string k=a.substr(i+1,s-i-1)+a[i]+a.substr(s+1);\\n                reverse(k.begin(),k.end());\\n                string ans=a.substr(0,i)+a[s]+k;\\n                if(ans.size()>=10 && ans>\"2147483647\")return -1;\\n                      return stoi(ans);}\\n            st.push({a[i]-\\'0\\',i});\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int k=n%10;\\n        string a=to_string(n);\\n        int s=-1;\\n        stack<pair<int,int>> st;\\n        for(int i=a.size()-1;i>=0;i--){\\n            while(!st.empty()&&a[i]-\\'0\\'<st.top().first){\\n                s=st.top().second;\\n                st.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1750623,
                "title": "c-simple-solution-find-swaping-point-closer-to-end-of-string",
                "content": "class Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        \\n        string s(to_string(n));\\n        bool swp = false;\\n        int mi =  -1, mj = -1;\\n        for(int i=s.length()-1;  i>0; i--)\\n        {\\n            char c = s[i];\\n            for(int j = i-1; j>=0; j--)\\n            {\\n                if(s[j] < c)\\n                {\\n                    if(mj<j)\\n                    {\\n                        mj = j; mi = i;\\n                    }\\n                    \\n                    swp= true;\\n                    \\n                }\\n            }\\n        }\\n        if(swp)\\n        {\\n            swap(s[mi], s[mj]);\\n            sort(s.begin()+mj+1, s.end());\\n        }\\n        \\n        long long ans = atoll(s.c_str());\\n        if(swp && ans> INT_MAX)\\n            return -1;\\n        return swp?atoi(s.c_str()):-1;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        \\n        string s(to_string(n));\\n        bool swp = false;\\n        int mi =  -1, mj = -1;\\n        for(int i=s.length()-1;  i>0; i--)\\n        {\\n            char c = s[i];\\n            for(int j = i-1; j>=0; j--)\\n            {\\n                if(s[j] < c)\\n                {\\n                    if(mj<j)\\n                    {\\n                        mj = j; mi = i;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1739513,
                "title": "c-solution-in-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string str;\\n        while(n){\\n            str.push_back(n%10+\\'0\\');\\n            n=n/10;\\n        }\\n        reverse(str.begin(),str.end());\\n        bool b=next_permutation(str.begin(),str.end());\\n        if(!b)\\n            return -1;\\n        long long num=0;\\n        for(int i=0;i<str.size();i++)\\n            num=num*10+(str[i]-\\'0\\');\\n        if(num>INT_MAX)\\n            return -1;\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        string str;\\n        while(n){\\n            str.push_back(n%10+\\'0\\');\\n            n=n/10;\\n        }\\n        reverse(str.begin(),str.end());\\n        bool b=next_permutation(str.begin(),str.end());\\n        if(!b)\\n            return -1;\\n        long long num=0;\\n        for(int i=0;i<str.size();i++)\\n            num=num*10+(str[i]-\\'0\\');\\n        if(num>INT_MAX)\\n            return -1;\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727802,
                "title": "next-permutation-implementation",
                "content": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = [int(c) for c in str(n)]\\n        k = len(digits)\\n        i = k - 1\\n        while i > 0:\\n            if digits[i - 1] < digits[i]:\\n                break\\n            i -= 1\\n        if i == 0:\\n            return -1\\n        closest = i\\n        for j in range(i, k):\\n            if digits[j] > digits[i - 1] and digits[j] - digits[i - 1] <= digits[closest] - digits[i - 1]:\\n                closest = j\\n        digits[i - 1], digits[closest] = digits[closest], digits[i - 1]\\n        digits = digits[:i] + digits[i:][::-1]\\n        op = 0\\n        for d in digits:\\n            op = 10 * op + d\\n        return op if op <= ((1 << 31) - 1) else -1\\n```\\n\\n![image](https://user-images.githubusercontent.com/17960677/151648780-35afaece-bfcc-4785-8a0e-d92d4771723e.png)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextGreaterElement(self, n: int) -> int:\\n        digits = [int(c) for c in str(n)]\\n        k = len(digits)\\n        i = k - 1\\n        while i > 0:\\n            if digits[i - 1] < digits[i]:\\n                break\\n            i -= 1\\n        if i == 0:\\n            return -1\\n        closest = i\\n        for j in range(i, k):\\n            if digits[j] > digits[i - 1] and digits[j] - digits[i - 1] <= digits[closest] - digits[i - 1]:\\n                closest = j\\n        digits[i - 1], digits[closest] = digits[closest], digits[i - 1]\\n        digits = digits[:i] + digits[i:][::-1]\\n        op = 0\\n        for d in digits:\\n            op = 10 * op + d\\n        return op if op <= ((1 << 31) - 1) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719379,
                "title": "100-faster-solution-c-solution-next-greater-element",
                "content": "class Solution {\\npublic:\\n    \\n   \\n    \\n    int nextGreaterElement(int n) {\\n        \\n        vector<int>nums;\\n        \\n        while(n!=0){\\n            int digit=n%10;\\n            nums.push_back(digit);\\n            n=n/10;\\n        }\\n     \\n        reverse(nums.begin(),nums.end());\\n        \\n        int m=nums.size();\\n        int i=m-2;\\n        while(i>=0){\\n            if(nums[i]<nums[i+1])\\n                break;\\n            i--;\\n        }\\n        \\n        reverse(nums.begin()+i+1,nums.end());\\n        \\n        if(i<0) return -1;;\\n        \\n        int j=i+1;\\n        while(nums[j]<=nums[i]){\\n            j++;\\n        }\\n        swap(nums[i],nums[j]);\\n    \\n        long long int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n          sum=sum*10+nums[i];\\n      }\\n        if(sum<-2147483648 || sum> 2147483647){\\n            return -1;\\n        }\\n        else{\\n            \\n            return sum; \\n        \\n        }\\n        return 0;\\n       \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n   \\n    \\n    int nextGreaterElement(int n) {\\n        \\n        vector<int>nums;\\n        \\n        while(n!=0){\\n            int digit=n%10;\\n            nums.push_back(digit);\\n            n=n/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1718773,
                "title": "next-greater-element-in-java-fully-explained-in-6-steps",
                "content": "6 steps code \\nstep 1 : change number into charArray\\n```\\n        char arr[] = String.valueOf(n).toCharArray();\\n```\\nstep 2: find the element that has a greater element to its right (elemtent from end)\\n```\\n        char arr[] = String.valueOf(n).toCharArray();\\n        int l = arr.length;\\n        int i = l-2,j=l-1;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        if(i<0)\\n            return -1;\\n\\n```\\nstep 3 : now find the element that is next greater then above element\\n```\\n        while(j>=0 && arr[j]<=arr[i])\\n            j--;\\n```\\nstep 4: swap the two elements\\n```\\n            swap(arr,i,j);\\n```\\nstep 5: reverse the rest elements from i+1 position\\n```\\n        int left = i+1,right=l-1;\\n        while(left<right)\\n            swap(arr,left++,right--);\\n\\n```\\nstep 6 check for end condition for 32 bit integer\\n```  \\n       long val = Long.valueOf(String.valueOf(arr));\\n        return val <= Integer.MAX_VALUE ? (int) val : -1;\\n```\\nfinal code :\\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char arr[] = String.valueOf(n).toCharArray();\\n        int l = arr.length;\\n        int i = l-2,j=l-1;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        if(i<0)\\n            return -1;\\n        while(j>=0 && arr[j]<=arr[i])\\n            j--;\\n        if(i>=0)\\n            swap(arr,i,j);\\n        int left = i+1,right=l-1;\\n        while(left<right)\\n            swap(arr,left++,right--);\\n        \\n       long val = Long.valueOf(String.valueOf(arr));\\n        return val <= Integer.MAX_VALUE ? (int) val : -1; \\n    }\\n    private void swap(char[] array, int i, int j) {\\n        char tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        char arr[] = String.valueOf(n).toCharArray();\\n```\n```\\n        char arr[] = String.valueOf(n).toCharArray();\\n        int l = arr.length;\\n        int i = l-2,j=l-1;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        if(i<0)\\n            return -1;\\n\\n```\n```\\n        while(j>=0 && arr[j]<=arr[i])\\n            j--;\\n```\n```\\n            swap(arr,i,j);\\n```\n```\\n        int left = i+1,right=l-1;\\n        while(left<right)\\n            swap(arr,left++,right--);\\n\\n```\n```  \\n       long val = Long.valueOf(String.valueOf(arr));\\n        return val <= Integer.MAX_VALUE ? (int) val : -1;\\n```\n```\\nclass Solution {\\n    public int nextGreaterElement(int n) {\\n        char arr[] = String.valueOf(n).toCharArray();\\n        int l = arr.length;\\n        int i = l-2,j=l-1;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        if(i<0)\\n            return -1;\\n        while(j>=0 && arr[j]<=arr[i])\\n            j--;\\n        if(i>=0)\\n            swap(arr,i,j);\\n        int left = i+1,right=l-1;\\n        while(left<right)\\n            swap(arr,left++,right--);\\n        \\n       long val = Long.valueOf(String.valueOf(arr));\\n        return val <= Integer.MAX_VALUE ? (int) val : -1; \\n    }\\n    private void swap(char[] array, int i, int j) {\\n        char tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710928,
                "title": "c-0ms-using-vector-detailed-comments",
                "content": "```\\nint nextGreaterElement(int n)\\n{\\n\\t// E.g. n = 135432\\n\\t//       -> 142335\\n\\n\\t//-------------------------\\n\\t// 1. Turn into array of digits (but we get them in reversed order)\\n\\t//        135432\\n\\t// -> [2,3,4,5,3,1]\\n\\n\\tvector<int> digits = {};\\n\\n\\twhile (n > 0)\\n\\t{\\n\\t\\tdigits.push_back(n % 10);\\n\\t\\tn /= 10;\\n\\t}\\n\\n\\t/*cout << \"Input as digits (reversed order):\" <<endl;\\n\\tfor (auto d : digits)\\n\\t\\tcout << d;\\n\\tcout << endl;*/\\n\\t//-------------------------\\n\\n\\n\\t//-------------------------\\n\\t// 2. Find index of the element that is lesser than previous one. That digits we need to increase to get output greater than input\\n\\t//    [2,3,4,5,3,1]\\n\\t// -> [2,3,4,5,3*,1]\\n\\n\\tint index = -1;\\n\\tfor (int i = 0; i < digits.size() - 1; ++i)\\n\\t{\\n\\t\\tif (digits[i] > digits[i+1])\\n\\t\\t{\\n\\t\\t\\tindex = i+1;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// If digits are already in the sorted order and last one is already the greates - there is no way for us to get output greater than input\\n\\tif (index == -1)\\n\\t\\treturn -1;\\n\\n\\t//cout << \"Index of the digit to swap on some greater one: \" << index << endl;\\n\\t//-------------------------\\n\\n\\n\\t//-------------------------\\n\\t// 3. Sort the digits before the index so that after reversing digits back into number we would get the lowest possible number\\n\\t//    [2,3,4,5,3*,1]\\n\\t// -> [5,4,3,2,3*,1]\\n\\n\\tsort(digits.begin(), digits.begin() + index, greater<int>());\\n\\n\\t/*cout << \"Partiallay sorted:\" <<endl;\\n\\tfor (auto d : digits)\\n\\t\\tcout << d;\\n\\tcout << endl;*/\\n\\t//-------------------------\\n\\n\\n\\t//-------------------------\\n\\t// 4. Swap Index digit with the one that is greater, but still lowest among those that are greater than current\\n\\t//    [5,4,3,2,3*,1]\\n\\t// -> [5,3,3,2,4*,1]\\n\\n\\tfor (int i = index - 1; i >= 0; --i)\\n\\t{\\n\\t\\tif (digits[i] > digits[index])\\n\\t\\t{\\n\\t\\t\\tswap(digits[i], digits[index]);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t/*cout << \"After swapping digits:\" <<endl;\\n\\tfor (auto d : digits)\\n\\t\\tcout << d;\\n\\tcout << endl;*/\\n\\t//-------------------------\\n\\n\\t//-------------------------\\n\\t// 5. Turn back into number\\n\\t//    [5,3,3,2,4*,1]\\n\\t// ->     142335\\n\\tlong int result = 0;\\n\\n\\tfor (int i = digits.size() - 1; i >= 0; --i)\\n\\t\\tresult = result*10 + digits[i];\\n\\t//-------------------------\\n\\n\\t//-------------------------\\n\\t// 6. Check if result is within 32-bit range\\n\\tif (result > numeric_limits<int>::max())\\n\\t\\treturn -1;\\n\\n\\treturn (int)result;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint nextGreaterElement(int n)\\n{\\n\\t// E.g. n = 135432\\n\\t//       -> 142335\\n\\n\\t//-------------------------\\n\\t// 1. Turn into array of digits (but we get them in reversed order)\\n\\t//        135432\\n\\t// -> [2,3,4,5,3,1]\\n\\n\\tvector<int> digits = {};\\n\\n\\twhile (n > 0)\\n\\t{\\n\\t\\tdigits.push_back(n % 10);\\n\\t\\tn /= 10;\\n\\t}\\n\\n\\t/*cout << \"Input as digits (reversed order):\" <<endl;\\n\\tfor (auto d : digits)\\n\\t\\tcout << d;\\n\\tcout << endl;*/\\n\\t//-------------------------\\n\\n\\n\\t//-------------------------\\n\\t// 2. Find index of the element that is lesser than previous one. That digits we need to increase to get output greater than input\\n\\t//    [2,3,4,5,3,1]\\n\\t// -> [2,3,4,5,3*,1]\\n\\n\\tint index = -1;\\n\\tfor (int i = 0; i < digits.size() - 1; ++i)\\n\\t{\\n\\t\\tif (digits[i] > digits[i+1])\\n\\t\\t{\\n\\t\\t\\tindex = i+1;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// If digits are already in the sorted order and last one is already the greates - there is no way for us to get output greater than input\\n\\tif (index == -1)\\n\\t\\treturn -1;\\n\\n\\t//cout << \"Index of the digit to swap on some greater one: \" << index << endl;\\n\\t//-------------------------\\n\\n\\n\\t//-------------------------\\n\\t// 3. Sort the digits before the index so that after reversing digits back into number we would get the lowest possible number\\n\\t//    [2,3,4,5,3*,1]\\n\\t// -> [5,4,3,2,3*,1]\\n\\n\\tsort(digits.begin(), digits.begin() + index, greater<int>());\\n\\n\\t/*cout << \"Partiallay sorted:\" <<endl;\\n\\tfor (auto d : digits)\\n\\t\\tcout << d;\\n\\tcout << endl;*/\\n\\t//-------------------------\\n\\n\\n\\t//-------------------------\\n\\t// 4. Swap Index digit with the one that is greater, but still lowest among those that are greater than current\\n\\t//    [5,4,3,2,3*,1]\\n\\t// -> [5,3,3,2,4*,1]\\n\\n\\tfor (int i = index - 1; i >= 0; --i)\\n\\t{\\n\\t\\tif (digits[i] > digits[index])\\n\\t\\t{\\n\\t\\t\\tswap(digits[i], digits[index]);\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t/*cout << \"After swapping digits:\" <<endl;\\n\\tfor (auto d : digits)\\n\\t\\tcout << d;\\n\\tcout << endl;*/\\n\\t//-------------------------\\n\\n\\t//-------------------------\\n\\t// 5. Turn back into number\\n\\t//    [5,3,3,2,4*,1]\\n\\t// ->     142335\\n\\tlong int result = 0;\\n\\n\\tfor (int i = digits.size() - 1; i >= 0; --i)\\n\\t\\tresult = result*10 + digits[i];\\n\\t//-------------------------\\n\\n\\t//-------------------------\\n\\t// 6. Check if result is within 32-bit range\\n\\tif (result > numeric_limits<int>::max())\\n\\t\\treturn -1;\\n\\n\\treturn (int)result;\\n}",
                "codeTag": "C++"
            },
            {
                "id": 1704338,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-next-permutation-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int temp=n;\\n        vector<int> nums;\\n        while (temp){\\n            nums.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        reverse(nums.begin(),nums.end());\\n        temp=nums.size();\\n        int k,m;\\n        for (k=temp-2;k>=0;k--){\\n            if (nums[k]<nums[k+1]) break;\\n        }\\n        if (k<0) return -1;\\n        else{\\n            for (m=temp-1;m>k;m--){\\n                if (nums[m]>nums[k]) break;\\n            }\\n            swap(nums[m],nums[k]);\\n            reverse(nums.begin()+k+1,nums.end());\\n        }\\n        long long int res=0;\\n        for (int i=0;i<temp;i++){\\n            res=res*10+nums[i];\\n        }\\n        if (res>INT_MAX) return -1;\\n        return res;\\n    }\\n};\\n```\\n\\nPS: If you found out this solution to be useful then please do \"UPVOTE\" :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextGreaterElement(int n) {\\n        int temp=n;\\n        vector<int> nums;\\n        while (temp){\\n            nums.push_back(temp%10);\\n            temp=temp/10;\\n        }\\n        reverse(nums.begin(),nums.end());\\n        temp=nums.size();\\n        int k,m;\\n        for (k=temp-2;k>=0;k--){\\n            if (nums[k]<nums[k+1]) break;\\n        }\\n        if (k<0) return -1;\\n        else{\\n            for (m=temp-1;m>k;m--){\\n                if (nums[m]>nums[k]) break;\\n            }\\n            swap(nums[m],nums[k]);\\n            reverse(nums.begin()+k+1,nums.end());\\n        }\\n        long long int res=0;\\n        for (int i=0;i<temp;i++){\\n            res=res*10+nums[i];\\n        }\\n        if (res>INT_MAX) return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564764,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1789070,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1721590,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1569431,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1920502,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1574122,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1915398,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1574166,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1576226,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1950766,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1564764,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1789070,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1721590,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1569431,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1920502,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1574122,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1915398,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1574166,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1576226,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            },
            {
                "id": 1950766,
                "content": [
                    {
                        "username": "Nakanu",
                        "content": "Here is one simple example.\\nindex:  012345\\ngiven:  124651\\nans :      125146\\nprocedure:\\nStarting from the rightmost digit, going to left. Find the first digit which is smaller than the previous digit. \\nIn this example, 4 is smaller than 6.  Remember 4 and its index 2. \\nGoing from rightmost again. This time, find the first digit which is bigger than 4. It is 5 here.\\nSwap 4 and 5. The number becomes 125641.\\nReverse all the digits which are right to 4's original index (That is 2), 641 should be reversed to 146 here.  \\nAnd the answer is reached which is 125146."
                    },
                    {
                        "username": "asharaf007",
                        "content": "how did you get the intuition behind it?"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thanks! I coded out your instructions and it ran really well. Some additional help for others: If you cannot find the smaller num index or the larger num index, return -1. If you can, and you do the whole swap and reverse process, then use long.Parse() to check if the result is greater than int.MaxValue. If yes, return -1. If no, return the result as an integer."
                    },
                    {
                        "username": "meanup",
                        "content": "The above comment is an excellent `Hint` for solving the problem.\\n`Helpful`"
                    },
                    {
                        "username": "Gourav_Sinha",
                        "content": "can someone explain the logic?\\n"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "An example of bigger number should be added so one could get a direction or intuition."
                    },
                    {
                        "username": "r_y_s",
                        "content": "This problem is same as next permutation with two additional conditions.\\n1) if current number is greatest number possible with given digits return -1\\n2) if next  permutation exceeds Integer limit return -1\\nThats it :) "
                    },
                    {
                        "username": "shivam2612002",
                        "content": "yes... exactly ."
                    },
                    {
                        "username": "guestly",
                        "content": "The correct answer is `9199999999` but interpreter was `-1`"
                    },
                    {
                        "username": "girishgupta211",
                        "content": "This is because it cross 32 bit size "
                    },
                    {
                        "username": "cvddl",
                        "content": "The question of  [31. Next Permutation](https://leetcode.com/problems/next-permutation/) will help to solve it"
                    },
                    {
                        "username": "richoncode",
                        "content": "Noticed in submission failing this test case.  signed-int allows 31 bits for positive integers.  in Python, int has no concept of losing a bit for sign so full 32 bits is reasonable to expect.  \\n\\nn= 2147483647 31 bits 1111111111111111111111111111111\\no= 2147483674 output 32 bits 10000000000000000000000000011010  failed test case\\ne= -1  expected\\n4294967296\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "next permutation"
                    },
                    {
                        "username": "rexhu100",
                        "content": "The previous 2 \"Next greater element\" problem are both stack related, so is this one. All 3 should have \"stack\" tag."
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n\\n![image](https://assets.leetcode.com/users/images/d366cec7-aef4-48f8-b557-b348b9db4417_1642095365.2523768.png)\\n\\n![image](https://assets.leetcode.com/users/images/e0d59425-e1ae-4190-ac89-ce114a27aad7_1642095372.1078918.png)\\n\\n![image](https://assets.leetcode.com/users/images/587cd70a-a0f7-4619-b513-efa52484dc1b_1642095379.6188931.png)\\n"
                    },
                    {
                        "username": "java_run",
                        "content": "Quite a tricky question .\nHINT : \n             1) Split the number into array .\n             2) The original and after converting the array (i.e -> next permutation) should fit in 32 Bit \n             3) Similar to the question --->  31) Next Permutation \n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Robot Return to Origin",
        "question_content": "<p>There is a robot starting at the position <code>(0, 0)</code>, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot <strong>ends up at </strong><code>(0, 0)</code> after it completes its moves.</p>\n\n<p>You are given a string <code>moves</code> that represents the move sequence of the robot where <code>moves[i]</code> represents its <code>i<sup>th</sup></code> move. Valid moves are <code>&#39;R&#39;</code> (right), <code>&#39;L&#39;</code> (left), <code>&#39;U&#39;</code> (up), and <code>&#39;D&#39;</code> (down).</p>\n\n<p>Return <code>true</code><em> if the robot returns to the origin after it finishes all of its moves, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p><strong>Note</strong>: The way that the robot is &quot;facing&quot; is irrelevant. <code>&#39;R&#39;</code> will always make the robot move to the right once, <code>&#39;L&#39;</code> will always make it move left, etc. Also, assume that the magnitude of the robot&#39;s movement is the same for each move.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> moves = &quot;UD&quot;\n<strong>Output:</strong> true\n<strong>Explanation</strong>: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> moves = &quot;LL&quot;\n<strong>Output:</strong> false\n<strong>Explanation</strong>: The robot moves left twice. It ends up two &quot;moves&quot; to the left of the origin. We return false because it is not at the origin at the end of its moves.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>moves</code> only contains the characters <code>&#39;U&#39;</code>, <code>&#39;D&#39;</code>, <code>&#39;L&#39;</code> and <code>&#39;R&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 106315,
                "title": "python-one-liner",
                "content": "```\\ndef judgeCircle(self, moves):\\n    return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')\\n```",
                "solutionTags": [],
                "code": "```\\ndef judgeCircle(self, moves):\\n    return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106316,
                "title": "c-java-clean-code",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int v = 0;\\n        int h = 0;\\n        for (char ch : moves) {\\n            switch (ch) {\\n                case 'U' : v++; break;\\n                case 'D' : v--; break;\\n                case 'R' : h++; break;\\n                case 'L' : h--; break;\\n            }\\n        }\\n        return v == 0 && h == 0;\\n    }\\n};\\n```\\n**Java**\\n```\\npublic class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0;\\n        int y = 0;\\n        for (char ch : moves.toCharArray()) {\\n            if (ch == 'U') y++;\\n            else if (ch == 'D') y--;\\n            else if (ch == 'R') x++;\\n            else if (ch == 'L') x--;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int v = 0;\\n        int h = 0;\\n        for (char ch : moves) {\\n            switch (ch) {\\n                case 'U' : v++; break;\\n                case 'D' : v--; break;\\n                case 'R' : h++; break;\\n                case 'L' : h--; break;\\n            }\\n        }\\n        return v == 0 && h == 0;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0;\\n        int y = 0;\\n        for (char ch : moves.toCharArray()) {\\n            if (ch == 'U') y++;\\n            else if (ch == 'D') y--;\\n            else if (ch == 'R') x++;\\n            else if (ch == 'L') x--;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106393,
                "title": "2-lines-python",
                "content": "    def judgeCircle(self, moves):\\n        c = collections.Counter(moves)\\n        return c['L'] == c['R'] and c['U'] == c['D']",
                "solutionTags": [],
                "code": "    def judgeCircle(self, moves):\\n        c = collections.Counter(moves)\\n        return c['L'] == c['R'] and c['U'] == c['D']",
                "codeTag": "Python3"
            },
            {
                "id": 106368,
                "title": "very-short-python-and-ruby",
                "content": "Python:\\n\\n    def judgeCircle(self, moves):\\n        return not sum(1j**'RUL'.find(m) for m in moves)\\n\\nRuby:\\n```\\ndef judge_circle(moves)\\n  moves.chars.map { |m| 1i**\"RULD\".index(m) }.sum == 0\\nend\\n```\\n\\nHad posted the Python version before as a [reply](https://discuss.leetcode.com/post/208187) to @waigx.",
                "solutionTags": [],
                "code": "```\\ndef judge_circle(moves)\\n  moves.chars.map { |m| 1i**\"RULD\".index(m) }.sum == 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106358,
                "title": "c-counter-4-lines-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char, int> c;\\n        for ( char m : moves )\\n            ++c[m];\\n        return c['L'] == c['R'] && c['U'] == c['D'];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char, int> c;\\n        for ( char m : moves )\\n            ++c[m];\\n        return c['L'] == c['R'] && c['U'] == c['D'];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150079,
                "title": "c-100-fast-short-and-concise-code",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int x=0;\\n        int y=0;\\n        \\n        for(int i=0;i<moves.size();i++){\\n            if(moves[i]==\\'U\\')x++;\\n            if(moves[i]==\\'D\\')x--;\\n            if(moves[i]==\\'R\\')y++;\\n            if(moves[i]==\\'L\\')y--;\\n        }\\n        \\n        return (x==0 && y==0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int x=0;\\n        int y=0;\\n        \\n        for(int i=0;i<moves.size();i++){\\n            if(moves[i]==\\'U\\')x++;\\n            if(moves[i]==\\'D\\')x--;\\n            if(moves[i]==\\'R\\')y++;\\n            if(moves[i]==\\'L\\')y--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 835933,
                "title": "bug-in-test-cases-case-with-10000-characters",
                "content": "The last test case with 10000 characters\\' result is not correct. I counted all the characters as below\\nand for it to be true, \"U\" =  \"D\" and \"L\" = \"R\" but the based on the count the correct answer\\nshould be False but the expected ouput is True.\\nBelow is the count:\\n```Counter({\\'D\\': 2513, \\'U\\': 2502, \\'R\\': 2507, \\'L\\': 2478})```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Counter({\\'D\\': 2513, \\'U\\': 2502, \\'R\\': 2507, \\'L\\': 2478})```",
                "codeTag": "Unknown"
            },
            {
                "id": 342078,
                "title": "solution-in-python-3-beats-99-one-line",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'L\\') == moves.count(\\'R\\') and moves.count(\\'U\\') == moves.count(\\'D\\')\\n\\n\\n- Python 3\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'L\\') == moves.count(\\'R\\') and moves.count(\\'U\\') == moves.count(\\'D\\')\\n\\n\\n- Python 3\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 394373,
                "title": "c-no-branching",
                "content": "Here\\'s a version of the solution that takes advantage of the fact that the move codes mod 5 are unique and consecutive to avoid branching. A switch/if requires 3 compares at least 25% of the time, assuming all four directions are used. \\n\\nFrom a performance standpoint it made no difference but it got the line count down so there\\'s that.\\n\\n```\\nbool judgeCircle(string moves) {\\n        //ASCII values % 5:\\n        //U: 85%5=0\\n        //D: 68%5=3\\n        //L: 76%5=1\\n        //R: 82%5=2\\n        \\n        int count[4]={0,0,0,0};\\n\\t\\tfor (auto i:moves){\\n            ++count[i%5];\\n        }\\n        \\n        //U==D, L==R\\n        return count[0]==count[3] && count[1]==count[2];\\n};\\n```\\n\\nThis ran consistently faster than 99% of C++ implementations (probably what the compiler is doing anyway):\\n```\\n    bool judgeCircle(string moves) {\\n        //ASCII values % 5:\\n        //U: 85%5=0\\n        //D: 68%5=3\\n        //L: 76%5=1\\n        //R: 82%5=2\\n        \\n        int i=0, stride=8;\\n        int count[4]={0,0,0,0};\\n        for (;i+stride<moves.length();i+=stride){\\n            ++count[moves[i]%5];\\n            ++count[moves[i+1]%5];\\n            ++count[moves[i+2]%5];\\n            ++count[moves[i+3]%5];\\n            ++count[moves[i+4]%5];\\n            ++count[moves[i+5]%5];\\n            ++count[moves[i+6]%5];\\n            ++count[moves[i+7]%5];\\n        }\\n        \\n        for (;i<moves.length();++i){\\n            ++count[moves[i]%5];\\n        }\\n        \\n        //U==D, L==R\\n        return count[0]==count[3] && count[1]==count[2];\\n    }\\n```\\n\\nAnd *faster than 100%*:\\n\\n```\\nint _=[](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return 0;\\n\\t}();\\n\\nclass Solution {\\npublic:\\n        bool judgeCircle(string moves) {\\n        int count[4]={0,0,0,0};\\n        for (auto i:moves){\\n            ++count[i%5];\\n        }\\n        \\n        //U==D, L==R\\n        return count[0]==count[3] && count[1]==count[2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool judgeCircle(string moves) {\\n        //ASCII values % 5:\\n        //U: 85%5=0\\n        //D: 68%5=3\\n        //L: 76%5=1\\n        //R: 82%5=2\\n        \\n        int count[4]={0,0,0,0};\\n\\t\\tfor (auto i:moves){\\n            ++count[i%5];\\n        }\\n        \\n        //U==D, L==R\\n        return count[0]==count[3] && count[1]==count[2];\\n};\\n```\n```\\n    bool judgeCircle(string moves) {\\n        //ASCII values % 5:\\n        //U: 85%5=0\\n        //D: 68%5=3\\n        //L: 76%5=1\\n        //R: 82%5=2\\n        \\n        int i=0, stride=8;\\n        int count[4]={0,0,0,0};\\n        for (;i+stride<moves.length();i+=stride){\\n            ++count[moves[i]%5];\\n            ++count[moves[i+1]%5];\\n            ++count[moves[i+2]%5];\\n            ++count[moves[i+3]%5];\\n            ++count[moves[i+4]%5];\\n            ++count[moves[i+5]%5];\\n            ++count[moves[i+6]%5];\\n            ++count[moves[i+7]%5];\\n        }\\n        \\n        for (;i<moves.length();++i){\\n            ++count[moves[i]%5];\\n        }\\n        \\n        //U==D, L==R\\n        return count[0]==count[3] && count[1]==count[2];\\n    }\\n```\n```\\nint _=[](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    cout.tie(NULL);\\n    return 0;\\n\\t}();\\n\\nclass Solution {\\npublic:\\n        bool judgeCircle(string moves) {\\n        int count[4]={0,0,0,0};\\n        for (auto i:moves){\\n            ++count[i%5];\\n        }\\n        \\n        //U==D, L==R\\n        return count[0]==count[3] && count[1]==count[2];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 174491,
                "title": "javascript-100-using-o-n-time-o-1-space",
                "content": "***Time:   O(n)\\nSpace: O(1)***\\n\\n```\\nvar judgeCircle = function(moves) {\\n    let x = 0, y = 0;\\n    for (let move of moves) {\\n        switch(move) {\\n            case \\'U\\': y++ ;break;\\n            case \\'D\\': y-- ;break;\\n            case \\'L\\': x-- ;break;\\n            case \\'R\\': x++ ;break;\\n        }\\n    }\\n    return x === 0 && y === 0\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar judgeCircle = function(moves) {\\n    let x = 0, y = 0;\\n    for (let move of moves) {\\n        switch(move) {\\n            case \\'U\\': y++ ;break;\\n            case \\'D\\': y-- ;break;\\n            case \\'L\\': x-- ;break;\\n            case \\'R\\': x++ ;break;\\n        }\\n    }\\n    return x === 0 && y === 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 285242,
                "title": "javascript-100-100",
                "content": "```\\nvar judgeCircle = function(moves) {    \\n    let x=0,y=0\\n    for(i=0;i<moves.length;i++){\\n        switch (moves[i]) {\\n            case \\'R\\':\\n                x++;\\n                break;\\n            case \\'L\\':\\n                x--;\\n                break;\\n            case \\'U\\':\\n                y++;\\n                break;\\n            case \\'D\\':\\n                y--;\\n                break;\\n        }\\n    }\\n     return x === 0 && y === 0\\n\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar judgeCircle = function(moves) {    \\n    let x=0,y=0\\n    for(i=0;i<moves.length;i++){\\n        switch (moves[i]) {\\n            case \\'R\\':\\n                x++;\\n                break;\\n            case \\'L\\':\\n                x--;\\n                break;\\n            case \\'U\\':\\n                y++;\\n                break;\\n            case \\'D\\':\\n                y--;\\n                break;\\n        }\\n    }\\n     return x === 0 && y === 0\\n\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1433094,
                "title": "java-very-easy-solution-7-lines-of-clean-code-o-n",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n               \\n        int leftright = 0, updown = 0;\\n        for(int i = 0 ; i<moves.length() ; i++){\\n            if(moves.charAt(i) == \\'U\\')  updown++;\\n            else if(moves.charAt(i) == \\'D\\')  updown--;\\n            else if(moves.charAt(i) == \\'R\\')  leftright++;\\n            else if(moves.charAt(i) == \\'L\\')  leftright--;\\n        }\\n        return (updown == 0 && leftright == 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n               \\n        int leftright = 0, updown = 0;\\n        for(int i = 0 ; i<moves.length() ; i++){\\n            if(moves.charAt(i) == \\'U\\')  updown++;\\n            else if(moves.charAt(i) == \\'D\\')  updown--;\\n            else if(moves.charAt(i) == \\'R\\')  leftright++;\\n            else if(moves.charAt(i) == \\'L\\')  leftright--;\\n        }\\n        return (updown == 0 && leftright == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397917,
                "title": "easy-understandable-java-solution-faster-than-96-4",
                "content": "**Consider a graph and a user is at the center of the graph at (0,0).\\nWe know that if we move above the origin along Y-axis the value at Y-axis increases and if we move below the value along Y-axis decreases (X Remains the same) same applies for X-axis too if we move along left of the center the value of X decreases and if we go right the value of x increases so using that,**\\n\\n**if we go above origin then y++\\nif we go below origin then y--\\nif we go left side of origin x--\\nif we go right side of origin x++**\\n\\n\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for (char move : moves.toCharArray()) {\\n            if (move == \\'U\\') y++;\\n            if (move == \\'D\\') y--;\\n            if (move == \\'L\\') x--;\\n            if (move == \\'R\\') x++;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for (char move : moves.toCharArray()) {\\n            if (move == \\'U\\') y++;\\n            if (move == \\'D\\') y--;\\n            if (move == \\'L\\') x--;\\n            if (move == \\'R\\') x++;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960405,
                "title": "two-simple-java-solutions-runtime-1ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1 \\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int UpDown = 0;\\n        int LeftRight = 0;\\n\\n        for (char c : moves.toCharArray() )\\n        {\\n            if (c == \\'U\\')\\n                UpDown++;\\n            else if (c == \\'D\\')\\n                UpDown--;\\n            else if (c == \\'R\\')\\n                LeftRight++;\\n            else if (c == \\'L\\')\\n                LeftRight--;\\n        }\\n        return (LeftRight == 0 && UpDown == 0);\\n    }\\n}\\n```\\n\\n\\n# code 2\\n\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int UpDown = 0;\\n        int LeftRight = 0;\\n\\n        for (char c : moves.toCharArray() )\\n        {\\n            switch (c){\\n                case \\'U\\':\\n                    UpDown++;\\n                    break;\\n                case \\'D\\':\\n                    UpDown--;\\n                    break;\\n                case \\'L\\':\\n                    LeftRight++;\\n                    break;\\n                case \\'R\\':\\n                    LeftRight--;\\n                    break;\\n            }\\n        }\\n\\n\\n\\n        return (LeftRight == 0 && UpDown == 0); \\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/97cc6364-7c08-4bf8-bb01-95f43404d1ed_1693004471.5767741.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int UpDown = 0;\\n        int LeftRight = 0;\\n\\n        for (char c : moves.toCharArray() )\\n        {\\n            if (c == \\'U\\')\\n                UpDown++;\\n            else if (c == \\'D\\')\\n                UpDown--;\\n            else if (c == \\'R\\')\\n                LeftRight++;\\n            else if (c == \\'L\\')\\n                LeftRight--;\\n        }\\n        return (LeftRight == 0 && UpDown == 0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int UpDown = 0;\\n        int LeftRight = 0;\\n\\n        for (char c : moves.toCharArray() )\\n        {\\n            switch (c){\\n                case \\'U\\':\\n                    UpDown++;\\n                    break;\\n                case \\'D\\':\\n                    UpDown--;\\n                    break;\\n                case \\'L\\':\\n                    LeftRight++;\\n                    break;\\n                case \\'R\\':\\n                    LeftRight--;\\n                    break;\\n            }\\n        }\\n\\n\\n\\n        return (LeftRight == 0 && UpDown == 0); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106342,
                "title": "easy-2-lines-java",
                "content": "Easy solution using split.(It needs spaces from front and behind to be calculated correctly):\\n```\\n public boolean judgeCircle(String moves) {\\n        moves=\" \" + moves + \" \";\\n        return moves.split(\"L\").length==moves.split(\"R\").length && moves.split(\"U\").length == moves.split(\"D\").length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public boolean judgeCircle(String moves) {\\n        moves=\" \" + moves + \" \";\\n        return moves.split(\"L\").length==moves.split(\"R\").length && moves.split(\"U\").length == moves.split(\"D\").length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520046,
                "title": "simplest-approach-easily-understandable-python-and-java-solution",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        lr , ud = 0 , 0\\n\\n        for move in moves:\\n            if move == \\'U\\':\\n                ud += 1\\n            elif move == \\'D\\':\\n                ud -= 1\\n            elif move == \\'L\\':\\n                lr += 1\\n            elif move == \\'R\\':\\n                lr -= 1\\n\\n        if lr == 0 and ud == 0:\\n            return True\\n```\\n```Java []\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for (int i = 0; i < moves.length(); i++) {\\n            char move = moves.charAt(i);\\n            if (move == \\'U\\') y--;\\n            else if (move == \\'D\\') y++;\\n            else if (move == \\'L\\') x--;\\n            else if (move == \\'R\\') x++;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        lr , ud = 0 , 0\\n\\n        for move in moves:\\n            if move == \\'U\\':\\n                ud += 1\\n            elif move == \\'D\\':\\n                ud -= 1\\n            elif move == \\'L\\':\\n                lr += 1\\n            elif move == \\'R\\':\\n                lr -= 1\\n\\n        if lr == 0 and ud == 0:\\n            return True\\n```\n```Java []\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for (int i = 0; i < moves.length(); i++) {\\n            char move = moves.charAt(i);\\n            if (move == \\'U\\') y--;\\n            else if (move == \\'D\\') y++;\\n            else if (move == \\'L\\') x--;\\n            else if (move == \\'R\\') x++;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836579,
                "title": "wrong-testcases",
                "content": "cpp solution that should\\'ve been accepted\\n```cpp\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char, pair<int, int>> dir ({\\n            {\\'U\\', make_pair(0, -1)},\\n            {\\'D\\', make_pair(0, 1)},\\n            {\\'L\\', make_pair(-1, 0)},\\n            {\\'R\\', make_pair(1, 0)}\\n        });\\n\\n        int r = 0, c = 0;\\n\\n        for(int i = 0; i < moves.size(); ++i) {\\n            r += dir[moves[i]].first;\\n            c += dir[moves[i]].second;\\n        }\\n\\n        return (r == c && c == 0);\\n    }\\n};\\n```\\nWhen submitted the second last case fails\\n![image](https://assets.leetcode.com/users/images/20d17731-9f7a-4210-8f89-7c818f25d5d7_1599581170.3943565.png)\\n\\nWhile running as test case it is accepted, not using any static variables\\n![image](https://assets.leetcode.com/users/images/8e67c937-94e2-4cb9-80b1-be4553783639_1599581206.6773372.png)\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char, pair<int, int>> dir ({\\n            {\\'U\\', make_pair(0, -1)},\\n            {\\'D\\', make_pair(0, 1)},\\n            {\\'L\\', make_pair(-1, 0)},\\n            {\\'R\\', make_pair(1, 0)}\\n        });\\n\\n        int r = 0, c = 0;\\n\\n        for(int i = 0; i < moves.size(); ++i) {\\n            r += dir[moves[i]].first;\\n            c += dir[moves[i]].second;\\n        }\\n\\n        return (r == c && c == 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150811,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        pos = [0,0]\\n        for m in moves:\\n            if m == \\'U\\':\\n                pos[0] += 1\\n            elif m == \\'D\\':\\n                pos[0] -= 1\\n            elif m == \\'L\\':\\n                pos[1] -= 1\\n            elif m == \\'R\\':\\n                pos[1] += 1\\n        return pos == [0,0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        pos = [0,0]\\n        for m in moves:\\n            if m == \\'U\\':\\n                pos[0] += 1\\n            elif m == \\'D\\':\\n                pos[0] -= 1\\n            elif m == \\'L\\':\\n                pos[1] -= 1\\n            elif m == \\'R\\':\\n                pos[1] += 1\\n        return pos == [0,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539597,
                "title": "easy-to-understand-both-naive-and-faster-than-100-python-solution",
                "content": "**Simple Naive solution**\\n\\n```\\ndef naive(self, moves):\\n        pos = [0, 0]\\n        for i in moves:\\n            if i == \\'U\\':\\n                pos[1] += 1\\n            elif i ==\\'D\\':\\n                pos[1] -= 1\\n            elif i==\\'R\\':\\n                pos[0] += 1\\n            else:\\n                pos[0] -= 1\\n        return pos[0]==0 and pos[1]==0\\n        \\n```\\n\\t\\n\\t\\t\\n**Faster Solution**\\t\\t\\n\\t\\t\\n\\n```\\ndef faster(self,moves):\\n\\tu = moves.count(\\'U\\')\\n\\td = moves.count(\\'D\\')\\n\\tl = moves.count(\\'L\\')\\n\\tr = moves.count(\\'R\\')\\n\\treturn u - d == 0 and l-r == 0\\n```\\n\\n**I hope that you have found the above solutions useful**\\n*Please do upvote, it only motivates me to write more such posts\\uD83D\\uDE03*\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef naive(self, moves):\\n        pos = [0, 0]\\n        for i in moves:\\n            if i == \\'U\\':\\n                pos[1] += 1\\n            elif i ==\\'D\\':\\n                pos[1] -= 1\\n            elif i==\\'R\\':\\n                pos[0] += 1\\n            else:\\n                pos[0] -= 1\\n        return pos[0]==0 and pos[1]==0\\n        \\n```\n```\\ndef faster(self,moves):\\n\\tu = moves.count(\\'U\\')\\n\\td = moves.count(\\'D\\')\\n\\tl = moves.count(\\'L\\')\\n\\tr = moves.count(\\'R\\')\\n\\treturn u - d == 0 and l-r == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 106398,
                "title": "1-line-javascript-solution",
                "content": "```\\nconst judgeCircle = (moves) => {\\n    return moves.split('')\\n        .reduce((p, m) => [p[0] + (m === 'R') - (m === 'L'), p[1] + (m === 'U') - (m === 'D')], [0, 0])\\n        .join('') === '00'\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst judgeCircle = (moves) => {\\n    return moves.split('')\\n        .reduce((p, m) => [p[0] + (m === 'R') - (m === 'L'), p[1] + (m === 'U') - (m === 'D')], [0, 0])\\n        .join('') === '00'\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537638,
                "title": "java-switch-robot-return-to-origin",
                "content": "\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int point[] = {0,0};\\n        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (Character m: moves.toCharArray()) {\\n            int ind = 0;\\n            switch (m)\\n            {\\n                case \\'U\\': {\\n                    ind = 0;\\n                    break;\\n                }\\n                case \\'D\\': {\\n                    ind = 1;\\n                    break;\\n                }\\n                case \\'L\\': {\\n                    ind = 2;\\n                    break;\\n                }\\n                case \\'R\\': {\\n                    ind = 3;\\n                    break;\\n                }\\n            }\\n            point[0] += move[ind][0];\\n            point[1] += move[ind][1];\\n        }\\n        return point[0] == 0 && point[1] == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int point[] = {0,0};\\n        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (Character m: moves.toCharArray()) {\\n            int ind = 0;\\n            switch (m)\\n            {\\n                case \\'U\\': {\\n                    ind = 0;\\n                    break;\\n                }\\n                case \\'D\\': {\\n                    ind = 1;\\n                    break;\\n                }\\n                case \\'L\\': {\\n                    ind = 2;\\n                    break;\\n                }\\n                case \\'R\\': {\\n                    ind = 3;\\n                    break;\\n                }\\n            }\\n            point[0] += move[ind][0];\\n            point[1] += move[ind][1];\\n        }\\n        return point[0] == 0 && point[1] == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281412,
                "title": "typescript-nice-and-beautiful-solution-runtime-90",
                "content": "# Code\\n```\\nfunction judgeCircle(moves: string): boolean {\\n    let x: number = 0, y: number = 0;\\n    const actions = {\\n        \\'U\\': () => y += 1,\\n        \\'D\\': () => y -= 1,\\n        \\'R\\': () => x += 1,\\n        \\'L\\': () => x -= 1,\\n    };\\n\\n    for (let i = 0; i < moves.length; i++) {\\n        actions[moves[i]]();\\n    }\\n\\n    return x == 0 && y == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction judgeCircle(moves: string): boolean {\\n    let x: number = 0, y: number = 0;\\n    const actions = {\\n        \\'U\\': () => y += 1,\\n        \\'D\\': () => y -= 1,\\n        \\'R\\': () => x += 1,\\n        \\'L\\': () => x -= 1,\\n    };\\n\\n    for (let i = 0; i < moves.length; i++) {\\n        actions[moves[i]]();\\n    }\\n\\n    return x == 0 && y == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3101497,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool judgeCircle(char * moves){\\n    int a=0,b=0,c=0,d=0;\\n    for(int i=0;i<strlen(moves);i++){\\n        if(moves[i]==\\'U\\'){\\n            a++;\\n        }\\n        if(moves[i]==\\'D\\'){\\n            b++;\\n        }\\n        if(moves[i]==\\'L\\'){\\n            c++;\\n        }\\n        if(moves[i]==\\'R\\'){\\n            d++;\\n        }\\n       \\n        \\n    }\\n     if((a==b)&&(c==d)){\\n            return true;\\n        }\\n    return false;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool judgeCircle(char * moves){\\n    int a=0,b=0,c=0,d=0;\\n    for(int i=0;i<strlen(moves);i++){\\n        if(moves[i]==\\'U\\'){\\n            a++;\\n        }\\n        if(moves[i]==\\'D\\'){\\n            b++;\\n        }\\n        if(moves[i]==\\'L\\'){\\n            c++;\\n        }\\n        if(moves[i]==\\'R\\'){\\n            d++;\\n        }\\n       \\n        \\n    }\\n     if((a==b)&&(c==d)){\\n            return true;\\n        }\\n    return false;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3047953,
                "title": "100-faster-java-using-chararray",
                "content": "![Screenshot_20230114_091815.png](https://assets.leetcode.com/users/images/9ced22e7-66ae-4696-84a1-37036e7a9d42_1673670021.3416722.png)\\n\\n\\n```Hey, please upvote, it you find it useful```\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for (char move : moves.toCharArray()) {\\n            if (move == \\'U\\') y++;\\n            else if (move == \\'D\\') y--;\\n            else if (move == \\'L\\') x--;\\n            else x++;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Hey, please upvote, it you find it useful```\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for (char move : moves.toCharArray()) {\\n            if (move == \\'U\\') y++;\\n            else if (move == \\'D\\') y--;\\n            else if (move == \\'L\\') x--;\\n            else x++;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462967,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        \\n        return moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        \\n        return moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374220,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} moves\\n * @return {boolean}\\n */\\nvar judgeCircle = function(moves) {  \\n    let x = 0;\\n    let y = 0;\\n    \\n    for (let move of moves) {\\n        if (move == \"R\") {\\n            x++;\\n        }\\n        if (move == \"L\") {\\n            x--;\\n        }\\n        if (move == \"D\") {\\n            y--;\\n        }\\n        if (move == \"U\") {\\n            y++;\\n        }        \\n    }\\n    \\n    return x == 0 && y == 0;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} moves\\n * @return {boolean}\\n */\\nvar judgeCircle = function(moves) {  \\n    let x = 0;\\n    let y = 0;\\n    \\n    for (let move of moves) {\\n        if (move == \"R\") {\\n            x++;\\n        }\\n        if (move == \"L\") {\\n            x--;\\n        }\\n        if (move == \"D\") {\\n            y--;\\n        }\\n        if (move == \"U\") {\\n            y++;\\n        }        \\n    }\\n    \\n    return x == 0 && y == 0;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 194765,
                "title": "java-one-liner",
                "content": "```    \\npublic boolean judgeCircle(String moves) {\\n        \\n                return moves.replace(\"L\", \"\").length() == moves.replace(\"R\", \"\").length()\\n            && moves.replace(\"U\", \"\").length() == moves.replace(\"D\", \"\").length();\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "```    \\npublic boolean judgeCircle(String moves) {\\n        \\n                return moves.replace(\"L\", \"\").length() == moves.replace(\"R\", \"\").length()\\n            && moves.replace(\"U\", \"\").length() == moves.replace(\"D\", \"\").length();\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 106415,
                "title": "java-solution-if-else",
                "content": "```\\npublic class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for (char c : moves.toCharArray()) {\\n            if (c == 'R') x++;\\n            else if (c == 'L') x--;\\n            else if (c == 'U') y--;\\n            else if (c == 'D') y++;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for (char c : moves.toCharArray()) {\\n            if (c == 'R') x++;\\n            else if (c == 'L') x--;\\n            else if (c == 'U') y--;\\n            else if (c == 'D') y++;\\n        }\\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265538,
                "title": "c-java-python-easy-solution-using-coordinates-o-n-time",
                "content": "# Complexity\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int xPos=0;\\n        int yPos=0;\\n        for (int i = 0; i < moves.length(); i++)\\n        {\\n            if (moves[i]==\\'L\\'){ xPos--; continue; }\\n            if (moves[i]==\\'R\\'){ xPos++; continue; }\\n            if (moves[i]==\\'D\\'){ yPos--; continue; }\\n            yPos++;\\n\\n        }\\n        if (xPos==0&&yPos==0) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int xPos=0;\\n        int yPos=0;\\n        for (int i = 0; i < moves.length(); i++)\\n        {\\n            if (moves.charAt(i)==\\'L\\'){ xPos--; continue; }\\n            if (moves.charAt(i)==\\'R\\'){ xPos++; continue; }\\n            if (moves.charAt(i)==\\'D\\'){ yPos--; continue; }\\n            yPos++;\\n\\n        }\\n        if (xPos==0&&yPos==0) return true;\\n        return false;\\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        xPos = 0\\n        yPos = 0\\n        for i in range(0,len(moves)):\\n            if (moves[i]==\\'L\\'):\\n                xPos-=1\\n                continue\\n            if (moves[i]==\\'R\\'):\\n                xPos+=1\\n                continue\\n            if (moves[i]==\\'D\\'):\\n                yPos-=1\\n                continue\\n            if (moves[i]==\\'U\\'):\\n                yPos+=1\\n                continue\\n        if (xPos==0 and yPos==0):\\n            return True\\n        return False\\n```\\n\\nUpvote if this helps please \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int xPos=0;\\n        int yPos=0;\\n        for (int i = 0; i < moves.length(); i++)\\n        {\\n            if (moves[i]==\\'L\\'){ xPos--; continue; }\\n            if (moves[i]==\\'R\\'){ xPos++; continue; }\\n            if (moves[i]==\\'D\\'){ yPos--; continue; }\\n            yPos++;\\n\\n        }\\n        if (xPos==0&&yPos==0) return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int xPos=0;\\n        int yPos=0;\\n        for (int i = 0; i < moves.length(); i++)\\n        {\\n            if (moves.charAt(i)==\\'L\\'){ xPos--; continue; }\\n            if (moves.charAt(i)==\\'R\\'){ xPos++; continue; }\\n            if (moves.charAt(i)==\\'D\\'){ yPos--; continue; }\\n            yPos++;\\n\\n        }\\n        if (xPos==0&&yPos==0) return true;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        xPos = 0\\n        yPos = 0\\n        for i in range(0,len(moves)):\\n            if (moves[i]==\\'L\\'):\\n                xPos-=1\\n                continue\\n            if (moves[i]==\\'R\\'):\\n                xPos+=1\\n                continue\\n            if (moves[i]==\\'D\\'):\\n                yPos-=1\\n                continue\\n            if (moves[i]==\\'U\\'):\\n                yPos+=1\\n                continue\\n        if (xPos==0 and yPos==0):\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173923,
                "title": "c-easy-understanding-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Iterative** - increment or decrement position co-ordinates according to the move in the string.\\nAfter traversing entire string compare if the co-ordinates are still at origin or not.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int srcx = 0 ; \\n        int srcy = 0 ; \\n\\n        for (int i = 0 ; i < moves.length() ; i++)\\n        {\\n            if (moves[i] == \\'R\\')\\n            {\\n                srcx++ ;\\n            }\\n            else if (moves[i] == \\'L\\')\\n            {\\n                srcx-- ;\\n            }\\n            else if (moves[i] == \\'U\\')\\n            {\\n                srcy++;\\n            }\\n            else\\n            {\\n                srcy--; \\n            }\\n        }\\n        if (srcx == 0 && srcy == 0)\\n        {\\n            return true ; \\n        }\\n        return false ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/352ff649-20f5-42b2-b801-8ec5fab84787_1676172182.376532.png)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int srcx = 0 ; \\n        int srcy = 0 ; \\n\\n        for (int i = 0 ; i < moves.length() ; i++)\\n        {\\n            if (moves[i] == \\'R\\')\\n            {\\n                srcx++ ;\\n            }\\n            else if (moves[i] == \\'L\\')\\n            {\\n                srcx-- ;\\n            }\\n            else if (moves[i] == \\'U\\')\\n            {\\n                srcy++;\\n            }\\n            else\\n            {\\n                srcy--; \\n            }\\n        }\\n        if (srcx == 0 && srcy == 0)\\n        {\\n            return true ; \\n        }\\n        return false ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812801,
                "title": "one-liner",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'L\\') == moves.count(\\'R\\') and moves.count(\\'U\\') == moves.count(\\'D\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'L\\') == moves.count(\\'R\\') and moves.count(\\'U\\') == moves.count(\\'D\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358283,
                "title": "python3-nerd-and-clever",
                "content": "* nerd \\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        d = {\\'R\\':[1,0],\\n            \\'L\\':[-1,0],\\n            \\'U\\':[0,1],\\n            \\'D\\':[0,-1]}\\n        p = [0,0]\\n        for w in moves:\\n            m = d[w]\\n            p[0]+=m[0]\\n            p[1]+=m[1]\\n        return p == [0,0]\\n```\\n*  clever\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'R\\') == moves.count(\\'L\\') and moves.count(\\'U\\') ==moves.count(\\'D\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        d = {\\'R\\':[1,0],\\n            \\'L\\':[-1,0],\\n            \\'U\\':[0,1],\\n            \\'D\\':[0,-1]}\\n        p = [0,0]\\n        for w in moves:\\n            m = d[w]\\n            p[0]+=m[0]\\n            p[1]+=m[1]\\n        return p == [0,0]\\n```\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'R\\') == moves.count(\\'L\\') and moves.count(\\'U\\') ==moves.count(\\'D\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266298,
                "title": "javascript-faster-than-99-84",
                "content": "Memory usage 92.04%\\n```\\nvar judgeCircle = function(moves) {\\n    let x = 0;\\n    let y = 0;   \\n    \\n    for(let i = 0; i < moves.length; i++) {\\n        switch (moves[i]) {\\n            case \\'R\\':\\n                x++;\\n                break;\\n            case \\'L\\':\\n                x--;\\n                break;\\n            case \\'U\\':\\n                y++;\\n                break;\\n            case \\'D\\':\\n                y--;\\n                break;\\n        }\\n    }\\n    return x == 0 && y == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar judgeCircle = function(moves) {\\n    let x = 0;\\n    let y = 0;   \\n    \\n    for(let i = 0; i < moves.length; i++) {\\n        switch (moves[i]) {\\n            case \\'R\\':\\n                x++;\\n                break;\\n            case \\'L\\':\\n                x--;\\n                break;\\n            case \\'U\\':\\n                y++;\\n                break;\\n            case \\'D\\':\\n                y--;\\n                break;\\n        }\\n    }\\n    return x == 0 && y == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 106373,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Judge Route Circle** https://leetcode.com/problems/judge-route-circle/description/\\n\\n**Balance U with D and R with L**\\n```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        return (moves.count(\"U\") == moves.count(\"D\")) and (moves.count(\"R\") == moves.count(\"L\"))\\n```\\n\\n**Simulate movements**\\n* Imagine we start with origin. After all movements, we must be back at origin.\\n```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        x,y = 0,0\\n        offsets = {\"U\":[0,1], \"D\":[0,-1], \"R\":[1,0], \"L\":[-1,0]}\\n        for move in moves:\\n            x,y = x+offsets[move][0], y+offsets[move][1]\\n        return (x == 0) and (y == 0)\\n```\\n\\n**User a counter and balance U/D and R/L**\\n```\\nfrom collections import Counter    \\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        ctr = Counter(moves)\\n        ctr += Counter(\"UDRL\")\\n        return (ctr[\"U\"] == ctr[\"D\"]) and (ctr[\"R\"] == ctr[\"L\"])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        return (moves.count(\"U\") == moves.count(\"D\")) and (moves.count(\"R\") == moves.count(\"L\"))\\n```\n```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        x,y = 0,0\\n        offsets = {\"U\":[0,1], \"D\":[0,-1], \"R\":[1,0], \"L\":[-1,0]}\\n        for move in moves:\\n            x,y = x+offsets[move][0], y+offsets[move][1]\\n        return (x == 0) and (y == 0)\\n```\n```\\nfrom collections import Counter    \\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        ctr = Counter(moves)\\n        ctr += Counter(\"UDRL\")\\n        return (ctr[\"U\"] == ctr[\"D\"]) and (ctr[\"R\"] == ctr[\"L\"])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566643,
                "title": "two-approaches-for-robot-return-to-origin-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. First Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply traverse the string and sum up the U, D, L, R\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int i, x=0, y=0;\\n        for(i=0 ; i<moves.length() ; i++)\\n        {\\n            if(moves[i]==\\'U\\')\\n                x++;\\n            else if(moves[i]==\\'D\\')\\n                x--;\\n            else if(moves[i]==\\'R\\')\\n                y++;\\n            else if(moves[i]==\\'L\\')\\n                y--;\\n        }\\n        if(x==0 && y==0)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n# 2. Second Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse count() function and match the number of occurences of U, D, L, R\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int u, d, l, r;\\n        u = count(moves.begin(), moves.end(), \\'U\\');\\n        d = count(moves.begin(), moves.end(), \\'D\\');\\n        l = count(moves.begin(), moves.end(), \\'L\\');\\n        r = count(moves.begin(), moves.end(), \\'R\\');\\n        if(u==d && l==r)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4663a3c8-16f7-4dd7-9749-31193ae3ee53_1685161982.8998024.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int i, x=0, y=0;\\n        for(i=0 ; i<moves.length() ; i++)\\n        {\\n            if(moves[i]==\\'U\\')\\n                x++;\\n            else if(moves[i]==\\'D\\')\\n                x--;\\n            else if(moves[i]==\\'R\\')\\n                y++;\\n            else if(moves[i]==\\'L\\')\\n                y--;\\n        }\\n        if(x==0 && y==0)\\n            return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int u, d, l, r;\\n        u = count(moves.begin(), moves.end(), \\'U\\');\\n        d = count(moves.begin(), moves.end(), \\'D\\');\\n        l = count(moves.begin(), moves.end(), \\'L\\');\\n        r = count(moves.begin(), moves.end(), \\'R\\');\\n        if(u==d && l==r)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314780,
                "title": "657-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize two counters up_down and left_right to keep track of the vertical and horizontal movements, respectively. Set both counters to 0.\\n\\n2. For each character move in the moves string, do the following:\\na. If move is \"U\", increment up_down by 1.\\nb. If move is \"D\", decrement up_down by 1.\\nc. If move is \"L\", decrement left_right by 1.\\nd. If move is \"R\", increment left_right by 1.\\n\\n3. After iterating through all the moves, check if both up_down and left_right are 0. If they are, return True, indicating that the robot returns to the origin. Otherwise, return False, indicating that the robot does not return to the origin.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        # Initialize counters for up/down and left/right movements\\n        up_down = left_right = 0\\n        # Iterate through each move and update counters accordingly\\n        for move in moves:\\n            if move == \"U\":\\n                up_down += 1\\n            elif move == \"D\":\\n                up_down -= 1\\n            elif move == \"L\":\\n                left_right -= 1\\n            elif move == \"R\":\\n                left_right += 1\\n        # Check if the final position is the origin\\n        return up_down == 0 and left_right == 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        # Initialize counters for up/down and left/right movements\\n        up_down = left_right = 0\\n        # Iterate through each move and update counters accordingly\\n        for move in moves:\\n            if move == \"U\":\\n                up_down += 1\\n            elif move == \"D\":\\n                up_down -= 1\\n            elif move == \"L\":\\n                left_right -= 1\\n            elif move == \"R\":\\n                left_right += 1\\n        # Check if the final position is the origin\\n        return up_down == 0 and left_right == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959304,
                "title": "c-easy-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string mov) {\\n        int x = 0;\\n        int y = 0;\\n        for(auto i : mov) {\\n            if(i == \\'L\\') x--;\\n            else if(i == \\'R\\') x++;\\n            else if(i == \\'U\\') y++;\\n            else y--;\\n        }\\n        if(x == 0 && y == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string mov) {\\n        int x = 0;\\n        int y = 0;\\n        for(auto i : mov) {\\n            if(i == \\'L\\') x--;\\n            else if(i == \\'R\\') x++;\\n            else if(i == \\'U\\') y++;\\n            else y--;\\n        }\\n        if(x == 0 && y == 0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842819,
                "title": "java-easy-to-understand-o-n-beats-100",
                "content": "- Return `true` if total of `R == L` and `U == D`\\n- Using an array to count the characters count.\\n- Comparing the count of `R,L` and `U,D` position values. \\n\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\t\\tint[] t = new int[86];\\n\\t\\tfor (char d : moves.toCharArray()) {\\n\\t\\t\\tt[d]++;\\n\\t\\t}\\n\\t\\treturn t[68] == t[85] && t[76] == t[82];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\t\\tint[] t = new int[86];\\n\\t\\tfor (char d : moves.toCharArray()) {\\n\\t\\t\\tt[d]++;\\n\\t\\t}\\n\\t\\treturn t[68] == t[85] && t[76] == t[82];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402246,
                "title": "c-o-n-time-and-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n     \\n        //the moves should consists of same number of up and downs and same number of left and right \\n        int up=0;\\n        int left=0;\\n        for(int i=0;i<moves.length();i++)\\n        {\\n            if(moves[i]==\\'U\\')\\n                up++;\\n            else if(moves[i]==\\'D\\')\\n                up--;\\n            else if(moves[i]==\\'L\\')\\n                left++;\\n            else if(moves[i]==\\'R\\')\\n                left--;\\n        }\\n        cout<<up<<\" \"<<left;\\n        return (up==0 && left==0);\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n     \\n        //the moves should consists of same number of up and downs and same number of left and right \\n        int up=0;\\n        int left=0;\\n        for(int i=0;i<moves.length();i++)\\n        {\\n            if(moves[i]==\\'U\\')\\n                up++;\\n            else if(moves[i]==\\'D\\')\\n                up--;\\n            else if(moves[i]==\\'L\\')\\n                left++;\\n            else if(moves[i]==\\'R\\')\\n                left--;\\n        }\\n        cout<<up<<\" \"<<left;\\n        return (up==0 && left==0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 982508,
                "title": "python-1-line-simplest",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\"R\")==moves.count(\"L\") and moves.count(\"U\")==moves.count(\"D\")\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\"R\")==moves.count(\"L\") and moves.count(\"U\")==moves.count(\"D\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900090,
                "title": "java-solution-clean-code-with-full-comments-4ms-83-28-speed-without-library",
                "content": "```\\nclass Solution \\n{\\n    public boolean judgeCircle(String moves)\\n    {\\n        char countR = \\' \\'; // Set counters for all possible movements.\\n        char countL = \\' \\';\\n        char countU = \\' \\';\\n        char countD = \\' \\';\\n        \\n        char[] arr = new char[moves.length()]; // Create character array for the String\\'s movements, you can use java library for that in order to save space and speed I assume, but this is the \"hand on\" approach.\\n        \\n        for(int i = 0; i < moves.length(); i++) // Iterate through the given string and place each character in the array.\\n        {\\n           arr[i] = moves.charAt(i);\\n        }\\n        \\n        if(arr.length == 1) // If the length of the array is one, thats mean that the robot will never return to the starting point.\\n        {\\n            return false;\\n        }\\n      \\n        for(char ch : arr) // Foreach the character array and count how many times a movement appears.\\n        {\\n            switch(ch)\\n            {\\n                case \\'U\\':\\n                    countU++;\\n                    break;\\n                    \\n                case \\'D\\':\\n                    countD++;\\n                    break;\\n                    \\n                case \\'L\\':\\n                    countL++;\\n                    break;\\n                    \\n                case \\'R\\':\\n                    countR++;\\n                    break;\\n            }\\n        }\\n        \\n        if((countU == countD) && (countL == countR))  // For the robot to return to the starting point, we most have EQUAL OPPOSING MOVEMENTS \\n    \\t{                                             // meaning that the counters of UP & DOWN must contain the same number of movements as well \\n\\t\\t    return true;\\t\\t\\t\\t    \\t      // the counters of LEFT & RIGHT must contain the same number of movments.\\n        }     \\n        else\\n        {\\n            return false;\\n        }\\n    } // Runtime: 4 ms, faster than 83.28% of Java online submissions for Robot Return to Origin.\\n      // Memory Usage: 38.9 MB, less than 9.57% of Java online submissions for Robot Return to Origin.\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public boolean judgeCircle(String moves)\\n    {\\n        char countR = \\' \\'; // Set counters for all possible movements.\\n        char countL = \\' \\';\\n        char countU = \\' \\';\\n        char countD = \\' \\';\\n        \\n        char[] arr = new char[moves.length()]; // Create character array for the String\\'s movements, you can use java library for that in order to save space and speed I assume, but this is the \"hand on\" approach.\\n        \\n        for(int i = 0; i < moves.length(); i++) // Iterate through the given string and place each character in the array.\\n        {\\n           arr[i] = moves.charAt(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 703426,
                "title": "2-simple-python-solutions",
                "content": "**Solution 1**\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")\\n```\\n**Solution 2**\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        position = list([0,0])\\n        for i in moves:\\n            if i == \"R\":\\n                position[1] +=1\\n            if i == \"L\":\\n                position[1] -=1\\n            if i == \"U\":\\n                position[0] +=1\\n            if i == \"D\":\\n                position[0] -=1\\n        \\n        return position == list([0,0])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654437,
                "title": "python3-three-solutions",
                "content": "### Solution 1\\n```\\nif (moves.count(\\'L\\') == moves.count(\\'R\\')) and (moves.count(\\'U\\') == moves.count(\\'D\\')):\\n            return True\\n        else:\\n            return False\\n        \\n     \\n        \\n```\\n### Solution 2\\n```\\n\\t\\t res = collections.Counter(moves)\\n         if (res[\\'U\\'] == res[\\'D\\']) and (res[\\'L\\'] == res[\\'R\\']):\\n             return True\\n         else:\\n             return False\\n```\\n### Solution 3 \\n```\\n\\n         res1 = 0\\n         res2 = 0\\n        \\n         for m in moves:\\n             if m == \\'U\\':\\n                 res1 += 1\\n            elif m == \\'D\\':\\n                res1 -= 1\\n            elif m == \\'L\\':\\n                 res2 += 1\\n             else:\\n                res2 -= 1\\n         if res1 == 0 and res2 == 0:              \\n\\t\\t\\treturn True\\n         else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nif (moves.count(\\'L\\') == moves.count(\\'R\\')) and (moves.count(\\'U\\') == moves.count(\\'D\\')):\\n            return True\\n        else:\\n            return False\\n        \\n     \\n        \\n```\n```\\n\\t\\t res = collections.Counter(moves)\\n         if (res[\\'U\\'] == res[\\'D\\']) and (res[\\'L\\'] == res[\\'R\\']):\\n             return True\\n         else:\\n             return False\\n```\n```\\n\\n         res1 = 0\\n         res2 = 0\\n        \\n         for m in moves:\\n             if m == \\'U\\':\\n                 res1 += 1\\n            elif m == \\'D\\':\\n                res1 -= 1\\n            elif m == \\'L\\':\\n                 res2 += 1\\n             else:\\n                res2 -= 1\\n         if res1 == 0 and res2 == 0:              \\n\\t\\t\\treturn True\\n         else:\\n            return False\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 456542,
                "title": "c-3-line-solution-using-16-ms",
                "content": "This code uses the ? operator to shorten it. Even though it looks super ugly, it still works. Here it is:\\n\\n```\\nbool judgeCircle(string moves) {\\n        int u = 0, r = 0;\\n        for (char i : moves) i == \\'R\\' ? r++ : i == \\'U\\' ? u++ : i == \\'D\\' ? u-- : r--;\\n        return(u == 0 && r == 0);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool judgeCircle(string moves) {\\n        int u = 0, r = 0;\\n        for (char i : moves) i == \\'R\\' ? r++ : i == \\'U\\' ? u++ : i == \\'D\\' ? u-- : r--;\\n        return(u == 0 && r == 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437723,
                "title": "python3-32ms-97",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n\\t\\t#If the number of moves is not even, we can be sure the resultion is False\\n        if len(moves) % 2 != 0:\\n            return False\\t\\n\\t\\t#If U moves are equal to D moves than the initial y-position is the same\\n\\t\\t#This is also true for the L and R moves in relation to the x-position\\n        elif moves.count(\\'U\\') == moves.count(\\'D\\') and moves.count(\\'L\\') == moves.count(\\'R\\'):\\n            return True\\t\\n\\t\\t#If they are not equal, the position has not returned to the origin\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n\\t\\t#If the number of moves is not even, we can be sure the resultion is False\\n        if len(moves) % 2 != 0:\\n            return False\\t\\n\\t\\t#If U moves are equal to D moves than the initial y-position is the same\\n\\t\\t#This is also true for the L and R moves in relation to the x-position\\n        elif moves.count(\\'U\\') == moves.count(\\'D\\') and moves.count(\\'L\\') == moves.count(\\'R\\'):\\n            return True\\t\\n\\t\\t#If they are not equal, the position has not returned to the origin\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334506,
                "title": "c-one-liner",
                "content": "```cpp\\nbool judgeCircle(string moves) {\\n\\treturn count(begin(moves), end(moves), \\'U\\') == count(begin(moves), end(moves), \\'D\\') && count(begin(moves), end(moves), \\'L\\') == count(begin(moves), end(moves), \\'R\\');   \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nbool judgeCircle(string moves) {\\n\\treturn count(begin(moves), end(moves), \\'U\\') == count(begin(moves), end(moves), \\'D\\') && count(begin(moves), end(moves), \\'L\\') == count(begin(moves), end(moves), \\'R\\');   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 138852,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        up_count , down_count , left_count , right_count = 0,0,0,0\\n        for move in moves:\\n            if move==\\'U\\':\\n                up_count = up_count + 1\\n            if move==\\'D\\':\\n                down_count = down_count + 1\\n            if move ==\\'R\\':\\n                right_count = right_count +1\\n            if move ==\\'L\\':\\n                left_count = left_count + 1\\n        \\n        if up_count==down_count and left_count == right_count:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        up_count , down_count , left_count , right_count = 0,0,0,0\\n        for move in moves:\\n            if move==\\'U\\':\\n                up_count = up_count + 1\\n            if move==\\'D\\':\\n                down_count = down_count + 1\\n            if move ==\\'R\\':\\n                right_count = right_count +1\\n            if move ==\\'L\\':\\n                left_count = left_count + 1\\n        \\n        if up_count==down_count and left_count == right_count:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106378,
                "title": "solution-by-vinnyoodles",
                "content": "#### Approach #1 Iterative [Accepted]\\n\\n**Intuition**\\n\\nKeep track of the current coordinate and compare the final coordinate to the initial coordinate.\\n\\n**Algorithm**\\n\\nThe initial coordinate is *(0, 0)*. If we visualize the initial coordinate as the origin in the coordinate plane, then we can give each of the four direction a vector value. \\n\\n```\\nU => +1 y\\nD => -1 y\\nL => -1 x\\nR => +1 x\\n```\\n\\nThe algorithm will keep track of the current coordinate for every move in the sequence of moves. For every move, the coordinate will be updated by adding the move's corresponding vector value.\\n\\nAfter the last move is taken into consideration, the final coordinate has been calculated. At this point, the final coordinate can be compared to the initial coordinate to determine if a circle has been completed. If the final coordinate and the initial coordinate are equivalent, then a circle has been completed.\\n\\n**Java**\\n\\n```java\\npublic class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0;\\n        int y = 0;\\n        for (char c : moves.toCharArray()) {\\n            if (c == 'U') {\\n                y ++;\\n            } else if (c == 'D') { \\n                y --;\\n            } else if (c == 'L') {\\n                x --; \\n            } else if (c == 'R') {\\n                x ++;  \\n            }\\n        }\\n        \\n        return x == 0 && y == 0;\\n    }\\n}\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity: $$O(n)$$. *n* is the number of moves and each move must be taken into consideration to find the final coordinate.\\n\\n* Space complexity: $$O(1)$$. The only variables needed are to keep track of the current coordinate. This can be done with two integer variables which both require constant space.",
                "solutionTags": [],
                "code": "```\\nU => +1 y\\nD => -1 y\\nL => -1 x\\nR => +1 x\\n```\n```java\\npublic class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0;\\n        int y = 0;\\n        for (char c : moves.toCharArray()) {\\n            if (c == 'U') {\\n                y ++;\\n            } else if (c == 'D') { \\n                y --;\\n            } else if (c == 'L') {\\n                x --; \\n            } else if (c == 'R') {\\n                x ++;  \\n            }\\n        }\\n        \\n        return x == 0 && y == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 106404,
                "title": "java-c-4-lines-solution",
                "content": "Actually, I think the question is not quite clear. It should note that the robot **finally** returns to (0,0).\\n\\nC++ version:\\n```\\n    bool judgeCircle(string moves) {\\n        int x = 0, y = 0;\\n        for(char c: moves){\\n            x += (c == 'R') - (c == 'L'), y += (c == 'U') - (c == 'D');\\n        }\\n        return x == 0 && y == 0;\\n    }\\n```\\n\\nJava version:\\n```\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for(char c: moves.toCharArray()){\\n            x += (c=='R'?1:0) + (c=='L'?-1:0); y += (c=='U'?1:0) + (c=='D'?-1:0);\\n        }\\n        return x == 0 && y == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool judgeCircle(string moves) {\\n        int x = 0, y = 0;\\n        for(char c: moves){\\n            x += (c == 'R') - (c == 'L'), y += (c == 'U') - (c == 'D');\\n        }\\n        return x == 0 && y == 0;\\n    }\\n```\n```\\n    public boolean judgeCircle(String moves) {\\n        int x = 0, y = 0;\\n        for(char c: moves.toCharArray()){\\n            x += (c=='R'?1:0) + (c=='L'?-1:0); y += (c=='U'?1:0) + (c=='D'?-1:0);\\n        }\\n        return x == 0 && y == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028158,
                "title": "beginner-friendly-solution-beats-92-of-solutions",
                "content": "> We take 2 integers stp1(Magnitude in Y axis) and stp2(Magnitude in X axis)\\n\\n> Just iterate through the string after that, U means +1 in upward direction, D means -1 in downward direction, L means +1 in left and R means -1 in Right. The final result of magnitude of both the directions must be zero. Please Upvote if u found it useful. :)\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n\\n        int stp1=0;\\n        int stp2=0;\\n\\n        for(int i=0; i<moves.size(); i++){\\n\\n            if(moves[i]==\\'U\\'){\\n            stp1=stp1+1;\\n            }\\n\\n            if(moves[i]==\\'D\\'){\\n            stp1=stp1-1;\\n            }\\n\\n            if(moves[i]==\\'L\\'){\\n            stp2=stp2+1;\\n            }\\n\\n            if(moves[i]==\\'R\\'){\\n            stp2=stp2-1;\\n            }\\n\\n\\n\\n        }\\n        if(stp1==0 && stp2==0)\\n        return true;\\n\\n        else return false;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n\\n        int stp1=0;\\n        int stp2=0;\\n\\n        for(int i=0; i<moves.size(); i++){\\n\\n            if(moves[i]==\\'U\\'){\\n            stp1=stp1+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3695443,
                "title": "very-simple-and-easy-solution-in-javascript-wow-you-must-watch-it",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} moves\\n * @return {boolean}\\n */\\nvar judgeCircle = function(moves) {\\n    let start = [0, 0]\\n    let directions = {\\n        \\'U\\': [0, 1],\\n        \\'D\\': [0, -1],\\n        \\'L\\': [-1, 0],\\n        \\'R\\': [1, 0]\\n    }\\n    for(let i = 0; i < moves.length; i++) {\\n        start[0] += directions[moves[i]][0]\\n        start[1] += directions[moves[i]][1]\\n    }\\n    return start[0] == 0 && start[1] == 0\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} moves\\n * @return {boolean}\\n */\\nvar judgeCircle = function(moves) {\\n    let start = [0, 0]\\n    let directions = {\\n        \\'U\\': [0, 1],\\n        \\'D\\': [0, -1],\\n        \\'L\\': [-1, 0],\\n        \\'R\\': [1, 0]\\n    }\\n    for(let i = 0; i < moves.length; i++) {\\n        start[0] += directions[moves[i]][0]\\n        start[1] += directions[moves[i]][1]\\n    }\\n    return start[0] == 0 && start[1] == 0\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612951,
                "title": "easiest-code-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string s) {\\n        int cnt=0,cntt=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'U\\') cnt++;\\n            else if(s[i]==\\'D\\') cnt--;\\n            else if(s[i]==\\'R\\') cntt++;\\n            else if(s[i]==\\'L\\')cntt--;\\n        }\\n        if(cnt==0 && cntt==0) return 1;\\n        return 0;\\n    }\\n};\\nDo UPVOTE\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string s) {\\n        int cnt=0,cntt=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'U\\') cnt++;\\n            else if(s[i]==\\'D\\') cnt--;\\n            else if(s[i]==\\'R\\') cntt++;\\n            else if(s[i]==\\'L\\')cntt--;\\n        }\\n        if(cnt==0 && cntt==0) return 1;\\n        return 0;\\n    }\\n};\\nDo UPVOTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595805,
                "title": "python-3-very-easy",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x: int = 0\\n        y: int = 0\\n        for move in moves:\\n            if move == \\'U\\':\\n                x += 1\\n            elif move == \\'D\\':\\n                x -= 1\\n            elif move == \\'L\\':\\n                y += 1\\n            elif move == \\'R\\':\\n                y -= 1\\n        return x == 0 and y == 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x: int = 0\\n        y: int = 0\\n        for move in moves:\\n            if move == \\'U\\':\\n                x += 1\\n            elif move == \\'D\\':\\n                x -= 1\\n            elif move == \\'L\\':\\n                y += 1\\n            elif move == \\'R\\':\\n                y -= 1\\n        return x == 0 and y == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423352,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int v = 0;\\n        int h = 0;\\n        for (char ch : moves) {\\n            switch (ch) {\\n                case \\'U\\' : v++; break;\\n                case \\'D\\' : v--; break;\\n                case \\'R\\' : h++; break;\\n                case \\'L\\' : h--; break;\\n            }\\n        }\\n        return v == 0 && h == 0;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\"L\") == moves.count(\"R\") and moves.count(\"U\") == moves.count(\"D\")\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\n        char[] ch = moves.toCharArray();\\n        int[] alpha = new int[26];\\n\\n        for (char c: ch) alpha[(int)(c - 65)]++;\\n\\n        if (alpha[3] == alpha[20] && alpha[17] == alpha[11]) return true;\\n        else return false;   \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int v = 0;\\n        int h = 0;\\n        for (char ch : moves) {\\n            switch (ch) {\\n                case \\'U\\' : v++; break;\\n                case \\'D\\' : v--; break;\\n                case \\'R\\' : h++; break;\\n                case \\'L\\' : h--; break;\\n            }\\n        }\\n        return v == 0 && h == 0;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\"L\") == moves.count(\"R\") and moves.count(\"U\") == moves.count(\"D\")\\n```\n```Java []\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\n        char[] ch = moves.toCharArray();\\n        int[] alpha = new int[26];\\n\\n        for (char c: ch) alpha[(int)(c - 65)]++;\\n\\n        if (alpha[3] == alpha[20] && alpha[17] == alpha[11]) return true;\\n        else return false;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239772,
                "title": "crisp-n-clear-o-n-javascript-memory-95-45-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nvar judgeCircle = function(moves) {\\n\\tlet initialXCoordinate = 0;\\n\\tlet initialYCoordinate = 0;\\n\\tfor (let index = 0; index < moves.length; index++) {\\n\\t\\tif (moves[index] === \\'L\\') {\\n\\t\\t\\tinitialXCoordinate -= 1;\\n\\t\\t} else if (moves[index] === \\'R\\') {\\n\\t\\t\\tinitialXCoordinate += 1;\\n\\t\\t} else if (moves[index] === \\'U\\') {\\n\\t\\t\\tinitialYCoordinate += 1;\\n\\t\\t} else {\\n\\t\\t\\tinitialYCoordinate -= 1;\\n\\t\\t}\\n\\t}\\n\\tif (initialXCoordinate === 0 && initialYCoordinate === 0) {\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar judgeCircle = function(moves) {\\n\\tlet initialXCoordinate = 0;\\n\\tlet initialYCoordinate = 0;\\n\\tfor (let index = 0; index < moves.length; index++) {\\n\\t\\tif (moves[index] === \\'L\\') {\\n\\t\\t\\tinitialXCoordinate -= 1;\\n\\t\\t} else if (moves[index] === \\'R\\') {\\n\\t\\t\\tinitialXCoordinate += 1;\\n\\t\\t} else if (moves[index] === \\'U\\') {\\n\\t\\t\\tinitialYCoordinate += 1;\\n\\t\\t} else {\\n\\t\\t\\tinitialYCoordinate -= 1;\\n\\t\\t}\\n\\t}\\n\\tif (initialXCoordinate === 0 && initialYCoordinate === 0) {\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3233358,
                "title": "easy-and-beginner-friendly-solution-in-python-count-and-compare",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        if len(moves)%2==0:\\n            if moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\"):\\n                return True\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        if len(moves)%2==0:\\n            if moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\"):\\n                return True\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088475,
                "title": "python-dictionary-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        d={}\\n        for i in moves:\\n            d[i]=d.get(i,0)+1\\n        #print(d)\\n        #print(d.get(\"L\",0))\\n        if(d.get(\"U\",0)==d.get(\"D\",0) and d.get(\"L\",0)==d.get(\"R\",0)):\\n            return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        d={}\\n        for i in moves:\\n            d[i]=d.get(i,0)+1\\n        #print(d)\\n        #print(d.get(\"L\",0))\\n        if(d.get(\"U\",0)==d.get(\"D\",0) and d.get(\"L\",0)==d.get(\"R\",0)):\\n            return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898183,
                "title": "using-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s obvious that robot returns to the same position if quantity of letters U equal D, and quantity of letters L equal R.\\n\\n# Solution\\n\\nSo we just need to count those letters. We can use **Counter()** for it, which returns the dictionary with keys U, D, L and R and their quantities. After that we just check if quantites are both equal for pairs U and D, L and R. In this case we don\\'t need to use count() several times (in one-line solution).\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        # Returns dictionary with sum of all moves.\\n        counted_moves = Counter(moves)\\n        return (counted_moves[\\'U\\'] == counted_moves[\\'D\\']) and (counted_moves[\\'L\\'] == counted_moves[\\'R\\'])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        # Returns dictionary with sum of all moves.\\n        counted_moves = Counter(moves)\\n        return (counted_moves[\\'U\\'] == counted_moves[\\'D\\']) and (counted_moves[\\'L\\'] == counted_moves[\\'R\\'])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865180,
                "title": "java-simple-and-naive-approach-8ms",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int up=0;int down=0;\\n        int left=0;int right=0;\\n        \\n        for(int i=0;i<moves.length();i++){\\n            if(moves.charAt(i)==\\'U\\'){\\n                up++;\\n            }\\n            else if(moves.charAt(i)==\\'D\\'){\\n                down++;\\n            }\\n            else if(moves.charAt(i)==\\'L\\'){\\n                left++;\\n            }\\n            else if(moves.charAt(i)==\\'R\\'){\\n                right++;\\n            }\\n        }\\n        if(left==0 && right==0){\\n            if(up==down){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(up==0 && down==0){\\n            if(left==right){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(up==down && left==right){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int up=0;int down=0;\\n        int left=0;int right=0;\\n        \\n        for(int i=0;i<moves.length();i++){\\n            if(moves.charAt(i)==\\'U\\'){\\n                up++;\\n            }\\n            else if(moves.charAt(i)==\\'D\\'){\\n                down++;\\n            }\\n            else if(moves.charAt(i)==\\'L\\'){\\n                left++;\\n            }\\n            else if(moves.charAt(i)==\\'R\\'){\\n                right++;\\n            }\\n        }\\n        if(left==0 && right==0){\\n            if(up==down){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(up==0 && down==0){\\n            if(left==right){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(up==down && left==right){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712297,
                "title": "java",
                "content": "```\\n\\n    public boolean judgeCircle(String moves) {\\n        int u = 0;\\n        int r = 0;\\n\\n        for (int i = 0; i < moves.length(); i++) {\\n            if (moves.charAt(i) == \\'U\\') u++;\\n            else if (moves.charAt(i) == \\'D\\') u--;\\n            else if (moves.charAt(i) == \\'R\\') r++;\\n            else if (moves.charAt(i) == \\'L\\') r--;\\n        }\\n\\n        return u == 0 && r == 0;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public boolean judgeCircle(String moves) {\\n        int u = 0;\\n        int r = 0;\\n\\n        for (int i = 0; i < moves.length(); i++) {\\n            if (moves.charAt(i) == \\'U\\') u++;\\n            else if (moves.charAt(i) == \\'D\\') u--;\\n            else if (moves.charAt(i) == \\'R\\') r++;\\n            else if (moves.charAt(i) == \\'L\\') r--;\\n        }\\n\\n        return u == 0 && r == 0;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2705133,
                "title": "rust-fold",
                "content": "```\\nimpl Solution {\\n    pub fn judge_circle(moves: String) -> bool {\\n        (0, 0) == moves.chars()\\n            .fold((0, 0), |(x, y), c| {\\n                match c {\\n                    \\'U\\' => (x, y + 1),\\n                    \\'D\\' => (x, y - 1),\\n                    \\'R\\' => (x + 1, y),\\n                    \\'L\\' => (x - 1, y),\\n                    _ => (x, y),\\n                }\\n             })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn judge_circle(moves: String) -> bool {\\n        (0, 0) == moves.chars()\\n            .fold((0, 0), |(x, y), c| {\\n                match c {\\n                    \\'U\\' => (x, y + 1),\\n                    \\'D\\' => (x, y - 1),\\n                    \\'R\\' => (x + 1, y),\\n                    \\'L\\' => (x - 1, y),\\n                    _ => (x, y),\\n                }\\n             })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2159294,
                "title": "python3-is-the-solution-is-o-n-runtime-and-o-1",
                "content": "`~I was thinking it should be O(1) in runtime because they already told us that input will be just 4 english letters, am I right? or it is O(n)~`\\n\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x, y = 0, 0\\n        \\n        for i in moves.lower():\\n            if i == \\'u\\':\\n                y += 1\\n            elif i == \\'r\\':\\n                x += 1\\n            elif i == \\'d\\':\\n                y -= 1\\n            elif i == \\'l\\':\\n                x -= 1\\n        return x == 0 and y == 0\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x, y = 0, 0\\n        \\n        for i in moves.lower():\\n            if i == \\'u\\':\\n                y += 1\\n            elif i == \\'r\\':\\n                x += 1\\n            elif i == \\'d\\':\\n                y -= 1\\n            elif i == \\'l\\':\\n                x -= 1\\n        return x == 0 and y == 0\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110609,
                "title": "easy-approach-o-n",
                "content": "class Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        \\n        long int c=0,c1=0;\\n        for(int i=0;i<moves.length();i++)\\n        {\\n            if(moves[i]==\\'L\\')\\n                c++;\\n            else if(moves[i]==\\'R\\')\\n                c--;\\n            else if(moves[i]==\\'U\\')\\n                c1++;\\n            else if(moves[i]==\\'D\\')\\n                c1--;\\n        }\\n        if(c1==0 && c==0)\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        \\n        long int c=0,c1=0;\\n        for(int i=0;i<moves.length();i++)\\n        {\\n            if(moves[i]==\\'L\\')\\n                c++;\\n            else if(moves[i]==\\'R\\')\\n                c--;\\n            else if(moves[i]==\\'U\\')\\n                c1++;\\n            else if(moves[i]==\\'D\\')\\n                c1--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1881846,
                "title": "robot-return-to-origin-solution-java",
                "content": "class Solution {\\n  public boolean judgeCircle(String moves) {\\n    int right = 0;\\n    int up = 0;\\n\\n    for (final char move : moves.toCharArray()) {\\n      switch (move) {\\n        case \\'R\\':\\n          ++right;\\n          break;\\n        case \\'L\\':\\n          --right;\\n          break;\\n        case \\'U\\':\\n          ++up;\\n          break;\\n        case \\'D\\':\\n          --up;\\n          break;\\n      }\\n    }\\n\\n    return right == 0 && up == 0;\\n  }\\n}\\n",
                "solutionTags": [
                    "String",
                    "Simulation"
                ],
                "code": "class Solution {\\n  public boolean judgeCircle(String moves) {\\n    int right = 0;\\n    int up = 0;\\n\\n    for (final char move : moves.toCharArray()) {\\n      switch (move) {\\n        case \\'R\\':\\n          ++right;\\n          break;\\n        case \\'L\\':\\n          --right;\\n          break;\\n        case \\'U\\':\\n          ++up;\\n          break;\\n        case \\'D\\':\\n          --up;\\n          break;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1712229,
                "title": "beginner-friendly-javascript-solution",
                "content": "**Time Complexity : O(n)**\\n```\\n/**\\n * @param {string} moves\\n * @return {boolean}\\n */\\nvar judgeCircle = function(moves) {\\n    let up = 0, left = 0;\\n    for(const move of moves){\\n        if(move == \\'L\\')   left++;\\n        else if(move == \\'R\\')   left--;\\n        else if(move == \\'U\\')   up++;\\n        else    up--;\\n    }\\n    return left == 0 && up == 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} moves\\n * @return {boolean}\\n */\\nvar judgeCircle = function(moves) {\\n    let up = 0, left = 0;\\n    for(const move of moves){\\n        if(move == \\'L\\')   left++;\\n        else if(move == \\'R\\')   left--;\\n        else if(move == \\'U\\')   up++;\\n        else    up--;\\n    }\\n    return left == 0 && up == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1540088,
                "title": "c-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int sum=0,sum1=0;\\n        // assigninng weights to L,R,U,D. \\n        // L-> -2, R-> +2, D-> -1, U-> +1\\n        for(int i=0;i<moves.size();i++){\\n            if(moves[i]==\\'L\\')\\n                sum1-=2;\\n            else if(moves[i]==\\'R\\')\\n                sum1+=2;\\n            else if(moves[i]==\\'U\\')\\n                sum+=1;\\n            else \\n                sum-=1;\\n        }\\n        \\n        if(sum!=0||sum1!=0)\\n            return false;\\n        // Robots comes at (0,0) if L+R=0, U+D=0 \\n        return true;\\n    }\\n};\\n```\\n***Upvote if you liked it ***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int sum=0,sum1=0;\\n        // assigninng weights to L,R,U,D. \\n        // L-> -2, R-> +2, D-> -1, U-> +1\\n        for(int i=0;i<moves.size();i++){\\n            if(moves[i]==\\'L\\')\\n                sum1-=2;\\n            else if(moves[i]==\\'R\\')\\n                sum1+=2;\\n            else if(moves[i]==\\'U\\')\\n                sum+=1;\\n            else \\n                sum-=1;\\n        }\\n        \\n        if(sum!=0||sum1!=0)\\n            return false;\\n        // Robots comes at (0,0) if L+R=0, U+D=0 \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344746,
                "title": "one-line-of-python",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'U\\') == moves.count(\\'D\\') and moves.count(\\'L\\') == moves.count(\\'R\\')\\n        \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'U\\') == moves.count(\\'D\\') and moves.count(\\'L\\') == moves.count(\\'R\\')\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173709,
                "title": "faster-than-99-15-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int l = 0, r = 0, u = 0, d = 0;\\n        for (char c : moves.toCharArray()) {\\n            switch (c) {\\n                case \\'L\\':\\n                    l++;\\n                    break;\\n                case \\'R\\':\\n                    r++;\\n                    break;\\n                case \\'U\\':\\n                    u++;\\n                    break;\\n                case \\'D\\':\\n                    d++;\\n                    break;\\n            }\\n        }\\n        return (l == r && u == d);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int l = 0, r = 0, u = 0, d = 0;\\n        for (char c : moves.toCharArray()) {\\n            switch (c) {\\n                case \\'L\\':\\n                    l++;\\n                    break;\\n                case \\'R\\':\\n                    r++;\\n                    break;\\n                case \\'U\\':\\n                    u++;\\n                    break;\\n                case \\'D\\':\\n                    d++;\\n                    break;\\n            }\\n        }\\n        return (l == r && u == d);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160971,
                "title": "javascript-hash-map-solution",
                "content": "Simple logic, create a map of moves. The robot is in it\\'s origin position if left moves = right moves and up moves = down moves\\n```\\nvar judgeCircle = function(moves) {\\n    let map = {}\\n    \\n    for (let char of moves){\\n        map[char] = map[char] + 1 || 1\\n    }\\n    \\n    return (map[\\'L\\'] === map[\\'R\\'] && map[\\'U\\'] === map[\\'D\\']) \\n };\\n };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar judgeCircle = function(moves) {\\n    let map = {}\\n    \\n    for (let char of moves){\\n        map[char] = map[char] + 1 || 1\\n    }\\n    \\n    return (map[\\'L\\'] === map[\\'R\\'] && map[\\'U\\'] === map[\\'D\\']) \\n };\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150471,
                "title": "java-simple-and-fast-solution-in-o-n",
                "content": "Approach: if robot has went to right side, it must come to left to come in initial position. Similarly if robot has gone \\nup then it should come down again and vice-versa.\\nHence just get count of left and right, up and down as well and match if count of left & right and up & down are same or not.\\n\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int L = 0;\\n        int R = 0;\\n        int U = 0;\\n        int D = 0;\\n        for(char k:moves.toCharArray())\\n            if(k==\\'L\\') L++;\\n            else if(k==\\'R\\') R++;\\n            else if(k==\\'U\\') U++;\\n            else\\n                D++;\\n        return( (L==R) && (U==D));\\n            \\n        \\n    }\\n}\\n```\\n\\nThat\\'s easy.. Enjoy.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int L = 0;\\n        int R = 0;\\n        int U = 0;\\n        int D = 0;\\n        for(char k:moves.toCharArray())\\n            if(k==\\'L\\') L++;\\n            else if(k==\\'R\\') R++;\\n            else if(k==\\'U\\') U++;\\n            else\\n                D++;\\n        return( (L==R) && (U==D));\\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127947,
                "title": "simple-1-liner-in-python-faster-than-98",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, m: str) -> bool:\\n        return m.count(\"D\") == m.count(\"U\") and m.count(\"R\") == m.count(\"L\")\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, m: str) -> bool:\\n        return m.count(\"D\") == m.count(\"U\") and m.count(\"R\") == m.count(\"L\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029512,
                "title": "python3-solution-with-counter",
                "content": "```Python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        steps = Counter(moves)\\n        return steps[\"L\"] == steps[\"R\"] and steps[\"U\"] == steps[\"D\"]\\n```",
                "solutionTags": [],
                "code": "```Python\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        steps = Counter(moves)\\n        return steps[\"L\"] == steps[\"R\"] and steps[\"U\"] == steps[\"D\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008301,
                "title": "python-dictionary",
                "content": "```\\n\\n\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        dic = {\\n            \\'U\\' : 10000,\\n            \\'R\\' : 1,\\n            \\'D\\' : -10000,\\n            \\'L\\' : -1\\n        }\\n        s = 0\\n        for i in range(len(moves)):\\n            s+= dic[moves[i]]\\n\\t\\treturn s==0",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        dic = {\\n            \\'U\\' : 10000,\\n            \\'R\\' : 1,\\n            \\'D\\' : -10000,\\n            \\'L\\' : -1\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 974527,
                "title": "simple-java-code-with-explanation",
                "content": "This code is `O(n)` time and `O(1)` space.\\n\\nThe principle of this code is pretty simple, if the move is `L, R, U` or `D` the code adds one to its counter. At the end if the counters of `L` and `R` are equal and the counters of `U` and `D` are equal return true. We can do this because if `L` is equal to `R` it is basicly saying that the number of right moves is equal to the number of left moves which cancels both of them out, the same applies for `U` and `D`.\\n```\\npublic boolean judgeCircle(String moves) {\\n\\tint L = 0;\\n\\tint R = 0;\\n\\tint U = 0;\\n\\tint D = 0;\\n\\tfor (char i : moves.toCharArray()){\\n\\t\\tswitch (i){\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tL += 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'R\\':\\n\\t\\t\\t\\tR += 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'U\\':\\n\\t\\t\\t\\tU += 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tD += 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn (L == R && U == D);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean judgeCircle(String moves) {\\n\\tint L = 0;\\n\\tint R = 0;\\n\\tint U = 0;\\n\\tint D = 0;\\n\\tfor (char i : moves.toCharArray()){\\n\\t\\tswitch (i){\\n\\t\\t\\tcase \\'L\\':\\n\\t\\t\\t\\tL += 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'R\\':\\n\\t\\t\\t\\tR += 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'U\\':\\n\\t\\t\\t\\tU += 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\'D\\':\\n\\t\\t\\t\\tD += 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn (L == R && U == D);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947562,
                "title": "python-for-loop-o-n-if-else",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        l = u = r = d = 0\\n        for i in moves:\\n            if i == \\'L\\': \\n                l += 1\\n            elif i == \\'R\\': \\n                r += 1\\n            elif i == \\'U\\': \\n                u += 1\\n            elif i == \\'D\\': \\n                d += 1\\n        if l == r and u == d:\\n            return True\\n        return False\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges/tree/master",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        l = u = r = d = 0\\n        for i in moves:\\n            if i == \\'L\\': \\n                l += 1\\n            elif i == \\'R\\': \\n                r += 1\\n            elif i == \\'U\\': \\n                u += 1\\n            elif i == \\'D\\': \\n                d += 1\\n        if l == r and u == d:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919000,
                "title": "less-than-100-memory-python",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        vertical = moves.count(\\'U\\') - moves.count(\\'D\\')\\n        horisontal = moves.count(\\'L\\') - moves.count(\\'R\\')\\n        \\n        return vertical == 0 and horisontal == 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        vertical = moves.count(\\'U\\') - moves.count(\\'D\\')\\n        horisontal = moves.count(\\'L\\') - moves.count(\\'R\\')\\n        \\n        return vertical == 0 and horisontal == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914586,
                "title": "python-3-intuitive-solution-beats-94-59",
                "content": "```\\nmoves = Counter(moves)\\nreturn moves[\\'L\\'] == moves[\\'R\\'] and moves[\\'U\\'] == moves[\\'D\\']\\n```",
                "solutionTags": [],
                "code": "```\\nmoves = Counter(moves)\\nreturn moves[\\'L\\'] == moves[\\'R\\'] and moves[\\'U\\'] == moves[\\'D\\']\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880700,
                "title": "c-o-n-time-o-1-space-98-23-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int cnt=0, cnt1=0;\\n\\t\\tif (moves.length() % 2 != 0) return false; //Will return false on all the cases with odd length string\\n        for(int i=0; i<moves.size(); i++){\\n            if(moves[i] == \\'R\\') cnt++;\\n            else if(moves[i] == \\'L\\') cnt--;\\n            else if(moves[i] == \\'U\\') cnt1++;\\n            else cnt1--;\\n        }\\n        if(cnt==0 && cnt1==0) return true;\\n        return false;\\n    }\\n};\\n```\\nWe maintain two counters to check if movement in right-left and up-down remains same.\\n\\nEdit: Improvised solution by @ragurajrai",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int cnt=0, cnt1=0;\\n\\t\\tif (moves.length() % 2 != 0) return false; //Will return false on all the cases with odd length string\\n        for(int i=0; i<moves.size(); i++){\\n            if(moves[i] == \\'R\\') cnt++;\\n            else if(moves[i] == \\'L\\') cnt--;\\n            else if(moves[i] == \\'U\\') cnt1++;\\n            else cnt1--;\\n        }\\n        if(cnt==0 && cnt1==0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825136,
                "title": "question-accepts-incorrect-solutions-explanation-and-proper-java-solution-provided",
                "content": "This question\\'s top accepted solution should not be accepted. Here\\'s the code:\\n\\n```\\npublic boolean judgeCircle(String moves) {\\n        if (moves == null || moves.isEmpty()) return true;\\n        int[] counts = new int[100];\\n        counts[\\'U\\'] = 1;\\n        counts[\\'D\\'] = -1;\\n        counts[\\'R\\'] = 9;\\n        counts[\\'L\\'] = -9;\\n        \\n        int dist = 0;\\n        for (char ch: moves.toCharArray()) {\\n            dist += counts[ch];\\n        }\\n        \\n        return dist == 0;\\n    }\\n```\\n\\nThis code is actually wrong. Consider the test case: UUUUUUUUUL.\\nThe 9 Us make dist == 9.\\nThe 1 L make dist == 0.\\n\\nHowever, the robot is **not** back at the origin and it should return ***false.***\\n\\nIt doesn\\'t matter what numbers you choose. There\\'s always a combination that will return the wrong answer.\\n\\n# However\\nMy initial approach was to use a HashMap mapping the Character to an Integer\\xA0U, R == 1 and D, L == -1. Then using the map to track the horizontal and vertical distances. If the final horizontal and vertical are both 0 the robot is back at the origin. Here\\'s a code snippet:\\n\\n```\\npublic boolean judgeCircle(String moves) {\\n        Map<Character, Integer> map = new HashMap<>(); //Map directions to int\\n        int horizontal = 0; //Track horizontal distance\\n        int vertical = 0; //Track vertical distance\\n        \\n        //Map UDLR to values\\n        map.put(\\'U\\', 1);\\n        map.put(\\'D\\', -1);\\n        map.put(\\'L\\', -1);\\n        map.put(\\'R\\', 1);\\n        \\n        //Iterate the moves\\n        for(int i = 0; i < moves.length(); i++) {\\n            char current = moves.charAt(i); //Get the current character\\n            \\n            //If up or down, add the mapped U or D value to vertical\\n            if(current == \\'U\\' || current == \\'D\\') {\\n                vertical += map.get(current);\\n            }\\n            //Else, if left or right, add the mapped L or R value to horizontal\\n            else if(current == \\'L\\' || current == \\'R\\') {\\n                horizontal += map.get(current);\\n            }\\n        }\\n        \\n        return horizontal == 0 && vertical == 0; //If horizontal and vertical are 0 we\\'ve returned to oirigin\\n```\\n\\nBut, we don\\'t need actually need to use two variables and all the extra logic. There\\'s a piece of information we aren\\'t utilizing!\\n\\nWe can get the number of moves from the passed String and use this number as the value for either horizontal or vertical and the other being 1.\\n\\nThere is a limit to this, however. The number of moves, and the value of the combination of moves, need to fit within the actual size of an Integer. But, since the question isn\\'t set up with such constraints and test cases, we can go with it. It\\'s just something to think about and keep in mind.\\n\\nHere\\'s the proper solution:\\n\\n```\\npublic boolean judgeCircle(String moves) {\\n        int numMoves = moves.length(); //Get the number of moves\\n        \\n        //Base case\\n        //If moves is null or empty, robot doesn\\'t move so return true\\n        if(moves == null || numMoves == 0) {\\n            return true;\\n        }\\n        \\n        int[] map = new int[getIndex(\\'U\\')+1]; //Initialize array needed for mapping character to int. Minimizing memory used and avoiding collision handling.\\n        \\n        //Build the map\\n        map[getIndex(\\'U\\')] = 1; //Map U to 1\\n        map[getIndex(\\'D\\')] = -1; //Map D to -1\\n        map[getIndex(\\'L\\')] = numMoves; //Map L to numMoves\\n        map[getIndex(\\'R\\')] = -numMoves; //Map R to -numMoves\\n        \\n        int distance = 0; //Track distance from origin\\n\\t\\t\\n\\t\\t//Iterate through each character in the passed String moves\\n        for (char c : moves.toCharArray()) {\\n            distance += map[getIndex(c)]; //Get value of char from map and add to distance\\n        }\\n        \\n        return distance == 0; //If distance is 0, robot is back at origin so return true. Else, return false.\\n    }\\n    \\n    //getIndex() method - Accepts a character and returns the appropriate index for the map\\n    private int getIndex(char c) {\\n        return Integer.valueOf(c)-Integer.valueOf(\\'D\\'); //Return index\\n    }\\n```\\n\\n**Complexity**\\n***Time***\\nWe iterate through each move (character in the String) ***n***  once. So, time complexity is linear **O(*n*)**.\\n\\n***Space***\\nOur map is always the same size no matter the input. So, space complexity is constant **O(*1*)**.\\n\\nIf you found this helpful, please leave an upvote **:)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean judgeCircle(String moves) {\\n        if (moves == null || moves.isEmpty()) return true;\\n        int[] counts = new int[100];\\n        counts[\\'U\\'] = 1;\\n        counts[\\'D\\'] = -1;\\n        counts[\\'R\\'] = 9;\\n        counts[\\'L\\'] = -9;\\n        \\n        int dist = 0;\\n        for (char ch: moves.toCharArray()) {\\n            dist += counts[ch];\\n        }\\n        \\n        return dist == 0;\\n    }\\n```\n```\\npublic boolean judgeCircle(String moves) {\\n        Map<Character, Integer> map = new HashMap<>(); //Map directions to int\\n        int horizontal = 0; //Track horizontal distance\\n        int vertical = 0; //Track vertical distance\\n        \\n        //Map UDLR to values\\n        map.put(\\'U\\', 1);\\n        map.put(\\'D\\', -1);\\n        map.put(\\'L\\', -1);\\n        map.put(\\'R\\', 1);\\n        \\n        //Iterate the moves\\n        for(int i = 0; i < moves.length(); i++) {\\n            char current = moves.charAt(i); //Get the current character\\n            \\n            //If up or down, add the mapped U or D value to vertical\\n            if(current == \\'U\\' || current == \\'D\\') {\\n                vertical += map.get(current);\\n            }\\n            //Else, if left or right, add the mapped L or R value to horizontal\\n            else if(current == \\'L\\' || current == \\'R\\') {\\n                horizontal += map.get(current);\\n            }\\n        }\\n        \\n        return horizontal == 0 && vertical == 0; //If horizontal and vertical are 0 we\\'ve returned to oirigin\\n```\n```\\npublic boolean judgeCircle(String moves) {\\n        int numMoves = moves.length(); //Get the number of moves\\n        \\n        //Base case\\n        //If moves is null or empty, robot doesn\\'t move so return true\\n        if(moves == null || numMoves == 0) {\\n            return true;\\n        }\\n        \\n        int[] map = new int[getIndex(\\'U\\')+1]; //Initialize array needed for mapping character to int. Minimizing memory used and avoiding collision handling.\\n        \\n        //Build the map\\n        map[getIndex(\\'U\\')] = 1; //Map U to 1\\n        map[getIndex(\\'D\\')] = -1; //Map D to -1\\n        map[getIndex(\\'L\\')] = numMoves; //Map L to numMoves\\n        map[getIndex(\\'R\\')] = -numMoves; //Map R to -numMoves\\n        \\n        int distance = 0; //Track distance from origin\\n\\t\\t\\n\\t\\t//Iterate through each character in the passed String moves\\n        for (char c : moves.toCharArray()) {\\n            distance += map[getIndex(c)]; //Get value of char from map and add to distance\\n        }\\n        \\n        return distance == 0; //If distance is 0, robot is back at origin so return true. Else, return false.\\n    }\\n    \\n    //getIndex() method - Accepts a character and returns the appropriate index for the map\\n    private int getIndex(char c) {\\n        return Integer.valueOf(c)-Integer.valueOf(\\'D\\'); //Return index\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747500,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        map<char,int>mp;\\n        int left=0,right=0,down=0,up=0;\\n        for(int i=0;i<moves.size();i++)\\n        {\\n            if(moves[i]==\\'L\\')\\n                left++;\\n            if(moves[i]==\\'R\\')\\n                right++;\\n            if(moves[i]==\\'U\\')\\n                up++;\\n            if(moves[i]==\\'D\\')\\n                down++;\\n        }\\n        if((left==right)&&(up==down))\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        map<char,int>mp;\\n        int left=0,right=0,down=0,up=0;\\n        for(int i=0;i<moves.size();i++)\\n        {\\n            if(moves[i]==\\'L\\')\\n                left++;\\n            if(moves[i]==\\'R\\')\\n                right++;\\n            if(moves[i]==\\'U\\')\\n                up++;\\n            if(moves[i]==\\'D\\')\\n                down++;\\n        }\\n        if((left==right)&&(up==down))\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544135,
                "title": "java-runtime-beats-99-57",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\n        int x = 0, y = 0;\\n\\n        for (char ch : moves.toCharArray()) {\\n            if (ch == \\'U\\')\\n                y++;\\n            else if (ch == \\'D\\')\\n                y--;\\n            else if (ch == \\'L\\')\\n                x++;\\n            else x--;\\n        }\\n        return (x == 0 && y == 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\n        int x = 0, y = 0;\\n\\n        for (char ch : moves.toCharArray()) {\\n            if (ch == \\'U\\')\\n                y++;\\n            else if (ch == \\'D\\')\\n                y--;\\n            else if (ch == \\'L\\')\\n                x++;\\n            else x--;\\n        }\\n        return (x == 0 && y == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531457,
                "title": "python-3-one-liner",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'L\\')==moves.count(\\'R\\') and moves.count(\\'U\\')==moves.count(\\'D\\')\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'L\\')==moves.count(\\'R\\') and moves.count(\\'U\\')==moves.count(\\'D\\')\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 511725,
                "title": "straightforward-js-solution",
                "content": "```\\nvar judgeCircle = function(moves) {\\n    let xCoord = 0, yCoord = 0;\\n    for (let move of moves) {\\n        if (move === \"R\") xCoord++;\\n        else if (move === \"L\") xCoord--;\\n        else if (move === \"U\") yCoord++;\\n        else if (move === \"D\") yCoord--;\\n    }\\n    if (xCoord === 0 && yCoord === 0) return true;\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar judgeCircle = function(moves) {\\n    let xCoord = 0, yCoord = 0;\\n    for (let move of moves) {\\n        if (move === \"R\") xCoord++;\\n        else if (move === \"L\") xCoord--;\\n        else if (move === \"U\") yCoord++;\\n        else if (move === \"D\") yCoord--;\\n    }\\n    if (xCoord === 0 && yCoord === 0) return true;\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502027,
                "title": "javascript-using-string-replacement",
                "content": "```javascript\\n/**\\n * @param {string} moves\\n * @return {boolean}\\n */\\nvar judgeCircle = function(moves) {\\n  const numL = moves.length - moves.replace(/L/g, \\'\\').length;\\n  const numR = moves.length - moves.replace(/R/g, \\'\\').length;\\n  const numU = moves.length - moves.replace(/U/g, \\'\\').length;\\n  const numD = moves.length - moves.replace(/D/g, \\'\\').length;\\n  return numL === numR && numU === numD;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} moves\\n * @return {boolean}\\n */\\nvar judgeCircle = function(moves) {\\n  const numL = moves.length - moves.replace(/L/g, \\'\\').length;\\n  const numR = moves.length - moves.replace(/R/g, \\'\\').length;\\n  const numU = moves.length - moves.replace(/U/g, \\'\\').length;\\n  const numD = moves.length - moves.replace(/D/g, \\'\\').length;\\n  return numL === numR && numU === numD;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 385629,
                "title": "swift-5-1-solution",
                "content": "```\\nfunc judgeCircle(_ moves: String) -> Bool {\\n\\treturn moves.reduce(into: (0, 0)) {\\n\\t\\tswitch $1 {\\n\\t\\tcase \"R\": $0.0 += 1\\n\\t\\tcase \"L\": $0.0 += -1\\n\\t\\tcase \"U\": $0.1 += 1\\n\\t\\tcase \"D\": $0.1 += -1\\n\\t\\tdefault: break\\n\\t\\t}\\n\\t} == (0, 0)\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc judgeCircle(_ moves: String) -> Bool {\\n\\treturn moves.reduce(into: (0, 0)) {\\n\\t\\tswitch $1 {\\n\\t\\tcase \"R\": $0.0 += 1\\n\\t\\tcase \"L\": $0.0 += -1\\n\\t\\tcase \"U\": $0.1 += 1\\n\\t\\tcase \"D\": $0.1 += -1\\n\\t\\tdefault: break\\n\\t\\t}\\n\\t} == (0, 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376743,
                "title": "python-4-lines-beats-99",
                "content": "```\\ndef judgeCircle(self, moves):\\n        if moves.count(\"U\") ==  moves.count(\"D\") and moves.count(\"L\") ==  moves.count(\"R\"):\\n            return True\\n        return False\\n\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\ndef judgeCircle(self, moves):\\n        if moves.count(\"U\") ==  moves.count(\"D\") and moves.count(\"L\") ==  moves.count(\"R\"):\\n            return True\\n        return False\\n\\t\\t\\t",
                "codeTag": "Python3"
            },
            {
                "id": 372254,
                "title": "python3-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef judgeCircle(self, moves: str) -> bool:\\n\\t\\t\\tdic={\\'D\\':0,\\'U\\':0,\\'L\\':0,\\'R\\':0}\\n\\t\\t\\tfor i in moves:\\n\\t\\t\\t\\tdic[i]+=1\\n\\t\\t\\treturn dic[\\'U\\']==dic[\\'D\\'] and dic[\\'L\\']==dic[\\'R\\']",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef judgeCircle(self, moves: str) -> bool:\\n\\t\\t\\tdic={\\'D\\':0,\\'U\\':0,\\'L\\':0,\\'R\\':0}",
                "codeTag": "Java"
            },
            {
                "id": 331705,
                "title": "python-98-72",
                "content": "```\\ndef judgeCircle(self, moves: str) -> bool:\\n        if moves.count(\\'U\\') == moves.count(\\'D\\') and moves.count(\\'L\\')==moves.count(\\'R\\'):\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\ndef judgeCircle(self, moves: str) -> bool:\\n        if moves.count(\\'U\\') == moves.count(\\'D\\') and moves.count(\\'L\\')==moves.count(\\'R\\'):\\n            return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 328200,
                "title": "a-simple-c-solution",
                "content": "///\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int px = 0, py = 0;\\n        for(int i=0;i<moves.size();i++) {\\n            if(moves[i] == \\'U\\')\\n                py++;\\n            else if(moves[i] == \\'D\\')\\n                py--;\\n            else if(moves[i] == \\'L\\')\\n                px--;\\n            else\\n                px++;\\n        }\\n        if(px == 0 && py == 0)\\n            return true;\\n        return false;\\n    }\\n};\\n///",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int px = 0, py = 0;\\n        for(int i=0;i<moves.size();i++) {\\n            if(moves[i] == \\'U\\')\\n                py++;\\n            else if(moves[i] == \\'D\\')\\n                py--;\\n            else if(moves[i] == \\'L\\')\\n                px--;\\n            else\\n                px++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 285065,
                "title": "scala-1l",
                "content": "```\\ndef judgeCircle(moves: String): Boolean = moves.count(_ == \\'L\\') == moves.count(_ == \\'R\\') && moves.count(_ == \\'U\\') == moves.count(_ == \\'D\\')\\n```",
                "solutionTags": [],
                "code": "```\\ndef judgeCircle(moves: String): Boolean = moves.count(_ == \\'L\\') == moves.count(_ == \\'R\\') && moves.count(_ == \\'U\\') == moves.count(_ == \\'D\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 268336,
                "title": "2-ms-java-solution-beats-99-90",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\n        int arr[];\\n        \\n        arr = new int[26];\\n        \\n        for (char c: moves.toCharArray()) {\\n            arr[c-\\'A\\']++;\\n        }\\n        \\n        return arr[\\'D\\'-\\'A\\']==arr[\\'U\\'-\\'A\\'] &&  arr[\\'L\\'-\\'A\\']==arr[\\'R\\'-\\'A\\'];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\n        int arr[];\\n        \\n        arr = new int[26];\\n        \\n        for (char c: moves.toCharArray()) {\\n            arr[c-\\'A\\']++;\\n        }\\n        \\n        return arr[\\'D\\'-\\'A\\']==arr[\\'U\\'-\\'A\\'] &&  arr[\\'L\\'-\\'A\\']==arr[\\'R\\'-\\'A\\'];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206948,
                "title": "python-use-dict",
                "content": "```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        mapper = {\\n            \"U\": 0,\\n            \"D\": 0,\\n            \"R\": 0,\\n            \"L\": 0\\n        }\\n        \\n        for m in moves:\\n            mapper[m] = mapper[m] + 1\\n        return mapper[\"U\"] == mapper[\"D\"] and mapper[\"L\"] == mapper[\"R\"]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        \"\"\"\\n        :type moves: str\\n        :rtype: bool\\n        \"\"\"\\n        mapper = {\\n            \"U\": 0,\\n            \"D\": 0,\\n            \"R\": 0,\\n            \"L\": 0\\n        }\\n        \\n        for m in moves:\\n            mapper[m] = mapper[m] + 1\\n        return mapper[\"U\"] == mapper[\"D\"] and mapper[\"L\"] == mapper[\"R\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161528,
                "title": "why-my-java-soln-giving-wrong-answer-for-this-case",
                "content": "if(moves.length()==1) return false;\\n        if(moves.length() == 2 && (moves.equalsIgnoreCase(\"LR\") || moves.equalsIgnoreCase(\"RL\") || moves.equalsIgnoreCase(\"UD\") || moves.equalsIgnoreCase(\"DU\")))\\n            return true;\\n\\n        HashMap<Character,Integer> map = new HashMap();\\n        map.put(\\'L\\',0);\\n        map.put(\\'R\\',0);\\n        map.put(\\'U\\',0);\\n        map.put(\\'D\\',0);\\n        int j = 0;\\n        for(int i =0;i<moves.length();i++){\\n            j=map.get(moves.charAt(i));\\n            map.put(moves.charAt(i),j+1);\\n\\n        }\\n        if((map.get(\\'L\\') == map.get(\\'R\\')) && (map.get(\\'U\\') == map.get(\\'D\\')))\\n            return true;\\n        return false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase : \"RULDDLLDLRDUUUURULRURRRRLRULRLULLLRRULULDDRDLRULDRRULLUDDURDLRRUDRUDDURLLLUUDULRUDRLURRDRLLDDLLLDLRLLRUUDUURDRLDUDRUDRLUDULRLUDRLDDUULDDLDURULUDUUDDRRDUURRLRDLDLRLLDRRUUURDLULLURRRRDRRURDUURDLRRUULRURRUULULUUDURUDLRDDDDDURRRLRUDRUULUUUULDURDRULLRRRUDDDUUULUURRDRDDRLLDRLDULDLUUDRDLULLDLDDRUUUUDDRRRDLLLLURUURLRUUULRDDULUULUURDURDDDRRURLURDLLLRLULRDLDDLRDRRRRLUURRRRLDUDLLRUDLDRDLDRUULDRDULRULRRDLDLLLUDLDLULLDURUURRLLULUURLRLRDUDULLDURRUDDLDDLLUDURLLRLDLDUDLURLLDRRURRDUDLDUULDUDRRUDULLUUDURRRURLULDDLRRURULUURURRDULUULDDDUUDRLDDRLULDUDDLLLDLDURDLRLUURDDRLUDRLUDLRRLUUULLDUUDUDURRUULLDDUDLURRDDLURLDRDRUDRLDDLDULDRULUDRRDRLLUURULURRRUDRLLUURULURRLUULRDDDRDDLDRLDRLDUDRLDRLDDLDUDDURUDUDDDLRRDLUUUDUDURLRDRURUDUDDRDRRLUDURULDULDDRLDLUURUULUDRLRLRLLLLRLDRURRRUULRDURDRRDDURULLRDUDRLULRRLLLDRLRLRRDULDDUDUURLRULUUUULURULDLDRDRLDDLRLURRUULRRLDULLUULUDUDRLDUDRDLLDULURLUDDUURULDURRUURLRDRRRLDDULLLLDDRRLRRDRDLRUDUUDLRLDRDRURULDLULRRDLLURDLLDLRDRURLRUDURDRRRULURDRURLDRRRDUDUDUDURUUUUULURDUDDRRDULRDDLULRDRULDRUURRURLUDDDDLDRLDLLLLRLDRLRDRRRLLDRDRUULURLDRULLDRRDUUDLURLLDULDUUDLRRRDDUDRLDULRDLLULRRUURRRURLRRLDDUDDLULRUDULDULRDUDRLRDULRUUDDRUURUDLDRDUDDUULLUDDLLRLURURLRRULLDDDLURDRRDLLLLULLDLUDDLURLLDDRLDLLDDRDRDDUDLDURLUUUUUDLLLRLDULDDRDDDDRUDLULDRRLLLDUUUDDDRDDLLULUULRRULRUDRURDDULURDRRURUULDDDDUULLLURRRRDLDDLRLDDDRLUUDRDDRDDLUDLUUULLDLRDLURRRLRDRLURUURLULLLLRDDLLLLRUDURRLDURULURULDDRULUDRLDRLLURURRRDURURDRRUDLDDLLRRDRDDLRLRLUDUDRRUDLLDUURUURRDUDLRRLRURUDURDLRRULLDLLUDURUDDRUDULLDUDRRDDUDLLLDLRDRUURLLDLDRDDLDLLUDRDDRUUUDDULRUULRDRUDUURRRURUDLURLRDDLUULRDULRDURLLRDDDRRUDDUDUDLLDDRRUUDURDLLUURDLRULULDULRUURUDRULDRDULLULRRDDLDRDLLLDULRRDDLDRDLLRDDRLUUULUURULRULRUDULRULRUURUDUUDLDUDUUURLLURDDDUDUDLRLULDLDUDUULULLRDUDLDRUDRUULRURDDLDDRDULRLRLRRRRLRULDLLLDDRLUDLULLUUDLDRRLUDULRDRLLRRRULRLRLLUDRUUDUDDLRLDRDDDDRDLDRURULULRUURLRDLLDDRLLRUDRRDDRDUDULRUDULURRUDRDLRDUUDDLDRUDLLDDLRLULLLRUUDRRRRUULLRLLULURLDUDDURLRULULDLDRURDRLLURRDLURRURLULDLRLDUDLULLLDRDLULDLRULLLUDUDUDUDLDDDDDRDLUDUULLUDRLUURDRLULD\"",
                "solutionTags": [],
                "code": "if(moves.length()==1) return false;\\n        if(moves.length() == 2 && (moves.equalsIgnoreCase(\"LR\") || moves.equalsIgnoreCase(\"RL\") || moves.equalsIgnoreCase(\"UD\") || moves.equalsIgnoreCase(\"DU\")))\\n            return true;\\n\\n        HashMap<Character,Integer> map = new HashMap();\\n        map.put(\\'L\\',0);\\n        map.put(\\'R\\',0);\\n        map.put(\\'U\\',0);\\n        map.put(\\'D\\',0);\\n        int j = 0;\\n        for(int i =0;i<moves.length();i++){\\n            j=map.get(moves.charAt(i));\\n            map.put(moves.charAt(i),j+1);\\n\\n        }\\n        if((map.get(\\'L\\') == map.get(\\'R\\')) && (map.get(\\'U\\') == map.get(\\'D\\')))\\n            return true;\\n        return false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcase : \"RULDDLLDLRDUUUURULRURRRRLRULRLULLLRRULULDDRDLRULDRRULLUDDURDLRRUDRUDDURLLLUUDULRUDRLURRDRLLDDLLLDLRLLRUUDUURDRLDUDRUDRLUDULRLUDRLDDUULDDLDURULUDUUDDRRDUURRLRDLDLRLLDRRUUURDLULLURRRRDRRURDUURDLRRUULRURRUULULUUDURUDLRDDDDDURRRLRUDRUULUUUULDURDRULLRRRUDDDUUULUURRDRDDRLLDRLDULDLUUDRDLULLDLDDRUUUUDDRRRDLLLLURUURLRUUULRDDULUULUURDURDDDRRURLURDLLLRLULRDLDDLRDRRRRLUURRRRLDUDLLRUDLDRDLDRUULDRDULRULRRDLDLLLUDLDLULLDURUURRLLULUURLRLRDUDULLDURRUDDLDDLLUDURLLRLDLDUDLURLLDRRURRDUDLDUULDUDRRUDULLUUDURRRURLULDDLRRURULUURURRDULUULDDDUUDRLDDRLULDUDDLLLDLDURDLRLUURDDRLUDRLUDLRRLUUULLDUUDUDURRUULLDDUDLURRDDLURLDRDRUDRLDDLDULDRULUDRRDRLLUURULURRRUDRLLUURULURRLUULRDDDRDDLDRLDRLDUDRLDRLDDLDUDDURUDUDDDLRRDLUUUDUDURLRDRURUDUDDRDRRLUDURULDULDDRLDLUURUULUDRLRLRLLLLRLDRURRRUULRDURDRRDDURULLRDUDRLULRRLLLDRLRLRRDULDDUDUURLRULUUUULURULDLDRDRLDDLRLURRUULRRLDULLUULUDUDRLDUDRDLLDULURLUDDUURULDURRUURLRDRRRLDDULLLLDDRRLRRDRDLRUDUUDLRLDRDRURULDLULRRDLLURDLLDLRDRURLRUDURDRRRULURDRURLDRRRDUDUDUDURUUUUULURDUDDRRDULRDDLULRDRULDRUURRURLUDDDDLDRLDLLLLRLDRLRDRRRLLDRDRUULURLDRULLDRRDUUDLURLLDULDUUDLRRRDDUDRLDULRDLLULRRUURRRURLRRLDDUDDLULRUDULDULRDUDRLRDULRUUDDRUURUDLDRDUDDUULLUDDLLRLURURLRRULLDDDLURDRRDLLLLULLDLUDDLURLLDDRLDLLDDRDRDDUDLDURLUUUUUDLLLRLDULDDRDDDDRUDLULDRRLLLDUUUDDDRDDLLULUULRRULRUDRURDDULURDRRURUULDDDDUULLLURRRRDLDDLRLDDDRLUUDRDDRDDLUDLUUULLDLRDLURRRLRDRLURUURLULLLLRDDLLLLRUDURRLDURULURULDDRULUDRLDRLLURURRRDURURDRRUDLDDLLRRDRDDLRLRLUDUDRRUDLLDUURUURRDUDLRRLRURUDURDLRRULLDLLUDURUDDRUDULLDUDRRDDUDLLLDLRDRUURLLDLDRDDLDLLUDRDDRUUUDDULRUULRDRUDUURRRURUDLURLRDDLUULRDULRDURLLRDDDRRUDDUDUDLLDDRRUUDURDLLUURDLRULULDULRUURUDRULDRDULLULRRDDLDRDLLLDULRRDDLDRDLLRDDRLUUULUURULRULRUDULRULRUURUDUUDLDUDUUURLLURDDDUDUDLRLULDLDUDUULULLRDUDLDRUDRUULRURDDLDDRDULRLRLRRRRLRULDLLLDDRLUDLULLUUDLDRRLUDULRDRLLRRRULRLRLLUDRUUDUDDLRLDRDDDDRDLDRURULULRUURLRDLLDDRLLRUDRRDDRDUDULRUDULURRUDRDLRDUUDDLDRUDLLDDLRLULLLRUUDRRRRUULLRLLULURLDUDDURLRULULDLDRURDRLLURRDLURRURLULDLRLDUDLULLLDRDLULDLRULLLUDUDUDUDLDDDDDRDLUDUULLUDRLUURDRLULD\"",
                "codeTag": "Unknown"
            },
            {
                "id": 160255,
                "title": "swift-1-line-code",
                "content": "```\\nreturn moves.filter({$0 == \"U\"}).count == moves.filter({$0 == \"D\"}).count &&\\n            moves.filter({$0 == \"R\"}).count == moves.filter({$0 == \"L\"}).count\\n```",
                "solutionTags": [],
                "code": "```\\nreturn moves.filter({$0 == \"U\"}).count == moves.filter({$0 == \"D\"}).count &&\\n            moves.filter({$0 == \"R\"}).count == moves.filter({$0 == \"L\"}).count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112473,
                "title": "javascript-one-liner",
                "content": "```js\\nvar judgeCircle = function(moves) {\\n    return moves.split('L').length == moves.split('R').length && moves.split('U').length == moves.split('D').length\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar judgeCircle = function(moves) {\\n    return moves.split('L').length == moves.split('R').length && moves.split('U').length == moves.split('D').length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038752,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\t\\t  int a=0,c=0;\\n       for(int i=0;i<moves.length();i++)\\n       {\\n           switch(moves.charAt(i)){\\n               case \\'L\\':a++; break;\\n            case \\'R\\':a--; break;\\n              case \\'U\\':c++; break;\\n                 default:c--; break;\\n           }\\n       }\\n       if(a==0&&c==0)\\n       return true;\\n       else \\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\t\\t  int a=0,c=0;\\n       for(int i=0;i<moves.length();i++)\\n       {\\n           switch(moves.charAt(i)){\\n               case \\'L\\':a++; break;\\n            case \\'R\\':a--; break;\\n              case \\'U\\':c++; break;\\n                 default:c--; break;\\n           }\\n       }\\n       if(a==0&&c==0)\\n       return true;\\n       else \\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914029,
                "title": "c-solution-easy-and-understandable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int a[2]={0};\\n        for (int i=0;i<moves.size();i++)\\n        {\\n            if (moves[i]==\\'U\\')\\n            a[0]=a[0]+1;\\n            else if (moves[i]==\\'D\\')\\n            a[0]=a[0]-1;\\n            else if (moves[i]==\\'R\\')\\n            a[1]=a[1]+1;\\n            else\\n            a[1]=a[1]-1;\\n        }\\n        for (int i=0;i<2;i++)\\n        {\\n            if (a[i]!=0)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int a[2]={0};\\n        for (int i=0;i<moves.size();i++)\\n        {\\n            if (moves[i]==\\'U\\')\\n            a[0]=a[0]+1;\\n            else if (moves[i]==\\'D\\')\\n            a[0]=a[0]-1;\\n            else if (moves[i]==\\'R\\')\\n            a[1]=a[1]+1;\\n            else\\n            a[1]=a[1]-1;\\n        }\\n        for (int i=0;i<2;i++)\\n        {\\n            if (a[i]!=0)\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878448,
                "title": "python3-my-first-explained-solution-faster-than-74-98-memory-beats-62-34-need-help",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought tracking the robot\\'s coordinate would help me find it\\'s current place, so I did track it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can track every move the robot does. Since tuples are **immutable**, we have to use an array.\\n1. If the robot moves up, the y coordinate should **add one**.\\n2. Down, y coordinate should **go down by one**.\\n3. Left, x coordinate **goes down by one**.\\n4. Right, x coordinate **adds one**.\\n# Complexity\\n- Time complexity: O(n) time bro\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: need expert. maybe O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/1fe019c8-a3a5-4de7-b308-b397d1243e2e_1691432620.2749715.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/935a7236-cbc0-4e09-a4f3-05c29a41fbdb_1691432668.5113518.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        original = [0, 0]\\n        robot = [0, 0]\\n        for m in moves:\\n            if m == \"U\":\\n                robot[1] += 1\\n            elif m == \"D\":\\n                robot[1] -= 1\\n            elif m == \"L\":\\n                robot[0] -= 1\\n            else:\\n                robot[0] += 1\\n        return original == robot\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        original = [0, 0]\\n        robot = [0, 0]\\n        for m in moves:\\n            if m == \"U\":\\n                robot[1] += 1\\n            elif m == \"D\":\\n                robot[1] -= 1\\n            elif m == \"L\":\\n                robot[0] -= 1\\n            else:\\n                robot[0] += 1\\n        return original == robot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831978,
                "title": "using-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# If You Like the solution then Upvote at bottom left corner!\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        moves = list(moves)\\n        count_U = moves.count(\\'U\\')\\n        count_D = moves.count(\\'D\\')\\n        count_R = moves.count(\\'R\\')\\n        count_L = moves.count(\\'L\\')\\n        if count_D == count_U and count_R == count_L:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# If You Like the solution then Upvote at bottom left corner!\\nclass Solution(object):\\n    def judgeCircle(self, moves):\\n        moves = list(moves)\\n        count_U = moves.count(\\'U\\')\\n        count_D = moves.count(\\'D\\')\\n        count_R = moves.count(\\'R\\')\\n        count_L = moves.count(\\'L\\')\\n        if count_D == count_U and count_R == count_L:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799703,
                "title": "c-very-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int x = 0, y = 0;\\n        for (char& move : moves) {\\n            switch (move) {\\n                case \\'U\\': y++; break;\\n                case \\'D\\': y--; break;\\n                case \\'L\\': x--; break;\\n                case \\'R\\': x++; break;\\n            }\\n        }\\n        return x == 0 && y == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int x = 0, y = 0;\\n        for (char& move : moves) {\\n            switch (move) {\\n                case \\'U\\': y++; break;\\n                case \\'D\\': y--; break;\\n                case \\'L\\': x--; break;\\n                case \\'R\\': x++; break;\\n            }\\n        }\\n        return x == 0 && y == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789264,
                "title": "golang-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc judgeCircle(moves string) bool {\\n  return strings.Count(moves, \"U\") == strings.Count(moves, \"D\") && strings.Count(moves, \"R\") == strings.Count(moves, \"L\")    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc judgeCircle(moves string) bool {\\n  return strings.Count(moves, \"U\") == strings.Count(moves, \"D\") && strings.Count(moves, \"R\") == strings.Count(moves, \"L\")    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597059,
                "title": "100-runtime-beat-c-solution",
                "content": "# Approach:- Left steps must be equal to right steps and upper must be equal to down .\\n# Complexity\\n- Time complexity:- Linear\\n- Space complexity:- Constant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string m) {\\n        int l=0,d=0;\\n        for(int i=0;i<m.size();i++)\\n            switch(m[i])\\n            {   case \\'R\\':l--;break;\\n                case \\'L\\':l++;break;\\n                case \\'U\\':d--;break;\\n                default:d++;    }\\n        if(l==0 and d==0)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string m) {\\n        int l=0,d=0;\\n        for(int i=0;i<m.size();i++)\\n            switch(m[i])\\n            {   case \\'R\\':l--;break;\\n                case \\'L\\':l++;break;\\n                case \\'U\\':d--;break;\\n                default:d++;    }\\n        if(l==0 and d==0)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594729,
                "title": "easiest-c-beginner-freindly-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n\\n        // map to store the counts of R,L,D,U\\n        map<int,int>mp;\\n        for(int i=0;i<moves.size();i++){\\n            mp[moves[i]]++;\\n        }\\n\\n       // yadi R hai toh L hona hi chahiye apne position per vapas ane ke liye\\uD83D\\uDE01\\n        if(mp[\\'R\\']!=mp[\\'L\\'])return false;\\n        if(mp[\\'U\\']!=mp[\\'D\\'])return false;\\n        return true;\\n    }\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) just to store the elements\\n\\n- Space complexity:\\nO(n)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n\\n        // map to store the counts of R,L,D,U\\n        map<int,int>mp;\\n        for(int i=0;i<moves.size();i++){\\n            mp[moves[i]]++;\\n        }\\n\\n       // yadi R hai toh L hona hi chahiye apne position per vapas ane ke liye\\uD83D\\uDE01\\n        if(mp[\\'R\\']!=mp[\\'L\\'])return false;\\n        if(mp[\\'U\\']!=mp[\\'D\\'])return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545736,
                "title": "one-line-solution-in-c-with-approach",
                "content": "In this approach, I have utilize the count function from the algorithm library to count the occurrences of \\'U\\', \\'D\\', \\'L\\', and \\'R\\' in the moves string. I have then compare the counts of \\'U\\' and \\'D\\' to check if they are equal, and the counts of \\'L\\' and \\'R\\' to check if they are equal. If both conditions are true, indicating that the robot returns to the origin, the function returns true; otherwise, it returns false.\\n``` \\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        return (count(moves.begin(), moves.end(), \\'U\\') == count(moves.begin(), moves.end(), \\'D\\')) &&\\n               (count(moves.begin(), moves.end(), \\'L\\') == count(moves.begin(), moves.end(), \\'R\\'));\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        return (count(moves.begin(), moves.end(), \\'U\\') == count(moves.begin(), moves.end(), \\'D\\')) &&\\n               (count(moves.begin(), moves.end(), \\'L\\') == count(moves.begin(), moves.end(), \\'R\\'));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3496965,
                "title": "c-hashing-without-hashing",
                "content": "## Hashing\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        map<char,int> mp;\\n        for (int i=0; i<moves.size(); i++){\\n            mp[moves[i]]++;\\n        }\\n        return (mp[\\'L\\']==mp[\\'R\\'] && mp[\\'U\\']==mp[\\'D\\']);\\n    }\\n};\\n```\\n\\n## Without Hashing\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int h=0, v=0;\\n        for (int i=0; i<moves.size(); i++){\\n            if (moves[i]==\\'L\\')h--;\\n            else if (moves[i]==\\'R\\')h++;\\n            else if (moves[i]==\\'U\\')v++;\\n            else v--;\\n        }\\n        return (h==0 && v==0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        map<char,int> mp;\\n        for (int i=0; i<moves.size(); i++){\\n            mp[moves[i]]++;\\n        }\\n        return (mp[\\'L\\']==mp[\\'R\\'] && mp[\\'U\\']==mp[\\'D\\']);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int h=0, v=0;\\n        for (int i=0; i<moves.size(); i++){\\n            if (moves[i]==\\'L\\')h--;\\n            else if (moves[i]==\\'R\\')h++;\\n            else if (moves[i]==\\'U\\')v++;\\n            else v--;\\n        }\\n        return (h==0 && v==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395370,
                "title": "c-solution-92-8-time-86-36-space-count-moves",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves);\\n};\\n/*******************************************************/\\nbool Solution::judgeCircle(string moves) {\\n    if (moves.size() % 2 != 0) {\\n        return false;\\n    }\\n    int i, size = moves.size();\\n    vector<short> v(4,0); /* U -> 0, D-> 1, L -> 2, R -> 3 */\\n    for (i = 0; i < size; ++i) {\\n        if (moves[i] == \\'U\\') {\\n            ++v[0];\\n        } else if (moves[i] == \\'D\\') {\\n            ++v[1];\\n        } else if (moves[i] == \\'L\\') {\\n            ++v[2];\\n        } else if (moves[i] == \\'R\\') {\\n            ++v[3];\\n        }\\n    }\\n    if (v[0] == v[1] && v[2] == v[3]) {\\n        return true;\\n    }\\n    return false;\\n}\\n/*******************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves);\\n};\\n/*******************************************************/\\nbool Solution::judgeCircle(string moves) {\\n    if (moves.size() % 2 != 0) {\\n        return false;\\n    }\\n    int i, size = moves.size();\\n    vector<short> v(4,0); /* U -> 0, D-> 1, L -> 2, R -> 3 */\\n    for (i = 0; i < size; ++i) {\\n        if (moves[i] == \\'U\\') {\\n            ++v[0];\\n        } else if (moves[i] == \\'D\\') {\\n            ++v[1];\\n        } else if (moves[i] == \\'L\\') {\\n            ++v[2];\\n        } else if (moves[i] == \\'R\\') {\\n            ++v[3];\\n        }\\n    }\\n    if (v[0] == v[1] && v[2] == v[3]) {\\n        return true;\\n    }\\n    return false;\\n}\\n/*******************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328818,
                "title": "power-of-2-hashmap-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need a data structure to store what would be the opposite move to neutralise the current move .\\nAfter that  we need a data structure to check if the opposite move is already been taken in the past  which can neutralise my current move .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) \\n- in the worst case when all the characters get inserted into the map without getting neutralised\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char,char> mp1({{\\'L\\',\\'R\\'},{\\'R\\',\\'L\\'},{\\'U\\',\\'D\\'},{\\'D\\',\\'U\\'}});\\n        unordered_map<char,int> mp2;\\n\\n        for(auto ch:moves)\\n        {\\n            char op=mp1[ch];\\n            if(mp2.find(op)==mp2.end()) mp2[ch]++;\\n            else{\\n                mp2[op]--;\\n                if(mp2[op]==0) mp2.erase(op);\\n            }\\n        }\\n\\n        return mp2.size()==0;\\n        \\n        \\n    }\\n};\\n```\\n//PLEASE UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char,char> mp1({{\\'L\\',\\'R\\'},{\\'R\\',\\'L\\'},{\\'U\\',\\'D\\'},{\\'D\\',\\'U\\'}});\\n        unordered_map<char,int> mp2;\\n\\n        for(auto ch:moves)\\n        {\\n            char op=mp1[ch];\\n            if(mp2.find(op)==mp2.end()) mp2[ch]++;\\n            else{\\n                mp2[op]--;\\n                if(mp2[op]==0) mp2.erase(op);\\n            }\\n        }\\n\\n        return mp2.size()==0;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323163,
                "title": "c-solution-using-hash-map-easy-approach-100-working-fine",
                "content": "# Intuition\\nWe will use hash map to map every move with its corresponding number of times it occurs.\\n\\n# Approach\\nfirst we will traverse in the string and take every char and map it with its count. Then we will check if count of every move is same or not. If yes then we will return true else we will return false.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        if(moves.length()==0){  // if string is empty return true\\n            return true;\\n        }\\n\\n        unordered_map<char,int> um;\\n\\n        for(int i=0;i<moves.length();i++){\\n            um[moves[i]]++;  //here we are mapping char with its count\\n        }\\n\\n        if(um[\\'L\\']==um[\\'R\\'] && um[\\'U\\']==um[\\'D\\']){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        if(moves.length()==0){  // if string is empty return true\\n            return true;\\n        }\\n\\n        unordered_map<char,int> um;\\n\\n        for(int i=0;i<moves.length();i++){\\n            um[moves[i]]++;  //here we are mapping char with its count\\n        }\\n\\n        if(um[\\'L\\']==um[\\'R\\'] && um[\\'U\\']==um[\\'D\\']){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291566,
                "title": "c-consised-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int ctr=0;\\n        int ctl=0;\\n        int ctu=0;\\n        int ctd=0;\\n\\n        for(auto i:moves)\\n        {\\n            if(i==\\'R\\')\\n            ctr++;\\n            if(i==\\'L\\')\\n            ctl++;\\n            if(i==\\'U\\')\\n            ctu++;\\n            if(i==\\'D\\')\\n            ctd++;\\n\\n        }\\n        if(ctr==ctl && ctu==ctd)\\n        return true;\\n\\n        else\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int ctr=0;\\n        int ctl=0;\\n        int ctu=0;\\n        int ctd=0;\\n\\n        for(auto i:moves)\\n        {\\n            if(i==\\'R\\')\\n            ctr++;\\n            if(i==\\'L\\')\\n            ctl++;\\n            if(i==\\'U\\')\\n            ctu++;\\n            if(i==\\'D\\')\\n            ctd++;\\n\\n        }\\n        if(ctr==ctl && ctu==ctd)\\n        return true;\\n\\n        else\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238562,
                "title": "javascript-reduce",
                "content": "```\\nconst judgeCircle = moves => {\\n  const res = [...moves].reduce((pos, c) => {\\n    switch(c) {\\n      case \\'U\\': return [pos[0], pos[1] + 1];\\n      case \\'D\\': return [pos[0], pos[1] - 1];\\n      case \\'R\\': return [pos[0] + 1, pos[1]];\\n      case \\'L\\': return [pos[0] - 1, pos[1]];\\n    }\\n  }, [0, 0]);\\n\\n  return res.every(a => a === 0);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst judgeCircle = moves => {\\n  const res = [...moves].reduce((pos, c) => {\\n    switch(c) {\\n      case \\'U\\': return [pos[0], pos[1] + 1];\\n      case \\'D\\': return [pos[0], pos[1] - 1];\\n      case \\'R\\': return [pos[0] + 1, pos[1]];\\n      case \\'L\\': return [pos[0] - 1, pos[1]];\\n    }\\n  }, [0, 0]);\\n\\n  return res.every(a => a === 0);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3091780,
                "title": "ruby-solution-easy-to-understand",
                "content": "```\\n# @param {String} moves\\n# @return {Boolean}\\ndef judge_circle(moves)\\n    moves.count(\\'D\\') == moves.count(\\'U\\') && moves.count(\\'L\\') == moves.count(\\'R\\')\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} moves\\n# @return {Boolean}\\ndef judge_circle(moves)\\n    moves.count(\\'D\\') == moves.count(\\'U\\') && moves.count(\\'L\\') == moves.count(\\'R\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3072507,
                "title": "golang-solution-100",
                "content": "# Golang Solution\\n```\\nfunc judgeCircle(moves string) bool {\\n    \\tmm := make(map[byte]int)\\n\\tfor i := 0; i <= len(moves)-1; i++ {\\n\\t\\tmm[moves[i]]++\\n\\t}\\n\\treturn mm[\\'U\\'] == mm[\\'D\\'] && mm[\\'L\\'] == mm[\\'R\\']\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc judgeCircle(moves string) bool {\\n    \\tmm := make(map[byte]int)\\n\\tfor i := 0; i <= len(moves)-1; i++ {\\n\\t\\tmm[moves[i]]++\\n\\t}\\n\\treturn mm[\\'U\\'] == mm[\\'D\\'] && mm[\\'L\\'] == mm[\\'R\\']\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3051575,
                "title": "scala-simulation",
                "content": "# Code\\n```\\nobject Solution {\\n  def judgeCircle(moves: String): Boolean = {\\n    def impl(seq: Seq[Char], acc: (Int,Int) = (0,0)): Boolean = {\\n      if(seq.isEmpty) acc == (0,0)\\n      else seq.head match {\\n        case \\'R\\' => impl(seq.tail, (acc._1+1, acc._2))\\n        case \\'L\\' => impl(seq.tail, (acc._1-1, acc._2))\\n        case \\'U\\' => impl(seq.tail, (acc._1, acc._2+1))\\n        case \\'D\\' => impl(seq.tail, (acc._1, acc._2-1))\\n        case _ => ???\\n      }\\n    }\\n    impl(moves.toList)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def judgeCircle(moves: String): Boolean = {\\n    def impl(seq: Seq[Char], acc: (Int,Int) = (0,0)): Boolean = {\\n      if(seq.isEmpty) acc == (0,0)\\n      else seq.head match {\\n        case \\'R\\' => impl(seq.tail, (acc._1+1, acc._2))\\n        case \\'L\\' => impl(seq.tail, (acc._1-1, acc._2))\\n        case \\'U\\' => impl(seq.tail, (acc._1, acc._2+1))\\n        case \\'D\\' => impl(seq.tail, (acc._1, acc._2-1))\\n        case _ => ???\\n      }\\n    }\\n    impl(moves.toList)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3049996,
                "title": "c-solution-using-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI bet I could do this in one line using LINQ.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI did it in one line using LINQ.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool JudgeCircle(string moves) {\\n        return moves.Count(x => x == \\'L\\') == moves.Count(x => x == \\'R\\')\\n            && moves.Count(x => x == \\'U\\') == moves.Count(x => x == \\'D\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool JudgeCircle(string moves) {\\n        return moves.Count(x => x == \\'L\\') == moves.Count(x => x == \\'R\\')\\n            && moves.Count(x => x == \\'U\\') == moves.Count(x => x == \\'D\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975927,
                "title": "best-easy-solution-in-python",
                "content": "# Intuition\\nFIND FREQUENCY\\n\\n# Approach\\nWE HAVE TO CALCULATE TE FREQUENCY FIRST ONE IS POSITIVE AND OPPOSITE SIDE WITH NEGATIVE SYMBOL \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        a=0\\n        b=0\\n        c=0\\n        d=0\\n        for i in moves:\\n            if i==\\'U\\':\\n                a+=1\\n            elif i==\\'D\\':\\n                b-=1\\n            elif i==\\'L\\':\\n                c+=1\\n            elif i==\\'R\\':\\n                d-=1\\n        e=a+b\\n        f=c+d\\n        if e==0 and f==0:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        a=0\\n        b=0\\n        c=0\\n        d=0\\n        for i in moves:\\n            if i==\\'U\\':\\n                a+=1\\n            elif i==\\'D\\':\\n                b-=1\\n            elif i==\\'L\\':\\n                c+=1\\n            elif i==\\'R\\':\\n                d-=1\\n        e=a+b\\n        f=c+d\\n        if e==0 and f==0:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962606,
                "title": "lazy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int count=0;\\n        for(int i=0;i<moves.size();i++){\\n            if(moves[i]==\\'U\\') count++;\\n            if(moves[i]==\\'D\\') count--;\\n        }\\n        if(count!=0) return false;\\n        for(int i=0;i<moves.size();i++){\\n            if(moves[i]==\\'R\\') count++;\\n            if(moves[i]==\\'L\\') count--;\\n        }\\n        if(count!=0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int count=0;\\n        for(int i=0;i<moves.size();i++){\\n            if(moves[i]==\\'U\\') count++;\\n            if(moves[i]==\\'D\\') count--;\\n        }\\n        if(count!=0) return false;\\n        for(int i=0;i<moves.size();i++){\\n            if(moves[i]==\\'R\\') count++;\\n            if(moves[i]==\\'L\\') count--;\\n        }\\n        if(count!=0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861462,
                "title": "c-using-maps-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string s) \\n    {\\n        map<string,int> m;\\n        int len=s.length();\\n        int u,d,l,r;\\n        u=d=l=r=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(s[i]==\\'U\\')\\n                u++;\\n            if(s[i]==\\'D\\')\\n                d++;\\n            if(s[i]==\\'L\\')\\n                l++;\\n            if(s[i]==\\'R\\')\\n                r++;\\n        }\\n        m.insert(pair<string,int>(\"U\",u));\\n        m.insert(pair<string,int>(\"D\",d));\\n        m.insert(pair<string,int>(\"L\",l));\\n        m.insert(pair<string,int>(\"R\",r));\\n        if(m.at(\"U\")-m.at(\"D\") != 0 || m.at(\"L\")-m.at(\"R\") !=0)\\n            return false;\\n        else\\n            return true;\\n    }\\n};\\n```\\nWe have map with 4 sides U D L and R for the direction and we count the number of moves each.\\n\\nTo return back to (0,0) the negations of opposite sides should be zero,\\n\\nSay:  we go UU then to get back to (0,0) we must have DD to negate the U. \\nHope this helps",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string s) \\n    {\\n        map<string,int> m;\\n        int len=s.length();\\n        int u,d,l,r;\\n        u=d=l=r=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            if(s[i]==\\'U\\')\\n                u++;\\n            if(s[i]==\\'D\\')\\n                d++;\\n            if(s[i]==\\'L\\')\\n                l++;\\n            if(s[i]==\\'R\\')\\n                r++;\\n        }\\n        m.insert(pair<string,int>(\"U\",u));\\n        m.insert(pair<string,int>(\"D\",d));\\n        m.insert(pair<string,int>(\"L\",l));\\n        m.insert(pair<string,int>(\"R\",r));\\n        if(m.at(\"U\")-m.at(\"D\") != 0 || m.at(\"L\")-m.at(\"R\") !=0)\\n            return false;\\n        else\\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812857,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhashmap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nstore key value pairs of right,left,up and down with same but opp signs then iterate thorugh the moves and keep adding the values of the keys at every step if the final sum = 0 return true else false\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char,int>m;\\n        m[\\'L\\']=-1;\\n        m[\\'R\\']=1;\\n        m[\\'U\\']=1000;\\n        m[\\'D\\']=-1000;\\n        int c=0;\\n        for(int i=0;i<moves.size();i++)\\n        {\\n            c+=m[moves[i]];\\n        }\\n        return c==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char,int>m;\\n        m[\\'L\\']=-1;\\n        m[\\'R\\']=1;\\n        m[\\'U\\']=1000;\\n        m[\\'D\\']=-1000;\\n        int c=0;\\n        for(int i=0;i<moves.size();i++)\\n        {\\n            c+=m[moves[i]];\\n        }\\n        return c==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689214,
                "title": "java-very-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\n        //Suppose L = -1, R = 1, U = 1, D = -1\\n\\n        //if the length of the stirng is odd, the robot will never be on the same origin\\n        //hence we can return false\\n        if (moves.length() % 2 == 1)\\n        {\\n            return false;\\n        } \\n\\n        //Increase or Decrease this if up and down respectively\\n        int vertical = 0;\\n        //Increase or Decrease this if right and left respectively\\n        int horizontal = 0;\\n\\n        //Iterating through each element in the moves\\n        for (char element : moves.toCharArray()) \\n        {\\n            if (element == \\'U\\') \\n            {\\n                vertical++;\\n            }\\n            else if (element == \\'D\\')\\n            {\\n                vertical--;\\n            } \\n            else if (element == \\'L\\') \\n            {\\n                horizontal--;\\n            }\\n            else \\n            {\\n                horizontal++;\\n            }\\n        }\\n\\n        //if both are 0 that means robot is back to the origin\\n        return vertical == 0 && horizontal == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n\\n        //Suppose L = -1, R = 1, U = 1, D = -1\\n\\n        //if the length of the stirng is odd, the robot will never be on the same origin\\n        //hence we can return false\\n        if (moves.length() % 2 == 1)\\n        {\\n            return false;\\n        } \\n\\n        //Increase or Decrease this if up and down respectively\\n        int vertical = 0;\\n        //Increase or Decrease this if right and left respectively\\n        int horizontal = 0;\\n\\n        //Iterating through each element in the moves\\n        for (char element : moves.toCharArray()) \\n        {\\n            if (element == \\'U\\') \\n            {\\n                vertical++;\\n            }\\n            else if (element == \\'D\\')\\n            {\\n                vertical--;\\n            } \\n            else if (element == \\'L\\') \\n            {\\n                horizontal--;\\n            }\\n            else \\n            {\\n                horizontal++;\\n            }\\n        }\\n\\n        //if both are 0 that means robot is back to the origin\\n        return vertical == 0 && horizontal == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633708,
                "title": "657",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0 , y = 0 ;\\n\\t\\tfor (int i = 0; i < moves.length(); i++) {\\n\\t\\t\\tif (moves.charAt(i)==\\'L\\') x++;\\n\\t\\t\\tif (moves.charAt(i)==\\'R\\') x--;\\n\\t\\t\\tif (moves.charAt(i)==\\'U\\') y++;\\n\\t\\t\\tif (moves.charAt(i)==\\'D\\') y--;\\n\\t\\t}\\n\\t\\tif (x==0&&y==0) {\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x = 0 , y = 0 ;\\n\\t\\tfor (int i = 0; i < moves.length(); i++) {\\n\\t\\t\\tif (moves.charAt(i)==\\'L\\') x++;\\n\\t\\t\\tif (moves.charAt(i)==\\'R\\') x--;\\n\\t\\t\\tif (moves.charAt(i)==\\'U\\') y++;\\n\\t\\t\\tif (moves.charAt(i)==\\'D\\') y--;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2592397,
                "title": "c-easy-solution-low-t-c",
                "content": "```\\n int size=s.length();\\n    \\n    if(size%2!=0)\\n        return 0;\\n    \\n    int up=0,down=0,left=0,right=0;\\n    \\n    for(int i =0;i<size;i++)\\n    {\\n        if(s[i]==\\'U\\')\\n        {up++;}\\n        else\\n            if(s[i]==\\'D\\')\\n            {down++;}\\n        else\\n            if(s[i]==\\'L\\')\\n            {left++;}\\n        else\\n        {right++;}\\n    }\\n    \\n    if(up!=down||right!=left)\\n        return 0;\\n    else\\n      return 1;",
                "solutionTags": [],
                "code": "```\\n int size=s.length();\\n    \\n    if(size%2!=0)\\n        return 0;\\n    \\n    int up=0,down=0,left=0,right=0;\\n    \\n    for(int i =0;i<size;i++)\\n    {\\n        if(s[i]==\\'U\\')\\n        {up++;}\\n        else\\n            if(s[i]==\\'D\\')\\n            {down++;}\\n        else\\n            if(s[i]==\\'L\\')\\n            {left++;}\\n        else\\n        {right++;}\\n    }\\n    \\n    if(up!=down||right!=left)\\n        return 0;\\n    else\\n      return 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2575739,
                "title": "left-is-inverse-of-right-same-goes-with-up-and-down",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string m) {\\n        int val = 0;\\n        for(auto i: m)\\n        {\\n            if(i==\\'R\\')\\n                val+=1;\\n            if(i==\\'L\\')\\n                val-=1;\\n        }\\n        \\n        if(val!=0)\\n            return false;\\n        \\n         for(auto i: m)\\n        {\\n            if(i==\\'U\\')\\n                val+=1;\\n            if(i==\\'D\\')\\n                val-=1;\\n        }\\n        \\n        return val==0;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string m) {\\n        int val = 0;\\n        for(auto i: m)\\n        {\\n            if(i==\\'R\\')\\n                val+=1;\\n            if(i==\\'L\\')\\n                val-=1;\\n        }\\n        \\n        if(val!=0)\\n            return false;\\n        \\n         for(auto i: m)\\n        {\\n            if(i==\\'U\\')\\n                val+=1;\\n            if(i==\\'D\\')\\n                val-=1;\\n        }\\n        \\n        return val==0;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543068,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        char[] arr = moves.toCharArray();\\n        int U = 0;\\n        int D = 0;\\n        int L = 0;\\n        int R = 0;\\n        for(char ch : arr) {\\n            if (ch == \\'U\\') {\\n                U++;\\n            }\\n            else if(ch == \\'D\\') {\\n                D++;\\n            }\\n            else if(ch == \\'L\\') {\\n                L++;\\n            }\\n            else if(ch == \\'R\\') {\\n                R++;\\n            }\\n        }\\n        if ((U-D) == 0 && (L-R) == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        char[] arr = moves.toCharArray();\\n        int U = 0;\\n        int D = 0;\\n        int L = 0;\\n        int R = 0;\\n        for(char ch : arr) {\\n            if (ch == \\'U\\') {\\n                U++;\\n            }\\n            else if(ch == \\'D\\') {\\n                D++;\\n            }\\n            else if(ch == \\'L\\') {\\n                L++;\\n            }\\n            else if(ch == \\'R\\') {\\n                R++;\\n            }\\n        }\\n        if ((U-D) == 0 && (L-R) == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509267,
                "title": "100-faster-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x=0,y=0;\\n        for(char a:moves.toCharArray()){\\n            if(a==\\'U\\')   x++;\\n            else if(a==\\'D\\')  x--;\\n            else if(a==\\'L\\')  y--;\\n            else y++;\\n        }\\n        return x==0&&y==0?true:false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int x=0,y=0;\\n        for(char a:moves.toCharArray()){\\n            if(a==\\'U\\')   x++;\\n            else if(a==\\'D\\')  x--;\\n            else if(a==\\'L\\')  y--;\\n            else y++;\\n        }\\n        return x==0&&y==0?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501320,
                "title": "easy-solution",
                "content": "```\\nbool judgeCircle(string moves) {\\n        \\n        int u=0,d=0, l=0,r=0;\\n        \\n        for(auto x : moves){\\n            \\n            if (x==\\'U\\') u++;\\n            \\n            else if (x==\\'D\\') d++;\\n            \\n            else if (x==\\'L\\') l++;\\n            \\n            else r++;\\n        }\\n        \\n        \\n            return (u!=d || l!=r) ? false : true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool judgeCircle(string moves) {\\n        \\n        int u=0,d=0, l=0,r=0;\\n        \\n        for(auto x : moves){\\n            \\n            if (x==\\'U\\') u++;\\n            \\n            else if (x==\\'D\\') d++;\\n            \\n            else if (x==\\'L\\') l++;\\n            \\n            else r++;\\n        }\\n        \\n        \\n            return (u!=d || l!=r) ? false : true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2488206,
                "title": "js-easy-solution-with-o-n-100",
                "content": "```\\nconst MOVE = {\\n    \"R\": [0, 1],\\n    \"L\": [0, -1],\\n    \"U\": [-1, 0],\\n    \"D\": [1, 0],\\n}\\n\\nvar judgeCircle = function(moves) {\\n    const current = [0, 0];\\n    \\n    for (let i = 0; i < moves.length; i++) {\\n        current[0] += MOVE[moves[i]][0];\\n        current[1] += MOVE[moves[i]][1];\\n    }\\n    \\n    return !current[0] && !current[1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst MOVE = {\\n    \"R\": [0, 1],\\n    \"L\": [0, -1],\\n    \"U\": [-1, 0],\\n    \"D\": [1, 0],\\n}\\n\\nvar judgeCircle = function(moves) {\\n    const current = [0, 0];\\n    \\n    for (let i = 0; i < moves.length; i++) {\\n        current[0] += MOVE[moves[i]][0];\\n        current[1] += MOVE[moves[i]][1];\\n    }\\n    \\n    return !current[0] && !current[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2483158,
                "title": "java-hardcode-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int countl =0;\\n        int countr =0;\\n        int countu =0;\\n        int countd =0;\\n        for(int i=0 ; i<moves.length();i++){\\n            if(moves.charAt(i) == \\'L\\'){\\n                countl++;\\n            }\\n            if(moves.charAt(i) == \\'R\\'){\\n                countr++;\\n            }\\n            if(moves.charAt(i) == \\'U\\'){\\n                countu++;\\n            }\\n            if(moves.charAt(i) == \\'D\\'){\\n                countd++;\\n            }\\n            \\n        }\\n        \\n        if(countl == countr && countu == countd){\\n            return true;        \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int countl =0;\\n        int countr =0;\\n        int countu =0;\\n        int countd =0;\\n        for(int i=0 ; i<moves.length();i++){\\n            if(moves.charAt(i) == \\'L\\'){\\n                countl++;\\n            }\\n            if(moves.charAt(i) == \\'R\\'){\\n                countr++;\\n            }\\n            if(moves.charAt(i) == \\'U\\'){\\n                countu++;\\n            }\\n            if(moves.charAt(i) == \\'D\\'){\\n                countd++;\\n            }\\n            \\n        }\\n        \\n        if(countl == countr && countu == countd){\\n            return true;        \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468980,
                "title": "easy-java-solution",
                "content": "```\\n  int[] position = {0,0};\\n        \\n        for(int i = 0; i < moves.length(); i++) {\\n            if(moves.charAt(i) == \\'U\\') {\\n                position[1] = position[1] + 1;\\n            } else if(moves.charAt(i) == \\'D\\') {\\n                position[1] = position[1] - 1;\\n            } else if (moves.charAt(i) == \\'R\\') {\\n                position[0] = position[0] + 1;\\n            } else {\\n                position[0] = position[0] - 1;\\n            }\\n        }\\n        \\n        return position[0] == 0 && position[1] == 0;\\n```\\n**Thubs up if you like sol**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  int[] position = {0,0};\\n        \\n        for(int i = 0; i < moves.length(); i++) {\\n            if(moves.charAt(i) == \\'U\\') {\\n                position[1] = position[1] + 1;\\n            } else if(moves.charAt(i) == \\'D\\') {\\n                position[1] = position[1] - 1;\\n            } else if (moves.charAt(i) == \\'R\\') {\\n                position[0] = position[0] + 1;\\n            } else {\\n                position[0] = position[0] - 1;\\n            }\\n        }\\n        \\n        return position[0] == 0 && position[1] == 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2460970,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        //(x,y)\\n        //(x + 1, y) == right move\\n        //(x - 1, y) == left move\\n        //(x, y + 1) == up move\\n        //(x, y - 1) == down move\\n        \\n        int[] position = {0,0};\\n        \\n        for(int i = 0; i < moves.length(); i++) {\\n            if(moves.charAt(i) == \\'U\\') {\\n                position[1] = position[1] + 1;\\n            } else if(moves.charAt(i) == \\'D\\') {\\n                position[1] = position[1] - 1;\\n            } else if (moves.charAt(i) == \\'R\\') {\\n                position[0] = position[0] + 1;\\n            } else {\\n                position[0] = position[0] - 1;\\n            }\\n        }\\n        \\n        return position[0] == 0 && position[1] == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        //(x,y)\\n        //(x + 1, y) == right move\\n        //(x - 1, y) == left move\\n        //(x, y + 1) == up move\\n        //(x, y - 1) == down move\\n        \\n        int[] position = {0,0};\\n        \\n        for(int i = 0; i < moves.length(); i++) {\\n            if(moves.charAt(i) == \\'U\\') {\\n                position[1] = position[1] + 1;\\n            } else if(moves.charAt(i) == \\'D\\') {\\n                position[1] = position[1] - 1;\\n            } else if (moves.charAt(i) == \\'R\\') {\\n                position[0] = position[0] + 1;\\n            } else {\\n                position[0] = position[0] - 1;\\n            }\\n        }\\n        \\n        return position[0] == 0 && position[1] == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459232,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n       int n= moves.size();\\n        int x=0;\\n        int y=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(moves[i]==\\'R\\')\\n                x++;\\n            if(moves[i]==\\'L\\')\\n                x--;\\n            if(moves[i]==\\'U\\')\\n                y++;\\n            if(moves[i]==\\'D\\')\\n                y--;\\n        }\\n        if(x==0&&y==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n       int n= moves.size();\\n        int x=0;\\n        int y=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(moves[i]==\\'R\\')\\n                x++;\\n            if(moves[i]==\\'L\\')\\n                x--;\\n            if(moves[i]==\\'U\\')\\n                y++;\\n            if(moves[i]==\\'D\\')\\n                y--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2443088,
                "title": "657-python-code",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        a = [0,0,0,0]\\n        for index in moves:\\n            if index == \"U\":\\n                a[0] += 1\\n            elif index == \"D\":\\n                a[1] += 1\\n            elif index == \"L\":\\n                a[2] += 1\\n            else:\\n                a[3] += 1\\n        return a[0] == a[1] and a[2] == a[3]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        a = [0,0,0,0]\\n        for index in moves:\\n            if index == \"U\":\\n                a[0] += 1\\n            elif index == \"D\":\\n                a[1] += 1\\n            elif index == \"L\":\\n                a[2] += 1\\n            else:\\n                a[3] += 1\\n        return a[0] == a[1] and a[2] == a[3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432331,
                "title": "c-easy-solution-using-simple-loop-if-else-condition-very-easy",
                "content": "# *Easy Solution Using Loop*\\n\\n#### class Solution {\\n#### public:\\n####     bool judgeCircle(string moves) {\\n####         int n = moves.length();\\n####         int movesLR = 0;\\n####         int movesUD = 0;\\n####         for(int i=0;i<n;i++)\\n####         {\\n####             if(moves[i]==\\'R\\')\\n####             {\\n####                 movesLR--;\\n####             }\\n####             else if(moves[i]==\\'L\\')\\n####             {\\n####                 movesLR++;\\n####             }\\n####             else if(moves[i]==\\'U\\')\\n####             {\\n####                 movesUD--;\\n####             }\\n####             else if(moves[i]==\\'D\\')\\n####             {\\n####                 movesUD++;\\n####             }\\n####             return true;\\n####     }\\n#### };",
                "solutionTags": [],
                "code": "class Solution {\\n#### public:\\n####     bool judgeCircle(string moves) {\\n####         int n = moves.length();\\n####         int movesLR = 0;\\n####         int movesUD = 0;\\n####         for(int i=0;i<n;i++)\\n####         {\\n####             if(moves[i]==\\'R\\')\\n####             {\\n####                 movesLR--;\\n####             }",
                "codeTag": "Java"
            },
            {
                "id": 2409011,
                "title": "kotlin-very-fast-solution",
                "content": "Runtime: 209 ms, faster than 100.00% of Kotlin online submissions for Robot Return to Origin.\\nMemory Usage: 35.9 MB, less than 98.08% of Kotlin online submissions for Robot Return to Origin.\\n\\n```\\n    fun judgeCircle(moves: String): Boolean {\\n        //very important condition for speed\\n        if (moves.length % 2 != 0) return false\\n        var horizontal = 0\\n        var vertical = 0\\n        moves.forEach {\\n            when (it) {\\n                \\'L\\' -> horizontal--\\n                \\'R\\' -> horizontal++\\n                \\'U\\' -> vertical++\\n                \\'D\\' -> vertical--\\n            }\\n        }\\n        return horizontal == 0 && vertical == 0\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    fun judgeCircle(moves: String): Boolean {\\n        //very important condition for speed\\n        if (moves.length % 2 != 0) return false\\n        var horizontal = 0\\n        var vertical = 0\\n        moves.forEach {\\n            when (it) {\\n                \\'L\\' -> horizontal--\\n                \\'R\\' -> horizontal++\\n                \\'U\\' -> vertical++\\n                \\'D\\' -> vertical--\\n            }\\n        }\\n        return horizontal == 0 && vertical == 0\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352528,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return ((moves.count(\\'L\\') == moves.count(\\'R\\')) and (moves.count(\\'U\\') == moves.count(\\'D\\')))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return ((moves.count(\\'L\\') == moves.count(\\'R\\')) and (moves.count(\\'U\\') == moves.count(\\'D\\')))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171765,
                "title": "simplest-approach-move-mapping",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        moveMap = {\\n            \\'R\\' : [0, 1],\\n            \\'L\\' : [0, -1],\\n            \\'U\\' : [1, 0],\\n            \\'D\\' : [-1, 0]\\n        }\\n        startX = 0\\n        startY = 0\\n        \\n        for move in moves:\\n            direction = moveMap[move]\\n            startX += direction[0]\\n            startY += direction[1]\\n        \\n        if [startX, startY] == [0, 0]:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        moveMap = {\\n            \\'R\\' : [0, 1],\\n            \\'L\\' : [0, -1],\\n            \\'U\\' : [1, 0],\\n            \\'D\\' : [-1, 0]\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2162836,
                "title": "c-simple-linq",
                "content": "Straightforward\\n```\\npublic class Solution\\n{\\n    public bool JudgeCircle(string moves)\\n    {\\n        (int x, int y) = (0, 0);\\n        foreach (char move in moves)\\n        {\\n            if (move is \\'U\\') y++;\\n            else if (move is \\'D\\') y--;\\n            else if (move is \\'R\\') x++;\\n            else if (move is \\'L\\') x--;\\n        }\\n\\n        return (x, y) == (0, 0);\\n    }\\n}\\n```\\n\\nLINQ \\n```\\npublic class Solution\\n{\\n    public bool JudgeCircle(string moves)\\n        => (0, 0) == moves.Aggregate(\\n               (X: 0, Y: 0),\\n               (Position, move) => move switch\\n               {\\n                   \\'U\\' => (Position.X, Position.Y - 1),\\n                   \\'D\\' => (Position.X, Position.Y + 1),\\n                   \\'L\\' => (Position.X + 1, Position.Y),\\n                   \\'R\\' => (Position.X - 1, Position.Y)\\n               }\\n           );\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool JudgeCircle(string moves)\\n    {\\n        (int x, int y) = (0, 0);\\n        foreach (char move in moves)\\n        {\\n            if (move is \\'U\\') y++;\\n            else if (move is \\'D\\') y--;\\n            else if (move is \\'R\\') x++;\\n            else if (move is \\'L\\') x--;\\n        }\\n\\n        return (x, y) == (0, 0);\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public bool JudgeCircle(string moves)\\n        => (0, 0) == moves.Aggregate(\\n               (X: 0, Y: 0),\\n               (Position, move) => move switch\\n               {\\n                   \\'U\\' => (Position.X, Position.Y - 1),\\n                   \\'D\\' => (Position.X, Position.Y + 1),\\n                   \\'L\\' => (Position.X + 1, Position.Y),\\n                   \\'R\\' => (Position.X - 1, Position.Y)\\n               }\\n           );\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161128,
                "title": "java-easy-to-understand-o-n",
                "content": "class Solution {\\n    public boolean judgeCircle(String moves) {\\n        \\n        int H=0, V=0; //  h-horizontal movements and v-vertical movements\\n        \\n        for(char c:moves.toCharArray()){\\n            if(c==\\'R\\') H++;\\n            else if(c==\\'L\\') H--;\\n            else if(c==\\'U\\') V++;\\n            else V--;\\n        }\\n        \\n        return (H==0 && V==0);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean judgeCircle(String moves) {\\n        \\n        int H=0, V=0; //  h-horizontal movements and v-vertical movements\\n        \\n        for(char c:moves.toCharArray()){\\n            if(c==\\'R\\') H++;\\n            else if(c==\\'L\\') H--;\\n            else if(c==\\'U\\') V++;\\n            else V--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2076042,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int ud = 0;\\n        int lr = 0;\\n        // loop over every move\\n        for(char x : moves.toCharArray()) {\\n            // if x.equals u -> ud+1\\n            if(x == \\'U\\') {\\n                ud += 1;\\n            }\\n            // if x.equals d -> ud-1\\n            if(x == \\'D\\') {\\n                ud -= 1;\\n            }\\n            // if x.equals r -> lr+1\\n            if(x == \\'R\\') {\\n                lr += 1;\\n            }\\n            // if x.equals l -> lr-1\\n            if(x == \\'L\\') {\\n                lr -= 1;\\n            }\\n        }\\n        \\n       if(ud != 0 || lr != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int ud = 0;\\n        int lr = 0;\\n        // loop over every move\\n        for(char x : moves.toCharArray()) {\\n            // if x.equals u -> ud+1\\n            if(x == \\'U\\') {\\n                ud += 1;\\n            }\\n            // if x.equals d -> ud-1\\n            if(x == \\'D\\') {\\n                ud -= 1;\\n            }\\n            // if x.equals r -> lr+1\\n            if(x == \\'R\\') {\\n                lr += 1;\\n            }\\n            // if x.equals l -> lr-1\\n            if(x == \\'L\\') {\\n                lr -= 1;\\n            }\\n        }\\n        \\n       if(ud != 0 || lr != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016023,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int sum=0;\\n        for(char c: moves.toCharArray()){\\n            switch(c) {\\n              case \\'U\\':\\n                sum+=3;\\n                break;\\n              case \\'D\\':\\n                sum-=3;\\n                break;\\n              case \\'L\\':\\n                sum--;\\n                break;\\n              case \\'R\\':\\n                sum++;\\n                break;\\n            }\\n        }\\n        if(sum==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int sum=0;\\n        for(char c: moves.toCharArray()){\\n            switch(c) {\\n              case \\'U\\':\\n                sum+=3;\\n                break;\\n              case \\'D\\':\\n                sum-=3;\\n                break;\\n              case \\'L\\':\\n                sum--;\\n                break;\\n              case \\'R\\':\\n                sum++;\\n                break;\\n            }\\n        }\\n        if(sum==0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999615,
                "title": "c-easy-switch-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int horizontal = 0;\\n        int vertical = 0;\\n        \\n        for(int i = 0; i < moves.length(); i++)\\n        {\\n            switch(moves[i])\\n            {\\n                case \\'U\\':\\n                    vertical++;\\n                    break;\\n                case \\'D\\':\\n                    vertical--;\\n                    break;\\n                case \\'L\\':\\n                    horizontal--;\\n                    break;\\n                case \\'R\\':\\n                    horizontal++;\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n        \\n        if(horizontal == 0 && vertical == 0) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int horizontal = 0;\\n        int vertical = 0;\\n        \\n        for(int i = 0; i < moves.length(); i++)\\n        {\\n            switch(moves[i])\\n            {\\n                case \\'U\\':\\n                    vertical++;\\n                    break;\\n                case \\'D\\':\\n                    vertical--;\\n                    break;\\n                case \\'L\\':\\n                    horizontal--;\\n                    break;\\n                case \\'R\\':\\n                    horizontal++;\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n        \\n        if(horizontal == 0 && vertical == 0) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849553,
                "title": "python-1-liner-faster-than-99-28-ms",
                "content": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'U\\') == moves.count(\\'D\\') and moves.count(\\'L\\') == moves.count(\\'R\\')\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        return moves.count(\\'U\\') == moves.count(\\'D\\') and moves.count(\\'L\\') == moves.count(\\'R\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820276,
                "title": "easy-python-code",
                "content": "x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \"U\":\\n                x += 1\\n            elif i == \"D\":\\n                x -= 1\\n            elif i == \"L\":\\n                y += 1\\n            else:\\n                y -= 1\\n        if x == 0 and y == 0:\\n            return True\\n        else:\\n            return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \"U\":\\n                x += 1\\n            elif i == \"D\":\\n                x -= 1\\n            elif i == \"L\":\\n                y += 1\\n            else:\\n                y -= 1\\n        if x == 0 and y == 0:\\n            return True\\n        else:\\n            return False",
                "codeTag": "Unknown"
            },
            {
                "id": 1807226,
                "title": "c-o-n-solution",
                "content": "```\\n bool judgeCircle(string moves) {\\n      int Up=0,Down=0,Left=0,Right=0;\\n        for(int i=0; i<moves.length(); i++)\\n        {\\n            if(moves[i]==\\'U\\') Up++;\\n            else if(moves[i]==\\'D\\') Down++;\\n            else if(moves[i]==\\'L\\') Left++;\\n            else Right++;\\n        }\\n        return (Left==Right) && (Down==Up);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool judgeCircle(string moves) {\\n      int Up=0,Down=0,Left=0,Right=0;\\n        for(int i=0; i<moves.length(); i++)\\n        {\\n            if(moves[i]==\\'U\\') Up++;\\n            else if(moves[i]==\\'D\\') Down++;\\n            else if(moves[i]==\\'L\\') Left++;\\n            else Right++;\\n        }\\n        return (Left==Right) && (Down==Up);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1794139,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String m) {\\n        int count=0;\\n        int var=0;\\n        for(int i=0;i<m.length();i++){\\n            if(m.charAt(i)==\\'U\\')\\n                count++;\\n            else if(m.charAt(i)==\\'D\\')\\n                count--;\\n        }\\n        \\n        for(int i=0;i<m.length();i++){\\n            if(m.charAt(i)==\\'R\\')\\n                var++;\\n            else if(m.charAt(i)==\\'L\\')\\n                var--;\\n        }\\n        \\n        if(count==0 && var==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String m) {\\n        int count=0;\\n        int var=0;\\n        for(int i=0;i<m.length();i++){\\n            if(m.charAt(i)==\\'U\\')\\n                count++;\\n            else if(m.charAt(i)==\\'D\\')\\n                count--;\\n        }\\n        \\n        for(int i=0;i<m.length();i++){\\n            if(m.charAt(i)==\\'R\\')\\n                var++;\\n            else if(m.charAt(i)==\\'L\\')\\n                var--;\\n        }\\n        \\n        if(count==0 && var==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780676,
                "title": "python3-easy-solution-o-n-time-and-o-1-space",
                "content": "\\t\\tx,y = 0,0\\n        \\n        for move in moves:\\n            if move == \\'U\\': y+=1\\n            elif move == \\'D\\': y-=1\\n            elif move == \\'R\\': x+=1\\n            elif move == \\'L\\': x-=1\\n                \\n        if x == 0 and y == 0:\\n            return True\\n        \"\"\"\\n        time: O(N) and space: O(1)\\n        \"\"\"",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\tx,y = 0,0\\n        \\n        for move in moves:\\n            if move == \\'U\\': y+=1\\n            elif move == \\'D\\': y-=1\\n            elif move == \\'R\\': x+=1\\n            elif move == \\'L\\': x-=1\\n                \\n        if x == 0 and y == 0:\\n            return True\\n        \"\"\"\\n        time: O(N) and space: O(1)\\n        \"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1778523,
                "title": "c-runtime-3-ms-faster-than-99-94-o-moves-length-time-complexity-solution",
                "content": "\\tbool judgeCircle(string moves) {\\n\\n        int arr[26]={0};\\n        \\n        for(int i=0;i<moves.length();i++)\\n            arr[moves[i]-\\'A\\']++;\\n    \\n        if(arr[\\'U\\'-\\'A\\']==arr[\\'D\\'-\\'A\\'] && arr[\\'L\\'-\\'A\\']==arr[\\'R\\'-\\'A\\'])\\n            return true;\\n        \\n        return false;\\n}\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tbool judgeCircle(string moves) {\\n\\n        int arr[26]={0};\\n        \\n        for(int i=0;i<moves.length();i++)\\n            arr[moves[i]-\\'A\\']++;\\n    \\n        if(arr[\\'U\\'-\\'A\\']==arr[\\'D\\'-\\'A\\'] && arr[\\'L\\'-\\'A\\']==arr[\\'R\\'-\\'A\\'])\\n            return true;\\n        \\n        return false;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1683404,
                "title": "c-solution-faster-than-63-7-users-beginner-friendly",
                "content": "``` For example : - str = \"LLDDRRUU\" ```\\n``` 1st iteration : - c -1 = -1```\\n``` 2nd iteration : - c -1 = -2```\\n``` 3rd iteration : - d -1 = -1```\\n``` 4th iteration : - d -1 = -2```\\n``` 5th iteration :- c+1 = -1```\\n``` 6th iteration :- c+1 = 0```\\n``` 7th iteration : - d +1 = -1```\\n``` 8th iteration : - d +1 = 0```\\n``` c = 0 , d = 0 so robot is at Origin.```\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string s) {\\n        int c=0,d=0;        // Initialise two counter variables to keep track of count of UP , DOWN , RIGHT , LEFT\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'R\\')   // If it moves \"Right\" then increase the count\\n                c+=1;\\n            else if(s[i]==\\'L\\')     // If it moves to \"Left\" then decrease the count\\n                c-=1;\\n            else if(s[i]==\\'D\\')   // If it moves \"Down\" then decrease the count\\n                d-=1;\\n            else if(s[i]==\\'U\\')   // If it moves \"UP\" then increase the count\\n                d+=1;\\n        }\\n        if(c==0 && d==0)    // If both counts become \"0\" then it signifies that the robot is at origin\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```\\n``` If you like my approach then hit the like button.```",
                "solutionTags": [],
                "code": "``` For example : - str = \"LLDDRRUU\" ```\n``` 1st iteration : - c -1 = -1```\n``` 2nd iteration : - c -1 = -2```\n``` 3rd iteration : - d -1 = -1```\n``` 4th iteration : - d -1 = -2```\n``` 5th iteration :- c+1 = -1```\n``` 6th iteration :- c+1 = 0```\n``` 7th iteration : - d +1 = -1```\n``` 8th iteration : - d +1 = 0```\n``` c = 0 , d = 0 so robot is at Origin.```\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string s) {\\n        int c=0,d=0;        // Initialise two counter variables to keep track of count of UP , DOWN , RIGHT , LEFT\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'R\\')   // If it moves \"Right\" then increase the count\\n                c+=1;\\n            else if(s[i]==\\'L\\')     // If it moves to \"Left\" then decrease the count\\n                c-=1;\\n            else if(s[i]==\\'D\\')   // If it moves \"Down\" then decrease the count\\n                d-=1;\\n            else if(s[i]==\\'U\\')   // If it moves \"UP\" then increase the count\\n                d+=1;\\n        }\\n        if(c==0 && d==0)    // If both counts become \"0\" then it signifies that the robot is at origin\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```\n``` If you like my approach then hit the like button.```",
                "codeTag": "Java"
            },
            {
                "id": 1672731,
                "title": "solution-in-python3-beats-90-two-lines",
                "content": "Using python3 default Counter object from **collections** library.\\n```\\ndef judgeCircle(self, moves):\\n\\tc = collections.Counter(moves)\\n\\treturn c[\\'U\\'] == c[\\'D\\'] and c[\\'L\\'] == c[\\'R\\']\\n```\\n**Time Complexity**\\n*O(n)*\\n**Space Complexity**\\n*O(n)*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef judgeCircle(self, moves):\\n\\tc = collections.Counter(moves)\\n\\treturn c[\\'U\\'] == c[\\'D\\'] and c[\\'L\\'] == c[\\'R\\']\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1638040,
                "title": "ordinary-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int ud = 0;\\n        int lr = 0;\\n        for(int i = 0; i < moves.length(); i++){\\n            switch(moves.charAt(i)){\\n                    case \\'U\\' -> ud++;\\n                    case \\'D\\' -> ud--;\\n                    case \\'L\\' -> lr++;\\n                    case \\'R\\' -> lr--;\\n            }\\n        }\\n        if(ud == 0 && lr == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int ud = 0;\\n        int lr = 0;\\n        for(int i = 0; i < moves.length(); i++){\\n            switch(moves.charAt(i)){\\n                    case \\'U\\' -> ud++;\\n                    case \\'D\\' -> ud--;\\n                    case \\'L\\' -> lr++;\\n                    case \\'R\\' -> lr--;\\n            }\\n        }\\n        if(ud == 0 && lr == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611612,
                "title": "c-two-methods-with-explanation-easy-to-understand",
                "content": "**Two Methods Discussed**\\n\\n**Method 1 :**\\n\\nMapping  **\\'U\\', \\'D\\', \\'R\\', \\'L\\'** with their number of occurences.\\n* if number of occurence of **\\'R\\'**==number of occurences of **\\'L\\'** and \\n\\tnumber of occurences of **\\'U\\'**==number of occurences of **\\'D\\'**, then return **\"true\"**\\n* else return **\"false\"**\\n\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char,int> m;\\n        for(int i=0;i<moves.size();i++){\\n            m[moves[i]]++;\\n        }\\n        return m[\\'U\\']==m[\\'D\\']&&m[\\'R\\']==m[\\'L\\'];\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(N)\\n**Space Complexity :** O(N)\\n\\n\\n**Method 2 :**\\n\\n* Incrementing the number of occurences of **\\'U\\'** and **\\'R\\'**\\n* Decrementing the number of occurences of **\\'U\\'** when **\\'D\\'** is found and \\nDecrementing the number of occurences of **\\'R\\'** when **\\'L\\'** is found\\n* checking the count of **\\'U\\'** and **\\'R\\'** if they both are equal to 0, then it returns true otherwise it returns false.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int countU=0,countR=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\')   countU++;\\n            else if(moves[i]==\\'R\\')   countR++;\\n            else if(moves[i]==\\'D\\')  countU--;\\n            else countR--;\\n        }\\n        \\n        return countU==0&&countR==0;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(N)\\n**Space Complexity :** O(1)\\n\\nIf you liked the solution, then please upvote : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        unordered_map<char,int> m;\\n        for(int i=0;i<moves.size();i++){\\n            m[moves[i]]++;\\n        }\\n        return m[\\'U\\']==m[\\'D\\']&&m[\\'R\\']==m[\\'L\\'];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int countU=0,countR=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\')   countU++;\\n            else if(moves[i]==\\'R\\')   countR++;\\n            else if(moves[i]==\\'D\\')  countU--;\\n            else countR--;\\n        }\\n        \\n        return countU==0&&countR==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564910,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1566983,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1571797,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1574801,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1571935,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1797727,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1768307,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1574351,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1575358,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1767813,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1564910,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1566983,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1571797,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1574801,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1571935,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1797727,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1768307,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1574351,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1575358,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 1767813,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "There are a few problems has vague descriptions which is quite confusing that make the contestants to submit multiple of time to \"guess\" or \"try out\" what is the real meaning of the problem.\\n\\nIt's remotely what we want in Leetcode. So please STOP making this kind of problem again. It's no more than a waste of our time.\\n\\nTHANK YOU!"
                    },
                    {
                        "username": "wjclbj",
                        "content": "![image](https://assets.leetcode.com/users/images/6de7793f-4974-4148-ae27-e6080d4020f0_1599658329.8546743.png)\\nWhat??"
                    },
                    {
                        "username": "fuzz",
                        "content": "LLLL should also be considered as a circle, right?"
                    },
                    {
                        "username": "Singh_uday99",
                        "content": "no , here L,R,U,D are respect to initial point .. as there is no concept of facing of robot there ... \\nHere L,R,U,D are like cartesian plane axes ,\\nL=-x axis \\nR=x axis \\nU=yaxis\\nD=-yaxis"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\treturn moves.count(\"U\") == moves.count(\"D\") and moves.count(\"L\") == moves.count(\"R\")"
                    },
                    {
                        "username": "VictorKoch",
                        "content": ";-) This one liner would perform four move string scans."
                    },
                    {
                        "username": "GuangSenNi",
                        "content": "if moves==\"LLLL\";\\nis it makes a circle?"
                    },
                    {
                        "username": "mcapewell",
                        "content": "No, think of \"L\" as \"Move West 1 space,\" not turn left. They should have worded it as north/south/west/east instead of u/d/l/r. That would have been clearer."
                    },
                    {
                        "username": "vikasdongarwar",
                        "content": "no, there is no facing concept so it will not create loop. It will be just 4 points away from its original position to the left. Use axis concept."
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "YEAH THAT\\'S THE LOOPHOLE OF THIS QUESTION."
                    },
                    {
                        "username": "nxli",
                        "content": "For Python, can the solution get more optimized than using Counter and checking if length of moves is odd?"
                    },
                    {
                        "username": "cheung4843",
                        "content": "if len(moves) & 1 == 1:\\n            return False\\nelse:\\n           apply Counter..."
                    },
                    {
                        "username": "Cyberpunk1984",
                        "content": "A nice simple simulation. One must store the coords in a pair of integers and increase or decrease them based on the move . [LRUD]"
                    },
                    {
                        "username": "simplyajith",
                        "content": "![image](https://assets.leetcode.com/users/images/a01c6c2d-6951-498b-b8fd-b33ed6b11b82_1599626434.5712624.png)\\n"
                    },
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/51ed36cc-4ad2-46ec-9b35-7f031ad5f557_1622938487.6859498.png)\\n\\n"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "If the Length of string is an Odd number, it will never make it to `(0,0)` position. `return false` in this case."
                    }
                ]
            },
            {
                "id": 2066263,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 2038538,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 1958164,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 1865301,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 1819803,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 1761698,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 1739510,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 1724850,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 1716510,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            },
            {
                "id": 1715368,
                "content": [
                    {
                        "username": "LC_LeetCodePython",
                        "content": "Just make sure U = D and R = L and ur done"
                    },
                    {
                        "username": "Supernova10",
                        "content": "where the heck U, D came from on a 2D plane? must be kidding. LOL"
                    },
                    {
                        "username": "Reprogrammed_AP",
                        "content": "\"LLLL\" this sequence of moves also end up at (0,0).  Why its showing false as expected?\\n "
                    },
                    {
                        "username": "mcapewell",
                        "content": "No \"L\" in this problem means take a step to the left (think of it as taking a step to the West. URDL = NESW). So you end up at (-4,0)"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "you didnt undrestand the question bro,each time the j decreases and it will not reach to zero"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "class Solution(object):\\n    def judgeCircle(self, moves):\\n        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s a very nice question.. think about  if i make 2 steps left and 1 up how many down steps and right steps i need to make to be in the original position?"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def judgeCircle(self, moves: str) -> bool:\\n        x = 0\\n        y = 0\\n        for i in moves:\\n            if i == \\'L\\' :\\n                x += 1\\n            elif i == \\'R\\':\\n                X -= 1\\n            elif i == \\'U\\':\\n                y += 1\\n            elif i == \\'D\\':\\n                y -= 1\\n        if x == 0 and y == 0 :\\n            return True\\n        else:\\n            return False\\n"
                    },
                    {
                        "username": "NishaSreedharan",
                        "content": "# number of up and down moves should be equal (similarly number of right and left moves should be similar), then the robot will always be back at 0,0 position\\n` \\n   \\n        updown = 0\\n        rightleft = 0\\n\\n        for i in moves:\\n            if i == \\'U\\':\\n                updown = updown + 1\\n            if i == \\'D\\':\\n                updown = updown - 1\\n            if i == \\'L\\':\\n                rightleft = rightleft + 1\\n            if i == \\'R\\':\\n                rightleft = rightleft -1\\n        return rightleft == 0 and updown == 0`\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Why HashMap didn\\'t work... I am wondering :("
                    },
                    {
                        "username": "VictorKoch",
                        "content": "HashMap could be used for this problem. But HashMap would make solution complicated."
                    },
                    {
                        "username": "Shubham_198",
                        "content": "Simple and Best C++ Solution with O(n):\\nclass Solution {\\npublic:\\n    bool judgeCircle(string moves) {\\n        int f=0,s=0;\\n        for(int i=0;i<moves.length();i++){\\n            if(moves[i]==\\'U\\'){\\n                f++;\\n            }\\n            if(moves[i]==\\'D\\'){\\n                f--;\\n            }\\n            if(moves[i]==\\'L\\'){\\n                s++;\\n            }\\n            if(moves[i]==\\'R\\'){\\n                s--;\\n            }\\n        }\\n        if(f==0 && s==0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "tsamawi",
                        "content": "I do not understand how using the 'Count' method in python is any faster than iterating manually. \n\nBEATS 99% in RunTime: \n`        return moves.count(\"U\")==moves.count(\"D\") and moves.count(\"L\")==moves.count(\"R\")\n`\n\nBEATS 10-15% in RunTime:\nSolution 1: \n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        curr_pos = [0, 0]\n        for i in range(len(moves)):\n            if moves[i] == 'L':\n                curr_pos[0] -= 1\n            elif moves[i] == 'R':\n                curr_pos[0] += 1\n            elif moves[i] == 'U':\n                curr_pos[1] += 1\n            elif moves[i] == 'D':\n                curr_pos[1] -= 1\n        return curr_pos == [0, 0]`\nSolution 2:\nfrom collections import defaultdict\n\n`class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        all_moves = defaultdict(int)\n        for i in range(len(moves)):\n            all_moves[moves[i]] += 1\n        \n        return all_moves['U'] == all_moves['D'] and all_moves['L'] == all_moves['R']\n`"
                    }
                ]
            }
        ]
    }
]