[
    {
        "title": "Weird Algorithm",
        "query": "Consider an algorithm that takes as input a positive integer n. If n is even, the algorithm divides it by two, and if n is odd, the algorithm multiplies it by three and adds one. The algorithm repeats this, until n is one. For example, the sequence for n=3 is as follows:\n 3 \\rightarrow 10 \\rightarrow 5 \\rightarrow 16 \\rightarrow 8 \\rightarrow 4 \\rightarrow 2 \\rightarrow 1\nYour task is to simulate the execution of the algorithm for a given value of n.\nInput\nThe only input line contains an integer n.\nOutput\nPrint a line that contains all values of n during the algorithm.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n\nOutput:\n3 10 5 16 8 4 2 1\n",
        "solution": "def main(n):\n    result = []\n    while n != 1:\n        result.append(n)\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n = n * 3 + 1\n    result.append(1)\n    return result",
          "sample1_input": "3",
    "sample1_output": "3 10 5 16 8 4 2 1",
    "sample2_input": "7",
    "sample2_output": "7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1",
    "sample3_input": "10",
    "sample3_output": "10 5 16 8 4 2 1",
    "sample4_input": "1",
    "sample4_output": "1",
    "sample5_input": "13",
    "sample5_output": "13 40 20 10 5 16 8 4 2 1"
    },
    {
        "title": "Missing Number",
        "query": "You are given all numbers between 1,2,\\ldots,n except one. Your task is to find the missing number.\nInput\nThe first input line contains an integer n.\nThe second line contains n-1 numbers. Each number is distinct and between 1 and n (inclusive).\nOutput\nPrint the missing number.\nConstraints\n\n2 \\le n \\le 2 \\cdot 10^5\n\nExample\nInput:\n5\n2 3 1 5\n\nOutput:\n4\n",
        "solution": "def main(n, numbers):\n    total_sum = (n * (n + 1)) // 2\n    actual_sum = sum(numbers)\n    missing_number = total_sum - actual_sum\n    return missing_number",
         "sample1_input": "5 \n 2 3 1 5",
    "sample1_output": "4",
    "sample2_input": "10 \n 2 3 1 10 6 7 4 8 5",
    "sample2_output": "9",
    "sample3_input": "3\n2 3",
    "sample3_output": "1",
    "sample4_input": "6\n 4 3 5 1 2",
    "sample4_output": "6",
    "sample5_input": "4\n2 1 4",
    "sample5_output": "3"
    },
    {
        "title": "Repetitions",
        "query": "You are given a DNA sequence: a string consisting of characters A, C, G, and T. Your task is to find the longest repetition in the sequence. This is a maximum-length substring containing only one type of character.\nInput\nThe only input line contains a string of n characters.\nOutput\nPrint one integer: the length of the longest repetition.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\nATTCGGGA\n\nOutput:\n3\n",
        "solution": "def main(dna_sequence):\n    max_repetition_length = 0\n    current_repetition_length = 1\n\n    for i in range(1, len(dna_sequence)):\n        if dna_sequence[i] == dna_sequence[i - 1]:\n            current_repetition_length += 1\n        else:\n            max_repetition_length = max(max_repetition_length, current_repetition_length)\n            current_repetition_length = 1\n\n    # Check the last repetition if it's the longest\n    max_repetition_length = max(max_repetition_length, current_repetition_length)\n\n    return str(max_repetition_length)",
         "sample1_input": "ATTCGGGA",
    "sample1_output": "3",
    "sample2_input": "ACGTACGTACGT",
    "sample2_output": "1",
    "sample3_input": "AAAAAA",
    "sample3_output": "6",
    "sample4_input": "CGTA",
    "sample4_output": "1",
    "sample5_input": "GCGCGCGC",
    "sample5_output": "8"
    },
    {
        "title": "Increasing Array",
        "query": "You are given an array of n integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element.\nOn each move, you may increase the value of any element by one. What is the minimum number of moves required?\nInput\nThe first input line contains an integer n: the size of the array.\nThen, the second line contains n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint the minimum number of moves.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5\n3 2 5 1 7\n\nOutput:\n5\n",
        "solution": "def main(n, arr):\n    moves = 0\n    prev = arr[0]\n\n    for i in range(1, n):\n        if arr[i] < prev:\n            moves += prev - arr[i]\n        else:\n            prev = arr[i]\n\n    return str(moves)",
        "sample1_input": {
        "n": "5",
        "arr": ["3", "2", "5", "1", "7"]
    },
    "sample1_output": "5",
    "sample2_input": {
        "n": "3",
        "arr": ["1", "1", "1"]
    },
    "sample2_output": "0",
    "sample3_input": {
        "n": "4",
        "arr": ["4", "2", "3", "7"]
    },
    "sample3_output": "4",
    "sample4_input": {
        "n": "2",
        "arr": ["1000000000", "1"]
    },
    "sample4_output": "999999999",
    "sample5_input": {
        "n": "6",
        "arr": ["1", "2", "3", "4", "5", "6"]
    },
    "sample5_output": "0"
    },
    {
        "title": "Permutations",
        "query": "A permutation of integers 1,2,\\ldots,n is called beautiful if there are no adjacent elements whose difference is 1.\nGiven n, construct a beautiful permutation if such a permutation exists.\nInput\nThe only input line contains an integer n.\nOutput\nPrint a beautiful permutation of integers 1,2,\\ldots,n. If there are several solutions, you may print any of them. If there are no solutions, print \"NO SOLUTION\".\nConstraints\n\n1 \\le n \\le 10^6\n\nExample 1\nInput:\n5\n\nOutput:\n4 2 5 3 1\nExample 2\nInput:\n3\n\nOutput:\nNO SOLUTION\n",
        "solution": "def main(n):\n    if n % 2 == 0:\n        result = [i + 1 for i in range(n)]\n        for i in range(0, n - 1, 2):\n            result[i], result[i + 1] = result[i + 1], result[i]\n        return result\n    else:\n        return 'NO SOLUTION'",
  "sample1_input": "5",
  "sample1_output": "[2, 1, 4, 3, 5]",
  "sample2_input": "3",
  "sample2_output": "NO SOLUTION",
  "sample3_input": "6",
  "sample3_output": "[2, 1, 4, 3, 6, 5]",
  "sample4_input": "8",
  "sample4_output": "[2, 1, 4, 3, 6, 5, 8, 7]",
  "sample5_input": "1",
  "sample5_output": "[1]"
    },
    {
        "title": "Number Spiral",
        "query": "A number spiral is an infinite grid whose upper-left square has number 1. Here are the first five layers of the spiral:\n\nYour task is to find out the number in row y and column x.\nInput\nThe first input line contains an integer t: the number of tests.\nAfter this, there are t lines, each containing integers y and x.\nOutput\nFor each test, print the number in row y and column x.\nConstraints\n\n1 \\le t \\le 10^5\n1 \\le y,x \\le 10^9\n\nExample\nInput:\n3\n2 3\n1 1\n4 2\n\nOutput:\n8\n1\n15\n",
        "solution": "def main(t, tests):\n    results = []\n    for i in range(t):\n        y, x = tests[i]\n        if y >= x:\n            if y % 2 == 1:\n                result = y * y - x + 1\n            else:\n                result = (y - 1) * (y - 1) + x\n        else:\n            if x % 2 == 0:\n                result = x * x - y + 1\n            else:\n                result = (x - 1) * (x - 1) + y\n        results.append(result)\n    return results",
  "sample1_input": "3\n2 3\n1 1\n4 2",
  "sample1_output": "[8, 1, 15]",
  "sample2_input": "2\n5 5\n3 4",
  "sample2_output": "[25, 10]",
  "sample3_input": "1\n7 8",
  "sample3_output": "[49]",
  "sample4_input": "2\n10 6\n9 7",
  "sample4_output": "[94, 81]",
  "sample5_input": "2\n1000000000 1000000000\n999999999 999999998",
  "sample5_output": "[999999999000000000, 999999997999999998]"

    },
    {
        "title": "Two Knights",
        "query": "Your task is to count for k=1,2,\\ldots,n the number of ways two knights can be placed on a k \\times k chessboard so that they do not attack each other.\nInput\nThe only input line contains an integer n.\nOutput\nPrint n integers: the results.\nConstraints\n\n1 \\le n \\le 10000\n\nExample\nInput:\n8\n\nOutput:\n0\n6\n28\n96\n252\n550\n1056\n1848\n",
         "solution": "def main(n):\n    results = []\n    for k in range(1, n + 1):\n        if k == 1:\n            ways = 0\n        elif k == 2:\n            ways = 6\n        else:\n            ways = (k * k * (k * k - 1)) // 2 - 4 * (k - 1) * (k - 2)\n        results.append(ways)\n    return results",
  "sample1_input": "8",
  "sample1_output": "[0, 6, 28, 96, 252, 550, 1056, 1848]",
  "sample2_input": "5",
  "sample2_output": "[0, 6, 28, 96, 252]",
  "sample3_input": "3",
  "sample3_output": "[0, 6, 28]",
  "sample4_input": "10",
  "sample4_output": "[0, 6, 28, 96, 252, 550, 1056, 1848, 3024, 4624]",
  "sample5_input": "1",
  "sample5_output": "[0]"
    },
    {
        "title": "Two Sets",
        "query": "Your task is to divide the numbers 1,2,\\ldots,n into two sets of equal sum.\nInput\nThe only input line contains an integer n.\nOutput\nPrint \"YES\", if the division is possible, and \"NO\" otherwise.\nAfter this, if the division is possible, print an example of how to create the sets. First, print the number of elements in the first set followed by the elements themselves in a separate line, and then, print the second set in a similar way.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample 1\nInput:\n7\n\nOutput:\nYES\n4\n1 2 4 7\n3\n3 5 6\nExample 2\nInput:\n6\n\nOutput:\nNO\n",
        "solution": "def main(n):\n    if n % 4 == 0:\n        result = 'YES'\n        first_set = [i for i in range(1, n // 2 + 1)]\n        second_set = [i for i in range(n // 2 + 1, n + 1)]\n    elif (n - 1) % 4 == 0:\n        result = 'YES'\n        first_set = [i for i in range(1, n // 2)] + [n]\n        second_set = [i for i in range(n // 2 + 1, n)]\n    else:\n        result = 'NO'\n        first_set = []\n        second_set = []\n    return result, first_set, second_set",
  "sample1_input": "7",
  "sample1_output": "YES\n4\n1 2 4 7\n3\n3 5 6",
  "sample2_input": "6",
  "sample2_output": "NO",
  "sample3_input": "10",
  "sample3_output": "YES\n5\n1 2 3 4 10\n5\n5 6 7 8 9",
  "sample4_input": "8",
  "sample4_output": "YES\n4\n1 2 3 8\n4\n4 5 6 7",
  "sample5_input": "5",
  "sample5_output": "NO"
    },
    {
        "title": "Bit Strings",
        "query": "Your task is to calculate the number of bit strings of length n.\nFor example, if n=3, the correct answer is 8, because the possible bit strings are 000, 001, 010, 011, 100, 101, 110, and 111.\nInput\nThe only input line has an integer n.\nOutput\nPrint the result modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n\nOutput:\n8\n",
        "solution": "def main(n):\n    MOD = 10**9 + 7\n    result = 2 ** n % MOD\n    return result",
  "sample1_input": "3",
  "sample1_output": "8",
  "sample2_input": "5",
  "sample2_output": "32",
  "sample3_input": "1",
  "sample3_output": "2",
  "sample4_input": "6",
  "sample4_output": "64",
  "sample5_input": "10",
  "sample5_output": "1024"
    },
    {
        "title": "Trailing Zeros",
        "query": "Your task is to calculate the number of trailing zeros in the factorial n!.\nFor example, 20!=2432902008176640000 and it has 4 trailing zeros.\nInput\nThe only input line has an integer n.\nOutput\nPrint the number of trailing zeros in n!.\nConstraints\n\n1 \\le n \\le 10^9\n\nExample\nInput:\n20\n\nOutput:\n4\n",
         "solution": "def main(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count",
  "sample1_input": "20",
  "sample1_output": "4",
  "sample2_input": "10",
  "sample2_output": "2",
  "sample3_input": "25",
  "sample3_output": "6",
  "sample4_input": "100",
  "sample4_output": "24",
  "sample5_input": "5",
  "sample5_output": "1"
    },
    {
        "title": "Coin Piles",
        "query": "You have two coin piles containing a and b coins. On each move, you can either remove one coin from the left pile and two coins from the right pile, or two coins from the left pile and one coin from the right pile.\nYour task is to efficiently find out if you can empty both the piles.\nInput\nThe first input line has an integer t: the number of tests.\nAfter this, there are t lines, each of which has two integers a and b: the numbers of coins in the piles.\nOutput\nFor each test, print \"YES\" if you can empty the piles and \"NO\" otherwise.\nConstraints\n\n1 \\le t \\le 10^5\n0 \\le a, b \\le 10^9\n\nExample\nInput:\n3\n2 1\n2 2\n3 3\n\nOutput:\nYES\nNO\nYES\n",
         "solution": "def main(t, tests):\n    results = []\n    for i in range(t):\n        a, b = tests[i]\n        if (a + b) % 3 == 0 and min(a, b) * 2 >= max(a, b):\n            results.append('YES')\n        else:\n            results.append('NO')\n    return results",
  "sample1_input": "3\n2 1\n2 2\n3 3",
  "sample1_output": "['YES', 'NO', 'YES']",
  "sample2_input": "2\n5 3\n4 8",
  "sample2_output": "['NO', 'YES']",
  "sample3_input": "1\n6 9",
  "sample3_output": "['YES']",
  "sample4_input": "1\n10 5",
  "sample4_output": "['NO']",
  "sample5_input": "1\n15 15",
  "sample5_output": "['NO']"
    },
    {
        "title": "Palindrome Reorder",
        "query": "Given a string, your task is to reorder its letters in such a way that it becomes a palindrome (i.e., it reads the same forwards and backwards).\nInput\nThe only input line has a string of length n consisting of characters A\u2013Z.\nOutput\nPrint a palindrome consisting of the characters of the original string. You may print any valid solution. If there are no solutions, print \"NO SOLUTION\".\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\nAAAACACBA\n\nOutput:\nAACABACAA\n",
        "solution": "def main(s):\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    odd_count = 0\n    odd_char = ''\n    first_half = ''\n    for char, count in freq.items():\n        if count % 2 == 1:\n            odd_count += 1\n            odd_char = char\n        first_half += char * (count // 2)\n    if odd_count > 1:\n        return 'NO SOLUTION'\n    second_half = first_half[::-1]\n    if odd_count == 1:\n        return first_half + odd_char + second_half\n    else:\n        return first_half + second_half",
  "sample1_input": "AAAACACBA",
  "sample1_output": "AACABACAA",
  "sample2_input": "ABCDABC",
  "sample2_output": "NO SOLUTION",
  "sample3_input": "AABB",
  "sample3_output": "ABBA",
  "sample4_input": "AAAAABBBBBCCCCC",
  "sample4_output": "ABCABCABCBA",
  "sample5_input": "XYZXYZXYZ",
  "sample5_output": "XYZXYZXYZ"
    },
    {
        "title": "Gray Code",
        "query": "A Gray code is a list of all 2^n bit strings of length n, where any two successive strings differ in exactly one bit (i.e., their Hamming distance is one).\nYour task is to create a Gray code for a given length n.\nInput\nThe only input line has an integer n.\nOutput\nPrint 2^n lines that describe the Gray code. You can print any valid solution.\nConstraints\n\n1 \\le n \\le 16\n\nExample\nInput:\n2\n\nOutput:\n00\n01\n11\n10\n",
        "solution": "",
        "sample": ""
    },
    {
        "title": "Tower of Hanoi",
        "query": "The Tower of Hanoi game consists of three stacks (left, middle and right) and n round disks of different sizes. Initially, the left stack has all the disks, in increasing order of size from top to bottom. \nThe goal is to move all the disks to the right stack using the middle stack. On each move you can move the uppermost disk from a stack to another stack. In addition, it is not allowed to place a larger disk on a smaller disk.\nYour task is to find a solution that minimizes the number of moves.\nInput\nThe only input line has an integer n: the number of disks.\nOutput\nFirst print an integer k: the minimum number of moves.\nAfter this, print k lines that describe the moves. Each line has two integers a and b: you move a disk from stack a to stack b.\nConstraints\n\n1 \\le n \\le 16\n\nExample\nInput:\n2\n\nOutput:\n3\n1 2\n1 3\n2 3\n",
        "solution": "def main(n):\n    moves = []\n\n    def hanoi(n, source, auxiliary, target):\n        if n == 1:\n            moves.append((source, target))\n        else:\n            hanoi(n - 1, source, target, auxiliary)\n            moves.append((source, target))\n            hanoi(n - 1, auxiliary, source, target)\n\n    hanoi(n, '1', '2', '3')\n\n    return len(moves), moves",
  "sample1_input": "2",
  "sample1_output": "[('1', '2'), ('1', '3'), ('2', '3')]",
  "sample2_input": "3",
  "sample2_output": "[('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3')]",
  "sample3_input": "1",
  "sample3_output": "[('1', '3')]",
  "sample4_input": "4",
  "sample4_output": "[('1', '2'), ('1', '3'), ('2', '3'), ('1', '2'), ('3', '1'), ('3', '2'), ('1', '2'), ('1', '3'), ('2', '3'), ('2', '1'), ('3', '1'), ('2', '3'), ('1', '2'), ('1', '3'), ('2', '3')]",
  "sample5_input": "5",
  "sample5_output": "[('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3'), ('1', '2'), ('3', '2'), ('3', '1'), ('2', '1'), ('3', '2'), ('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3'), ('2', '1'), ('3', '2'), ('1', '3'), ('1', '2'), ('3', '2'), ('1', '3'), ('2', '1'), ('2', '3'), ('1', '3')]"

    },
    {
        "title": "Creating Strings",
        "query": "Given a string, your task is to generate all different strings that can be created using its characters.\nInput\nThe only input line has a string of length n. Each character is between a\u2013z.\nOutput\nFirst print an integer k: the number of strings. Then print k lines: the strings in alphabetical order.\nConstraints\n\n1 \\le n \\le 8\n\nExample\nInput:\naabac\n\nOutput:\n20\naaabc\naaacb\naabac\naabca\naacab\naacba\nabaac\nabaca\nabcaa\nacaab\nacaba\nacbaa\nbaaac\nbaaca\nbacaa\nbcaaa\ncaaab\ncaaba\ncabaa\ncbaaa\n",
        "solution": "from itertools import permutations\n\ndef main(s):\n    all_permutations = set(permutations(s))\n    result = sorted([''.join(p) for p in all_permutations])\n    return len(result), result",
  "sample1_input": "aabac",
  "sample1_output": "[20, ['aaabc', 'aaacb', 'aabac', 'aabca', 'aacab', 'aacba', 'abaac', 'abaca', 'abcaa', 'acaab', 'acaba', 'acbaa', 'baaac', 'baaca', 'bacaa', 'bcaaa', 'caaab', 'caaba', 'cabaa', 'cbaaa']]",
  "sample2_input": "abcd",
  "sample2_output": "[24, ['abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba']]",
  "sample3_input": "xyz",
  "sample3_output": "[6, ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx']]",
  "sample4_input": "aa",
  "sample4_output": "[2, ['aa', 'aa']]",
  "sample5_input": "abcde",
  "sample5_output": "[120, ['abcde', 'abced', 'abdec', 'abecd', 'abecd', 'abced', 'acdeb', 'acbed', 'acebd', 'acebd', 'acbed', 'acdeb', 'adceb', 'adceb', 'adecb', 'adebc', 'adbec', 'adbce', 'aedcb', 'aedbc', 'aebdc', 'aebcd', 'aebcd', 'aebdc', 'aedbc', 'aedcb', 'adbce', 'adbec', 'adebc', 'adecb', 'acdeb', 'acdeb', 'acbed', 'acebd', 'acebd', 'acbed', 'abced', 'abced', 'abecd', 'abdec', 'abcde', 'abcde']]"

    },
    {
        "title": "Apple Division",
        "query": "There are n apples with known weights. Your task is to divide the apples into two groups so that the difference between the weights of the groups is minimal.\nInput\nThe first input line has an integer n: the number of apples.\nThe next line has n integers p_1,p_2,\\dots,p_n: the weight of each apple.\nOutput\nPrint one integer: the minimum difference between the weights of the groups.\nConstraints\n\n1 \\le n \\le 20\n1 \\le p_i \\le 10^9\n\nExample\nInput:\n5\n3 2 7 4 1\n\nOutput:\n1\n\nExplanation: Group 1 has weights 2, 3 and 4 (total weight 9), and group 2 has weights 1 and 7 (total weight 8).\n",
        "solution": "def main(n, weights):\n    total_weight = sum(weights)\n    half_weight = total_weight // 2\n\n    dp = [[False] * (half_weight + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(half_weight + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= weights[i - 1]:\n                dp[i][j] = dp[i][j] or dp[i - 1][j - weights[i - 1]]\n\n    for w in range(half_weight, -1, -1):\n        if dp[n][w]:\n            return total_weight - 2 * w",
  "sample1_input": "5\n3 2 7 4 1",
  "sample1_output": "1",
  "sample2_input": "4\n1 1 1 1",
  "sample2_output": "0",
  "sample3_input": "3\n5 5 10",
  "sample3_output": "0",
  "sample4_input": "6\n1 2 3 4 5 6",
  "sample4_output": "1",
  "sample5_input": "10\n1 2 3 4 5 6 7 8 9 10",
  "sample5_output": "0"
    },
    {
        "title": "Chessboard and Queens",
        "query": "Your task is to place eight queens on a chessboard so that no two queens are attacking each other. As an additional challenge, each square is either free or reserved, and you can only place queens on the free squares. However, the reserved squares do not prevent queens from attacking each other.\nHow many possible ways are there to place the queens?\nInput\nThe input has eight lines, and each of them has eight characters. Each square is either free (.) or reserved (*).\nOutput\nPrint one integer: the number of ways you can place the queens.\nExample\nInput:\n........\n........\n..*.....\n........\n........\n.....**.\n...*....\n........\n\nOutput:\n65\n",
        "solution": "def main(board):\n    def is_safe(row, col):\n        # Check left side of the current row\n        for i in range(col):\n            if board[row][i] == 'Q':\n                return False\n        \n        # Check upper-left diagonal\n        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n            if board[i][j] == 'Q':\n                return False\n        \n        # Check lower-left diagonal\n        for i, j in zip(range(row, len(board), 1), range(col, -1, -1)):\n            if board[i][j] == 'Q':\n                return False\n        \n        return True\n\n    def solve(row):\n        if row == len(board):\n            # A valid placement is found\n            solutions.append(board[:])\n            return\n        \n        for col in range(len(board)):\n            if is_safe(row, col):\n                board[row][col] = 'Q'\n                solve(row + 1)\n                board[row][col] = '.'\n\n    solutions = []\n    solve(0)\n    return len(solutions)",
  "sample1_input": "........\n........\n..*.....\n........\n........\n.....**.\n...*....\n........",
  "sample1_output": "65",
  "sample2_input": "........\n........\n........\n........\n........\n........\n........\n........",
  "sample2_output": "92",
  "sample3_input": "********\n********\n********\n********\n********\n********\n********\n********",
  "sample3_output": "0",
  "sample4_input": "........\n.*......\n........\n........\n........\n........\n........\n........",
  "sample4_output": "7",
  "sample5_input": "........\n........\n........\n........\n........\n........\n........\n.*......",
  "sample5_output": "7"
    },
    {
        "title": "Digit Queries",
        "query": "Consider an infinite string that consists of all positive integers in increasing order:\n12345678910111213141516171819202122232425...\n\nYour task is to process q queries of the form: what is the digit at position k in the string?\nInput\nThe first input line has an integer q: the number of queries.\nAfter this, there are q lines that describe the queries. Each line has an integer k: a 1-indexed position in the string.\nOutput\nFor each query, print the corresponding digit.\nConstraints\n\n1 \\le q \\le 1000\n1 \\le k \\le 10^{18}\n\nExample\nInput:\n3\n7\n19\n12\n\nOutput:\n7\n4\n1\n",
        "solution": "def main(q, queries):\n    result = []\n    for k in queries:\n        # Initialize variables to keep track of the current position and the current number\n        current_position = 0\n        current_number = 1\n        # Calculate the length of the current number\n        current_length = len(str(current_number))\n        # Keep moving forward in the string until we reach the desired position k\n        while current_position + current_length < k:\n            current_position += current_length\n            current_number += 1\n            current_length = len(str(current_number))\n        # Calculate the digit at the desired position\n        digit = int(str(current_number)[k - current_position - 1])\n        result.append(digit)\n    return result",
  "sample1_input": "3\n7\n19\n12",
  "sample1_output": "[7, 4, 1]",
  "sample2_input": "4\n1\n10\n100\n1000",
  "sample2_output": "[1, 1, 5, 3]",
  "sample3_input": "2\n5\n25",
  "sample3_output": "[5, 7]",
  "sample4_input": "1\n50",
  "sample4_output": "[5]",
  "sample5_input": "2\n9\n99",
  "sample5_output": "[9, 4]"
    },
    {
        "title": "Grid Paths",
        "query": "There are 88418 paths in a 7 \\times 7 grid from the upper-left square to the lower-left square. Each path corresponds to a 48-character description consisting of characters D (down), U (up), L (left) and R (right).\nFor example, the path\n\ncorresponds to the description DRURRRRRDDDLUULDDDLDRRURDDLLLLLURULURRUULDLLDDDD.\nYou are given a description of a path which may also contain characters ? (any direction). Your task is to calculate the number of paths that match the description.\nInput\nThe only input line has a 48-character string of characters ?, D, U, L and R.\nOutput\nPrint one integer: the total number of paths.\nExample\nInput:\n??????R??????U??????????????????????????LD????D?\n\nOutput:\n201\n",
         "solution": "def main(path_description):\n    # Initialize a matrix to store the number of ways to reach each cell\n    dp = [[0] * 7 for _ in range(7)]\n    dp[0][0] = 1\n\n    # Define the possible directions\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    # Iterate through the path description\n    for char in path_description:\n        new_dp = [[0] * 7 for _ in range(7)]\n        for i in range(7):\n            for j in range(7):\n                # Skip cells that are not reachable\n                if dp[i][j] == 0:\n                    continue\n                if char == '?':\n                    # For '?' character, distribute the ways to all possible directions\n                    for dx, dy in directions:\n                        ni, nj = i + dx, j + dy\n                        if 0 <= ni < 7 and 0 <= nj < 7:\n                            new_dp[ni][nj] += dp[i][j]\n                else:\n                    # Move in the specified direction\n                    if char == 'D':\n                        ni, nj = i + 1, j\n                    elif char == 'U':\n                        ni, nj = i - 1, j\n                    elif char == 'L':\n                        ni, nj = i, j - 1\n                    else:\n                        ni, nj = i, j + 1\n                    if 0 <= ni < 7 and 0 <= nj < 7:\n                        new_dp[ni][nj] += dp[i][j]\n        dp = new_dp\n\n    # Return the number of ways to reach the lower-left cell\n    return dp[6][0]",
  "sample1_input": "??????R??????U??????????????????????????LD????D?",
  "sample1_output": "201",
  "sample2_input": "????????????????????????????????????????????",
  "sample2_output": "88418",
  "sample3_input": "UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU",
  "sample3_output": "0",
  "sample4_input": "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD",
  "sample4_output": "0",
  "sample5_input": "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD",
  "sample5_output": "0"
    },
    {
        "title": "Distinct Numbers",
        "query": "You are given a list of n integers, and your task is to calculate the number of distinct values in the list.\nInput\nThe first input line has an integer n: the number of values.\nThe second line has n integers x_1,x_2,\\dots,x_n.\nOutput\nPrint one integers: the number of distinct values.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5\n2 3 2 2 3\n\nOutput:\n2\n",
         "solution": "def main(n, values):\n    distinct_values = set()\n    for value in values:\n        distinct_values.add(value)\n    return len(distinct_values)",
  "sample1_input": "5\n2 3 2 2 3",
  "sample1_output": "2",
  "sample2_input": "10\n1 2 3 4 5 6 7 8 9 10",
  "sample2_output": "10",
  "sample3_input": "5\n5 5 5 5 5",
  "sample3_output": "1",
  "sample4_input": "6\n1 1 2 2 3 3",
  "sample4_output": "3",
  "sample5_input": "3\n10 10 10",
  "sample5_output": "1"
    },
    {
        "title": "Apartments",
        "query": "There are n applicants and m free apartments. Your task is to distribute the apartments so that as many applicants as possible will get an apartment.\nEach applicant has a desired apartment size, and they will accept any apartment whose size is close enough to the desired size.\nInput\nThe first input line has three integers n, m, and k: the number of applicants, the number of apartments, and the maximum allowed difference.\nThe next line contains n integers a_1, a_2, \\ldots, a_n: the desired apartment size of each applicant. If the desired size of an applicant is x, he or she will accept any apartment whose size is between x-k and x+k.\nThe last line contains m integers b_1, b_2, \\ldots, b_m: the size of each apartment.\nOutput\nPrint one integer: the number of applicants who will get an apartment.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n0 \\le k \\le 10^9\n1 \\le a_i, b_i \\le 10^9\n\nExample\nInput:\n4 3 5\n60 45 80 60\n30 60 75\n\nOutput:\n2\n",
        "solution": "def main(n, m, k, applicants, apartments):\n    applicants.sort()\n    apartments.sort()\n    ans = 0\n    i, j = 0, 0\n    while i < n and j < m:\n        if abs(applicants[i] - apartments[j]) <= k:\n            ans += 1\n            i += 1\n            j += 1\n        elif applicants[i] < apartments[j]:\n            i += 1\n        else:\n            j += 1\n    return ans",
  "sample1_input": "4 3 5\n60 45 80 60\n30 60 75",
  "sample1_output": "2",
  "sample2_input": "5 5 2\n70 80 90 100 110\n85 80 75 70 65",
  "sample2_output": "5",
  "sample3_input": "3 4 10\n50 70 90\n85 70 100 45",
  "sample3_output": "2",
  "sample4_input": "2 3 1\n10 20\n30 10 25",
  "sample4_output": "2",
  "sample5_input": "3 3 0\n100 200 300\n100 200 300",
  "sample5_output": "3"
    },
    {
        "title": "Ferris Wheel",
        "query": "There are n children who want to go to a Ferris wheel, and your task is to find a gondola for each child.\nEach gondola may have one or two children in it, and in addition, the total weight in a gondola may not exceed x. You know the weight of every child.\nWhat is the minimum number of gondolas needed for the children?\nInput\nThe first input line contains two integers n and x: the number of children and the maximum allowed weight.\nThe next line contains n integers p_1,p_2,\\ldots,p_n: the weight of each child.\nOutput\nPrint one integer: the minimum number of gondolas.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x \\le 10^9\n1 \\le p_i \\le x\n\nExample\nInput:\n4 10\n7 2 3 9\n\nOutput:\n3\n",
        "solution": "def main(n, x, weights):\n    weights.sort()\n    left, right = 0, n - 1\n    gondolas = 0\n    while left <= right:\n        if weights[left] + weights[right] <= x:\n            left += 1\n            right -= 1\n        else:\n            right -= 1\n        gondolas += 1\n    return gondolas",
  "sample1_input": "4 10\n7 2 3 9",
  "sample1_output": "3",
  "sample2_input": "5 7\n4 4 3 1 2",
  "sample2_output": "3",
  "sample3_input": "3 5\n5 5 5",
  "sample3_output": "2",
  "sample4_input": "6 6\n2 2 2 2 2 2",
  "sample4_output": "3",
  "sample5_input": "4 100\n50 30 20 70",
  "sample5_output": "2"
    },
    {
        "title": "Concert Tickets",
        "query": "There are n concert tickets available, each with a certain price. Then, m customers arrive, one after another.\nEach customer announces the maximum price they are willing to pay for a ticket, and after this, they will get a ticket with the nearest possible price such that it does not exceed the maximum price.\nInput\nThe first input line contains integers n and m: the number of tickets and the number of customers.\nThe next line contains n integers h_1,h_2,\\ldots,h_n: the price of each ticket.\nThe last line contains m integers t_1,t_2,\\ldots,t_m: the maximum price for each customer in the order they arrive.\nOutput\nPrint, for each customer, the price that they will pay for their ticket. After this, the ticket cannot be purchased again.\nIf a customer cannot get any ticket, print -1.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n1 \\le h_i, t_i \\le 10^9\n\nExample\nInput:\n5 3\n5 3 7 8 5\n4 8 3\n\nOutput:\n3\n8\n-1\n",
        "solution": "def main(n, m, tickets, customers):\n    tickets.sort()\n    results = []\n    for customer in customers:\n        left, right = 0, n - 1\n        ticket_idx = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if tickets[mid] <= customer:\n                ticket_idx = mid\n                left = mid + 1\n            else:\n                right = mid - 1\n        if ticket_idx == -1:\n            results.append(-1)\n        else:\n            results.append(tickets[ticket_idx])\n            del tickets[ticket_idx]\n            n -= 1\n    return results",
  "sample1_input": "5 3\n5 3 7 8 5\n4 8 3",
  "sample1_output": "[3, 8, -1]",
  "sample2_input": "6 4\n2 2 2 2 2 3\n3 2 2 1",
  "sample2_output": "[2, 2, 2, -1]",
  "sample3_input": "4 3\n1 2 3 4\n3 4 5",
  "sample3_output": "[3, 4, -1]",
  "sample4_input": "5 5\n10 20 30 40 50\n25 35 10 5 15",
  "sample4_output": "[20, 30, 10, -1, 40]",
  "sample5_input": "3 3\n7 7 7\n6 5 8",
  "sample5_output": "[-1, -1, -1]"
    },
    {
        "title": "Restaurant Customers",
        "query": "You are given the arrival and leaving times of n customers in a restaurant.\nWhat was the maximum number of customers in the restaurant at any time?\nInput\nThe first input line has an integer n: the number of customers.\nAfter this, there are n lines that describe the customers. Each line has two integers a and b: the arrival and leaving times of a customer.\nYou may assume that all arrival and leaving times are distinct.\nOutput\nPrint one integer: the maximum number of customers.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a &lt; b \\le 10^9\n\nExample\nInput:\n3\n5 8\n2 4\n3 9\n\nOutput:\n2\n",
        "solution": "def main(n, customers):\n    events = []\n    for a, b in customers:\n        events.append((a, 1))\n        events.append((b, -1))\n    events.sort()\n    max_customers = 0\n    current_customers = 0\n    for _, event in events:\n        current_customers += event\n        max_customers = max(max_customers, current_customers)\n    return max_customers",
  "sample1_input": "3\n5 8\n2 4\n3 9",
  "sample1_output": "2",
  "sample2_input": "5\n1 2\n2 3\n3 4\n4 5\n5 6",
  "sample2_output": "1",
  "sample3_input": "4\n1 5\n2 6\n3 7\n4 8",
  "sample3_output": "4",
  "sample4_input": "6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7",
  "sample4_output": "1",
  "sample5_input": "3\n1 5\n2 6\n3 7",
  "sample5_output": "3"
    },
    {
        "title": "Movie Festival",
        "query": "In a movie festival n movies will be shown. You know the starting and ending time of each movie. What is the maximum number of movies you can watch entirely?\nInput\nThe first input line has an integer n: the number of movies.\nAfter this, there are n lines that describe the movies. Each line has two integers a and b: the starting and ending times of a movie.\nOutput\nPrint one integer: the maximum number of movies.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a &lt; b \\le 10^9\n\nExample\nInput:\n3\n3 5\n4 9\n5 8\n\nOutput:\n2\n",
         "solution": "def main(n, movies):\n    movies.sort(key=lambda x: x[1])\n    current_end = -1\n    count = 0\n    for movie in movies:\n        start, end = movie\n        if start >= current_end:\n            current_end = end\n            count += 1\n    return count",
  "sample1_input": "3\n3 5\n4 9\n5 8",
  "sample1_output": "2",
  "sample2_input": "5\n1 2\n2 3\n3 4\n4 5\n5 6",
  "sample2_output": "5",
  "sample3_input": "4\n1 5\n2 6\n3 7\n4 8",
  "sample3_output": "1",
  "sample4_input": "6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7",
  "sample4_output": "1",
  "sample5_input": "3\n1 5\n2 6\n3 7",
  "sample5_output": "2"
    },
    {
        "title": "Sum of Two Values",
        "query": "You are given an array of n integers, and your task is to find two values (at distinct positions) whose sum is x.\nInput\nThe first input line has two integers n and x: the array size and the target sum.\nThe second line has n integers a_1,a_2,\\dots,a_n: the array values.\nOutput\nPrint two integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x,a_i \\le 10^9\n\nExample\nInput:\n4 8\n2 7 5 1\n\nOutput:\n2 4\n",
         "solution": "def main(n, x, arr):\n    seen = {}\n    for i, num in enumerate(arr):\n        complement = x - num\n        if complement in seen:\n            return [seen[complement] + 1, i + 1]\n        seen[num] = i\n    return 'IMPOSSIBLE'",
  "sample1_input": "4 8\n2 7 5 1",
  "sample1_output": "2 4",
  "sample2_input": "5 12\n4 9 6 3 8",
  "sample2_output": "1 3",
  "sample3_input": "3 10\n1 2 3",
  "sample3_output": "1 3",
  "sample4_input": "6 15\n10 7 8 6 9 5",
  "sample4_output": "1 2",
  "sample5_input": "4 7\n3 2 4 5",
  "sample5_output": "1 4"
    },
    {
        "title": "Maximum Subarray Sum",
        "query": "Given an array of n integers, your task is to find the maximum sum of values in a contiguous, nonempty subarray.\nInput\nThe first input line has an integer n: the size of the array.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nOutput\nPrint one integer: the maximum subarray sum.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n-10^9 \\le x_i \\le 10^9\n\nExample\nInput:\n8\n-1 3 -2 5 3 -5 2 2\n\nOutput:\n9\n",
        "solution": "def main(n, arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    for i in range(1, n):\n        current_sum = max(arr[i], current_sum + arr[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
  "sample1_input": "8\n-1 3 -2 5 3 -5 2 2",
  "sample1_output": "9",
  "sample2_input": "6\n-2 -3 -4 -1 -2 -5",
  "sample2_output": "-1",
  "sample3_input": "5\n5 -2 5 3 -5",
  "sample3_output": "11",
  "sample4_input": "4\n1 2 3 4",
  "sample4_output": "10",
  "sample5_input": "7\n-2 1 -3 4 -1 2 1",
  "sample5_output": "5"
    },
    {
        "title": "Stick Lengths",
        "query": "There are n sticks with some lengths. Your task is to modify the sticks so that each stick has the same length.\nYou can either lengthen and shorten each stick. Both operations cost x where x is the difference between the new and original length.\nWhat is the minimum total cost?\nInput\nThe first input line contains an integer n: the number of sticks.\nThen there are n integers: p_1,p_2,\\ldots,p_n: the lengths of the sticks.\nOutput\nPrint one integer: the minimum total cost.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le p_i \\le 10^9\n\nExample\nInput:\n5\n2 3 1 5 2\n\nOutput:\n5\n",
        "solution": "def main(n, sticks):\n    total_cost = 0\n    sticks.sort()\n    median = sticks[n // 2]\n    for stick in sticks:\n        total_cost += abs(stick - median)\n    return total_cost",
  "sample1_input": "5\n2 3 1 5 2",
  "sample1_output": "5",
  "sample2_input": "4\n1 1 1 1",
  "sample2_output": "0",
  "sample3_input": "6\n1 1 2 2 3 3",
  "sample3_output": "5",
  "sample4_input": "3\n5 5 5",
  "sample4_output": "0",
  "sample5_input": "7\n10 20 30 40 50 60 70",
  "sample5_output": "105"
    },
    {
        "title": "Missing Coin Sum",
        "query": "You have n coins with positive integer values. What is the smallest sum you cannot create using a subset of the coins?\nInput\nThe first input line has an integer n: the number of coins.\nThe second line has n integers x_1,x_2,\\dots,x_n: the value of each coin.\nOutput\nPrint one integer: the smallest coin sum.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5\n2 9 1 2 7\n\nOutput:\n6\n",
        "solution": "def main(n, coins):\n    coins.sort()\n    smallest_sum = 1\n    for coin in coins:\n        if coin <= smallest_sum:\n            smallest_sum += coin\n        else:\n            break\n    return smallest_sum",
  "sample1_input": "5\n2 9 1 2 7",
  "sample1_output": "6",
  "sample2_input": "3\n1 2 4",
  "sample2_output": "8",
  "sample3_input": "4\n1 3 6 8",
  "sample3_output": "19",
  "sample4_input": "5\n5 10 20 40 80",
  "sample4_output": "1",
  "sample5_input": "6\n1 1 1 1 1 1",
  "sample5_output": "7"
    },
    {
        "title": "Collecting Numbers",
        "query": "You are given an array that contains each number between 1 \\dots n exactly once. Your task is to collect the numbers from 1 to n in increasing order.\nOn each round, you go through the array from left to right and collect as many numbers as possible. What will be the total number of rounds?\nInput\nThe first line has an integer n: the array size.\nThe next line has n integers x_1,x_2,\\dots,x_n: the numbers in the array.\nOutput\nPrint one integer: the number of rounds.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n\nExample\nInput:\n5\n4 2 1 5 3\n\nOutput:\n3\n",
         "solution": "def main(n, arr):\n    rounds = 0\n    current_expected = 1\n    for x in arr:\n        if x == current_expected:\n            current_expected += 1\n        else:\n            rounds += 1\n    return rounds",
  "sample1_input": "5\n4 2 1 5 3",
  "sample1_output": "3",
  "sample2_input": "4\n1 2 3 4",
  "sample2_output": "0",
  "sample3_input": "7\n5 1 6 3 7 2 4",
  "sample3_output": "4",
  "sample4_input": "5\n5 4 3 2 1",
  "sample4_output": "4",
  "sample5_input": "6\n1 3 2 5 4 6",
  "sample5_output": "1"
    },
    {
        "title": "Collecting Numbers II",
        "query": "You are given an array that contains each number between 1 \\dots n exactly once. Your task is to collect the numbers from 1 to n in increasing order.\nOn each round, you go through the array from left to right and collect as many numbers as possible.\nGiven m operations that swap two numbers in the array, your task is to report the number of rounds after each operation.\nInput\nThe first line has two integers n and m: the array size and the number of operations.\nThe next line has n integers x_1,x_2,\\dots,x_n: the numbers in the array.\nFinally, there are m lines that describe the operations. Each line has two integers a and b: the numbers at positions a and b are swapped.\nOutput\nPrint m integers: the number of rounds after each swap.\nConstraints\n\n1 \\le n, m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 3\n4 2 1 5 3\n2 3\n1 5\n2 3\n\nOutput:\n2\n3\n4\n",
        "solution": "def main(n, m, arr, operations):\n    def count_rounds(arr):\n        rounds = 0\n        current_expected = 1\n        for x in arr:\n            if x == current_expected:\n                current_expected += 1\n            else:\n                rounds += 1\n        return rounds\n\n    result = []\n    rounds = count_rounds(arr)\n    result.append(rounds)\n\n    for a, b in operations:\n        if arr[a - 1] > arr[b - 1]:\n            arr[a - 1], arr[b - 1] = arr[b - 1], arr[a - 1]\n            rounds = count_rounds(arr)\n        result.append(rounds)\n\n    return result",
  "sample1_input": "5 3\n4 2 1 5 3\n2 3\n1 5\n2 3",
  "sample1_output": "2\n3\n4",
  "sample2_input": "4 2\n1 2 3 4\n1 3\n2 4",
  "sample2_output": "0\n0",
  "sample3_input": "6 1\n2 4 6 1 3 5\n1 6",
  "sample3_output": "2",
  "sample4_input": "8 4\n5 1 6 4 3 8 7 2\n2 7\n4 5\n1 3\n6 8",
  "sample4_output": "4\n5\n5\n6",
  "sample5_input": "5 5\n4 2 1 5 3\n2 3\n1 5\n2 3\n3 4\n4 5",
  "sample5_output": "2\n3\n4\n4\n4"
    },
    {
        "title": "Playlist",
        "query": "You are given a playlist of a radio station since its establishment. The playlist has a total of n songs.\nWhat is the longest sequence of successive songs where each song is unique?\nInput\nThe first input line contains an integer n: the number of songs.\nThe next line has n integers k_1,k_2,\\ldots,k_n: the id number of each song.\nOutput\nPrint the length of the longest sequence of unique songs.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le k_i \\le 10^9\n\nExample\nInput:\n8\n1 2 1 3 2 7 4 2\n\nOutput:\n5\n",
         "solution": "def main(n, songs):\n    last_occurrence = {}\n    longest_sequence = 0\n    current_sequence = 0\n    left_pointer = 0\n\n    for right_pointer in range(n):\n        song = songs[right_pointer]\n        if song in last_occurrence and last_occurrence[song] >= left_pointer:\n            left_pointer = last_occurrence[song] + 1\n\n        last_occurrence[song] = right_pointer\n        current_sequence = right_pointer - left_pointer + 1\n        longest_sequence = max(longest_sequence, current_sequence)\n\n    return longest_sequence",
  "sample1_input": "8\n1 2 1 3 2 7 4 2",
  "sample1_output": "5",
  "sample2_input": "5\n1 2 3 4 5",
  "sample2_output": "5",
  "sample3_input": "10\n5 4 3 2 1 5 4 3 2 1",
  "sample3_output": "5",
  "sample4_input": "7\n1 2 3 4 5 6 7",
  "sample4_output": "7",
  "sample5_input": "7\n1 2 3 4 5 6 1",
  "sample5_output": "6"
    },
    {
        "title": "Towers",
        "query": "You are given n cubes in a certain order, and your task is to build towers using them. Whenever two cubes are one on top of the other, the upper cube must be smaller than the lower cube.\nYou must process the cubes in the given order. You can always either place the cube on top of an existing tower, or begin a new tower. What is the minimum possible number of towers?\nInput\nThe first input line contains an integer n: the number of cubes.\nThe next line contains n integers k_1,k_2,\\ldots,k_n: the sizes of the cubes.\nOutput\nPrint one integer: the minimum number of towers.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le k_i \\le 10^9\n\nExample\nInput:\n5\n3 8 2 1 5\n\nOutput:\n2\n",
         "solution": "def main(n, cubes):\n    towers = []\n\n    for cube in cubes:\n        placed = False\n\n        for i in range(len(towers)):\n            if towers[i][-1] >= cube:\n                towers[i].append(cube)\n                placed = True\n                break\n\n        if not placed:\n            towers.append([cube])\n\n    return len(towers)",
  "sample1_input": "5\n3 8 2 1 5",
  "sample1_output": "2",
  "sample2_input": "6\n4 4 4 4 4 4",
  "sample2_output": "6",
  "sample3_input": "7\n7 6 5 4 3 2 1",
  "sample3_output": "7",
  "sample4_input": "8\n8 1 7 2 6 3 5 4",
  "sample4_output": "1",
  "sample5_input": "4\n1 2 3 4",
  "sample5_output": "4"
    },
    {
        "title": "Traffic Lights",
        "query": "There is a street of length x whose positions are numbered 0,1,\\ldots,x. Initially there are no traffic lights, but n sets of traffic lights are added to the street one after another.\nYour task is to calculate the length of the longest passage without traffic lights after each addition.\nInput\nThe first input line contains two integers x and n: the length of the street and the number of sets of traffic lights.\nThen, the next line contains n integers p_1,p_2,\\ldots,p_n: the position of each set of traffic lights. Each position is distinct.\nOutput\nPrint the length of the longest passage without traffic lights after each addition.\nConstraints\n\n1 \\le x \\le 10^9\n1 \\le n \\le 2 \\cdot 10^5\n0 &lt; p_i &lt; x\n\nExample\nInput:\n8 3\n3 6 2\n\nOutput:\n5 3 3\n",
         "solution": "def main(x, n, lights):\n    gaps = [x]\n    lights_set = set(lights)\n    max_gap = x\n\n    for light in lights:\n        left_gap = light\n        right_gap = x - light\n\n        if left_gap in lights_set and right_gap in lights_set:\n            gaps.remove(max_gap)\n            gaps.append(left_gap)\n            gaps.append(right_gap)\n        elif left_gap in lights_set:\n            gaps.remove(max_gap)\n            gaps.append(left_gap)\n        elif right_gap in lights_set:\n            gaps.remove(max_gap)\n            gaps.append(right_gap)\n\n        max_gap = max(gaps)\n        print(max_gap)",
  "sample1_input": "8 3\n3 6 2",
  "sample1_output": "5\n3\n3",
  "sample2_input": "10 2\n4 7",
  "sample2_output": "6\n3",
  "sample3_input": "5 1\n1",
  "sample3_output": "4",
  "sample4_input": "12 4\n2 5 9 11",
  "sample4_output": "10\n6\n3\n1",
  "sample5_input": "7 2\n3 6",
  "sample5_output": "4\n3"
    },
    {
        "title": "Josephus Problem I",
        "query": "Consider a game where there are n children (numbered 1,2,\\dots,n) in a circle. During the game, every other child is removed from the circle until there are no children left. In which order will the children be removed?\nInput\nThe only input line has an integer n.\nOutput\nPrint n integers: the removal order.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n\nExample\nInput:\n7\n\nOutput:\n2 4 6 1 5 3 7\n",
         "solution": "def main(n):\n    result = []\n    queue = list(range(1, n + 1))\n    i = 0\n\n    while queue:\n        i = (i + 1) % len(queue)\n        result.append(queue[i])\n        queue.pop(i)\n\n    return result",
  "sample1_input": "7",
  "sample1_output": "2 4 6 1 5 3 7",
  "sample2_input": "5",
  "sample2_output": "2 4 1 5 3",
  "sample3_input": "3",
  "sample3_output": "2 1 3",
  "sample4_input": "10",
  "sample4_output": "2 4 6 8 10 3 7 1 9 5",
  "sample5_input": "1",
  "sample5_output": "1"
    },
    {
        "title": "Josephus Problem II",
        "query": "Consider a game where there are n children (numbered 1,2,\\dots,n) in a circle. During the game, repeatedly k children are skipped and one child is removed from the circle. In which order will the children be removed?\nInput\nThe only input line has two integers n and k.\nOutput\nPrint n integers: the removal order.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n0 \\le k \\le 10^9\n\nExample\nInput:\n7 2\n\nOutput:\n3 6 2 7 5 1 4\n",
        "solution": "def main(n, k):\n    result = []\n    circle = list(range(1, n + 1))\n    i = 0\n\n    while circle:\n        i = (i + k - 1) % len(circle)\n        result.append(circle.pop(i))\n\n    return result",
  "sample1_input": "7 2",
  "sample1_output": "3 6 2 7 5 1 4",
  "sample2_input": "5 1",
  "sample2_output": "1 2 3 4 5",
  "sample3_input": "3 0",
  "sample3_output": "1 2 3",
  "sample4_input": "10 3",
  "sample4_output": "3 6 9 2 7 1 8 5 10 4",
  "sample5_input": "1 0",
  "sample5_output": "1"
    },
    {
        "title": "Nested Ranges Check",
        "query": "Given n ranges, your task is to determine for each range if it contains some other range and if some other range contains it.\nRange [a,b] contains range [c,d] if a \\le c and d \\le b.\nInput\nThe first input line has an integer n: the number of ranges.\nAfter this, there are n lines that describe the ranges. Each line has two integers x and y: the range is [x,y].\nYou may assume that no range appears more than once in the input.\nOutput\nFirst print a line that describes for each range (in the input order) if it contains some other range (1) or not (0).\nThen print a line that describes for each range (in the input order) if some other range contains it (1) or not (0).\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x &lt; y \\le 10^9\n\nExample\nInput:\n4\n1 6\n2 4\n4 8\n3 6\n\nOutput:\n1 0 0 0\n0 1 0 1\n",
       "solution": "def main(n, ranges):\n    contains = [0] * n\n    is_contained = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                a, b = ranges[i]\n                c, d = ranges[j]\n                if a <= c and d <= b:\n                    contains[i] = 1\n                if a >= c and d >= b:\n                    is_contained[i] = 1\n\n    return contains, is_contained",
  "sample1_input": "4\n1 6\n2 4\n4 8\n3 6",
  "sample1_output": "1 0 0 0\n0 1 0 1",
  "sample2_input": "3\n1 5\n2 4\n3 6",
  "sample2_output": "0 0 1\n1 1 0",
  "sample3_input": "2\n1 3\n4 6",
  "sample3_output": "0 0\n0 0",
  "sample4_input": "5\n1 5\n2 4\n3 6\n7 8\n8 10",
  "sample4_output": "0 0 0 1 0\n1 1 1 0 0",
  "sample5_input": "1\n1 10",
  "sample5_output": "0\n0"
    },
    {
        "title": "Nested Ranges Count",
        "query": "Given n ranges, your task is to count for each range how many other ranges it contains and how many other ranges contain it.\nRange [a,b] contains range [c,d] if a \\le c and d \\le b.\nInput\nThe first input line has an integer n: the number of ranges.\nAfter this, there are n lines that describe the ranges. Each line has two integers x and y: the range is [x,y].\nYou may assume that no range appears more than once in the input.\nOutput\nFirst print a line that describes for each range (in the input order) how many other ranges it contains.\nThen print a line that describes for each range (in the input order) how many other ranges contain it.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x &lt; y \\le 10^9\n\nExample\nInput:\n4\n1 6\n2 4\n4 8\n3 6\n\nOutput:\n2 0 0 0\n0 1 0 1\n",
        "solution": "def main(n, ranges):\n    contains = [0] * n\n    is_contained = [0] * n\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                a, b = ranges[i]\n                c, d = ranges[j]\n                if a <= c and d <= b:\n                    contains[i] += 1\n                if a >= c and d >= b:\n                    is_contained[i] += 1\n\n    return contains, is_contained",
  "sample1_input": "4\n1 6\n2 4\n4 8\n3 6",
  "sample1_output": "2 0 0 0\n0 1 0 1",
  "sample2_input": "3\n1 5\n2 4\n3 6",
  "sample2_output": "0 0 1\n1 1 0",
  "sample3_input": "2\n1 3\n4 6",
  "sample3_output": "0 0\n0 0",
  "sample4_input": "5\n1 5\n2 4\n3 6\n7 8\n8 10",
  "sample4_output": "0 0 0 1 0\n1 1 1 0 0",
  "sample5_input": "1\n1 10",
  "sample5_output": "0\n0"
    },
    {
        "title": "Room Allocation",
        "query": "There is a large hotel, and n customers will arrive soon. Each customer wants to have a single room.\nYou know each customer's arrival and departure day. Two customers can stay in the same room if the departure day of the first customer is earlier than the arrival day of the second customer.\nWhat is the minimum number of rooms that are needed to accommodate all customers? And how can the rooms be allocated?\nInput\nThe first input line contains an integer n: the number of customers.\nThen there are n lines, each of which describes one customer. Each line has two integers a and b: the arrival and departure day.\nOutput\nPrint first an integer k: the minimum number of rooms required.\nAfter that, print a line that contains the room number of each customer in the same order as in the input. The rooms are numbered 1,2,\\ldots,k. You can print any valid solution.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a \\le b \\le 10^9\n\nExample\nInput:\n3\n1 2\n2 4\n4 4\n\nOutput:\n2\n1 2 1\n",
         "solution": "def main(n, customers):\n    sorted_customers = sorted(enumerate(customers, start=1), key=lambda x: x[1][0])\n    rooms = [0] * n\n    room_count = 1\n    end_times = [sorted_customers[0][1][1]]\n    rooms[sorted_customers[0][0] - 1] = room_count\n\n    for i in range(1, n):\n        customer = sorted_customers[i][1]\n        start_time = customer[0]\n        end_time = customer[1]\n\n        if start_time > end_times[0]:\n            room_count += 1\n            end_times[0] = end_time\n            rooms[sorted_customers[i][0] - 1] = room_count\n        else:\n            for j in range(len(end_times)):\n                if start_time > end_times[j]:\n                    end_times[j] = end_time\n                    rooms[sorted_customers[i][0] - 1] = j + 1\n                    break\n            else:\n                room_count += 1\n                end_times.append(end_time)\n                rooms[sorted_customers[i][0] - 1] = room_count\n\n    return room_count, rooms",
  "sample1_input": "3\n1 2\n2 4\n4 4",
  "sample1_output": "2\n1 2 1",
  "sample2_input": "4\n1 2\n2 4\n4 4\n5 6",
  "sample2_output": "2\n1 2 1 2",
  "sample3_input": "5\n1 2\n2 4\n4 4\n5 6\n7 8",
  "sample3_output": "3\n1 2 1 2 3",
  "sample4_input": "3\n1 5\n2 6\n3 7",
  "sample4_output": "1\n1 1 1",
  "sample5_input": "6\n1 3\n2 4\n3 5\n4 6\n5 7\n6 8",
  "sample5_output": "1\n1 1 1 1 1 1"
    },
    {
        "title": "Factory Machines",
        "query": "A factory has n machines which can be used to make products. Your goal is to make a total of t products.\nFor each machine, you know the number of seconds it needs to make a single product. The machines can work simultaneously, and you can freely decide their schedule.\nWhat is the shortest time needed to make t products?\nInput\nThe first input line has two integers n and t: the number of machines and products.\nThe next line has n integers k_1,k_2,\\dots,k_n: the time needed to make a product using each machine.\nOutput\nPrint one integer: the minimum time needed to make t products.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le t \\le 10^9\n1 \\le k_i \\le 10^9\n\nExample\nInput:\n3 7\n3 2 5\n\nOutput:\n8\n\nExplanation: Machine 1 makes two products, machine 2 makes four products and machine 3 makes one product.\n",
        "solution": "def main(n, t, machines):\n    left = 1\n    right = 10**18\n\n    while left < right:\n        mid = (left + right) // 2\n        total_products = 0\n\n        for machine in machines:\n            total_products += mid // machine\n\n        if total_products >= t:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left",
  "sample1_input": "3 7\n3 2 5",
  "sample1_output": "8",
  "sample2_input": "1 10\n7",
  "sample2_output": "70",
  "sample3_input": "5 100\n1 2 3 4 5",
  "sample3_output": "40",
  "sample4_input": "2 1000000000\n3 5",
  "sample4_output": "2000000000",
  "sample5_input": "4 5\n2 2 2 2",
  "sample5_output": "6"
    },
    {
        "title": "Tasks and Deadlines",
        "query": "You have to process n tasks. Each task has a duration and a deadline, and you will process the tasks in some order one after another. Your reward for a task is d-f where d is its deadline and f is your finishing time. (The starting time is 0, and you have to process all tasks even if a task would yield negative reward.)\nWhat is your maximum reward if you act optimally?\nInput\nThe first input line has an integer n: the number of tasks.\nAfter this, there are n lines that describe the tasks. Each line has two integers a and d: the duration and deadline of the task.\nOutput\nPrint one integer: the maximum reward.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a,d \\le 10^6\n\nExample\nInput:\n3\n6 10\n8 15\n5 12\n\nOutput:\n2\n",
          "solution": "def main(n, tasks):\n    tasks.sort(key=lambda x: x[1])\n    time = 0\n    reward = 0\n\n    for task in tasks:\n        duration, deadline = task\n        time += duration\n        reward += deadline - time\n\n    return reward",
  "sample1_input": "3\n6 10\n8 15\n5 12",
  "sample1_output": "2",
  "sample2_input": "1\n7 5",
  "sample2_output": "0",
  "sample3_input": "4\n2 10\n3 12\n1 5\n5 15",
  "sample3_output": "20",
  "sample4_input": "2\n1 1\n1 1",
  "sample4_output": "1",
  "sample5_input": "5\n5 10\n4 15\n3 12\n2 5\n1 8",
  "sample5_output": "19"
    },
    {
        "title": "Reading Books",
        "query": "There are n books, and Kotivalo and Justiina are going to read them all. For each book, you know the time it takes to read it.\nThey both read each book from beginning to end, and they cannot read a book at the same time. What is the minimum total time required?\nInput\nThe first input line has an integer n: the number of books.\nThe second line has n integers t_1,t_2,\\dots,t_n: the time required to read each book.\nOutput\nPrint one integer: the minimum total time.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le t_i \\le 10^9\n\nExample\nInput:\n3\n2 8 3\n\nOutput:\n16\n",
       "solution": "def main(n, times):\n    times.sort()\n    total_time = 0\n\n    for i in range(n // 2):\n        total_time += times[n - i - 1]\n\n    return total_time",
  "sample1_input": "3\n2 8 3",
  "sample1_output": "16",
  "sample2_input": "1\n7",
  "sample2_output": "7",
  "sample3_input": "4\n2 10 1 5",
  "sample3_output": "15",
  "sample4_input": "2\n1 1",
  "sample4_output": "1",
  "sample5_input": "5\n5 10 3 2 8",
  "sample5_output": "21"
    },
    {
        "title": "Sum of Three Values",
        "query": "You are given an array of n integers, and your task is to find three values (at distinct positions) whose sum is x.\nInput\nThe first input line has two integers n and x: the array size and the target sum.\nThe second line has n integers a_1,a_2,\\dots,a_n: the array values.\nOutput\nPrint three integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE.\nConstraints\n\n1 \\le n \\le 5000\n1 \\le x,a_i \\le 10^9\n\nExample\nInput:\n4 8\n2 7 5 1\n\nOutput:\n1 3 4\n",
         "solution": "def main(n, x, arr):\n    positions = {}\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            target = x - arr[i] - arr[j]\n\n            if target in positions:\n                return [positions[target], i + 1, j + 1]\n\n            positions[arr[i]] = i + 1\n\n    return 'IMPOSSIBLE'",
  "sample1_input": "4 8\n2 7 5 1",
  "sample1_output": "1 3 4",
  "sample2_input": "3 10\n1 5 6",
  "sample2_output": "IMPOSSIBLE",
  "sample3_input": "5 15\n10 5 3 2 7",
  "sample3_output": "1 4 5",
  "sample4_input": "4 6\n3 1 2 5",
  "sample4_output": "1 2 4",
  "sample5_input": "6 13\n10 3 8 5 1 9",
  "sample5_output": "1 3 6"
    },
    {
        "title": "Sum of Four Values",
        "query": "You are given an array of n integers, and your task is to find four values (at distinct positions) whose sum is x.\nInput\nThe first input line has two integers n and x: the array size and the target sum.\nThe second line has n integers a_1,a_2,\\dots,a_n: the array values.\nOutput\nPrint four integers: the positions of the values. If there are several solutions, you may print any of them. If there are no solutions, print IMPOSSIBLE.\nConstraints\n\n1 \\le n \\le 1000\n1 \\le x,a_i \\le 10^9\n\nExample\nInput:\n8 15\n3 2 5 8 1 3 2 3\n\nOutput:\n2 4 6 7\n",
       "solution": "def main(n, x, arr):\n    positions = {}\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                target = x - arr[i] - arr[j] - arr[k]\n\n                if target in positions:\n                    return [positions[target], i + 1, j + 1, k + 1]\n\n                positions[arr[i]] = i + 1\n\n    return 'IMPOSSIBLE'",
  "sample1_input": "8 15\n3 2 5 8 1 3 2 3",
  "sample1_output": "2 4 6 7",
  "sample2_input": "6 10\n1 2 3 4 5 6",
  "sample2_output": "IMPOSSIBLE",
  "sample3_input": "7 19\n8 5 4 7 2 1 3",
  "sample3_output": "2 3 4 7",
  "sample4_input": "5 12\n3 4 5 6 7",
  "sample4_output": "1 2 4 5",
  "sample5_input": "4 7\n2 1 2 2",
  "sample5_output": "IMPOSSIBLE"
    },
    {
        "title": "Nearest Smaller Values",
        "query": "Given an array of n integers, your task is to find for each array position the nearest position to its left having a smaller value.\nInput\nThe first input line has an integer n: the size of the array.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nOutput\nPrint n integers: for each array position the nearest position with a smaller value. If there is no such position, print 0.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n8\n2 5 1 4 8 3 2 5\n\nOutput:\n0 1 0 3 4 3 3 7\n",
        "solution": "def main(n, arr):\n    stack = []\n    result = [0] * n\n\n    for i in range(n):\n        while stack and arr[i] < arr[stack[-1]]:\n            j = stack.pop()\n            result[j] = i + 1\n        stack.append(i)\n\n    return result",
  "sample1_input": "8\n2 5 1 4 8 3 2 5",
  "sample1_output": "0 1 0 3 4 3 3 7",
  "sample2_input": "6\n3 1 4 1 5 9",
  "sample2_output": "0 0 2 2 4 5",
  "sample3_input": "5\n5 4 3 2 1",
  "sample3_output": "0 1 2 3 4",
  "sample4_input": "7\n1 2 3 4 5 6 7",
  "sample4_output": "0 1 2 3 4 5 6",
  "sample5_input": "4\n4 4 4 4",
  "sample5_output": "0 0 0 0"
    },
    {
        "title": "Subarray Sums I",
        "query": "Given an array of n positive integers, your task is to count the number of subarrays having sum x.\nInput\nThe first input line has two integers n and x: the size of the array and the target sum x.\nThe next line has n integers a_1,a_2,\\dots,a_n: the contents of the array.\nOutput\nPrint one integer: the required number of subarrays.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x,a_i \\le 10^9\n\nExample\nInput:\n5 7\n2 4 1 2 7\n\nOutput:\n3\n",
         "solution": "def main(n, x, arr):\n    prefix_sum = {0: 1}\n    current_sum = 0\n    count = 0\n\n    for num in arr:\n        current_sum += num\n        if current_sum - x in prefix_sum:\n            count += prefix_sum[current_sum - x]\n        if current_sum in prefix_sum:\n            prefix_sum[current_sum] += 1\n        else:\n            prefix_sum[current_sum] = 1\n\n    return count",
  "sample1_input": "5 7\n2 4 1 2 7",
  "sample1_output": "3",
  "sample2_input": "6 10\n1 2 3 4 5 6",
  "sample2_output": "1",
  "sample3_input": "5 5\n5 5 5 5 5",
  "sample3_output": "5",
  "sample4_input": "5 15\n10 2 3 1 5",
  "sample4_output": "2",
  "sample5_input": "3 4\n1 2 3",
  "sample5_output": "1"
    },
    {
        "title": "Subarray Sums II",
        "query": "Given an array of n integers, your task is to count the number of subarrays having sum x.\nInput\nThe first input line has two integers n and x: the size of the array and the target sum x.\nThe next line has n integers a_1,a_2,\\dots,a_n: the contents of the array.\nOutput\nPrint one integer: the required number of subarrays.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n-10^9 \\le x,a_i \\le 10^9\n\nExample\nInput:\n5 7\n2 -1 3 5 -2\n\nOutput:\n2\n",
        "solution": "def main(n, x, arr):\n    prefix_sum = {0: 1}\n    current_sum = 0\n    count = 0\n\n    for num in arr:\n        current_sum += num\n        if current_sum - x in prefix_sum:\n            count += prefix_sum[current_sum - x]\n        if current_sum in prefix_sum:\n            prefix_sum[current_sum] += 1\n        else:\n            prefix_sum[current_sum] = 1\n\n    return count",
  "sample1_input": "5 7\n2 -1 3 5 -2",
  "sample1_output": "2",
  "sample2_input": "6 10\n1 2 3 4 5 6",
  "sample2_output": "0",
  "sample3_input": "5 5\n5 5 5 5 5",
  "sample3_output": "0",
  "sample4_input": "5 15\n10 2 3 1 5",
  "sample4_output": "1",
  "sample5_input": "3 4\n1 2 3",
  "sample5_output": "1"
    },
    {
        "title": "Subarray Divisibility",
        "query": "Given an array of n integers, your task is to count the number of subarrays where the sum of values is divisible by n.\nInput\nThe first input line has an integer n: the size of the array.\nThe next line has n integers a_1,a_2,\\dots,a_n: the contents of the array.\nOutput\nPrint one integer: the required number of subarrays.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n-10^9 \\le a_i \\le 10^9\n\nExample\nInput:\n5\n3 1 2 7 4\n\nOutput:\n1\n",
        "solution": "def main(n, arr):\n    prefix_remainder = {0: 1}\n    current_sum = 0\n    count = 0\n\n    for num in arr:\n        current_sum += num\n        remainder = current_sum % n\n        if remainder in prefix_remainder:\n            count += prefix_remainder[remainder]\n        if remainder in prefix_remainder:\n            prefix_remainder[remainder] += 1\n        else:\n            prefix_remainder[remainder] = 1\n\n    return count",
  "sample1_input": "5\n3 1 2 7 4",
  "sample1_output": "1",
  "sample2_input": "6\n2 2 2 2 2 2",
  "sample2_output": "15",
  "sample3_input": "4\n1 2 3 4",
  "sample3_output": "4",
  "sample4_input": "3\n1 2 3",
  "sample4_output": "2",
  "sample5_input": "5\n5 5 5 5 5",
  "sample5_output": "10"
    },
    {
        "title": "Subarray Distinct Values",
        "query": "Given an array of n integers, your task is to calculate the number of subarrays that have at most k distinct values.\nInput\nThe first input line has two integers n and k.\nThe next line has n integers x_1,x_2,\\dots,x_n: the contents of the array.\nOutput\nPrint one integer: the number of subarrays.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5 2\n1 2 3 1 1\n\nOutput:\n10\n",
        "solution": "def main(n, k, arr):\n    left = 0\n    count = 0\n    distinct_values = {}\n\n    for right in range(n):\n        if arr[right] not in distinct_values:\n            distinct_values[arr[right]] = 0\n        distinct_values[arr[right]] += 1\n\n        while len(distinct_values) > k:\n            distinct_values[arr[left]] -= 1\n            if distinct_values[arr[left]] == 0:\n                del distinct_values[arr[left]]\n            left += 1\n\n        count += right - left + 1\n\n    return count",
  "sample1_input": "5 2\n1 2 3 1 1",
  "sample1_output": "10",
  "sample2_input": "6 3\n1 2 1 2 1 2",
  "sample2_output": "17",
  "sample3_input": "4 1\n5 5 5 5",
  "sample3_output": "4",
  "sample4_input": "7 4\n1 2 3 4 5 6 7",
  "sample4_output": "21",
  "sample5_input": "5 2\n1 2 3 4 5",
  "sample5_output": "11"
    },
    {
        "title": "Array Division",
        "query": "You are given an array containing n positive integers.\nYour task is to divide the array into k subarrays so that the maximum sum in a subarray is as small as possible.\nInput\nThe first input line contains two integers n and k: the size of the array and the number of subarrays in the division.\nThe next line contains n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint one integer: the maximum sum in a subarray in the optimal division.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le k \\le n\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n5 3\n2 4 7 3 5\n\nOutput:\n8\n\nExplanation: An optimal division is [2,4],[7],[3,5] where the sums of the subarrays are 6,7,8. The largest sum is the last sum 8.\n",
        "solution": "import math\n\ndef main(n, k, arr):\n    left = max(arr)\n    right = sum(arr)\n\n    while left < right:\n        mid = (left + right) // 2\n        subarrays = 1\n        current_sum = 0\n\n        for num in arr:\n            if current_sum + num > mid:\n                subarrays += 1\n                current_sum = 0\n            current_sum += num\n\n        if subarrays <= k:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left",
  "sample1_input": "5 3\n2 4 7 3 5",
  "sample1_output": "8",
  "sample2_input": "6 2\n1 2 3 4 5 6",
  "sample2_output": "11",
  "sample3_input": "4 1\n5 5 5 5",
  "sample3_output": "5",
  "sample4_input": "7 4\n1 2 3 4 5 6 7",
  "sample4_output": "7",
  "sample5_input": "8 8\n1 2 3 4 5 6 7 8",
  "sample5_output": "8"
    },
    {
        "title": "Sliding Median",
        "query": "You are given an array of n integers. Your task is to calculate the median of each window of k elements, from left to right.\nThe median is the middle element when the elements are sorted. If the number of elements is even, there are two possible medians and we assume that the median is the smaller of them.\nInput\nThe first input line contains two integers n and k: the number of elements and the size of the window.\nThen there are n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint n-k+1 values: the medians.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n8 3\n2 4 3 5 8 1 2 1\n\nOutput:\n3 4 5 5 2 1\n",
        "solution": "from collections import deque\n\ndef main(n, k, arr):\n    result = []\n    window = deque()\n\n    for i in range(n):\n        if i >= k:\n            window.popleft()\n        while window and window[-1] > arr[i]:\n            window.pop()\n        window.append(arr[i])\n\n        if i >= k - 1:\n            result.append(window[k // 2] if k % 2 == 1 else min(window[k // 2], window[k // 2 - 1]))\n\n    return result",
  "sample1_input": "8 3\n2 4 3 5 8 1 2 1",
  "sample1_output": "3 4 5 5 2 1",
  "sample2_input": "6 2\n1 2 3 4 5 6",
  "sample2_output": "1 2 3 4 5",
  "sample3_input": "5 5\n1 2 3 4 5",
  "sample3_output": "3",
  "sample4_input": "7 4\n7 6 5 4 3 2 1",
  "sample4_output": "6 5 4 3 2",
  "sample5_input": "10 5\n10 9 8 7 6 5 4 3 2 1",
  "sample5_output": "6 5 4 3 2 1"
    },
    {
        "title": "Sliding Cost",
        "query": "You are given an array of n integers. Your task is to calculate for each window of k elements, from left to right, the minimum total cost of making all elements equal.\nYou can increase or decrease each element with cost x where x is the difference between the new and the original value. The total cost is the sum of such costs.\nInput\nThe first input line contains two integers n and k: the number of elements and the size of the window.\nThen there are n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nOutput n-k+1 values: the costs.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n8 3\n2 4 3 5 8 1 2 1\n\nOutput:\n2 2 5 7 7 1\n",
        "solution": "def main(n, k, arr):\n    costs = []\n    prefix_sum = [0]\n\n    for x in arr:\n        prefix_sum.append(prefix_sum[-1] + x)\n\n    for i in range(n - k + 1):\n        window_sum = prefix_sum[i + k] - prefix_sum[i]\n        window_avg = window_sum / k\n        cost = 0\n\n        for j in range(i, i + k):\n            cost += abs(arr[j] - window_avg)\n\n        costs.append(cost)\n\n    return costs",
  "sample1_input": "8 3\n2 4 3 5 8 1 2 1",
  "sample1_output": "2 2 5 7 7 1",
  "sample2_input": "6 2\n1 2 3 4 5 6",
  "sample2_output": "1 1 1 1 1",
  "sample3_input": "5 5\n1 2 3 4 5",
  "sample3_output": "2",
  "sample4_input": "7 4\n7 6 5 4 3 2 1",
  "sample4_output": "3 2 1 1",
  "sample5_input": "10 5\n10 9 8 7 6 5 4 3 2 1",
  "sample5_output": "5 4 3 2 1"
    },
    {
        "title": "Movie Festival II",
        "query": "In a movie festival, n movies will be shown. Syrj\u00e4l\u00e4's movie club consists of k members, who will be all attending the festival.\nYou know the starting and ending time of each movie. What is the maximum total number of movies the club members can watch entirely if they act optimally?\nInput\nThe first input line has two integers n and k: the number of movies and club members.\nAfter this, there are n lines that describe the movies. Each line has two integers a and b: the starting and ending time of a movie.\nOutput\nPrint one integer: the maximum total number of movies.\nConstraints\n\n1 \\le k \\le n \\le 2 \\cdot 10^5\n1 \\le a &lt; b \\le 10^9\n\nExample\nInput:\n5 2\n1 5\n8 10\n3 6\n2 5\n6 9\n\nOutput:\n4\n",
         "solution": "def main(n, k, movies):\n    movies.sort(key=lambda x: x[1])\n    selected_movies = 0\n    end_time = 0\n\n    for start, end in movies:\n        if start >= end_time:\n            selected_movies += 1\n            end_time = end\n\n        if selected_movies == k:\n            break\n\n    return selected_movies",
  "sample1_input": "5 2\n1 5\n8 10\n3 6\n2 5\n6 9",
  "sample1_output": "4",
  "sample2_input": "4 3\n1 4\n2 3\n4 5\n6 7",
  "sample2_output": "3",
  "sample3_input": "6 1\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7",
  "sample3_output": "1",
  "sample4_input": "7 7\n1 2\n3 4\n5 6\n7 8\n9 10\n11 12\n13 14",
  "sample4_output": "7",
  "sample5_input": "5 5\n1 2\n2 3\n3 4\n4 5\n5 6",
  "sample5_output": "5"
    },
    {
        "title": "Maximum Subarray Sum II",
        "query": "Given an array of n integers, your task is to find the maximum sum of values in a contiguous subarray with length between a and b.\nInput\nThe first input line has three integers n, a and b: the size of the array and the minimum and maximum subarray length.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nOutput\nPrint one integer: the maximum subarray sum.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a \\le b \\le n\n-10^9 \\le x_i \\le 10^9\n\nExample\nInput:\n8 1 2\n-1 3 -2 5 3 -5 2 2\n\nOutput:\n8\n",
        "solution": "def main(n, a, b, arr):\n    prefix_sum = [0] * (n + 1)\n    max_sum = float('-inf')\n    min_prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n\n    for i in range(1, n + 1):\n        min_prefix_sum[i] = min(min_prefix_sum[i - 1], prefix_sum[i])\n\n    for len_subarray in range(a, b + 1):\n        for i in range(len_subarray, n + 1):\n            max_sum = max(max_sum, prefix_sum[i] - min_prefix_sum[i - len_subarray])\n\n    return max_sum",
  "sample1_input": "8 1 2\n-1 3 -2 5 3 -5 2 2",
  "sample1_output": "8",
  "sample2_input": "5 2 4\n2 -1 3 4 1",
  "sample2_output": "9",
  "sample3_input": "6 1 3\n1 2 3 -2 5 -1",
  "sample3_output": "11",
  "sample4_input": "5 3 5\n-2 3 -4 5 -1",
  "sample4_output": "3",
  "sample5_input": "7 2 3\n1 2 3 4 5 6 7",
  "sample5_output": "21"
    },
    {
        "title": "Dice Combinations",
        "query": "Your task is to count the number of ways to construct sum n by throwing a dice one or more times. Each throw produces an outcome between 1 and  6.\nFor example, if n=3, there are 4 ways:\n\n1+1+1\n1+2\n2+1\n3\n\nInput\nThe only input line has an integer n.\nOutput\nPrint the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n\nOutput:\n4\n",
        "solution": "def main(n):\n    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, 7):\n            if i - j >= 0:\n                dp[i] += dp[i - j]\n                dp[i] %= MOD\n\n    return dp[n]",
  "sample1_input": "3",
  "sample1_output": "4",
  "sample2_input": "4",
  "sample2_output": "8",
  "sample3_input": "5",
  "sample3_output": "16",
  "sample4_input": "6",
  "sample4_output": "32",
  "sample5_input": "10",
  "sample5_output": "4928"
    },
    {
        "title": "Minimizing Coins",
        "query": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to produce a sum of money x using the available coins in such a way that the number of coins is minimal.\nFor example, if the coins are \\{1,5,7\\} and the desired sum is 11, an optimal solution is 5+5+1 which requires 3 coins.\nInput\nThe first input line has two integers n and x: the number of coins and the desired sum of money.\nThe second line has n distinct integers c_1,c_2,\\dots,c_n: the value of each coin.\nOutput\nPrint one integer: the minimum number of coins. If it is not possible to produce the desired sum, print -1.\nConstraints\n\n1 \\le n \\le 100\n1 \\le x \\le 10^6\n1 \\le c_i \\le 10^6\n\nExample\nInput:\n3 11\n1 5 7\n\nOutput:\n3\n",
        "solution": "def main(n, x, coins):\n    INF = float('inf')\n    dp = [INF] * (x + 1)\n    dp[0] = 0\n\n    for i in range(1, x + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    if dp[x] == INF:\n        return -1\n    else:\n        return dp[x]",
  "sample1_input": "3 11\n1 5 7",
  "sample1_output": "3",
  "sample2_input": "5 9\n2 3 5 6 8",
  "sample2_output": "2",
  "sample3_input": "4 13\n2 4 6 8",
  "sample3_output": "-1",
  "sample4_input": "5 7\n1 2 3 4 5",
  "sample4_output": "2",
  "sample5_input": "4 10\n1 3 5 7",
  "sample5_output": "2"
    },
    {
        "title": "Coin Combinations I",
        "query": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ways you can produce a money sum x using the available coins.\nFor example, if the coins are \\{2,3,5\\} and the desired sum is 9, there are 8 ways:\n\n2+2+5\n2+5+2\n5+2+2\n3+3+3\n2+2+2+3\n2+2+3+2\n2+3+2+2\n3+2+2+2\n\nInput\nThe first input line has two integers n and x: the number of coins and the desired sum of money.\nThe second line has n distinct integers c_1,c_2,\\dots,c_n: the value of each coin.\nOutput\nPrint one integer: the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 100\n1 \\le x \\le 10^6\n1 \\le c_i \\le 10^6\n\nExample\nInput:\n3 9\n2 3 5\n\nOutput:\n8\n",
         "solution": "def main(n, x, coins):\n    MOD = 10**9 + 7\n    dp = [0] * (x + 1)\n    dp[0] = 1\n\n    for i in range(1, x + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    return dp[x]",
  "sample1_input": "3 9\n2 3 5",
  "sample1_output": "8",
  "sample2_input": "5 9\n2 3 5 6 8",
  "sample2_output": "9",
  "sample3_input": "4 13\n2 4 6 8",
  "sample3_output": "0",
  "sample4_input": "5 7\n1 2 3 4 5",
  "sample4_output": "21",
  "sample5_input": "4 10\n1 3 5 7",
  "sample5_output": "15"
    },
    {
        "title": "Coin Combinations II",
        "query": "Consider a money system consisting of n coins. Each coin has a positive integer value. Your task is to calculate the number of distinct ordered ways you can produce a money sum x using the available coins.\nFor example, if the coins are \\{2,3,5\\} and the desired sum is 9, there are 3 ways:\n\n2+2+5\n3+3+3\n2+2+2+3\n\nInput\nThe first input line has two integers n and x: the number of coins and the desired sum of money.\nThe second line has n distinct integers c_1,c_2,\\dots,c_n: the value of each coin.\nOutput\nPrint one integer: the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 100\n1 \\le x \\le 10^6\n1 \\le c_i \\le 10^6\n\nExample\nInput:\n3 9\n2 3 5\n\nOutput:\n3\n",
        "solution": "def main(n, x, coins):\n    MOD = 10**9 + 7\n    dp = [0] * (x + 1)\n    dp[0] = 1\n\n    for i in range(1, x + 1):\n        for coin in coins:\n            if i - coin >= 0:\n                dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    return dp[x]",
  "sample1_input": "3 9\n2 3 5",
  "sample1_output": "3",
  "sample2_input": "5 9\n2 3 5 6 8",
  "sample2_output": "6",
  "sample3_input": "4 13\n2 4 6 8",
  "sample3_output": "0",
  "sample4_input": "5 7\n1 2 3 4 5",
  "sample4_output": "15",
  "sample5_input": "4 10\n1 3 5 7",
  "sample5_output": "8"
    },
    {
        "title": "Removing Digits",
        "query": "You are given an integer n. On each step, you may subtract one of the digits from the number.\nHow many steps are required to make the number equal to 0?\nInput\nThe only input line has an integer n.\nOutput\nPrint one integer: the minimum number of steps.\nConstraints\n\n1 \\le n \\le 10^6\n\nExample\nInput:\n27\n\nOutput:\n5\n\nExplanation: An optimal solution is 27 \\rightarrow 20 \\rightarrow 18 \\rightarrow 10 \\rightarrow 9 \\rightarrow 0.\n",
        "solution": "def main(n):\n    steps = 0\n    while n > 0:\n        max_digit = max(str(n))\n        n -= int(max_digit)\n        steps += 1\n    return steps",
  "sample1_input": "27",
  "sample1_output": "5",
  "sample2_input": "123",
  "sample2_output": "6",
  "sample3_input": "9",
  "sample3_output": "1",
  "sample4_input": "54321",
  "sample4_output": "5",
  "sample5_input": "1000000",
  "sample5_output": "2"
    },
    {
        "title": "Grid Paths",
        "query": "Consider an n \\times n grid whose squares may have traps. It is not allowed to move to a square with a trap.\nYour task is to calculate the number of paths from the upper-left square to the lower-right square. You can only move right or down.\nInput\nThe first input line has an integer n: the size of the grid.\nAfter this, there are n lines that describe the grid. Each line has n characters: . denotes an empty cell, and * denotes a trap.\nOutput\nPrint the number of paths modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 1000\n\nExample\nInput:\n4\n....\n.*..\n...*\n*...\n\nOutput:\n3\n",
        "solution": "def main(n, grid):\n    MOD = 1000000007\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '*':\n                continue\n            if i + 1 < n:\n                dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD\n            if j + 1 < n:\n                dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % MOD\n\n    return dp[n - 1][n - 1]",
  "sample1_input": "4\n....\n.*..\n...*\n*...",
  "sample1_output": "3",
  "sample2_input": "3\n.*.\n..*\n.*.",
  "sample2_output": "0",
  "sample3_input": "2\n.*\n*.\n",
  "sample3_output": "0",
  "sample4_input": "5\n.....\n.*...\n....*\n*....\n.....",
  "sample4_output": "10",
  "sample5_input": "1\n.",
  "sample5_output": "1"
    },
    {
        "title": "Book Shop",
        "query": "You are in a book shop which sells n different books. You know the price and number of pages of each book.\nYou have decided that the total price of your purchases will be at most x. What is the maximum number of pages you can buy? You can buy each book at most once.\nInput\nThe first input line contains two integers n and x: the number of books and the maximum total price.\nThe next line contains n integers h_1,h_2,\\ldots,h_n: the price of each book.\nThe last line contains n integers s_1,s_2,\\ldots,s_n: the number of pages of each book.\nOutput\nPrint one integer: the maximum number of pages.\nConstraints\n\n1 \\le n \\le 1000\n1 \\le x \\le 10^5\n1 \\le h_i, s_i \\le 1000\n\nExample\nInput:\n4 10\n4 8 5 3\n5 12 8 1\n\nOutput:\n13\n\nExplanation: You can buy books 1 and 3. Their price is 4+5=9 and the number of pages is 5+8=13.\n",
        "solution": "def main(n, x, prices, pages):\n    dp = [[0] * (x + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(x + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= prices[i - 1]:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - prices[i - 1]] + pages[i - 1])\n\n    return dp[n][x]",
  "sample1_input": "4 10\n4 8 5 3\n5 12 8 1",
  "sample1_output": "13",
  "sample2_input": "3 7\n2 4 3\n3 5 2",
  "sample2_output": "5",
  "sample3_input": "2 5\n1 2\n2 3",
  "sample3_output": "3",
  "sample4_input": "5 15\n3 7 2 6 5\n8 12 2 9 5",
  "sample4_output": "29",
  "sample5_input": "1 1000\n1000\n1000",
  "sample5_output": "1000"
    },
    {
        "title": "Array Description",
        "query": "You know that an array has n integers between 1 and  m, and the absolute difference between two adjacent values is at most 1.\nGiven a description of the array where some values may be unknown, your task is to count the number of arrays that match the description.\nInput\nThe first input line has two integers n and m: the array size and the upper bound for each value.\nThe next line has n integers x_1,x_2,\\dots,x_n: the contents of the array. Value 0 denotes an unknown value.\nOutput\nPrint one integer: the number of arrays modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 100\n0 \\le x_i \\le m\n\nExample\nInput:\n3 5\n2 0 2\n\nOutput:\n3\n\nExplanation: The arrays [2,1,2], [2,2,2] and [2,3,2] match the description.\n",
         "solution": "def main(n, m, arr):\n    MOD = 10**9 + 7\n\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for x in range(1, m + 1):\n        if arr[0] == 0 or arr[0] == x:\n            dp[1][x] = 1\n\n    for i in range(2, n + 1):\n        for x in range(1, m + 1):\n            if arr[i - 1] == 0 or arr[i - 1] == x:\n                dp[i][x] = (dp[i - 1][x - 1] + dp[i - 1][x] + dp[i - 1][x + 1]) % MOD\n\n    return sum(dp[n]) % MOD",
  "sample1_input": "3 5\n2 0 2\n",
  "sample1_output": "3\n",
  "sample2_input": "4 3\n1 0 0 2\n",
  "sample2_output": "0\n",
  "sample3_input": "2 4\n0 0\n",
  "sample3_output": "10\n",
  "sample4_input": "5 6\n0 0 0 0 0\n",
  "sample4_output": "32\n",
  "sample5_input": "1 100\n0\n",
  "sample5_output": "100\n"
    },
    {
        "title": "Counting Towers",
        "query": "Your task is to build a tower whose width is 2 and height is n. You have an unlimited supply of blocks whose width and height are integers.\nFor example, here are some possible solutions for n=6:\n\nGiven n, how many different towers can you build? Mirrored and rotated towers are counted separately if they look different.\nInput\nThe first input line contains an integer t: the number of tests.\nAfter this, there are t lines, and each line contains an integer n: the height of the tower.\nOutput\nFor each test, print the number of towers modulo 10^9+7.\nConstraints\n\n1 \\le t \\le 100\n1 \\le n \\le 10^6\n\nExample\nInput:\n3\n2\n6\n1337\n\nOutput:\n8\n2864\n640403945\n",
         "solution": "def main(t, heights):\n    MOD = 10**9 + 7\n    results = []\n\n    for n in heights:\n        # Initialize DP array\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        dp[1] = 1\n\n        # Calculate the number of towers for each height\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n        # Calculate the total number of towers\n        total_towers = (dp[n] + dp[n - 1]) % MOD\n        results.append(total_towers)\n\n    return results",
  "sample1_input": "3\n2\n6\n1337\n",
  "sample1_output": "8\n2864\n640403945\n",
  "sample2_input": "2\n1\n10\n",
  "sample2_output": "2\n4897\n",
  "sample3_input": "1\n20\n",
  "sample3_output": "33574528\n",
  "sample4_input": "4\n5\n7\n9\n11\n",
  "sample4_output": "16\n48\n144\n424\n",
  "sample5_input": "5\n15\n18\n21\n24\n27\n",
  "sample5_output": "1704\n17952\n190569\n2029408\n21656305\n"

    },
    {
        "title": "Edit Distance",
        "query": "The edit distance between two strings is the minimum number of operations required to transform one string into the other.\nThe allowed operations are:\n\nAdd one character to the string.\nRemove one character from the string.\nReplace one character in the string.\n\nFor example, the edit distance between LOVE and MOVIE is 2, because you can first replace L with M, and then add I.\nYour task is to calculate the edit distance between two strings.\nInput\nThe first input line has a string that contains n characters between A\u2013Z.\nThe second input line has a string that contains m characters between A\u2013Z.\nOutput\nPrint one integer: the edit distance between the strings.\nConstraints\n\n1 \\le n,m \\le 5000\n\nExample\nInput:\nLOVE\nMOVIE\n\nOutput:\n2\n",
        "solution": "def main(str1, str2):\n    n = len(str1)\n    m = len(str2)\n\n    # Create a 2D DP array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Initialize the DP array\n    for i in range(n + 1):\n        dp[i][0] = i\n    for j in range(m + 1):\n        dp[0][j] = j\n\n    # Fill the DP array using dynamic programming\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n    return dp[n][m]",
  "sample1_input": "LOVE\nMOVIE\n",
  "sample1_output": "2\n",
  "sample2_input": "ABCDEF\nXYZ\n",
  "sample2_output": "6\n",
  "sample3_input": "HELLO\nHI\n",
  "sample3_output": "4\n",
  "sample4_input": "ALGORITHM\nALTRUISM\n",
  "sample4_output": "7\n",
  "sample5_input": "OPENAI\nGPT\n",
  "sample5_output": "5\n"
    },
    {
        "title": "Rectangle Cutting",
        "query": "Given an a \\times b rectangle, your task is to cut it into squares. On each move you can select a rectangle and cut it into two rectangles in such a way that all side lengths remain integers. What is the minimum possible number of moves?\nInput\nThe only input line has two integers a and b.\nOutput\nPrint one integer: the minimum number of moves.\nConstraints\n\n1 \\le a,b \\le 500\n\nExample\nInput:\n3 5\n\nOutput:\n3\n",
        "solution": "def main(a, b):\n    # Ensure a is the larger dimension\n    if a < b:\n        a, b = b, a\n\n    # Initialize the number of moves\n    moves = 0\n\n    while b > 0:\n        # Increment the number of moves by the number of squares that can be cut from the current rectangle\n        moves += a // b\n\n        # Update the dimensions of the remaining rectangle\n        a, b = b, a % b\n\n    return moves",
  "sample1_input": "3 5\n",
  "sample1_output": "3\n",
  "sample2_input": "5 5\n",
  "sample2_output": "1\n",
  "sample3_input": "7 4\n",
  "sample3_output": "4\n",
  "sample4_input": "10 2\n",
  "sample4_output": "5\n",
  "sample5_input": "15 9\n",
  "sample5_output": "5\n"
    },
    {
        "title": "Money Sums",
        "query": "You have n coins with certain values. Your task is to find all money sums you can create using these coins.\nInput\nThe first input line has an integer n: the number of coins.\nThe next line has n integers x_1,x_2,\\dots,x_n: the values of the coins.\nOutput\nFirst print an integer k: the number of distinct money sums. After this, print all possible sums in increasing order.\nConstraints\n\n1 \\le n \\le 100\n1 \\le x_i \\le 1000\n\nExample\nInput:\n4\n4 2 5 2\n\nOutput:\n9\n2 4 5 6 7 8 9 11 13\n",
         "solution": "def main(n, coins):\n    # Initialize a set to store distinct money sums\n    money_sums = set()\n\n    # Add 0 as the initial sum\n    money_sums.add(0)\n\n    # Iterate through each coin's value\n    for coin in coins:\n        # Create a list to store new sums\n        new_sums = []\n\n        # Iterate through existing sums\n        for sum_value in money_sums:\n            # Calculate the new sum by adding the coin's value to the existing sum\n            new_sum = sum_value + coin\n\n            # Add the new sum to the list of new sums\n            new_sums.append(new_sum)\n\n        # Add all new sums to the set of money sums\n        money_sums.update(new_sums)\n\n    # Sort the money sums in increasing order\n    sorted_sums = sorted(money_sums)\n\n    return len(sorted_sums), sorted_sums",
  "sample1_input": "4\n4 2 5 2\n",
  "sample1_output": "9\n2 4 5 6 7 8 9 11 13\n",
  "sample2_input": "5\n1 2 3 4 5\n",
  "sample2_output": "15\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n",
  "sample3_input": "3\n7 11 13\n",
  "sample3_output": "63\n7 11 13 18 20 24 28 31 34 35 38 41 42 45 48 51 52 55 58 59 62 65 66 69 72 73 76 79 80 83 86 87 90 93 94 97 100 101 104 107 108 111 114 115 118 121 122 125 128 129 132 135 138 141 142 145 148 149 152 155 158 161 164 165 168 171 174 177 178 181\n",
  "sample4_input": "2\n10 15\n",
  "sample4_output": "16\n10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90\n",
  "sample5_input": "1\n1\n",
  "sample5_output": "1\n0 1\n"
    },
    {
        "title": "Removal Game",
        "query": "There is a list of n numbers and two players who move alternately. On each move, a player removes either the first or last number from the list, and their score increases by that number. Both players try to maximize their scores.\nWhat is the maximum possible score for the first player when both players play optimally?\nInput\nThe first input line contains an integer n: the size of the list.\nThe next line has n integers x_1,x_2,\\ldots,x_n: the contents of the list.\nOutput\nPrint the maximum possible score for the first player.\nConstraints\n\n1 \\le n \\le 5000\n-10^9 \\le x_i \\le 10^9\n\nExample\nInput:\n4\n4 5 1 3\n\nOutput:\n8\n",
         "solution": "def main(n, nums):\n    # Initialize a 2D table to store the maximum possible score for the first player\n    dp = [[0] * n for _ in range(n)]\n\n    # Fill the table diagonally\n    for i in range(n):\n        dp[i][i] = nums[i]\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n\n    # The maximum possible score for the first player is at dp[0][n - 1]\n    return dp[0][n - 1]",
  "sample1_input": "4\n4 5 1 3\n",
  "sample1_output": "8\n",
  "sample2_input": "5\n7 2 8 1 5\n",
  "sample2_output": "13\n",
  "sample3_input": "3\n10 2 7\n",
  "sample3_output": "15\n",
  "sample4_input": "2\n-5 5\n",
  "sample4_output": "5\n",
  "sample5_input": "1\n1000\n",
  "sample5_output": "1000\n"
    },
    {
        "title": "Two Sets II",
        "query": "Your task is to count the number of ways numbers 1,2,\\ldots,n can be divided into two sets of equal sum.\nFor example, if n=7, there are four solutions:\n\n\\{1,3,4,6\\} and \\{2,5,7\\}\n\\{1,2,5,6\\} and \\{3,4,7\\}\n\\{1,2,4,7\\} and \\{3,5,6\\}\n\\{1,6,7\\} and \\{2,3,4,5\\}\n\nInput\nThe only input line contains an integer n.\nOutput\nPrint the answer modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 500\n\nExample\nInput:\n7\n\nOutput:\n4\n",
        "solution": "def main(n):\n    # Calculate the total sum of numbers from 1 to n\n    total_sum = (n * (n + 1)) // 2\n\n    # If the total sum is odd, there's no way to divide it into two sets with equal sums\n    if total_sum % 2 != 0:\n        return 0\n\n    # Initialize a 2D table to store the count of ways to achieve a given sum with the first i numbers\n    dp = [[0] * (total_sum // 2 + 1) for _ in range(n + 1)]\n\n    # There's one way to achieve a sum of 0, which is to have an empty set\n    for i in range(n + 1):\n        dp[i][0] = 1\n\n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, total_sum // 2 + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= i:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - i]) % (10**9 + 7)\n\n    # The answer is in dp[n][total_sum // 2]\n    return dp[n][total_sum // 2]",
  "sample1_input": "7\n",
  "sample1_output": "4\n",
  "sample2_input": "5\n",
  "sample2_output": "2\n",
  "sample3_input": "10\n",
  "sample3_output": "42\n",
  "sample4_input": "2\n",
  "sample4_output": "0\n",
  "sample5_input": "1\n",
  "sample5_output": "0\n"
    },
    {
        "title": "Increasing Subsequence",
        "query": "You are given an array containing n integers. Your task is to determine the longest increasing subsequence in the array, i.e., the longest subsequence where every element is larger than the previous one.\nA subsequence is a sequence that can be derived from the array by deleting some elements without changing the order of the remaining elements. \nInput\nThe first line contains an integer n: the size of the array.\nAfter this there are n integers x_1,x_2,\\ldots,x_n: the contents of the array.\nOutput\nPrint the length of the longest increasing subsequence.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n\nExample\nInput:\n8\n7 3 5 3 6 2 9 8\n\nOutput:\n4\n",
        "solution": "def main(n, arr):\n    # Initialize an array to store the length of the longest increasing subsequence ending at each index\n    dp = [1] * n\n\n    # Iterate through the array to calculate the longest increasing subsequence length\n    for i in range(n):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    # The answer is the maximum value in the dp array\n    return max(dp)",
  "sample1_input": "8\n7 3 5 3 6 2 9 8\n",
  "sample1_output": "4\n",
  "sample2_input": "5\n1 2 3 4 5\n",
  "sample2_output": "5\n",
  "sample3_input": "6\n5 4 3 2 1 6\n",
  "sample3_output": "1\n",
  "sample4_input": "7\n5 1 2 3 6 4 7\n",
  "sample4_output": "4\n",
  "sample5_input": "3\n1 1 1\n",
  "sample5_output": "1\n"
    },
    {
        "title": "Projects",
        "query": "There are n projects you can attend. For each project, you know its starting and ending days and the amount of money you would get as reward. You can only attend one project during a day.\nWhat is the maximum amount of money you can earn?\nInput\nThe first input line contains an integer n: the number of projects.\nAfter this, there are n lines. Each such line has three integers a_i, b_i, and p_i: the starting day, the ending day, and the reward.\nOutput\nPrint one integer: the maximum amount of money you can earn.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le a_i \\le b_i \\le 10^9\n1 \\le p_i \\le 10^9\n\nExample\nInput:\n4\n2 4 4\n3 6 6\n6 8 2\n5 7 3\n\nOutput:\n7\n",
        "solution": "def main(n, projects):\n    # Sort the projects by their ending day\n    projects.sort(key=lambda x: x[1])\n\n    # Initialize an array to store the maximum reward for each day\n    dp = [0] * (max(p[1] for p in projects) + 1)\n\n    for i in range(n):\n        start, end, reward = projects[i]\n        # Find the maximum reward for the current day\n        dp[end] = max(dp[end], dp[start] + reward)\n\n    # The maximum reward is the maximum value in the dp array\n    return max(dp)",
  "sample1_input": "4\n2 4 4\n3 6 6\n6 8 2\n5 7 3\n",
  "sample1_output": "7\n",
  "sample2_input": "5\n1 3 5\n2 4 6\n3 5 7\n4 6 8\n5 7 9\n",
  "sample2_output": "26\n",
  "sample3_input": "3\n1 2 1\n2 3 2\n3 4 3\n",
  "sample3_output": "6\n",
  "sample4_input": "3\n1 3 3\n2 4 4\n3 5 5\n",
  "sample4_output": "9\n",
  "sample5_input": "2\n1 4 10\n2 5 5\n",
  "sample5_output": "15\n"
    },
    {
        "title": "Elevator Rides",
        "query": "There are n people who want to get to the top of a building which has only one elevator. You know the weight of each person and the maximum allowed weight in the elevator. What is the minimum number of elevator rides?\nInput\nThe first input line has two integers n and x: the number of people and the maximum allowed weight in the elevator.\nThe second line has n integers w_1,w_2,\\dots,w_n: the weight of each person.\nOutput\nPrint one integer: the minimum number of rides.\nConstraints\n\n1 \\le n \\le 20\n1 \\le x \\le 10^9\n1 \\le w_i \\le x\n\nExample\nInput:\n4 10\n4 8 6 1\n\nOutput:\n2\n",
         "solution": "def main(n, x, weights):\n    weights.sort(reverse=True)\n    rides = 0\n    left, right = 0, n - 1\n\n    while left <= right:\n        if weights[left] + weights[right] <= x:\n            left += 1\n        right -= 1\n        rides += 1\n\n    return rides",
  "sample1_input": "4 10\n4 8 6 1\n",
  "sample1_output": "2\n",
  "sample2_input": "5 15\n10 7 8 4 5\n",
  "sample2_output": "3\n",
  "sample3_input": "3 7\n3 2 1\n",
  "sample3_output": "2\n",
  "sample4_input": "2 5\n3 4\n",
  "sample4_output": "1\n",
  "sample5_input": "1 1000\n1000\n",
  "sample5_output": "1\n"
    },
    {
        "title": "Counting Tilings",
        "query": "Your task is to count the number of ways you can fill an n \\times m grid using 1 \\times 2 and 2 \\times 1 tiles.\nInput\nThe only input line has two integers n and m.\nOutput\nPrint one integer: the number of ways modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10\n1 \\le m \\le 1000\n\nExample\nInput:\n4 7\n\nOutput:\n781\n",
        "solution": "def main(n, m):\n    MOD = 10**9 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 1\n\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if i + 1 <= n and j + 2 <= m:\n                dp[i + 1][j + 2] = (dp[i + 1][j + 2] + dp[i][j]) % MOD\n            if i + 2 <= n and j + 1 <= m:\n                dp[i + 2][j + 1] = (dp[i + 2][j + 1] + dp[i][j]) % MOD\n\n    return dp[n][m]",
  "sample1_input": "4 7\n",
  "sample1_output": "781\n",
  "sample2_input": "3 3\n",
  "sample2_output": "2\n",
  "sample3_input": "1 10\n",
  "sample3_output": "1\n",
  "sample4_input": "5 5\n",
  "sample4_output": "20\n",
  "sample5_input": "2 2\n",
  "sample5_output": "3\n"
    },
    {
        "title": "Counting Numbers",
        "query": "Your task is to count the number of integers between a and b where no two adjacent digits are the same.\nInput\nThe only input line has two integers a and b.\nOutput\nPrint one integer: the answer to the problem.\nConstraints\n\n0 \\le a \\le b \\le 10^{18}\n\nExample\nInput:\n123 321\n\nOutput:\n171\n",
        "solution": "def main(a, b):\n    def count_numbers_with_no_adjacent_digits(x):\n        digits = str(x)\n        n = len(digits)\n        dp = [[0] * 10 for _ in range(n)]\n\n        for i in range(10):\n            dp[0][i] = 1\n\n        for i in range(1, n):\n            for j in range(10):\n                for k in range(10):\n                    if j != k:\n                        dp[i][j] += dp[i - 1][k]\n\n        count = sum(dp[n - 1])\n        return count\n\n    count_a = count_numbers_with_no_adjacent_digits(a - 1)\n    count_b = count_numbers_with_no_adjacent_digits(b)\n    result = count_b - count_a\n    return result",
  "sample1_input": "123 321\n",
  "sample1_output": "171\n",
  "sample2_input": "0 9\n",
  "sample2_output": "10\n",
  "sample3_input": "101 105\n",
  "sample3_output": "4\n",
  "sample4_input": "1000 1010\n",
  "sample4_output": "10\n",
  "sample5_input": "9876543210 9876543210\n",
  "sample5_output": "1\n"
    },
    {
        "title": "Counting Rooms",
        "query": "You are given a map of a building, and your task is to count the number of its rooms. The size of the map is n \\times m squares, and each square is either floor or wall. You can walk left, right, up, and down through the floor squares.\nInput\nThe first input line has two integers n and m: the height and width of the map.\nThen there are n lines of m characters describing the map. Each character is either . (floor) or # (wall).\nOutput\nPrint one integer: the number of rooms.\nConstraints\n\n1 \\le n,m \\le 1000\n\nExample\nInput:\n5 8\n########\n#..#...#\n####.#.#\n#..#...#\n########\n\nOutput:\n3\n",
        "solution": "def main(n, m, grid):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x, y):\n        if not is_valid(x, y) or grid[x][y] == '#':\n            return\n        grid[x][y] = '#'\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            dfs(nx, ny)\n\n    rooms = 0\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                dfs(i, j)\n                rooms += 1\n\n    return rooms",
  "sample1_input": "5 8\n########\n#..#...#\n####.#.#\n#..#...#\n########\n",
  "sample1_output": "3\n",
  "sample2_input": "3 3\n###\n#.#\n###\n",
  "sample2_output": "1\n",
  "sample3_input": "3 3\n###\n###\n###\n",
  "sample3_output": "0\n",
  "sample4_input": "5 5\n#####\n#.#.#\n#.#.#\n#.#.#\n#####\n",
  "sample4_output": "1\n",
  "sample5_input": "6 6\n######\n#.#..#\n#.#..#\n#.#..#\n######\n######\n",
  "sample5_output": "2\n"
    },
    {
        "title": "Labyrinth",
        "query": "You are given a map of a labyrinth, and your task is to find a path from start to end. You can walk left, right, up and down.\nInput\nThe first input line has two integers n and m: the height and width of the map.\nThen there are n lines of m characters describing the labyrinth. Each character is . (floor), # (wall), A (start), or B (end). There is exactly one A and one B in the input.\nOutput\nFirst print \"YES\", if there is a path, and \"NO\" otherwise.\nIf there is a path, print the length of the shortest such path and its description as a string consisting of characters L (left), R (right), U (up), and D (down). You can print any valid solution.\nConstraints\n\n1 \\le n,m \\le 1000\n\nExample\nInput:\n5 8\n########\n#.A#...#\n#.##.#B#\n#......#\n########\n\nOutput:\nYES\n9\nLDDRRRRRU\n",
       "solution": "def main(n, m, labyrinth):\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def bfs(start_x, start_y, end_x, end_y):\n        queue = [(start_x, start_y, 0, '')]\n        visited = set()\n        directions = [(1, 0, 'D'), (-1, 0, 'U'), (0, 1, 'R'), (0, -1, 'L')]\n\n        while queue:\n            x, y, steps, path = queue.pop(0)\n\n            if x == end_x and y == end_y:\n                return 'YES', steps, path\n\n            for dx, dy, move in directions:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and labyrinth[nx][ny] == '.' and (nx, ny) not in visited:\n                    queue.append((nx, ny, steps + 1, path + move))\n                    visited.add((nx, ny))\n\n        return 'NO'\n\n    for i in range(n):\n        for j in range(m):\n            if labyrinth[i][j] == 'A':\n                start_x, start_y = i, j\n            elif labyrinth[i][j] == 'B':\n                end_x, end_y = i, j\n\n    result = bfs(start_x, start_y, end_x, end_y)\n    return result",
  "sample1_input": "5 8\n########\n#.A#...#\n#.##.#B#\n#......#\n########\n",
  "sample1_output": "YES\n9\nLDDRRRRRU\n",
  "sample2_input": "3 3\n###\n#.#\n###\n",
  "sample2_output": "YES\n2\nRR\n",
  "sample3_input": "3 3\n###\n###\n###\n",
  "sample3_output": "NO\n",
  "sample4_input": "5 5\n#####\n#.#.#\n#.#.#\n#.#.#\n#####\n",
  "sample4_output": "NO\n",
  "sample5_input": "6 6\n######\n#.#..#\n#.#..#\n#.#..#\n######\n######\n",
  "sample5_output": "YES\n10\nRRRRRRRRUU\n"
    },
    {
        "title": "Building Roads",
        "query": "Byteland has n cities, and m roads between them. The goal is to construct new roads so that there is a route between any two cities.\nYour task is to find out the minimum number of roads required, and also determine which roads should be built.\nInput\nThe first input line has two integers n and m: the number of cities and roads. The cities are numbered 1,2,\\dots,n.\nAfter that, there are m lines describing the roads. Each line has two integers a and b: there is a road between those cities.\nA road always connects two different cities, and there is at most one road between any two cities.\nOutput\nFirst print an integer k: the number of required roads.\nThen, print k lines that describe the new roads. You can print any valid solution.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n4 2\n1 2\n3 4\n\nOutput:\n1\n2 3\n",
         "solution": "def main(n, m, roads):\n    cities = [set() for _ in range(n)]\n    new_roads = []\n\n    for a, b in roads:\n        cities[a - 1].add(b)\n        cities[b - 1].add(a)\n\n    def dfs(city):\n        if not visited[city]:\n            visited[city] = True\n            for neighbor in cities[city]:\n                if not visited[neighbor]:\n                    new_roads.append((city + 1, neighbor + 1))\n                    dfs(neighbor)\n\n    visited = [False] * n\n    connected_components = 0\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    required_roads = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j not in cities[i]:\n                required_roads.append((i + 1, j + 1))\n\n    return connected_components - 1, required_roads",
  "sample1_input": "4 2\n1 2\n3 4\n",
  "sample1_output": "1\n1 3\n",
  "sample2_input": "5 3\n1 2\n2 3\n4 5\n",
  "sample2_output": "1\n1 4\n",
  "sample3_input": "3 0\n",
  "sample3_output": "2\n1 2\n1 3\n",
  "sample4_input": "5 6\n1 2\n2 3\n3 4\n4 5\n5 1\n1 3\n",
  "sample4_output": "1\n1 5\n",
  "sample5_input": "6 9\n1 2\n2 3\n3 4\n4 5\n5 6\n6 1\n1 3\n2 4\n4 6\n",
  "sample5_output": "0\n"
    },
    {
        "title": "Message Route",
        "query": "Syrj\u00e4l\u00e4's network has n computers and m connections. Your task is to find out if Uolevi can send a message to Maija, and if it is possible, what is the minimum number of computers on such a route.\nInput\nThe first input line has two integers n and m: the number of computers and connections. The computers are numbered 1,2,\\dots,n. Uolevi's computer is 1 and Maija's computer is n.\nThen, there are m lines describing the connections. Each line has two integers a and b: there is a connection between those computers.\nEvery connection is between two different computers, and there is at most one connection between any two computers.\nOutput\nIf it is possible to send a message, first print k: the minimum number of computers on a valid route. After this, print an example of such a route. You can print any valid solution.\nIf there are no routes, print \"IMPOSSIBLE\".\nConstraints\n\n2 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 5\n1 2\n1 3\n1 4\n2 3\n5 4\n\nOutput:\n3\n1 4 5\n",
        "solution": "def main(n, m, connections):\n    graph = [[] for _ in range(n)]\n    for a, b in connections:\n        graph[a - 1].append(b)\n        graph[b - 1].append(a)\n\n    visited = [False] * n\n    distance = [0] * n\n    parent = [-1] * n\n\n    def bfs():\n        queue = [0]\n        visited[0] = True\n\n        while queue:\n            node = queue.pop(0)\n\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    distance[neighbor] = distance[node] + 1\n                    parent[neighbor] = node\n                    queue.append(neighbor)\n\n    bfs()\n\n    if not visited[n - 1]:\n        return \"IMPOSSIBLE\"\n\n    path = [n]\n    current = n - 1\n\n    while current != 0:\n        current = parent[current]\n        path.append(current + 1)\n\n    return len(path), path[::-1]",
  "sample1_input": "5 5\n1 2\n1 3\n1 4\n2 3\n5 4\n",
  "sample1_output": "3\n1 4 5\n",
  "sample2_input": "6 6\n1 2\n2 3\n3 4\n4 5\n5 6\n1 6\n",
  "sample2_output": "2\n1 6\n",
  "sample3_input": "4 3\n1 2\n2 3\n3 4\n",
  "sample3_output": "4\n1 2 3 4\n",
  "sample4_input": "4 4\n1 2\n2 3\n3 4\n4 1\n",
  "sample4_output": "3\n1 2 3\n",
  "sample5_input": "3 2\n1 2\n2 3\n",
  "sample5_output": "IMPOSSIBLE\n"
    },
    {
        "title": "Building Teams",
        "query": "There are n pupils in Uolevi's class, and m friendships between them. Your task is to divide the pupils into two teams in such a way that no two pupils in a team are friends. You can freely choose the sizes of the teams.\nInput\nThe first input line has two integers n and m: the number of pupils and friendships. The pupils are numbered 1,2,\\dots,n.\nThen, there are m lines describing the friendships. Each line has two integers a and b: pupils a and b are friends.\nEvery friendship is between two different pupils. You can assume that there is at most one friendship between any two pupils.\nOutput\nPrint an example of how to build the teams. For each pupil, print \"1\" or \"2\" depending on to which team the pupil will be assigned. You can print any valid team.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 3\n1 2\n1 3\n4 5\n\nOutput:\n1 2 2 1 2\n",
         "solution": "def main(n, m, friendships):\n    graph = [[] for _ in range(n)]\n    teams = [0] * n\n\n    for a, b in friendships:\n        graph[a - 1].append(b)\n        graph[b - 1].append(a)\n\n    def dfs(node, team):\n        teams[node] = team\n        for neighbor in graph[node]:\n            if teams[neighbor] == team:\n                return False\n            if teams[neighbor] == 0 and not dfs(neighbor, 3 - team):\n                return False\n        return True\n\n    for i in range(n):\n        if teams[i] == 0 and not dfs(i, 1):\n            return \"IMPOSSIBLE\"\n\n    return teams",
  "sample1_input": "5 3\n1 2\n1 3\n4 5\n",
  "sample1_output": "1 2 2 1 2\n",
  "sample2_input": "6 4\n1 2\n1 3\n4 5\n4 6\n",
  "sample2_output": "1 2 2 1 1 2\n",
  "sample3_input": "4 2\n1 2\n3 4\n",
  "sample3_output": "1 2 1 2\n",
  "sample4_input": "3 3\n1 2\n2 3\n3 1\n",
  "sample4_output": "IMPOSSIBLE\n",
  "sample5_input": "5 5\n1 2\n2 3\n3 4\n4 5\n5 1\n",
  "sample5_output": "IMPOSSIBLE\n"
    },
    {
        "title": "Round Trip",
        "query": "Byteland has n cities and m roads between them. Your task is to design a round trip that begins in a city, goes through two or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.\nInput\nThe first input line has two integers n and m: the number of cities and roads. The cities are numbered 1,2,\\dots,n.\nThen, there are m lines describing the roads. Each line has two integers a and b: there is a road between those cities.\nEvery road is between two different cities, and there is at most one road between any two cities.\nOutput\nFirst print an integer k: the number of cities on the route. Then print k cities in the order they will be visited. You can print any valid solution.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 6\n1 3\n1 2\n5 3\n1 5\n2 4\n4 5\n\nOutput:\n4\n3 5 1 3\n",
         "solution": "def main(n, m, roads):\n    graph = [[] for _ in range(n)]\n\n    for a, b in roads:\n        graph[a - 1].append(b)\n        graph[b - 1].append(a)\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    path.append(neighbor)\n                    return True\n                elif neighbor != parent:\n                    return True\n        return False\n\n    visited = [False] * n\n    path = []\n\n    for i in range(n):\n        if not visited[i] and dfs(i, -1):\n            path.append(i + 1)\n            return len(path), path\n\n    return \"IMPOSSIBLE\"",
  "sample1_input": "5 6\n1 3\n1 2\n5 3\n1 5\n2 4\n4 5\n",
  "sample1_output": "4\n3 1 2 4\n",
  "sample2_input": "4 4\n1 2\n2 3\n3 4\n4 1\n",
  "sample2_output": "4\n1 2 3 4\n",
  "sample3_input": "3 2\n1 2\n2 3\n",
  "sample3_output": "IMPOSSIBLE\n",
  "sample4_input": "5 5\n1 2\n2 3\n3 4\n4 5\n5 1\n",
  "sample4_output": "5\n1 2 3 4 5\n",
  "sample5_input": "4 3\n1 2\n2 3\n3 4\n",
  "sample5_output": "IMPOSSIBLE\n"
    },
    {
        "title": "Monsters",
        "query": "You and some monsters are in a labyrinth. When taking a step to some direction in the labyrinth, each monster may simultaneously take one as well. Your goal is to reach one of the boundary squares without ever sharing a square with a monster.\nYour task is to find out if your goal is possible, and if it is, print a path that you can follow. Your plan has to work in any situation; even if the monsters know your path beforehand.\nInput\nThe first input line has two integers n and m: the height and width of the map.\nAfter this there are n lines of m characters describing the map. Each character is . (floor), # (wall), A (start), or M (monster). There is exactly one A in the input.\nOutput\nFirst print \"YES\" if your goal is possible, and \"NO\" otherwise.\nIf your goal is possible, also print an example of a valid path (the length of the path and its description using characters D, U, L, and R). You can print any path, as long as its length is at most n \\cdot m steps.\nConstraints\n\n1 \\le n,m \\le 1000\n\nExample\nInput:\n5 8\n########\n#M..A..#\n#.#.M#.#\n#M#..#..\n#.######\n\nOutput:\nYES\n5\nRRDDR\n",
        "solution": "def main(n, m, labyrinth):\n    def dfs(x, y, path):\n        if not (0 <= x < n) or not (0 <= y < m) or labyrinth[x][y] == '#' or visited[x][y]:\n            return False\n        if labyrinth[x][y] == 'A':\n            return True\n\n        visited[x][y] = True\n        if dfs(x + 1, y, path + 'D') or dfs(x - 1, y, path + 'U') or dfs(x, y + 1, path + 'R') or dfs(x, y - 1, path + 'L'):\n            return True\n        visited[x][y] = False\n        return False\n\n    n, m = map(int, input().split())\n    labyrinth = [list(input()) for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if labyrinth[i][j] == 'A':\n                start_x, start_y = i, j\n                break\n\n    if dfs(start_x, start_y, ''):\n        print('YES')\n        print(len(path))\n        print(path)\n    else:\n        print('NO')\n",
  "sample1_input": "5 8\n########\n#M..A..#\n#.#.M#.#\n#M#..#..\n#.######\n",
  "sample1_output": "YES\n5\nRRDDR\n",
  "sample2_input": "3 3\n###\nAMA\n###\n",
  "sample2_output": "YES\n4\nRDDR\n",
  "sample3_input": "4 5\n#####\nAM#AA\n#M.M#\n#####\n",
  "sample3_output": "NO\n",
  "sample4_input": "2 2\nAM\nMA\n",
  "sample4_output": "YES\n2\nRD\n",
  "sample5_input": "3 3\n###\nA.M\nM##\n",
  "sample5_output": "YES\n2\nRD\n"
    },
    {
        "title": "Shortest Routes I",
        "query": "There are n cities and m flight connections between them. Your task is to determine the length of the shortest route from Syrj\u00e4l\u00e4 to every city.\nInput\nThe first input line has two integers n and m: the number of cities and flight connections. The cities are numbered 1,2,\\dots,n, and city 1 is Syrj\u00e4l\u00e4.\nAfter that, there are m lines describing the flight connections. Each line has three integers a, b and c: a flight begins at city a, ends at city b, and its length is c. Each flight is a one-way flight.\nYou can assume that it is possible to travel from Syrj\u00e4l\u00e4 to all other cities.\nOutput\nPrint n integers: the shortest route lengths from Syrj\u00e4l\u00e4 to cities 1,2,\\dots,n.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n\nExample\nInput:\n3 4\n1 2 6\n1 3 2\n3 2 3\n1 3 4\n\nOutput:\n0 5 2\n",
        "solution": "import heapq\n\ndef main(n, m, connections):\n    INF = 10 ** 18\n    graph = [[] for _ in range(n)]\n    distance = [INF] * n\n    distance[0] = 0\n\n    for a, b, c in connections:\n        graph[a - 1].append((b - 1, c))\n\n    pq = [(0, 0)]\n    while pq:\n        dist, node = heapq.heappop(pq)\n        if dist > distance[node]:\n            continue\n        for neighbor, weight in graph[node]:\n            if distance[node] + weight < distance[neighbor]:\n                distance[neighbor] = distance[node] + weight\n                heapq.heappush(pq, (distance[neighbor], neighbor))\n\n    return distance\n\nn, m = map(int, input().split())\nconnections = [list(map(int, input().split())) for _ in range(m)]\nresult = main(n, m, connections)\nprint(' '.join(map(str, result)))",
  "sample1_input": "3 4\n1 2 6\n1 3 2\n3 2 3\n1 3 4\n",
  "sample1_output": "0 5 2\n",
  "sample2_input": "4 4\n1 2 1\n2 3 2\n3 4 1\n1 4 100\n",
  "sample2_output": "0 1 3 100\n",
  "sample3_input": "5 6\n1 2 5\n1 3 3\n2 4 1\n3 4 2\n4 5 1\n2 5 10\n",
  "sample3_output": "0 5 3 5 15\n",
  "sample4_input": "5 6\n1 2 2\n2 3 3\n3 4 4\n4 5 5\n1 5 1\n1 3 1\n",
  "sample4_output": "0 2 3 7 12\n",
  "sample5_input": "4 4\n1 2 1\n2 3 1\n3 4 1\n4 1 1\n",
  "sample5_output": "0 1 2 3\n"
    },
    {
        "title": "Shortest Routes II",
        "query": "There are n cities and m roads between them. Your task is to process q queries where you have to determine the length of the shortest route between two given cities.\nInput\nThe first input line has three integers n, m and q: the number of cities, roads, and queries.\nThen, there are m lines describing the roads. Each line has three integers a, b and c: there is a road between cities a and b whose length is c. All roads are two-way roads.\nFinally, there are q lines describing the queries. Each line has two integers a and b: determine the length of the shortest route between cities a and b.\nOutput\nPrint the length of the shortest route for each query. If there is no route, print -1 instead.\nConstraints\n\n1 \\le n \\le 500\n1 \\le m \\le n^2\n1 \\le q \\le 10^5\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n\nExample\nInput:\n4 3 5\n1 2 5\n1 3 9\n2 3 3\n1 2\n2 1\n1 3\n1 4\n3 2\n\nOutput:\n5\n5\n8\n-1\n3\n",
        "solution": "import heapq\n\n\ndef main(n, m, q, roads, queries):\n    INF = 10 ** 18\n    graph = [[] for _ in range(n)]\n    distance = [[INF] * n for _ in range(n)]\n\n    for a, b, c in roads:\n        graph[a - 1].append((b - 1, c))\n        graph[b - 1].append((a - 1, c))\n\n    for i in range(n):\n        distance[i][i] = 0\n        pq = [(0, i)]\n        while pq:\n            dist, node = heapq.heappop(pq)\n            if dist > distance[i][node]:\n                continue\n            for neighbor, weight in graph[node]:\n                if distance[i][node] + weight < distance[i][neighbor]:\n                    distance[i][neighbor] = distance[i][node] + weight\n                    heapq.heappush(pq, (distance[i][neighbor], neighbor))\n\n    result = []\n    for a, b in queries:\n        if distance[a - 1][b - 1] == INF:\n            result.append(-1)\n        else:\n            result.append(distance[a - 1][b - 1])\n\n    return result\n\n\nn, m, q = map(int, input().split())\nroads = [list(map(int, input().split())) for _ in range(m)]\nqueries = [list(map(int, input().split())) for _ in range(q)]\nresult = main(n, m, q, roads, queries)\nfor res in result:\n    print(res)",
  "sample1_input": "4 3 5\n1 2 5\n1 3 9\n2 3 3\n1 2\n2 1\n1 3\n1 4\n3 2\n",
  "sample1_output": "5\n5\n8\n-1\n3\n",
  "sample2_input": "5 5 2\n1 2 3\n1 3 4\n2 4 1\n3 5 1\n4 5 1\n1 4\n2 5\n",
  "sample2_output": "4\n-1\n",
  "sample3_input": "3 3 2\n1 2 10\n2 3 10\n1 3 10\n1 3\n2 1\n",
  "sample3_output": "10\n-1\n",
  "sample4_input": "2 1 1\n1 2 5\n1 2\n",
  "sample4_output": "5\n",
  "sample5_input": "6 9 3\n1 2 1\n1 3 5\n2 4 3\n3 5 2\n4 6 1\n5 6 4\n2 3 1\n2 5 6\n3 6 2\n1 4\n1 6\n4 5\n",
  "sample5_output": "8\n6\n3\n"
    },
    {
        "title": "High Score",
        "query": "You play a game consisting of n rooms and m tunnels. Your initial score is 0, and each tunnel increases your score by x where x may be both positive or negative. You may go through a tunnel several times.\nYour task is to walk from room 1 to room n. What is the maximum score you can get?\nInput\nThe first input line has two integers n and m: the number of rooms and tunnels. The rooms are numbered 1,2,\\dots,n.\nThen, there are m lines describing the tunnels. Each line has three integers a, b and x: the tunnel starts at room a, ends at room b, and it increases your score by x. All tunnels are one-way tunnels.\nYou can assume that it is possible to get from room 1 to room n.\nOutput\nPrint one integer: the maximum score you can get. However, if you can get an arbitrarily large score, print -1.\nConstraints\n\n1 \\le n \\le 2500\n1 \\le m \\le 5000\n1 \\le a,b \\le n\n-10^9 \\le x \\le 10^9\n\nExample\nInput:\n4 5\n1 2 3\n2 4 -1\n1 3 -2\n3 4 7\n1 4 4\n\nOutput:\n5\n",
        "solution": "def main(n, m, tunnels):\n    INF = float('inf')\n    dp = [0] + [-INF] * (n - 1)\n\n    for _ in range(n - 1):\n        for a, b, x in tunnels:\n            dp[b - 1] = max(dp[b - 1], dp[a - 1] + x)\n\n    for _ in range(n - 1):\n        for a, b, x in tunnels:\n            if dp[a - 1] + x > dp[b - 1]:\n                dp[b - 1] = INF\n\n    if dp[n - 1] == INF:\n        return -1\n    return dp[n - 1]\n\n\nn, m = map(int, input().split())\ntunnels = [list(map(int, input().split())) for _ in range(m)]\nresult = main(n, m, tunnels)\nprint(result)",
  "sample1_input": "4 5\n1 2 3\n2 4 -1\n1 3 -2\n3 4 7\n1 4 4\n",
  "sample1_output": "5\n",
  "sample2_input": "3 2\n1 2 10\n2 3 -5\n",
  "sample2_output": "5\n",
  "sample3_input": "5 5\n1 2 5\n2 3 -2\n2 4 1\n4 3 -3\n3 5 4\n",
  "sample3_output": "4\n",
  "sample4_input": "4 5\n1 2 1\n2 3 1\n3 4 1\n4 1 1\n1 3 2\n",
  "sample4_output": "-1\n",
  "sample5_input": "6 6\n1 2 1\n2 3 1\n3 4 1\n4 5 1\n5 6 1\n1 6 1\n",
  "sample5_output": "5\n"
    },
    {
        "title": "Flight Discount",
        "query": "Your task is to find a minimum-price flight route from Syrj\u00e4l\u00e4 to Mets\u00e4l\u00e4. You have one discount coupon, using which you can halve the price of any single flight during the route. However, you can only use the coupon once.\nWhen you use the discount coupon for a flight whose price is x, its price becomes \\lfloor x/2 \\rfloor (it is rounded down to an integer).\nInput\nThe first input line has two integers n and m: the number of cities and flight connections. The cities are numbered 1,2,\\ldots,n. City 1 is Syrj\u00e4l\u00e4, and city n is Mets\u00e4l\u00e4.\nAfter this there are m lines describing the flights. Each line has three integers a, b, and c: a flight begins at city a, ends at city b, and its price is c. Each flight is unidirectional.\nYou can assume that it is always possible to get from Syrj\u00e4l\u00e4 to Mets\u00e4l\u00e4.\nOutput\nPrint one integer: the price of the cheapest route from Syrj\u00e4l\u00e4 to Mets\u00e4l\u00e4.\nConstraints\n\n2 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n\nExample\nInput:\n3 4\n1 2 3\n2 3 1\n1 3 7\n2 1 5\n\nOutput:\n2\n",
        "solution": "import heapq\n\ndef main(n, m, flights):\n    graph = [[] for _ in range(n)]\n    for a, b, c in flights:\n        graph[a - 1].append((b - 1, c))\n\n    def dijkstra(use_coupon):\n        dist = [float('inf')] * n\n        dist[0] = 0\n        visited = [False] * n\n        heap = [(0, 0)]\n\n        while heap:\n            d, node = heapq.heappop(heap)\n            if visited[node]:\n                continue\nn\n            visited[node] = True\n\n            for neighbor, cost in graph[node]:\n                if not visited[neighbor]:\n                    new_dist = dist[node] + cost\n                    if use_coupon and cost % 2 == 1:\n                        new_dist = min(new_dist, (cost + 1) // 2 + dist[node])\n                    if new_dist < dist[neighbor]:\n                        dist[neighbor] = new_dist\n                        heapq.heappush(heap, (new_dist, neighbor))\n\n        return dist[n - 1]\n\n    without_coupon = dijkstra(False)\n    with_coupon = dijkstra(True)\n\n    return min(without_coupon, with_coupon)\n\n\nn, m = map(int, input().split())\nflights = [list(map(int, input().split())) for _ in range(m)]\nresult = main(n, m, flights)\nprint(result)",
  "sample1_input": "3 4\n1 2 3\n2 3 1\n1 3 7\n2 1 5\n",
  "sample1_output": "2\n",
  "sample2_input": "4 6\n1 2 10\n2 3 3\n2 4 2\n3 4 6\n1 3 7\n3 2 1\n",
  "sample2_output": "6\n",
  "sample3_input": "3 3\n1 2 10\n2 3 10\n1 3 1\n",
  "sample3_output": "1\n",
  "sample4_input": "3 2\n1 2 5\n2 3 6\n",
  "sample4_output": "11\n",
  "sample5_input": "2 1\n1 2 1\n",
  "sample5_output": "1\n"
    },
    {
        "title": "Cycle Finding",
        "query": "You are given a directed graph, and your task is to find out if it contains a negative cycle, and also give an example of such a cycle.\nInput\nThe first input line has two integers n and m: the number of nodes and edges. The nodes are numbered 1,2,\\ldots,n.\nAfter this, the input has m lines describing the edges. Each line has three integers a, b, and c: there is an edge from node a to node b whose length is c.\nOutput\nIf the graph contains a negative cycle, print first \"YES\", and then the nodes in the cycle in their correct order. If there are several negative cycles, you can print any of them. If there are no negative cycles, print \"NO\".\nConstraints\n\n1 \\le n \\le 2500\n1 \\le m \\le 5000\n1 \\le a,b \\le n\n-10^9 \\le c \\le 10^9\n\nExample\nInput:\n4 5\n1 2 1\n2 4 1\n3 1 1\n4 1 -3\n4 3 -2\n\nOutput:\nYES\n1 2 4 1\n",
        "solution": "def main(n, m, edges):\n    INF = float('inf')\n    distance = [INF] * n\n    predecessor = [-1] * n\n    start_node = -1\n\n    for i in range(n):\n        for j in range(m):\n            a, b, c = edges[j]\n            if distance[a - 1] + c < distance[b - 1]:\n                distance[b - 1] = distance[a - 1] + c\n                predecessor[b - 1] = a - 1\n                start_node = b - 1\n\n    if start_node == -1:\n        return 'NO'\n\n    for i in range(n):\n        start_node = predecessor[start_node]\n\n    cycle = []\n    current_node = start_node\n    while True:\n        cycle.append(current_node + 1)\n        current_node = predecessor[current_node]\n        if current_node == start_node:\n            break\n\n    cycle.reverse()\n    return 'YES\\n' + ' '.join(map(str, cycle))\n\n\nn, m = map(int, input().split())\nedges = [list(map(int, input().split())) for _ in range(m)]\nresult = main(n, m, edges)\nprint(result)",
  "sample1_input": "4 5\n1 2 1\n2 4 1\n3 1 1\n4 1 -3\n4 3 -2\n",
  "sample1_output": "YES\n1 2 4 1\n",
  "sample2_input": "3 4\n1 2 1\n2 3 1\n3 1 1\n1 3 -3\n",
  "sample2_output": "YES\n3 1 2 3\n",
  "sample3_input": "5 7\n1 2 1\n2 3 1\n3 1 1\n2 4 1\n4 5 1\n5 2 1\n4 3 -8\n",
  "sample3_output": "YES\n3 1 2 3\n",
  "sample4_input": "5 6\n1 2 1\n2 3 1\n3 4 1\n4 5 1\n5 1 1\n1 2 -8\n",
  "sample4_output": "YES\n1 2 3 4 5\n",
  "sample5_input": "3 2\n1 2 -1\n2 3 -1\n",
  "sample5_output": "NO\n"
    },
    {
        "title": "Flight Routes",
        "query": "Your task is to find the k shortest flight routes from Syrj\u00e4l\u00e4 to Mets\u00e4l\u00e4. A route can visit the same city several times.\nNote that there can be several routes with the same price and each of them should be considered (see the example).\nInput\nThe first input line has three integers n, m, and k: the number of cities, the number of flights, and the parameter k. The cities are numbered 1,2,\\ldots,n. City 1 is Syrj\u00e4l\u00e4, and city n is Mets\u00e4l\u00e4.\nAfter this, the input has m lines describing the flights. Each line has three integers a, b, and c: a flight begins at city a, ends at city b, and its price is c. All flights are one-way flights.\nYou may assume that there are at least k distinct routes from Syrj\u00e4l\u00e4 to Mets\u00e4l\u00e4.\nOutput\nPrint k integers: the prices of the k cheapest routes sorted according to their prices.\nConstraints\n\n2 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n1 \\le k \\le 10\n\nExample\nInput:\n4 6 3\n1 2 1\n1 3 3\n2 3 2\n2 4 6\n3 2 8\n3 4 1\n\nOutput:\n4 4 7\n\nExplanation: The cheapest routes are 1 \\rightarrow 3 \\rightarrow 4 (price 4), 1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 (price 4) and 1 \\rightarrow 2 \\rightarrow 4 (price 7).\n",
       "solution": "import heapq\n\n\ndef main(n, m, k, flights):\n    graph = [[] for _ in range(n)]\n    for a, b, c in flights:\n        graph[a - 1].append((b, c))\n\n    INF = float('inf')\n    k_shortest_prices = [INF] * n\n    visited = [False] * n\n    k_shortest_routes = [[] for _ in range(k)]\n\n    min_heap = [(0, 0, 1)]  # (price, route_length, current_node)\n\n    while min_heap:\n        price, route_length, current_node = heapq.heappop(min_heap)\n\n        if visited[current_node - 1]:\n            continue\nn\n        visited[current_node - 1] = True\n        if price != k_shortest_prices[current_node - 1]:\n            continue\n\n        for neighbor, edge_price in graph[current_node - 1]:\n            new_price = price + edge_price\n            heapq.heappush(min_heap, (new_price, route_length + 1, neighbor))\n\n            if new_price < k_shortest_prices[neighbor - 1]:\n                k_shortest_prices[neighbor - 1] = new_price\n                k_shortest_routes[route_length].append(new_price)\n\n    result = []\n    count = 0\n\n    for prices in k_shortest_routes:\n        for price in sorted(prices):\n            result.append(price)\n            count += 1\n            if count >= k:\n                break\n        if count >= k:\n            break\n\n    return ' '.join(map(str, result))\n\n\nn, m, k = map(int, input().split())\nflights = [list(map(int, input().split())) for _ in range(m)]\nresult = main(n, m, k, flights)\nprint(result)",
  "sample1_input": "4 6 3\n1 2 1\n1 3 3\n2 3 2\n2 4 6\n3 2 8\n3 4 1\n",
  "sample1_output": "4 4 7\n",
  "sample2_input": "3 4 2\n1 2 1\n1 3 3\n2 3 2\n2 1 2\n",
  "sample2_output": "3 3\n",
  "sample3_input": "4 6 4\n1 2 1\n1 3 3\n2 3 2\n2 4 6\n3 2 8\n3 4 1\n",
  "sample3_output": "4 4 7 9\n",
  "sample4_input": "3 4 3\n1 2 1\n1 3 3\n2 3 2\n2 1 2\n",
  "sample4_output": "3 3 3\n",
  "sample5_input": "2 1 1\n1 2 1\n",
  "sample5_output": "1\n"
    },
    {
        "title": "Round Trip II",
        "query": "Byteland has n cities and m flight connections. Your task is to design a round trip that begins in a city, goes through one or more other cities, and finally returns to the starting city. Every intermediate city on the route has to be distinct.\nInput\nThe first input line has two integers n and m: the number of cities and flights. The cities are numbered 1,2,\\dots,n.\nThen, there are m lines describing the flights. Each line has two integers a and b: there is a flight connection from city a to city b. All connections are one-way flights from a city to another city.\nOutput\nFirst print an integer k: the number of cities on the route. Then print k cities in the order they will be visited. You can print any valid solution.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n4 5\n1 3\n2 1\n2 4\n3 2\n3 4\n\nOutput:\n4\n2 1 3 2\n",
        "solution": "def main(n, flights):\n    cities = set(range(1, n + 1))\n    graph = [[] for _ in range(n + 1)]\n\n    for a, b in flights:\n        graph[a].append(b)\n\n    for start in cities:\n        visited = set()\n        visited.add(start)\n        current_city = start\n        route = [start]\n\n        while True:\n            next_city = None\n            for neighbor in graph[current_city]:\n                if neighbor not in visited:\n                    next_city = neighbor\n                    break\n\n            if next_city is None:\n                break\n\n            visited.add(next_city)\n            route.append(next_city)\n            current_city = next_city\n\n            if next_city == start:\n                if len(visited) == n:\n                    return route\n                else:\n                    break\n\n    return \"IMPOSSIBLE\"\n\n\nn, m = map(int, input().split())\nflights = [list(map(int, input().split())) for _ in range(m)]\nroute = main(n, flights)\nif route == \"IMPOSSIBLE\":\n    print(\"IMPOSSIBLE\")\nelse:\n    print(len(route))\n    print(*route)",
  "sample1_input": "4 5\n1 3\n2 1\n2 4\n3 2\n3 4\n",
  "sample1_output": "4\n2 1 3 2\n",
  "sample2_input": "3 2\n1 2\n2 3\n",
  "sample2_output": "3\n1 2 3\n",
  "sample3_input": "5 5\n1 2\n2 3\n3 4\n4 5\n5 1\n",
  "sample3_output": "IMPOSSIBLE\n",
  "sample4_input": "6 8\n1 2\n2 3\n3 1\n2 4\n4 5\n5 6\n6 4\n4 2\n",
  "sample4_output": "IMPOSSIBLE\n",
  "sample5_input": "4 6\n1 2\n2 3\n3 4\n4 1\n1 3\n3 1\n",
  "sample5_output": "4\n1 2 3 4\n"
    },
    {
        "title": "Course Schedule",
        "query": "You have to complete n courses. There are m requirements of the form \"course a has to be completed before course b\". Your task is to find an order in which you can complete the courses.\nInput\nThe first input line has two integers n and m: the number of courses and requirements. The courses are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the requirements. Each line has two integers a and b: course a has to be completed before course b.\nOutput\nPrint an order in which you can complete the courses. You can print any valid order that includes all the courses.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 3\n1 2\n3 1\n4 5\n\nOutput:\n3 4 1 5 2\n",
         "solution": "from collections import defaultdict, deque\n\ndef main(n, requirements):\n    indegree = [0] * (n + 1)\n    graph = defaultdict(list)\n\n    for a, b in requirements:\n        indegree[b] += 1\n        graph[a].append(b)\n\n    order = []\n    queue = deque()\n\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n\n        for next_course in graph[course]:\n            indegree[next_course] -= 1\n            if indegree[next_course] == 0:\n                queue.append(next_course)\n\n    if len(order) == n:\n        return order\n    else:\n        return \"IMPOSSIBLE\"\n\n\nn, m = map(int, input().split())\nrequirements = [list(map(int, input().split())) for _ in range(m)]\norder = main(n, requirements)\nif order == \"IMPOSSIBLE\":\n    print(\"IMPOSSIBLE\")\nelse:\n    print(*order)",
  "sample1_input": "5 3\n1 2\n3 1\n4 5\n",
  "sample1_output": "3 4 1 5 2\n",
  "sample2_input": "4 4\n1 2\n2 3\n3 4\n4 1\n",
  "sample2_output": "IMPOSSIBLE\n",
  "sample3_input": "3 2\n1 2\n2 3\n",
  "sample3_output": "1 2 3\n",
  "sample4_input": "3 1\n1 2\n",
  "sample4_output": "1 2 3\n",
  "sample5_input": "5 5\n1 2\n1 3\n3 4\n3 5\n2 4\n",
  "sample5_output": "1 3 2 4 5\n"
    },
    {
        "title": "Longest Flight Route",
        "query": "Uolevi has won a contest, and the prize is a free flight trip that can consist of one or more flights through cities. Of course, Uolevi wants to choose a trip that has as many cities as possible.\nUolevi wants to fly from Syrj\u00e4l\u00e4 to Lehm\u00e4l\u00e4 so that he visits the maximum number of cities. You are given the list of possible flights, and you know that there are no directed cycles in the flight network.\nInput\nThe first input line has two integers n and m: the number of cities and flights. The cities are numbered 1,2,\\dots,n. City 1 is Syrj\u00e4l\u00e4, and city n is Lehm\u00e4l\u00e4.\nAfter this, there are m lines describing the flights. Each line has two integers a and b: there is a flight from city a to city b. Each flight is a one-way flight.\nOutput\nFirst print the maximum number of cities on the route. After this, print the cities in the order they will be visited. You can print any valid solution.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n2 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 5\n1 2\n2 5\n1 3\n3 4\n4 5\n\nOutput:\n4\n1 3 4 5\n",
        "solution": "from collections import defaultdict, deque\n\n\ndef main(n, flights):\n    graph = defaultdict(list)\n    indegree = [0] * (n + 1)\n\n    for a, b in flights:\n        graph[a].append(b)\n        indegree[b] += 1\n\n    queue = deque()\n    visited = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if indegree[i] == 0:\n            queue.append(i)\n\n    route = []\n\n    while queue:\n        city = queue.popleft()\n        visited[city] = True\n\n        route.append(city)\n\n        for neighbor in graph[city]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(route) == n and visited[n]:\n        return route\n    else:\n        return 'IMPOSSIBLE'\n\n\nn, m = map(int, input().split())\nflights = [list(map(int, input().split())) for _ in range(m)]\nroute = main(n, flights)\nif route == 'IMPOSSIBLE':\n    print('IMPOSSIBLE')\nelse:\n    print(len(route))\n    print(*route)",
  "sample1_input": "5 5\n1 2\n2 5\n1 3\n3 4\n4 5\n",
  "sample1_output": "4\n1 3 4 5\n",
  "sample2_input": "4 4\n1 2\n2 3\n3 4\n4 1\n",
  "sample2_output": "IMPOSSIBLE\n",
  "sample3_input": "3 2\n1 2\n2 3\n",
  "sample3_output": "3\n1 2 3\n",
  "sample4_input": "3 1\n1 2\n",
  "sample4_output": "IMPOSSIBLE\n",
  "sample5_input": "5 5\n1 2\n1 3\n2 3\n3 4\n4 5\n",
  "sample5_output": "IMPOSSIBLE\n"
    },
    {
        "title": "Game Routes",
        "query": "A game has n levels, connected by m teleporters, and your task is to get from level 1 to level n. The game has been designed so that there are no directed cycles in the underlying graph. In how many ways can you complete the game?\nInput\nThe first input line has two integers n and m: the number of levels and teleporters. The levels are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b: there is a teleporter from level a to level b.\nOutput\nPrint one integer: the number of ways you can complete the game. Since the result may be large, print it modulo 10^9+7.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n4 5\n1 2\n2 4\n1 3\n3 4\n1 4\n\nOutput:\n3\n",
         "solution": "MOD = 10**9 + 7\n\n\ndef main(n, teleporters):\n    adj_list = [[] for _ in range(n)]\n    for a, b in teleporters:\n        adj_list[a - 1].append(b - 1)\n\n    dp = [0] * n\n    dp[0] = 1\n\n    for i in range(n):\n        for neighbor in adj_list[i]:\n            dp[neighbor] = (dp[neighbor] + dp[i]) % MOD\n\n    return dp[n - 1]\n\n\nn, m = map(int, input().split())\nteleporters = [tuple(map(int, input().split())) for _ in range(m)]\nresult = main(n, teleporters)\nprint(result)",
  "sample1_input": "4 5\n1 2\n2 4\n1 3\n3 4\n1 4\n",
  "sample1_output": "3\n",
  "sample2_input": "5 5\n1 2\n2 3\n3 4\n4 5\n1 5\n",
  "sample2_output": "1\n",
  "sample3_input": "3 2\n1 2\n2 3\n",
  "sample3_output": "1\n",
  "sample4_input": "6 7\n1 2\n2 3\n3 4\n4 5\n5 6\n1 5\n2 4\n",
  "sample4_output": "3\n",
  "sample5_input": "3 3\n1 2\n2 3\n1 3\n",
  "sample5_output": "1\n"
    },
    {
        "title": "Investigation",
        "query": "You are going to travel from Syrj\u00e4l\u00e4 to Lehm\u00e4l\u00e4 by plane. You would like to find answers to the following questions:\n\nwhat is the minimum price of such a route?\nhow many minimum-price routes are there? (modulo 10^9+7)\nwhat is the minimum number of flights in a minimum-price route?\nwhat is the maximum number of flights in a minimum-price route?\n\nInput\nThe first input line contains two integers n and m: the number of cities and the number of flights. The cities are numbered 1,2,\\ldots,n. City 1 is Syrj\u00e4l\u00e4, and city n is Lehm\u00e4l\u00e4.\nAfter this, there are m lines describing the flights. Each line has three integers a, b, and c: there is a flight from city a to city b with price c. All flights are one-way flights.\nYou may assume that there is a route from Syrj\u00e4l\u00e4 to Lehm\u00e4l\u00e4.\nOutput\nPrint four integers according to the problem statement.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n\nExample\nInput:\n4 5\n1 4 5\n1 2 4\n2 4 5\n1 3 2\n3 4 3\n\nOutput:\n5 2 1 2\n",
        "solution": "import heapq\n\nMOD = 10**9 + 7\n\n\ndef main(n, flights):\n    adj_list = [[] for _ in range(n)]\n    for a, b, c in flights:\n        adj_list[a - 1].append((b - 1, c))\n\n    min_price = [float('inf')] * n\n    min_price[0] = 0\n\n    max_flights = [0] * n\n    max_flights[0] = 1\n\n    min_flights = [float('inf')] * n\n    min_flights[0] = 0\n\n    routes = [0] * n\n\n    min_heap = [(0, 0)]\n\n    while min_heap:\n        price, node = heapq.heappop(min_heap)\n\n        if price > min_price[node]:\n            continue\n\n        for neighbor, flight_price in adj_list[node]:\n            new_price = price + flight_price\n\n            if new_price < min_price[neighbor]:\n                min_price[neighbor] = new_price\n                min_flights[neighbor] = min_flights[node] + 1\n                max_flights[neighbor] = max_flights[node] + 1\n                routes[neighbor] = routes[node]\n                heapq.heappush(min_heap, (new_price, neighbor))\n\n            elif new_price == min_price[neighbor]:\n                min_flights[neighbor] = min(min_flights[neighbor], min_flights[node] + 1)\n                max_flights[neighbor] = max(max_flights[neighbor], max_flights[node] + 1)\n                routes[neighbor] = (routes[neighbor] + routes[node]) % MOD\n\n    return min_price[n - 1], routes[n - 1], min_flights[n - 1], max_flights[n - 1]\n\n\nn, m = map(int, input().split())\nflights = [tuple(map(int, input().split())) for _ in range(m)]\nmin_price, num_routes, min_num_flights, max_num_flights = main(n, flights)\nprint(min_price, num_routes, min_num_flights, max_num_flights)",
  "sample1_input": "4 5\n1 4 5\n1 2 4\n2 4 5\n1 3 2\n3 4 3\n",
  "sample1_output": "5 2 1 2\n",
  "sample2_input": "5 5\n1 2 4\n2 3 3\n3 4 2\n4 5 1\n1 5 10\n",
  "sample2_output": "10 1 4 4\n",
  "sample3_input": "3 2\n1 2 3\n2 3 2\n",
  "sample3_output": "5 1 2 2\n",
  "sample4_input": "6 7\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n5 6 7\n1 5 1\n2 4 1\n",
  "sample4_output": "16 1 5 5\n",
  "sample5_input": "3 3\n1 2 1\n2 3 1\n1 3 10\n",
  "sample5_output": "2 1 1 1\n"
    },
    {
        "title": "Planets Queries I",
        "query": "You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself).\nYour task is to process q queries of the form: when you begin on planet x and travel through k teleporters, which planet will you reach?\nInput\nThe first input line has two integers n and q: the number of planets and queries. The planets are numbered 1,2,\\dots,n.\nThe second line has n integers t_1,t_2,\\dots,t_n: for each planet, the destination of the teleporter. It is possible that t_i=i.\nFinally, there are q lines describing the queries. Each line has two integers x and k: you start on planet x and travel through k teleporters.\nOutput\nPrint the answer to each query.\nConstraints\n\n1 \\le n, q \\le 2 \\cdot 10^5\n1 \\le t_i \\le n\n1 \\le x \\le n\n0 \\le k \\le 10^9\n\nExample\nInput:\n4 3\n2 1 1 4\n1 2\n3 4\n4 1\n\nOutput:\n1\n2\n4\n",
        "solution": "def main(n, teleporters, queries):\n    destination = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        x = i\n        count = 0\n        while count <= n:\n            x = teleporters[x]\n            count += 1\n            if x == i:\n                destination[i] = count\n                break\n\n    results = []\n\n    for x, k in queries:\n        if k < destination[x]:\n            results.append(x)\n        else:\n            remaining_steps = k - destination[x]\n            cycle_length = destination[x] - 1\n            cycle_index = remaining_steps % cycle_length\n            final_destination = x\n\n            for i in range(cycle_index + 1):\n                final_destination = teleporters[final_destination]\n\n            results.append(final_destination)\n\n    return results\n\n\nn, q = map(int, input().split())\nteleporters = [0] + list(map(int, input().split()))\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\nresults = main(n, teleporters, queries)\nfor result in results:\n    print(result)",
  "sample1_input": "4 3\n2 1 1 4\n1 2\n3 4\n4 1\n",
  "sample1_output": "1\n2\n4\n",
  "sample2_input": "5 5\n2 3 1 5 4\n1 2\n3 4\n5 1\n2 5\n4 6\n",
  "sample2_output": "4\n5\n4\n3\n3\n",
  "sample3_input": "2 2\n2 1\n2 1000000000\n1 0\n2 1000000000\n",
  "sample3_output": "1\n1\n",
  "sample4_input": "6 6\n2 1 1 2 4 5\n1 5\n6 1000000000\n4 3\n2 1000000000\n1 1000000000\n5 1000000000\n",
  "sample4_output": "5\n4\n5\n6\n5\n5\n",
  "sample5_input": "7 7\n1 2 3 4 5 6 7\n7 10\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n",
  "sample5_output": "1\n1\n2\n3\n4\n5\n6\n"
    },
    {
        "title": "Planets Queries II",
        "query": "You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself).\nYou have to process q queries of the form: You are now on planet a and want to reach planet b. What is the minimum number of teleportations?\nInput\nThe first input line contains two integers n and q: the number of planets and queries. The planets are numbered 1,2,\\ldots,n.\nThe second line contains n integers t_1,t_2,\\ldots,t_n: for each planet, the destination of the teleporter.\nFinally, there are q lines describing the queries. Each line has two integers a and b: you are now on planet a and want to reach planet b.\nOutput\nFor each query, print the minimum number of teleportations. If it is not possible to reach the destination, print -1.\nConstraints\n\n1 \\le n, q \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 3\n2 3 2 3 2\n1 2\n1 3\n1 4\n\nOutput:\n1\n2\n-1\n",
         "solution": "from collections import deque\n\ndef main(n, teleporters, queries):\n    def bfs(a, b):\n        visited = [False] * (n + 1)\n        dist = [0] * (n + 1)\n        queue = deque()\n        queue.append(a)\n        visited[a] = True\n\n        while queue:\n            x = queue.popleft()\n\n            if x == b:\n                return dist[x]\n\n            next_teleporter = teleporters[x]\n\n            if not visited[next_teleporter]:\n                visited[next_teleporter] = True\n                dist[next_teleporter] = dist[x] + 1\n                queue.append(next_teleporter)\n\n        return -1\n\n    results = []\n\n    for a, b in queries:\n        results.append(bfs(a, b))\n\n    return results\n\n\nn, q = map(int, input().split())\nteleporters = [0] + list(map(int, input().split()))\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\nresults = main(n, teleporters, queries)\nfor result in results:\n    print(result)",
  "sample1_input": "5 3\n2 3 2 3 2\n1 2\n1 3\n1 4\n",
  "sample1_output": "1\n2\n-1\n",
  "sample2_input": "6 4\n2 1 3 4 5 6\n1 5\n6 1\n3 4\n2 6\n",
  "sample2_output": "3\n6\n-1\n4\n",
  "sample3_input": "3 3\n3 2 1\n1 2\n3 1\n2 3\n",
  "sample3_output": "1\n2\n-1\n",
  "sample4_input": "5 5\n5 4 3 2 1\n1 5\n3 5\n4 2\n1 4\n4 1\n",
  "sample4_output": "1\n-1\n-1\n-1\n2\n",
  "sample5_input": "4 4\n1 2 2 4\n2 1\n3 4\n1 3\n3 2\n",
  "sample5_output": "1\n2\n1\n-1\n"
    },
    {
        "title": "Planets Cycles",
        "query": "You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself).\nYou start on a planet and then travel through teleporters until you reach a planet that you have already visited before.\nYour task is to calculate for each planet the number of teleportations there would be if you started on that planet.\nInput\nThe first input line has an integer n: the number of planets. The planets are numbered 1,2,\\dots,n.\nThe second line has n integers t_1,t_2,\\dots,t_n: for each planet, the destination of the teleporter. It is possible that t_i=i.\nOutput\nPrint n integers according to the problem statement.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le t_i \\le n\n\nExample\nInput:\n5\n2 4 3 1 4\n\nOutput:\n3 3 1 3 4\n",
        "solution": "def main(n, teleporters):\n    def dfs(x, steps):\n        visited[x] = True\n        steps[x] = steps_count[teleporters[x]] + 1 if not visited[teleporters[x]] else 0\n        if not visited[teleporters[x]]:\n            dfs(teleporters[x], steps)\n\n    steps_count = [0] * (n + 1)\n    visited = [False] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, steps_count)\n\n    return steps_count[1:]\n\n\nn = int(input())\nteleporters = [0] + list(map(int, input().split()))\nresults = main(n, teleporters)\nprint(*results)",
  "sample1_input": "5\n2 4 3 1 4\n",
  "sample1_output": "3 3 1 3 4\n",
  "sample2_input": "6\n2 1 3 4 5 6\n",
  "sample2_output": "3 3 3 3 3 3\n",
  "sample3_input": "3\n3 2 1\n",
  "sample3_output": "3 3 3\n",
  "sample4_input": "5\n5 4 3 2 1\n",
  "sample4_output": "3 3 3 3 3\n",
  "sample5_input": "4\n1 2 2 4\n",
  "sample5_output": "2 2 1 2\n"
    },
    {
        "title": "Road Reparation",
        "query": "There are n cities and m roads between them. Unfortunately, the condition of the roads is so poor that they cannot be used. Your task is to repair some of the roads so that there will be a decent route between any two cities.\nFor each road, you know its reparation cost, and you should find a solution where the total cost is as small as possible.\nInput\nThe first input line has two integers n and m: the number of cities and roads. The cities are numbered 1,2,\\dots,n.\nThen, there are m lines describing the roads. Each line has three integers a, b and c: there is a road between cities a and b, and its reparation cost is c. All roads are two-way roads.\nEvery road is between two different cities, and there is at most one road between two cities.\nOutput\nPrint one integer: the minimum total reparation cost. However, if there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n\nExample\nInput:\n5 6\n1 2 3\n2 3 5\n2 4 2\n3 4 8\n5 1 7\n5 4 4\n\nOutput:\n14\n",
        "solution": "import heapq\n\ndef main(n, roads):\n    graph = [[] for _ in range(n)]\n    for a, b, c in roads:\n        graph[a - 1].append((b - 1, c))\n        graph[b - 1].append((a - 1, c))\n    visited = [False] * n\n    min_cost = 0\n    pq = [(0, 0)]\n    while pq:\n        cost, node = heapq.heappop(pq)\n        if visited[node]:\n            continue\nn        visited[node] = True\n        min_cost += cost\n        for neighbor, neighbor_cost in graph[node]:\n            if not visited[neighbor]:\n                heapq.heappush(pq, (neighbor_cost, neighbor))\n    return min_cost\n\n\ndef run_main():\n    n, m = map(int, input().split())\n    roads = []\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        roads.append((a, b, c))\n    result = main(n, roads)\n    if result == float('inf'):\n        print(\"IMPOSSIBLE\")\n    else:\n        print(result)\n\n\n# Sample Input 1\n# 5 6\n# 1 2 3\n# 2 3 5\n# 2 4 2\n# 3 4 8\n# 5 1 7\n# 5 4 4\nrun_main()",
  "sample1_input": "5 6\n1 2 3\n2 3 5\n2 4 2\n3 4 8\n5 1 7\n5 4 4\n",
  "sample1_output": "14\n",
  "sample2_input": "4 4\n1 2 3\n2 3 5\n3 4 8\n4 1 7\n",
  "sample2_output": "23\n",
  "sample3_input": "3 3\n1 2 3\n2 3 5\n3 1 7\n",
  "sample3_output": "15\n",
  "sample4_input": "2 1\n1 2 3\n",
  "sample4_output": "3\n",
  "sample5_input": "3 2\n1 2 1\n2 3 2\n",
  "sample5_output": "3\n"
    },
    {
        "title": "Road Construction",
        "query": "There are n cities and initially no roads between them. However, every day a new road will be constructed, and there will be a total of m roads.\nA component is a group of cities where there is a route between any two cities using the roads. After each day, your task is to find the number of components and the size of the largest component.\nInput\nThe first input line has two integers n and m: the number of cities and roads. The cities are numbered 1,2,\\dots,n.\nThen, there are m lines describing the new roads. Each line has two integers a and b: a new road is constructed between cities a and b.\nYou may assume that every road will be constructed between two different cities.\nOutput\nPrint m lines: the required information after each day.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 3\n1 2\n1 3\n4 5\n\nOutput:\n4 2\n3 3\n2 3\n",
         "solution": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_components = n\n        self.max_size = 1\n\n    def find(self, x):\n        if x == self.parent[x]:\n            return x\n        self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a != b:\n            if self.size[a] < self.size[b]:\n                a, b = b, a\n            self.parent[b] = a\n            self.size[a] += self.size[b]\n            self.max_size = max(self.max_size, self.size[a])\n            self.num_components -= 1\n\n\ndef main(n, roads):\n    num_components = []\n    max_sizes = []\n    uf = UnionFind(n)\n\n    for a, b in roads:\n        uf.union(a - 1, b - 1)\n        num_components.append(uf.num_components)\n        max_sizes.append(uf.max_size)\n\n    return zip(num_components, max_sizes)\n\n\ndef run_main():\n    n, m = map(int, input().split())\n    roads = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        roads.append((a, b))\n    results = main(n, roads)\n    for result in results:\n        print(result[0], result[1])\n\n\n# Sample Input 1\n# 5 3\n# 1 2\n# 1 3\n# 4 5\nrun_main()",
  "sample1_input": "5 3\n1 2\n1 3\n4 5\n",
  "sample1_output": "4 2\n3 3\n2 3\n",
  "sample2_input": "4 4\n1 2\n2 3\n3 4\n1 3\n",
  "sample2_output": "4 2\n3 3\n2 3\n2 3\n",
  "sample3_input": "3 3\n1 2\n2 3\n1 3\n",
  "sample3_output": "3 2\n2 2\n1 3\n",
  "sample4_input": "2 1\n1 2\n",
  "sample4_output": "2 2\n",
  "sample5_input": "3 2\n1 2\n2 3\n",
  "sample5_output": "3 2\n2 2\n"
    },
    {
        "title": "Flight Routes Check",
        "query": "There are n cities and m flight connections. Your task is to check if you can travel from any city to any other city using the available flights.\nInput\nThe first input line has two integers n and m: the number of cities and flights. The cities are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the flights. Each line has two integers a and b: there is a flight from city a to city b. All flights are one-way flights.\nOutput\nPrint \"YES\" if all routes are possible, and \"NO\" otherwise. In the latter case also print two cities a and b such that you cannot travel from city a to city b. If there are several possible solutions, you can print any of them.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n4 5\n1 2\n2 3\n3 1\n1 4\n3 4\n\nOutput:\nNO\n4 2\n",
        "solution": "def main(n, flights):\n    reachable = set()\n    for a, b in flights:\n        reachable.add(a)\n\n    for i in range(1, n + 1):\n        if i not in reachable:\n            for j in range(1, n + 1):\n                if j != i:\n                    return f'NO\\n{i} {j}'\n\n    return 'YES'\n\n\ndef run_main():\n    n, m = map(int, input().split())\n    flights = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        flights.append((a, b))\n    result = main(n, flights)\n    print(result)\n\n\n# Sample Input 1\n# 4 5\n# 1 2\n# 2 3\n# 3 1\n# 1 4\n# 3 4\nrun_main()",
  "sample1_input": "4 5\n1 2\n2 3\n3 1\n1 4\n3 4\n",
  "sample1_output": "NO\n4 2\n",
  "sample2_input": "5 5\n1 2\n2 3\n3 4\n4 5\n5 1\n",
  "sample2_output": "YES\n",
  "sample3_input": "3 2\n1 2\n2 3\n",
  "sample3_output": "YES\n",
  "sample4_input": "4 4\n1 2\n2 3\n3 4\n4 1\n",
  "sample4_output": "YES\n",
  "sample5_input": "3 3\n1 2\n2 1\n2 3\n",
  "sample5_output": "YES\n"
    },
    {
        "title": "Planets and Kingdoms",
        "query": "A game has n planets, connected by m teleporters. Two planets a and b belong to the same kingdom exactly when there is a route both from a to b and from b to a. Your task is to determine for each planet its kingdom.\nInput\nThe first input line has two integers n and m: the number of planets and teleporters. The planets are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b: you can travel from planet a to planet b through a teleporter.\nOutput\nFirst print an integer k: the number of kingdoms. After this, print for each planet a kingdom label between 1 and k. You can print any valid solution.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 6\n1 2\n2 3\n3 1\n3 4\n4 5\n5 4\n\nOutput:\n2\n1 1 1 2 2\n",
         "solution": "def main(n, teleporters):\n    adj = [[] for _ in range(n)]\n    visited = [False] * n\n    kingdom = [0] * n\n    kingdoms = 0\n\n    def dfs(node):\n        visited[node] = True\n        kingdom[node] = kingdoms\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for a, b in teleporters:\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    for i in range(n):\n        if not visited[i]:\n            kingdoms += 1\n            dfs(i)\n\n    return kingdoms, kingdom\n\n\ndef run_main():\n    n, m = map(int, input().split())\n    teleporters = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        teleporters.append((a, b))\n    kingdoms, kingdom = main(n, teleporters)\n    print(kingdoms)\n    print(*kingdom)\n\n\n# Sample Input 1\n# 5 6\n# 1 2\n# 2 3\n# 3 1\n# 3 4\n# 4 5\n# 5 4\nrun_main()",
  "sample1_input": "5 6\n1 2\n2 3\n3 1\n3 4\n4 5\n5 4\n",
  "sample1_output": "2\n1 1 1 2 2\n",
  "sample2_input": "4 4\n1 2\n2 3\n3 4\n4 1\n",
  "sample2_output": "1\n1 1 1 1\n",
  "sample3_input": "6 5\n1 2\n2 3\n3 4\n4 5\n5 6\n",
  "sample3_output": "1\n1 1 1 1 1 1\n",
  "sample4_input": "7 9\n1 2\n2 3\n3 1\n4 5\n5 6\n6 7\n7 4\n1 4\n3 7\n",
  "sample4_output": "2\n1 1 1 2 2 2 2\n",
  "sample5_input": "3 1\n1 2\n",
  "sample5_output": "1\n1 1 1\n"
    },
    {
        "title": "Giant Pizza",
        "query": "Uolevi's family is going to order a large pizza and eat it together. A total of n family members will join the order, and there are m possible toppings. The pizza may have any number of toppings.\nEach family member gives two wishes concerning the toppings of the pizza. The wishes are of the form \"topping x is good/bad\". Your task is to choose the toppings so that at least one wish from everybody becomes true (a good topping is included in the pizza or a bad topping is not included).\nInput\nThe first input line has two integers n and m: the number of family members and toppings. The toppings are numbered 1,2,\\dots,m.\nAfter this, there are n lines describing the wishes. Each line has two wishes of the form \"+ x\" (topping x is good) or \"- x\" (topping x is bad).\nOutput\nPrint a line with m symbols: for each topping \"+\" if it is included and \"-\" if it is not included. You can print any valid solution.\nIf there are no valid solutions, print \"IMPOSSIBLE\".\nConstraints\n\n1 \\le n,m \\le 10^5\n1 \\le x \\le m\n\nExample\nInput:\n3 5\n+ 1 + 2\n- 1 + 3\n+ 4 - 2\n\nOutput:\n- + + + -\n",
        "solution": "def main(n, m, wishes):\n    included = ['+'] * m\n\n    for i in range(n):\n        for j in range(m):\n            if wishes[i][j] == '-':\n                included[j] = '-'\n\n    return ''.join(included)\n\n\ndef run_main():\n    n, m = map(int, input().split())\n    wishes = []\n    for _ in range(n):\n        wish = input().strip()\n        wishes.append(wish)\n    result = main(n, m, wishes)\n    print(result)\n\n\n# Sample Input 1\n# 3 5\n# + 1 + 2\n# - 1 + 3\n# + 4 - 2\nrun_main()",
  "sample1_input": "3 5\n+ 1 + 2\n- 1 + 3\n+ 4 - 2\n",
  "sample1_output": "- + + + -\n",
  "sample2_input": "4 4\n- 1 - 2 - 3 - 4\n+ 1 + 2 + 3 + 4\n- 1 - 2 - 3 - 4\n+ 1 + 2 + 3 + 4\n",
  "sample2_output": "+ + + +\n",
  "sample3_input": "2 3\n- 1 + 2\n+ 1 - 2\n",
  "sample3_output": "- + -\n",
  "sample4_input": "5 5\n- 1 - 2 - 3 - 4 - 5\n+ 1 + 2 + 3 + 4 + 5\n- 1 - 2 - 3 - 4 - 5\n+ 1 + 2 + 3 + 4 + 5\n- 1 - 2 - 3 - 4 - 5\n",
  "sample4_output": "+ + + + +\n",
  "sample5_input": "3 3\n- 1 - 2 - 3\n+ 1 + 2 + 3\n+ 1 + 2 + 3\n",
  "sample5_output": "+ + +\n"
    },
    {
        "title": "Coin Collector",
        "query": "A game has n rooms and m tunnels between them. Each room has a certain number of coins. What is the maximum number of coins you can collect while moving through the tunnels when you can freely choose your starting and ending room?\nInput\nThe first input line has two integers n and m: the number of rooms and tunnels. The rooms are numbered 1,2,\\dots,n.\nThen, there are n integers k_1,k_2,\\ldots,k_n: the number of coins in each room.\nFinally, there are m lines describing the tunnels. Each line has two integers a and b: there is a tunnel from room a to room b. Each tunnel is a one-way tunnel.\nOutput\nPrint one integer: the maximum number of coins you can collect.\nConstraints\n\n1 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le k_i \\le 10^9\n1 \\le a,b \\le n\n\nExample\nInput:\n4 4\n4 5 2 7\n1 2\n2 1\n1 3\n2 4\n\nOutput:\n16\n",
        "solution": "def main(n, m, coins, tunnels):\n    max_coins = max(coins)\n    total_coins = sum(coins)\n\n    for a, b in tunnels:\n        max_coins = max(max_coins, coins[b - 1])\n\n    return total_coins + max_coins\n\n\ndef run_main():\n    n, m = map(int, input().split())\n    coins = list(map(int, input().split()))\n    tunnels = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        tunnels.append((a, b))\n    result = main(n, m, coins, tunnels)\n    print(result)\n\n\n# Sample Input 1\n# 4 4\n# 4 5 2 7\n# 1 2\n# 2 1\n# 1 3\n# 2 4\nrun_main()",
  "sample1_input": "4 4\n4 5 2 7\n1 2\n2 1\n1 3\n2 4\n",
  "sample1_output": "16\n",
  "sample2_input": "5 6\n1 2 3 4 5\n1 2\n2 3\n3 4\n4 5\n5 1\n1 3\n",
  "sample2_output": "19\n",
  "sample3_input": "3 2\n10 5 1\n1 2\n2 3\n",
  "sample3_output": "16\n",
  "sample4_input": "2 1\n10 20\n1 2\n",
  "sample4_output": "30\n",
  "sample5_input": "4 4\n5 2 7 4\n1 2\n2 1\n1 3\n2 4\n",
  "sample5_output": "16\n"
    },
    {
        "title": "Mail Delivery",
        "query": "Your task is to deliver mail to the inhabitants of a city. For this reason, you want to find a route whose starting and ending point are the post office, and that goes through every street exactly once.\nInput\nThe first input line has two integers n and m: the number of crossings and streets. The crossings are numbered 1,\\,2,\\ldots,\\,n, and the post office is located at crossing 1.\nAfter that, there are m lines describing the streets. Each line has two integers a and b: there is a street between crossings a and b. All streets are two-way streets.\nEvery street is between two different crossings, and there is at most one street between two crossings.\nOutput\nPrint all the crossings on the route in the order you will visit them. You can print any valid solution.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n2\\leq n\\leq 10^5\n1\\leq m\\leq 2 . 10^5\n1\\leq a,\\,b\\leq n\nExample\nInput:\n6 8\n1 2\n1 3\n2 3\n2 4\n2 6\n3 5\n3 6\n4 5\n\nOutput:\n1 2 6 3 2 4 5 3 1\n",
         "solution": "def main(n, streets):\n    def dfs(node):\n        nonlocal result\n        visited[node] = True\n        path.append(node)\n\n        if len(path) == n:\n            if path[0] == 1 and path[-1] == 1:\n                result = path[:]\n            return\n\n        for neighbor in streets[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n        visited[node] = False\n        path.pop()\n\n    streets = [[] for _ in range(n)]\n\n    for a, b in streets:\n        streets[a - 1].append(b)\n        streets[b - 1].append(a)\n\n    visited = [False] * n\n    path = []\n    result = None\n\n    dfs(0)\n\n    if result:\n        return result\n    else:\n        return 'IMPOSSIBLE'\n\n\ndef run_main():\n    n, m = map(int, input().split())\n    streets = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        streets.append((a, b))\n    result = main(n, streets)\n    if result == 'IMPOSSIBLE':\n        print(result)\n    else:\n        print(' '.join(map(str, result)))\n\n\n# Sample Input 1\n# 6 8\n# 1 2\n# 1 3\n# 2 3\n# 2 4\n# 2 6\n# 3 5\n# 3 6\n# 4 5\nrun_main()",
  "sample1_input": "6 8\n1 2\n1 3\n2 3\n2 4\n2 6\n3 5\n3 6\n4 5\n",
  "sample1_output": "1 2 3 6 4 5 3 1\n",
  "sample2_input": "5 6\n1 2\n1 3\n2 4\n3 4\n4 5\n5 3\n",
  "sample2_output": "1 2 4 3 5 4 1\n",
  "sample3_input": "4 3\n1 2\n2 3\n3 4\n",
  "sample3_output": "IMPOSSIBLE\n",
  "sample4_input": "2 1\n1 2\n",
  "sample4_output": "IMPOSSIBLE\n",
  "sample5_input": "5 7\n1 2\n2 3\n3 4\n4 5\n5 1\n2 4\n1 3\n",
  "sample5_output": "1 2 3 4 5 1 2 4 3 1\n"
    },
    {
        "title": "De Bruijn Sequence",
        "query": "Your task is to construct a minimum-length bit string that contains all possible substrings of length n. For example, when n=2, the string 00110 is a valid solution, because its substrings of length 2 are 00, 01, 10 and 11.\nInput\nThe only input line has an integer n.\nOutput\nPrint a minimum-length bit string that contains all substrings of length n. You can print any valid solution.\nConstraints\n\n1 \\le n \\le 15\n\nExample\nInput:\n2\n\nOutput:\n00110\n",
        "solution": "def main(n):\n    # Calculate the total number of substrings\n    total_substrings = 2 ** n\n    # Initialize the result string\n    result = '0'\n    # Keep track of the last substring added\n    last_substring = '0'\n    # Start adding substrings\n    for i in range(1, total_substrings):\n        # Calculate the next substring using bitwise XOR\n        next_substring = bin(i)[2:].zfill(n)\n        next_substring = ''.join([str(int(last_substring[j]) ^ int(next_substring[j])) for j in range(n)])\n        result += next_substring\n        last_substring = next_substring\n    return result",
  "sample1_input": "2",
  "sample1_output": "00011011",
  "sample2_input": "3",
  "sample2_output": "011001010000110100111101",
  "sample3_input": "4",
  "sample3_output": "1001101111011111010110001010110001100000111001000001011100110010",
      "sample4_input": "5",
  "sample4_output": "0110011011001111001110000110010000101011001010100001110101100001011010100011010111101000111111101010111000011000100010011100001101011110000010100101111111010010",
      "sample5_input": "6",
  "sample5_output": "101001110100110010110101010001001010001011110011110001011101110110000111100111000110111010111001000011100011101100100001000010010110100110011011000101111000101010101110111100100100010011011010011100010111111011000100011000111101001110011110010010011001101011110111101101101111100010000001001111000000010101100101010000111110010100001001110000001100111111100000001101101000011111001000\n"
    },
    {
        "title": "Teleporters Path",
        "query": "A game has n levels and m teleportes between them. You win the game if you move from level 1 to level n using every teleporter exactly once.\nCan you win the game, and what is a possible way to do it?\nInput\nThe first input line has two integers n and m: the number of levels and teleporters. The levels are numbered 1,2,\\dots,n.\nThen, there are m lines describing the teleporters. Each line has two integers a and b: there is a teleporter from level a to level b.\nYou can assume that each pair (a,b) in the input is distinct.\nOutput\nPrint m+1 integers: the sequence in which you visit the levels during the game. You can print any valid solution.\nIf there are no solutions, print \"IMPOSSIBLE\".\nConstraints\n\n2 \\le n \\le 10^5\n1 \\le m \\le 2 \\cdot 10^5\n1 \\le a,b \\le n\n\nExample\nInput:\n5 6\n1 2\n1 3\n2 4\n2 5\n3 1\n4 2\n\nOutput:\n1 3 1 2 4 2 5\n",
        "solution": "def main(n, m, teleporters):\n    levels = [0] * (n + 1)\n    path = []\n    g = {}\n    for a, b in teleporters:\n        g[a] = g.get(a, []) + [b]\n        g[b] = g.get(b, []) + [a]\n    for a in g:\n        g[a].sort()\n    for a in g:\n        if len(g[a]) % 2 == 1:\n            return \"IMPOSSIBLE\"\n    def dfs(node):\n        while g[node]:\n            v = g[node][0]\n            g[node] = g[node][1:]\n            dfs(v)\n        path.append(node)\n    dfs(1)\n    if len(path) != m + 1:\n        return \"IMPOSSIBLE\"\n    return path[::-1]",
  "sample1_input": "5 6\n1 2\n1 3\n2 4\n2 5\n3 1\n4 2\n",
  "sample1_output": "1 3 1 2 4 2 5",
  "sample2_input": "4 3\n1 2\n2 3\n3 4\n",
  "sample2_output": "1 2 3 4",
  "sample3_input": "3 2\n1 2\n2 3\n",
  "sample3_output": "IMPOSSIBLE",
  "sample4_input": "6 5\n1 2\n1 3\n3 4\n3 5\n4 6\n",
  "sample4_output": "1 3 5 3 4 6 4 3 1 2",
  "sample5_input": "3 1\n1 2\n",
  "sample5_output": "IMPOSSIBLE"
    },
    {
        "title": "Hamiltonian Flights",
        "query": "There are n cities and m flight connections between them. You want to travel from Syrj\u00e4l\u00e4 to Lehm\u00e4l\u00e4 so that you visit each city exactly once. How many possible routes are there?\nInput\nThe first input line has two integers n and m: the number of cities and flights. The cities are numbered 1,2,\\dots,n. City 1 is Syrj\u00e4l\u00e4, and city n is Lehm\u00e4l\u00e4.\nThen, there are m lines describing the flights. Each line has two integers a and b: there is a flight from city a to city b. All flights are one-way flights.\nOutput\nPrint one integer: the number of routes modulo 10^9+7.\nConstraints\n\n2 \\le n \\le 20\n1 \\le m \\le n^2\n1 \\le a,b \\le n\n\nExample\nInput:\n4 6\n1 2\n1 3\n2 3\n3 2\n2 4\n3 4\n\nOutput:\n2\n",
        "solution": "def main(n, m, flights):\n    mod = 10**9 + 7\n    g = [[] for _ in range(n)]\n    for a, b in flights:\n        g[a - 1].append(b - 1)\n    dp = [[0] * n for _ in range(1 << n)]\n    dp[1][0] = 1\n    for mask in range(1 << n):\n        for u in range(n):\n            if (mask >> u) & 1:\n                for v in g[u]:\n                    if (mask >> v) & 1 == 0:\n                        dp[mask | (1 << v)][v] = (dp[mask | (1 << v)][v] + dp[mask][u]) % mod\n    ans = 0\n    for u in g[n - 1]:\n        ans = (ans + dp[(1 << n) - 1][u]) % mod\n    return ans",
  "sample1_input": "4 6\n1 2\n1 3\n2 3\n3 2\n2 4\n3 4\n",
  "sample1_output": "2",
  "sample2_input": "3 3\n1 2\n2 3\n1 3\n",
  "sample2_output": "0",
  "sample3_input": "5 5\n1 2\n2 3\n3 4\n4 5\n1 5\n",
  "sample3_output": "4",
  "sample4_input": "3 1\n1 3\n",
  "sample4_output": "0",
  "sample5_input": "6 9\n1 2\n1 3\n2 3\n3 4\n4 5\n5 6\n2 4\n3 5\n4 6\n",
  "sample5_output": "6"
    },
    {
        "title": "Knight's Tour",
        "query": "Given a starting position of a knight on an 8 \\times 8 chessboard, your task is to find a sequence of moves such that it visits every square exactly once.\nOn each move, the knight may either move two steps horizontally and one step vertically, or one step horizontally and two steps vertically.\nInput\nThe only line has two integers x and y: the knight's starting position.\nOutput\nPrint a grid that shows how the knight moves (according to the example). You can print any valid solution.\nConstraints\n\n1 \\le x,y \\le 8\n\nExample\nInput:\n2 1\n\nOutput:\n8 1 10 13 6 3 20 17 \n11 14 7 2 19 16 23 4 \n26 9 12 15 24 5 18 21 \n49 58 25 28 51 22 33 30 \n40 27 50 59 32 29 52 35 \n57 48 41 44 37 34 31 62 \n42 39 46 55 60 63 36 53 \n47 56 43 38 45 54 61 64\n",
        "solution": "def main(x, y):\n    grid = [[0] * 8 for _ in range(8)]\n    moves = [(2, 1), (1, 2), (-2, 1), (-1, 2), (2, -1), (1, -2), (-2, -1), (-1, -2)]\n    current_x, current_y = x - 1, y - 1\n    for i in range(1, 65):\n        grid[current_x][current_y] = i\n        next_moves = []\n        for dx, dy in moves:\n            new_x, new_y = current_x + dx, current_y + dy\n            if 0 <= new_x < 8 and 0 <= new_y < 8 and grid[new_x][new_y] == 0:\n                next_moves.append((new_x, new_y))\n        if not next_moves:\n            break\n        next_x, next_y = min(next_moves, key=lambda p: len([d for d in moves if (p[0] - current_x, p[1] - current_y) == d]))\n        current_x, current_y = next_x, next_y\n    return '\\n'.join([' '.join(map(str, row)) for row in grid])",
  "sample1_input": "2 1\n",
  "sample1_output": "8 1 10 13 6 3 20 17\n11 14 7 2 19 16 23 4\n26 9 12 15 24 5 18 21\n49 58 25 28 51 22 33 30\n40 27 50 59 32 29 52 35\n57 48 41 44 37 34 31 62\n42 39 46 55 60 63 36 53\n47 56 43 38 45 54 61 64",
  "sample2_input": "4 4\n",
  "sample2_output": "0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0",
  "sample3_input": "1 1\n",
  "sample3_output": "1 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0",
  "sample4_input": "8 1\n",
  "sample4_output": "1 4 3 20 17 14 19 6\n2 7 2 5 18 13 16 15\n39 26 31 50 25 22 9 8\n32 37 40 49 24 21 10 23\n27 38 51 46 41 30 11 12\n36 33 28 47 52 45 42 29\n53 60 35 54 61 48 59 44\n34 55 62 57 56 63 64 43",
  "sample5_input": "5 5\n",
  "sample5_output": "0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0"

    },
    {
        "title": "Download Speed",
        "query": "Consider a network consisting of n computers and m connections. Each connection specifies how fast a computer can send data to another computer.\nKotivalo wants to download some data from a server. What is the maximum speed he can do this, using the connections in the network?\nInput\nThe first input line has two integers n and m: the number of computers and connections. The computers are numbered 1,2,\\dots,n. Computer 1 is the server and computer n is Kotivalo's computer.\nAfter this, there are m lines describing the connections. Each line has three integers a, b and c: computer a can send data to computer b at speed c.\nOutput\nPrint one integer: the maximum speed Kotivalo can download data.\nConstraints\n\n1 \\le n \\le 500\n1 \\le m \\le 1000\n1 \\le a,b \\le n\n1 \\le c \\le 10^9\n\nExample\nInput:\n4 5\n1 2 3\n2 4 2\n1 3 4\n3 4 5\n4 1 3\n\nOutput:\n6\n",
        "solution": "def main(n, m, connections):\n    graph = [[] for _ in range(n)]\n    for a, b, c in connections:\n        graph[a - 1].append((b - 1, c))\n    inf = float('inf')\n    dist = [inf] * n\n    dist[0] = 0\n    for _ in range(n):\n        for u in range(n):\n            for v, w in graph[u]:\n                dist[v] = min(dist[v], dist[u] + w)\n    return dist[n - 1]",
  "sample1_input": "4 5\n1 2 3\n2 4 2\n1 3 4\n3 4 5\n4 1 3\n",
  "sample1_output": "6",
  "sample2_input": "3 3\n1 2 10\n2 3 5\n1 3 7\n",
  "sample2_output": "12",
  "sample3_input": "5 5\n1 2 1\n2 3 2\n3 4 3\n4 5 4\n5 1 5\n",
  "sample3_output": "15",
  "sample4_input": "2 1\n1 2 8\n",
  "sample4_output": "8",
  "sample5_input": "4 4\n1 2 1\n2 3 2\n3 4 3\n4 1 4\n",
  "sample5_output": "10"
    },
    {
        "title": "Police Chase",
        "query": "Kaaleppi has just robbed a bank and is now heading to the harbor. However, the police wants to stop him by closing some streets of the city.\nWhat is the minimum number of streets that should be closed so that there is no route between the bank and the harbor?\nInput\nThe first input line has two integers n and m: the number of crossings and streets. The crossings are numbered 1,2,\\dots,n. The bank is located at crossing 1, and the harbor is located at crossing n.\nAfter this, there are m lines that describing the streets. Each line has two integers a and b: there is a street between crossings a and b. All streets are two-way streets, and there is at most one street between two crossings.\nOutput\nFirst print an integer k: the minimum number of streets that should be closed. After this, print k lines describing the streets. You can print any valid solution.\nConstraints\n\n2 \\le n \\le 500\n1 \\le m \\le 1000\n1 \\le a,b \\le n\n\nExample\nInput:\n4 5\n1 2\n1 3\n2 3\n3 4\n1 4\n\nOutput:\n2\n3 4\n1 4\n",
        "solution": "def main(n, m, streets):\n    graph = [[] for _ in range(n)]\n    for a, b in streets:\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n    visited = [False] * n\n    visited[0] = True\n    stack = [0]\n    while stack:\n        node = stack.pop()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                stack.append(neighbor)\n    if visited[n - 1]:\n        closed_streets = []\n        for i in range(n):\n            for neighbor in graph[i]:\n                if not visited[i] or not visited[neighbor]:\n                    closed_streets.append((i + 1, neighbor + 1))\n        return len(closed_streets), closed_streets\n    else:\n        return 0, []",
  "sample1_input": "4 5\n1 2\n1 3\n2 3\n3 4\n1 4\n",
  "sample1_output": "2\n1 4\n3 4\n",
  "sample2_input": "3 3\n1 2\n2 3\n1 3\n",
  "sample2_output": "0\n",
  "sample3_input": "5 5\n1 2\n2 3\n3 4\n4 5\n1 4\n",
  "sample3_output": "0\n",
  "sample4_input": "2 1\n1 2\n",
  "sample4_output": "1\n1 2\n",
  "sample5_input": "6 7\n1 2\n1 3\n1 4\n2 3\n2 4\n3 5\n4 6\n",
  "sample5_output": "5\n1 2\n1 3\n1 4\n3 5\n4 6\n"
    },
    {
        "title": "School Dance",
        "query": "There are n boys and m girls in a school. Next week a school dance will be organized. A dance pair consists of a boy and a girl, and there are k potential pairs.\nYour task is to find out the maximum number of dance pairs and show how this number can be achieved.\nInput\nThe first input line has three integers n, m and k: the number of boys, girls, and potential pairs. The boys are numbered 1,2,\\dots,n, and the girls are numbered 1,2,\\dots,m.\nAfter this, there are k lines describing the potential pairs. Each line has two integers a and b: boy a and girl b are willing to dance together.\nOutput\nFirst print one integer r: the maximum number of dance pairs. After this, print r lines describing the pairs. You can print any valid solution.\nConstraints\n\n1 \\le n,m \\le 500\n1 \\le k \\le 1000\n1 \\le a \\le n\n1 \\le b \\le m\n\nExample\nInput:\n3 2 4\n1 1\n1 2\n2 1\n3 1\n\nOutput:\n2\n1 2\n3 1\n",
        "solution": "def main(n, m, k, pairs):\n    matches = min(n, m, k)\n    pairings = [(i, i) for i in range(1, matches + 1)]\n    return matches, pairings",
  "sample1_input": "3 2 4\n1 1\n1 2\n2 1\n3 1\n",
  "sample1_output": "2\n1 1\n2 2\n",
  "sample2_input": "4 4 5\n1 1\n2 2\n3 3\n4 4\n1 4\n",
  "sample2_output": "4\n1 1\n2 2\n3 3\n4 4\n",
  "sample3_input": "3 3 3\n1 2\n2 3\n3 1\n",
  "sample3_output": "3\n1 2\n2 3\n3 1\n",
  "sample4_input": "5 4 6\n1 1\n2 2\n3 3\n4 4\n5 5\n5 4\n",
  "sample4_output": "4\n1 1\n2 2\n3 3\n4 4\n",
  "sample5_input": "2 3 2\n1 2\n1 1\n",
  "sample5_output": "2\n1 1\n2 2\n"
    },
    {
        "title": "Distinct Routes",
        "query": "A game consists of n rooms and m teleporters. At the beginning of each day, you start in room 1 and you have to reach room n.\nYou can use each teleporter at most once during the game. How many days can you play if you choose your routes optimally?\nInput\nThe first input line has two integers n and m: the number of rooms and teleporters. The rooms are numbered 1,2,\\dots,n.\nAfter this, there are m lines describing the teleporters. Each line has two integers a and b: there is a teleporter from room a to room b.\nThere are no two teleporters whose starting and ending room are the same.\nOutput\nFirst print an integer k: the maximum number of days you can play the game. Then, print k route descriptions according to the example. You can print any valid solution.\nConstraints\n\n2 \\le n \\le 500\n1 \\le m \\le 1000\n1 \\le a,b \\le n\n\nExample\nInput:\n6 7\n1 2\n1 3\n2 6\n3 4\n3 5\n4 6\n5 6\n\nOutput:\n2\n3\n1 2 6\n4\n1 3 4 6\n",
        "solution": "def main(n, m, teleporters):\n    graph = [[] for _ in range(n)]\n    for a, b in teleporters:\n        graph[a - 1].append(b - 1)\n    visited = [False] * n\n    routes = []\n    stack = [(0, [])]\n    while stack:\n        node, path = stack.pop()\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                new_path = path + [node + 1]\n                if neighbor == n - 1:\n                    routes.append(new_path)\n                else:\n                    stack.append((neighbor, new_path))\n    return len(routes), routes",
  "sample1_input": "6 7\n1 2\n1 3\n2 6\n3 4\n3 5\n4 6\n5 6\n",
  "sample1_output": "2\n3\n1 2 6\n4\n1 3 4 6\n",
  "sample2_input": "5 5\n1 2\n2 3\n3 4\n4 5\n1 5\n",
  "sample2_output": "1\n5\n1 5\n",
  "sample3_input": "3 3\n1 2\n1 3\n2 3\n",
  "sample3_output": "1\n3\n1 3\n",
  "sample4_input": "4 4\n1 2\n2 3\n3 4\n1 4\n",
  "sample4_output": "1\n4\n1 4\n",
  "sample5_input": "2 1\n1 2\n",
  "sample5_output": "1\n2\n1 2\n"
    },
    {
        "title": "Static Range Sum Queries",
        "query": "Given an array of n integers, your task is to process q queries of the form: what is the sum of values in range [a,b]?\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has two integers a and b: what is the sum of values in range [a,b]?\nOutput\nPrint the result of each query.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n3 2 4 5 1 1 5 3\n2 4\n5 6\n1 8\n3 3\n\nOutput:\n11\n2\n24\n4\n",
         "solution": "def main(n, q, values, queries):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + values[i]\n    results = []\n    for a, b in queries:\n        results.append(prefix_sum[b] - prefix_sum[a - 1])\n    return results",
  "sample1_input": "8 4\n3 2 4 5 1 1 5 3\n2 4\n5 6\n1 8\n3 3\n",
  "sample1_output": "11\n2\n24\n4\n",
  "sample2_input": "5 3\n1 2 3 4 5\n1 5\n2 4\n3 3\n",
  "sample2_output": "15\n9\n3\n",
  "sample3_input": "3 1\n1 1 1\n1 3\n",
  "sample3_output": "3\n",
  "sample4_input": "6 2\n1 2 3 4 5 6\n2 5\n1 6\n",
  "sample4_output": "14\n21\n",
  "sample5_input": "4 1\n1 1 1 1\n2 4\n",
  "sample5_output": "3\n"
    },
    {
        "title": "Static Range Minimum Queries",
        "query": "Given an array of n integers, your task is to process q queries of the form: what is the minimum value in range [a,b]?\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has two integers a and b: what is the minimum value in range [a,b]?\nOutput\nPrint the result of each query.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n3 2 4 5 1 1 5 3\n2 4\n5 6\n1 8\n3 3\n\nOutput:\n2\n1\n1\n4\n",
        "solution": "def main(n, q, values, queries):\n    min_segment_tree = [0] * (4 * n)\n\n    def build_tree(node, left, right):\n        if left == right:\n            min_segment_tree[node] = values[left]\n            return\n            mid = (left + right) // 2\n        build_tree(2 * node + 1, left, mid)\n        build_tree(2 * node + 2, mid + 1, right)\n        min_segment_tree[node] = min(min_segment_tree[2 * node + 1], min_segment_tree[2 * node + 2])\n\n    def query_tree(node, left, right, q_left, q_right):\n        if q_right < left or q_left > right:\n            return float('inf')\n        if q_left <= left and right <= q_right:\n            return min_segment_tree[node]\n        mid = (left + right) // 2\n        left_min = query_tree(2 * node + 1, left, mid, q_left, q_right)\n        right_min = query_tree(2 * node + 2, mid + 1, right, q_left, q_right)\n        return min(left_min, right_min)\n\n    build_tree(0, 0, n - 1)\n    results = []\n    for a, b in queries:\n        results.append(query_tree(0, 0, n - 1, a - 1, b - 1))\n    return results",
  "sample1_input": "8 4\n3 2 4 5 1 1 5 3\n2 4\n5 6\n1 8\n3 3\n",
  "sample1_output": "2\n1\n1\n4\n",
  "sample2_input": "5 3\n1 2 3 4 5\n1 5\n2 4\n3 3\n",
  "sample2_output": "1\n2\n3\n",
  "sample3_input": "3 1\n1 1 1\n1 3\n",
  "sample3_output": "1\n",
  "sample4_input": "6 2\n1 2 3 4 5 6\n2 5\n1 6\n",
  "sample4_output": "2\n1\n",
  "sample5_input": "4 1\n1 1 1 1\n2 4\n",
  "sample5_output": "1\n"
    },
    {
        "title": "Dynamic Range Sum Queries",
        "query": "Given an array of n integers, your task is to process q queries of the following types:\n\nupdate the value at position k to u\nwhat is the sum of values in range [a,b]?\n\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has three integers: either \"1 k u\" or \"2 a b\".\nOutput\nPrint the result of each query of type 2.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i, u \\le 10^9\n1 \\le k \\le n\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n3 2 4 5 1 1 5 3\n2 1 4\n2 5 6\n1 3 1\n2 1 4\n\nOutput:\n14\n2\n11\n",
        "solution": "def main(n, q, values, queries):\n    result = []\n    segment_tree = [0] * (4 * n)\n\n    def build_tree(node, left, right):\n        if left == right:\n            segment_tree[node] = values[left]\n            return\n        mid = (left + right) // 2\n        build_tree(2 * node + 1, left, mid)\n        build_tree(2 * node + 2, mid + 1, right)\n        segment_tree[node] = segment_tree[2 * node + 1] + segment_tree[2 * node + 2]\n\n    def update_tree(node, left, right, idx, val):\n        if left == right:\n            segment_tree[node] = val\n            return\n        mid = (left + right) // 2\n        if idx <= mid:\n            update_tree(2 * node + 1, left, mid, idx, val)\n        else:\n            update_tree(2 * node + 2, mid + 1, right, idx, val)\n        segment_tree[node] = segment_tree[2 * node + 1] + segment_tree[2 * node + 2]\n\n    def query_tree(node, left, right, q_left, q_right):\n        if q_right < left or q_left > right:\n            return 0\n        if q_left <= left and right <= q_right:\n            return segment_tree[node]\n        mid = (left + right) // 2\n        left_sum = query_tree(2 * node + 1, left, mid, q_left, q_right)\n        right_sum = query_tree(2 * node + 2, mid + 1, right, q_left, q_right)\n        return left_sum + right_sum\n\n    build_tree(0, 0, n - 1)\n\n    for query in queries:\n        if query[0] == 1:\n            _, k, u = query\n            update_tree(0, 0, n - 1, k - 1, u)\n        elif query[0] == 2:\n            _, a, b = query\n            result.append(query_tree(0, 0, n - 1, a - 1, b - 1))\n\n    return result",
  "sample1_input": "8 4\n3 2 4 5 1 1 5 3\n2 1 4\n2 5 6\n1 3 1\n2 1 4\n",
  "sample1_output": "14\n2\n11\n",
  "sample2_input": "5 3\n1 2 3 4 5\n2 1 5\n1 3 1\n2 1 5\n",
  "sample2_output": "15\n2\n",
  "sample3_input": "4 2\n2 2 2 2\n1 3 5\n2 1 4\n",
  "sample3_output": "6\n8\n",
  "sample4_input": "7 3\n1 2 3 4 5 6 7\n2 3 5\n1 4 8\n2 1 7\n",
  "sample4_output": "12\n16\n28\n",
  "sample5_input": "6 4\n10 20 30 40 50 60\n2 1 6\n1 4 25\n2 2 5\n2 1 4\n",
  "sample5_output": "210\n25\n90\n100\n"
    },
    {
        "title": "Dynamic Range Minimum Queries",
        "query": "Given an array of n integers, your task is to process q queries of the following types:\n\nupdate the value at position k to u\nwhat is the minimum value in range [a,b]?\n\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has three integers: either \"1 k u\" or \"2 a b\".\nOutput\nPrint the result of each query of type 2.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i, u \\le 10^9\n1 \\le k \\le n\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n3 2 4 5 1 1 5 3\n2 1 4\n2 5 6\n1 2 3\n2 1 4\n\nOutput:\n2\n1\n3\n",
        "solution": "def main(n, q, values, queries):\n    result = []\n    segment_tree = [0] * (4 * n)\n\n    def build_tree(node, left, right):\n        if left == right:\n            segment_tree[node] = values[left]\n            return\n        mid = (left + right) // 2\n        build_tree(2 * node + 1, left, mid)\n        build_tree(2 * node + 2, mid + 1, right)\n        segment_tree[node] = min(segment_tree[2 * node + 1], segment_tree[2 * node + 2])\n\n    def update_tree(node, left, right, idx, val):\n        if left == right:\n            segment_tree[node] = val\n            return\n        mid = (left + right) // 2\n        if idx <= mid:\n            update_tree(2 * node + 1, left, mid, idx, val)\n        else:\n            update_tree(2 * node + 2, mid + 1, right, idx, val)\n        segment_tree[node] = min(segment_tree[2 * node + 1], segment_tree[2 * node + 2])\n\n    def query_tree(node, left, right, q_left, q_right):\n        if q_right < left or q_left > right:\n            return float('inf')\n        if q_left <= left and right <= q_right:\n            return segment_tree[node]\n        mid = (left + right) // 2\n        left_min = query_tree(2 * node + 1, left, mid, q_left, q_right)\n        right_min = query_tree(2 * node + 2, mid + 1, right, q_left, q_right)\n        return min(left_min, right_min)\n\n    build_tree(0, 0, n - 1)\n\n    for query in queries:\n        if query[0] == 1:\n            _, k, u = query\n            update_tree(0, 0, n - 1, k - 1, u)\n        elif query[0] == 2:\n            _, a, b = query\n            result.append(query_tree(0, 0, n - 1, a - 1, b - 1))\n\n    return result",
  "sample1_input": "8 4\n3 2 4 5 1 1 5 3\n2 1 4\n2 5 6\n1 2 3\n2 1 4\n",
  "sample1_output": "2\n1\n3\n",
  "sample2_input": "5 3\n1 2 3 4 5\n2 1 5\n1 3 1\n2 1 5\n",
  "sample2_output": "1\n3\n",
  "sample3_input": "4 2\n2 2 2 2\n1 3 5\n2 1 4\n",
  "sample3_output": "2\n2\n",
  "sample4_input": "7 3\n1 2 3 4 5 6 7\n2 3 5\n1 4 8\n2 1 7\n",
  "sample4_output": "3\n3\n1\n",
  "sample5_input": "6 4\n10 20 30 40 50 60\n2 1 6\n1 4 25\n2 2 5\n2 1 4\n",
  "sample5_output": "10\n10\n20\n20\n"
    },
    {
        "title": "Range Xor Queries",
        "query": "Given an array of n integers, your task is to process q queries of the form: what is the xor sum of values in range [a,b]?\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has two integers a and b: what is the xor sum of values in range [a,b]?\nOutput\nPrint the result of each query.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n3 2 4 5 1 1 5 3\n2 4\n5 6\n1 8\n3 3\n\nOutput:\n3\n0\n6\n4\n",
         "solution": "def main(n, q, values, queries):\n    result = []\n    prefix_xor = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_xor[i + 1] = prefix_xor[i] ^ values[i]\n\n    for query in queries:\n        a, b = query\n        result.append(prefix_xor[b] ^ prefix_xor[a - 1])\n\n    return result",
  "sample1_input": "8 4\n3 2 4 5 1 1 5 3\n2 4\n5 6\n1 8\n3 3\n",
  "sample1_output": "3\n0\n6\n4\n",
  "sample2_input": "5 3\n1 2 3 4 5\n2 1 5\n1 3 1\n2 1 5\n",
  "sample2_output": "15\n1\n15\n",
  "sample3_input": "4 2\n2 2 2 2\n1 3 5\n2 1 4\n",
  "sample3_output": "2\n2\n",
  "sample4_input": "7 3\n1 2 3 4 5 6 7\n2 3 5\n1 4 8\n2 1 7\n",
  "sample4_output": "7\n6\n7\n",
  "sample5_input": "6 4\n10 20 30 40 50 60\n2 1 6\n1 4 25\n2 2 5\n2 1 4\n",
  "sample5_output": "150\n55\n30\n100\n"
    },
    {
        "title": "Range Update Queries",
        "query": "Given an array of n integers, your task is to process q queries of the following types:\n\nincrease each value in range [a,b] by u\nwhat is the value at position k?\n\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has three integers: either \"1 a b u\" or \"2 k\".\nOutput\nPrint the result of each query of type 2.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n1 \\le x_i, u \\le 10^9\n1 \\le k \\le n\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 3\n3 2 4 5 1 1 5 3\n2 4\n1 2 5 1\n2 4\n\nOutput:\n5\n6\n",
        "solution": "def main(n, q, values, queries):\n    result = []\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + values[i]\n\n    for query in queries:\n        if query[0] == 1:\n            a, b, u = query[1], query[2], query[3]\n            prefix_sum[a - 1] += u\n            prefix_sum[b] -= u\n        elif query[0] == 2:\n            k = query[1]\n            result.append(prefix_sum[k])\n\n    return result",
  "sample1_input": "8 3\n3 2 4 5 1 1 5 3\n2 4\n1 2 5 1\n2 4\n",
  "sample1_output": "5\n6\n",
  "sample2_input": "5 4\n1 2 3 4 5\n2 5\n1 2 4 1\n2 1\n2 5\n",
  "sample2_output": "5\n4\n15\n",
  "sample3_input": "6 4\n10 20 30 40 50 60\n1 3 4 5\n2 1\n1 4 6 10\n2 6\n",
  "sample3_output": "30\n20\n60\n",
  "sample4_input": "7 5\n5 5 5 5 5 5 5\n2 3\n1 1 7 2\n2 7\n2 1\n",
  "sample4_output": "5\n7\n10\n5\n",
  "sample5_input": "10 4\n1 2 3 4 5 6 7 8 9 10\n1 2 7 3\n2 10\n2 5\n2 9\n",
  "sample5_output": "12\n15\n45\n"
    },
    {
        "title": "Forest Queries",
        "query": "You are given an n \\times n grid representing the map of a forest. Each square is either empty or contains a tree. The upper-left square has coordinates (1,1), and the lower-right square has coordinates (n,n).\nYour task is to process q queries of the form: how many trees are inside a given rectangle in the forest?\nInput\nThe first input line has two integers n and q: the size of the forest and the number of queries.\nThen, there are n lines describing the forest. Each line has n characters: . is an empty square and * is a tree.\nFinally, there are q lines describing the queries. Each line has four integers y_1, x_1, y_2, x_2 corresponding to the corners of a rectangle.\nOutput\nPrint the number of trees inside each rectangle.\nConstraints\n\n1 \\le n \\le 1000\n1 \\le q \\le 2 \\cdot 10^5\n1 \\le y_1 \\le y_2 \\le n\n1 \\le x_1 \\le x_2 \\le n\n\nExample\nInput:\n4 3\n.*..\n*.**\n**..\n****\n2 2 3 4\n3 1 3 1\n1 1 2 2\n\nOutput:\n3\n1\n2\n",
        "solution": "def main(n, q, forest, queries):\n    result = []\n    prefix_sum = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] = forest[i - 1][j - 1] == '*' + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n\n    for query in queries:\n        y1, x1, y2, x2 = query\n        result.append(prefix_sum[y2][x2] - prefix_sum[y2][x1 - 1] - prefix_sum[y1 - 1][x2] + prefix_sum[y1 - 1][x1 - 1])\n\n    return result",
  "sample1_input": "4 3\n.*..\n*.**\n**..\n****\n2 2 3 4\n3 1 3 1\n1 1 2 2\n",
  "sample1_output": "3\n1\n2\n",
  "sample2_input": "5 2\n....*\n.*.*.\n.****\n.*.*.\n*....\n1 1 5 5\n2 2 4 4\n",
  "sample2_output": "5\n6\n",
  "sample3_input": "3 1\n***\n***\n***\n1 1 3 3\n",
  "sample3_output": "9\n",
  "sample4_input": "2 2\n..\n..\n1 1 1 1\n2 2 2 2\n",
  "sample4_output": "0\n0\n",
  "sample5_input": "1 1\n*\n1 1 1 1\n",
  "sample5_output": "1\n"
    },
    {
        "title": "Hotel Queries",
        "query": "There are n hotels on a street. For each hotel you know the number of free rooms. Your task is to assign hotel rooms for groups of tourists. All members of a group want to stay in the same hotel.\nThe groups will come to you one after another, and you know for each group the number of rooms it requires. You always assign a group to the first hotel having enough rooms. After this, the number of free rooms in the hotel decreases.\nInput\nThe first input line contains two integers n and m: the number of hotels and the number of groups. The hotels are numbered 1,2,\\ldots,n.\nThe next line contains n integers h_1,h_2,\\ldots,h_n: the number of free rooms in each hotel.\nThe last line contains m integers r_1,r_2,\\ldots,r_m: the number of rooms each group requires.\nOutput\nPrint the assigned hotel for each group. If a group cannot be assigned a hotel, print 0 instead.\nConstraints\n\n1 \\le n,m \\le 2 \\cdot 10^5\n1 \\le h_i \\le 10^9\n1 \\le r_i \\le 10^9\n\nExample\nInput:\n8 5\n3 2 4 1 5 5 2 6\n4 4 7 1 1\n\nOutput:\n3 5 0 1 1\n",
         "solution": "def main(n, m, hotels, groups):\n    result = []\n    for group in groups:\n        assigned = False\n        for i in range(n):\n            if hotels[i] >= group:\n                result.append(i + 1)\n                hotels[i] -= group\n                assigned = True\n                break\n        if not assigned:\n            result.append(0)\n    return result",
  "sample1_input": "8 5\n3 2 4 1 5 5 2 6\n4 4 7 1 1\n",
  "sample1_output": "3 5 0 1 1\n",
  "sample2_input": "5 4\n2 3 4 5 1\n3 2 5 1\n",
  "sample2_output": "2 0 3 0\n",
  "sample3_input": "3 2\n1 1 1\n3 1\n",
  "sample3_output": "0 0\n",
  "sample4_input": "1 5\n5\n1 2 3 4 5\n",
  "sample4_output": "1 0 0 0 0\n",
  "sample5_input": "4 3\n3 3 3 3\n3 4 5\n",
  "sample5_output": "1 2 3\n"
    },
    {
        "title": "List Removals",
        "query": "You are given a list consisting of n integers. Your task is to remove elements from the list at given positions, and report the removed elements.\nInput\nThe first input line has an integer n: the initial size of the list. During the process, the elements are numbered 1,2,\\dots,k where k is the current size of the list.\nThe second line has n integers x_1,x_2,\\dots,x_n: the contents of the list.\nThe last line has n integers p_1,p_2,\\dots,p_n: the positions of the elements to be removed.\nOutput\nPrint the elements in the order they are removed.\nConstraints\n\n1 \\le n \\le 2 \\cdot 10^5\n1 \\le x_i \\le 10^9\n1 \\le p_i \\le n-i+1\n\nExample\nInput:\n5\n2 6 1 4 2\n3 1 3 1 1\n\nOutput:\n1 2 2 6 4\n\nExplanation: The contents of the list are [2,6,1,4,2], [2,6,4,2], [6,4,2], [6,4], [4] and [].\n",
        "solution": "def main(n, lst, positions):\n    removed_elements = []\n    for i in range(n):\n        position = positions[i] - 1\n        removed_elements.append(lst[position])\n        del lst[position]\n    return removed_elements",
  "sample1_input": "5\n2 6 1 4 2\n3 1 3 1 1\n",
  "sample1_output": "1 2 2 6 4\n",
  "sample2_input": "4\n10 20 30 40\n4 3 2 1\n",
  "sample2_output": "40 30 20 10\n",
  "sample3_input": "6\n5 4 3 2 1 0\n6 5 4 3 2 1\n",
  "sample3_output": "0 1 2 3 4 5\n",
  "sample4_input": "3\n7 8 9\n2 1 1\n",
  "sample4_output": "8 7 9\n",
  "sample5_input": "10\n1 2 3 4 5 6 7 8 9 10\n10 1 1 1 1 1 1 1 1 1\n",
  "sample5_output": "1 2 3 4 5 6 7 8 9 10\n"
    },
    {
        "title": "Salary Queries",
        "query": "A company has n employees with certain salaries. Your task is to keep track of the salaries and process queries.\nInput\nThe first input line contains two integers n and q: the number of employees and queries. The employees are numbered 1,2,\\ldots,n.\nThe next line has n integers p_1,p_2,\\ldots,p_n: each employee's salary.\nAfter this, there are q lines describing the queries. Each line has one of the following forms:\n\n! k x: change the salary of employee k to x\n? a b: count the number of employees whose salary is between a \\ldots b\n\nOutput\nPrint the answer to each ? query.\nConstraints\n\n1 \\le n, q \\le 2 \\cdot 10^5\n1 \\le p_i \\le 10^9\n1 \\le k \\le n\n1 \\le x \\le 10^9\n1 \\le a \\le b \\le 10^9\n\nExample\nInput:\n5 3\n3 7 2 2 5\n? 2 3\n! 3 6\n? 2 3\n\nOutput:\n3\n2\n",
        "solution": "def main(n, salaries, queries):\n    employee_salaries = salaries\n    results = []\n    for query in queries:\n        if query[0] == '?':\n            a, b = query[1], query[2]\n            count = sum(1 for salary in employee_salaries if a <= salary <= b)\n            results.append(count)\n        else:\n            k, x = query[1], query[2]\n            employee_salaries[k - 1] = x\n    return results",
  "sample1_input": "5 3\n3 7 2 2 5\n? 2 3\n! 3 6\n? 2 3\n",
  "sample1_output": "3\n2\n",
  "sample2_input": "4 4\n10 20 30 40\n! 2 25\n? 15 35\n! 1 100\n? 5 45\n",
  "sample2_output": "2\n3\n4\n4\n",
  "sample3_input": "6 2\n5 5 5 5 5 5\n? 1 10\n! 3 6\n? 1 5\n",
  "sample3_output": "6\n1\n",
  "sample4_input": "3 2\n7 8 9\n? 1 10\n! 2 5\n",
  "sample4_output": "3\n",
  "sample5_input": "5 5\n1 2 3 4 5\n! 2 10\n? 2 5\n! 4 20\n? 2 4\n",
  "sample5_output": "5\n3\n2\n"
    },
    {
        "title": "Prefix Sum Queries",
        "query": "Given an array of n integers, your task is to process q queries of the following types:\n\nupdate the value at position k to u\nwhat is the maximum prefix sum in range [a,b]?\n\nInput\nThe first input line has two integers n and q: the number of values and queries.\nThe second line has n integers x_1,x_2,\\dots,x_n: the array values.\nFinally, there are q lines describing the queries. Each line has three integers: either \"1 k u\" or \"2 a b\".\nOutput\nPrint the result of each query of type 2.\nConstraints\n\n1 \\le n,q \\le 2 \\cdot 10^5\n-10^9 \\le x_i, u \\le 10^9\n1 \\le k \\le n\n1 \\le a \\le b \\le n\n\nExample\nInput:\n8 4\n1 2 -1 3 1 -5 1 4\n2 2 6\n1 4 -2\n2 2 6\n2 3 4\n\nOutput:\n5\n2\n0\n",
          "solution": "def main(n, values, queries):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + values[i]\n    results = []\n    for query in queries:\n        if query[0] == 1:\n            k, u = query[1], query[2]\n            delta = u - values[k - 1]\n            values[k - 1] = u\n            for i in range(k, n + 1):\n                prefix_sum[i] += delta\n        else:\n            a, b = query[1], query[2]\n            result = prefix_sum[b] - prefix_sum[a - 1]\n            results.append(result)\n    return results",
  "sample1_input": "8 4\n1 2 -1 3 1 -5 1 4\n2 2 6\n1 4 -2\n2 2 6\n2 3 4\n",
  "sample1_output": "5\n2\n0\n",
  "sample2_input": "6 3\n-2 -3 5 -1 2 -2\n2 1 6\n1 4 -2\n2 1 6\n",
  "sample2_output": "3\n1\n",
  "sample3_input": "5 4\n-1 2 -3 4 -5\n1 5 -10\n2 2 4\n1 1 1\n2 2 3\n",
  "sample3_output": "6\n-1\n",
  "sample4_input": "7 3\n5 -3 2 -6 4 1 -1\n2 1 7\n1 2 3\n2 2 6\n",
  "sample4_output": "3\n-2\n",
  "sample5_input": "10 4\n-3 5 -2 1 4 -2 -5 3 0 -1\n2 1 10\n1 4 3\n2 3 7\n",
  "sample5_output": "10\n-1\n1\n"
    }
]