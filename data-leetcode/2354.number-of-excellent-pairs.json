[
    {
        "title": "Equal Row and Column Pairs",
        "question_content": "Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.\nA row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).\n&nbsp;\nExample 1:\n\nInput: grid = [[3,2,1],[1,7,6],[2,7,7]]\nOutput: 1\nExplanation: There is 1 equal row and column pair:\n- (Row 2, Column 1): [2,7,7]\n\nExample 2:\n\nInput: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\nOutput: 3\nExplanation: There are 3 equal row and column pairs:\n- (Row 0, Column 0): [3,1,2,2]\n- (Row 2, Column 2): [2,4,2,2]\n- (Row 3, Column 2): [2,4,2,2]\n\n&nbsp;\nConstraints:\n\n\tn == grid.length == grid[i].length\n\t1 <= n <= 200\n\t1 <= grid[i][j] <= 105",
        "solutions": [
            {
                "id": 2324872,
                "title": "100-fast-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        // Number to store the count of equal pairs.\\n        int ans = 0;\\n        map<vector<int>, int> mp;\\n        // Storing each row int he map\\n        for (int i = 0; i < grid.size(); i++)\\n            mp[grid[i]]++;\\n        \\n        for (int i = 0; i < grid[0].size(); i++)\\n        {\\n            vector<int> v;\\n            // extracting column in a vector.\\n            for (int j = 0; j < grid.size(); j++)\\n                v.push_back(grid[j][i]);\\n            // Add the number of times that column appeared as a row.\\n            ans += mp[v];\\n        }\\n        // Return the number of count\\n        return ans;\\n    }\\n};\\n```\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        // Number to store the count of equal pairs.\\n        int ans = 0;\\n        map<vector<int>, int> mp;\\n        // Storing each row int he map\\n        for (int i = 0; i < grid.size(); i++)\\n            mp[grid[i]]++;\\n        \\n        for (int i = 0; i < grid[0].size(); i++)\\n        {\\n            vector<int> v;\\n            // extracting column in a vector.\\n            for (int j = 0; j < grid.size(); j++)\\n                v.push_back(grid[j][i]);\\n            // Add the number of times that column appeared as a row.\\n            ans += mp[v];\\n        }\\n        // Return the number of count\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324688,
                "title": "cubic-432-vs-three-map-95-vs-trie-137",
                "content": "`n` is small, so a Cubic solution should do for the contest.\\n\\nLater, I solved this problem using the Trie and Tree Map approaches, which are Quadratic.\\n\\n#### Cubic (432 ms)\\n**C++**\\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    for (int i = 0; i < n; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int k = 0;\\n            while (k < n && g[i][k] == g[k][j])\\n                ++k;\\n            res += k == n;\\n        }\\n    return res;\\n}\\n```\\n\\n#### Three Map (95 ms)\\nNote that we need to use a three map (ordered map) instead of hash map. For a vector, the three map stops matching when bumps into a discrepancy, while hash map process all elements first to compute a hash.\\n\\nNote how we optimize the memory usage here. To check if a row exists in map, we are using existing rows. That way, we do not build an entire vector only to find out we have a mismatch on the first element.\\n\\n**C++**\\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    map<vector<int>, int> m;\\n    for (int j = 0; j < n; ++j) {\\n        vector<int> col;\\n        for (int i = 0; i < n; ++i)\\n            col.push_back(g[i][j]);\\n        auto it = m.find(col);\\n        if (it == end(m))\\n            m.emplace(move(col), 1);\\n        else\\n            ++it->second;\\n    }\\n    for (const auto &row : g)\\n        res += m[row];\\n    return res;\\n}\\n```\\n\\n#### Trie (137 ms)\\nThis is similar to the Three Map solution above, but here we build it ourselves.\\n\\nFirst, we populate Trie for columns, and then count matching rows.\\n\\n**C++**\\n```cpp\\nstruct Trie {\\n    unordered_map<int, Trie*> m;\\n    int cnt = 0;\\n    int insert(vector<vector<int>>& g, int i, int j, bool row) {\\n        auto node = this;\\n        for (; max(i, j) < g.size(); i += row, j += !row) {\\n            auto it = node->m.find(g[i][j]);\\n            if (it == end(node->m)) {\\n                if (row)\\n                    return 0; // no match.\\n                it = node->m.insert({g[i][j], new Trie()}).first;\\n            }\\n            node = it->second;\\n        }\\n        return node->cnt += !row;\\n    }\\n};\\nint equalPairs(vector<vector<int>>& g) {\\n    Trie t;\\n    int res = 0;\\n    for (int i = 0; i < g.size(); ++i)\\n        t.insert(g, i, 0, false);\\n    for (int j = 0; j < g.size(); ++j)\\n        res += t.insert(g, 0, j, true);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    for (int i = 0; i < n; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            int k = 0;\\n            while (k < n && g[i][k] == g[k][j])\\n                ++k;\\n            res += k == n;\\n        }\\n    return res;\\n}\\n```\n```cpp\\nint equalPairs(vector<vector<int>>& g) {\\n    int res = 0, n = g.size();\\n    map<vector<int>, int> m;\\n    for (int j = 0; j < n; ++j) {\\n        vector<int> col;\\n        for (int i = 0; i < n; ++i)\\n            col.push_back(g[i][j]);\\n        auto it = m.find(col);\\n        if (it == end(m))\\n            m.emplace(move(col), 1);\\n        else\\n            ++it->second;\\n    }\\n    for (const auto &row : g)\\n        res += m[row];\\n    return res;\\n}\\n```\n```cpp\\nstruct Trie {\\n    unordered_map<int, Trie*> m;\\n    int cnt = 0;\\n    int insert(vector<vector<int>>& g, int i, int j, bool row) {\\n        auto node = this;\\n        for (; max(i, j) < g.size(); i += row, j += !row) {\\n            auto it = node->m.find(g[i][j]);\\n            if (it == end(node->m)) {\\n                if (row)\\n                    return 0; // no match.\\n                it = node->m.insert({g[i][j], new Trie()}).first;\\n            }\\n            node = it->second;\\n        }\\n        return node->cnt += !row;\\n    }\\n};\\nint equalPairs(vector<vector<int>>& g) {\\n    Trie t;\\n    int res = 0;\\n    for (int i = 0; i < g.size(); ++i)\\n        t.insert(g, i, 0, false);\\n    for (int j = 0; j < g.size(); ++j)\\n        res += t.insert(g, 0, j, true);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3630812,
                "title": "java-c-python-easy-to-understand",
                "content": "# Guys Please Vote up )):\\nTo solve this problem, we can iterate through each row and column of the grid and check if they contain the same elements in the same order. If they do, we increment a counter. Finally, we return the value of the counter.\\n\\n# Approach\\nHere\\'s the approach to solve the problem:\\n\\n    Initialize a variable count to 0 to keep track of the number of equal row-column pairs.\\n    Iterate through each row ri from 0 to n-1:\\n    a. Iterate through each column cj from 0 to n-1:\\n    i. Check if the row ri and column cj are equal by comparing the corresponding elements.\\n    ii. If they are equal, increment the count variable by 1.\\n    Return the value of count.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n^3) because we have three nested loops: one for iterating through rows, one for iterating through columns, and one for comparing the elements. \\n\\n- Space complexity:\\nThe space complexity is O(1) since we are using a constant amount of extra space.\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int pair=0;\\n        int temp=0;\\n        int row=0;\\n        while(temp<=grid.length-1)\\n        {\\n            HashMap<Integer,Integer> map=new HashMap<>();\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                map.put(j,grid[row][j]);\\n            }\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                int curr=0;\\n                for(int k=0;k<grid.length;k++)\\n                {\\n                    if(map.get(k)!=grid[k][i])\\n                    {\\n                        curr=0;\\n                        break;\\n                    }\\n                    else\\n                        curr=1;\\n                }\\n                pair+=curr;\\n            }\\n            row++;\\n            temp++;\\n        }\\n        return pair;\\n    }\\n}\\n```\\n# C++ Code\\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python3 Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int pair=0;\\n        int temp=0;\\n        int row=0;\\n        while(temp<=grid.length-1)\\n        {\\n            HashMap<Integer,Integer> map=new HashMap<>();\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                map.put(j,grid[row][j]);\\n            }\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                int curr=0;\\n                for(int k=0;k<grid.length;k++)\\n                {\\n                    if(map.get(k)!=grid[k][i])\\n                    {\\n                        curr=0;\\n                        break;\\n                    }\\n                    else\\n                        curr=1;\\n                }\\n                pair+=curr;\\n            }\\n            row++;\\n            temp++;\\n        }\\n        return pair;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328910,
                "title": "python3-3-lines-transpose-ctr-w-explanation-t-m-97-100",
                "content": "\\nConsider this grid for an example:\\n```\\n           grid = [[1,2,1,9]\\n                   [2,8,9,2]\\n                   [1,2,1,9]\\n                   [9,2,6,3]]\\n```    \\nHere\\'s the plan:\\n- Determine`tpse`, the transpose of`grid`(using`zip(*grid)`):\\n```\\n           tspe = [[1,2,1,9] \\n                   [2,8,2,2]\\n                   [1,9,1,6]\\n                   [9,2,9,3]]\\n```\\n- The problem now is to determine the pairs of identical rows, one row in `tpse`and the other in` grid`. We hash`grid`and`tspe`:\\n```\\n          Counter(tuple(grid)):\\n               {(1,2,1,9): 2, (2,8,9,2): 1, (9,2,6,3): 1}\\n \\n           Counter(zip(*grid)):\\n            {(1,2,1,9): 1, (2,8,2,2): 1, (1,9,1,6): 1, (9,2,9,3): 1}\\n```            \\n   \\u2022 Finally, we determine the number of pairs:\\n```\\n       (1,2,1,9): 2 and (1,2,1,9): 1    => 2x1 = 2\\n```\\nHere\\'s the code:\\n```\\nclass Solution:                                \\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        tpse = Counter(zip(*grid))                  # <-- determine the transpose\\n                                                    #     and hash the rows\\n\\n        grid = Counter(map(tuple,grid))             # <-- hash the rows of grid. (Note the tuple-map, so\\n                                                    #     we can compare apples w/ apples in next step.)\\n\\n        return  sum(tpse[t]*grid[t] for t in tpse)  # <-- compute the number of identical pairs\\n```\\n[https://leetcode.com/problems/equal-row-and-column-pairs/submissions/939711156/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~ `len(grid)`.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n           grid = [[1,2,1,9]\\n                   [2,8,9,2]\\n                   [1,2,1,9]\\n                   [9,2,6,3]]\\n```\n```\\n           tspe = [[1,2,1,9] \\n                   [2,8,2,2]\\n                   [1,9,1,6]\\n                   [9,2,9,3]]\\n```\n```\\n          Counter(tuple(grid)):\\n               {(1,2,1,9): 2, (2,8,9,2): 1, (9,2,6,3): 1}\\n \\n           Counter(zip(*grid)):\\n            {(1,2,1,9): 1, (2,8,2,2): 1, (1,9,1,6): 1, (9,2,9,3): 1}\\n```\n```\\n       (1,2,1,9): 2 and (1,2,1,9): 1    => 2x1 = 2\\n```\n```\\nclass Solution:                                \\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        tpse = Counter(zip(*grid))                  # <-- determine the transpose\\n                                                    #     and hash the rows\\n\\n        grid = Counter(map(tuple,grid))             # <-- hash the rows of grid. (Note the tuple-map, so\\n                                                    #     we can compare apples w/ apples in next step.)\\n\\n        return  sum(tpse[t]*grid[t] for t in tpse)  # <-- compute the number of identical pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324750,
                "title": "java-python-3-o-n-2-codes-w-brief-explanation-and-analysis",
                "content": "Count row hash values then traverse col hash values to count the required pairs.\\n\\n----\\n\\nConvert rows and cols into strings, then use them as hash values.\\n\\nNote: \\n`cnt.merge(Arrays.toString(row), 1, Integer::sum);` is same as \\n```java\\nString key = Arrays.toString(row);\\ncnt.put(key, 1 + cnt.getOrDefault(key, 0));\\n```\\n\\n`Arrays.toString(row)/value` is `key/value` binding of HashMap `cnt`;\\n\\n`Integer::sum` here means that the method `sum` of `Integer` is used to increase by `1` the `value` corresponding to `key`: `Arrays.toString(row)`. The default `value` is `0` in case the `key` is absent.\\n\\n```java\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        for (int[] row : grid) {\\n            cnt.merge(Arrays.toString(row), 1, Integer::sum);\\n        }\\n        int pairs = 0;\\n        for (int c = 0, n = grid.length; c < n; ++c) {\\n            int[] col = new int[n];\\n            for (int r = 0; r < n; ++r) {\\n                col[r] = grid[r][c];\\n            }\\n            pairs += cnt.getOrDefault(Arrays.toString(col), 0);\\n        }\\n        return pairs;\\n    }\\n```\\n\\n----\\n\\nConvert the rows and cols into tuples, then use them as hash values.\\n\\n```python\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        pairs = 0\\n        cnt = Counter(tuple(row) for row in grid)\\n        for tpl in zip(*grid):\\n            pairs += cnt[tpl]\\n        return pairs\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n ^ 2)`, where `n = grid.length`.\\n\\n----\\n\\n**Q & A**\\n\\nQ: Can someone explain why do we need to convert it to tuple in python code ?\\nA: List is unhashable! can\\'t use as Key in dict and can\\'t store in set as value.\\nso... we need to convert it to tuple. -- Credit to **@I_and_Me**.\\n\\n**End of Q & A**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\nString key = Arrays.toString(row);\\ncnt.put(key, 1 + cnt.getOrDefault(key, 0));\\n```\n```java\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> cnt = new HashMap<>();\\n        for (int[] row : grid) {\\n            cnt.merge(Arrays.toString(row), 1, Integer::sum);\\n        }\\n        int pairs = 0;\\n        for (int c = 0, n = grid.length; c < n; ++c) {\\n            int[] col = new int[n];\\n            for (int r = 0; r < n; ++r) {\\n                col[r] = grid[r][c];\\n            }\\n            pairs += cnt.getOrDefault(Arrays.toString(col), 0);\\n        }\\n        return pairs;\\n    }\\n```\n```python\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        pairs = 0\\n        cnt = Counter(tuple(row) for row in grid)\\n        for tpl in zip(*grid):\\n            pairs += cnt[tpl]\\n        return pairs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3631209,
                "title": "c-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int r=0;\\n        vector<vector<int>>c=v;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(v[i][j],v[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i]==c[j])r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/d3301764-7132-4285-9a92-9f6415c050da_1686626781.0602562.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int r=0;\\n        vector<vector<int>>c=v;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(v[i][j],v[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i]==c[j])r++;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325191,
                "title": "java-two-pass-clean-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] g) {\\n\\t\\tint n = g.length;\\n        int res = 0;\\n\\t\\t//convert the numbers in each row to a single string\\n        Map<String, Integer> sToFreq = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = 0; j < n; j++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }\\n            String s = sb.toString();\\n            sToFreq.put(s, sToFreq.getOrDefault(s, 0) + 1);\\n        }\\n        \\n\\t\\t//convert the numbers in each col to string and find the matches\\n        for (int j = 0; j < n; j++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i = 0; i < n; i++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }\\n            String s = sb.toString();\\n            if (sToFreq.containsKey(s)) {\\n                res += sToFreq.get(s);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int equalPairs(int[][] g) {\\n\\t\\tint n = g.length;\\n        int res = 0;\\n\\t\\t//convert the numbers in each row to a single string\\n        Map<String, Integer> sToFreq = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = 0; j < n; j++) { \\n                sb.append(g[i][j]);\\n                sb.append(\"+\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3630977,
                "title": "c-map-fast-solution-w-explanation",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2*logn)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> counter;\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for (vector<int> row : grid) {\\n            counter[row] += 1;\\n        }\\n        for (int i = 0; i < row; i++) {\\n            vector<int> column_list = {};\\n            for (int j = 0; j < col; j++) {\\n                column_list.push_back(grid[j][i]);\\n            }\\n            ans += counter[column_list];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![ex1.jpg](https://assets.leetcode.com/users/images/41456c5f-1cde-4366-a7f6-74aec6f0f623_1686620000.3283463.jpeg)\\n# Step by Step\\n```\\nmap<vector<int>, int> counter;\\nfor (vector<int> row : grid) {\\n    counter[row] += 1;\\n}\\n```\\n- We use this to hold the value of each row as a key. To see if a column list is equal to the row key. Since we are comparing rows to columns only one needs to be the key\\n- Example of this for loop\\n    - counter[{3,2,1}] = 1;\\n    - counter[{1,7,6}] = 1;\\n    - counter[{2,7,7}] = 1;\\n\\n```        \\nfor (int i = 0; i < row; i++) {\\n    vector<int> column_list = {};\\n    for (int j = 0; j < col; j++) {\\n        column_list.push_back(grid[j][i]);\\n    }\\n    ans += counter[column_list];\\n}\\n```\\n- This is getting each list of column values. Since we do not have an array list of column values like row values, we need to create the list ourselves.\\n- Example\\n    - column_list = {3,1,2};\\n    - column_list = {2,7,7};\\n    - column_list = {1,6,7};\\n```\\nans += counter[column_list];\\n```\\n- Now take the values we just got and see if it matches the row keys we created.\\n- Example\\n    - counter[{3,1,2}] = 0;\\n    - counter[{2,7,7}] = 1;\\n    - counter[{1,6,7}] = 0;\\n- ans = 1\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> counter;\\n        int row = grid.size(), col = grid[0].size(), ans = 0;\\n        for (vector<int> row : grid) {\\n            counter[row] += 1;\\n        }\\n        for (int i = 0; i < row; i++) {\\n            vector<int> column_list = {};\\n            for (int j = 0; j < col; j++) {\\n                column_list.push_back(grid[j][i]);\\n            }\\n            ans += counter[column_list];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nmap<vector<int>, int> counter;\\nfor (vector<int> row : grid) {\\n    counter[row] += 1;\\n}\\n```\n```        \\nfor (int i = 0; i < row; i++) {\\n    vector<int> column_list = {};\\n    for (int j = 0; j < col; j++) {\\n        column_list.push_back(grid[j][i]);\\n    }\\n    ans += counter[column_list];\\n}\\n```\n```\\nans += counter[column_list];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781858,
                "title": "c-5-or-so-different-approaches-fast-54ms-100",
                "content": "<!---\\nTitle: C++ || a few different approaches with some variants || fast (54ms, 100%)\\nProblem: 2352\\nURL: \\n-->\\n\\nI had quite some fun solving this problem in a few different ways and trying some variants for different approaches. Please let me know if you have another idea or a suggestion for one of the approaches below.\\n\\n**TODO(heder): The complexity analysis isn\\'t complete for all of the approaches below.**\\n# Approach 1: nested loops (490ms)\\n\\nThe first approach is to just check each row against each column, which leads to $$O(n^3)$$ runtime.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t r = 0; r < n; ++r) {\\n            for (size_t c = 0; c < n; ++c) {\\n                bool equal = true;\\n                for (size_t i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        equal = false;\\n                        break;\\n                    }\\n                }\\n                ans += equal;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n@harsh_negi_07 posted a [neat variant of this idea](https://leetcode.com/problems/equal-row-and-column-pairs/discuss/2781858/c-5-or-so-different-approaches-fast-54ms-100) which is creating the column vectors and then just using ```std::count``` to compare against the rows of the ```grid```.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            ans += count(begin(grid), end(grid), column);\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: $$O(n^3)$$\\n  * Space Complexity: $$O(1)$$\\n\\n\\n# Approach 2: map of vectors (82ms)\\n\\nFirst we count the frequency of each row vector. Then we build a column vector and check in map how many matching row vectors we have got.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\nInstead of\\n\\n```cpp\\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n```\\n\\nwe could just do\\n\\n```cpp\\n            ans += m[column];\\n```\\n\\nwhich would be more compact code, however we would inserting the column vectors into the map as well which is unnecessary.\\n\\n**Complexity Analysis**\\n  * Time Complexity: TODO(heder): I need to think about this a bit more. We are inserting $$n$$ vectors into map and then we are looking up $$n$$ vectors in this map, but how expensive are these inserts and lookups?\\n  * Space Complexity: $$O(n^2)$$ for the map of vectors. We have up to $$n$$ row vectors and each of them is $$n$$ long. The column vector requires only $$n$$ space.\\n\\n\\n# Approach 3: hash map of std::string_view (54ms, 100%)\\n\\nFor approach 2 you are maybe wondering: Could we use ```std::unordered_map``` instead of  ```std::map```? Well, not out of the box, because the STL doesn\\'t define a hash function for a ```vector<int>```. Now what? One way to work around this is to treat the underlying raw data as the content of a ```std::string_view```. For ```std::string_view``` the STL defines a hash function. A ```std::vector``` guarantees that the underlying storage is contiguous so only the necessary ```reinterpret_cast<>``` makes it a big ugly, but other than that this should all be safe and sound and it\\'s fast.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        const size_t bytes = n * sizeof(int);\\n        unordered_map<string_view, int> m;\\n        for (const vector<int>& row : grid)\\n            ++m[string_view(reinterpret_cast<const char *>(row.data()), bytes)];\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(string_view(reinterpret_cast<const char *>(column.data()), bytes));\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n  * Time Complexity: TODO(heder): Think about this some more. $$O(n^2)$$ because we need to compute the hash for all rows and each of them is $$O(n)$$ long. The insert into the hash map should be $$O(1)$$, but if we have a hash collision we need to compare up to $$n$$ integers. Similar for the columns.\\n  * Space Complexity: $$O(n)$$ for the hash map. This isn\\'t $$O(n^2)$$ as we are only allocating a few bytes per row for the ```string_view```.\\n\\n\\n# Approach 4: hash map of vector with custom hash function (70ms)\\n\\nAnother approach to use a ```std::unordered_map``` here is to provide a custom hash function for ```std::vector<int>```. With the following setup code:\\n\\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n\\ntemplate<class T>\\nstruct std::hash<const vector<T>>\\n{\\n    std::size_t operator()(const vector<T>& v) const noexcept\\n    {\\n        std::size_t hash = size(v);\\n        for (const T& a : v) hash_combine(hash, a);\\n        return hash;\\n    }\\n};\\n```\\n\\nWe can use the same code for approach 2, but using ```std::unordered_map``` instead of ```std::map```.\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        unordered_map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n### Approach 5: only compute hashes (not 100% correct) (70ms)\\n\\n**WARNING:** This approach passes all test cases, but is not 100% correct as it doesn\\'t handle hash collisions.\\n\\nWe use the same ```hash_combine``` from the boost library:\\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n```\\n\\n... and then:\\n\\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        // NB. This approach is not 100% correct, as it doesn\\'t handle hash collisions.\\n        const size_t n = size(grid);\\n        unordered_map<size_t, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) {\\n            size_t hash = 0;\\n            for (int a : row) hash_combine(hash, a);\\n            ++m[hash];\\n        }\\n        int ans = 0;\\n        // Compute the hash for the column vector.\\n        for (size_t c = 0; c < n; ++c) {\\n            size_t hash = 0;\\n            for (size_t r = 0; r < n; ++r)\\n                hash_combine(hash, grid[r][c]);\\n            \\n            auto it = m.find(hash);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nIt\\'s basically the same as approach 3.\\n\\n# Approach 6: trie\\n\\nI saw a solution using a trie instead of a (hash) map. Time permitting I\\'ll give that a trie^Wtry too.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t r = 0; r < n; ++r) {\\n            for (size_t c = 0; c < n; ++c) {\\n                bool equal = true;\\n                for (size_t i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        equal = false;\\n                        break;\\n                    }\\n                }\\n                ans += equal;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```std::count```\n```grid```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            ans += count(begin(grid), end(grid), column);\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```cpp\\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n```\n```cpp\\n            ans += m[column];\\n```\n```std::unordered_map```\n```std::map```\n```vector<int>```\n```std::string_view```\n```std::string_view```\n```std::vector```\n```reinterpret_cast<>```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        const size_t bytes = n * sizeof(int);\\n        unordered_map<string_view, int> m;\\n        for (const vector<int>& row : grid)\\n            ++m[string_view(reinterpret_cast<const char *>(row.data()), bytes)];\\n        int ans = 0;\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(string_view(reinterpret_cast<const char *>(column.data()), bytes));\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```string_view```\n```std::unordered_map```\n```std::vector<int>```\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n\\ntemplate<class T>\\nstruct std::hash<const vector<T>>\\n{\\n    std::size_t operator()(const vector<T>& v) const noexcept\\n    {\\n        std::size_t hash = size(v);\\n        for (const T& a : v) hash_combine(hash, a);\\n        return hash;\\n    }\\n};\\n```\n```std::unordered_map```\n```std::map```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        const size_t n = size(grid);\\n        unordered_map<const vector<int>, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) ++m[row];\\n        int ans = 0;\\n        // Build the column vectors and check if we have matching row vectors\\n        // in the map.\\n        for (size_t c = 0; c < n; ++c) {\\n            vector<int> column;\\n            column.reserve(n);\\n            for (size_t r = 0; r < n; ++r)\\n                column.push_back(grid[r][c]);\\n            \\n            auto it = m.find(column);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```\n```hash_combine```\n```cpp\\n// from https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine\\ntemplate <class T>\\ninline void hash_combine(std::size_t& seed, const T& v)\\n{\\n    std::hash<T> hasher;\\n    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\\n}\\n```\n```cpp\\n    static int equalPairs(const vector<vector<int>>& grid) noexcept {\\n        // NB. This approach is not 100% correct, as it doesn\\'t handle hash collisions.\\n        const size_t n = size(grid);\\n        unordered_map<size_t, int> m;\\n        // Add each row vector to the map.\\n        for (const vector<int>& row : grid) {\\n            size_t hash = 0;\\n            for (int a : row) hash_combine(hash, a);\\n            ++m[hash];\\n        }\\n        int ans = 0;\\n        // Compute the hash for the column vector.\\n        for (size_t c = 0; c < n; ++c) {\\n            size_t hash = 0;\\n            for (size_t r = 0; r < n; ++r)\\n                hash_combine(hash, grid[r][c]);\\n            \\n            auto it = m.find(hash);\\n            if (it != end(m)) ans += it->second;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324850,
                "title": "cpp-easy-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                bool flag=true;\\n                for(int k=0;k<n;k++){\\n                    if(v[i][k]!=v[k][j]){\\n                        flag=false;break;\\n                    }\\n                }\\n                ans+=flag;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& v) {\\n        int n=v.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                bool flag=true;\\n                for(int k=0;k<n;k++){\\n                    if(v[i][k]!=v[k][j]){\\n                        flag=false;break;\\n                    }\\n                }\\n                ans+=flag;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324751,
                "title": "find-pairs-using-hashing-o-n-2-solution",
                "content": "**Similar Question** - [1814. Count Nice Pairs in an Array](https://leetcode.com/contest/biweekly-contest-49/problems/count-nice-pairs-in-an-array/)\\n\\nCollect the order in form of string in the map for every rows.\\nThen simply traverse every column, and count how many are there in map having same string configuration as current {That many pairs will be made}\\n# C++    \\n\\tint equalPairs(vector<vector<int>>& a) {\\n        int n= a.size(), res=0;\\n        unordered_map<string,int> mp;\\n\\t\\t //put in the map\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[i][j]) +\" \";\\n            mp[config]++;\\n        }\\n        //collect pairs\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[j][i]) +\" \";\\n            res+= mp[config];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Similar Question** - [1814. Count Nice Pairs in an Array](https://leetcode.com/contest/biweekly-contest-49/problems/count-nice-pairs-in-an-array/)\\n\\nCollect the order in form of string in the map for every rows.\\nThen simply traverse every column, and count how many are there in map having same string configuration as current {That many pairs will be made}\\n# C++    \\n\\tint equalPairs(vector<vector<int>>& a) {\\n        int n= a.size(), res=0;\\n        unordered_map<string,int> mp;\\n\\t\\t //put in the map\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[i][j]) +\" \";\\n            mp[config]++;\\n        }\\n        //collect pairs\\n        for(int i=0;i<n;i++){\\n            string config=\"\";\\n            for(int j=0;j<n;j++) config+= to_string(a[j][i]) +\" \";\\n            res+= mp[config];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3630895,
                "title": "beat-100-o-n-2-o-n-optimal-solution-art-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn my previous [solution](https://leetcode.com/problems/equal-row-and-column-pairs/solutions/3564106/beat-100-o-n-2-optimal-solution-true-hash-map/) I explained the basic way for solving this problem. However we needed to copy `vector`s around and that is very expensive. In this solution we are going to use a C++ technique to avoid the copying.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define a data type `RowOrColumn` that only takes reference to the actual data, not copying them. We then define our own equality operator and hash for it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\nWe no longer copies the data so the extra space needed is only $N$ rather than $N^2$.\\n\\n# Code\\n```\\n\\nstruct RowOrColumn {\\n  const vector<vector<int>>& grid;\\n  const bool is_row;\\n  const int offset;\\n\\n  // This data behaves as if it is a vector for reading.\\n  int operator[](int index) const {\\n    return is_row ? grid[offset][index] : grid[index][offset];\\n  }\\n\\n  bool operator==(const RowOrColumn& other) const {\\n    // We skip the size equality since here it\\'s always the same.\\n    for (int i = 0; i < size(); ++i) {\\n      if ((*this)[i] != other[i]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  int size() const {\\n    return grid.size();  // Row and column size should be the same.\\n  }\\n};\\n\\nstruct RangeHash {\\n  int operator()(const RowOrColumn& v) const {\\n    uint hash = 0;\\n    for(int i = 0; i < v.size(); ++i) {\\n        hash ^= v[i] + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<RowOrColumn, int, RangeHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      ++counts[RowOrColumn{.grid = grid, .is_row = false, .offset = c}];\\n    }\\n    int answer = 0;\\n    for (int r = 0; r < N; ++r) {\\n      answer += counts[RowOrColumn{.grid = grid, .is_row = true, .offset = r}];\\n    }\\n    return answer;\\n  }\\n};\\n```\\n\\n# Appendix: About the Hash Function.\\nIt is basically copied from the [boost `hash_combine`](https://www.boost.org/doc/libs/1_82_0/libs/container_hash/doc/html/hash.html#notes_hash_combine)\\n\\nIf you are wondering where this magic number `0x9e3779b9` comes from? It comes from the golden ratio:\\n$$\\n\\\\phi = \\\\frac{1 + \\\\sqrt{5}}{2} \\\\\\\\\\n\\\\frac{2^{32}}{\\\\phi} = \\\\text{0x9e3779b9}\\n$$",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n\\nstruct RowOrColumn {\\n  const vector<vector<int>>& grid;\\n  const bool is_row;\\n  const int offset;\\n\\n  // This data behaves as if it is a vector for reading.\\n  int operator[](int index) const {\\n    return is_row ? grid[offset][index] : grid[index][offset];\\n  }\\n\\n  bool operator==(const RowOrColumn& other) const {\\n    // We skip the size equality since here it\\'s always the same.\\n    for (int i = 0; i < size(); ++i) {\\n      if ((*this)[i] != other[i]) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  int size() const {\\n    return grid.size();  // Row and column size should be the same.\\n  }\\n};\\n\\nstruct RangeHash {\\n  int operator()(const RowOrColumn& v) const {\\n    uint hash = 0;\\n    for(int i = 0; i < v.size(); ++i) {\\n        hash ^= v[i] + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<RowOrColumn, int, RangeHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      ++counts[RowOrColumn{.grid = grid, .is_row = false, .offset = c}];\\n    }\\n    int answer = 0;\\n    for (int r = 0; r < N; ++r) {\\n      answer += counts[RowOrColumn{.grid = grid, .is_row = true, .offset = r}];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324649,
                "title": "java-hashmap",
                "content": "**Code:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n\\t\\tHashMap<String, Integer> y = new HashMap<>();\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb1.append(grid[i][j]);\\n                sb2.append(grid[j][i]);\\n                sb1.append(\\',\\'); sb2.append(\\',\\');\\n            }\\n            String curr1 = sb1.toString(), curr2 = sb2.toString();\\n            x.put(curr1, x.getOrDefault(curr1, 0)+1);\\n            y.put(curr2, y.getOrDefault(curr2, 0)+1);\\n        }\\n        \\n        for(String str : x.keySet())\\n            if(y.containsKey(str))\\n                res += x.get(str)*y.get(str);\\n        return res;\\n    }\\n\\t\\n**Single Map, two loops:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[i][j]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            x.put(curr, x.getOrDefault(curr, 0) +1);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            if(x.containsKey(curr))\\n                res += x.get(curr);\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "**Code:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n\\t\\tHashMap<String, Integer> y = new HashMap<>();\\n\\t\\t\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb1 = new StringBuilder(), sb2 = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb1.append(grid[i][j]);\\n                sb2.append(grid[j][i]);\\n                sb1.append(\\',\\'); sb2.append(\\',\\');\\n            }\\n            String curr1 = sb1.toString(), curr2 = sb2.toString();\\n            x.put(curr1, x.getOrDefault(curr1, 0)+1);\\n            y.put(curr2, y.getOrDefault(curr2, 0)+1);\\n        }\\n        \\n        for(String str : x.keySet())\\n            if(y.containsKey(str))\\n                res += x.get(str)*y.get(str);\\n        return res;\\n    }\\n\\t\\n**Single Map, two loops:**\\n\\n    public int equalPairs(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        HashMap<String, Integer> x = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[i][j]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            x.put(curr, x.getOrDefault(curr, 0) +1);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j=0; j<n; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\\',\\');\\n            }\\n            String curr = sb.toString();\\n            if(x.containsKey(curr))\\n                res += x.get(curr);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3035336,
                "title": "easy-concise-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const rows = grid.map(arr => arr.join())\\n    const columns = grid[0].map((col, i) => grid.map(row => row[i]).join())\\n    let count = 0\\n    for (let row of rows) {\\n        for (let column of columns) {\\n            if (row === column) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const rows = grid.map(arr => arr.join())\\n    const columns = grid[0].map((col, i) => grid.map(row => row[i]).join())\\n    let count = 0\\n    for (let row of rows) {\\n        for (let column of columns) {\\n            if (row === column) count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3631869,
                "title": "c-easy-explanation-maps",
                "content": "# Approach\\nStoring Rows as KEY in Hashmaps\\nChecking through each Column to find Similar rows \\nIf found add the Freq of Row\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // Taking rows as key and storing it\\'s frequency\\n        for(int i =0; i<m; i++){\\n            mp[grid[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        // Checking Columns with already present Rows\\n        for(int j = 0; j<n; j++){\\n            vector<int> col;\\n            for(int i = 0; i<m; i++){\\n                col.push_back(grid[i][j]);\\n            }\\n\\n            if(mp[col]>0) ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        // Taking rows as key and storing it\\'s frequency\\n        for(int i =0; i<m; i++){\\n            mp[grid[i]]++;\\n        }\\n        \\n        int ans = 0;\\n        // Checking Columns with already present Rows\\n        for(int j = 0; j<n; j++){\\n            vector<int> col;\\n            for(int i = 0; i<m; i++){\\n                col.push_back(grid[i][j]);\\n            }\\n\\n            if(mp[col]>0) ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325190,
                "title": "count-the-array-column-wise-c-easiest-solution",
                "content": "***Find the transpose of matrix and count the number of equal arrays***\\n***Given Matrix Grid is Treated as Row-Wise***\\n***Transpose Matrix T is treated as Colmun-Wise***\\n\\n***Example***\\n***Grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]***\\nRow-wise (same as Given)\\n3  1  2  2 \\n1  4  4  5 \\n2  4  2  2 \\n2  4  2  2\\n\\nColumn-wise (Transpose of matrix , For explaination)\\n3  1  2  2 \\n1  4  4  4 \\n2  4  2  2 \\n2  5  2  2  \\n\\n***Iterate in Grid and make a array COLUMN-WISE of grid in each iteration***\\n\\n***1st iteration we get -> 3 1 2 2***\\nCount its occurrences in Grid -> 1\\n***2nd iteration we get -> 1 4 4 4***\\ncount its occurrences in Grid -> 0\\n***3rd iteration we get ->2 4 2 2***\\ncount its occurrences in Grid -> 2\\n***4th iteration we get ->2 5 2 2***\\ncount its occurrences in Grid -> 0\\n\\n***Final Answer = 3***\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int i = 0; i < grid.size(); i++) {\\n            vector<int> T;\\n            for (int j = 0; j < grid.size(); j++) {\\n                T.push_back(grid[j][i]);\\n            }\\n            ans += count(begin(grid), end(grid), T);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int i = 0; i < grid.size(); i++) {\\n            vector<int> T;\\n            for (int j = 0; j < grid.size(); j++) {\\n                T.push_back(grid[j][i]);\\n            }\\n            ans += count(begin(grid), end(grid), T);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630850,
                "title": "hash-table-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we are given a `0-indexed` `n x n` integer matrix grid, we want to `return the number of pairs (ri, cj)` such that `row ri` and `column cj` are `equal`.\\n\\n### Explanation\\n\\nThis problem basically wants us to traverse through the matrix and check which row and columns contains the same pair values and then increment our counter once found.\\n\\nTo do that, we can traverse through our matrix row and use `hash table` to first store the frequencies of each row, converting each row into string representation to create unique keys using `tuple` or `JSON.stringify()` to make it hashable\\n\\nWe then traverse over each column of our matrix, and for each column, we create a string representation by extracting the elements from that current column using `lists`.\\n\\nAfter extracting the current column, we now check if it exists in our hash table. If so, we increment count by its frequency\\n\\nBy using `hash table`, all we need to do is iterate over each row and column once\\n\\n\\n# Code\\n\\n**Python**\\n\\n```   \\ndef equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        count = 0\\n        rows = {}\\n\\n        for r in range(n):\\n            row = tuple(grid[r])\\n            rows[row]= 1 + rows.get(row, 0)\\n        \\n        for c in range(n):\\n            col = tuple(grid[i][c] for i in range(n))\\n            count += rows.get(col, 0)\\n            \\n        return count``\\n\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n\\n    const n = grid.length\\n    let count = 0\\n    const rows = new Map()\\n\\n    for(let r = 0; r < n; r++){\\n        const row = JSON.stringify(grid[r])\\n        rows.set(row, 1 + (rows.get(row) || 0))\\n    }\\n\\n    for(let c = 0; c < n; c++){\\n        const col = JSON.stringify(grid.map(row => row[c]))\\n        count += (rows.get(col) || 0)\\n    }\\n    \\n    return count\\n};\\n```\\n### Time Complexity: `O(n^2)`\\n### Space Complexity: `O(n^2)`\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```   \\ndef equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        count = 0\\n        rows = {}\\n\\n        for r in range(n):\\n            row = tuple(grid[r])\\n            rows[row]= 1 + rows.get(row, 0)\\n        \\n        for c in range(n):\\n            col = tuple(grid[i][c] for i in range(n))\\n            count += rows.get(col, 0)\\n            \\n        return count``\\n\\n```\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n\\n    const n = grid.length\\n    let count = 0\\n    const rows = new Map()\\n\\n    for(let r = 0; r < n; r++){\\n        const row = JSON.stringify(grid[r])\\n        rows.set(row, 1 + (rows.get(row) || 0))\\n    }\\n\\n    for(let c = 0; c < n; c++){\\n        const col = JSON.stringify(grid.map(row => row[c]))\\n        count += (rows.get(col) || 0)\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2325049,
                "title": "dont-think-too-much",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int row = grid.length;\\n        int col = grid.length;\\n        for(int i = 0; i < row; i++){\\n            String res = \"\";\\n            for(int j = 0; j < col; j++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            map.put(res, map.getOrDefault(res, 0) + 1);\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < col; j++){\\n            String res = \"\";\\n            for(int i = 0; i < row; i++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            cnt += map.getOrDefault(res, 0);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String, Integer> map = new HashMap<>();\\n        int row = grid.length;\\n        int col = grid.length;\\n        for(int i = 0; i < row; i++){\\n            String res = \"\";\\n            for(int j = 0; j < col; j++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            map.put(res, map.getOrDefault(res, 0) + 1);\\n        }\\n        int cnt = 0;\\n        for(int j = 0; j < col; j++){\\n            String res = \"\";\\n            for(int i = 0; i < row; i++){\\n                res += \"-\" + grid[i][j];\\n            }\\n            cnt += map.getOrDefault(res, 0);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633511,
                "title": "simple-java-solution-hashmap-easy-to-understand-3-ms-beats-99",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length,c = 0;\\n        HashMap<Long,Integer> h = new  HashMap<Long,Integer>();\\n        for(int i=0;i<n;i++){\\n            long t1 = 0;\\n            for(int j=0;j<n;j++) t1 = t1 * 10 + grid[i][j];\\n            h.put(t1,h.getOrDefault(t1,0) + 1);\\n        }\\n        for(int i=0;i<n;i++){\\n            long t2 = 0;\\n            for(int j=0;j<n;j++) t2 = t2 * 10 + grid[j][i];\\n            c += h.getOrDefault(t2,0);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length,c = 0;\\n        HashMap<Long,Integer> h = new  HashMap<Long,Integer>();\\n        for(int i=0;i<n;i++){\\n            long t1 = 0;\\n            for(int j=0;j<n;j++) t1 = t1 * 10 + grid[i][j];\\n            h.put(t1,h.getOrDefault(t1,0) + 1);\\n        }\\n        for(int i=0;i<n;i++){\\n            long t2 = 0;\\n            for(int j=0;j<n;j++) t2 = t2 * 10 + grid[j][i];\\n            c += h.getOrDefault(t2,0);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631261,
                "title": "best-c-solution-map-fully-optimized-possible-solution",
                "content": "# Approach\\n- The function initializes an integer variable \"ans\" to zero and a map called \"mp\" with vector<int> as its key and integer as its value.\\n\\n- The first for loop iterates through the rows of the \"grid\" and increments the value of the corresponding key in the map \"mp\" by 1.\\n\\n- The second for loop iterates through the columns of the \"grid\". For each column, it creates a new vector called \"v\" and fills it with the values of that column. It then adds the value of the corresponding key in the map \"mp\" to the variable \"ans\".\\n\\n- Finally, the function returns the value of \"ans\".\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/18f3e1d4-778b-4148-bac1-580b6a4b2f6c_1686627741.015125.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324718,
                "title": "c-simple-solution",
                "content": "**Approach-1:** Compare each row with every column \\n**TC: O(N^3) SC: O(1)**\\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        int n=grid.size();\\n         \\n        for(int i=0; i<n; i++) //for row\\n        {\\n            for(int j=0; j<n; j++) //for column\\n            {\\n                for(int k=0; k<n; k++) //for comparing each row with every column\\n                {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    if(k==n-1) count++; //if row is totally equal to the column we increase the count\\n   \\n               }\\n            } \\n            \\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Approach-2:** Store row and its occurences in a hashmap. Then, store column in a vector and check whether that column is in the hashmap, if it is increase the count by its occurrences.\\n\\n**TC: O(N^2) SC: O(N^2)**\\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        map<vector<int> , int> mp;\\n        int n=grid.size();\\n        \\n        for(auto it:grid) //storing rows\\n            mp[it]++;\\n              \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++) \\n            {\\n                temp.push_back(grid[j][i]); //storing column\\n                \\n                if(mp[temp]) count += mp[temp]; //if row is totally equal to the column we increase the count\\n\\n           }\\n        } \\n           \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        int n=grid.size();\\n         \\n        for(int i=0; i<n; i++) //for row\\n        {\\n            for(int j=0; j<n; j++) //for column\\n            {\\n                for(int k=0; k<n; k++) //for comparing each row with every column\\n                {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    if(k==n-1) count++; //if row is totally equal to the column we increase the count\\n   \\n               }\\n            } \\n            \\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int count=0;\\n        map<vector<int> , int> mp;\\n        int n=grid.size();\\n        \\n        for(auto it:grid) //storing rows\\n            mp[it]++;\\n              \\n        for(int i=0; i<n; i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++) \\n            {\\n                temp.push_back(grid[j][i]); //storing column\\n                \\n                if(mp[temp]) count += mp[temp]; //if row is totally equal to the column we increase the count\\n\\n           }\\n        } \\n           \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631860,
                "title": "c-easy-explanation-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCertainly! Here\\'s the intuition behind my code in simpler terms:\\n\\n1. The code counts the occurrences of rows and columns in a grid using two maps: `pq` for rows and `col` for columns.\\n\\n2. It iterates over each row and increments its count in the `pq` map.\\n\\n3. It extracts the values of each column and stores them in the `col` map, incrementing their count.\\n\\n4. Then, it iterates over the rows and checks if the corresponding column exists in the `col` map.\\n\\n5. If a matching column is found, it calculates the count of equal pairs by multiplying the counts of the row and column.\\n\\n6. It adds this count to the total count of equal pairs.\\n\\n7. Finally, it returns the total count of equal pairs.\\n\\nThe code efficiently counts the occurrences of rows and columns and determines the count of equal pairs by comparing the maps.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> pq;  // Map to count occurrences of each row\\n        int n=grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            pq[grid[i]]++;  // Count occurrences of each row\\n        }\\n        \\n        map<vector<int>,int> col;  // Map to count occurrences of each column\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);  // Extracting column values and storing them in a vector\\n            }\\n            \\n            col[temp]++;  // Count occurrences of each column\\n        }\\n        \\n        int count=0;\\n        for(auto &i:pq)\\n        {\\n            if(col.find(i.first)!=col.end())  // Check if the column exists in the map\\n            {\\n                count += (i.second)* col[i.first];  // Calculate the count of equal pairs\\n            }\\n        }\\n        return count;  // Return the count of equal pairs\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> pq;  // Map to count occurrences of each row\\n        int n=grid.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            pq[grid[i]]++;  // Count occurrences of each row\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3630920,
                "title": "hashmap-solution-video-java-c-python",
                "content": "# Brute force and arriving at hashMap\\n1. Brute force: we can go through each row and column of the grid and see if they have the same elements in the same order. If they do, we increase the count. \\nThe problem with this approach is we will be checking twice for column with same values: eg 2, 5, 2, 2 occurs 2 times and we will be rechecking this. This can be avoided using a hashMap to store the row.\\n\\nStore each row as key in the hashMap i.e array 1,2,2,1 will be key and the value will be the count of 1,2,2,1 in rows\\n\\nIterate through the columns and increment the count by value if its Present in the hashMap.\\n\\n\\n# Appoach.\\n1. Create hashMap <String, Integer> hashMap.\\nwhy String?? As array hash is based on reference we convert it to string and store.\\n2. For each row in grid. convert row to String and store in hashMap. increase count if already existing.\\n3. For every column convert the col to String and check if present in hashMap, incerase the ans by value in hashMap.\\n4. return count\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/pcH-Ym3EWLU\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> hashMap = new HashMap<String, Integer>();\\n        for(int [] row: grid){\\n            String rowStr = Arrays.toString(row);\\n            hashMap.put(rowStr, hashMap.getOrDefault(rowStr,0)+1);\\n        }\\n        \\n        int count = 0;\\n        for(int j = 0;j<n;j++){\\n            int [] col = new int[n];\\n            for(int i = 0;i<n;i++){\\n                col[i] = grid[i][j];\\n            }\\n            count+=hashMap.getOrDefault(Arrays.toString(col),0);\\n        }\\n        return count;\\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(std::vector<std::vector<int>>& grid) {\\n        int n = grid.size();\\n        std::unordered_map<std::string, int> hashMap;\\n        \\n        for (std::vector<int>& row : grid) {\\n            std::string rowStr = vectorToString(row);\\n            hashMap[rowStr]++;\\n        }\\n        \\n        int count = 0;\\n        for (int j = 0; j < n; j++) {\\n            std::vector<int> col(n);\\n            for (int i = 0; i < n; i++) {\\n                col[i] = grid[i][j];\\n            }\\n            std::string colStr = vectorToString(col);\\n            count += hashMap[colStr];\\n        }\\n        \\n        return count;\\n    }\\n    \\nprivate:\\n    std::string vectorToString(std::vector<int>& vec) {\\n        std::string str;\\n        str += \\'[\\';\\n        for (int i = 0; i < vec.size(); i++) {\\n            if (i > 0) {\\n                str += \\',\\';\\n            }\\n            str += std::to_string(vec[i]);\\n        }\\n        str += \\']\\';\\n        return str;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        hashMap = defaultdict(int)\\n        \\n        for row in grid:\\n            rowStr = str(row)\\n            hashMap[rowStr] += 1\\n        \\n        count = 0\\n        for j in range(n):\\n            col = [grid[i][j] for i in range(n)]\\n            colStr = str(col)\\n            count += hashMap[colStr]\\n        \\n        return count\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> hashMap = new HashMap<String, Integer>();\\n        for(int [] row: grid){\\n            String rowStr = Arrays.toString(row);\\n            hashMap.put(rowStr, hashMap.getOrDefault(rowStr,0)+1);\\n        }\\n        \\n        int count = 0;\\n        for(int j = 0;j<n;j++){\\n            int [] col = new int[n];\\n            for(int i = 0;i<n;i++){\\n                col[i] = grid[i][j];\\n            }\\n            count+=hashMap.getOrDefault(Arrays.toString(col),0);\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(std::vector<std::vector<int>>& grid) {\\n        int n = grid.size();\\n        std::unordered_map<std::string, int> hashMap;\\n        \\n        for (std::vector<int>& row : grid) {\\n            std::string rowStr = vectorToString(row);\\n            hashMap[rowStr]++;\\n        }\\n        \\n        int count = 0;\\n        for (int j = 0; j < n; j++) {\\n            std::vector<int> col(n);\\n            for (int i = 0; i < n; i++) {\\n                col[i] = grid[i][j];\\n            }\\n            std::string colStr = vectorToString(col);\\n            count += hashMap[colStr];\\n        }\\n        \\n        return count;\\n    }\\n    \\nprivate:\\n    std::string vectorToString(std::vector<int>& vec) {\\n        std::string str;\\n        str += \\'[\\';\\n        for (int i = 0; i < vec.size(); i++) {\\n            if (i > 0) {\\n                str += \\',\\';\\n            }\\n            str += std::to_string(vec[i]);\\n        }\\n        str += \\']\\';\\n        return str;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        hashMap = defaultdict(int)\\n        \\n        for row in grid:\\n            rowStr = str(row)\\n            hashMap[rowStr] += 1\\n        \\n        count = 0\\n        for j in range(n):\\n            col = [grid[i][j] for i in range(n)]\\n            colStr = str(col)\\n            count += hashMap[colStr]\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342273,
                "title": "java-simple-solution-100-fast",
                "content": "I have seen many solutions using hashmap, but we can easily solve this question without complex approach.\\n1) Transpose the matrix\\n2) Iterate through grid, and check for matching cols.\\n\\nTC : `O( N x N) `\\nSpace : `O( N x N) `\\n\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] transpose = new int[m][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                //Transpose of matrix\\n                transpose[j][i] = grid[i][j];\\n            }\\n        }\\n        int ans = 0;\\n        for(int[] row : grid){\\n            for(int[] col : transpose){\\n                //Check for equality\\n                if(Arrays.equals(row, col)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] transpose = new int[m][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                //Transpose of matrix\\n                transpose[j][i] = grid[i][j];\\n            }\\n        }\\n        int ans = 0;\\n        for(int[] row : grid){\\n            for(int[] col : transpose){\\n                //Check for equality\\n                if(Arrays.equals(row, col)) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325162,
                "title": "python-2-line-solution",
                "content": "# **Explanation**\\nFirst, Counts all columns frequency.\\nSedcone, iterate rows and accumulate the number of same.\\n<br>\\n\\n# **Complexity**\\nTime `O(n * n)`\\nSpace `O(n * n)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def equalPairs(self, A):\\n        count = Counter(zip(*A))\\n        return sum(count[tuple(r)] for r in A)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def equalPairs(self, A):\\n        count = Counter(zip(*A))\\n        return sum(count[tuple(r)] for r in A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3631774,
                "title": "c-easy-solution-hash-table",
                "content": "# Intuition\\nWe need to count the pairs of same rows and columns. We can make use of map.\\n\\n# Approach\\nLet us initialise map of vector to int which stores the frequency of a row vector.\\n**map<vector<int>,int>mppr**\\n\\nFirst for every row store the frequency of the row vector.\\n\\nNow for every column vector add the frequency of that vector to ans from mppr.\\n\\nFinally return ans.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2logn)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mppr;\\n        int ans = 0;\\n        int n = grid.size();\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n            mppr[temp]++;\\n        }\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans+=mppr[temp];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mppr;\\n        int ans = 0;\\n        int n = grid.size();\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n            mppr[temp]++;\\n        }\\n        for(int i = 0;i<n;i++){\\n            vector<int>temp;\\n            for(int j = 0;j<n;j++){\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans+=mppr[temp];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537821,
                "title": "c-trie-try-new-approach-easy",
                "content": "---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---\\n# Code\\n```\\nclass Trie {\\npublic:\\n    int endCount = 0;\\n    map<int, Trie*> mp;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        Trie* orig_trie = new Trie();\\n        int n = grid.size();\\n\\n        // Add rows of the matrix in the trie\\n        for(int i = 0; i<n; i++){\\n            Trie* temp_trie = orig_trie;\\n            for(int j = 0; j<n; j++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    temp_trie->mp[grid[i][j]] = new Trie();\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            temp_trie->endCount += 1;\\n        }\\n\\n        int ans = 0;\\n        // Traverse all the columns of the matrix in the trie\\n        for(int j = 0; j<n; j++){\\n            Trie* temp_trie = orig_trie;\\n            for(int i = 0; i<n; i++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    break;\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            ans += temp_trie->endCount;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n---\\n\\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Trie",
                    "Matrix"
                ],
                "code": "```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\n```\\nclass Trie {\\npublic:\\n    int endCount = 0;\\n    map<int, Trie*> mp;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        Trie* orig_trie = new Trie();\\n        int n = grid.size();\\n\\n        // Add rows of the matrix in the trie\\n        for(int i = 0; i<n; i++){\\n            Trie* temp_trie = orig_trie;\\n            for(int j = 0; j<n; j++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    temp_trie->mp[grid[i][j]] = new Trie();\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            temp_trie->endCount += 1;\\n        }\\n\\n        int ans = 0;\\n        // Traverse all the columns of the matrix in the trie\\n        for(int j = 0; j<n; j++){\\n            Trie* temp_trie = orig_trie;\\n            for(int i = 0; i<n; i++){\\n                if(temp_trie->mp.find(grid[i][j]) == temp_trie->mp.end())\\n                    break;\\n                \\n                temp_trie = temp_trie->mp[grid[i][j]];\\n            }\\n\\n            ans += temp_trie->endCount;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448832,
                "title": "python-simple-clean-code-3-solutions",
                "content": "# Code\\n\\n## Using Numpy - having bad TC\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        grid = np.array(grid)\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if all( [ a == b for a, b in zip( grid[i], grid[:,j] ) ] ):\\n                    cnt+=1\\n        return cnt\\n```\\n\\n## using Dictionary - Better TC\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n```\\n\\n## Best of 3\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[tuple(row)] += 1\\n        \\n        for col in zip(*grid):\\n            cnt += m[tuple(col)]\\n            \\n        return cnt\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        grid = np.array(grid)\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if all( [ a == b for a, b in zip( grid[i], grid[:,j] ) ] ):\\n                    cnt+=1\\n        return cnt\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[str(row)] += 1\\n        \\n        for i in range(len(grid[0])):\\n            col = []\\n            for j in range(len(grid)):\\n                col.append(grid[j][i])\\n            cnt += m[str(col)]\\n        return cnt\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        m = defaultdict(int)\\n        cnt = 0\\n\\n        for row in grid:\\n            m[tuple(row)] += 1\\n        \\n        for col in zip(*grid):\\n            cnt += m[tuple(col)]\\n            \\n        return cnt\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2643204,
                "title": "python-elegant-short-o-n-3-vs-o-n-2-hashing",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^3)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        pairs = 0\\n\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    if grid[i][k] != grid[k][j]:\\n                        break\\n                else:\\n                    pairs += 1\\n\\n        return pairs\\n```\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mp = defaultdict(int)\\n\\n        for col in zip(*grid):\\n            mp[self.serialize(col)] += 1\\n\\n        return sum(mp[self.serialize(row)] for row in grid)\\n\\n    @staticmethod\\n    def serialize(nums: Generator) -> str:\\n        return \\',\\'.join(map(str, nums))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^3)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        pairs = 0\\n\\n        for i in range(n):\\n            for j in range(n):\\n                for k in range(n):\\n                    if grid[i][k] != grid[k][j]:\\n                        break\\n                else:\\n                    pairs += 1\\n\\n        return pairs\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n^2)\\n    Memory: O(n)\\n    \"\"\"\\n\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mp = defaultdict(int)\\n\\n        for col in zip(*grid):\\n            mp[self.serialize(col)] += 1\\n\\n        return sum(mp[self.serialize(row)] for row in grid)\\n\\n    @staticmethod\\n    def serialize(nums: Generator) -> str:\\n        return \\',\\'.join(map(str, nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324846,
                "title": "easy-solution-using-transpose-of-the-matrix",
                "content": "```\\n\\tpublic int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n\\tpublic int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2324684,
                "title": "c-simple-commented-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int cnt = 0;\\n        int n = grid.size();\\n        \\n        for(int i=0;i<n;i++)           // over row\\n        {\\n            for(int j=0;j<n;j++)       // over col\\n            {\\n                for(int k=0;k<n;k++)\\n                {\\n                    // cheking the gird(row,col) == grid(col,row)\\n                    if(grid[i][k]!=grid[k][j])\\n                        break;\\n                    \\n                    // if we have all value same in col & row then increase the count by 1\\n                    if(k==n-1)\\n                        cnt++;\\n                }\\n            }   \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int cnt = 0;\\n        int n = grid.size();\\n        \\n        for(int i=0;i<n;i++)           // over row\\n        {\\n            for(int j=0;j<n;j++)       // over col\\n            {\\n                for(int k=0;k<n;k++)\\n                {\\n                    // cheking the gird(row,col) == grid(col,row)\\n                    if(grid[i][k]!=grid[k][j])\\n                        break;\\n                    \\n                    // if we have all value same in col & row then increase the count by 1\\n                    if(k==n-1)\\n                        cnt++;\\n                }\\n            }   \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633109,
                "title": "easiest-faang-method-ever",
                "content": "# Intuition\\nTo count the number of pairs (ri, cj) such that row ri and column cj are equal, we need to iterate over each row and column pair and check if they contain the same elements in the same order. If they do, we increment a counter.\\n# Approach\\n\\n1. Initialize a variable `count` to 0 to keep track of the number of equal row-column pairs.\\n2. Iterate over each row `ri` in the range [0, n), where `len` is the size of the grid.\\n    - Inside the outer loop, iterate over each column `cj` in the range [0, len).\\n        - Inside the inner loop, check if the row `ri` and column `cj` in the grid are equal by comparing the elements of the corresponding row and column.\\n        - If the row and column are equal, increment the `count` variable.\\n3. After the loops finish, return the value of `count` as the result.\\n\\n# Complexity\\n- Time complexity:\\n\\nThe solution uses three nested loops: one for iterating over the rows, one for iterating over the columns, and one for comparing the elements of the row and column. The time complexity is \\'**O(n^3)**\\', where n is the size of the grid. In the worst case, when n is large, the time complexity can be considered cubic.\\n\\n- Space complexity:\\n\\nThe solution uses a constant amount of extra space for variables. Hence, the space complexity is **\\'O(1)\\'**.\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        int count = 0;\\n\\n        for (int ri = 0; ri < len; ri++) {\\n            for (int cj = 0; cj < len; cj++) {\\n                boolean isEqual = true;\\n\\n                for (int i = 0; i < len; i++) {\\n                    if (grid[ri][i] != grid[i][cj]) {\\n                        isEqual = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (isEqual) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        int count = 0;\\n\\n        for (int ri = 0; ri < len; ri++) {\\n            for (int cj = 0; cj < len; cj++) {\\n                boolean isEqual = true;\\n\\n                for (int i = 0; i < len; i++) {\\n                    if (grid[ri][i] != grid[i][cj]) {\\n                        isEqual = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (isEqual) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632741,
                "title": "c-solution-with-explanatory-comments-o-n-2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   string Mapfun(vector<int>&nums){\\n       string temp = \"\";\\n       for(auto it:nums){\\n           temp += to_string(it) + \"$\";\\n          //adding \"$\" between each number to make it unique string\\n          //for Ex- nums = [11,1] and nums= [1,11] will be identical if we will not seprate them with \"$\"\\n       } \\n       return temp;\\n   }\\n    int equalPairs(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n = grid.size();\\n      unordered_map<string,int>mp;\\n    \\n     //mapping with the help of Map function which convert rows in unique strings\\n      for(int i=0;i<n;i++){\\n          mp[Mapfun(grid[i])]++;\\n      } \\n       \\n       for(int i=0;i<n;i++){\\n           string search = \"\";\\n           for(int j=0;j<n;j++){\\n               //also converting coulumn same as row\\n               search += to_string(grid[j][i]) + \"$\";\\n               //note that we used grid[j][i] to traverse in coulumn\\n           }\\n          //just search in map if it is present then add the corresponding value in ans\\n          ans += mp[search];\\n       }\\n      return ans;\\n    }\\n};\\n```\\n**Please Upvote if helpful**",
                "solutionTags": [
                    "C++",
                    "String",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string Mapfun(vector<int>&nums){\\n       string temp = \"\";\\n       for(auto it:nums){\\n           temp += to_string(it) + \"$\";\\n          //adding \"$\" between each number to make it unique string\\n          //for Ex- nums = [11,1] and nums= [1,11] will be identical if we will not seprate them with \"$\"\\n       } \\n       return temp;\\n   }\\n    int equalPairs(vector<vector<int>>& grid) {\\n      int ans=0;\\n      int n = grid.size();\\n      unordered_map<string,int>mp;\\n    \\n     //mapping with the help of Map function which convert rows in unique strings\\n      for(int i=0;i<n;i++){\\n          mp[Mapfun(grid[i])]++;\\n      } \\n       \\n       for(int i=0;i<n;i++){\\n           string search = \"\";\\n           for(int j=0;j<n;j++){\\n               //also converting coulumn same as row\\n               search += to_string(grid[j][i]) + \"$\";\\n               //note that we used grid[j][i] to traverse in coulumn\\n           }\\n          //just search in map if it is present then add the corresponding value in ans\\n          ans += mp[search];\\n       }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630904,
                "title": "w-explanation-c-solutions-using-unordered-map-with-own-hashes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn C++, it is hard to use unordered_map for arrays as keys.\\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\\n\\nIn second solution, we build own hash and unordered_map over vector<int> is applicable.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;  // Variable to store the size of the grid\\n    unordered_map<string, int> Hash;  // Hash map to store the frequency of each string representation of a vector\\n\\n    // Function to convert a vector of integers to a string representation\\n    string to_str(const vector<int>& nums){\\n        string s=\"(\";  // Initialize the string with an opening parenthesis\\n        for(int x:nums)\\n            s+=to_string(x)+\",\";  // Append each integer to the string followed by a comma\\n        return s;  // Return the resulting string\\n    } \\n\\n    // Function to calculate the number of equal pairs in the grid\\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();  // Set the size of the grid\\n\\n        // Loop through each vector in the grid\\n        for(const vector<int>& nums: grid){\\n            string s=to_str(nums);  // Convert the vector to a string representation\\n            if (Hash.count(s)==0)\\n                Hash[s]=1;  // If the string representation is not present in the hash map, add it with a frequency of 1\\n            else\\n                Hash[s]++;  // If the string representation is already present, increment its frequency\\n        }\\n\\n        int ans=0;  // Initialize the answer variable\\n\\n        // Loop through each column in the grid\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);  // Initialize a vector to store the elements of the current column\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];  // Store the elements of the column in the vector\\n            }\\n            string s=to_str(col);  // Convert the vector to a string representation\\n\\n            // Check if the string representation exists in the hash map and add its frequency to the answer\\n            if (Hash.count(s)>0)\\n                ans+=Hash[s];       \\n        }\\n\\n        return ans;  // Return the final answer\\n    }\\n};\\n\\n```\\n# Use Own Hash to use unordered_map over arrays, and faster\\nRuntime 99 ms Beats 85.41%\\n```\\nclass Solution {\\n//Build own Hash and own unordered_map<vector<int>, int> as hash table\\npublic:\\n    struct MyHash\\n    {\\n        size_t operator()(const vector<int>& nums) const\\n        {\\n            size_t digest=0;\\n            for (int x: nums)\\n                digest^=hash<int>{}(x);\\n            return digest; \\n        }\\n    };\\n    int n;\\n    unordered_map<vector<int>, int, MyHash> Hash;\\n    \\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        for(const vector<int>& nums: grid){\\n            if (Hash.count(nums)==0) Hash[nums]=1;\\n            else \\n                Hash[nums]++;\\n        }\\n        int ans=0;\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];\\n            }\\n            if (Hash.count(col)>0)\\n                ans+=Hash[col];       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;  // Variable to store the size of the grid\\n    unordered_map<string, int> Hash;  // Hash map to store the frequency of each string representation of a vector\\n\\n    // Function to convert a vector of integers to a string representation\\n    string to_str(const vector<int>& nums){\\n        string s=\"(\";  // Initialize the string with an opening parenthesis\\n        for(int x:nums)\\n            s+=to_string(x)+\",\";  // Append each integer to the string followed by a comma\\n        return s;  // Return the resulting string\\n    } \\n\\n    // Function to calculate the number of equal pairs in the grid\\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();  // Set the size of the grid\\n\\n        // Loop through each vector in the grid\\n        for(const vector<int>& nums: grid){\\n            string s=to_str(nums);  // Convert the vector to a string representation\\n            if (Hash.count(s)==0)\\n                Hash[s]=1;  // If the string representation is not present in the hash map, add it with a frequency of 1\\n            else\\n                Hash[s]++;  // If the string representation is already present, increment its frequency\\n        }\\n\\n        int ans=0;  // Initialize the answer variable\\n\\n        // Loop through each column in the grid\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);  // Initialize a vector to store the elements of the current column\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];  // Store the elements of the column in the vector\\n            }\\n            string s=to_str(col);  // Convert the vector to a string representation\\n\\n            // Check if the string representation exists in the hash map and add its frequency to the answer\\n            if (Hash.count(s)>0)\\n                ans+=Hash[s];       \\n        }\\n\\n        return ans;  // Return the final answer\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n//Build own Hash and own unordered_map<vector<int>, int> as hash table\\npublic:\\n    struct MyHash\\n    {\\n        size_t operator()(const vector<int>& nums) const\\n        {\\n            size_t digest=0;\\n            for (int x: nums)\\n                digest^=hash<int>{}(x);\\n            return digest; \\n        }\\n    };\\n    int n;\\n    unordered_map<vector<int>, int, MyHash> Hash;\\n    \\n    int equalPairs(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        for(const vector<int>& nums: grid){\\n            if (Hash.count(nums)==0) Hash[nums]=1;\\n            else \\n                Hash[nums]++;\\n        }\\n        int ans=0;\\n        for(int i=0; i<n ;i++){\\n            vector<int> col(n, 0);\\n            for(int j=0; j<n; j++){\\n                col[j]=grid[j][i];\\n            }\\n            if (Hash.count(col)>0)\\n                ans+=Hash[col];       \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630834,
                "title": "easy-clear-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        sumrow=[]\\n        sumcol=[]\\n        n=len(grid)\\n        for i in range(n):\\n            sumrow.append(sum(grid[i]))\\n            s=0\\n            for j in range(n):\\n                s+=grid[j][i]\\n            sumcol.append(s)\\n        \\n        res=0\\n        for i in range(n):\\n            for j in range(n):\\n                if sumrow[i]==sumcol[j]:\\n                    test=True\\n                    for k in range(n):\\n                        if grid[i][k]!=grid[k][j]:\\n                            test=False\\n                            break\\n                    if test:\\n                        res+=1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        sumrow=[]\\n        sumcol=[]\\n        n=len(grid)\\n        for i in range(n):\\n            sumrow.append(sum(grid[i]))\\n            s=0\\n            for j in range(n):\\n                s+=grid[j][i]\\n            sumcol.append(s)\\n        \\n        res=0\\n        for i in range(n):\\n            for j in range(n):\\n                if sumrow[i]==sumcol[j]:\\n                    test=True\\n                    for k in range(n):\\n                        if grid[i][k]!=grid[k][j]:\\n                            test=False\\n                            break\\n                    if test:\\n                        res+=1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630816,
                "title": "java-trie-beats-78-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Scan through one row at a time and construct a trie data structure using the values in sequence in the rows.\\n2. The leaf nodes in the trie must store the number of paths that follow the same set of nodes (i.e. the rows containing the exact same elements).\\n3. Now scan through one column at a time and try to traverse the trie using the sequence of values in each column.\\n4. We will either reach a leaf node in the trie, in which case we add the count in the leaf node to our final answer, or we won\\'t find a match at some point and have to break out of the trie traversal for each column.\\n5. Return the final answer which is the summation of the counts of all leaf nodes reached.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  class Node {\\n    Map<Integer, Node> next = new HashMap<>();\\n    int cnt;\\n  }\\n\\n  public int equalPairs(int[][] grid) {\\n    int n = grid.length, ans = 0;\\n    var root = new Node();\\n\\n    for (var row : grid) {\\n      var ptr = root;\\n\\n      for (var val : row) {\\n        if (ptr.next.containsKey(val))\\n          ptr = ptr.next.get(val);\\n        else {\\n          var newNode = new Node();\\n          ptr.next.put(val, newNode);\\n          ptr = newNode;\\n        }\\n      }\\n      ptr.cnt++;\\n    }\\n    for (var i=0; i<n; i++) {\\n      var ptr = root;\\n\\n      for (var j=0; j<n; j++) {\\n        if (ptr.next.containsKey(grid[j][i]))\\n          ptr = ptr.next.get(grid[j][i]);\\n        else break;\\n      }\\n      ans += ptr.cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Trie",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  class Node {\\n    Map<Integer, Node> next = new HashMap<>();\\n    int cnt;\\n  }\\n\\n  public int equalPairs(int[][] grid) {\\n    int n = grid.length, ans = 0;\\n    var root = new Node();\\n\\n    for (var row : grid) {\\n      var ptr = root;\\n\\n      for (var val : row) {\\n        if (ptr.next.containsKey(val))\\n          ptr = ptr.next.get(val);\\n        else {\\n          var newNode = new Node();\\n          ptr.next.put(val, newNode);\\n          ptr = newNode;\\n        }\\n      }\\n      ptr.cnt++;\\n    }\\n    for (var i=0; i<n; i++) {\\n      var ptr = root;\\n\\n      for (var j=0; j<n; j++) {\\n        if (ptr.next.containsKey(grid[j][i]))\\n          ptr = ptr.next.get(grid[j][i]);\\n        else break;\\n      }\\n      ans += ptr.cnt;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630779,
                "title": "daily-leetcoding-challenge-june-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/equal-row-and-column-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Hash Map\n\n  \n**Approach 3:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/equal-row-and-column-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3502709,
                "title": "javascript-96-8-runtime-and-81-37-memory",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const columns = new Map();\\n    const rows = new Map();\\n    let rowNums, colNums, rowHash, colHash;\\n    let ans = 0;\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        rowNums = [];\\n        colNums = [];\\n        \\n        for (let j = 0; j < grid[i].length; j++) {\\n            rowNums.push(grid[i][j]);\\n            colNums.push(grid[j][i]);\\n        }\\n\\n        rowHash = rowNums.join(\\',\\');\\n        colHash = colNums.join(\\',\\');\\n        \\n        rows.set(rowHash, (rows.get(rowHash) || 0) + 1);\\n        columns.set(colHash, (columns.get(colHash) || 0) + 1);\\n    }\\n\\n    for (const [row, value] of rows) {\\n        if (columns.has(row)) {\\n            ans += value * columns.get(row);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    const columns = new Map();\\n    const rows = new Map();\\n    let rowNums, colNums, rowHash, colHash;\\n    let ans = 0;\\n\\n    for (let i = 0; i < grid.length; i++) {\\n        rowNums = [];\\n        colNums = [];\\n        \\n        for (let j = 0; j < grid[i].length; j++) {\\n            rowNums.push(grid[i][j]);\\n            colNums.push(grid[j][i]);\\n        }\\n\\n        rowHash = rowNums.join(\\',\\');\\n        colHash = colNums.join(\\',\\');\\n        \\n        rows.set(rowHash, (rows.get(rowHash) || 0) + 1);\\n        columns.set(colHash, (columns.get(colHash) || 0) + 1);\\n    }\\n\\n    for (const [row, value] of rows) {\\n        if (columns.has(row)) {\\n            ans += value * columns.get(row);\\n        }\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3814071,
                "title": "simple-solution-o-n-3-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                boolean flag = true;\\n                for(int k=0;k<n;k++) {\\n                    if(grid[i][k] == grid[k][j]) {\\n                        continue;\\n                    }else{\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag == true) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int count=0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                boolean flag = true;\\n                for(int k=0;k<n;k++) {\\n                    if(grid[i][k] == grid[k][j]) {\\n                        continue;\\n                    }else{\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n                if(flag == true) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642277,
                "title": "best-solution",
                "content": "# Approach\\nUsing Map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = 0;\\n        map <vector<int>, int> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[grid[i]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            vector <int> col;\\n            for (int j = 0; j < n; j++) {\\n                col.push_back(grid[j][i]);\\n            }\\n            if (mp.find(col) != mp.end())\\n                ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = 0;\\n        map <vector<int>, int> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[grid[i]]++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            vector <int> col;\\n            for (int j = 0; j < n; j++) {\\n                col.push_back(grid[j][i]);\\n            }\\n            if (mp.find(col) != mp.end())\\n                ans += mp[col];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634451,
                "title": "easy-optimal-solution-like-no-one-else-custom-rolling-hash-function-used-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile I was reading this question, a few approaches immediately popped in my mind. The first was obviously the BRUTE force approach where you check ever element in every row and column but it takes a lot of time to do that. Now here, I remembered about the concept of Dynamic Programming where the ideology is to NOT repeat calculations. So that is how I thought of using HASH functions.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhat you do here is... For every row, A hash value is computed using a rolling hash function (Here it is defined as hash()). The hash value depends on the ORDER of elements and their numeric value or \"weight\". Each row gets a unique hash value which can be regenerated by an array having same elements in the same order.\\n\\nNow, the problem is that the input grid[][] may have duplicate rows. So what I thought of was to keep a frequency count of the row in a hashmap where the key is the hash value computed.\\n\\nOnce the map is ready, we calculate the hash value for ALL columns which unfortunately takes O(n^2) because we first construct the array (Done only once, after that we just replace the values) to compute hash value for every column.\\n\\nIf a match is found, we then simply add the frequency to the result because the column matches with BOTH rows (which are identical)\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (O(k))\\n&emsp; *Where k is max(row, column)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    // Hash Function\\n    ll hash(vector<int> &vec){\\n        ll hash_so_far = 0;\\n        ll p = 31, m = 1e9 + 7;\\n        ll p_pow = 1;\\n        ll n = (ll)vec.size();\\n        for (long long i = 0; i < n; ++i) {\\n            hash_so_far = (hash_so_far + vec[i] * p_pow) % m;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        return hash_so_far;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int res = 0;\\n        int row = grid.size();\\n        int column = grid[0].size();\\n        ll hashed_col;\\n\\n        unordered_map<ll, int> umap;\\n\\n        for(int i = 0 ; i < row ; i++){\\n            // Computing hash value\\n            umap[hash(grid[i])]++;\\n        }\\n        vector<int> col(row);\\n        for(int i = 0 ; i < column ; i++){\\n            for(int j = 0 ; j < row ; j++){\\n                col[j] = grid[j][i];\\n                // Generating column vector\\n            }\\n            // Hash value of column vector\\n            hashed_col = hash(col);\\n            if(umap.find(hashed_col) != umap.end()){\\n                res += umap.at(hashed_col);\\n                // Adding frequency of the hash value if match = true\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    // Hash Function\\n    ll hash(vector<int> &vec){\\n        ll hash_so_far = 0;\\n        ll p = 31, m = 1e9 + 7;\\n        ll p_pow = 1;\\n        ll n = (ll)vec.size();\\n        for (long long i = 0; i < n; ++i) {\\n            hash_so_far = (hash_so_far + vec[i] * p_pow) % m;\\n            p_pow = (p_pow * p) % m;\\n        }\\n        return hash_so_far;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int res = 0;\\n        int row = grid.size();\\n        int column = grid[0].size();\\n        ll hashed_col;\\n\\n        unordered_map<ll, int> umap;\\n\\n        for(int i = 0 ; i < row ; i++){\\n            // Computing hash value\\n            umap[hash(grid[i])]++;\\n        }\\n        vector<int> col(row);\\n        for(int i = 0 ; i < column ; i++){\\n            for(int j = 0 ; j < row ; j++){\\n                col[j] = grid[j][i];\\n                // Generating column vector\\n            }\\n            // Hash value of column vector\\n            hashed_col = hash(col);\\n            if(umap.find(hashed_col) != umap.end()){\\n                res += umap.at(hashed_col);\\n                // Adding frequency of the hash value if match = true\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634405,
                "title": "c-o-n-2-transpose-method",
                "content": "# Intuition\\nFirstly tranpose the given matrix and then compare the rows of the given matrix and the transpose matrix.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity:O(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<vector<int>> t;\\n        int cnt=0;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            vector<int> a;\\n            for(int j=0; j<grid.size(); j++)\\n            {\\n                a.push_back(grid[j][i]);\\n            }\\n            t.push_back(a);\\n        }\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid.size(); j++)\\n            if(grid[i]==t[j]) \\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<vector<int>> t;\\n        int cnt=0;\\n        for(int i=0; i<grid[0].size(); i++)\\n        {\\n            vector<int> a;\\n            for(int j=0; j<grid.size(); j++)\\n            {\\n                a.push_back(grid[j][i]);\\n            }\\n            t.push_back(a);\\n        }\\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            for(int j=0; j<grid.size(); j++)\\n            if(grid[i]==t[j]) \\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633733,
                "title": "c-easy-solution-using-hashmap",
                "content": "\\n\\n# Approach\\n->First traverse on the grid in row wise manner & keep on adding elements in the vector  after each row push it in map.\\n-> Then traverse again but this time in column wise manner & now try to find that column array in the map. \\n-> If you get it increase the count \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       map<vector<int>,int >m;\\n       int n = grid.size();\\n       for(int i =0;i<n;i++){\\n           vector<int>temp;\\n           for(int j =0;j<n; j++){\\n            temp.push_back(grid[i][j]);\\n           }\\n           m[temp]++;\\n       }\\n      \\n       int cnt = 0;\\n        for(int j =0;j<n;j++){\\n          vector<int>temp;\\n           for(int i =0;i<n; i++){\\n               temp.push_back(grid[i][j]);\\n           }\\n           if(m.find(temp) != m.end()){\\n               cnt += m[temp];\\n           }\\n           }\\n           return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       map<vector<int>,int >m;\\n       int n = grid.size();\\n       for(int i =0;i<n;i++){\\n           vector<int>temp;\\n           for(int j =0;j<n; j++){\\n            temp.push_back(grid[i][j]);\\n           }\\n           m[temp]++;\\n       }\\n      \\n       int cnt = 0;\\n        for(int j =0;j<n;j++){\\n          vector<int>temp;\\n           for(int i =0;i<n; i++){\\n               temp.push_back(grid[i][j]);\\n           }\\n           if(m.find(temp) != m.end()){\\n               cnt += m[temp];\\n           }\\n           }\\n           return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632398,
                "title": "detailed-python-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\"Please UP-VOTE Friends\"\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        #initilize the count as 0\\n        c=0\\n        for i in range(len(grid)):\\n            #Iterate the grid and take it from colum elements and make it as x\\n            x=[grid[j][i] for j in range(len(grid))]\\n            #if colum in grid then count\\n            if x in grid:\\n                #add to count how many times it would be occur in a grid\\n                c=c+grid.count(x)\\n        #Then return the total count\\n        return c\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        #initilize the count as 0\\n        c=0\\n        for i in range(len(grid)):\\n            #Iterate the grid and take it from colum elements and make it as x\\n            x=[grid[j][i] for j in range(len(grid))]\\n            #if colum in grid then count\\n            if x in grid:\\n                #add to count how many times it would be occur in a grid\\n                c=c+grid.count(x)\\n        #Then return the total count\\n        return c\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631592,
                "title": "python-shortest-1-liners-multiple-solutions-functional-programming",
                "content": "# Approach 1: Brute force\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 3)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n * n is the dimensions of grid.`\\n\\n# Code\\n\\nMultiline:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        transpose = lambda matrix: list(map(list, zip(*matrix)))\\n        rows, cols = grid, transpose(grid)\\n        return sum(starmap(eq, product(rows, cols)))\\n\\n\\n```\\n\\n1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(starmap(eq, product(grid, list(map(list, zip(*grid))))))\\n\\n\\n```\\n\\n---\\n# Approach 1: Hashmap\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n * n is the dimensions of grid.`\\n\\n# Code\\n\\nMultiline:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        rows = Counter(map(tuple, grid))\\n        return sum(rows[col] for col in zip(*grid))\\n\\n\\n```\\n\\n1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return (rows := Counter(map(tuple, grid))) and sum(rows[col] for col in zip(*grid))\\n\\n\\n```\\n\\nAnother 1-liner:\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(itemgetter(*zip(*grid), 0)(Counter(map(tuple, grid))))\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        transpose = lambda matrix: list(map(list, zip(*matrix)))\\n        rows, cols = grid, transpose(grid)\\n        return sum(starmap(eq, product(rows, cols)))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(starmap(eq, product(grid, list(map(list, zip(*grid))))))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        rows = Counter(map(tuple, grid))\\n        return sum(rows[col] for col in zip(*grid))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return (rows := Counter(map(tuple, grid))) and sum(rows[col] for col in zip(*grid))\\n\\n\\n```\n```python\\nclass Solution:\\n    def equalPairs(self, grid: list[list[int]]) -> int:\\n        return sum(itemgetter(*zip(*grid), 0)(Counter(map(tuple, grid))))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631483,
                "title": "easiest-python-solution-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem aims to count the number of equal pairs in the given grid. One way to approach this is to compare each row in the grid with the first row and check if they are equal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Store the first row of the grid in the variable column_starts_with.\\n\\n2.Initialize an empty list called columns to store the columns of the grid.\\n\\n3.Iterate through each row in the grid.\\n\\n4.For each row, iterate through each element and append it to the corresponding column in the columns list using the enumerate function.\\n\\n5.After iterating through all the rows, the columns list contains the columns of the grid.\\n\\n6.Initialize a variable called equal_pairs to keep track of the count of equal pairs.\\n\\n7.Iterate through each row in the grid.\\n\\n8.For each row, iterate through each element in the column_starts_with list.\\n\\n9.Check if the first element of the row is equal to the element in the corresponding column.\\n\\n10.If the condition is met, compare the entire row with the column to determine if they are equal.\\n\\n11.If the row is equal to the column, increment the count of equal_pairs.\\nFinally, return the count of equal_pairs.\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        # Store the first row of the grid\\n        column_starts_with = grid[0]\\n\\n        # Initialize a list to store the columns of the grid\\n        columns = [[] for _ in column_starts_with]\\n        \\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the row and append it to the corresponding column\\n            for j, element in enumerate(row):\\n                columns[j].append(element)\\n        \\n        # Initialize a variable to count the equal pairs\\n        equal_pairs = 0\\n\\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the first row\\n            for j, element in enumerate(column_starts_with):\\n                # Check if the first element of the row is equal to the element in the corresponding column\\n                if row[0] == element:\\n                    # Check if the entire row is equal to the column\\n                    if row == columns[j]:\\n                        equal_pairs += 1\\n    \\n        return equal_pairs\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        # Store the first row of the grid\\n        column_starts_with = grid[0]\\n\\n        # Initialize a list to store the columns of the grid\\n        columns = [[] for _ in column_starts_with]\\n        \\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the row and append it to the corresponding column\\n            for j, element in enumerate(row):\\n                columns[j].append(element)\\n        \\n        # Initialize a variable to count the equal pairs\\n        equal_pairs = 0\\n\\n        # Iterate through each row of the grid\\n        for row in grid:\\n            # Iterate through each element in the first row\\n            for j, element in enumerate(column_starts_with):\\n                # Check if the first element of the row is equal to the element in the corresponding column\\n                if row[0] == element:\\n                    # Check if the entire row is equal to the column\\n                    if row == columns[j]:\\n                        equal_pairs += 1\\n    \\n        return equal_pairs\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631470,
                "title": "best-c-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon analyzing the code, it appears that the `equalPairs` function takes a 2D grid represented by a vector of vectors (`grid`) as input. The function aims to count the number of equal pairs in the grid.\\n\\n\\nThis solution leverages a map to count the frequency of each vector in the grid, allowing us to efficiently find the number of equal pairs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->To solve the problem, the approach followed by the given code is as follows:\\n\\n1. Initialize a variable `ans` to keep track of the count of equal pairs.\\n2. Create a `map` called `mp` to store the frequency of each vector in the `grid`.\\n3. Iterate over each row (`i`) in the `grid` using a for loop.\\n   - Inside the loop, access the current row of the `grid` and increment the frequency of that row\\'s vector in the `mp` map.\\n4. Iterate over each column (`j`) in the `grid` using a nested for loop.\\n   - Inside the nested loop, perform the following steps:\\n     - Create an empty vector `v` to store the values of the column.\\n     - Iterate over each row (`i`) in the `grid` using another for loop.\\n       - Inside this loop, access the value at column `j` of the current row and append it to the vector `v`.\\n     - After the inner loop ends, increment `ans` by the frequency of vector `v` in the `mp` map.\\n5. After both loops complete, return the final count `ans`.\\n\\nThe approach essentially counts the occurrences of each row vector in the `grid` using a map, and then counts the occurrences of each column vector by transposing the grid. Finally, it sums up the frequencies of equal pairs and returns the count.\\n\\n# Complexity\\n- Time complexity: O(M * N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> where M and N are the dimensions of the grid.\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->where M and N are the dimensions of the grid. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/abf00482-9fde-4cf1-9911-a767b8732f15_1686631415.479188.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) \\n    {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            mp[grid[i]]++;\\n        }\\n        for(int j =0;j<grid[0].size();j++)\\n        {\\n            vector<int>v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n            ans+=mp[v];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631290,
                "title": "java-solution-for-equal-row-and-column-pairs-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to iterate through each row of the grid and keep track of the frequency of each row using a map. Then, for each column, construct a temporary array by extracting the elements of the column. Convert this array to a string and check its frequency in the row frequency map. Add the frequency to the total count.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the count variable to 0 and the size of the grid, n.\\n1. Create a map called rowCounter to keep track of the frequency of each row.\\n1. Iterate through each row of the grid:\\n- Convert the row array to a string using Arrays.toString().\\n- Increment the frequency of the row string in the rowCounter map.\\n4. Iterate through each column of the grid:\\n- Create a temporary array called colArray to store the elements of the column.\\n- Extract the elements of the column by iterating through the rows and accessing the corresponding element.\\n- Convert the colArray to a string using Arrays.toString().\\n- Retrieve the frequency of the column string from the rowCounter map using getOrDefault().\\n- Add the frequency to the count variable.\\n5. Return the count.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^2), where n is the size of the grid. The code iterates through each row and column of the grid once, and the operations performed within the loops are constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n^2). It uses additional space to store the rowCounter map, which can contain up to n^2 entries in the worst case.\\n\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        int n = grid.length;\\n\\n        // Keep track of the frequency of each row.\\n        Map<String, Integer> rowCounter = new HashMap<>();\\n        for (int[] row : grid) \\n        {\\n            String rowString = Arrays.toString(row);\\n            rowCounter.put(rowString, 1 + rowCounter.getOrDefault(rowString, 0));\\n        }\\n\\n        // Add up the frequency of each column in the map.\\n        for (int c = 0; c < n; c++) \\n        {\\n            int[] colArray = new int[n];\\n            for (int r = 0; r < n; r++) \\n            {\\n                colArray[r] = grid[r][c];\\n            }\\n            count += rowCounter.getOrDefault(Arrays.toString(colArray), 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        int n = grid.length;\\n\\n        // Keep track of the frequency of each row.\\n        Map<String, Integer> rowCounter = new HashMap<>();\\n        for (int[] row : grid) \\n        {\\n            String rowString = Arrays.toString(row);\\n            rowCounter.put(rowString, 1 + rowCounter.getOrDefault(rowString, 0));\\n        }\\n\\n        // Add up the frequency of each column in the map.\\n        for (int c = 0; c < n; c++) \\n        {\\n            int[] colArray = new int[n];\\n            for (int r = 0; r < n; r++) \\n            {\\n                colArray[r] = grid[r][c];\\n            }\\n            count += rowCounter.getOrDefault(Arrays.toString(colArray), 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631059,
                "title": "simplest-python-solution-take-transpose-of-matrix",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        ans = 0\\n\\n        for row in grid:\\n            d[tuple(row)] += 1\\n\\n        for col in zip(*grid):\\n            ans += d[tuple(col)]\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        ans = 0\\n\\n        for row in grid:\\n            d[tuple(row)] += 1\\n\\n        for col in zip(*grid):\\n            ans += d[tuple(col)]\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630973,
                "title": "brute-force-m-3-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,k,n=grid.size(),ans=0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                k = 0;\\n                while(k<n&&grid[i][k]==grid[k][j])k++;\\n                if(k>=n)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,k,n=grid.size(),ans=0;\\n        for(i = 0; i < n; i++){\\n            for(j = 0; j < n; j++){\\n                k = 0;\\n                while(k<n&&grid[i][k]==grid[k][j])k++;\\n                if(k>=n)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630899,
                "title": "o-n-3-o-n-2-solution-c",
                "content": "#Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0; i<n;i++){\\n            vector<int> temp;\\n            for(int j=0; j<n;j++){\\n                cout<<grid[j][i]<<\" \";\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n            cout<<endl;\\n        }\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==ans[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string str(vector<int> & row){\\n        string ans=\"\";\\n        for(int j:row){\\n            ans+=to_string(j)+\"#\";\\n        }\\n        return ans;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        map<string,int> mp;\\n        for(int i=0; i<n;i++){\\n            mp[str(grid[i])]++;\\n        }\\n        for(int i=0; i<n;i++){\\n            string ans=\"\";\\n            for(int j=0; j<n;j++){\\n                ans+=to_string(grid[j][i])+\"#\";\\n            }\\n            count+=mp[ans];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0; i<n;i++){\\n            vector<int> temp;\\n            for(int j=0; j<n;j++){\\n                cout<<grid[j][i]<<\" \";\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n            cout<<endl;\\n        }\\n        for(int i=0; i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==ans[j]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string str(vector<int> & row){\\n        string ans=\"\";\\n        for(int j:row){\\n            ans+=to_string(j)+\"#\";\\n        }\\n        return ans;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count=0;\\n        int n=grid.size();\\n        map<string,int> mp;\\n        for(int i=0; i<n;i++){\\n            mp[str(grid[i])]++;\\n        }\\n        for(int i=0; i<n;i++){\\n            string ans=\"\";\\n            for(int j=0; j<n;j++){\\n                ans+=to_string(grid[j][i])+\"#\";\\n            }\\n            count+=mp[ans];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324784,
                "title": "just-do-what-it-says-easy-solution",
                "content": "Just do what the question asks.\\n\\nFor a single `row, col` position iterate the whole row and the whole column, and check whether the elements are equal and in the same order.\\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        \\n        for row in range(n):\\n            for col in range(n):\\n                has_found = True\\n                \\n                for i in range(n):\\n                    if grid[row][i] != grid[i][col]:\\n                        has_found = False\\n                        break\\n                    \\n                if has_found:\\n                    ans += 1\\n\\t\\t\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ans = 0\\n        \\n        for row in range(n):\\n            for col in range(n):\\n                has_found = True\\n                \\n                for i in range(n):\\n                    if grid[row][i] != grid[i][col]:\\n                        has_found = False\\n                        break\\n                    \\n                if has_found:\\n                    ans += 1\\n\\t\\t\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784119,
                "title": "python-3-tuple-dict-and-transpose-matrix-using-zip-beats-97",
                "content": "```python3 []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        for row in grid:\\n            d[tuple(row)] += 1\\n        \\n        return sum(d[tuple(col)] for col in zip(*grid))        \\n```\\n![Screenshot 2023-07-18 at 20.06.44.png](https://assets.leetcode.com/users/images/3d8310a3-d6e3-4a22-8a43-0dec42ff4ee1_1689700226.718251.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d = defaultdict(int)\\n        for row in grid:\\n            d[tuple(row)] += 1\\n        \\n        return sum(d[tuple(col)] for col in zip(*grid))        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634601,
                "title": "python-dictionary-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$, where n is the number of cells in the grid\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d1 = {}\\n        d2 = {}\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d1[tupled_row] = 1 + d1.get(tupled_row, 0)\\n\\n        grid = zip(*grid)\\n\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d2[tupled_row] = 1 + d2.get(tupled_row, 0)\\n\\n        res = 0\\n        for i in d1:\\n            if i in d2:\\n                res += d1[i]*d2[i]\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        d1 = {}\\n        d2 = {}\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d1[tupled_row] = 1 + d1.get(tupled_row, 0)\\n\\n        grid = zip(*grid)\\n\\n        for row in grid:\\n            tupled_row = tuple(row)\\n            d2[tupled_row] = 1 + d2.get(tupled_row, 0)\\n\\n        res = 0\\n        for i in d1:\\n            if i in d2:\\n                res += d1[i]*d2[i]\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632254,
                "title": "c-java-beginner-friendly",
                "content": "# Intuition\\nJust move every rows in a map and count them then compare it with the cols,if they are equals then increase the result value\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If i did it in brute force approach then we have to take a row and compare it with all the columns (comparing done by element by element) so the total time complexity would be $$O(n^3)$$ (n*n for compare row and col and n * n *n to compare element by element)\\n2. But In optimal approach we store the row-wise value as a string format in a map,But we have to join the numbers by some special character like ($$#,$,@ etc$$) cause lets take a case a row-wise value is 2,2,1,0 and if i joined it without special char then the string would be like \"2211\" and suppose in col-wise the value is 22,1,1 and after joining without special chars the string would be like \"2211\",Now both the strings are same and it will increase our result,but thats not true. So thats why we put a special char between every number.\\n3. After apply the logic the strings look like this row-wise=\"2@2@1@1\" col-wise=\"22@1@1\" ,now both are not same.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:Brute force->$$O(n^3)$$\\n                  Optimal approach->$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ for storing the rows in a map\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` c++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        unordered_map<string,int> map;\\n        for(vector<int> row:grid){\\n            string res=\"\";\\n            for(int ele:row){\\n                res+=to_string(ele);\\n                res+=\\'#\\';\\n            }\\n            map[res]++;\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            string res=\"\"; \\n            for(int i=0;i<grid.size();i++){\\n                res+=to_string(grid[i][j]);\\n                res+=\\'#\\';\\n            }\\n            ans+=map[res];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        int ans=0;\\n        for(int []row:grid){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i:row){\\n                sb.append(i).append(\\'#\\');\\n            }\\n            map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1);\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i=0;i<grid.length;i++){\\n                sb.append(grid[i][j]).append(\\'#\\');\\n            }\\n            ans+=map.getOrDefault(sb.toString(),0);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**If you enjoyed the solution \\uD83D\\uDE01, an upvote would be greatly appreciated! Your support motivates me to share more helpful solutions. Thank you!**",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` c++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        unordered_map<string,int> map;\\n        for(vector<int> row:grid){\\n            string res=\"\";\\n            for(int ele:row){\\n                res+=to_string(ele);\\n                res+=\\'#\\';\\n            }\\n            map[res]++;\\n        }\\n        for(int j=0;j<grid[0].size();j++){\\n            string res=\"\"; \\n            for(int i=0;i<grid.size();i++){\\n                res+=to_string(grid[i][j]);\\n                res+=\\'#\\';\\n            }\\n            ans+=map[res];\\n        }\\n        return ans;\\n    }\\n};\\n```\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> map=new HashMap<>();\\n        int ans=0;\\n        for(int []row:grid){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i:row){\\n                sb.append(i).append(\\'#\\');\\n            }\\n            map.put(sb.toString(),map.getOrDefault(sb.toString(),0)+1);\\n        }\\n        for(int j=0;j<grid[0].length;j++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int i=0;i<grid.length;i++){\\n                sb.append(grid[i][j]).append(\\'#\\');\\n            }\\n            ans+=map.getOrDefault(sb.toString(),0);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631695,
                "title": "no-map-no-trie-two-o-n-3-approach-c",
                "content": "# Intuition and Approach\\nWe are Simply creating a new vector<vector<string>> and then storing elements in it column-wise and rowWise\\nso now we have two vectors gc-gridColumnWise , gr-gridRowWise\\n\\nwe iterate through them and equate them to see if any pairs of vector is same in both of them\\n# Complexity\\n- Time complexity:O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code - Less than O(n^3)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        int n=g.size();\\n        vector<string> gc,gr;\\n\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[j][i]);\\n                s+=\"-\";\\n            }\\n            gc.push_back(s);\\n        }\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[i][j]);\\n                s+=\"-\";\\n            }\\n            gr.push_back(s);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code - O(n^3)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& gr) {\\n        vector<vector<int>> gc;\\n        int n=gr.size();\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> v;\\n            for(int j=0;j<n;j++){\\n                v.push_back(gr[j][i]); // columnWise pushing\\n            }\\n            gc.push_back(v);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        int n=g.size();\\n        vector<string> gc,gr;\\n\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[j][i]);\\n                s+=\"-\";\\n            }\\n            gc.push_back(s);\\n        }\\n        for(int i=0;i<n;i++){\\n            string s;\\n            for(int j=0;j<n;j++){\\n                s+=to_string(g[i][j]);\\n                s+=\"-\";\\n            }\\n            gr.push_back(s);\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& gr) {\\n        vector<vector<int>> gc;\\n        int n=gr.size();\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> v;\\n            for(int j=0;j<n;j++){\\n                v.push_back(gr[j][i]); // columnWise pushing\\n            }\\n            gc.push_back(v);\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(gr[i]==gc[j]){  // comparing the vectors\\n                    ans++;\\n                }\\n            }            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631010,
                "title": "easy-to-understand-c-solution-python-solution-fastest",
                "content": "# Approach : Map\\n<!-- Describe your approach to solving the problem. -->\\n# Code 1\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int ans=0;\\n        \\n        map<vector<int> ,int> mp;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            mp[grid[i]]++;\\n            \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            vector<int> v;\\n            \\n            for(int j=0;j<grid.size();j++)\\n                v.push_back(grid[j][i]);\\n            \\n            ans+=mp[v];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n# Approach : Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n# Code 2\\n```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i]==ans[j])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# Approach : Simple Comparison { Python}\\n<!-- Describe your approach to solving the problem. -->\\n# Code 3\\n```\\n\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        ans = 0 \\n        for j in range(len(grid)):\\n            column = []\\n            for row in grid:\\n                column.append(row[j])\\n            ans+= grid.count(column) # count how many rows equal to this column\\n            \\n        return ans \\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int ans=0;\\n        \\n        map<vector<int> ,int> mp;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            mp[grid[i]]++;\\n            \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            vector<int> v;\\n            \\n            for(int j=0;j<grid.size();j++)\\n                v.push_back(grid[j][i]);\\n            \\n            ans+=mp[v];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int>temp;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n            ans.push_back(temp);\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i]==ans[j])\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\n\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        ans = 0 \\n        for j in range(len(grid)):\\n            column = []\\n            for row in grid:\\n                column.append(row[j])\\n            ans+= grid.count(column) # count how many rows equal to this column\\n            \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564106,
                "title": "beat-100-o-n-2-optimal-solution-true-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use hash map for most problems of *finding the number of pairs*.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe tricky part here is that we are dealing with rows and column. The rows are already `vector<int>`. We can dump columns into `vector<int>` as well and use a custom hash function for it.\\n\\n**DO NOT USE `std::map` FOR HASH MAP USAGE CASES**\\n`std::map` is both suboptimal in big O and practically quite slow.\\n\\n# Better Solution\\nI added another [solution](https://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/) that is an improved version of this one by not copying any data.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n# Code\\n```\\nstruct VectorHash {\\n  int operator()(const vector<int> &v) const {\\n    uint hash = v.size();\\n    for(int x : v) {\\n        hash ^= x + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<vector<int>, int, VectorHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      vector<int> key(N);\\n      for (int r = 0; r < N; ++r) {\\n        key[r] = grid[r][c];\\n      }\\n      ++counts[key];\\n    }\\n    int answer = 0;\\n    for (const vector<int>& row : grid) {\\n      answer += counts[row];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nstruct VectorHash {\\n  int operator()(const vector<int> &v) const {\\n    uint hash = v.size();\\n    for(int x : v) {\\n        hash ^= x + 0x9e3779b9 + (hash << 6) + (hash >> 2);\\n    }\\n    return hash;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    const int N = grid.size();\\n    unordered_map<vector<int>, int, VectorHash> counts;\\n    for (int c = 0; c < N; ++c) {\\n      vector<int> key(N);\\n      for (int r = 0; r < N; ++r) {\\n        key[r] = grid[r][c];\\n      }\\n      ++counts[key];\\n    }\\n    int answer = 0;\\n    for (const vector<int>& row : grid) {\\n      answer += counts[row];\\n    }\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473341,
                "title": "easy-solution-using-2-maps",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint equalPairs(vector<vector<int>>& grid) {\\n\\t\\t\\tmap<vector<int>,int> row;\\n\\t\\t\\tmap<vector<int>,int> col;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[i][j]);\\n\\t\\t\\t\\trow[data]++;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[j][i]);\\n\\t\\t\\t\\tcol[data]++;\\n\\t\\t\\t}\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(auto x: row){\\n\\t\\t\\t\\tif(col.find(x.first)!=col.end())\\n\\t\\t\\t\\t\\tres+=(x.second*col[x.first]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint equalPairs(vector<vector<int>>& grid) {\\n\\t\\t\\tmap<vector<int>,int> row;\\n\\t\\t\\tmap<vector<int>,int> col;\\n\\t\\t\\tint n = grid.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tvector<int> data;\\n\\t\\t\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t\\t\\t\\tdata.push_back(grid[i][j]);\\n\\t\\t\\t\\trow[data]++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2344176,
                "title": "c-easy-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n          mp[grid[i]]++;  \\n        }\\n        for(int i=0;i<grid[0].size();i++)\\n        { \\n            vector<int>chk;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n            chk.push_back(grid[j][i]);\\n            ans+=mp[chk];\\n            }\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0;\\n        map<vector<int>,int>mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n          mp[grid[i]]++;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2324818,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int EqualPairs(int[][] grid)\\n    {\\n        var count = 0;\\n        var dic = new Dictionary<string, int>();\\n        \\n        var n = grid.Length;\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Empty;\\n            for (var j = 0; j < n; j++)\\n                s += Convert.ToString(grid[j][i]) + \",\";\\n\\n            if (dic.ContainsKey(s))\\n                dic[s] += 1;\\n            else\\n                dic.Add(s, 1);\\n        }\\n        \\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Join(\",\", grid[i].Select(j => j.ToString()).ToArray()) + \",\";\\n            count += dic.ContainsKey(s) ? dic[s] : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int EqualPairs(int[][] grid)\\n    {\\n        var count = 0;\\n        var dic = new Dictionary<string, int>();\\n        \\n        var n = grid.Length;\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Empty;\\n            for (var j = 0; j < n; j++)\\n                s += Convert.ToString(grid[j][i]) + \",\";\\n\\n            if (dic.ContainsKey(s))\\n                dic[s] += 1;\\n            else\\n                dic.Add(s, 1);\\n        }\\n        \\n        for (var i = 0; i < n; i++)\\n        {\\n            var s = string.Join(\",\", grid[i].Select(j => j.ToString()).ToArray()) + \",\";\\n            count += dic.ContainsKey(s) ? dic[s] : 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324772,
                "title": "python3-freq-table-o-n-2",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/d61cd3ed09bbf59fd619802a6e861a516ec17094) for solutions of weekly 303. \\n\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        freq = Counter(tuple(row) for row in grid)\\n        return sum(freq[tuple(col)] for col in zip(*grid))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        freq = Counter(tuple(row) for row in grid)\\n        return sum(freq[tuple(col)] for col in zip(*grid))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324671,
                "title": "c-equal-row-and-column-pairs-easy-solution",
                "content": "```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(); // grid size \\n        \\n        int ans = 0; // final answer \\n        \\n        for (int i = 0; i < n; i++){\\n            // ith row \\n            for (int j = 0; j < n; j++){\\n                // jth column \\n                int count = 0; \\n                \\n                for (int k = 0; k < n; k++){\\n                    if (grid[i][k] == grid[k][j]) count++;\\n                }\\n                \\n                // check if row and column are equal \\n                if (count == n) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(); // grid size \\n        \\n        int ans = 0; // final answer \\n        \\n        for (int i = 0; i < n; i++){\\n            // ith row \\n            for (int j = 0; j < n; j++){\\n                // jth column \\n                int count = 0; \\n                \\n                for (int k = 0; k < n; k++){\\n                    if (grid[i][k] == grid[k][j]) count++;\\n                }\\n                \\n                // check if row and column are equal \\n                if (count == n) ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3731477,
                "title": "java-easy-solution-using-hashmap-and-string-patterns",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> map1 = new HashMap<>();\\n        HashMap<String, Integer> map2 = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[i][j]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map1.put(str, map1.getOrDefault(str, 0) + 1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[j][i]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map2.put(str, map2.getOrDefault(str, 0) + 1);\\n        }\\n        int ans = 0;\\n        for(String s : map1.keySet()) {\\n            if(map2.containsKey(s)) {\\n                ans += map1.get(s) * map2.get(s);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        HashMap<String, Integer> map1 = new HashMap<>();\\n        HashMap<String, Integer> map2 = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[i][j]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map1.put(str, map1.getOrDefault(str, 0) + 1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < n; j++) {\\n                s.append(grid[j][i]);\\n                s.append(\":\");\\n            }\\n            String str = s.toString();\\n            map2.put(str, map2.getOrDefault(str, 0) + 1);\\n        }\\n        int ans = 0;\\n        for(String s : map1.keySet()) {\\n            if(map2.containsKey(s)) {\\n                ans += map1.get(s) * map2.get(s);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636433,
                "title": "simple-easy-approach-with-beats-52-42-in-runtime-and-95-31-in-memory",
                "content": "# Intuition\\nVery simple logic I followed, go ahead with the checking untill you got diffrent numbers.\\n\\n# Approach\\n1. Take two pointers for the row and column [ ex: `r`& `c` ]\\n2. Start a while loop for untill your pointer for row and column touches the length of the grid means `n`.\\n3. Take another two pointers for itreating the rows and cols [ ex: `i` & `j` ]\\n4. Check `grid[r][i] === grid[j][c]`, untill it dismatch, go ahead and if you find that your `i` & `j` reaches `n` means grid\\'s length then `increment/++` the count of the equal Row and Cols\\n5. After this, just do `column++ / c++`. And If you reach in the last column then restart the column number from 0 like `c=0` and increase the value of the row `row++ / r++`\\n6. Now you\\'ve the no of equal rows and cols, just return it outside of your loops;\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n![Beats.PNG](https://assets.leetcode.com/users/images/e3ea9158-de0d-4065-94ce-3b81c9ca9ba5_1686729479.15648.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function (grid) {\\n    const n = grid.length;\\n    let equalCount = 0;\\n    let r = 0, c = 0;\\n    while (r < n && c < n) {\\n        let i = 0, j = 0;\\n        while (grid[r][i] === grid[j][c]) {\\n            i++;\\n            j++;\\n            if (i === n && j === n) {\\n                equalCount++;\\n                break;\\n            }\\n        }\\n        c++;\\n        if(c === n){\\n            c = 0;\\n            r++;\\n        }\\n    }\\n    return equalCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function (grid) {\\n    const n = grid.length;\\n    let equalCount = 0;\\n    let r = 0, c = 0;\\n    while (r < n && c < n) {\\n        let i = 0, j = 0;\\n        while (grid[r][i] === grid[j][c]) {\\n            i++;\\n            j++;\\n            if (i === n && j === n) {\\n                equalCount++;\\n                break;\\n            }\\n        }\\n        c++;\\n        if(c === n){\\n            c = 0;\\n            r++;\\n        }\\n    }\\n    return equalCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634899,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size();\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int fl = 1;\\n                for (int i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        fl = 0;\\n                        break;\\n                    }\\n                }\\n                ans += fl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size();\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                int fl = 1;\\n                for (int i = 0; i < n; ++i) {\\n                    if (grid[r][i] != grid[i][c]) {\\n                        fl = 0;\\n                        break;\\n                    }\\n                }\\n                ans += fl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634864,
                "title": "c-u16string-hashing-vs-trie-100-time-58ms-85-space-24-1mb",
                "content": "My first intuition was that it would be rather easy to hash each row, count the frequency of each hash and then do the for each column, adding the frequency previously found to the result for each match.\\n\\nIn order to do so, a normal `string` would not cut it, since `char`s go with `7` bits and cut out the rest, so we will get tons of collisions from that. But with `16` bits, we can cover almost completely the full range (to go up to `10e5` we would have needed `17`, but with `16` we do well enough to avoid any collisions with all the test cases, although you might argue that a few such cases might be created to let us slip with this approach).\\n\\nWe will start `using` `u16String` as our `hashType`, then declaring our usual support variables:\\n* `hashFreq` will map hashes to their respective frequence;\\n* `res` is our usual accumulator variable, initially set to `0`;\\n* `len` will store the size of the provided `grid`;\\n* `tmp` is our helper string, preset to be `len` characters.\\n\\nWe will start parsing the rows first and for each `row` in `grid`, we will:\\n* declare our writer pointer `w` with initial value of `0`;\\n* loop through each value `c` in `row` and:\\n    * write it in `tmp[w]`;\\n    * advance `w` by `1`, ready to write in the next cell;\\n* increase `hashFreq[tmp]` by `1`.\\n\\nWith our hashes so computed for each row, time to do the same for each column `x` in grid and we will:\\n* loop through each row `y` in `grid` and write `grid[y][c]` in `tmp[y]`;\\n* assign the result of `hashFreq.find(tmp)` to `it`;\\n* if we ever found such a value (ie: `it != end(hashFreq)`), we will then increase `res` by that value (ie: `it->second`).\\n\\nOnce done, we can finally `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```cpp\\nusing hashType = u16string;\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        unordered_map<hashType, int> hashFreq;\\n        int res = 0, len = grid.size();\\n        hashType tmp(len, \\'*\\');\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating the row hash\\n            int w = 0;\\n            for (int c: row) tmp[w++] = c;\\n            // storing the hash\\n            hashFreq[tmp]++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // creating the column hash\\n            for (int y = 0; y < len; y++) tmp[y] = grid[y][x];\\n            // checking if we found the same hash before\\n            auto it = hashFreq.find(tmp);\\n            if (it != end(hashFreq)) res += it->second;\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Brag\\n![image.png](https://assets.leetcode.com/users/images/30054297-a35b-49b2-8dc1-25591b39578a_1686687724.9152997.png)\\n\\n\\nNext I tried my other idea, a `Trie` approach, since this again goes well when you need to check your matches in a given dictionary and in a way I was doing that with my string hashing, but could have been done MAYBE better with something like this DS.\\n\\nIn this approach we will create a `Trie` `struct` which will just have two properties:\\n* `matches`, initially set to `0`, will store all the matches we have for a given chain (it will be increased only for the end-of-chain nodes);\\n* `children` is a set of `bucketSize` pointers we will use to connect each node to its descendents on a chain.\\n\\nIn our main function we will proceed similarly to the previous approach, declaring a first `Trie` node `root` and a `Trie` pointer `curr` instead of `tmp`.\\n\\nFor the rows we will then proceed for each character `row` and:\\n* `reset` `curr` to be `root`;\\n* for each value `c`, we will:\\n    * try to get its modulo `bucketSize` by consistently subtracting it `while` `c >= bucketSize` (see the third solution here for my thoughts on actually using `%`);\\n    * check if we do not have `curr->children[c]` and if so, we will create it as a new `Trie` node;\\n    * advance `curr` to be `curr->children[c]`;\\n* finally, having reached the last node of this chain, we will increase `curr->matches` by `1`.\\n\\nAgain, we will proceed specularly for each column, getting `grid[y][x]` as `c` and with two sole differences:\\n* whenever we do not find a node to advance next (ie: `curr->children[c] == NULL`) we will `break`;\\n* at the end of each inner loop, we will increase `res` by `curr->matches` (which is going to be `0` every time we hit `break` before reaching the end of a previously created chain).\\n\\nTweaking `bucketSize` has a MASSIVE effect on performance and turns out using a small enough number (initially I tried `1337`, but quickly run out of memory; it was slow but working with `137` and rather fast for other significantly smaller values, while still burning way more memory than the string hashing approach):\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n^2)$$\\n- \\n```cpp\\nconstexpr int bucketSize = 27;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAs a proof of how expensive is to compute a modulo, this alternative version while I don\\'t just use repeated subtraction to reduce all the numbers above `bucketSize` ran actually a bit slower after several tests (I am sure it would be the opposite with `grid` being populated with larger numbers, but that is really telling):\\n\\n```cpp\\nconstexpr int bucketSize = 19;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                c %= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                c %= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNeedless to say, I wanted to try also with a hashmap for `children`; boring, and way slower and more inefficient than expected:\\n\\n```cpp\\nstruct Trie {\\n    int matches = 0;\\n    unordered_map<int, Trie*> children;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) children[c] = new Trie();\\n                curr = children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) break;\\n                curr = children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Trie",
                    "Hash Function"
                ],
                "code": "```cpp\\nusing hashType = u16string;\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        unordered_map<hashType, int> hashFreq;\\n        int res = 0, len = grid.size();\\n        hashType tmp(len, \\'*\\');\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating the row hash\\n            int w = 0;\\n            for (int c: row) tmp[w++] = c;\\n            // storing the hash\\n            hashFreq[tmp]++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // creating the column hash\\n            for (int y = 0; y < len; y++) tmp[y] = grid[y][x];\\n            // checking if we found the same hash before\\n            auto it = hashFreq.find(tmp);\\n            if (it != end(hashFreq)) res += it->second;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int bucketSize = 27;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                while (c >= bucketSize) c -= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nconstexpr int bucketSize = 19;\\n\\nstruct Trie {\\n    int matches = 0;\\n    Trie *children[bucketSize] = {};\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                c %= bucketSize;\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                c %= bucketSize;\\n                if (!curr->children[c]) break;\\n                curr = curr->children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nstruct Trie {\\n    int matches = 0;\\n    unordered_map<int, Trie*> children;\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>> &grid) {\\n        // support variables\\n        Trie *root = new Trie(), *curr;\\n        int res = 0, len = grid.size();\\n        // parsing rows\\n        for (auto &row: grid) {\\n            // creating Trie path for the row\\n            curr = root;\\n            for (int c: row) {\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) children[c] = new Trie();\\n                curr = children[c];\\n            }\\n            // adding the frequence\\n            curr->matches++;\\n        }\\n        // parsing columns\\n        for (int x = 0; x < len; x++) {\\n            // checking Trie path for the column\\n            curr = root;\\n            for (int y = 0, c; y < len; y++) {\\n                c = grid[y][x];\\n                auto &children = curr->children;\\n                if (children.find(c) == end(children)) break;\\n                curr = children[c];\\n            }\\n            // adding the frequence, if any\\n            res += curr->matches;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633184,
                "title": "easy-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                s.append(grid[i][j]);\\n                s.append(\"+\");\\n            }\\n            String ss = s.toString();\\n            map.put(ss, map.getOrDefault(ss, 0) + 1);\\n        }\\n        int c = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\"+\");\\n            }\\n            String ss = sb.toString();\\n            if(map.containsKey(ss)){\\n                c += map.get(ss);\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String, Integer> map = new HashMap<>();\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder s = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                s.append(grid[i][j]);\\n                s.append(\"+\");\\n            }\\n            String ss = s.toString();\\n            map.put(ss, map.getOrDefault(ss, 0) + 1);\\n        }\\n        int c = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            StringBuilder sb = new StringBuilder();\\n            for(int j = 0; j < grid.length; j++){\\n                sb.append(grid[j][i]);\\n                sb.append(\"+\");\\n            }\\n            String ss = sb.toString();\\n            if(map.containsKey(ss)){\\n                c += map.get(ss);\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632259,
                "title": "simple-and-explained-solution",
                "content": "\\n\\n# Approach\\n1. Initialize a variable count to keep track of the number of equal pairs.\\n2. Iterate over each row in the grid.\\n3. For each row, iterate over each column in the grid.\\n4. Compare the current row with the corresponding column using the getColumn helper function.\\n5. If the row and column are equal (i.e., they contain the same elements in the same order), increment the count variable.\\n6. After iterating over all rows and columns, return the final value of count.\\n\\nThe getColumn helper function extracts the elements from a specific column in the grid and returns them as a separate vector. It loops over each row and retrieves the element at the specified column index, constructing a vector representing the column.\\n\\nBy comparing each row with each corresponding column, the solution correctly counts the number of pairs where a row and column are equal.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int count = 0;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (grid[row] == getColumn(grid, col))\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\nprivate:\\n    vector<int> getColumn(const vector<vector<int>>& grid, int col) {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++) {\\n            column.push_back(grid[i][col]);\\n        }\\n        return column;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int count = 0;\\n\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (grid[row] == getColumn(grid, col))\\n                    count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\nprivate:\\n    vector<int> getColumn(const vector<vector<int>>& grid, int col) {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++) {\\n            column.push_back(grid[i][col]);\\n        }\\n        return column;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631921,
                "title": "java-python-most-easy-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts of solving this problem was to mantain a data structure to store the value vertically and then compare it horizontally\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMap data structure is used to store the value of array in form of String along with their counts i.e. how many times they occur vertically. Then same approach is used while traversing horizontally and after each iteration value of String is fetched from map and added to count.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String,Integer> map=new HashMap<>();\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for( int j=0;j<m;j++){\\n            String s=\"\";\\n            for(int i=0;i<n;i++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            String s=\"\";\\n            for(int j=0;j<m;j++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            System.out.println(s);\\n            if(map.containsKey(s)==true){\\n                System.out.println(s+\" \"+map.get(s));\\n                cnt+=map.get(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        map = {}\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        for j in range(m):\\n            s = \"\"\\n            for i in range(n):\\n                s += str(grid[i][j]) + \",\"\\n            map[s] = map.get(s, 0) + 1\\n        \\n        cnt = 0\\n        for i in range(n):\\n            s = \"\"\\n            for j in range(m):\\n                s += str(grid[i][j]) + \",\"\\n            if s in map:\\n                cnt += map[s]\\n        \\n        return cnt\\n\\n```\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Array",
                    "Hash Table"
                ],
                "code": "```java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<String,Integer> map=new HashMap<>();\\n        int n=grid.length;\\n        int m=grid[0].length;\\n        for( int j=0;j<m;j++){\\n            String s=\"\";\\n            for(int i=0;i<n;i++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            map.put(s,map.getOrDefault(s,0)+1);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            String s=\"\";\\n            for(int j=0;j<m;j++){\\n                s+=grid[i][j]+\",\";\\n            }\\n            System.out.println(s);\\n            if(map.containsKey(s)==true){\\n                System.out.println(s+\" \"+map.get(s));\\n                cnt+=map.get(s);\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        map = {}\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        for j in range(m):\\n            s = \"\"\\n            for i in range(n):\\n                s += str(grid[i][j]) + \",\"\\n            map[s] = map.get(s, 0) + 1\\n        \\n        cnt = 0\\n        for i in range(n):\\n            s = \"\"\\n            for j in range(m):\\n                s += str(grid[i][j]) + \",\"\\n            if s in map:\\n                cnt += map[s]\\n        \\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631670,
                "title": "doubt-regarding-hashmap-solution",
                "content": "Hi, I have attached the reference solution below (Not written by me)\\nWhen we store a vector (or vector converted to string), it\\'s complexity shouldn\\'t be O(N), but the official solution says it\\'s O(1), as they have considered the TC to be O(N^2)- O(N) [Row]* O(N) [Column]* O(1) inserting into map. \\n\\nIn my opinion, it\\'s complexity should be O(N^3) as inserting a string(or vector) into map also takes the size of string(or vector) complexity i.e O(S.size() ==n(in this case), so TC should be O(N^3).\\n\\nCorrect me if I am wrong, thanks!\\n\\n```\\nint equalPairs(vector<vector<int>> &grid)\\n        {\\n            int ans = 0, n = grid.size();\\n            map<vector<int>, int> mp;\\n            for (auto row: grid)\\n                ++mp[row];\\n\\n            for (int i = 0; i < n; ++i)\\n            {\\n                vector<int> v(n);\\n                for (int j = 0; j < n; ++j)\\n                    v[j] = grid[j][i];\\n                \\n                if (mp.find(v) != mp.end())\\n                    ans += mp[v];\\n            }\\n\\n            return ans;\\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "Hi, I have attached the reference solution below (Not written by me)\\nWhen we store a vector (or vector converted to string), it\\'s complexity shouldn\\'t be O(N), but the official solution says it\\'s O(1), as they have considered the TC to be O(N^2)- O(N) [Row]* O(N) [Column]* O(1) inserting into map. \\n\\nIn my opinion, it\\'s complexity should be O(N^3) as inserting a string(or vector) into map also takes the size of string(or vector) complexity i.e O(S.size() ==n(in this case), so TC should be O(N^3).\\n\\nCorrect me if I am wrong, thanks!\\n\\n```\\nint equalPairs(vector<vector<int>> &grid)\\n        {\\n            int ans = 0, n = grid.size();\\n            map<vector<int>, int> mp;\\n            for (auto row: grid)\\n                ++mp[row];\\n\\n            for (int i = 0; i < n; ++i)\\n            {\\n                vector<int> v(n);\\n                for (int j = 0; j < n; ++j)\\n                    v[j] = grid[j][i];\\n                \\n                if (mp.find(v) != mp.end())\\n                    ans += mp[v];\\n            }\\n\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3631552,
                "title": "clean-java-solution",
                "content": "\\n# Approach\\nLoop on each row, col index; then compare each element in the row with the col. \\nEx(grid[row][i] == grid[i][column])\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^3)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        for(int i =0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++)\\n                if (checkIfEqual(i,j,grid)) count++;    \\n        return count;\\n    }\\n\\n    public boolean checkIfEqual(int m, int n,int[][] grid){\\n        for(int i = 0;i<grid.length;i++)\\n            if(grid[m][i]!=grid[i][n]) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int count = 0;\\n        for(int i =0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++)\\n                if (checkIfEqual(i,j,grid)) count++;    \\n        return count;\\n    }\\n\\n    public boolean checkIfEqual(int m, int n,int[][] grid){\\n        for(int i = 0;i<grid.length;i++)\\n            if(grid[m][i]!=grid[i][n]) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631299,
                "title": "finding-the-transpose",
                "content": "### Find the transpose of given grid and solve by comparing each row of grid with each col of the transpose of that grid matrix.\\n---\\n# Python Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        matrix = []\\n        for i in range(n):\\n            rows = []\\n            for j in range(n):\\n                rows.append(grid[j][i])\\n            matrix.append(rows)\\n        count = 0\\n        for i in grid:\\n            for k in matrix:\\n                if i == k:\\n                    count+=1\\n        return count\\n        \\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.\\uD83D\\uDC4D*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        matrix = []\\n        for i in range(n):\\n            rows = []\\n            for j in range(n):\\n                rows.append(grid[j][i])\\n            matrix.append(rows)\\n        count = 0\\n        for i in grid:\\n            for k in matrix:\\n                if i == k:\\n                    count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631034,
                "title": "c-fast-code-88-beat-most-optimal-approach-o-n-2-updated-97-beat-correct-solution",
                "content": "We have to compare rows and arrays, instead of comparing element by element can we do it in O(1) operation?\\nHere in this approach i have used a pair that uniquely identifies each array, the first value of pair is the addition of each value multiplied by its index and the second value is sum of the array.\\nComparing based on this value, we can find the ans in N^2 time instead of N^3 time.\\n(88% beat code)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[i][j];\\n                val += grid[i][j]*j;\\n            }\\n            mp[{val,s}]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[j][i];\\n                val += grid[j][i]*j;\\n            }\\n            if(mp.count({val,s})) ans+=mp[{val,s}];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(N*(log N + N)) = O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Updated:\\nThis approach fails for some test cases that are not present in the leetcode test cases, for ex  [[2,3,4],[6,1,7],[8,5,9]]\\nThanks to @yjian012 for the correction.\\nSo, the correct approach would be use whole vector as key. The code for the same is below (97% beat)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> x;\\n            for(int j=0;j<n;j++){\\n                x.push_back(grid[j][i]);\\n            }\\n            if(mp.count(x)) ans+=mp[x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[i][j];\\n                val += grid[i][j]*j;\\n            }\\n            mp[{val,s}]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int val=0,s=0;\\n            for(int j=0;j<n;j++){\\n                s += grid[j][i];\\n                val += grid[j][i]*j;\\n            }\\n            if(mp.count({val,s})) ans+=mp[{val,s}];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> x;\\n            for(int j=0;j<n;j++){\\n                x.push_back(grid[j][i]);\\n            }\\n            if(mp.count(x)) ans+=mp[x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631004,
                "title": "2-liner-beats-93-simple-python-code-using-zip",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`zip` will allow us to easily convert the grid into an iterable column\\n\\nWe simply use tuples to store the rows into the hash map and we then check the column tuples against the row hash map and count the number of matches.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^2)$\\n When we construct the initial `rows` hashmap it is $O(n^2)$ since we go through each row and to construct each tuple $O(n)$(? im not sure)\\n\\nLikewise it is $O(n^2)$ for when we are checking and also the time complexity of `zip` (If all the tuple conversion time complexity is $O(n)$)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDepends on the implementation of the hash map\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = defaultdict(int)\\n\\n        for row in grid:\\n            rows[tuple(row)] += 1\\n        \\n        match = 0\\n        for col in zip(*grid):\\n            if col in rows:\\n                match += rows[col]\\n        \\n        return match\\n```\\n\\n## 2 Liner\\nUsing `Counter` as well as list comprehension we can get a significantly shorter piece of code that can run fast\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = Counter([tuple(row) for row in grid])\\n        return sum([rows[col] for col in zip(*grid)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = defaultdict(int)\\n\\n        for row in grid:\\n            rows[tuple(row)] += 1\\n        \\n        match = 0\\n        for col in zip(*grid):\\n            if col in rows:\\n                match += rows[col]\\n        \\n        return match\\n```\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rows = Counter([tuple(row) for row in grid])\\n        return sum([rows[col] for col in zip(*grid)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630966,
                "title": "rust-elixir-hash-map-solution",
                "content": "Elixir\\'s code is very simple for doing this kind of operations.\\n# Code\\n```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut hash = HashMap::<&[i32], i32>::new();\\n        for row in grid.iter() {\\n            *hash.entry(row).or_insert(0) += 1;\\n        }\\n        let mut ans = 0;\\n        let mut v = vec![0; grid.len()];\\n        for j in 0..grid.len() {\\n            for i in 0..grid.len() {\\n                v[i] = grid[i][j];\\n            }\\n            if let Some(&x) = hash.get(&v[..]) {\\n                ans += x;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec equal_pairs(grid :: [[integer]]) :: integer\\n  def equal_pairs(grid) do\\n    Enum.frequencies(grid)\\n    |> then(fn map ->\\n      Enum.zip_with(grid, &(&1))\\n      |> Enum.map(&(Map.get(map, &1, 0)))\\n    end)\\n    |> Enum.sum()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Hash Table"
                ],
                "code": "```Rust []\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut hash = HashMap::<&[i32], i32>::new();\\n        for row in grid.iter() {\\n            *hash.entry(row).or_insert(0) += 1;\\n        }\\n        let mut ans = 0;\\n        let mut v = vec![0; grid.len()];\\n        for j in 0..grid.len() {\\n            for i in 0..grid.len() {\\n                v[i] = grid[i][j];\\n            }\\n            if let Some(&x) = hash.get(&v[..]) {\\n                ans += x;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec equal_pairs(grid :: [[integer]]) :: integer\\n  def equal_pairs(grid) do\\n    Enum.frequencies(grid)\\n    |> then(fn map ->\\n      Enum.zip_with(grid, &(&1))\\n      |> Enum.map(&(Map.get(map, &1, 0)))\\n    end)\\n    |> Enum.sum()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3630965,
                "title": "c-best-solution-2-approach-easy-to-understand",
                "content": "\\n# Approach\\nBrute force\\n\\n# Code\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vvi row, col;\\n        for(auto it : grid) row.push_back(it);\\n        for(int i=0; i<n; i++)  {\\n            vi temp;\\n            for(int j=0; j<n; j++)  \\n                temp.push_back(grid[j][i]);\\n            col.push_back(temp);\\n        }\\n\\n        int cnt = 0;\\n        for(auto it : row) for(auto x : col)\\n            if(x == it) cnt++;\\n\\n        return cnt;\\n    }\\n};\\n```\\n\\n# Approach\\nNo extra Space two pointer\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), cnt = 0;\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<n; j++)  {\\n                int k = 0;\\n                while(k < n)    {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    k++;\\n                }\\n                if(k == n)  cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vvi row, col;\\n        for(auto it : grid) row.push_back(it);\\n        for(int i=0; i<n; i++)  {\\n            vi temp;\\n            for(int j=0; j<n; j++)  \\n                temp.push_back(grid[j][i]);\\n            col.push_back(temp);\\n        }\\n\\n        int cnt = 0;\\n        for(auto it : row) for(auto x : col)\\n            if(x == it) cnt++;\\n\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), cnt = 0;\\n        for(int i=0; i<n; i++)  {\\n            for(int j=0; j<n; j++)  {\\n                int k = 0;\\n                while(k < n)    {\\n                    if(grid[i][k] != grid[k][j]) break;\\n                    k++;\\n                }\\n                if(k == n)  cnt++;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630907,
                "title": "c-easy-implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        for (int i = 0; i < n; i += 1)\\n            for (int j = 0; j < n; j += 1) {\\n                int ok = 1;\\n                for (int k = 0; k < n and ok; k += 1)\\n                    ok = grid[i][k] == grid[k][j];\\n                res += ok;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size(), res = 0;\\n        for (int i = 0; i < n; i += 1)\\n            for (int j = 0; j < n; j += 1) {\\n                int ok = 1;\\n                for (int k = 0; k < n and ok; k += 1)\\n                    ok = grid[i][k] == grid[k][j];\\n                res += ok;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630785,
                "title": "short-ruby-solution-with-explanation",
                "content": "# Intuition\\nCount how often each row appears.  Total the number of rows matching each column.\\n\\n# Approach\\n1. Create a hash where rows are keys and their frequencies are values.  (We\\'re using a hash instead of a set because a row can appear multiple times.)\\n2. Initialize total to 0.\\n3. Transpose the grid to iterate through the columns.  For each column, add the number of matching rows to total.\\n4. Return the total.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m*n)$$\\n\\n# Code\\n```\\ndef equal_pairs(grid)\\n    rows = grid.tally\\n    total = 0\\n\\n    grid.transpose.each do |col|\\n        total += rows[col] if rows[col]\\n    end\\n\\n    total\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef equal_pairs(grid)\\n    rows = grid.tally\\n    total = 0\\n\\n    grid.transpose.each do |col|\\n        total += rows[col] if rows[col]\\n    end\\n\\n    total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3586137,
                "title": "golang-map-solution-without-using-strings-conversion-fast-and-memory-effective",
                "content": "# Intuition\\nTo find number of pairs it is enough to count all variants for rows, and then compare it with columns\\n# Approach\\nTo faster comparison we use golang map. We can not use slice as key, so replace it with array $[200]int$ ( other variant is to convert slice in some string). We add every row in map, and then we run through all columns and look for it in map.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ to build all columns\\n\\n- Space complexity:\\n $$O(n)$$ - we use map with mostly $n$ different keys\\n\\n# Code\\n```\\nfunc equalPairs(grid [][]int) int {\\n    n:=len(grid)\\n    m:=make( map[[200]int]int)\\n    arr:=[200]int{}\\n    for i:=0;i<n;i++{\\n        copy(arr[:],grid[i])\\n        m[arr]++\\n    }\\n    res:=0\\n\\n    for i:=0;i<n;i++{\\n        arr = [200]int{}\\n        for j:=0;j<n;j++{ // copy column to arr\\n            arr[j]=grid[j][i]\\n        }\\n        if v,ok:=m[arr];ok{\\n            res+=v\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nfunc equalPairs(grid [][]int) int {\\n    n:=len(grid)\\n    m:=make( map[[200]int]int)\\n    arr:=[200]int{}\\n    for i:=0;i<n;i++{\\n        copy(arr[:],grid[i])\\n        m[arr]++\\n    }\\n    res:=0\\n\\n    for i:=0;i<n;i++{\\n        arr = [200]int{}\\n        for j:=0;j<n;j++{ // copy column to arr\\n            arr[j]=grid[j][i]\\n        }\\n        if v,ok:=m[arr];ok{\\n            res+=v\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552258,
                "title": "golang-trie",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\ntype Trie struct {\\n    Count int\\n    Children map[int]*Trie\\n}\\n\\nfunc equalPairs(grid [][]int) int {\\n    root := &Trie{Children: make(map[int]*Trie)}\\n\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    // O(n) * O(m)\\n    for c := 0; c < n; c++ {\\n        insert(root, c, m, grid)\\n    }\\n\\n    count := 0\\n    // O(m) * O(n)\\n    for r := 0; r < m; r++ {\\n        count += search(root, r, n, grid)\\n    }\\n\\n    return count\\n}\\n\\n// O(m)\\nfunc insert(node *Trie, c, m int, grid [][]int) {\\n    for r := 0; r < m; r++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            node.Children[idx] = &Trie{Children: make(map[int]*Trie)}\\n        }\\n        node = node.Children[idx]\\n    }\\n    node.Count++\\n}\\n\\n// O(n)\\nfunc search(node *Trie, r, n int, grid [][]int) int {\\n    for c := 0; c < n; c++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            return 0\\n        }\\n        node = node.Children[idx]\\n    }\\n    return node.Count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Trie struct {\\n    Count int\\n    Children map[int]*Trie\\n}\\n\\nfunc equalPairs(grid [][]int) int {\\n    root := &Trie{Children: make(map[int]*Trie)}\\n\\n    m := len(grid)\\n    n := len(grid[0])\\n\\n    // O(n) * O(m)\\n    for c := 0; c < n; c++ {\\n        insert(root, c, m, grid)\\n    }\\n\\n    count := 0\\n    // O(m) * O(n)\\n    for r := 0; r < m; r++ {\\n        count += search(root, r, n, grid)\\n    }\\n\\n    return count\\n}\\n\\n// O(m)\\nfunc insert(node *Trie, c, m int, grid [][]int) {\\n    for r := 0; r < m; r++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            node.Children[idx] = &Trie{Children: make(map[int]*Trie)}\\n        }\\n        node = node.Children[idx]\\n    }\\n    node.Count++\\n}\\n\\n// O(n)\\nfunc search(node *Trie, r, n int, grid [][]int) int {\\n    for c := 0; c < n; c++ {\\n        idx := grid[r][c]\\n        if _, ok := node.Children[idx]; !ok {\\n            return 0\\n        }\\n        node = node.Children[idx]\\n    }\\n    return node.Count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497467,
                "title": "c-easy-approach-brut-force-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,c=0,n=grid.size();\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                int k=0;\\n                while(k!=n && grid[i][k]==grid[k][j])\\n                {\\n                    k++;\\n                }\\n                if(k==n)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int i,j,c=0,n=grid.size();\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                int k=0;\\n                while(k!=n && grid[i][k]==grid[k][j])\\n                {\\n                    k++;\\n                }\\n                if(k==n)\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420644,
                "title": "python3",
                "content": "![image.png](https://assets.leetcode.com/users/images/11c9dc60-d43c-47a3-98f7-2bbb206ba35f_1681579473.8935993.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count=0\\n        lst=[]\\n        for i in zip(*grid):\\n            lst.append(list(i))\\n        for i in range(len(lst)):\\n            for j in grid:\\n                if lst[i]==j:\\n                    count+=1\\n                else:\\n                    count+=0\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count=0\\n        lst=[]\\n        for i in zip(*grid):\\n            lst.append(list(i))\\n        for i in range(len(lst)):\\n            for j in grid:\\n                if lst[i]==j:\\n                    count+=1\\n                else:\\n                    count+=0\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282176,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, vector<int>> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]].push_back(i);\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col].size();\\n        }\\n        return sum;\\n\\n    }\\n};\\n```\\n\\nOr\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]]++;\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, vector<int>> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]].push_back(i);\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col].size();\\n        }\\n        return sum;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> mp;\\n        for(int i = 0; i < grid.size(); i++) mp[grid[i]]++;\\n        int sum = 0;\\n        for(int i = 0; i < grid[0].size(); i++){\\n            vector<int> col;\\n            for(int j = 0; j < grid.size(); j++){\\n                col.push_back(grid[j][i]);\\n            }\\n            sum += mp[col];\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264514,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int > m ; \\n        int res = 0 ; \\n        for(int i = 0; i<grid.size();i++)\\n        {\\n            vector<int> curr ; \\n            for(int j = 0; j<grid.size();j++){\\n\\n            curr.push_back(grid[i][j]);\\n            }\\n           \\n           m[curr]++;\\n        }\\n        \\n     \\n        cout<<endl;\\n        for(int j = 0 ; j<grid.size();j++)\\n        {\\n            vector<int> temp; \\n            for(int i = 0 ; i< grid.size();i++)\\n            temp.push_back(grid[i][j]);\\n            \\n            if(m.find(temp)!=m.end())\\n            res += m[temp];\\n        }\\n        \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int > m ; \\n        int res = 0 ; \\n        for(int i = 0; i<grid.size();i++)\\n        {\\n            vector<int> curr ; \\n            for(int j = 0; j<grid.size();j++){\\n\\n            curr.push_back(grid[i][j]);\\n            }\\n           \\n           m[curr]++;\\n        }\\n        \\n     \\n        cout<<endl;\\n        for(int j = 0 ; j<grid.size();j++)\\n        {\\n            vector<int> temp; \\n            for(int i = 0 ; i< grid.size();i++)\\n            temp.push_back(grid[i][j]);\\n            \\n            if(m.find(temp)!=m.end())\\n            res += m[temp];\\n        }\\n        \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3239054,
                "title": "c-simple-clear-concise-easy-to-understand-single-hashmap-matrix-code-quality",
                "content": "\\n# Code\\n**Bruteforce:-**\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<string, int> rowmap;\\n        map<string, int> colmap;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int ans = 0;\\n        for (int i=0; i<row; i++) {\\n            string rows;\\n            string cols;\\n            for (int j=0; j<col; j++) {\\n                rows += to_string(grid[i][j]) + \"-\";\\n                cols += to_string(grid[j][i]) + \"-\";\\n            }\\n            rowmap[rows]++;\\n            colmap[cols]++;\\n        }\\n        for (auto &it:rowmap) {\\n            if (colmap.find(it.first) != colmap.end()) {\\n                ans += (it.second * colmap[it.first]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Optimized:-**\\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>, Integer> hashmap = new HashMap<>();\\n        int n = grid.length, ans = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> c = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                c.add(j, grid[i][j]);\\n            }\\n            hashmap.put(c, hashmap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> curr = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                curr.add(j, grid[j][i]);\\n            }\\n            ans += hashmap.getOrDefault(curr, 0);\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        hashmap = defaultdict(int)\\n        n, ans = len(grid), 0\\n\\n        for i in range(n):\\n            hashmap[str(grid[i])] += 1\\n        \\n        for i in range(n):\\n            curr = []\\n            for j in range(n):\\n                curr.append(grid[j][i])\\n            ans += hashmap[str(curr)]\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<string, int> rowmap;\\n        map<string, int> colmap;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int ans = 0;\\n        for (int i=0; i<row; i++) {\\n            string rows;\\n            string cols;\\n            for (int j=0; j<col; j++) {\\n                rows += to_string(grid[i][j]) + \"-\";\\n                cols += to_string(grid[j][i]) + \"-\";\\n            }\\n            rowmap[rows]++;\\n            colmap[cols]++;\\n        }\\n        for (auto &it:rowmap) {\\n            if (colmap.find(it.first) != colmap.end()) {\\n                ans += (it.second * colmap[it.first]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>, int> hashmap;\\n        int ans = 0;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        for (int i=0; i<row; i++) {\\n            hashmap[grid[i]]++;\\n        }\\n        for (int j=0; j<col; j++) {\\n            vector<int> curr;\\n            for (int i=0; i<row; i++) {\\n                curr.emplace_back(grid[i][j]);\\n            }\\n            ans += hashmap[curr];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>, Integer> hashmap = new HashMap<>();\\n        int n = grid.length, ans = 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> c = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                c.add(j, grid[i][j]);\\n            }\\n            hashmap.put(c, hashmap.getOrDefault(c, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            List<Integer> curr = new ArrayList<>(n);\\n            for (int j = 0; j < n; ++j) {\\n                curr.add(j, grid[j][i]);\\n            }\\n            ans += hashmap.getOrDefault(curr, 0);\\n        }\\n\\n        return ans;\\n\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        hashmap = defaultdict(int)\\n        n, ans = len(grid), 0\\n\\n        for i in range(n):\\n            hashmap[str(grid[i])] += 1\\n        \\n        for i in range(n):\\n            curr = []\\n            for j in range(n):\\n                curr.append(grid[j][i])\\n            ans += hashmap[str(curr)]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169755,
                "title": "javascript-solution-with-hashmap",
                "content": "### Want to say thank you if you give me a thumbs up\\n###### this solution is $$O(n^2)$$ time and space, if I found more better solution I\\'ll come back and update it.\\n# Intuition\\n1. Question to find row has same value with column\\n2. We can use each row join as key, then  column join as value to check has same value with row\\n3. Here have issues\\n    >* **What if a row shows in 2 or more times**\\n     -> answer we set value as an array store two value [rowShowTime - 1, columnMetcahRowTimes]\\n    >* **What if we have [11,1] [1,11] when join they are all equal to 111 but 11,1 != 1,11**\\n    -> answer we join with \\',\\' so  [11,1] [1,11] will became \"11,1\" and \"1,11\"\\n\\n4. Then we just return result += hashMap.value(value[0] * value[1]) why * not +, because the value[0] is show times\\n\\n# Approach\\nHere we use hashMap\\n1. initial hashMap, then loop through grid assign to hashMap key as row.join(\\',\\') value = [0,0] if that key already exist value[0] += 1\\n2. loop through grid i = 0; i < grid[0].length; i++, because its grid, so each subarray has same length (we want each the column += eachRow[j][i] to get column sum).\\n    * let column = [] //use array not string because in js string is immutable, evertime string += 1 need to create a new string.\\n    * while loop j < grid.length //idea is to loop vertically which is column\\n        * column.push(eachRow[j][i]) \\n        * j++\\n        * column = column.join(\\',\\')\\n        * check if hashMap has value then value += 1 else continue\\n\\n3. finally we just have to loop through hashMap value\\n    * result += value[0] * value[1]\\n4. return result\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    let hashMap = new Map()\\n    for(let i = 0; i < grid.length; i++){\\n        let rowRef = grid[i].join(\\',\\')\\n        if(!hashMap.has(rowRef)){\\n            hashMap.set(rowRef, [1, 0])\\n        }else{\\n            hashMap.get(rowRef)[0] = hashMap.get(rowRef)[0] + 1\\n        }\\n    }\\n\\n        \\n\\n    for(let i = 0; i < grid[0].length; i++){\\n        let column = []\\n        let j = 0\\n\\n        while(j < grid.length){\\n            column.push(grid[j][i])\\n            j++\\n        }\\n\\n        let columnRef = column.join(\\',\\')\\n        console.log(columnRef)\\n\\n        if(hashMap.has(columnRef)){ //not use get becaue when get value == 0, 0 is false false won\\'t go in condation\\n            hashMap.get(columnRef)[1] = hashMap.get(columnRef)[1] + 1\\n        }\\n    }\\n\\n    let result = 0\\n    for(const value of hashMap.values()){\\n        result += (value[0] * value[1])\\n    }\\n\\n    return result\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar equalPairs = function(grid) {\\n    let hashMap = new Map()\\n    for(let i = 0; i < grid.length; i++){\\n        let rowRef = grid[i].join(\\',\\')\\n        if(!hashMap.has(rowRef)){\\n            hashMap.set(rowRef, [1, 0])\\n        }else{\\n            hashMap.get(rowRef)[0] = hashMap.get(rowRef)[0] + 1\\n        }\\n    }\\n\\n        \\n\\n    for(let i = 0; i < grid[0].length; i++){\\n        let column = []\\n        let j = 0\\n\\n        while(j < grid.length){\\n            column.push(grid[j][i])\\n            j++\\n        }\\n\\n        let columnRef = column.join(\\',\\')\\n        console.log(columnRef)\\n\\n        if(hashMap.has(columnRef)){ //not use get becaue when get value == 0, 0 is false false won\\'t go in condation\\n            hashMap.get(columnRef)[1] = hashMap.get(columnRef)[1] + 1\\n        }\\n    }\\n\\n    let result = 0\\n    for(const value of hashMap.values()){\\n        result += (value[0] * value[1])\\n    }\\n\\n    return result\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900905,
                "title": "java-2-hashmaps-clean-and-simple",
                "content": "# Please Upvote :D\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/51265fcd-5172-4e47-a6ae-2fb7c55b8eb0_1670755996.5962312.png)\\n\\n---\\n\\n``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n\\n        Map<String, Integer> rows = new HashMap<>();\\n        Map<String, Integer> cols = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder r = new StringBuilder();\\n            StringBuilder c = new StringBuilder();\\n\\n            for (int j = 0; j < n; j++) {\\n                r.append(grid[i][j]).append(\\' \\');\\n                c.append(grid[j][i]).append(\\' \\');\\n            }\\n\\n            rows.put(r.toString(), rows.getOrDefault(r.toString(), 0) + 1);\\n            cols.put(c.toString(), cols.getOrDefault(c.toString(), 0) + 1);\\n        }\\n\\n        int count = 0;\\n\\n        for (String s : rows.keySet()) {\\n            if (cols.containsKey(s)) {\\n                count += rows.get(s) * cols.get(s);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 2) + O(n) ~ O(n ^ 2)\\n// SC: O(n + n) ~ O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n\\n        Map<String, Integer> rows = new HashMap<>();\\n        Map<String, Integer> cols = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            StringBuilder r = new StringBuilder();\\n            StringBuilder c = new StringBuilder();\\n\\n            for (int j = 0; j < n; j++) {\\n                r.append(grid[i][j]).append(\\' \\');\\n                c.append(grid[j][i]).append(\\' \\');\\n            }\\n\\n            rows.put(r.toString(), rows.getOrDefault(r.toString(), 0) + 1);\\n            cols.put(c.toString(), cols.getOrDefault(c.toString(), 0) + 1);\\n        }\\n\\n        int count = 0;\\n\\n        for (String s : rows.keySet()) {\\n            if (cols.containsKey(s)) {\\n                count += rows.get(s) * cols.get(s);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 2) + O(n) ~ O(n ^ 2)\\n// SC: O(n + n) ~ O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773068,
                "title": "c-easy-to-understand-10-faster-than-most-voted",
                "content": "#  **Please upvote if it helps!!\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> mp;\\n        int count=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n           mp[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> vec;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                vec.push_back(grid[j][i]);\\n            }\\n            if(mp.find(vec)!=mp.end() )\\n            {\\n                count+=mp[vec];\\n            }\\n        }\\n        \\n     \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> mp;\\n        int count=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n           mp[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> vec;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                vec.push_back(grid[j][i]);\\n            }\\n            if(mp.find(vec)!=mp.end() )\\n            {\\n                count+=mp[vec];\\n            }\\n        }\\n        \\n     \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444509,
                "title": "c-using-map-easy-to-understand",
                "content": "```\\nclass Solution {\\n    // Row\\n    vector<int> get_row(int i, vector<vector<int>>& v){\\n        return v[i];\\n    }\\n    // Cloumn\\n    vector<int> get_col(int j, vector<vector<int>>& v){\\n        vector<int> u;\\n        int l = v.size();\\n        for(int i=0; i<l; ++i){\\n            u.push_back(v[i][j]);\\n        }\\n        return u;\\n    }\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> m;\\n        int l = grid.size();\\n        for(int i=0; i<l; ++i){\\n            vector<int> v = get_row(i,grid);\\n            m[v]++;\\n        }\\n        int c=0;\\n        for(int j=0; j<l; ++j){\\n            vector<int> v = get_col(j,grid);\\n            if(m.find(v) != m.end()) c += m[v];\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    // Row\\n    vector<int> get_row(int i, vector<vector<int>>& v){\\n        return v[i];\\n    }\\n    // Cloumn\\n    vector<int> get_col(int j, vector<vector<int>>& v){\\n        vector<int> u;\\n        int l = v.size();\\n        for(int i=0; i<l; ++i){\\n            u.push_back(v[i][j]);\\n        }\\n        return u;\\n    }\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> m;\\n        int l = grid.size();\\n        for(int i=0; i<l; ++i){\\n            vector<int> v = get_row(i,grid);\\n            m[v]++;\\n        }\\n        int c=0;\\n        for(int j=0; j<l; ++j){\\n            vector<int> v = get_col(j,grid);\\n            if(m.find(v) != m.end()) c += m[v];\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403516,
                "title": "c-rust-c-rolling-hash-o-n-2-time-o-n-space",
                "content": "##### C++\\n\\n```c++\\nconst int base = 5119;\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    vector<long long> row_hash(n);\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * base + grid[i][j]) % mod;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * base + grid[i][j]) % mod;\\n\\n      for (int i = 0; i < n; i++) res += int(row_hash[i] == h);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\\n\\n---\\n\\n##### Rust\\n```rust\\nconst BASE: i64 = 5119;\\nconst MOD: i64 = 1000000007;\\n\\nimpl Solution {\\n  pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n    let n = grid.len();\\n    let mut row_hash: Vec<i64> = vec![0; n];\\n\\n    let mut res = 0;\\n\\n    // rows\\n    for i in 0..n {\\n      let mut h: i64 = 0;\\n      for j in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for j in 0..n {\\n      let mut h: i64 = 0;\\n      for i in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n\\n      for i in 0..n {\\n        if row_hash[i] == h { res += 1; }\\n      }\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n\\n---\\n\\n##### C#\\n```cs\\npublic class Solution {\\n  const int BASE = 5119;\\n  const int MOD = 1000000007;\\n\\n  public int EqualPairs(int[][] grid) {\\n    int n = grid.Length;\\n    long[] row_hash = new long[n];\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * BASE + grid[i][j]) % MOD;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * BASE + grid[i][j]) % MOD;\\n\\n      for (int i = 0; i < n; i++) res += row_hash[i] == h ? 1 : 0;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#",
                    "Rolling Hash"
                ],
                "code": "```c++\\nconst int base = 5119;\\nconst int mod = 1e9 + 7;\\n\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    int n = grid.size();\\n    vector<long long> row_hash(n);\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * base + grid[i][j]) % mod;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * base + grid[i][j]) % mod;\\n\\n      for (int i = 0; i < n; i++) res += int(row_hash[i] == h);\\n    }\\n\\n    return res;\\n  }\\n};\\n```\n```rust\\nconst BASE: i64 = 5119;\\nconst MOD: i64 = 1000000007;\\n\\nimpl Solution {\\n  pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n    let n = grid.len();\\n    let mut row_hash: Vec<i64> = vec![0; n];\\n\\n    let mut res = 0;\\n\\n    // rows\\n    for i in 0..n {\\n      let mut h: i64 = 0;\\n      for j in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for j in 0..n {\\n      let mut h: i64 = 0;\\n      for i in 0..n {\\n        h = (h * BASE + grid[i][j] as i64) % MOD;\\n      }\\n\\n      for i in 0..n {\\n        if row_hash[i] == h { res += 1; }\\n      }\\n    }\\n\\n    return res;\\n  }\\n}\\n```\n```cs\\npublic class Solution {\\n  const int BASE = 5119;\\n  const int MOD = 1000000007;\\n\\n  public int EqualPairs(int[][] grid) {\\n    int n = grid.Length;\\n    long[] row_hash = new long[n];\\n\\n    int res = 0;\\n\\n    // rows\\n    for (int i = 0; i < n; i++) {\\n      long h = 0;\\n      for (int j = 0; j < n; j++) h = (h * BASE + grid[i][j]) % MOD;\\n      row_hash[i] = h;\\n    }\\n\\n    // cols\\n    for (int j = 0; j < n; j++) {\\n      long h = 0;\\n      for (int i = 0; i < n; i++) h = (h * BASE + grid[i][j]) % MOD;\\n\\n      for (int i = 0; i < n; i++) res += row_hash[i] == h ? 1 : 0;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356230,
                "title": "c-easy-solution",
                "content": "**Pls upvote if it\\'s helpful**\\n```\\nint equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int>mp ;\\n        int res=0 ;\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            vector<int>ds ;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                ds.push_back(grid[i][j])  ;\\n            }\\n            mp[ds]++ ;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int>ds;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                ds.push_back(grid[i][j]) ;\\n            }\\n            if(mp.find(ds)!=mp.end())\\n                res+=mp[ds] ;\\n        }\\n        return res ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid)\\n    {\\n        map<vector<int>,int>mp ;\\n        int res=0 ;\\n        for(int j=0;j<grid[0].size();j++)\\n        {\\n            vector<int>ds ;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                ds.push_back(grid[i][j])  ;\\n            }\\n            mp[ds]++ ;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int>ds;\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                ds.push_back(grid[i][j]) ;\\n            }\\n            if(mp.find(ds)!=mp.end())\\n                res+=mp[ds] ;\\n        }\\n        return res ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2352684,
                "title": "python-radix-sort-solution-explained-o-n-2",
                "content": "## Radix Sort\\n(skip this section if you\\'re already familiar with radix sort)\\n\\nRadix sort is a sorting algorithm which works by bucket sorting the items in the list based on a specific *bit* in the item and then recombining the buckets. This iteration is repeated for each *bit* in the data (I use the term *bit* loosely since it could also be a character in a string, or a base 10 digit, or really any other piece of serialized information in the item). Here is an example of radix sort being used to sort a list of words:\\n\\nwords = [horse, apple, heard, candy, pitch, think, women, rules]\\n\\n1. Bucket Sort by 5th/Last Letter\\nbuckets = {d: [heard], e: [horse, apple], h: [pitch], k: [think], n: [women], s: [rules], y: [candy]}\\nwords = [heard, horse, apple, pitch, think, women, rules, candy]\\n(Note how horse is in front of apple because it appeared first in the original word list. The order of words being preserved in each step is key to the success of this algorithm)\\n\\n2. Bucket Sort by 4th Letter\\nbuckets = {c: [pitch], d: [candy], e: [women, rules], l: [apple], n: [think], r: [heard], s: [horse]}\\n[pitch, candy, women, rules, apple, think, heard, horse]\\n\\n3. Bucket Sort by 3rd Letter\\nbuckets = {n: [candy], p: [apple], l: [rules], m: [women], n: [think], r: [heard], s: [horse], t: [pitch]}\\nwords = [candy, apple, rules, women, think, heard, horse, pitch]\\n\\n4. Bucket Sort by 2nd Letter\\nbuckets = {a: [candy], e: [heard], h: [think], i: [pitch], o: [women, horse], p: [apple], u: [rules]}\\nwords = [candy, heard, think, pitch, women, horse, apple, rules]\\n\\n5. Bucket Sort by 1st Letter\\nbuckets = {a: [apple], c: [candy], h: [heard, horse], p: [pitch], r: [rules], t: [think], w: [women]}\\nwords = [apple, candy, heard, horse, pitch, rules, think, women]\\n\\nRadix sort runs in quasilinear time (O(k\\\\*n) where k is the max number of *bits* in any of the items being sorted). Because it is not comparison-based, it is not limited by the O(nlogn), but in practice this rarely leads to real-world performance improvements over algorithms like quicksort and merge sort. That being said, it has found real-world uses sorting physical objects (like index cards), where comparison sorting and long-range swaps are more difficult to implement.\\n\\nThe auxillary space required by the radix sort algorithm is O(n) because it needs to allocate enough space in the buckets to hold all the items being sorted.\\n\\n## The Algorithm\\nTo solve this problem I modified the radix sort algorithm by never re-combining the groups (instead, each existing group gets split into new groups where all items in the group are equal). I also pruned any groups which only had 1 item in them, since single item groups can never create pairs down the road. To keep the rows and colums separated the list of states included a bit to mark if an item was a row (0) or a column (1).\\n\\n### Example 1\\n\\ngrid = [\\n\\t[3, 2, 1],\\n    [1, 7, 6],\\n    [2, 7, 7]\\n]\\n\\n#### Initial Positions:\\n* rows: [(0, 0), (1, 0), (2, 0)] - these point to the start of each row\\n* columns: [(0, 0), (0, 1), (0, 2)] - these point to the start of each column\\n* positions: [(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)] - note how the first element in each tuple denotes if it\\'s a row or column\\n* buckets = [positions] = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)]]\\n\\n#### Iterations:\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2)]]\\n\\t* Keys = [[3, 1, 2, 3, 2, 1]]\\n\\t* Groups by Key = \\n\\t\\t3: [(0, 0, 0), (1, 0, 0)] - 1 potential pairs\\n\\t\\t2: [(0, 2, 0), (1, 0, 1)] - 1 potential pairs\\n\\t\\t1: [(0, 1, 0), (1, 0, 2)] - 1 potential pairs\\n\\t* Next States by Key = \\n\\t\\t3: [(0, 0, 1), (1, 1, 0)]\\n\\t\\t2: [(0, 2, 1), (1, 1, 1)]\\n\\t\\t1: [(0, 1, 1), (1, 1, 2)]\\n\\t* New Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\t* Keys = [[2, 1], [7, 7], [7, 6]]\\n\\t* First Bucket by Key = \\n\\t\\t2: [(0, 0, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t1: [(1, 1, 0)] - 0 potential pairs -> prune when computing next states\\n\\t* Second Bucket by Key = \\n\\t\\t7: [(0, 2, 1), (1, 1, 1)] - 1 potential pair\\n\\t* Third Bucket by Key = \\n\\t\\t7: [(0, 1, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t6: [(1, 1, 2)] - 0 potential pairs -> prune when computing next states\\n\\t* Next States by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n3. Initial Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\t* Keys = [[7, 7]]\\n\\t* First Bucket by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)] - 1 potential pair\\n\\t* Next States by Key (unnecessary at this step) = \\n\\t\\t7: [(0, 2, 3), (1, 3, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n#### Count Pairs\\nThere is only 1 remainig bucket, and in that bucket there are 2 items: 1 row, and 1 column. To compute the number of pairs this bucket creates we multiply the number of rows by the number of columns: pairs = 1\\\\*1 = 1. Since there are no other remaining buckets, the result is 1.\\n\\n### Example 2\\n\\ngrid = [\\n\\t[3, 1, 2, 2]\\n\\t[1, 4, 4, 5]\\n\\t[2, 4, 2, 2]\\n\\t[2, 4, 2, 2]\\n]\\n\\n#### Iterations\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 3, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t3 : [(0, 0, 1), (1, 1, 0)] - 1 potential pair - current path: 3\\n\\t\\t1 : [(0, 1, 1), (1, 1, 1)] - 1 potential pair - current path: 1\\n\\t\\t2 : [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)] - 4 potential pairs\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 1, 1), (1, 1, 1)], [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t1 : [(0, 0, 2), (1, 2, 0)] - 1 potential pair - current path: 3-1\\n\\t* Bucket 2:\\n\\t\\t4 : [(0, 1, 2), (1, 2, 1)] - 1 potential pair - current path: 1-4\\n\\t* Bucket 3:\\n\\t\\t4 : [(0, 2, 2), (0, 3, 2), (1, 2, 2)] - 2 potential pairs - current path: 2-4\\n\\t\\t5 : [(1, 2, 3)] - 0 potential pairs - current path: 2-5 - prune from next iteration\\n3. Initial Buckets = [[(0, 0, 2), (1, 2, 0)], [(0, 1, 2), (1, 2, 1)], [(0, 2, 2), (0, 3, 2), (1, 2, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1: \\n\\t\\t2 : [(0, 0, 3), (1, 3, 0)] - 1 potential pair - current path: 3-1-2\\n\\t* Bucket 2: \\n\\t\\t4 : [(0, 1, 3), (1, 3, 1)] - 1 potential pair - current path: 1-4-4\\n\\t* Bucket 3: \\n\\t\\t2 : [(0, 2, 3), (0, 3, 3), (1, 3, 2)] - 2 potential pairs - current path: 2-4-2\\n4. Initial Buckets = [[(0, 0, 3), (1, 3, 0)], [(0, 1, 3), (1, 3, 1)], [(0, 2, 3), (0, 3, 3), (1, 3, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t2 : [(0, 0, 4), (1, 4, 0)] - 1 potential pair - current path: 3-1-2-2\\n\\t* Bucket 2:\\n\\t\\t5 : [(0, 1, 4)] - 0 potential pairs - current path: 1-4-4-5 - prune from final bucket list\\n\\t\\t4 : [(1, 4, 1)] - 0 potential pairs - current path: 1-4-4-4 - prune from final bucket list\\n\\t* Bucket 3:\\n\\t\\t2 : [(0, 2, 4), (0, 3, 4), (1, 4, 2)] - 2 potential pairs - current path: 2-4-2-2\\n\\n#### Count Pairs\\nThe final bucket list is: [[(0, 0, 4), (1, 4, 0)], [(0, 2, 4), (0, 3, 4), (1, 4, 2)]]\\n* Bucket 1: 1 row, 1 column -> pairs contributed: 1\\\\*1 = 1\\n* Bucket 2: 2 rows, 1 column -> paris contributed: 2\\\\*1 = 2\\nFrom this we know the total number of pairs found is 1 + 2 = 3\\n\\n### Code\\nFirst Run Performance: 609 ms/19 MB\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Radix Sort the Row/Column Indecies (maintaining the Separate buckets) - O(n^2)\\n\\t\\t\\t# positions are stored as a tuple containing: (direction, row index, column index)\\n\\t\\t\\tpositions = [(0, i, 0) for i in range(n)] # all starting row positions\\n\\t\\t\\tpositions.extend((1, 0, j) for j in range(n)) # all starting column positions\\n\\t\\t\\toldBuckets = [positions]\\n\\t\\t\\tfor k in range(n):\\n\\t\\t\\t\\t# Split the Current Buckets Into New Buckets\\n\\t\\t\\t\\tbuckets = []\\n\\t\\t\\t\\tfor bucket in oldBuckets:\\n\\t\\t\\t\\t\\t# Split the Current Bucket Into New Buckets\\n\\t\\t\\t\\t\\tbucketMap = defaultdict(list)\\n\\t\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t\\t# Add the Next Position to its Respective Bucket Based on the Current Position\\n\\t\\t\\t\\t\\t\\tbucketMap[grid[i][j]].append((d, i + d, j + 1 - d))\\n\\n\\t\\t\\t\\t\\t# Add the New Buckets to the List of Buckets (pruning buckets with no pairs) - O(n)\\n\\t\\t\\t\\t\\tbuckets.extend(x for x in bucketMap.values() if len(x) > 1)\\n\\n\\t\\t\\t\\t# Update the Buckets\\n\\t\\t\\t\\toldBuckets = buckets\\n\\n\\t\\t\\t# Count the Number of Rows/Columns in Each Bucket - O(n)\\n\\t\\t\\tpairs = 0\\n\\t\\t\\tfor bucket in buckets:\\n\\t\\t\\t\\t# Count the Number of Rows/Columns in the Current Bucket\\n\\t\\t\\t\\trows = 0\\n\\t\\t\\t\\tcols = 0\\n\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t# Check if the Position is From a Column or a Row\\n\\t\\t\\t\\t\\tif d:\\n\\t\\t\\t\\t\\t\\tcols += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\trows += 1\\n\\n\\t\\t\\t\\t# Count the Number of Pairs That Contributes\\n\\t\\t\\t\\tpairs += rows * cols\\n\\n\\t\\t\\t# Return the Total Number of Pairs\\n\\t\\t\\treturn pairs\\n\\'\\'\\'\\n\\n## Notes\\nThis solution could actuall be slightly improved if the rows/columns are kept separated from the start as this would eliminate the need for the final pass where the number of pairs is computed. But the time saved from this is small since it only contributes O(n) to the overall time complexity, while the time complexity for the whole algorith is O(n^2). The bigger way this could help the performance though is by more agressive pruning during the radix sort.\\n\\nThere are 2 instances in this algorithm where nested loops only contribute a factor of O(n) to their respective section in the code: \"for bucket in oldBuckets\"/\"for d, i, j in bucket\", and \"for bucket in buckets\"/\"for d, i, j in bucket\". In both of these instances, the total number of positions in all buckets is at most 2\\\\*n since the total number of starting positions is 2\\\\*n (i.e. sum(len(bucket) for bucket in buckets) = # remaining positions <= # starting positions = 2\\\\*n). The radix sort section of the algorithm has an additional factor of O(n) from the \"for k in range(n)\", so its time complexity is O(n^2), while the pair counting section just has a time complexity of O(n). Together these give an overal time complexity of O(n^2). Furthermore, since the number of positions is O(n), the space complexity for the algorithm is O(n) as *positions*, *oldBuckets*, *buckets*, and *bucketMap* each store all the remaining posiitons once, meaning that they each use O(n) space.\\n\\n# Hashmap Solution\\nAs fun as the radix sort solution is, this much simpler solution using hashmaps achieves the same time/space complexity, and similar real-world performance. So you should all really use something like this:\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Hash the Rows - O(n^2)\\n\\t\\t\\tcounts = Counter(map(tuple, grid))\\n\\n\\t\\t\\t# Hash the Columns and Count the Pairs - O(n^2)\\n\\t\\t\\treturn sum(counts[tuple(grid[i][j] for i in range(n))] for j in range(n))\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "## Radix Sort\\n(skip this section if you\\'re already familiar with radix sort)\\n\\nRadix sort is a sorting algorithm which works by bucket sorting the items in the list based on a specific *bit* in the item and then recombining the buckets. This iteration is repeated for each *bit* in the data (I use the term *bit* loosely since it could also be a character in a string, or a base 10 digit, or really any other piece of serialized information in the item). Here is an example of radix sort being used to sort a list of words:\\n\\nwords = [horse, apple, heard, candy, pitch, think, women, rules]\\n\\n1. Bucket Sort by 5th/Last Letter\\nbuckets = {d: [heard], e: [horse, apple], h: [pitch], k: [think], n: [women], s: [rules], y: [candy]}\\nwords = [heard, horse, apple, pitch, think, women, rules, candy]\\n(Note how horse is in front of apple because it appeared first in the original word list. The order of words being preserved in each step is key to the success of this algorithm)\\n\\n2. Bucket Sort by 4th Letter\\nbuckets = {c: [pitch], d: [candy], e: [women, rules], l: [apple], n: [think], r: [heard], s: [horse]}\\n[pitch, candy, women, rules, apple, think, heard, horse]\\n\\n3. Bucket Sort by 3rd Letter\\nbuckets = {n: [candy], p: [apple], l: [rules], m: [women], n: [think], r: [heard], s: [horse], t: [pitch]}\\nwords = [candy, apple, rules, women, think, heard, horse, pitch]\\n\\n4. Bucket Sort by 2nd Letter\\nbuckets = {a: [candy], e: [heard], h: [think], i: [pitch], o: [women, horse], p: [apple], u: [rules]}\\nwords = [candy, heard, think, pitch, women, horse, apple, rules]\\n\\n5. Bucket Sort by 1st Letter\\nbuckets = {a: [apple], c: [candy], h: [heard, horse], p: [pitch], r: [rules], t: [think], w: [women]}\\nwords = [apple, candy, heard, horse, pitch, rules, think, women]\\n\\nRadix sort runs in quasilinear time (O(k\\\\*n) where k is the max number of *bits* in any of the items being sorted). Because it is not comparison-based, it is not limited by the O(nlogn), but in practice this rarely leads to real-world performance improvements over algorithms like quicksort and merge sort. That being said, it has found real-world uses sorting physical objects (like index cards), where comparison sorting and long-range swaps are more difficult to implement.\\n\\nThe auxillary space required by the radix sort algorithm is O(n) because it needs to allocate enough space in the buckets to hold all the items being sorted.\\n\\n## The Algorithm\\nTo solve this problem I modified the radix sort algorithm by never re-combining the groups (instead, each existing group gets split into new groups where all items in the group are equal). I also pruned any groups which only had 1 item in them, since single item groups can never create pairs down the road. To keep the rows and colums separated the list of states included a bit to mark if an item was a row (0) or a column (1).\\n\\n### Example 1\\n\\ngrid = [\\n\\t[3, 2, 1],\\n    [1, 7, 6],\\n    [2, 7, 7]\\n]\\n\\n#### Initial Positions:\\n* rows: [(0, 0), (1, 0), (2, 0)] - these point to the start of each row\\n* columns: [(0, 0), (0, 1), (0, 2)] - these point to the start of each column\\n* positions: [(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)] - note how the first element in each tuple denotes if it\\'s a row or column\\n* buckets = [positions] = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 1, 0), (1, 2, 0)]]\\n\\n#### Iterations:\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2)]]\\n\\t* Keys = [[3, 1, 2, 3, 2, 1]]\\n\\t* Groups by Key = \\n\\t\\t3: [(0, 0, 0), (1, 0, 0)] - 1 potential pairs\\n\\t\\t2: [(0, 2, 0), (1, 0, 1)] - 1 potential pairs\\n\\t\\t1: [(0, 1, 0), (1, 0, 2)] - 1 potential pairs\\n\\t* Next States by Key = \\n\\t\\t3: [(0, 0, 1), (1, 1, 0)]\\n\\t\\t2: [(0, 2, 1), (1, 1, 1)]\\n\\t\\t1: [(0, 1, 1), (1, 1, 2)]\\n\\t* New Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 2, 1), (1, 1, 1)], [(0, 1, 1), (1, 1, 2)]]\\n\\t* Keys = [[2, 1], [7, 7], [7, 6]]\\n\\t* First Bucket by Key = \\n\\t\\t2: [(0, 0, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t1: [(1, 1, 0)] - 0 potential pairs -> prune when computing next states\\n\\t* Second Bucket by Key = \\n\\t\\t7: [(0, 2, 1), (1, 1, 1)] - 1 potential pair\\n\\t* Third Bucket by Key = \\n\\t\\t7: [(0, 1, 1)] - 0 potential pairs -> prune when computing next states\\n\\t\\t6: [(1, 1, 2)] - 0 potential pairs -> prune when computing next states\\n\\t* Next States by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n3. Initial Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\t* Keys = [[7, 7]]\\n\\t* First Bucket by Key = \\n\\t\\t7: [(0, 2, 2), (1, 2, 1)] - 1 potential pair\\n\\t* Next States by Key (unnecessary at this step) = \\n\\t\\t7: [(0, 2, 3), (1, 3, 1)]\\n\\t* New Buckets = [[(0, 2, 2), (1, 2, 1)]]\\n\\n#### Count Pairs\\nThere is only 1 remainig bucket, and in that bucket there are 2 items: 1 row, and 1 column. To compute the number of pairs this bucket creates we multiply the number of rows by the number of columns: pairs = 1\\\\*1 = 1. Since there are no other remaining buckets, the result is 1.\\n\\n### Example 2\\n\\ngrid = [\\n\\t[3, 1, 2, 2]\\n\\t[1, 4, 4, 5]\\n\\t[2, 4, 2, 2]\\n\\t[2, 4, 2, 2]\\n]\\n\\n#### Iterations\\n1. Initial Buckets = [[(0, 0, 0), (0, 1, 0), (0, 2, 0), (0, 3, 0), (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t3 : [(0, 0, 1), (1, 1, 0)] - 1 potential pair - current path: 3\\n\\t\\t1 : [(0, 1, 1), (1, 1, 1)] - 1 potential pair - current path: 1\\n\\t\\t2 : [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)] - 4 potential pairs\\n2. Initial Buckets = [[(0, 0, 1), (1, 1, 0)], [(0, 1, 1), (1, 1, 1)], [(0, 2, 1), (0, 3, 1), (1, 1, 2), (1, 1, 3)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t1 : [(0, 0, 2), (1, 2, 0)] - 1 potential pair - current path: 3-1\\n\\t* Bucket 2:\\n\\t\\t4 : [(0, 1, 2), (1, 2, 1)] - 1 potential pair - current path: 1-4\\n\\t* Bucket 3:\\n\\t\\t4 : [(0, 2, 2), (0, 3, 2), (1, 2, 2)] - 2 potential pairs - current path: 2-4\\n\\t\\t5 : [(1, 2, 3)] - 0 potential pairs - current path: 2-5 - prune from next iteration\\n3. Initial Buckets = [[(0, 0, 2), (1, 2, 0)], [(0, 1, 2), (1, 2, 1)], [(0, 2, 2), (0, 3, 2), (1, 2, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1: \\n\\t\\t2 : [(0, 0, 3), (1, 3, 0)] - 1 potential pair - current path: 3-1-2\\n\\t* Bucket 2: \\n\\t\\t4 : [(0, 1, 3), (1, 3, 1)] - 1 potential pair - current path: 1-4-4\\n\\t* Bucket 3: \\n\\t\\t2 : [(0, 2, 3), (0, 3, 3), (1, 3, 2)] - 2 potential pairs - current path: 2-4-2\\n4. Initial Buckets = [[(0, 0, 3), (1, 3, 0)], [(0, 1, 3), (1, 3, 1)], [(0, 2, 3), (0, 3, 3), (1, 3, 2)]]\\n\\tNext States by Group/Key = \\n\\t* Bucket 1:\\n\\t\\t2 : [(0, 0, 4), (1, 4, 0)] - 1 potential pair - current path: 3-1-2-2\\n\\t* Bucket 2:\\n\\t\\t5 : [(0, 1, 4)] - 0 potential pairs - current path: 1-4-4-5 - prune from final bucket list\\n\\t\\t4 : [(1, 4, 1)] - 0 potential pairs - current path: 1-4-4-4 - prune from final bucket list\\n\\t* Bucket 3:\\n\\t\\t2 : [(0, 2, 4), (0, 3, 4), (1, 4, 2)] - 2 potential pairs - current path: 2-4-2-2\\n\\n#### Count Pairs\\nThe final bucket list is: [[(0, 0, 4), (1, 4, 0)], [(0, 2, 4), (0, 3, 4), (1, 4, 2)]]\\n* Bucket 1: 1 row, 1 column -> pairs contributed: 1\\\\*1 = 1\\n* Bucket 2: 2 rows, 1 column -> paris contributed: 2\\\\*1 = 2\\nFrom this we know the total number of pairs found is 1 + 2 = 3\\n\\n### Code\\nFirst Run Performance: 609 ms/19 MB\\nTime Complexity: O(n^2)\\nSpace Complexity: O(n)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Radix Sort the Row/Column Indecies (maintaining the Separate buckets) - O(n^2)\\n\\t\\t\\t# positions are stored as a tuple containing: (direction, row index, column index)\\n\\t\\t\\tpositions = [(0, i, 0) for i in range(n)] # all starting row positions\\n\\t\\t\\tpositions.extend((1, 0, j) for j in range(n)) # all starting column positions\\n\\t\\t\\toldBuckets = [positions]\\n\\t\\t\\tfor k in range(n):\\n\\t\\t\\t\\t# Split the Current Buckets Into New Buckets\\n\\t\\t\\t\\tbuckets = []\\n\\t\\t\\t\\tfor bucket in oldBuckets:\\n\\t\\t\\t\\t\\t# Split the Current Bucket Into New Buckets\\n\\t\\t\\t\\t\\tbucketMap = defaultdict(list)\\n\\t\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t\\t# Add the Next Position to its Respective Bucket Based on the Current Position\\n\\t\\t\\t\\t\\t\\tbucketMap[grid[i][j]].append((d, i + d, j + 1 - d))\\n\\n\\t\\t\\t\\t\\t# Add the New Buckets to the List of Buckets (pruning buckets with no pairs) - O(n)\\n\\t\\t\\t\\t\\tbuckets.extend(x for x in bucketMap.values() if len(x) > 1)\\n\\n\\t\\t\\t\\t# Update the Buckets\\n\\t\\t\\t\\toldBuckets = buckets\\n\\n\\t\\t\\t# Count the Number of Rows/Columns in Each Bucket - O(n)\\n\\t\\t\\tpairs = 0\\n\\t\\t\\tfor bucket in buckets:\\n\\t\\t\\t\\t# Count the Number of Rows/Columns in the Current Bucket\\n\\t\\t\\t\\trows = 0\\n\\t\\t\\t\\tcols = 0\\n\\t\\t\\t\\tfor d, i, j in bucket:\\n\\t\\t\\t\\t\\t# Check if the Position is From a Column or a Row\\n\\t\\t\\t\\t\\tif d:\\n\\t\\t\\t\\t\\t\\tcols += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\trows += 1\\n\\n\\t\\t\\t\\t# Count the Number of Pairs That Contributes\\n\\t\\t\\t\\tpairs += rows * cols\\n\\n\\t\\t\\t# Return the Total Number of Pairs\\n\\t\\t\\treturn pairs\\n\\'\\'\\'\\n\\n## Notes\\nThis solution could actuall be slightly improved if the rows/columns are kept separated from the start as this would eliminate the need for the final pass where the number of pairs is computed. But the time saved from this is small since it only contributes O(n) to the overall time complexity, while the time complexity for the whole algorith is O(n^2). The bigger way this could help the performance though is by more agressive pruning during the radix sort.\\n\\nThere are 2 instances in this algorithm where nested loops only contribute a factor of O(n) to their respective section in the code: \"for bucket in oldBuckets\"/\"for d, i, j in bucket\", and \"for bucket in buckets\"/\"for d, i, j in bucket\". In both of these instances, the total number of positions in all buckets is at most 2\\\\*n since the total number of starting positions is 2\\\\*n (i.e. sum(len(bucket) for bucket in buckets) = # remaining positions <= # starting positions = 2\\\\*n). The radix sort section of the algorithm has an additional factor of O(n) from the \"for k in range(n)\", so its time complexity is O(n^2), while the pair counting section just has a time complexity of O(n). Together these give an overal time complexity of O(n^2). Furthermore, since the number of positions is O(n), the space complexity for the algorithm is O(n) as *positions*, *oldBuckets*, *buckets*, and *bucketMap* each store all the remaining posiitons once, meaning that they each use O(n) space.\\n\\n# Hashmap Solution\\nAs fun as the radix sort solution is, this much simpler solution using hashmaps achieves the same time/space complexity, and similar real-world performance. So you should all really use something like this:\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef equalPairs(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t# Get the Size of the Grid\\n\\t\\t\\tn = len(grid)\\n\\n\\t\\t\\t# Hash the Rows - O(n^2)\\n\\t\\t\\tcounts = Counter(map(tuple, grid))\\n\\n\\t\\t\\t# Hash the Columns and Count the Pairs - O(n^2)\\n\\t\\t\\treturn sum(counts[tuple(grid[i][j] for i in range(n))] for j in range(n))\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2352409,
                "title": "c-easy-solution-please-upvote",
                "content": "//STORE EACH ROW  AND ITS COUNT  THEN MATCH WITH EACH COLUMN \\n// FOR MATCHING ROW COL  , INCREMENT ANS = ANS + NO OF TIMES( ROW)\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> s;\\n        int res=0;\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            if(s.find(grid[i])==s.end())\\n            {\\n               s.insert ({grid[i],1});\\n            }\\n            else\\n            {\\n              s[grid[i]]++;  \\n            }\\n        }\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n            for(int j =0;j<grid.size();j++)\\n            {\\n                 temp.push_back(grid[j][i]);\\n                \\n            }\\n            if(s.find(temp)!=s.end())\\n            {\\n                res= res+s[temp];\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map <vector<int>,int> s;\\n        int res=0;\\n        for(int i =0;i<grid.size();i++)\\n        {\\n            if(s.find(grid[i])==s.end())\\n            {\\n               s.insert ({grid[i],1}",
                "codeTag": "Java"
            },
            {
                "id": 2344208,
                "title": "rust-hashmap-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut map = HashMap::new();\\n        for row in &grid {            \\n            *map.entry(row).or_insert(0) += 1;\\n        }\\n\\n        let mut ans = 0;\\n        for j in 0..grid[0].len() {\\n            let mut v = Vec::new();\\n            for i in 0..grid.len() {\\n                v.push(grid[i][j])\\n            }\\n            ans += map.get(&v).unwrap_or(&0);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut map = HashMap::new();\\n        for row in &grid {            \\n            *map.entry(row).or_insert(0) += 1;\\n        }\\n\\n        let mut ans = 0;\\n        for j in 0..grid[0].len() {\\n            let mut v = Vec::new();\\n            for i in 0..grid.len() {\\n                v.push(grid[i][j])\\n            }\\n            ans += map.get(&v).unwrap_or(&0);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2339230,
                "title": "rust-hashmap",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl2/lc2352)\\n\\n<b>Problem List</b>\\n#HashMap - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/map/hashmap)\\n#CountOccurrences - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_topic/count_occurrences.txt)\\n#MatrixManipulation - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/array/by_topic/manipulation/matrix)\\n#Trie - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/tree/by_data_structure/trie.txt)\\n\\n```\\nuse std::collections::HashMap;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/equal-row-and-column-pairs/\\n/// Time Complexity:    O(`len_rs` * `len_cs`)\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let row_to_freq: HashMap<&Vec<i32>, u8> = {\\n            let mut map: HashMap<&Vec<i32>, u8> = HashMap::with_capacity(len_rs);\\n            for row in &grid {\\n                *map.entry(row).or_default() += 1;\\n            }\\n            map\\n        };\\n        let mut cnt: i32 = 0;\\n        for c in 0..len_cs {\\n            let mut col: Vec<i32> = Vec::with_capacity(len_cs);\\n            for r in 0..len_rs {\\n                col.push(grid[r][c]);\\n            }\\n            if let Some(&freq) = row_to_freq.get(&col) {\\n                cnt += freq as i32;\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/equal-row-and-column-pairs/\\n/// Time Complexity:    O(`len_rs` * `len_cs`)\\n/// Space Complexity:   O(`len_rs` * `len_cs`)\\nimpl Solution {\\n    pub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\\n        let len_rs: usize = grid.len();\\n        let len_cs: usize = grid[0].len();\\n        let row_to_freq: HashMap<&Vec<i32>, u8> = {\\n            let mut map: HashMap<&Vec<i32>, u8> = HashMap::with_capacity(len_rs);\\n            for row in &grid {\\n                *map.entry(row).or_default() += 1;\\n            }\\n            map\\n        };\\n        let mut cnt: i32 = 0;\\n        for c in 0..len_cs {\\n            let mut col: Vec<i32> = Vec::with_capacity(len_cs);\\n            for r in 0..len_rs {\\n                col.push(grid[r][c]);\\n            }\\n            if let Some(&freq) = row_to_freq.get(&col) {\\n                cnt += freq as i32;\\n            }\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336822,
                "title": "faster-than-80-java-solution-using-hashmap-stringbuilder",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> hmap = new HashMap<>();\\n        for(int arr[]:grid)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                sb.append(arr[i]);\\n                sb.append(\" \");\\n            }\\n            String dummy = sb.toString();\\n            hmap.put(dummy,hmap.getOrDefault(dummy,0)+1);\\n        }\\n        int c=0;\\n        for(int j=0;j<grid[0].length;j++)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<grid.length;i++)\\n            {\\n                sb.append(grid[i][j]);\\n                sb.append(\" \");\\n            }\\n            String dummy = sb.toString();\\n            if(hmap.get(dummy)!=null)\\n            {\\n                c+=hmap.get(dummy);\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int equalPairs(int[][] grid) {\\n        HashMap<String,Integer> hmap = new HashMap<>();\\n        for(int arr[]:grid)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                sb.append(arr[i]);\\n                sb.append(\" \");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2327741,
                "title": "i-love-this-solution-o-n-3",
                "content": "\\t public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "\\t public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int count = 0;\\n        int trans[][] = new int[n][n];\\n        transpose(grid, trans);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\t\\t\\t\\t//compare each row of original matrix with its transpose\\n                if(Arrays.equals(grid[i], trans[j]))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private void transpose(int A[][], int B[][]){\\n        int n = A.length;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                B[i][j] = A[j][i];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2326298,
                "title": "c-easy-map-with-approach",
                "content": "```\\nint equalPairs(vector<vector<int>>& grid) \\n    {\\n        int c=0;\\n        map<vector<int>,int> m;\\n\\t\\t//We store each vector of grid in map\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            m[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n\\t\\t\\t//Now we traverse vertically and store elements in a vector\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n\\t\\t\\t//Check if the temp vector is present in map, if present we increment our count\\n            c+=m[temp];\\n        }\\n        return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint equalPairs(vector<vector<int>>& grid) \\n    {\\n        int c=0;\\n        map<vector<int>,int> m;\\n\\t\\t//We store each vector of grid in map\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            m[grid[i]]++;\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            vector<int> temp;\\n\\t\\t\\t//Now we traverse vertically and store elements in a vector\\n            for(int j=0;j<grid.size();j++)\\n            {\\n                temp.push_back(grid[j][i]);\\n            }\\n\\t\\t\\t//Check if the temp vector is present in map, if present we increment our count\\n            c+=m[temp];\\n        }\\n        return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326136,
                "title": "java-hashmap-easy",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>,Integer> m = new HashMap<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            List<Integer> l =new ArrayList<>();\\n            for(int j=0;j<grid.length;j++){\\n                l.add(grid[i][j]);\\n            }\\n               m.put(l,m.getOrDefault(l,0)+1);\\n        }\\n        int count=0;\\n        \\n        for(int j=0;j<grid.length;j++){\\n            List<Integer> l = new ArrayList<>();\\n            for(int i=0;i<grid.length;i++){\\n                l.add(grid[i][j]);\\n            }\\n            \\n            if(m.containsKey(l)) count+=m.get(l);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        Map<List<Integer>,Integer> m = new HashMap<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            List<Integer> l =new ArrayList<>();\\n            for(int j=0;j<grid.length;j++){\\n                l.add(grid[i][j]);\\n            }\\n               m.put(l,m.getOrDefault(l,0)+1);\\n        }\\n        int count=0;\\n        \\n        for(int j=0;j<grid.length;j++){\\n            List<Integer> l = new ArrayList<>();\\n            for(int i=0;i<grid.length;i++){\\n                l.add(grid[i][j]);\\n            }\\n            \\n            if(m.containsKey(l)) count+=m.get(l);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325221,
                "title": "typescript-hashmap",
                "content": "\\n```ts\\nfunction equalPairs(grid: number[][]): number {\\n  const rowMap = new Map<string, number>()\\n  for (let row of grid) {\\n    const key = row.join(\",\")\\n    rowMap.set(key, (rowMap.get(key) || 0) + 1)\\n  }\\n  \\n  let res = 0\\n  for (let c = 0; c < grid.length; c++) {\\n    const column = []\\n    for (let r = 0; r < grid[0].length; r++) {\\n      column.push(grid[r][c])\\n    }\\n    const columnKey = column.join(\",\")\\n    if (rowMap.has(columnKey)) {\\n      res += rowMap.get(columnKey)\\n    }\\n  }\\n  \\n  return res\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction equalPairs(grid: number[][]): number {\\n  const rowMap = new Map<string, number>()\\n  for (let row of grid) {\\n    const key = row.join(\",\")\\n    rowMap.set(key, (rowMap.get(key) || 0) + 1)\\n  }\\n  \\n  let res = 0\\n  for (let c = 0; c < grid.length; c++) {\\n    const column = []\\n    for (let r = 0; r < grid[0].length; r++) {\\n      column.push(grid[r][c])\\n    }\\n    const columnKey = column.join(\",\")\\n    if (rowMap.has(columnKey)) {\\n      res += rowMap.get(columnKey)\\n    }\\n  }\\n  \\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325047,
                "title": "c-easy-hashmap-o-n-2-solution-o-n-space",
                "content": "**Logic**\\nStore every rows in hashmap as a string of number separted by underscore, For an example if row contain following [2,44,5,9] then key of hashmap will be \"2_44_5_9_\"\\n\\nNow iterate over each column and convert them to string in same way and add check if key is in map then add key -> value to ans .\\n\\n```\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    unordered_map<string, int> mp;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n\\n    for (int i = 0; i < m; i++) {\\n      string s = \"\";\\n      for (int j = 0; j < n; j++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      mp[s] += 1;\\n    }\\n    int ans = 0;\\n    for (int j = 0; j < n; j++) {\\n      string s = \"\";\\n      for (int i = 0; i < m; i++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      ans += mp[s];\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int equalPairs(vector<vector<int>>& grid) {\\n    unordered_map<string, int> mp;\\n    int m = grid.size();\\n    int n = grid[0].size();\\n\\n    for (int i = 0; i < m; i++) {\\n      string s = \"\";\\n      for (int j = 0; j < n; j++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      mp[s] += 1;\\n    }\\n    int ans = 0;\\n    for (int j = 0; j < n; j++) {\\n      string s = \"\";\\n      for (int i = 0; i < m; i++) {\\n        int elem = grid[i][j];\\n        s += to_string(elem);\\n        s += \"_\";\\n      }\\n      ans += mp[s];\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324873,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        HashMap<String, Integer> map = new HashMap();\\n        \\n        for(int i[] : grid){\\n            map.put(Arrays.toString(i), map.getOrDefault(Arrays.toString(i),0) + 1);\\n        }\\n        \\n       int count = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            int arr[] = new int[grid.length];\\n            for(int j = 0; j < grid.length; j++){\\n                arr[j] = grid[j][i];\\n            }\\n            count += map.getOrDefault(Arrays.toString(arr),0);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        HashMap<String, Integer> map = new HashMap();\\n        \\n        for(int i[] : grid){\\n            map.put(Arrays.toString(i), map.getOrDefault(Arrays.toString(i),0) + 1);\\n        }\\n        \\n       int count = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            int arr[] = new int[grid.length];\\n            for(int j = 0; j < grid.length; j++){\\n                arr[j] = grid[j][i];\\n            }\\n            count += map.getOrDefault(Arrays.toString(arr),0);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324832,
                "title": "javascript-solution",
                "content": "```\\nvar equalPairs = function(grid) {\\n    \\n    const map = new Map();\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[i][j] + \\' \\';\\n        }\\n        let c = map.has(str)?map.get(str): 0;\\n        map.set(str,++c);\\n    }\\n    \\n    //console.log(map);\\n    let ans = 0;\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[j][i] + \\' \\';\\n        }\\n        if(map.has(str))\\n            ans += map.get(str);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar equalPairs = function(grid) {\\n    \\n    const map = new Map();\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[i][j] + \\' \\';\\n        }\\n        let c = map.has(str)?map.get(str): 0;\\n        map.set(str,++c);\\n    }\\n    \\n    //console.log(map);\\n    let ans = 0;\\n    for(let i = 0; i < grid.length; i++){\\n        let str = \\'\\';\\n        for(let j = 0; j < grid.length; j++){\\n            str += grid[j][i] + \\' \\';\\n        }\\n        if(map.has(str))\\n            ans += map.get(str);\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324686,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)                  //Traverse for every row.\\n        {\\n            for(int j=0;j<n;j++)              // Traverse each row for every column.\\n            {\\n                int count=0;\\n                for(int k=0;k<n;k++)          // kth element of every row will be compared to kth element of every column.\\n                {\\n                    if(grid[i][k]==grid[k][j]){        \\n                        count++;\\n                    }\\n                    else\\n                    {\\n                        break;                // If an unequal element is found check for next column.\\n                    }\\n                    \\n                    if(count==n)              // If all the elements of that row and column are equal increase the answer.\\n                        ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)                  //Traverse for every row.\\n        {\\n            for(int j=0;j<n;j++)              // Traverse each row for every column.\\n            {\\n                int count=0;\\n                for(int k=0;k<n;k++)          // kth element of every row will be compared to kth element of every column.\\n                {\\n                    if(grid[i][k]==grid[k][j]){        \\n                        count++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4031071,
                "title": "java-easy-to-understand-97-faster",
                "content": "# Complexity\\n- Time complexity: \\n1st Code - O(n^2)\\n2nd Code - O(n^3)\\n\\n\\n# Code\\n- Space complexity: O(n^2)\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int ans=0;\\n        int[][] transpose = new int[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                transpose[i][y]=grid[y][i];\\n            }\\n        }\\n        for(int[] row:grid){\\n            for(int[] column:transpose){\\n                if(Arrays.equals(row, column)){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n- Space Complexity = O(1)\\n```\\nclass Solution {\\n    public boolean check(int[][] grid, int row, int column){\\n        int n=grid.length;\\n        for(int i=0; i<n; i++){\\n            if(grid[i][row]!=grid[column][i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public int equalPairs(int[][] grid) {\\n        int ans=0;\\n        int n=grid.length;\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                if(grid[0][i]==grid[y][0]){\\n                    if(check(grid, i, y)){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int ans=0;\\n        int[][] transpose = new int[n][n];\\n        for(int i=0; i<n; i++){\\n            for(int y=0; y<n; y++){\\n                transpose[i][y]=grid[y][i];\\n            }\\n        }\\n        for(int[] row:grid){\\n            for(int[] column:transpose){\\n                if(Arrays.equals(row, column)){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024091,
                "title": "c-using-map-easy-and-straightforward-code",
                "content": "```\\n int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mp;\\n        int n = grid.size();\\n        \\n        vector<int>vc;\\n        for(auto i : grid){\\n            vc.clear();\\n            for(auto j : i){\\n                vc.push_back(j);\\n            }\\n            mp[vc]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            vc.clear();\\n            for(int j = 0; j<n; j++){\\n                vc.push_back(grid[j][i]);\\n            }\\n            ans+=mp[vc];\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nTime : O(N^2)\\nSpace : O(N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int>mp;\\n        int n = grid.size();\\n        \\n        vector<int>vc;\\n        for(auto i : grid){\\n            vc.clear();\\n            for(auto j : i){\\n                vc.push_back(j);\\n            }\\n            mp[vc]++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            vc.clear();\\n            for(int j = 0; j<n; j++){\\n                vc.push_back(grid[j][i]);\\n            }\\n            ans+=mp[vc];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924219,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n        // row, freq\\n        map<vector<int>, int> row; \\n        for (int i = 0; i < grid.size(); i++) {\\n            row[grid[i]]++;\\n        }\\n\\n        vector<int> col(grid.size());\\n\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            for (int i = 0; i < grid.size(); i++)\\n                col[i] = grid[i][j];\\n            \\n            if (row.find(col) != row.end())\\n                result += row[col];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int result = 0;\\n\\n        // row, freq\\n        map<vector<int>, int> row; \\n        for (int i = 0; i < grid.size(); i++) {\\n            row[grid[i]]++;\\n        }\\n\\n        vector<int> col(grid.size());\\n\\n        for (int j = 0; j < grid[0].size(); j++) {\\n            for (int i = 0; i < grid.size(); i++)\\n                col[i] = grid[i][j];\\n            \\n            if (row.find(col) != row.end())\\n                result += row[col];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826240,
                "title": "c-beats-99-34-runtime-set-unordered-map",
                "content": "# Intuition\\nUse a set to keep track of duplicate rows and use an unordered map to keep track of each multiple duplicate rows\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        set<vector<int>> res;\\n        unordered_map<int, vector<int>> dupe;\\n\\n        for(int i = 0; i < grid.size(); ++i){\\n            if(res.find(grid[i]) != res.end()) {\\n                dupe[i] = grid[i];\\n                // if the row already exists, then in case of a     duplicate, it has to be counted multiple times\\n            } \\n            res.insert(grid[i]);\\n        }\\n        for(int i = 0; i < grid.size(); ++i){\\n            vector<int> temp;\\n            for(int j = 0; j <  grid.size(); ++j){\\n                temp.push_back(grid[j][i]);\\n            }\\n            if(res.find(temp) != res.end()) {\\n                for(auto& it: dupe){\\n                //  itterate through dupe unordered_map to add duplicate rows\\n                    if(it.second == temp){\\n                        ++count;\\n                    }\\n                }\\n                ++count;\\n                cout << i << \" \";\\n            } \\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        set<vector<int>> res;\\n        unordered_map<int, vector<int>> dupe;\\n\\n        for(int i = 0; i < grid.size(); ++i){\\n            if(res.find(grid[i]) != res.end()) {\\n                dupe[i] = grid[i];\\n                // if the row already exists, then in case of a     duplicate, it has to be counted multiple times\\n            } \\n            res.insert(grid[i]);\\n        }\\n        for(int i = 0; i < grid.size(); ++i){\\n            vector<int> temp;\\n            for(int j = 0; j <  grid.size(); ++j){\\n                temp.push_back(grid[j][i]);\\n            }\\n            if(res.find(temp) != res.end()) {\\n                for(auto& it: dupe){\\n                //  itterate through dupe unordered_map to add duplicate rows\\n                    if(it.second == temp){\\n                        ++count;\\n                    }\\n                }\\n                ++count;\\n                cout << i << \" \";\\n            } \\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3724518,
                "title": "easy-java-solution-clean-code-easy-understanding",
                "content": "# Intuition\\nTo solve this problem, we need to compare each row with each column. However, doing this directly would be inefficient. An idea is to convert rows and columns to strings (with a separator for each element) and store them in two separate hashmaps, counting the frequency of each unique row and column. Then, we iterate through the keys in the hashmap for rows, and for each row that is also a column (i.e., exists in the hashmap for columns), we multiply their counts from both hashmaps, which gives the number of pairs (ri, cj) where row ri and column cj are equal.\\n\\n\\n# Approach\\n1. Initialize two hashmaps, rowMap and colMap.\\n2. Iterate over the matrix to populate rowMap and colMap with the counts of unique rows and columns, respectively. For each row or column, we create a string representation (with a separator to handle multi-digit integers correctly) and increment the corresponding count in the appropriate hashmap.\\n3. Initialize a variable count to store the total number of pairs (ri, cj) where row ri and column cj are equal.\\n4. Iterate over the keys in rowMap. For each key that also exists in colMap, add the product of their counts in both hashmaps to count.\\n5. Return count as the total number of pairs (ri, cj) where row ri and column cj are equal.\\n\\n# Complexity\\n**Time complexity:** The time complexity is O(n^2) because we have to iterate through the matrix to populate rowMap and colMap, which takes O(n^2) time. We then iterate through the keys in rowMap (in the worst case, there are n keys), and for each key, we check its existence in colMap and retrieve the count, which takes O(1) time. So the total time complexity is O(n^2) + O(n) = O(n^2).\\n**Space complexity:** The space complexity is O(n^2) because in the worst case, if all rows and columns are unique, we store n keys in both rowMap and colMap, and each key is a string representation of a row or a column, which has length n. So the total space complexity is O(n^2) + O(n^2) = O(n^2).\\n\\nUpvote if you like the solution and explaination! \\uD83D\\uDC4D\\u2764\\uFE0F\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        Map<String, Integer> rowMap = new HashMap<>();\\n        Map<String, Integer> colMap = new HashMap<>();\\n\\n        for(int i = 0; i < len; i++) {\\n            String row = \"\";\\n            String col = \"\";\\n            for(int j = 0; j < len; j++) {\\n                row += grid[i][j] + \",\";\\n                col += grid[j][i] + \",\";\\n            }\\n            rowMap.put(row, rowMap.getOrDefault(row, 0) + 1);\\n            colMap.put(col, colMap.getOrDefault(col, 0) + 1);\\n        }\\n\\n        int count = 0;\\n        for(String s: rowMap.keySet()) {\\n            if(colMap.containsKey(s)) {\\n                count += rowMap.get(s) * colMap.get(s);;\\n            } \\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int len = grid.length;\\n        Map<String, Integer> rowMap = new HashMap<>();\\n        Map<String, Integer> colMap = new HashMap<>();\\n\\n        for(int i = 0; i < len; i++) {\\n            String row = \"\";\\n            String col = \"\";\\n            for(int j = 0; j < len; j++) {\\n                row += grid[i][j] + \",\";\\n                col += grid[j][i] + \",\";\\n            }\\n            rowMap.put(row, rowMap.getOrDefault(row, 0) + 1);\\n            colMap.put(col, colMap.getOrDefault(col, 0) + 1);\\n        }\\n\\n        int count = 0;\\n        for(String s: rowMap.keySet()) {\\n            if(colMap.containsKey(s)) {\\n                count += rowMap.get(s) * colMap.get(s);;\\n            } \\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670344,
                "title": "c-hashing-maps",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> mp;\\n        int n= grid.size();\\n        for (auto vec: grid){\\n            mp[vec]++;\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            vector<int> req;\\n            for (int j=0; j<n; j++)req.push_back(grid[j][i]);\\n            ans+= mp[req];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        map<vector<int>,int> mp;\\n        int n= grid.size();\\n        for (auto vec: grid){\\n            mp[vec]++;\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            vector<int> req;\\n            for (int j=0; j<n; j++)req.push_back(grid[j][i]);\\n            ans+= mp[req];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659438,
                "title": "super-fast-and-simple-javascript-solution-beats-99-8",
                "content": "```js\\nconst equalPairs = (grid) => {\\n    \\n    rowMap = {};\\n    let count = 0;\\n\\n    // create stringified map of every row\\n    for (let r = 0; r < grid.length; r++) {\\n        const key = JSON.stringify(grid[r]);\\n        rowMap[key] = (rowMap[key] || 0) + 1;\\n    }\\n\\n    // count number of rows that are equal to cols\\n    for (let r = 0; r < grid.length; r++) {\\n        const col = [];\\n        for (let c = 0; c < grid[0].length; c++) {\\n            col.push(grid[c][r]);\\n        }\\n        const key = JSON.stringify(col);\\n        if (key in rowMap) count += rowMap[key];\\n    }\\n\\n    return count;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```js\\nconst equalPairs = (grid) => {\\n    \\n    rowMap = {};\\n    let count = 0;\\n\\n    // create stringified map of every row\\n    for (let r = 0; r < grid.length; r++) {\\n        const key = JSON.stringify(grid[r]);\\n        rowMap[key] = (rowMap[key] || 0) + 1;\\n    }\\n\\n    // count number of rows that are equal to cols\\n    for (let r = 0; r < grid.length; r++) {\\n        const col = [];\\n        for (let c = 0; c < grid[0].length; c++) {\\n            col.push(grid[c][r]);\\n        }\\n        const key = JSON.stringify(col);\\n        if (key in rowMap) count += rowMap[key];\\n    }\\n\\n    return count;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3636603,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int ans=0;\\n        // iterate rows\\n        for(int row=0; row<grid.Length; row++){\\n            // for each row iterate columns to find matches\\n            // this for loop iterate columns\\n            for(int col=0;col<grid.Length;col++){\\n                ans++;\\n                // now compare each col to the current row\\n                for(int i=0;i<grid.Length;i++){\\n                    if(grid[row][i]!=grid[i][col]){\\n                        ans--;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int ans=0;\\n        // iterate rows\\n        for(int row=0; row<grid.Length; row++){\\n            // for each row iterate columns to find matches\\n            // this for loop iterate columns\\n            for(int col=0;col<grid.Length;col++){\\n                ans++;\\n                // now compare each col to the current row\\n                for(int i=0;i<grid.Length;i++){\\n                    if(grid[row][i]!=grid[i][col]){\\n                        ans--;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636373,
                "title": "c-brute-force-easy-understanding",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a `temp` matrix & copy `grid` into it \\n2. **Rotate the temp matrix** \\n3. *Compare the rows* of both the matrices now\\n4. If row of grid & temp matrix is same then *increase the count* \\n5. **Return count** in the end\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() ;\\n        int cnt = 0 ;\\n        vector<vector<int>> temp = grid ;\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = i ; j < n ; j ++)\\n            {\\n                swap(temp[i][j], temp[j][i]) ;              \\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = 0 ; j < n ; j ++)\\n            {\\n                if (grid[i] == temp[j])\\n                {\\n                    cnt ++ ;\\n                }\\n            }\\n        }\\n        return cnt ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/34f022a6-57c6-486e-aea8-7a98397b0fd3_1686728313.9694998.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() ;\\n        int cnt = 0 ;\\n        vector<vector<int>> temp = grid ;\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = i ; j < n ; j ++)\\n            {\\n                swap(temp[i][j], temp[j][i]) ;              \\n            }\\n        }\\n\\n        for (int i = 0 ; i < n ; i ++)\\n        {\\n            for (int j = 0 ; j < n ; j ++)\\n            {\\n                if (grid[i] == temp[j])\\n                {\\n                    cnt ++ ;\\n                }\\n            }\\n        }\\n        return cnt ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636026,
                "title": "sipmle-python-solution-100-faster-then-you",
                "content": "# Intuition\\nI like rotate matrix :) \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        upvote_please = 0      \\n        d = {}\\n        for rot in tuple(zip(*grid)):\\n            if rot not in d:\\n                d[rot]=1\\n            else:\\n                d[rot]+=1\\n        for gr in grid:\\n            if tuple(gr) in d:\\n                upvote_please+=d[tuple(gr)]\\n        return upvote_please\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        upvote_please = 0      \\n        d = {}\\n        for rot in tuple(zip(*grid)):\\n            if rot not in d:\\n                d[rot]=1\\n            else:\\n                d[rot]+=1\\n        for gr in grid:\\n            if tuple(gr) in d:\\n                upvote_please+=d[tuple(gr)]\\n        return upvote_please\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634590,
                "title": "java-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare every element with every element\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> Compare every row with every column.**Bold**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    /*This function compares the row with all the existing columns\\n    and returns the number of common column with the input row*/\\n    static int compare(int[][] grid, int[] ar,int n){\\n        boolean flag = true;\\n        int k=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(ar[k++] != grid[j][i]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) ans++;\\n            else flag = true;\\n            k=0;\\n        }\\n        return ans;\\n    }\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int ans = 0;\\n        /*This just iterates through every row and uses the \\n        compare function to add the result into the global result */\\n        for(int i=0;i<n;i++){\\n            int[] row = grid[i];\\n            ans += compare(grid,row,n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    /*This function compares the row with all the existing columns\\n    and returns the number of common column with the input row*/\\n    static int compare(int[][] grid, int[] ar,int n){\\n        boolean flag = true;\\n        int k=0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(ar[k++] != grid[j][i]){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag) ans++;\\n            else flag = true;\\n            k=0;\\n        }\\n        return ans;\\n    }\\n    public int equalPairs(int[][] grid) {\\n        int n = grid.length;\\n        int ans = 0;\\n        /*This just iterates through every row and uses the \\n        compare function to add the result into the global result */\\n        for(int i=0;i<n;i++){\\n            int[] row = grid[i];\\n            ans += compare(grid,row,n);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634484,
                "title": "easiest-c-code-with-o-n-2-complexity-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is quiet simple first we copy the original matrix then transpose the original matrix after transpose row become column and column become row now we will check the row of transpose and copied matrix using loop if rows of both the matrix are same then we will do cnt++ and then return cnt\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int cnt=0;\\n        vector<vector<int>>c=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(grid[i][j],grid[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==c[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nPlease Upvote :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int cnt=0;\\n        vector<vector<int>>c=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++)swap(grid[i][j],grid[j][i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==c[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634482,
                "title": "c-easy-and-readable-solution-less-than-84",
                "content": "![image.png](https://assets.leetcode.com/users/images/f46f1a9c-4a0d-4880-9711-3d55b82b3c76_1686679900.7108681.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int EqualPairs(int[][] g) {\\n        int ans = 0;\\n        for (int i = 0; i < g.Length; i++)\\n            for (int j = 0; j < g.Length; j++)\\n            {\\n                int check = 0;\\n                for (int k = 0; k < g.Length; k++)\\n                    if (g[i][k] == g[k][j])\\n                        check++;\\n                if (check == g.Length)\\n                    ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] g) {\\n        int ans = 0;\\n        for (int i = 0; i < g.Length; i++)\\n            for (int j = 0; j < g.Length; j++)\\n            {\\n                int check = 0;\\n                for (int k = 0; k < g.Length; k++)\\n                    if (g[i][k] == g[k][j])\\n                        check++;\\n                if (check == g.Length)\\n                    ans++;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634454,
                "title": "easy-to-understand-c-code-complete-explanation-o-n-2-time-complexity-hashmap",
                "content": "# Intuition\\nWe will use mashmap for this problem.\\nconvert every row of the matrix into a string and store it as a key value in an **unordered** map.\\nincrement value of map corresponding to key value each time you find a string in each row.\\nNow iterate over each columns and similarly convert it into string and add the corresponding value found in rowmap to the answer,\\nreturn the result.\\n\\nKindly upvote if you like the solution.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string mapstr(vector<int>& row){\\n        string str = \"\";\\n        for(auto it : row){\\n           str+=to_string(it);\\n           str+=\"#\";\\n        }\\n        return str;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string,int>m;\\n\\n        for(vector<int> row : grid){\\n            m[mapstr(row)]++;\\n        }\\n        int result = 0;\\n\\n        for(int j = 0 ; j < grid[0].size() ; j++){\\n            string finder = \"\";\\n            for(int i = 0 ; i < grid.size() ; i++){\\n                finder+=to_string(grid[i][j]);\\n                finder+=\"#\";\\n            }\\n            result+=m[finder];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string mapstr(vector<int>& row){\\n        string str = \"\";\\n        for(auto it : row){\\n           str+=to_string(it);\\n           str+=\"#\";\\n        }\\n        return str;\\n    }\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string,int>m;\\n\\n        for(vector<int> row : grid){\\n            m[mapstr(row)]++;\\n        }\\n        int result = 0;\\n\\n        for(int j = 0 ; j < grid[0].size() ; j++){\\n            string finder = \"\";\\n            for(int i = 0 ; i < grid.size() ; i++){\\n                finder+=to_string(grid[i][j]);\\n                finder+=\"#\";\\n            }\\n            result+=m[finder];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634370,
                "title": "c-using-hashmaps",
                "content": "First we will create a map of rows being the key.Then we will create a vector of columns and check if the vector is presented in the map. If yes we will add it to count.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        map<vector<int>, int> um;\\n        // creating a map of row\\n        for(int i=0;i<n;i++){\\n            um[grid[i]]++;\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> vec;\\n            // creating a vector of columns\\n            for(int j=0;j<n;j++){\\n                vec.push_back(grid[j][i]);\\n            }\\n            // adding the corresponding value of keys into count; \\n            count+=um[vec];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        map<vector<int>, int> um;\\n        // creating a map of row\\n        for(int i=0;i<n;i++){\\n            um[grid[i]]++;\\n        }\\n\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            vector<int> vec;\\n            // creating a vector of columns\\n            for(int j=0;j<n;j++){\\n                vec.push_back(grid[j][i]);\\n            }\\n            // adding the corresponding value of keys into count; \\n            count+=um[vec];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634366,
                "title": "daily-challenge-6-13-2023-python3-easy-solution",
                "content": "# Intuition\\nTo approach this, simply make a rotated grid and compare each rows see if they are duplicate. \\nRuntime 496 ms Beats 72.9%\\nMemory 21.3 MB Beats 82.96%\\n\\n# Approach\\n1.  Using zip() to make a rotation grid.\\n    rotatedgrid = list(zip(*grid)):\\n    [3,2,1]->[3,1,2]\\n    [1,7,6]->[2,7,7]\\n    [2,7,7]->[1,6,7]\\n\\n2.  Store each row as Tuple in a dictionary.\\n    In case there are duplicate rows in grid, save tuple(row) as key and counts as value in dictionary.\\n\\n3.  Loop \"rotatedgrid\" check if row is in the dictionary, add the value to answer.\\n(value means how many times it duplicate with origin  rows)\\n\\n# Complexity\\n- Time complexity:\\nO(n * m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        gridset = defaultdict(int)\\n        rotatedgrid = list(zip(*grid))\\n        ans = 0\\n        for row in grid :\\n            gridset[tuple(row)] += 1\\n        for column in rotatedgrid :\\n            if column in gridset :\\n                ans += gridset[tuple(column)]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        gridset = defaultdict(int)\\n        rotatedgrid = list(zip(*grid))\\n        ans = 0\\n        for row in grid :\\n            gridset[tuple(row)] += 1\\n        for column in rotatedgrid :\\n            if column in gridset :\\n                ans += gridset[tuple(column)]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634327,
                "title": "magical-solution-using-string-and",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<string>v2;\\n        vector<string>v1;\\n        int n= grid[0].size();\\n        int c=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n          string v3=\"\";\\n          string v4=\"\";\\n          for(int j=0;j<n;j++)\\n          {\\n             v3=v3+\",\"+to_string(grid[i][j]);\\n             v4=v4+\",\"+to_string(grid[j][i]);\\n          }\\n          v1.push_back(v3);\\n          v2.push_back(v4);\\n          \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v1[i]==v2[j])\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        vector<string>v2;\\n        vector<string>v1;\\n        int n= grid[0].size();\\n        int c=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n          string v3=\"\";\\n          string v4=\"\";\\n          for(int j=0;j<n;j++)\\n          {\\n             v3=v3+\",\"+to_string(grid[i][j]);\\n             v4=v4+\",\"+to_string(grid[j][i]);\\n          }\\n          v1.push_back(v3);\\n          v2.push_back(v4);\\n          \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v1[i]==v2[j])\\n                {\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634271,
                "title": "easy-code-no-complication",
                "content": "just simply run loops to put all the rows as String in hashMap\\nthen check if columns exist in hashMap or not\\n\\nas easy as that\\n\\ndo not know why people are over-complicating this question\\n\\nthe code should be self explanatory\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        return util1(grid);\\n    }\\n    public int util1(int[][] grid) {\\n        HashMap<String, Integer> hm = new HashMap<>();\\n        for (int[] arr : grid) {\\n            String toAdd = \"\";\\n            for (int i : arr) {\\n                toAdd = toAdd + \" \" + i;\\n            }\\n            int toPut = 1;\\n            if (hm.containsKey(toAdd)) {\\n                toPut = hm.get(toAdd) + 1;\\n            }\\n            hm.put(toAdd, toPut);\\n        }\\n        int ans = 0;\\n        for (int j = 0; j < grid[0].length; j++) {\\n            String toCheck = \"\";\\n            for (int i = 0; i < grid.length; i++) {\\n                toCheck = toCheck + \" \" + grid[i][j];\\n            }\\n            if (hm.containsKey(toCheck)) {\\n                ans += hm.get(toCheck);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        return util1(grid);\\n    }\\n    public int util1(int[][] grid) {\\n        HashMap<String, Integer> hm = new HashMap<>();\\n        for (int[] arr : grid) {\\n            String toAdd = \"\";\\n            for (int i : arr) {\\n                toAdd = toAdd + \" \" + i;\\n            }\\n            int toPut = 1;\\n            if (hm.containsKey(toAdd)) {\\n                toPut = hm.get(toAdd) + 1;\\n            }\\n            hm.put(toAdd, toPut);\\n        }\\n        int ans = 0;\\n        for (int j = 0; j < grid[0].length; j++) {\\n            String toCheck = \"\";\\n            for (int i = 0; i < grid.length; i++) {\\n                toCheck = toCheck + \" \" + grid[i][j];\\n            }\\n            if (hm.containsKey(toCheck)) {\\n                ans += hm.get(toCheck);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634066,
                "title": "easy-solution-3-loop-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int result = 0;\\n        int len = grid.Length;\\n\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len; j++){\\n                int checker = 0;\\n                for(int z = 0; z<len; z++){\\n                    if(grid[i][z] == grid[z][j]){\\n                        checker++;\\n                    }\\n                }\\n                if(checker == len){\\n                    result++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int EqualPairs(int[][] grid) {\\n        int result = 0;\\n        int len = grid.Length;\\n\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len; j++){\\n                int checker = 0;\\n                for(int z = 0; z<len; z++){\\n                    if(grid[i][z] == grid[z][j]){\\n                        checker++;\\n                    }\\n                }\\n                if(checker == len){\\n                    result++;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633822,
                "title": "c-solution-using-ordered-map-of-vector-and-int",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n       map<vector<int>,int> mp;\\n\\n       int res=0;\\n\\n       int row=grid.size();\\n       int col=grid[0].size();\\n\\n       for(int i=0;i<row;i++){\\n           mp[grid[i]]++;\\n       }\\n\\n       for(int i=0;i<col;i++){\\n\\n           vector<int> temp;\\n\\n           for(int j=0;j<row;j++){\\n               temp.push_back(grid[j][i]);\\n           }\\n\\n           res+=mp[temp];\\n       }\\n    \\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n       map<vector<int>,int> mp;\\n\\n       int res=0;\\n\\n       int row=grid.size();\\n       int col=grid[0].size();\\n\\n       for(int i=0;i<row;i++){\\n           mp[grid[i]]++;\\n       }\\n\\n       for(int i=0;i<col;i++){\\n\\n           vector<int> temp;\\n\\n           for(int j=0;j<row;j++){\\n               temp.push_back(grid[j][i]);\\n           }\\n\\n           res+=mp[temp];\\n       }\\n    \\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633794,
                "title": "c-super-cool-easy-to-grasp-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        map<vector<int>,int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[grid[i]]++;\\n        }\\n        int count = 0;\\n        for(int c=0; c<n; c++){\\n            vector<int> temp;\\n            for(int r=0; r<n; r++){\\n                temp.push_back(grid[r][c]);\\n            }\\n            if(mp.find(temp) != mp.end()) count += mp[temp];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        map<vector<int>,int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[grid[i]]++;\\n        }\\n        int count = 0;\\n        for(int c=0; c<n; c++){\\n            vector<int> temp;\\n            for(int r=0; r<n; r++){\\n                temp.push_back(grid[r][c]);\\n            }\\n            if(mp.find(temp) != mp.end()) count += mp[temp];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633741,
                "title": "hashmap-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string, int> m;\\n        int n=grid.size();\\n        int count=0;\\n        string s1=\"\";\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[i][j]);\\n                s1+=\\'.\\';\\n            }\\n            m[s1]++;\\n            s1=\"\";\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[j][i]);\\n                s1+=\\'.\\';\\n            }\\n            count+=m[s1];\\n            s1=\"\";\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        unordered_map<string, int> m;\\n        int n=grid.size();\\n        int count=0;\\n        string s1=\"\";\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[i][j]);\\n                s1+=\\'.\\';\\n            }\\n            m[s1]++;\\n            s1=\"\";\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                s1+=to_string(grid[j][i]);\\n                s1+=\\'.\\';\\n            }\\n            count+=m[s1];\\n            s1=\"\";\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633546,
                "title": "beginner-friendly-easy-to-understand-solution-c-o-n-2",
                "content": "# Intuition\\nThis solution is only for understanding better. Just you need to know about vectors in STL C++.\\n\\n# Approach\\nWe are aldready having row vectors in grid, so take column vectors in another 2D array type, and compare both of them. If found similar, increase the answer by 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2). As this is Beginner friendly, it takes O(n^2) time to solve the problem \\n\\n- Space complexity:\\nO(n^2). It takes one 2D vector, to store. So O(n^2) space complexity.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int ct = 0;\\n\\n        vector<vector<int>>coli;\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                v.push_back(grid[j][i]);\\n            }\\n            coli.push_back(v);\\n            v.clear();\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(coli[i]==grid[j]) ct += 1;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int ct = 0;\\n\\n        vector<vector<int>>coli;\\n\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                v.push_back(grid[j][i]);\\n            }\\n            coli.push_back(v);\\n            v.clear();\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(coli[i]==grid[j]) ct += 1;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633465,
                "title": "python-solution",
                "content": "# Intuition\\nFirstly, one would need to check that for each row, how many of the same amount of columns are there. However this solution takes too long due to us having to reiterate each row/col multiple times. \\n\\n# Approach\\nTherefore, it may be better to use a hashmap or dictionary in python to store the rows and columns. This way, since the access time is O(1) and there is no need to reiterate the same problem multiple times. For each possible rows and columns in a grid, we would then store the number of times it appears.\\nAfter computing every row and column, we would then take the multiplication of the number of rows with the number of columns to find all equal row/cols pair and add it to our final answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rowdict={}\\n        for i in grid:\\n            if tuple(i) not in rowdict:\\n                rowdict[tuple(i)]=1\\n            else:\\n                rowdict[tuple(i)]+=1\\n        coldict={}\\n        for j in range(len(grid[0])):\\n            temp=[]\\n            for i in range(len(grid)):\\n                temp.append(grid[i][j])\\n            if tuple(temp) not in coldict:\\n                coldict[tuple(temp)]=1\\n            else:\\n                coldict[tuple(temp)]+=1\\n        ans=0\\n        print(rowdict)\\n        print(coldict)\\n        for key,value in rowdict.items():\\n            if key in coldict:\\n                ans=ans+(value*coldict[key])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        rowdict={}\\n        for i in grid:\\n            if tuple(i) not in rowdict:\\n                rowdict[tuple(i)]=1\\n            else:\\n                rowdict[tuple(i)]+=1\\n        coldict={}\\n        for j in range(len(grid[0])):\\n            temp=[]\\n            for i in range(len(grid)):\\n                temp.append(grid[i][j])\\n            if tuple(temp) not in coldict:\\n                coldict[tuple(temp)]=1\\n            else:\\n                coldict[tuple(temp)]+=1\\n        ans=0\\n        print(rowdict)\\n        print(coldict)\\n        for key,value in rowdict.items():\\n            if key in coldict:\\n                ans=ans+(value*coldict[key])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633430,
                "title": "python-beats-100-optimised-solution",
                "content": "# Intuition\\nThe code counts the number of equal pairs of subgrids in a given grid. It uses a dictionary to store the frequency of encountered subgrids and iterates through the grid to construct and compare subgrids, incrementing the count when equal pairs are found.\\n\\n# Approach\\n1. Initialize an empty dictionary dic to store the frequency of subgrids and a variable count to keep track of the number of equal pairs.\\n\\n2. Iterate through each row i in the grid list:\\na. Convert the current row i to a string representation using str(i).\\nb. Use the get() method of the dictionary dic to retrieve the frequency of the current row. If the row is not present in the dictionary, it returns 0, to which 1 is added. Then, update the dictionary with the new frequency.\\n\\n3. Iterate over a range from 0 to the length of the grid list:\\na. Initialize an empty list temp_lst to store the current column\\'s elements.\\nb. Iterate over a range from 0 to the length of the grid list:\\n-Append the j-th element of the grid list\\'s j-th row to the temp_lst.\\nc. Convert the temp_lst to a string representation using str(temp_lst).\\nd. Use the get() method of the dictionary dic to retrieve the frequency of the current column. If the column is not present in the dictionary, it returns 0.\\ne. Add the obtained frequency to the count variable.\\nReturn the final value of the count variable, which represents the number of equal pairs of subgrids in the grid.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        dic = {}\\n        count = 0\\n        for i in grid:\\n            dic.update({str(i) : dic.get(str(i),0)+1})\\n        \\n        for i in range(len(grid)):\\n            temp_lst = []\\n            for j in range(len(grid)):\\n                temp_lst.append(grid[j][i])\\n            count += dic.get(str(temp_lst),0)\\n        return count\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        dic = {}\\n        count = 0\\n        for i in grid:\\n            dic.update({str(i) : dic.get(str(i),0)+1})\\n        \\n        for i in range(len(grid)):\\n            temp_lst = []\\n            for j in range(len(grid)):\\n                temp_lst.append(grid[j][i])\\n            count += dic.get(str(temp_lst),0)\\n        return count\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633420,
                "title": "c-easiest-and-simplest-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n\\n        int cnt = 0;\\n        int n = grid.size();\\n        map<vector<int>, int> mp;\\n\\n        for(int i=0; i<n; i++) {\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int j=0; j<n; j++) {\\n            vector<int> temp;\\n            for(int i=0; i<n; i++) {\\n                temp.push_back(grid[i][j]);\\n            }\\n            if(mp[temp]) cnt += mp[temp];\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n\\n        int cnt = 0;\\n        int n = grid.size();\\n        map<vector<int>, int> mp;\\n\\n        for(int i=0; i<n; i++) {\\n            mp[grid[i]]++;\\n        }\\n\\n        for(int j=0; j<n; j++) {\\n            vector<int> temp;\\n            for(int i=0; i<n; i++) {\\n                temp.push_back(grid[i][j]);\\n            }\\n            if(mp[temp]) cnt += mp[temp];\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633270,
                "title": "java-beginner-friendly-for-while-loops-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni -> Iterator for the rows(ex: 0,1,2).\\nj-> Iterator for columns..resets to 0 when reaches n( ex:0,1,2 (reaches n so 0,1,2...until i reaches n) ) //Basically we compare a row with each column.\\nk->Iterates through the elements. If not equal breaks. Else if k==n which implies all elements were equal so we increment final ans c. then go to next column j++;\\nif(j reaches n) -> we go to next row and compare with all columns by reseting j to 0;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int i=0,j=0,k,c=0;\\n        while(i<n)\\n        { int v=0;\\n           if(j==n)\\n           { j=0;i++;}\\n           if(i==n)\\n           return c;\\n           for(k=0;k<n;k++)\\n           {\\n               if(grid[k][i]!=grid[j][k])\\n               break;\\n                //System.out.println(grid[k][i]+\" \"+grid[j][k]);\\n           }\\n           //System.out.println(i+\" \"+j);\\n           if(k==n)\\n           c++;\\n           j++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        int n=grid.length;\\n        int i=0,j=0,k,c=0;\\n        while(i<n)\\n        { int v=0;\\n           if(j==n)\\n           { j=0;i++;}\\n           if(i==n)\\n           return c;\\n           for(k=0;k<n;k++)\\n           {\\n               if(grid[k][i]!=grid[j][k])\\n               break;\\n                //System.out.println(grid[k][i]+\" \"+grid[j][k]);\\n           }\\n           //System.out.println(i+\" \"+j);\\n           if(k==n)\\n           c++;\\n           j++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633208,
                "title": "c-o-n-2-tc-and-o-n-sc",
                "content": "```\\n#define ll long long \\n#define m 1000000007\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        map<ll,ll> r;\\n        map<ll,ll> c;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int j=0;j<g.size();j++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            c[h]++;\\n        }\\n        for(int j=0;j<g.size();j++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int i=0;i<g.size();i++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            r[h]++;\\n        }\\n        ll ans=0;\\n        for(auto& i:r)\\n        {\\n            ans=ans+i.second*c[i.first];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash"
                ],
                "code": "```\\n#define ll long long \\n#define m 1000000007\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        map<ll,ll> r;\\n        map<ll,ll> c;\\n        for(int i=0;i<g.size();i++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int j=0;j<g.size();j++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            c[h]++;\\n        }\\n        for(int j=0;j<g.size();j++)\\n        {\\n            ll p=100003;\\n            ll h=0;\\n            for(int i=0;i<g.size();i++)\\n            {\\n                h=(h+(1LL*g[i][j]*p)%m)%m;\\n                p*=p;\\n                p%=m;\\n            }\\n            r[h]++;\\n        }\\n        ll ans=0;\\n        for(auto& i:r)\\n        {\\n            ans=ans+i.second*c[i.first];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633198,
                "title": "java-solution-o-2-n-2-o-n-using-hashmap",
                "content": "# Intuition\\ni thought we can simply go through each row and store the numbers as a string in a HashMap with their frequency. And then we can traverse through each column and store the number of column in a string to compare it with the HashMap elements after each column iteration ends.\\n\\n# Approach\\n1- I created a HashMap to Store each row elements as a String with their frequencies. \\n2- I started with row wise traversal where i used a StringBuilder to easily concatenate the values as a String.\\n**The reason i used \\'#\\' to append after each value is due to the case where in a row there might be all same digit numbers such as in example [[11,1],[1,11]] where when you will store the number as String without appending \\'#\\' you will get 111 and 111 which is completely wrong.**\\n3- Then i am just updating the frequencies.\\n4- Now i started with column wise traversal and storing every column as a string and then looking if the column string is present in the hashmap.\\n5- if it is present in the hashmap ,then add their frequencies to the count\\n\\n# Complexity\\n- Time complexity:\\nfrom my analysis it is -\\n\\n1. O(N^2) for row traversal \\n2. O(N^2) for column traversal \\n3. O(N) for hashMap lookup and Insertions \\n4. //correct me if i am wrong  \\n\\n- Space complexity:\\nAs i took a hashMap ,it can go as long as O(N) space complexity\\n//correct me if i am wrong\\n\\n# Code\\n```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        int n =grid.length;\\n        int m=grid[0].length;\\n        int mod=(int)1e9+7;\\n        HashMap<String,Integer>row = new HashMap<>();\\n        int count=0 ; \\n          for(int i =0 ; i<n ;i++){\\n              StringBuilder sb = new StringBuilder();\\n              for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[i][j]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n             if (row.containsKey(toMatch)) {\\n                int frequency = row.get(toMatch);\\n                row.put(toMatch, frequency + 1);\\n            } else {\\n                row.put(toMatch, 1);\\n            }\\n          }\\n          System.out.print(row);\\n          // column-wise traversal \\n           for(int i =0 ; i<n ;i++){\\n                 StringBuilder sb = new StringBuilder();\\n                for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[j][i]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n              if(row.containsKey(toMatch)){\\n                count+=row.get(toMatch); \\n              }\\n          }\\n          return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int equalPairs(int[][] grid) {\\n        \\n        int n =grid.length;\\n        int m=grid[0].length;\\n        int mod=(int)1e9+7;\\n        HashMap<String,Integer>row = new HashMap<>();\\n        int count=0 ; \\n          for(int i =0 ; i<n ;i++){\\n              StringBuilder sb = new StringBuilder();\\n              for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[i][j]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n             if (row.containsKey(toMatch)) {\\n                int frequency = row.get(toMatch);\\n                row.put(toMatch, frequency + 1);\\n            } else {\\n                row.put(toMatch, 1);\\n            }\\n          }\\n          System.out.print(row);\\n          // column-wise traversal \\n           for(int i =0 ; i<n ;i++){\\n                 StringBuilder sb = new StringBuilder();\\n                for(int j = 0 ; j<n ;j++){\\n                  sb.append(Integer.toString(grid[j][i]));\\n                  sb.append(\"#\");\\n              }\\n              String toMatch=sb.toString(); \\n              if(row.containsKey(toMatch)){\\n                count+=row.get(toMatch); \\n              }\\n          }\\n          return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633158,
                "title": "equal-row-and-column-pairs",
                "content": "# Intuition\\nWe can optimize this approach by using a hash map data structure to reduce the time complexity.\\n\\n# Approach\\nIn this approach, we can consider each row as the key and store it in a hash map. The corresponding value for each key would be the frequency of that row in the grid. Then, we can traverse through each column of the grid and increment the answer by the frequency of the equivalent row in the hash map.\\n\\n# Complexity\\n- Time complexity:   O(n^2)\\nWe iterate over each row and column only once, converting one array of length n into a hashable object takes O(n) time.\\nOperations like adding or checking on hash map take O(1) time.\\n\\n- Space complexity:   O(n^2)\\nWe store each row of the grid in the hash map, in the worst-case scenario, row_counter might contains nnn distinct rows of length n.\\n\\n# Code\\n```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count =0;\\n        n = len(grid)\\n\\n        # Keep track of the frequency of each row.\\n        row_counter = collections.Counter(tuple(row) for row in grid)\\n\\n        # Add up the frequency of each column in map.\\n        for c in range(n):\\n            col = [grid[i][c] for i in range(n)]\\n            count += row_counter[tuple(col)]\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        count =0;\\n        n = len(grid)\\n\\n        # Keep track of the frequency of each row.\\n        row_counter = collections.Counter(tuple(row) for row in grid)\\n\\n        # Add up the frequency of each column in map.\\n        for c in range(n):\\n            col = [grid[i][c] for i in range(n)]\\n            count += row_counter[tuple(col)]\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633097,
                "title": "2-approach-c-o-n-1-space-and-o-n-3-time-o-n-2-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn equal pair is formed by two rows in the grid that have the same elements in corresponding positions.\\nWe need to count the number of such equal pairs in the grid.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a map **gridRow** to store the **frequency** of each row in the grid.\\nThe **key** of the map is a vector representing a row, and the value is the frequency of that row in the grid.\\n```\\n map<vector<int>,int> gridRow;\\n```\\n- Iterate through each row in the grid and update the frequency in the gridRow map.\\nFor each row row in the grid, increment gridRow[row] by 1.\\n```\\nfor(auto x:grid){\\n            gridRow[x]++;\\n        }\\n```\\n- Create a temporary vector temp to store the elements of each column.\\n```\\n vector<int>temp;\\n```\\n- Iterate through each column in the grid.\\n\\n For each column, iterate through the rows and store the   corresponding elements in the temp vector.\\n This step effectively transposes the grid, allowing us to treat columns as rows\\n```\\n for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]);  \\n            }\\n```\\n- Check if the temp vector exists as a key in the gridRow map.\\n\\nIf it does, increment ans by the frequency of the column stored in gridRow[temp].\\nClear the temp vector to prepare it for the next column.\\n``` \\n if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; \\n            }\\n```\\n# Complexity\\n- Time complexity:**O(N^2)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(N^2)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n``` \\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        std::map<std::vector<int>, int> gridRow; // Map to store the frequency of each row\\n        int ans = 0; // Variable to store the result\\n        \\n        // Count the frequency of each row in the grid\\n        for (auto row : grid) {\\n            gridRow[row]++;\\n        }\\n        \\n        std::vector<int> temp; // Temporary vector to store each column\\n        \\n        // Iterate through each column\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]); // Store the elements of the column in the temporary vector\\n            }\\n            \\n            if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; // Increment the result by the frequency of the column in the grid\\n            }\\n            \\n            temp.clear(); // Clear the temporary vector for the next column\\n        }\\n        \\n        return ans; // Return the final result\\n    }\\n};\\n\\n```\\n# Code 2\\n```\\n \\n\\nclass Solution {\\npublic:\\n    // Function to check if all elements in a row and column are equal to grid[row][col]\\n    bool check(vector<vector<int>>& grid, int row, int col) {\\n        int size = grid.size();\\n        int r1 = 0;\\n        int c1 = 0;\\n        \\n        // Compare each element in the row with corresponding element in the column\\n        while (r1 < size) {\\n            if (grid[row][c1] != grid[r1][col]) {\\n                return false; // If any element is not equal, return false\\n            }\\n            r1++;\\n            c1++;\\n        }\\n        \\n        return true; // All elements in the row and column are equal\\n    }\\n\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        // Iterate through each element in the grid\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                if (check(grid, i, j)) {\\n                    ans++; // If all elements in the row and column are equal, increment the count\\n                }\\n            }\\n        }\\n        \\n        return ans; // Return the total count of equal pairs\\n    }\\n};\\n \\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n map<vector<int>,int> gridRow;\\n```\n```\\nfor(auto x:grid){\\n            gridRow[x]++;\\n        }\\n```\n```\\n vector<int>temp;\\n```\n```\\n for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]);  \\n            }\\n```\n``` \\n if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; \\n            }\\n```\n``` \\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        std::map<std::vector<int>, int> gridRow; // Map to store the frequency of each row\\n        int ans = 0; // Variable to store the result\\n        \\n        // Count the frequency of each row in the grid\\n        for (auto row : grid) {\\n            gridRow[row]++;\\n        }\\n        \\n        std::vector<int> temp; // Temporary vector to store each column\\n        \\n        // Iterate through each column\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                temp.push_back(grid[j][i]); // Store the elements of the column in the temporary vector\\n            }\\n            \\n            if (gridRow.count(temp)) {\\n                ans += gridRow[temp]; // Increment the result by the frequency of the column in the grid\\n            }\\n            \\n            temp.clear(); // Clear the temporary vector for the next column\\n        }\\n        \\n        return ans; // Return the final result\\n    }\\n};\\n\\n```\n```\\n \\n\\nclass Solution {\\npublic:\\n    // Function to check if all elements in a row and column are equal to grid[row][col]\\n    bool check(vector<vector<int>>& grid, int row, int col) {\\n        int size = grid.size();\\n        int r1 = 0;\\n        int c1 = 0;\\n        \\n        // Compare each element in the row with corresponding element in the column\\n        while (r1 < size) {\\n            if (grid[row][c1] != grid[r1][col]) {\\n                return false; // If any element is not equal, return false\\n            }\\n            r1++;\\n            c1++;\\n        }\\n        \\n        return true; // All elements in the row and column are equal\\n    }\\n\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        // Iterate through each element in the grid\\n        for (int i = 0; i < grid.size(); i++) {\\n            for (int j = 0; j < grid.size(); j++) {\\n                if (check(grid, i, j)) {\\n                    ans++; // If all elements in the row and column are equal, increment the count\\n                }\\n            }\\n        }\\n        \\n        return ans; // Return the total count of equal pairs\\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633018,
                "title": "easy-c-solution-o-n2",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        map<vector<int>,vector<string>>map;\\n\\n        for(int i=0;i<n; i++){\\n            map[grid[i]].push_back(\"r\");\\n        }\\n\\n        for(int j=0; j<m; j++){\\n            vector<int>res;\\n            for(int i=0; i<n; i++){\\n                res.push_back(grid[i][j]);\\n            }\\n            map[res].push_back(\"c\");\\n        }\\n        int count=0;\\n\\n        for(auto x: map){\\n            vector<string>res = x.second;\\n            if(res.size() >1){\\n                int a = std::count(res.begin(),res.end(),\"r\");\\n                int b = std::count(res.begin(),res.end(),\"c\");\\n                count+=a*b;\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n\\n\\n// map <vector<int> , vector<string>>\\n// 3122 - r ,c\\n// 1445 - r\\n// 2422 - r, r , c \\n// 1444 - c\\n// 3522 - c\\n\\n// one row and 1 column -->total pairs ==> 1*2 \\n// 3 row 2 column --==> 6 pairs\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        map<vector<int>,vector<string>>map;\\n\\n        for(int i=0;i<n; i++){\\n            map[grid[i]].push_back(\"r\");\\n        }\\n\\n        for(int j=0; j<m; j++){\\n            vector<int>res;\\n            for(int i=0; i<n; i++){\\n                res.push_back(grid[i][j]);\\n            }\\n            map[res].push_back(\"c\");\\n        }\\n        int count=0;\\n\\n        for(auto x: map){\\n            vector<string>res = x.second;\\n            if(res.size() >1){\\n                int a = std::count(res.begin(),res.end(),\"r\");\\n                int b = std::count(res.begin(),res.end(),\"c\");\\n                count+=a*b;\\n            }\\n        }\\n        return count;\\n    }\\n\\n};\\n\\n\\n// map <vector<int> , vector<string>>\\n// 3122 - r ,c\\n// 1445 - r\\n// 2422 - r, r , c \\n// 1444 - c\\n// 3522 - c\\n\\n// one row and 1 column -->total pairs ==> 1*2 \\n// 3 row 2 column --==> 6 pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632977,
                "title": "c-2-solutions-easy-methods-bruteforce-and-map",
                "content": "# Approach I\\nThe bruteforce method would be to compare each row with each column taking $$ O(n^3) $$ time and constant space.\\n\\n\\n# Approach II\\n<!-- Describe your approach to solving the problem. -->\\nBy using map (for using vector directly) or unordered map (by converting vector to string) to map every row, and then comparing every column with it.\\nIt takes $$ O(n^2) $$ time and $$ O(n^2) $$ space \\n\\nConversion to string takes extra time and memory, so its better you make your own hash function and use it with <unordered_map> (you can\\'t use vector with unordered map)\\n\\n# Code I\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++) {\\n                bool match = true;\\n                for (int k=0; k<len; k++) {\\n                    if (grid[i][k] != grid[k][j]) {match = false; break;}\\n                }\\n                count += match ? 1 : 0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\n# Code II\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n\\n        unordered_map <string, int> mymap;\\n        for (int i=0; i<len; i++) {\\n            string row = \"\";\\n            for (int j=0; j<len; j++) {\\n                row += to_string(grid[i][j]) + \" \"; // We add \" \" in order to handle cases like \"1 11\" and \"11 1\".\\n            }\\n            mymap[row]++;\\n        }\\n\\n        for (int j=0; j<len; j++) {\\n            string col = \"\";\\n            for (int k=0; k<len; k++) {\\n                col += to_string(grid[k][j]) + \" \";\\n            }\\n            if (mymap.find(col) != mymap.end()) count += mymap[col];\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n        for (int i=0; i<len; i++){\\n            for (int j=0; j<len; j++) {\\n                bool match = true;\\n                for (int k=0; k<len; k++) {\\n                    if (grid[i][k] != grid[k][j]) {match = false; break;}\\n                }\\n                count += match ? 1 : 0;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int count = 0;\\n        int len = grid.size();\\n\\n        unordered_map <string, int> mymap;\\n        for (int i=0; i<len; i++) {\\n            string row = \"\";\\n            for (int j=0; j<len; j++) {\\n                row += to_string(grid[i][j]) + \" \"; // We add \" \" in order to handle cases like \"1 11\" and \"11 1\".\\n            }\\n            mymap[row]++;\\n        }\\n\\n        for (int j=0; j<len; j++) {\\n            string col = \"\";\\n            for (int k=0; k<len; k++) {\\n                col += to_string(grid[k][j]) + \" \";\\n            }\\n            if (mymap.find(col) != mymap.end()) count += mymap[col];\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632828,
                "title": "maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        unordered_map<int , vector<int>> mp;\\n        unordered_map<int , vector<int>> mpc;\\n        \\n        map<vector<int>, int> mo;\\n        int n  = g.size();\\n        int yy = 0;\\n        for(auto &i: g )\\n            mp[yy++] = i;\\n        \\n        yy=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int > t(n);\\n            for(int j=0;j<n;j++)\\n            {\\n                t[j] = g[j][i];\\n            }\\n            \\n            mpc[yy++] = t;\\n        }\\n        \\n        \\n        int res = 0;\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n        {\\n            for(auto j=mpc.begin();j!=mpc.end();j++)\\n            {\\n                if(i->second == j->second)\\n                    res++;\\n            }\\n        }\\n        return res;\\n        \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& g) {\\n        unordered_map<int , vector<int>> mp;\\n        unordered_map<int , vector<int>> mpc;\\n        \\n        map<vector<int>, int> mo;\\n        int n  = g.size();\\n        int yy = 0;\\n        for(auto &i: g )\\n            mp[yy++] = i;\\n        \\n        yy=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int > t(n);\\n            for(int j=0;j<n;j++)\\n            {\\n                t[j] = g[j][i];\\n            }\\n            \\n            mpc[yy++] = t;\\n        }\\n        \\n        \\n        int res = 0;\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n        {\\n            for(auto j=mpc.begin();j!=mpc.end();j++)\\n            {\\n                if(i->second == j->second)\\n                    res++;\\n            }\\n        }\\n        return res;\\n        \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632721,
                "title": "2352-equal-row-and-column-pairs-mapping",
                "content": "```\\nclass Solution {\\npublic:\\nint equalPairs(vector<vector<int>> &grid)\\n    {\\n    int ans = 0;\\n    map<vector<int>, int> map;\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        map[grid[i]]++;\\n    }\\n    \\n    for (int j = 0; j < grid[0].size(); j++)\\n    {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            column.push_back(grid[i][j]);\\n        }\\n        ans += map[column];\\n    }\\n        return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint equalPairs(vector<vector<int>> &grid)\\n    {\\n    int ans = 0;\\n    map<vector<int>, int> map;\\n    for (int i = 0; i < grid.size(); i++)\\n    {\\n        map[grid[i]]++;\\n    }\\n    \\n    for (int j = 0; j < grid[0].size(); j++)\\n    {\\n        vector<int> column;\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            column.push_back(grid[i][j]);\\n        }\\n        ans += map[column];\\n    }\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632595,
                "title": "c-trie-o-n-2",
                "content": "If you are not familiar with `Trie` data structure you can solve [this](https://leetcode.com/problems/implement-trie-prefix-tree/) leetcode problem on trie and see [this](https://youtu.be/oobqoCJlHA0) video\\n[https://youtu.be/oobqoCJlHA0]()\\n```\\nclass trieNode{\\n    public:\\n    int count;\\n    unordered_map<int, trieNode*> children;\\n    trieNode(){\\n        this->count = 0;\\n    }\\n};\\n\\nclass Trie{\\n    public:\\n    trieNode* root;\\n    Trie(){\\n        this->root = new trieNode;\\n    }\\n\\n    void insert(vector<int> &arr){\\n        trieNode *temp = root;\\n        for(int num : arr){\\n            if(temp->children.find(num) != temp->children.end()){\\n                temp = temp->children[num];\\n            }else{\\n                trieNode* newNode = new trieNode();\\n                temp->children[num] = newNode;\\n                temp = temp->children[num];\\n            }\\n        }\\n        temp->count++;\\n    }\\n\\n    int search(vector<vector<int>> &grid, int n, int col){\\n        trieNode *temp = root;\\n        for(int i = 0; i < n; i++){\\n            if(temp->children.find(grid[i][col]) == temp->children.end()){\\n                return 0;\\n            }\\n            temp = temp->children[grid[i][col]];\\n        }\\n        return temp->count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        Trie *myTrie = new Trie();\\n        for(auto &row : grid){\\n            myTrie->insert(row);\\n        }\\n\\n        int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            ans += myTrie->search(grid, n, col);\\n        }\\n        delete myTrie;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass trieNode{\\n    public:\\n    int count;\\n    unordered_map<int, trieNode*> children;\\n    trieNode(){\\n        this->count = 0;\\n    }\\n};\\n\\nclass Trie{\\n    public:\\n    trieNode* root;\\n    Trie(){\\n        this->root = new trieNode;\\n    }\\n\\n    void insert(vector<int> &arr){\\n        trieNode *temp = root;\\n        for(int num : arr){\\n            if(temp->children.find(num) != temp->children.end()){\\n                temp = temp->children[num];\\n            }else{\\n                trieNode* newNode = new trieNode();\\n                temp->children[num] = newNode;\\n                temp = temp->children[num];\\n            }\\n        }\\n        temp->count++;\\n    }\\n\\n    int search(vector<vector<int>> &grid, int n, int col){\\n        trieNode *temp = root;\\n        for(int i = 0; i < n; i++){\\n            if(temp->children.find(grid[i][col]) == temp->children.end()){\\n                return 0;\\n            }\\n            temp = temp->children[grid[i][col]];\\n        }\\n        return temp->count;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        Trie *myTrie = new Trie();\\n        for(auto &row : grid){\\n            myTrie->insert(row);\\n        }\\n\\n        int ans = 0;\\n        for(int col = 0; col < n; col++){\\n            ans += myTrie->search(grid, n, col);\\n        }\\n        delete myTrie;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632583,
                "title": "easiest-approach-o-n-2-explained-in-hindi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       int n=grid.size();\\n       vector<vector<int>>trans(n,vector<int>(n,0));\\n       int count=0;\\n       //transpose matrix bana diya \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               trans[i][j]=grid[j][i];\\n           }\\n       } \\n\\n       //har ek row grid ki transpose ki har ek row se compare kiya\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               if(grid[i]==trans[j])count++;\\n           }\\n       }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n       int n=grid.size();\\n       vector<vector<int>>trans(n,vector<int>(n,0));\\n       int count=0;\\n       //transpose matrix bana diya \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               trans[i][j]=grid[j][i];\\n           }\\n       } \\n\\n       //har ek row grid ki transpose ki har ek row se compare kiya\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<n;j++)\\n           {\\n               if(grid[i]==trans[j])count++;\\n           }\\n       }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632488,
                "title": "easy-c-solution-with-explanation-runtime-99-ms-space-28-1-mb",
                "content": "# Intuition\\n\\n# Approach\\nThere are three approaches to solve this question\\nFirst is Brute force\\nWe check each row with each column and if they are the same, we add one to the count\\nSecond is also Brute force but reduces some comparisons\\nWe store the sum of each row and column in another vector and only compare the row and column if there sums are equal\\nThird approach is using maps\\nPush all the row vectors into a map, \\nThen increment the count by the frequency of how many times a column appears in the map\\n# Complexity\\n- Time complexity:\\n    O(n^2), as we go over the whole matrix\\n- Space complexity:\\n    O(n) \\n###    \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        // Approach 1: Brute Force\\n        // int n = grid.size();\\n        // vector<int> row_sum(n,0);\\n        // vector<int> column_sum(n,0);\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         row_sum[i]+=grid[i][j];\\n        //         column_sum[i] += grid[j][i];\\n        //     }\\n        // }\\n\\n        // int count = 0;\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         if(row_sum[i] == column_sum[j]){\\n        //             bool equal = true;\\n        //             for(int k = 0; k<n; k++){\\n        //                 if(grid[i][k] != grid[k][j]){\\n        //                     equal = false;\\n        //                     break;\\n        //                 }\\n        //             }\\n        //             if(equal){\\n        //                 count++;\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n        // return count;\\n\\n\\n        // Approach 2: Using maps\\n\\n        map<vector<int>, int> rows;\\n        int n = grid.size();\\n        for(int i = 0; i<n; i++){\\n            rows[grid[i]]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            vector<int> column(n);\\n            for(int j = 0; j<n; j++){\\n                column[j] = grid[j][i];\\n            }\\n            count+=rows[column];\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        \\n        // Approach 1: Brute Force\\n        // int n = grid.size();\\n        // vector<int> row_sum(n,0);\\n        // vector<int> column_sum(n,0);\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         row_sum[i]+=grid[i][j];\\n        //         column_sum[i] += grid[j][i];\\n        //     }\\n        // }\\n\\n        // int count = 0;\\n        // for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<n; j++){\\n        //         if(row_sum[i] == column_sum[j]){\\n        //             bool equal = true;\\n        //             for(int k = 0; k<n; k++){\\n        //                 if(grid[i][k] != grid[k][j]){\\n        //                     equal = false;\\n        //                     break;\\n        //                 }\\n        //             }\\n        //             if(equal){\\n        //                 count++;\\n        //             }\\n        //         }\\n        //     }\\n        // }\\n        // return count;\\n\\n\\n        // Approach 2: Using maps\\n\\n        map<vector<int>, int> rows;\\n        int n = grid.size();\\n        for(int i = 0; i<n; i++){\\n            rows[grid[i]]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            vector<int> column(n);\\n            for(int j = 0; j<n; j++){\\n                column[j] = grid[j][i];\\n            }\\n            count+=rows[column];\\n        }\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632466,
                "title": "python-o-n-2-time-o-n-space-breadth-first-sequence-trie",
                "content": "# Intuition\\nI wanted to try for a solution that skipped unneccesary comparisons at the earliest possible moment, and minimized storage.\\n\\nThe approach that jumped out as a way to do this was to collect matches for each element in a sequence, then only continue to check rows and columns that continued to match. For example, collecting all the rows and columns that match for the 1st element of the sequence. Then, when we moved on to the 2nd element, we need only check that the existing matches continue to have matches with each other.\\n\\nA Trie is well suited for this task, but how it was used in this solution is very different than the suggestion in the editorial. A Breadth First approach to both constructing and validating the trie would discard invalid cases at the earliest opportunity, minimizing best case time needed. The trie nodes only representing valid matches would allow us to only store each index a maximum of 2 times each level, once for row, and once for column. This is key to the better space demands, as we don\\'t need to keep trie nodes we\\'ve already processed.\\n\\n# Approach\\nAt the end of the function, we\\'d need to return the count of the pairs. We start with a variable at the outer scope we can add to later:\\n\\n\\n```\\n+class Solution:\\n+    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        pairs_count = 0\\n+\\n+        return pairs_count\\n```\\n\\nAs an overview, I wanted to construct a Trie.\\n\\nThe keys for the children along a path down the tree would represent the values for the sequence, and the value for the key would recursively be another TrieNode\\n\\n```\\n+class TrieNodeMatches:\\n+    def __init__(self):\\n+        self.children = {}\\n+\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        root = TrieNodeMatches()\\n=        pairs_count = 0\\n=\\n=        return pairs_count\\n```\\n\\nThe children need to be populated. Our breadth first approach demands we collect rows and columns. We\\'ll start by iterating through the first row. \\n\\nEach element in the first row represents the first value in the sequence of a column. This element\\'s value will be the key for child nodes. We can\\'t know yet if there is going to be a match in rows, so for every new value we see, we create a new child node.\\n\\nIn order for us to contine testing matches along this sequence, we need to be able to continue validating along the same column. We will store all the column indexes in lists in the children TrieNodes, but if it\\'s a grid value we\\'ve already seen, it gets added to the existing node.\\n\\nWe also will need to remember which index we are on in the sequence, just the column isn\\'t enough. We will provide that to the TrieNode and store it with the constructor.\\n\\n\\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n+        self.index = index\\n+        self.columns = []\\n=        self.children = {}\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n-        root = TrieNodeMatches()\\n+        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+\\n+        for i in range(len(grid)):\\n+            n = grid[0][i]\\n+            if n not in root.children:\\n+                root.children[n] = TrieNodeMatches(1)\\n+            root.children[n].columns.append(i)\\n=\\n=        return pairs_count\\n```\\n\\nWe do something similar for the rows by iterating through the first column. \\nThe row indexes get stored in lists the children nodes too. The TrieNode index is the same, 0th element in matching sequence so nothing changes there.\\n\\nThere is a slight difference when it comes to finding grid values we haven\\'t yet seen. One way to do it would be identical to the columns, just create new children as needed and add all rows in. If we think for a moment though, this doesn\\'t make sense. Only matches are relevant and anything new doesn\\'t have a column match. Every child we created at this point would be discarded at the next step. For that reason, it is slightly better to just skip creating children for grid values we haven\\'t already seen.\\n\\nI threw in some functions that will allow us to use `print()` for TrieNode as well, which I used to help troubleshoot issues as they arose.\\n\\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n=        self.index = index\\n+        self.rows = []\\n=        self.columns = []\\n=        self.children = {}\\n+    \\n+    def __str__(self):\\n+        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n+    def __repr__(self):\\n+        return self.__str__()\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n=        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+        size = len(grid)\\n-        for i in range(len(grid)):\\n+        for i in range(size):\\n=            n = grid[0][i]\\n=            if n not in root.children:\\n=                root.children[n] = TrieNodeMatches(1)\\n=            root.children[n].columns.append(i)\\n+\\n+        for i in range(size):\\n+            n = grid[i][0]\\n+            if n in root.children:\\n+                root.children[n].rows.append(i)\\n=\\n=        return pairs_count\\n```\\n\\nAt this point, we have a root node of the Trie. The index is 0, and the keys for the children are the 1st number of the sequence. The values of the children contain the lists of row and column grid indexes that belong to that sequence and an sequence index value of 1. Their children\\'s children are emtpy, as we haven\\'t gotten to them yet, that\\'s what we need to do next. Since the plan is breadth first, we will create a queue and add the children to it. We use deque, with appendleft() and pop() for a FIFO queue.\\n\\nWhile we are adding, we will also validate. There needs to be rows and columns for a valid sequence. If either are missing, then we are finished with this sequence as this can\\'t lead to matching rows and columns. Every node will have columns, since every columns first sequence value had a node created for it, and none were created for row values with empty columns. Not every node will have rows, as there is no guarantee that they matched, so we validate that matches exist by checking that there are some positive number of rows before adding it to the queue.\\n\\n\\n```\\n=...\\n=        for i in range(size):\\n=            n = grid[i][0]\\n=            if n in root.children:\\n=                root.children[n].rows.append(i)\\n+\\n+        for t in root.children.values():\\n+            if len(t.rows) > 0:\\n+                q.appendleft(t)\\n=\\n=        return pairs_count\\n```\\n\\nNow that we have all the child nodes in a FIFO queue, Breadth First is just taking items out of the queue, then processing each child node in a way very similar to what we did with root earlier, including adding thier children. The main change is dropping the hardcoded values. The index represents both the level in the tree the node sits at, and the index in the sequence for the rows and columns that have matched so far. Up to now, we have hardcoded the index.\\n\\nWhen iterating over the columns, the way to get the `i`th element for the sequence of the column `c` from the grid is `grid[i][c]` and for row `r` its reverse, `grid[r][i]` . The formula for it\\'s change between parent and child couldn\\'t be simpler, it just increments by 1. The node index we stored with the constructor earlier is this sequence index we need. Since it\\'s availible on the node we are working with, we have what we need for these dynamic values.\\n\\n\\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+\\n+        while q:\\n+            t = q.pop()\\n+\\n+            for c in t.columns:\\n+                n = grid[t.index][c]\\n+                if n not in t.children:\\n+                    t.children[n] = TrieNodeMatches(t.index + 1)\\n+                t.children[n].columns.append(c)\\n+            \\n+            for r in t.rows:\\n+                n = grid[r][t.index]\\n+                if n in t.children:\\n+                    t.children[n].rows.append(r)\\n+            \\n+            for t2 in t.children.values():\\n+                if len(t2.rows) > 0:\\n+                    q.appendleft(t2)\\n=        \\n=        return pairs_count\\n```\\n\\nAt this point, if there are any valid matches, our loop will run over the end of the grid, and try to access invalid indexes. We need to test for reaching the end of sequences, and then act by adding the valid pair amount to the `pairs_count`. The amount of pairs to add is multiplication, each column matches with every row. Critically, we can\\'t let it attempt anything else in the loop for this sequence, as we want to avoid both accessing out of bound indexes, and stop adding children. We don\\'t want to break the loop though, there could still be valid pairs to process in the queue, so we `continue` to skip to the next node. Each node remaining will get processed without adding children until the queue is empty, exiting the loop.\\n\\n```\\n=...\\n=        while q:\\n=            t = q.pop()\\n+\\n+            if t.index == size:\\n+                pairs_count += len(t.rows) * len(t.columns)\\n+                continue\\n=\\n=            for c in t.columns:\\n=...\\n```\\n\\nJust one more thing to add... One of the main benefits to this method is the reduced need to store data, but if you are paying attention, so far we have n levels in the tree which each have up to 2n values. That\\'s O(n<sup>2</sup>) which doesn\\'t save space at all. But, after putting all the children into the queue, we never revisit that node ever again. The node can be discarded. If we do, we will almost always have the equivalent of one level of the trie in memory during the breadth first processing. The one exception is when we have added the rows and columns to the children and are adding them to the queue. \\n\\nWe will evaluate 2 bad cases, one where all grid values are identical, and one where each row matches a different column:\\n\\nOne case, where all values in the grid are identical, each level will be 1 node with 2 lists, each having n values for 2n space. While creating and appending the children to the queue, we would have the lists for at most 2 levels in memory, for an upper limit of 4n grid index values, 2 indexes, and 1 int key, in addition to 2 ints and the deque with 2 items. O(4n + ~7) is O(n)\\n\\nAn alternative, where each row matches a different column, would have n nodes at each level of the trie, each with 1 match. Thats n items in the queue, n index values, 1 keys for children and 2n + 2 items in node lists, in addition to the 2 outer scope ints. I think this evalutates closer to O(3n + 4). Still O(n)\\n\\nAny other cases should get better space results than the worst of these 2.\\nThis gets O(n) space.\\n\\n\\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+        \\n+        del root\\n=\\n=        while q:\\n=...\\n=            for t2 in t.children.values():\\n=                if len(t2.rows) > 0:\\n=                    q.appendleft(t2)\\n+            \\n+            del t\\n=        \\n=        return pairs_count\\n```\\n\\n\\n# Complexity\\nWhere n is the length of a side of the grid.\\n- Time complexity:\\nO(n<sup>2</sup>)\\nWorst case is all rows and columns have matches. A grid with every value identical, or some alternative patterns where the sequences are different but every sequence has a match would have each element of the grid visted twice with this solution. Some value of O(n<sup>2</sup>) should be the minimum, as in this worst case any algorithm would need to visit and check every element, and there are n<sup>2</sup> elements.\\nBest case, at each index in range(n), all sequences that stop matching are discarded, leaving unneccesary elements never visited.\\n\\n- Space complexity:\\nO(n)\\nA tree of n levels is created, and each levels nodes contain arrays. if the entire level had that levels arrays concatenated, worst case would be 2n per level.\\nIf the entire tree was kept, that would be O(n<sup>2</sup>), but nodes are discarded after processing, with worst case 1 full level of the tree and 1 nodes children in memory. For a grid with identical values, that\\'s a cap of 2 levels: 4 lists with n length, but 4n is O(n), far better than O(n<sup>2</sup>) for large n\\'s\\n\\n\\n# Code\\n```\\nclass TrieNodeMatches:\\n    def __init__(self, index):\\n        self.index = index\\n        self.rows = []\\n        self.columns = []\\n        self.children = {}\\n    \\n    def __str__(self):\\n        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n    def __repr__(self):\\n        return self.__str__()\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        root = TrieNodeMatches(0)\\n        pairs_count = 0\\n        size = len(grid)\\n        for i in range(size):\\n            n = grid[0][i]\\n            if n not in root.children:\\n                root.children[n] = TrieNodeMatches(1)\\n            root.children[n].columns.append(i)\\n        \\n        for i in range(size):\\n            n = grid[i][0]\\n            if n in root.children:\\n                root.children[n].rows.append(i)\\n        \\n        for t in root.children.values():\\n            if len(t.rows) > 0:\\n                q.appendleft(t)\\n        \\n        del root\\n\\n        while q:\\n            t = q.pop()\\n\\n            if t.index == size:\\n                pairs_count += len(t.rows) * len(t.columns)\\n                continue\\n            \\n            for c in t.columns:\\n                n = grid[t.index][c]\\n                if n not in t.children:\\n                    t.children[n] = TrieNodeMatches(t.index + 1)\\n                t.children[n].columns.append(c)\\n            \\n            for r in t.rows:\\n                n = grid[r][t.index]\\n                if n in t.children:\\n                    t.children[n].rows.append(r)\\n            \\n            for t2 in t.children.values():\\n                if len(t2.rows) > 0:\\n                    q.appendleft(t2)\\n            \\n            del t\\n        \\n        return pairs_count\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Trie",
                    "Queue"
                ],
                "code": "```\\n+class Solution:\\n+    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        pairs_count = 0\\n+\\n+        return pairs_count\\n```\n```\\n+class TrieNodeMatches:\\n+    def __init__(self):\\n+        self.children = {}\\n+\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n+        root = TrieNodeMatches()\\n=        pairs_count = 0\\n=\\n=        return pairs_count\\n```\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n+        self.index = index\\n+        self.columns = []\\n=        self.children = {}\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n-        root = TrieNodeMatches()\\n+        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+\\n+        for i in range(len(grid)):\\n+            n = grid[0][i]\\n+            if n not in root.children:\\n+                root.children[n] = TrieNodeMatches(1)\\n+            root.children[n].columns.append(i)\\n=\\n=        return pairs_count\\n```\n```\\n=class TrieNodeMatches:\\n=    def __init__(self, index):\\n=        self.index = index\\n+        self.rows = []\\n=        self.columns = []\\n=        self.children = {}\\n+    \\n+    def __str__(self):\\n+        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n+    def __repr__(self):\\n+        return self.__str__()\\n=\\n=class Solution:\\n=    def equalPairs(self, grid: List[List[int]]) -> int:\\n=        root = TrieNodeMatches(0)\\n=        pairs_count = 0\\n+        size = len(grid)\\n-        for i in range(len(grid)):\\n+        for i in range(size):\\n=            n = grid[0][i]\\n=            if n not in root.children:\\n=                root.children[n] = TrieNodeMatches(1)\\n=            root.children[n].columns.append(i)\\n+\\n+        for i in range(size):\\n+            n = grid[i][0]\\n+            if n in root.children:\\n+                root.children[n].rows.append(i)\\n=\\n=        return pairs_count\\n```\n```\\n=...\\n=        for i in range(size):\\n=            n = grid[i][0]\\n=            if n in root.children:\\n=                root.children[n].rows.append(i)\\n+\\n+        for t in root.children.values():\\n+            if len(t.rows) > 0:\\n+                q.appendleft(t)\\n=\\n=        return pairs_count\\n```\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+\\n+        while q:\\n+            t = q.pop()\\n+\\n+            for c in t.columns:\\n+                n = grid[t.index][c]\\n+                if n not in t.children:\\n+                    t.children[n] = TrieNodeMatches(t.index + 1)\\n+                t.children[n].columns.append(c)\\n+            \\n+            for r in t.rows:\\n+                n = grid[r][t.index]\\n+                if n in t.children:\\n+                    t.children[n].rows.append(r)\\n+            \\n+            for t2 in t.children.values():\\n+                if len(t2.rows) > 0:\\n+                    q.appendleft(t2)\\n=        \\n=        return pairs_count\\n```\n```\\n=...\\n=        while q:\\n=            t = q.pop()\\n+\\n+            if t.index == size:\\n+                pairs_count += len(t.rows) * len(t.columns)\\n+                continue\\n=\\n=            for c in t.columns:\\n=...\\n```\n```\\n=...\\n=        for t in root.children.values():\\n=            if len(t.rows) > 0:\\n=                q.appendleft(t)\\n+        \\n+        del root\\n=\\n=        while q:\\n=...\\n=            for t2 in t.children.values():\\n=                if len(t2.rows) > 0:\\n=                    q.appendleft(t2)\\n+            \\n+            del t\\n=        \\n=        return pairs_count\\n```\n```\\nclass TrieNodeMatches:\\n    def __init__(self, index):\\n        self.index = index\\n        self.rows = []\\n        self.columns = []\\n        self.children = {}\\n    \\n    def __str__(self):\\n        return \"{\" + f\" number {self.index} in sequence, matching rows: {self.rows}, columns: {self.columns}, children: {[n for n in self.children]}\" + \"}\"\\n    def __repr__(self):\\n        return self.__str__()\\n\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        q = deque()\\n        root = TrieNodeMatches(0)\\n        pairs_count = 0\\n        size = len(grid)\\n        for i in range(size):\\n            n = grid[0][i]\\n            if n not in root.children:\\n                root.children[n] = TrieNodeMatches(1)\\n            root.children[n].columns.append(i)\\n        \\n        for i in range(size):\\n            n = grid[i][0]\\n            if n in root.children:\\n                root.children[n].rows.append(i)\\n        \\n        for t in root.children.values():\\n            if len(t.rows) > 0:\\n                q.appendleft(t)\\n        \\n        del root\\n\\n        while q:\\n            t = q.pop()\\n\\n            if t.index == size:\\n                pairs_count += len(t.rows) * len(t.columns)\\n                continue\\n            \\n            for c in t.columns:\\n                n = grid[t.index][c]\\n                if n not in t.children:\\n                    t.children[n] = TrieNodeMatches(t.index + 1)\\n                t.children[n].columns.append(c)\\n            \\n            for r in t.rows:\\n                n = grid[r][t.index]\\n                if n in t.children:\\n                    t.children[n].rows.append(r)\\n            \\n            for t2 in t.children.values():\\n                if len(t2.rows) > 0:\\n                    q.appendleft(t2)\\n            \\n            del t\\n        \\n        return pairs_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632449,
                "title": "c-intuitive-and-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create another vector of vector named v such that the columns of original grid are the rows of \\'v\\'.\\nAfter that we compare the rows of the original grid to each row of the new grid and increment the count if both the rows are totally same.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> v=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                v[i][j]=grid[j][i];\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==v[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> v=grid;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                v[i][j]=grid[j][i];\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i]==v[j])cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632359,
                "title": "two-nested-loops-in-one-line-python",
                "content": "# Intuition\\nTranspose of a matrix and compare rows.\\n\\n# Approach\\nTwo nested loops.\\n\\n# Complexity\\n- Time complexity:  O(N^2)\\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        grid = map(tuple, grid)\\n        return len([True for i in zip(*grid) for j in grid if i == j])\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def equalPairs(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        grid = map(tuple, grid)\\n        return len([True for i in zip(*grid) for j in grid if i == j])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632207,
                "title": "easy-java-solution-javith-sadham-hussain",
                "content": "# Code\\n```\\nclass Solution \\n{\\n    public int equalPairs(int[][] grid) \\n    {\\n        int countOfEqualPairs = 0;\\n        boolean blnEqual;\\n\\n        for(int idx=0; idx<grid.length; idx++)\\n        { \\n            for(int j=0; j<grid.length; j++)\\n            {\\n                blnEqual = true;\\n                for(int k=0; k<grid.length; k++)\\n                {\\n                    if(grid[idx][k] != grid[k][j])\\n                    {\\n                        blnEqual = false;\\n                        break;\\n                    }\\n                }  \\n                countOfEqualPairs += blnEqual ? 1 : 0;              \\n            }             \\n        }\\n\\n        return countOfEqualPairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int equalPairs(int[][] grid) \\n    {\\n        int countOfEqualPairs = 0;\\n        boolean blnEqual;\\n\\n        for(int idx=0; idx<grid.length; idx++)\\n        { \\n            for(int j=0; j<grid.length; j++)\\n            {\\n                blnEqual = true;\\n                for(int k=0; k<grid.length; k++)\\n                {\\n                    if(grid[idx][k] != grid[k][j])\\n                    {\\n                        blnEqual = false;\\n                        break;\\n                    }\\n                }  \\n                countOfEqualPairs += blnEqual ? 1 : 0;              \\n            }             \\n        }\\n\\n        return countOfEqualPairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632197,
                "title": "2-solutions-simple-fast-and-easy-with-explanation",
                "content": "# \\uD83D\\uDD25 2 Solutions \\uD83D\\uDD25 || Simple Fast and Easy || with Explanation \\uD83D\\uDE08\\n\\n## Solution - 1\\n\\n```dart\\nclass Solution {\\n  List<List<int>> transpose(List<List<int>> gr) {\\n    final List<List<int>> gc = [].map((e) => <int>[]).toList();\\n    int n = gr.length;\\n\\n    for (int i = 0; i < n; i++) {\\n      final List<int> v = <int>[];\\n      for (int j = 0; j < n; j++) {\\n        v.add(gr[j][i]); // column-wise pushing\\n      }\\n      gc.add(v);\\n    }\\n\\n    return gc;\\n  }\\n\\n  bool isListEqual(List<int> listOne, List<int> listTwo) {\\n    if (listOne.length != listTwo.length) {\\n      return false;\\n    }\\n\\n    for (int i = 0; i < listOne.length; i++) {\\n      if (listOne[i] != listTwo[i]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  int equalPairs(List<List<int>> gr) {\\n    final List<List<int>> gc = transpose(gr);\\n    final int n = gr.length;\\n\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (isListEqual(gr[i], gc[j])) {\\n          ans++;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\\n\\n## Solution - 2\\n\\n```dart\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int equalPairs(List<List<int>> grid) {\\n    int pair = 0;\\n    int temp = 0;\\n    int row = 0;\\n\\n    while (temp <= grid.length - 1) {\\n      final HashMap<int, int> map = HashMap<int, int>();\\n      for (int j = 0; j < grid.length; j++) {\\n        map[j] = grid[row][j];\\n      }\\n      for (int i = 0; i < grid.length; i++) {\\n        int current = 0;\\n        for (int k = 0; k < grid.length; k++) {\\n          if (map[k] != grid[k][i]) {\\n            current = 0;\\n            break;\\n          } else {\\n            current = 1;\\n          }\\n        }\\n        pair += current;\\n      }\\n      row++;\\n      temp++;\\n    }\\n    return pair;\\n  }\\n}\\n```\\n### [GitHub Link](https://github.com/ayoubzulfiqar/leetcode)",
                "solutionTags": [
                    "Dart",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```dart\\nclass Solution {\\n  List<List<int>> transpose(List<List<int>> gr) {\\n    final List<List<int>> gc = [].map((e) => <int>[]).toList();\\n    int n = gr.length;\\n\\n    for (int i = 0; i < n; i++) {\\n      final List<int> v = <int>[];\\n      for (int j = 0; j < n; j++) {\\n        v.add(gr[j][i]); // column-wise pushing\\n      }\\n      gc.add(v);\\n    }\\n\\n    return gc;\\n  }\\n\\n  bool isListEqual(List<int> listOne, List<int> listTwo) {\\n    if (listOne.length != listTwo.length) {\\n      return false;\\n    }\\n\\n    for (int i = 0; i < listOne.length; i++) {\\n      if (listOne[i] != listTwo[i]) {\\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  int equalPairs(List<List<int>> gr) {\\n    final List<List<int>> gc = transpose(gr);\\n    final int n = gr.length;\\n\\n    int ans = 0;\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (isListEqual(gr[i], gc[j])) {\\n          ans++;\\n        }\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```\n```dart\\nimport \\'dart:collection\\';\\n\\nclass Solution {\\n  int equalPairs(List<List<int>> grid) {\\n    int pair = 0;\\n    int temp = 0;\\n    int row = 0;\\n\\n    while (temp <= grid.length - 1) {\\n      final HashMap<int, int> map = HashMap<int, int>();\\n      for (int j = 0; j < grid.length; j++) {\\n        map[j] = grid[row][j];\\n      }\\n      for (int i = 0; i < grid.length; i++) {\\n        int current = 0;\\n        for (int k = 0; k < grid.length; k++) {\\n          if (map[k] != grid[k][i]) {\\n            current = 0;\\n            break;\\n          } else {\\n            current = 1;\\n          }\\n        }\\n        pair += current;\\n      }\\n      row++;\\n      temp++;\\n    }\\n    return pair;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632182,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n## Intuition\\nThe problem requires us to find the number of pairs `(ri, cj)` such that row `ri` and column `cj` are equal. We can use a hash table to store the `frequency` of each row. Then we can iterate over each column and check if it matches any row in the hash table.\\n\\n## Approach\\n1. Create a hash table to store the frequency of each row.\\n2. Iterate over each column and check if it matches any row in the hash table.\\n3. If it matches, add the frequency of that row to the `count`.\\n\\n\\n```python\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mapping = defaultdict(lambda : 0)\\n        count = 0\\n        n = len(grid)\\n        for row in grid:\\n            mapping[str(row)] += 1\\n        \\n        for i in range(n):\\n            col = []\\n            for j in range(n):\\n                col.append(grid[j][i])\\n            count += mapping[str(col)]\\n        return count\\n```\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```python\\nclass Solution:\\n    def equalPairs(self, grid: List[List[int]]) -> int:\\n        mapping = defaultdict(lambda : 0)\\n        count = 0\\n        n = len(grid)\\n        for row in grid:\\n            mapping[str(row)] += 1\\n        \\n        for i in range(n):\\n            col = []\\n            for j in range(n):\\n                col.append(grid[j][i])\\n            count += mapping[str(col)]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632179,
                "title": "c-easy-understanding-and-easy-to-implement-clean-matrcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a matrix that are Transpose of the initial matrix and compare each row of initial matrix to each row of its transpose matrix when its equal just increment ans.\\n# Complexity\\n- Time complexity:\\n- O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0,cnt=0;\\n        int n=grid.size();\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        \\n     for(int i=0;i<grid.size();i++){\\n        \\n        for(int j=0;j<grid.size();j++){\\n         // transpose matrix\\n         v[j][i]=grid[i][j];\\n        } \\n        \\n     }\\n    for(int i=0;i<grid.size();i++){\\n      for(int j=0;j<grid.size();j++) {\\n//      compare row of transpose matrix and initial matrix\\n          if(v[j]==grid[i]){\\n              ans++;\\n          }\\n      }\\n        \\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int equalPairs(vector<vector<int>>& grid) {\\n        int ans=0,cnt=0;\\n        int n=grid.size();\\n        vector<vector<int>>v(n,vector<int>(n,0));\\n        \\n     for(int i=0;i<grid.size();i++){\\n        \\n        for(int j=0;j<grid.size();j++){\\n         // transpose matrix\\n         v[j][i]=grid[i][j];\\n        } \\n        \\n     }\\n    for(int i=0;i<grid.size();i++){\\n      for(int j=0;j<grid.size();j++) {\\n//      compare row of transpose matrix and initial matrix\\n          if(v[j]==grid[i]){\\n              ans++;\\n          }\\n      }\\n        \\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1927475,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1810006,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927166,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1891948,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927325,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1928385,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927333,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927125,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927583,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1881303,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927475,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1810006,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927166,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1891948,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927325,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1928385,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927333,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927125,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927583,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1881303,
                "content": [
                    {
                        "username": "code__HARD",
                        "content": "Entered my 300th problem on Leetcode!"
                    },
                    {
                        "username": "KevinShenDuke",
                        "content": "congrats"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "Congo bro\\uD83D\\uDE4C"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Congrats dude! number 500 for me, on to 1000!"
                    },
                    {
                        "username": "barvin04",
                        "content": "Congrats bud, more to come !!\\n"
                    },
                    {
                        "username": "DoraBabukondala",
                        "content": "Make your way to 500!! Congrats"
                    },
                    {
                        "username": "netherjs",
                        "content": "Let\\'s goooooooo"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Congrats!!!"
                    },
                    {
                        "username": "xasati9865",
                        "content": "Congratulationss "
                    },
                    {
                        "username": "Movsar",
                        "content": "Instead of calculating each row and column you can use 2 hash maps. 1 for rows and 1 for columns. Let's look at example 1:\n\n![matrix](https://i.ibb.co/cFQFXJQ/Screenshot-2023-02-22-at-01-04-07.png)\nYou can save rows like:\n```\n{321: 1, 176: 1, ...}\n```\nThe same for columns. Hope it will help you :)"
                    },
                    {
                        "username": "kunal17265",
                        "content": "[@fahad_sait](/fahad_sait) \\nfor(let i = 0 ; i<rowLen ; i++){\\n        let val = 0;\\n        for(let j = 0 ; j<colLen ; j++){\\n            val = val*10 + grid[i][j];\\n        }\\n        rowMap[val] = (rowMap[val] || 0) + 1\\n    }\\nthis is how I did"
                    },
                    {
                        "username": "serkora",
                        "content": "[@fahad_sait](/fahad_sait) You would make it a string, not an integer, otherwise you\\'ll run out of integer size _really_ quickly (within 21 elements for 64 bit int if all numbers are single digits)."
                    },
                    {
                        "username": "fahad_sait",
                        "content": "how can I gather all elements from the row as one integer??\nCan anyone help me with this??\n\n\n\n\n\n\n\n"
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "[@nikhilag84](/nikhilag84) Yes, then simply put a dot seperator after adding each element to the string. Then it would be 1.11 and 11.1 and these would be counted as different."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "[@nikhilag84](/nikhilag84) i got it we can use some character like % ^ to separate"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i guess this approach will fail for [[1,11],[11,1]] . as this will consider 1 11 as 111 and 11 1 also as 111 that is wrong . and it will give answer as 4 but it should be 2.   btw approach was good . i am trying to improve this above case bug\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It\\'s having to compare the entire row and column after finding a matching hash that slows this down I think. Even if you placed a row (and not just its has) into a table, you still have to compare the row when you search the hash table because of possible collisions.\\n\\nThe editorial suggests storing <row,frequency> in a hash table then checking if the columns match a row (add the row frequency if so). With the need to compare an entire row to see if you have the correct hash entry, I don\\'t see that this would be any faster either."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@psionl0](/psionl0) Did the same thing with the same result. Not the fastest and not 100% reliable approach because of theoretically possible hash collisions."
                    },
                    {
                        "username": "user5400vw",
                        "content": "definitely a great optimization idea.  As mentioned by others, need a separator and string keys.  a Trie approach would save further cpu cycles but i think unnecessary for this problem."
                    },
                    {
                        "username": "psionl0",
                        "content": "I did something like that. I hashed each row, hashed each column and stored the hashes in arrays. Even though I only needed to compare pre-computed hashes for each row/column, my running time was actually slower than a brute force solution."
                    },
                    {
                        "username": "vaibhavt147",
                        "content": "[@SimonBomb](/SimonBomb)  We can insert dashes in between, like storing it as 1-23-334 and 12-33-34.\\nBut I suppose there might be some better ways to solve the problem"
                    },
                    {
                        "username": "SimonBomb",
                        "content": "I suppose you are lucky that this works ! )) \nWhat your algorithm would do with these rows like [1,23,334] and cols [12, 33, 34 ]? \nthese two seem to be the same in your code '123334' and '123334'\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "In C++, it is hard to use unordered_map for arrays as keys.\nTherefore, transfer them to strings! Then unordered_map can be easily applied for such strings as Hash map.\nTo use unordered_map for arrays, you have to define your own hash!"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "1 11 \nans\n11 1\nthis would give issue if we turn them into string.\nOne hack would me to make it like \"1,11\"\n\nI submitted three ways and the order of speed was:\nCustom hash + unordered_map > Map >>> string + map"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@tehpolecat](/tehpolecat)  Transferring arrays to strings then using unordered_map is slow. It would be better to use map if  the data is not big."
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@GenisisRaiden](/GenisisRaiden) C++ docs claim that map is usually implemented as a red-black tree which has constant time amortized insertion and worst case logn insertion. unordered_map has average constant and worst case n insertions (i assume this is if all entries get hashed into the same bin for some reason?). So theoretically, using map would give you better worst-case guarantees, although the worst case seems very unlikely. But in practice, many factors could determine which performs better and with small input, it might not make a difference. I'd be interested to know what others think."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@GenisisRaiden](/GenisisRaiden) It is doable! But maybe it is slower "
                    },
                    {
                        "username": "kshzz24",
                        "content": "what about  map<vector<int>, int> ?"
                    },
                    {
                        "username": "jackburg",
                        "content": "This should be easy. "
                    },
                    {
                        "username": "_sharma",
                        "content": "I didn\\'t get the question itself :( had to watch youtube video to understand the question."
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It\\'s the way you do it, Brute force is accepted but for beginners, doing this problem in O(n*n) using hashing might be little different."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Good morning warriors!!"
                    },
                    {
                        "username": "eduard92",
                        "content": "This is a medium based on the skill needed despite the time complexity that allows brute force.\\nDon\\'t be hard on yourself if you can\\'t solve it quickly and others are bragging is easy. \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "To optimize, convert to string and use unordered map\\nwhile converting to string use any character as separator for each element\\nex. 1, 26, 32  -->  \"1_26_32\""
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Why medium"
                    },
                    {
                        "username": "ahmz",
                        "content": "This is a perfect medium problem. I liked all 3 ways it can be solved."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "Bro, at least solve the problem first before questioning the difficulty..."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "java solution which beats 100% is counting sum of rows and cols and storing it into the arrays and comparing that array sums.\\nI also thought the same at first but then I realized it should not be true in every case. but after I saw that solution I think testcases are not constructed well although it\\'s a medium level problem."
                    },
                    {
                        "username": "dingwalnitin",
                        "content": "no, in the first testcase itself, it wont work"
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "[@SahilNikam](/SahilNikam) Yes, it\\'s effectively hashing the array into a long, but the hash has collisions:\\n\\n- `[[2,1],[1,11]]` has an expected output of `2` but with that solution copy-pasted, you get a wrong output of `4`.\\n- That solution reasons that `[2,1]` is an equal pair to `[1, 11]` because `(2*10 + 1) == (1*10 + 11) == 21 == 21` so it overcounts"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "[@juangutierrez01](/juangutierrez01) bro actually I was wrong in reading 0ms solution, actually they are maintaining long array and converting array row and col elements into long number by multiplying it by 10 and adding it. then after comparison we get the ans."
                    },
                    {
                        "username": "juangutierrez01",
                        "content": "For example, [[2,1],[1,11]] gives wrong answer for the 3 ms java solutions using array sums"
                    },
                    {
                        "username": "codejoker223",
                        "content": "there is one testcase where grid is grid = [[2,1],[1,34]]\\n\\nand expected output is 2 \\ni don\\'t understand how?\\n\\ncan anyone please help?\\n\\n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Row 0 and column 0 are equal, they are all `[2, 1]`. Row 1 and column 1 are equal, they are all `[1, 34]`"
                    },
                    {
                        "username": "psionl0",
                        "content": "``2  1``\n``1 34``"
                    },
                    {
                        "username": "coderInUS",
                        "content": "rows{21=1, 44=1}\\ncols{21=1, 44=1}"
                    },
                    {
                        "username": "RiteshArora",
                        "content": "1 = row 0, col 0 and 2 = row 1, col 1"
                    }
                ]
            },
            {
                "id": 1927296,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1947166,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927568,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927314,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1949055,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1932258,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927857,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 1927467,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2059722,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2046804,
                "content": [
                    {
                        "username": "sameertri039",
                        "content": "I really can\\'t understand LeetCode\\'s difficulty algorithm. This question is tagged as Medium which belongs to the same category as questions like Word Search, Redundant Connections etc. which are nightmares for beginners."
                    },
                    {
                        "username": "Tigarana",
                        "content": "Depends on your background I guess. For me, as a beginner, I agree that this was much simpler than the others. But it highly depends on the concepts one already knows, and I\\'m very familiar with matrices. "
                    },
                    {
                        "username": "johnnychang",
                        "content": "matrix is definitely not easy for beginners. Also one concept may be easier for one than others. "
                    },
                    {
                        "username": "daring-calf",
                        "content": "Well, this is too a nightmare for beginners."
                    },
                    {
                        "username": "Barani2001",
                        "content": "grid = [[11,1],[1,11]] the output I get which I think I am correct is 4.\\nBut the expected output is 2.\\n\\nCan any one explain which is correct?"
                    },
                    {
                        "username": "FWard",
                        "content": "Do not think of columns and rows backwards or diagonally. Just go from right to left, top to bottom"
                    },
                    {
                        "username": "lamasonmez",
                        "content": "[@Barani R](/Barani2001) please note that the row 0= 11,1 is a match with column 0 = 11,1 and the row 1 = 1,11 is a match with column 1 = 1, 11 , so the correct answer is = 2 , while there is another testcase [[13,13],[13,13]] , so here the row 0 is a match with column 0 and 1 , and also the row 1 is a match with columsn 0, and1 so the answer is 4 "
                    },
                    {
                        "username": "swatantrajain_02",
                        "content": "I\\'m not able to understand the language of the question. Can someone help ? "
                    },
                    {
                        "username": "maynouf",
                        "content": "You can have a look at my tip here: https://leetcode.com/problems/equal-row-and-column-pairs/description/comments/1927857\\n\\nBasically in the first case, column 1 is [2, 7, 7], and the last row is also [2, 7, 7]. It helps if you look at the image (if you can); you don\\'t have to perform any calculations on numbers or anything like that."
                    },
                    {
                        "username": "Tigarana",
                        "content": "It might help looking at the example. In Example 1, you can see that row 2 (=[2,7,7]) is the same as column 1 (=[2,7,7]). No other pairs are found, so answer = 1\\n"
                    },
                    {
                        "username": "pramod74",
                        "content": "Enjoyed solving this puzzle today, Along the way, learnt an efficient way to transpose a matrix! Thanks!"
                    },
                    {
                        "username": "Dwaraganathan15",
                        "content": "What is that efficient way..?!\\n"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "Am I missing something?\\n[[13,13],[13,13]] = 4\\nYet\\n[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]] = 3\\nI\\'m seeing -\\n3,1,2,2 x 2 (column 0, row 0)\\n2,4,2,2 x 3 (column 2, row 2, row 3)\\n= 5 \\nFollowing same logic as [[13,13],[13,13]] = 4"
                    },
                    {
                        "username": "mh72156",
                        "content": "[[3,1,2,2],[1,4,4,4],[2,4,2,2],[2,5,2,2]]\\n\\noutput:2\\nexpected: 3\\n\\nhow??"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "$\\\\begin{matrix}\\n3 & 1 & 2 & 2 \\\\\\\\\\n1 & 4 & 4 & 4 \\\\\\\\\\n2 & 4 & 2 & 2 \\\\\\\\\\n2 & 5 & 2 & 2\\n\\\\end{matrix}$\\n\\nrow 0, column 0 :  3122\\nrow 2, column 2 :  2422\\nrow 2, column 3 :  2422"
                    },
                    {
                        "username": "maynouf",
                        "content": "I had a hard time understanding the wording of the problem. Basically, for the first example, the second column (1st if 0-indexed) of the matrix is [2, 7, 7], which is the same value of the last row [2, 7, 7]. \\n\\nSame thing happens in the second example: the 2nd column (3rd if 0-indexed) of Example 2 is [2, 4, 2, 2], which is the same list of numbers as the two last rows of the matrix. \\n\\nI hope this helps someone."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "BRUTE FORCE: \\nStep1: make another matrix of n*n and transpose it.\\nStep2: Transpose means row become column and column.\\nStep3:for each row of original matrix check all the row of transposed matrix. 3 loops used.\\n\\nOPTIMAL:\\nStep1: make a map which store vector of row size;\\nstep2: store all the rows in vector.\\nStep3: transpose the original matrix. \\nStep4: check the transpose matrix is in map or not.\\nStep5: if transpose row exist in map increase counter.\\nstep6: return counter.\\n\\nTime complexity:\\nBRUTE FORCE: O(n^3)\\nOPTIMAL:O(n^2 + nlogn) =>n^2 for transposing + nlogn for searching each row in map take logn time so nlogn. ==O(n^2)\\n\\nSpace Complexity:\\nBRUTE FORCE: O(n^2) \\nOPTIMAL:O(n^2) map is storing n row\\'s of n size each.\\n\\nPlease Upvote if you Understand the Concept.\\nSolution link:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631646/c-brute-force-optimal/"
                    },
                    {
                        "username": "harshitaguptaaaa",
                        "content": "def equalPairs(self, grid: List[List[int]]) -> int:\\n\\n        map={}\\n        count=0\\n        for i in range(len(grid)):\\n            s=\"\"\\n            for j in range(len(grid[0])):\\n                s+=str(grid[i][j])\\n                s+=\"*\"\\n\\n            if s in map:\\n                map[s]+=1\\n            else:\\n                map[s]=1\\n\\n        for i in range(len(grid[0])):\\n            s=\"\"\\n            for j in range(len(grid)):\\n                s+=str(grid[j][i])\\n                s+=\"*\"\\n            count+=map[s]\\n\\n        return count  \\nThis is my code I don\\' understand why there is error  in count+=map[s]"
                    },
                    {
                        "username": "iamnot_coder",
                        "content": "Don't convert the numbers in a row or column to string and then comparing it. The test case fails when it is [[11,1],  [1,11]]. this gives 4 as output but the real answer is 2. Instead of converting it into string just make map that accepts the vector like map\nmap<vector<int>, int> mp"
                    },
                    {
                        "username": "Anya819",
                        "content": "use a separator when creating strings to maintain order e.g 11_1 != 1_11"
                    }
                ]
            },
            {
                "id": 2045650,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 2001818,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1991924,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1975685,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1972771,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1965066,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1963877,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1959722,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1950408,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1929521,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "Looks that the existing testcases don\\'t have matrices with duplicate columns:\\na solution with missed handling of duplicate columns passes all the tests."
                    },
                    {
                        "username": "RyanRosario11",
                        "content": "This problem is a pain in Python for other reasons aside from the algorithm."
                    },
                    {
                        "username": "Koffi_exe",
                        "content": "Discuss\\n"
                    },
                    {
                        "username": "excute_15",
                        "content": "please help what is wrong with this code\n vector <string>   v,vp;\n        int n=grid.size();\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[i][j];\n            }\n            v.push_back(s);\n        }\n        for(int i=0;i<n;i++){\n            string s=\"\";\n            for(int j=0;j<n;j++){\n               s+=grid[j][i];\n            }\n            vp.push_back(s);\n        }\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(v[i]==vp[j]){\n                    ans++;\n                }\n            }\n        }\n        return ans;\nfor input :[[250,78,253],[334,252,253],[250,253,253]]\noutput is 0 but compiler show 1 how?"
                    },
                    {
                        "username": "hugjobk",
                        "content": "I used brute force to solve this without TLE :))"
                    },
                    {
                        "username": "narasimhakamath",
                        "content": "1. You can create two maps with a key of the row and column values respectively separated by underscore or a full stop, and the count of each of it.\\n2. Set a counter with an initial value of 0.\\n3. Loop through either the row map or the column map. If the value is present in the other map, then multiply the values of both the common keys and keep incrementing the counter value.\\n4. Return count."
                    },
                    {
                        "username": "schwaccc",
                        "content": "I'm confused about the definition of equal pairs. My understanding is if the combination of indices of row and col are different, then it's a unique pair. So after we calculate the counts of each rows and cols in HashMap, the final result should be the product of two count values from row map and col map. Why is it simply an addition?\n\nFor example:\n3, 1, 2, 2, 2\n1, 4, 4, 4, 1\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n2, 4, 2, 2, 2\n\ncounts of 24222 in rows are 3 and 2 in columns. So it should be 2X3 instead of 2+3.\n\nThe total equal pairs are 7 as follows:\n[R0, C0]\n[R2, C2]\n[R2, C3]\n[R3, C2]\n[R3, C3]\n[R4, C2]\n[R4, C3]\n\nCan anybody help to explain this? Thanks! I implemented the code using this method and passed with AC."
                    },
                    {
                        "username": "lytao",
                        "content": "My solution is accepted all cases are passed. But I know this solution is not entirely corrected or complete. \\n\\nBetter test cases are needed for this problem."
                    },
                    {
                        "username": "muemresahin",
                        "content": "why for array  [[11,1],[1,11]] expected answer is 2 ?"
                    },
                    {
                        "username": "schwaccc",
                        "content": "[11, 1]\\n[1, 11]\\n\\nequal pairs are: \\n[row 0, col 0]\\n[row 1, col 1]"
                    },
                    {
                        "username": "kenlau",
                        "content": "I found the question does not specify the order on how to read the row (left to right or right to left) and column (top to bottom or bottom to top).\\nShouldn\\'t the case `grid = [[3,2,1],[1,7,6],[7,7,2]]` (slightly tweak from example 1 where the last row becomes `7 7 2`) has 1 pair if we read the last row from right to left"
                    },
                    {
                        "username": "Tigarana",
                        "content": "It does, by mentioning that it should be in the same order. Meaning that going through a row grid[r_i][:] and through a row grid[:][c_i] equals left-to-right and top-down. "
                    }
                ]
            },
            {
                "id": 1928642,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928454,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928180,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928179,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928166,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1928148,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927831,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927763,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927748,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927714,
                "content": [
                    {
                        "username": "DeclanGH",
                        "content": "Someone please explain this. grid = [[13,13],[13,13]]\\nThis means when we see [13,13] on the first row, the second row is repeat 1, column 1 is repeat 2 and column 2 is repeat 3. \\nMy code output 3, but they said the expected answer is 4. How is that ???"
                    },
                    {
                        "username": "adityapanzer",
                        "content": "[@DeclanGH](/DeclanGH) I had similar output for my solution.. guess we gotta try some otherway"
                    },
                    {
                        "username": "maynouf",
                        "content": "[@DeclanGH](/DeclanGH) row wise:\n- first row [13, 13]; count 1\n- second row [13, 13]; count 2\ncolumn wise:\n- first column [13, 13]; count 3\n- second column [13, 13]; count 4"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@maynouf](/maynouf) That is just two then. according to the example given, that is not how you count the repeats. \\n"
                    },
                    {
                        "username": "maynouf",
                        "content": "in terms of rows, 0 and 1 are equal: [13, 13]\\nin terms of columns, 0 and 1 are equal:\\n[13,\\n13]\\nthus, 4"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Trying to learn here:\\n\\nI solved the problem brute force, I\\'ve played with the idea to convert the row into a string or concatenated int and compare only one value per row, instead of n values. However, my intuition said that creating a combined parameter (either string or int) would also take time complexity O(n) and therefore end result would be the same (or worst) than element-wise comparison. \\n\\nThan I checked other peoples comments mentioning hash tables as a solution. Which seems conceptually close to what I had in mind, but intuitively thought not to be more efficient. Can someone explain to me why creating the hash table is not adding time complexity? "
                    },
                    {
                        "username": "psionl0",
                        "content": "To compare each row with each column requires n^2 calculations. But hashing each row and each column only requires 2n calculations. You still need to compare a row and column if their hashes match but if they don\\'t match then no further comparison is required for that row/column pair."
                    },
                    {
                        "username": "indrajit10",
                        "content": "[leetcode](https://leetcode.com) @"
                    },
                    {
                        "username": "indrajit10",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "AariazP",
                        "content": "There is a testcase where [[13,13],[13,13]] should return 4 but is actually 3. Does anyone know why?"
                    },
                    {
                        "username": "DeclanGH",
                        "content": "[@ashish030899](/ashish030899) I asked this same question. it is completely wrong according to the example and explanation we were given. Don\\'t try to justify the result they gave us. "
                    },
                    {
                        "username": "ashish030899",
                        "content": "It is going for all possible combinations so 2 rows and 2 columns will have 4 same rows and columns\\n"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Create a hashmap row, of string and integer and convert the each row into string and calculate the frequency of it.\\nexample -> 3,2,1 -> \",3,2,1\"\\nNow create a string row col and convert each col in string in similiar way.\\nIterate the col array and check if map contains the key or not and store the frequency into count variable.\\n\\nReturn count;\\n"
                    },
                    {
                        "username": "ashish030899",
                        "content": "Not to be considered as a medium level question but here how you can approach it.\\nUse hash map and use vector(rows) as key to count the rows and then using it find the columns that are present in row map. If present then increase the count by number of rows present.\\nThere is no need to have two hash maps for both. You can simply do it with just one.\\n\\nHope it helps.\\n"
                    },
                    {
                        "username": "SibtainAhmed",
                        "content": "Make a HashMap for ROWS (count repeating rows that no. of times)\\nusing nested loop make COLUMNS and check it in HashMap if availaible then add in Result (that no. of times row is repeating).\\nFor Pythonists \\uD83D\\uDC0D use defaultdict(int) "
                    },
                    {
                        "username": "ghost_rider2002",
                        "content": "unordered_map<vector<int>,int> mp;\\n        int ans=0;\\n      for(int i=0;i<grid.size();i++){\\n          mp[grid[i]]++;\\n      }\\n      for(int j=0;j<grid[0].size();j++){\\n          vector<int> v;\\n          for(int i=0;i<grid.size();i++){\\n              v.push_back(grid[i][j]);\\n          }\\n           ans+=mp[v];\\n      }\\n      return ans;\\n\\n\\n\\nwhy this code is getting error???\\n it is working on orderd map!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "Hey, I am from future!!!!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@its_shivamjha](/its_shivamjha) I am fine, what about you dude!!!!"
                    },
                    {
                        "username": "singhadityakumar1911",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) yeah we have!!!!!"
                    },
                    {
                        "username": "shivamkjha",
                        "content": "waasupp bro?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Hey, do you have flying hoverboards there?"
                    }
                ]
            },
            {
                "id": 1927696,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927659,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927607,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927575,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927496,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927301,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927276,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1927154,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1907173,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            },
            {
                "id": 1706555,
                "content": [
                    {
                        "username": "sarwa_deshpande",
                        "content": "for [[13,13][13,13]] how the op is 4 should it be 2 , please can anyone explain?"
                    },
                    {
                        "username": "hero080",
                        "content": "`row1 == col1, row2 == col2, row1 == col2, row2 == col1`"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "BruteForce worked here :)"
                    },
                    {
                        "username": "Kodiac1",
                        "content": "[@Tigarana](/Tigarana) \\uD83D\\uDE4C"
                    },
                    {
                        "username": "Tigarana",
                        "content": "Same for me \\uD83D\\uDE2C happily surprised!"
                    },
                    {
                        "username": "purushattom1999",
                        "content": "This is really easy type question."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "This is easy one, brute force works!\\nMy approach was take another 2d vector and store Column level traversal\\nthen I matched those arrays\\nwell, time complexity is worst in this case, but as n<=200 so it got accepted!"
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have a doubt what is the cost of comparing two strings of length n. in c++ we do directly if(s1==s2). is it O(1) or O(n) internally. can anyone confirm;"
                    },
                    {
                        "username": "Tigarana",
                        "content": "I assumed it would be O(1) as its considered a string and not an array of char, but would be good to have someone confirm "
                    },
                    {
                        "username": "wypeng1103",
                        "content": "using row as key to get the counter result by map"
                    },
                    {
                        "username": "noman598",
                        "content": "O(n^2) solution hint - \\n\\n1.Store rows of grid as key in Unordered_Map and their count as value.\\n2.Now use 2 for loop to traverse grid by column-wise and store the col in new vector and check weather column vector is present in map or not. if yes -> increment count otherwise leave.\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "Or do not create new vectors (nor copy vectors into hash map keys). Use C++ tricks:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-on2-on-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "hero080",
                        "content": "We can do this in $O(N^2)$ time and $O(N)$ extra space:\\nhttps://leetcode.com/problems/equal-row-and-column-pairs/solutions/3630895/beat-100-o-n-2-o-n-optimal-solution-art-of-c/"
                    },
                    {
                        "username": "SchlechtGut",
                        "content": "why is it n^2? "
                    },
                    {
                        "username": "ananyaj1",
                        "content": "You have to iterate through every element in the 2d vector, which is n^2 time."
                    },
                    {
                        "username": "calm27",
                        "content": "I made it using prefix sum however test 68/72 failed with Time Limit Exceeded. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Design a Food Rating System",
        "question_content": "<p>Design a food rating system that can do the following:</p>\n\n<ul>\n\t<li><strong>Modify</strong> the rating of a food item listed in the system.</li>\n\t<li>Return the highest-rated food item for a type of cuisine in the system.</li>\n</ul>\n\n<p>Implement the <code>FoodRatings</code> class:</p>\n\n<ul>\n\t<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> Initializes the system. The food items are described by <code>foods</code>, <code>cuisines</code> and <code>ratings</code>, all of which have a length of <code>n</code>.\n\n\t<ul>\n\t\t<li><code>foods[i]</code> is the name of the <code>i<sup>th</sup></code> food,</li>\n\t\t<li><code>cuisines[i]</code> is the type of cuisine of the <code>i<sup>th</sup></code> food, and</li>\n\t\t<li><code>ratings[i]</code> is the initial rating of the <code>i<sup>th</sup></code> food.</li>\n\t</ul>\n\t</li>\n\t<li><code>void changeRating(String food, int newRating)</code> Changes the rating of the food item with the name <code>food</code>.</li>\n\t<li><code>String highestRated(String cuisine)</code> Returns the name of the food item that has the highest rating for the given type of <code>cuisine</code>. If there is a tie, return the item with the <strong>lexicographically smaller</strong> name.</li>\n</ul>\n\n<p>Note that a string <code>x</code> is lexicographically smaller than string <code>y</code> if <code>x</code> comes before <code>y</code> in dictionary order, that is, either <code>x</code> is a prefix of <code>y</code>, or if <code>i</code> is the first position such that <code>x[i] != y[i]</code>, then <code>x[i]</code> comes before <code>y[i]</code> in alphabetic order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;FoodRatings&quot;, &quot;highestRated&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;]\n[[[&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]], [&quot;korean&quot;], [&quot;japanese&quot;], [&quot;sushi&quot;, 16], [&quot;japanese&quot;], [&quot;ramen&quot;, 16], [&quot;japanese&quot;]]\n<strong>Output</strong>\n[null, &quot;kimchi&quot;, &quot;ramen&quot;, null, &quot;sushi&quot;, null, &quot;ramen&quot;]\n\n<strong>Explanation</strong>\nFoodRatings foodRatings = new FoodRatings([&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]);\nfoodRatings.highestRated(&quot;korean&quot;); // return &quot;kimchi&quot;\n                                    // &quot;kimchi&quot; is the highest rated korean food with a rating of 9.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;ramen&quot;\n                                      // &quot;ramen&quot; is the highest rated japanese food with a rating of 14.\nfoodRatings.changeRating(&quot;sushi&quot;, 16); // &quot;sushi&quot; now has a rating of 16.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;sushi&quot;\n                                      // &quot;sushi&quot; is the highest rated japanese food with a rating of 16.\nfoodRatings.changeRating(&quot;ramen&quot;, 16); // &quot;ramen&quot; now has a rating of 16.\nfoodRatings.highestRated(&quot;japanese&quot;); // return &quot;ramen&quot;\n                                      // Both &quot;sushi&quot; and &quot;ramen&quot; have a rating of 16.\n                                      // However, &quot;ramen&quot; is lexicographically smaller than &quot;sushi&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>n == foods.length == cuisines.length == ratings.length</code></li>\n\t<li><code>1 &lt;= foods[i].length, cuisines[i].length &lt;= 10</code></li>\n\t<li><code>foods[i]</code>, <code>cuisines[i]</code> consist of lowercase English letters.</li>\n\t<li><code>1 &lt;= ratings[i] &lt;= 10<sup>8</sup></code></li>\n\t<li>All the strings in <code>foods</code> are <strong>distinct</strong>.</li>\n\t<li><code>food</code> will be the name of a food item in the system across all calls to <code>changeRating</code>.</li>\n\t<li><code>cuisine</code> will be a type of cuisine of <strong>at least one</strong> food item in the system across all calls to <code>highestRated</code>.</li>\n\t<li>At most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>changeRating</code> and <code>highestRated</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2324669,
                "title": "three-maps",
                "content": "- `cuisine_ratings` maps cuisine to food, ordered by rating (we use a sorted set).\\n- `food_cuisine` maps food to cuisine.\\n- `food_rating` maps food to the current rating.\\n    \\nFor the `changeRating` operation, we first get the cuisine and current rating for the food. \\n    \\nThen, we remove the old food rating from `cuisine_ratings`, and add the new one.\\n\\n> Implementation note: since we need to return food with the highest rating, we put a negative rating into the set.\\n> That way, we do not have to provide a custom comparator.\\n    \\n**C++**\\n```cpp\\nclass FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int, string>>> cuisine_ratings;\\n    unordered_map<string, string> food_cuisine;\\n    unordered_map<string, int> food_rating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); ++i) {\\n            cuisine_ratings[cuisines[i]].insert({ -ratings[i], foods[i] });\\n            food_cuisine[foods[i]] = cuisines[i];\\n            food_rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto &cuisine = food_cuisine.find(food)->second;\\n        cuisine_ratings[cuisine].erase({ -food_rating[food], food });\\n        cuisine_ratings[cuisine].insert({ -newRating, food });\\n        food_rating[food] = newRating;\\n    }\\n    string highestRated(string cuisine) {\\n        return begin(cuisine_ratings[cuisine])->second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int, string>>> cuisine_ratings;\\n    unordered_map<string, string> food_cuisine;\\n    unordered_map<string, int> food_rating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); ++i) {\\n            cuisine_ratings[cuisines[i]].insert({ -ratings[i], foods[i] });\\n            food_cuisine[foods[i]] = cuisines[i];\\n            food_rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto &cuisine = food_cuisine.find(food)->second;\\n        cuisine_ratings[cuisine].erase({ -food_rating[food], food });\\n        cuisine_ratings[cuisine].insert({ -newRating, food });\\n        food_rating[food] = newRating;\\n    }\\n    string highestRated(string cuisine) {\\n        return begin(cuisine_ratings[cuisine])->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324714,
                "title": "java-priority-queue-hashmap-and-custom-class",
                "content": "**Code:**\\n    \\n    HashMap<String, PriorityQueue<Food>> x = new HashMap<>(); // get pq from cuisine name\\n    HashMap<String, Food> menu = new HashMap<>(); // get Food (object) from food name\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0; i<foods.length; i++){\\n\\t\\t\\tFood curr = new Food(foods[i], cuisines[i], ratings[i]);\\n            x.putIfAbsent(cuisines[i], new PriorityQueue<>((a,b)->\\n                b.rating==a.rating ? a.name.compareTo(b.name) : b.rating-a.rating));\\n\\t\\t\\tPriorityQueue<Food> pq = x.get(cuisines[i]);\\n            pq.add(curr);\\n            menu.put(foods[i], curr);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food curr = menu.get(food);\\n        PriorityQueue<Food> pq = x.get(curr.cuisine);\\n        pq.remove(curr);\\n        curr.rating = newRating;\\n        pq.add(curr);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return x.get(cuisine).peek().name;\\n    }\\n    \\n    class Food{\\n        int rating;\\n        String name, cuisine;\\n        Food(String name, String cuisine, int rating){\\n            this.name = name; this.rating = rating; this.cuisine = cuisine;\\n        }\\n    }\\n\\t\\n---\\n**For TreeSet Based:**\\n* replace all `PriorityQueue<Food>` with `TreeSet<Food>`\\n* use `return x.get(cuisine).first().name;` for highestRated()",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "**Code:**\\n    \\n    HashMap<String, PriorityQueue<Food>> x = new HashMap<>(); // get pq from cuisine name\\n    HashMap<String, Food> menu = new HashMap<>(); // get Food (object) from food name\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0; i<foods.length; i++){\\n\\t\\t\\tFood curr = new Food(foods[i], cuisines[i], ratings[i]);\\n            x.putIfAbsent(cuisines[i], new PriorityQueue<>((a,b)->\\n                b.rating==a.rating ? a.name.compareTo(b.name) : b.rating-a.rating));\\n\\t\\t\\tPriorityQueue<Food> pq = x.get(cuisines[i]);\\n            pq.add(curr);\\n            menu.put(foods[i], curr);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food curr = menu.get(food);\\n        PriorityQueue<Food> pq = x.get(curr.cuisine);\\n        pq.remove(curr);\\n        curr.rating = newRating;\\n        pq.add(curr);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return x.get(cuisine).peek().name;\\n    }\\n    \\n    class Food{\\n        int rating;\\n        String name, cuisine;\\n        Food(String name, String cuisine, int rating){\\n            this.name = name; this.rating = rating; this.cuisine = cuisine;\\n        }\\n    }\\n\\t\\n---\\n**For TreeSet Based:**\\n* replace all `PriorityQueue<Food>` with `TreeSet<Food>`\\n* use `return x.get(cuisine).first().name;` for highestRated()",
                "codeTag": "Java"
            },
            {
                "id": 2324713,
                "title": "c-map",
                "content": "HAPPY CODING :)\\n \\n **IF YOU LEARN SOMETHING FROM THIS POST, DO UPVOTE :)**\\n```\\nclass FoodRatings {\\npublic:\\n    map<string,set<pair<int,string>>> s;\\n    unordered_map<string,string> cus;\\n    unordered_map<string,int> rat;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();++i)\\n        {\\n            s[cuisines[i]].insert({-ratings[i],foods[i]});\\n            cus[foods[i]]=cuisines[i];\\n            rat[foods[i]]=-ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int r=rat[food];\\n        string c=cus[food];\\n        s[c].erase({r,food});\\n        s[c].insert({-newRating,food});\\n        rat[food]=-newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        pair<int,string> p= *(s[cuisine].begin());\\n        return p.second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    map<string,set<pair<int,string>>> s;\\n    unordered_map<string,string> cus;\\n    unordered_map<string,int> rat;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();++i)\\n        {\\n            s[cuisines[i]].insert({-ratings[i],foods[i]});\\n            cus[foods[i]]=cuisines[i];\\n            rat[foods[i]]=-ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int r=rat[food];\\n        string c=cus[food];\\n        s[c].erase({r,food});\\n        s[c].insert({-newRating,food});\\n        rat[food]=-newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        pair<int,string> p= *(s[cuisine].begin());\\n        return p.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324791,
                "title": "python3-sortedlist",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/d61cd3ed09bbf59fd619802a6e861a516ec17094) for solutions of weekly 303. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.mp = {}\\n        self.data = defaultdict(SortedList)\\n        for food, cuisine, rating in zip(foods, cuisines, ratings): \\n            self.mp[food] = (cuisine, rating)\\n            self.data[cuisine].add((-rating, food))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, rating = self.mp[food]\\n        self.mp[food] = cuisine, newRating\\n        self.data[cuisine].remove((-rating, food))\\n        self.data[cuisine].add((-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.data[cuisine][0][1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.mp = {}\\n        self.data = defaultdict(SortedList)\\n        for food, cuisine, rating in zip(foods, cuisines, ratings): \\n            self.mp[food] = (cuisine, rating)\\n            self.data[cuisine].add((-rating, food))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, rating = self.mp[food]\\n        self.mp[food] = cuisine, newRating\\n        self.data[cuisine].remove((-rating, food))\\n        self.data[cuisine].add((-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.data[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324852,
                "title": "python-hashmap-heap-extravaganza",
                "content": "We have a heap for each cuisine. We push to the heap whenever we update a rating. We check the rating is current before returning the Highest rating.\\n\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.foods = foods; self.cuisines = cuisines; self.ratings = ratings\\n        self.index = dict(zip(foods, range(n)))\\n        self.cuisinesMap = defaultdict(list)\\n        for i, cuisine in enumerate(cuisines):\\n            heappush(self.cuisinesMap[cuisine], (-self.ratings[i], self.foods[i]))\\n            \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        i = self.index[food]\\n        self.ratings[i] = newRating; cuisine = self.cuisines[i]\\n        heappush(self.cuisinesMap[cuisine], (-self.ratings[i], self.foods[i]))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisinesMap[cuisine][0]\\n        while rating != -self.ratings[self.index[food]]:  # check highest rating is current\\n            heappop(self.cuisinesMap[cuisine])\\n            rating, food = self.cuisinesMap[cuisine][0]\\n        return food\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.foods = foods; self.cuisines = cuisines; self.ratings = ratings\\n        self.index = dict(zip(foods, range(n)))\\n        self.cuisinesMap = defaultdict(list)\\n        for i, cuisine in enumerate(cuisines):\\n            heappush(self.cuisinesMap[cuisine], (-self.ratings[i], self.foods[i]))\\n            \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        i = self.index[food]\\n        self.ratings[i] = newRating; cuisine = self.cuisines[i]\\n        heappush(self.cuisinesMap[cuisine], (-self.ratings[i], self.foods[i]))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisinesMap[cuisine][0]\\n        while rating != -self.ratings[self.index[food]]:  # check highest rating is current\\n            heappop(self.cuisinesMap[cuisine])\\n            rating, food = self.cuisinesMap[cuisine][0]\\n        return food\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324903,
                "title": "heap-and-hashmap-fully-explained",
                "content": "Our goal is to return quickly the most rated food for the queried cuisine.\\n\\nWe can achieve this with a `heap`\\n\\nNow there is also a functionality to change the rating of a food item.\\n\\nWe could find it in the heap and mutate, but it will be too slow and lose the point of the heap.\\n\\nInstead of that we will do **lazy deletion** with the help of a hash map\\n\\n`food_to_latest_ratings` hashmap will save the latest rating for a specific food, and if the value we found in the heap doesn\\'t match we know that the entry was obsolete, so we continue searching for the next one which is valid.\\n\\nAlso we need to create a custom class `RatedFood` to sort lexicographically as the second sort condition (at least in python)\\n\\n```\\nfrom heapq import heapify, heappop, heappush\\n\\nclass RatedFood:\\n    def __init__(self, rating, food):\\n        self.rating = rating\\n        self.food = food\\n        \\n    def __lt__(self, other):\\n        if other.rating == self.rating:\\n            return self.food < other.food\\n        return self.rating < other.rating\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuis_to_score_heap = defaultdict(list)\\n        self.food_to_latest_ratings = defaultdict(int)\\n        self.food_to_cuis = defaultdict(str)\\n        \\n        for food, cuis, rating in zip(foods, cuisines, ratings):\\n            self.food_to_cuis[food] = cuis\\n            self.food_to_latest_ratings[food] = rating\\n            heappush(self.cuis_to_score_heap[cuis], RatedFood(-rating, food))\\n        \\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_to_latest_ratings[food] = newRating\\n        cuis = self.food_to_cuis[food]\\n        heappush(self.cuis_to_score_heap[cuis], RatedFood(-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while True:\\n            ratedFood = heappop(self.cuis_to_score_heap[cuisine])\\n            if self.food_to_latest_ratings[ratedFood.food] == (-ratedFood.rating):\\n\\t\\t\\t\\n\\t\\t\\t\\t# because the food item is still valid, we put it back into the heap\\n                heappush(self.cuis_to_score_heap[cuisine], ratedFood)\\n\\t\\t\\t\\t\\n                return ratedFood.food\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heappop, heappush\\n\\nclass RatedFood:\\n    def __init__(self, rating, food):\\n        self.rating = rating\\n        self.food = food\\n        \\n    def __lt__(self, other):\\n        if other.rating == self.rating:\\n            return self.food < other.food\\n        return self.rating < other.rating\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuis_to_score_heap = defaultdict(list)\\n        self.food_to_latest_ratings = defaultdict(int)\\n        self.food_to_cuis = defaultdict(str)\\n        \\n        for food, cuis, rating in zip(foods, cuisines, ratings):\\n            self.food_to_cuis[food] = cuis\\n            self.food_to_latest_ratings[food] = rating\\n            heappush(self.cuis_to_score_heap[cuis], RatedFood(-rating, food))\\n        \\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_to_latest_ratings[food] = newRating\\n        cuis = self.food_to_cuis[food]\\n        heappush(self.cuis_to_score_heap[cuis], RatedFood(-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while True:\\n            ratedFood = heappop(self.cuis_to_score_heap[cuisine])\\n            if self.food_to_latest_ratings[ratedFood.food] == (-ratedFood.rating):\\n\\t\\t\\t\\n\\t\\t\\t\\t# because the food item is still valid, we put it back into the heap\\n                heappush(self.cuis_to_score_heap[cuisine], ratedFood)\\n\\t\\t\\t\\t\\n                return ratedFood.food\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324861,
                "title": "c-two-unordered-maps-are-all-you-need",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    unordered_map<string, map<int, set<string>>> cuisine2rateAndFood;\\n    unordered_map<string, pair<int, string>> food2cuisineAndRate;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; ++i) {\\n            cuisine2rateAndFood[cuisines[i]][ratings[i]].insert(foods[i]);\\n            food2cuisineAndRate[foods[i]] = make_pair(ratings[i], cuisines[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [prevRating, cuisine] = food2cuisineAndRate[food];\\n        cuisine2rateAndFood[cuisine][prevRating].erase(food);\\n        if (cuisine2rateAndFood[cuisine][prevRating].empty()) {\\n            cuisine2rateAndFood[cuisine].erase(prevRating);\\n        }\\n        cuisine2rateAndFood[cuisine][newRating].insert(food);\\n        \\n        food2cuisineAndRate[food].first = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto foodSet = cuisine2rateAndFood[cuisine].rbegin()->second;\\n        return *foodSet.begin();\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    unordered_map<string, map<int, set<string>>> cuisine2rateAndFood;\\n    unordered_map<string, pair<int, string>> food2cuisineAndRate;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; ++i) {\\n            cuisine2rateAndFood[cuisines[i]][ratings[i]].insert(foods[i]);\\n            food2cuisineAndRate[foods[i]] = make_pair(ratings[i], cuisines[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [prevRating, cuisine] = food2cuisineAndRate[food];\\n        cuisine2rateAndFood[cuisine][prevRating].erase(food);\\n        if (cuisine2rateAndFood[cuisine][prevRating].empty()) {\\n            cuisine2rateAndFood[cuisine].erase(prevRating);\\n        }\\n        cuisine2rateAndFood[cuisine][newRating].insert(food);\\n        \\n        food2cuisineAndRate[food].first = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto foodSet = cuisine2rateAndFood[cuisine].rbegin()->second;\\n        return *foodSet.begin();\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331910,
                "title": "c-map-simple-explanation",
                "content": "\\nWe need to store two things -> rating and cuisine for every food because they are the ones affecting the changes in answer\\nThen we need to change the ratings which is simple using map, last map of set is for getting the highest rated cuisine food in minimum time possible, if we store the ratings in positive values the highest rating will be at the end but the food for that rating in smallest lexicograpgical order will not necessarily be at the end for multiple highest rating, so we use the set property to store the ratings in negative values , eg: { -50, Cake }, {-50, Donut } ......this is how it will be stored for  rating 50 and food items cake and donut, so this way the lexicographically smallest food item will automatically come in the first position\\n\\n``````````````````\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,int>mp;\\n    unordered_map<string,string>mp2;\\n    unordered_map<string,set<pair<int,string>>>hrating;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[foods[i]]=ratings[i];\\n            mp2[foods[i]]=cuisines[i];\\n            hrating[cuisines[i]].insert({-ratings[i],foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        string t=mp2[food];\\n        int tmp=mp[food];\\n        mp[food]=newRating;\\n        hrating[t].erase(hrating[t].find({-tmp,food}));\\n        hrating[t].insert({-newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        string res=\"\";\\n        auto anss=*(hrating[cuisine].begin());\\n        res=anss.second;\\n        return res;\\n    }\\n};\\n````````````````````````\\nPls UPVOTE if you understood\\n![image](https://assets.leetcode.com/users/images/71647b89-5e64-4694-b1d4-d096a65e9776_1659218495.424549.jpeg)",
                "solutionTags": [],
                "code": "``````\n``````\n``````\n``````\n``````\n``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 2325436,
                "title": "java-with-treeset",
                "content": "I used 3 Maps\\n1. Cuisine to food so we can get all food of that cuisine. I used a TreeSet to keep everything ordered. TreeSet is a binary search tree (Red Black Tree to be precise) so it\\'s balanced. \\n2. Food to Cuisine so we can know where to find the food TreeSet when updating the rating\\n3. Food to Rating (can be avoided if we created a custom class).\\n\\nLessons\\n1. TreeSet uses the comparator to see if your element exists in the TreeSet (might not be correct, that\\'s from personal experiments). Thus, remove the element, THEN update the rating, THEN insert again. Don\\'t do update, remove, insert. This way, TreeSet will contain duplicates.\\n2. Always use .equals() to compare Objects. That includes Integer. ```foodToRat.get(a)==(foodToRat.get(b))``` actually would break the code! HashMap.get() returns an Integer. \\n```\\nclass FoodRatings {\\n    HashMap<String, TreeSet<String>> cuiToFood = new HashMap();\\n    HashMap<String, Integer> foodToRat = new HashMap();\\n    HashMap<String, String> foodToCui = new HashMap();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.length; i++){\\n            TreeSet<String> foodOfThisCuisine = cuiToFood.getOrDefault(cuisines[i], new TreeSet<String> ((a,b)->\\n            foodToRat.get(a).equals(foodToRat.get(b)) ? a.compareTo(b) : foodToRat.get(b)-foodToRat.get(a)));\\n\\t\\t\\t\\n\\t\\t\\t// Both comparators are equal\\n\\t\\t\\t/* new Comparator<String>(){\\n                @Override\\n                public int compare(String a, String b){\\n                    int aRat = foodToRat.get(a);\\n                    int bRat = foodToRat.get(b);\\n                    \\n                    if(aRat != bRat) return bRat - aRat; // largest rating first\\n                    for(int i = 0; i < Math.min(a.length(), b.length()); i++){\\n                        if(a.charAt(i) != b.charAt(i)) return a.charAt(i) - b.charAt(i);\\n                    }\\n                    return a.length() - b.length();\\n                }\\n            })\\n\\t\\t\\t*/\\n            \\n            foodToRat.put(foods[i], ratings[i]);\\n            foodOfThisCuisine.add(foods[i]);\\n            foodToCui.put(foods[i], cuisines[i]);    \\n            \\n            cuiToFood.put(cuisines[i], foodOfThisCuisine);\\n        }\\n    }\\n    \\n    // CompareTo() is used to compare whether 2 strings are equal in hashSet! So remove, change value of key in HashMap, then insert again\\n    public void changeRating(String food, int newRating) {\\n        String cui = foodToCui.get(food);\\n        TreeSet<String> foodOfThisCui = cuiToFood.get(cui);\\n        foodOfThisCui.remove(food);\\n        foodToRat.put(food, newRating);\\n        \\n        foodOfThisCui.add(food);\\n        cuiToFood.put(cui, foodOfThisCui);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuiToFood.get(cuisine).first();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```foodToRat.get(a)==(foodToRat.get(b))```\n```\\nclass FoodRatings {\\n    HashMap<String, TreeSet<String>> cuiToFood = new HashMap();\\n    HashMap<String, Integer> foodToRat = new HashMap();\\n    HashMap<String, String> foodToCui = new HashMap();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.length; i++){\\n            TreeSet<String> foodOfThisCuisine = cuiToFood.getOrDefault(cuisines[i], new TreeSet<String> ((a,b)->\\n            foodToRat.get(a).equals(foodToRat.get(b)) ? a.compareTo(b) : foodToRat.get(b)-foodToRat.get(a)));\\n\\t\\t\\t\\n\\t\\t\\t// Both comparators are equal\\n\\t\\t\\t/* new Comparator<String>(){\\n                @Override\\n                public int compare(String a, String b){\\n                    int aRat = foodToRat.get(a);\\n                    int bRat = foodToRat.get(b);\\n                    \\n                    if(aRat != bRat) return bRat - aRat; // largest rating first\\n                    for(int i = 0; i < Math.min(a.length(), b.length()); i++){\\n                        if(a.charAt(i) != b.charAt(i)) return a.charAt(i) - b.charAt(i);\\n                    }\\n                    return a.length() - b.length();\\n                }\\n            })\\n\\t\\t\\t*/\\n            \\n            foodToRat.put(foods[i], ratings[i]);\\n            foodOfThisCuisine.add(foods[i]);\\n            foodToCui.put(foods[i], cuisines[i]);    \\n            \\n            cuiToFood.put(cuisines[i], foodOfThisCuisine);\\n        }\\n    }\\n    \\n    // CompareTo() is used to compare whether 2 strings are equal in hashSet! So remove, change value of key in HashMap, then insert again\\n    public void changeRating(String food, int newRating) {\\n        String cui = foodToCui.get(food);\\n        TreeSet<String> foodOfThisCui = cuiToFood.get(cui);\\n        foodOfThisCui.remove(food);\\n        foodToRat.put(food, newRating);\\n        \\n        foodOfThisCui.add(food);\\n        cuiToFood.put(cui, foodOfThisCui);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuiToFood.get(cuisine).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324774,
                "title": "write-bug-free-code-to-get-ac-hints-to-write-clean-code",
                "content": "## Bellow points would cast time in contest but you can able to avoid wa submission and it\\'s best practice for interview purpose. \\nWell, for such question where design is more important than the logic, we have to write bug free code. Because once you get the error in code than it\\'s hard to debug while in the contest because of large number of code.\\n*  So hint to write clean solution :\\n\\t*  Always write a variable name which have clear explanation, will help to quick debug.\\n\\t*  Try to enacpsulat as much as possible in single entity, It will help to handle the data.\\n\\t*  Split the design in class/function and each function must have only one task to do, So this will help to give confidence that if this function is correct you don\\'t need to check again\\n\\t*  Always check **Null Pointer exception** and that\\'s the major problem when you tackel with language like java.\\n\\t*  For debug/print perpuse override toString function of your class, due to this you can simply put sout and see the data.\\n\\t*  Always write code in well farmated manner, leetcode doesn\\'t give feature to auto-formate, So make habit of it.\\n\\t*  Avoid redundant code, it\\'ll give your code in smaller line, so smaller code will take smaller time to debug and you skip the typing time cast.\\n\\n\\n```\\nclass Data {\\n    String food;\\n    String cuisine;\\n    int rating;\\n    public Data(String food, String cuisine, int rating) {\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public void set(String food, String cuisine, int rating) {\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public String toString() {\\n        return food+\" \"+\" \"+cuisine+\" \"+rating;\\n    }\\n}\\n\\nclass FoodRatings {\\n    Map<String, Data> nameToData;\\n    Map<String, TreeSet<Data>> csToData;\\n    \\n    private void add(String food, String cuisine, int rating) {\\n        String combine = rating+food;\\n        Data data = nameToData.getOrDefault(food, null);\\n        \\n        if(data!=null && csToData.containsKey(data.cuisine)) {\\n            TreeSet<Data> set = csToData.get(data.cuisine);\\n            if(set!=null) {\\n                set.remove(data);\\n                if(set.size()==0) {\\n                    csToData.remove(data.cuisine);\\n                }\\n            }\\n        }\\n        \\n        if(data == null) {\\n            data = new Data(food, cuisine, rating);\\n        }\\n        data.set(food, cuisine, rating);\\n        nameToData.put(food, data);\\n        if(!csToData.containsKey(cuisine)) {\\n            csToData.put(cuisine, new TreeSet<>((a,b)->{\\n                if(a.rating == b.rating) {\\n                    return -1*(a.food.compareTo(b.food));\\n                }\\n                return a.rating-b.rating;\\n            }));\\n        }\\n        csToData.get(cuisine).add(data);\\n    }\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        nameToData = new HashMap<>();\\n        csToData = new HashMap<>();\\n        for(int i=0;i<foods.length;i++) {\\n            add(foods[i], cuisines[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        add(food, nameToData.get(food).cuisine, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return csToData.get(cuisine).last().food;\\n    }\\n}\\n```\\n\\n**Please upvote if you find helpful**\\n*Happy coding*",
                "solutionTags": [],
                "code": "```\\nclass Data {\\n    String food;\\n    String cuisine;\\n    int rating;\\n    public Data(String food, String cuisine, int rating) {\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public void set(String food, String cuisine, int rating) {\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public String toString() {\\n        return food+\" \"+\" \"+cuisine+\" \"+rating;\\n    }\\n}\\n\\nclass FoodRatings {\\n    Map<String, Data> nameToData;\\n    Map<String, TreeSet<Data>> csToData;\\n    \\n    private void add(String food, String cuisine, int rating) {\\n        String combine = rating+food;\\n        Data data = nameToData.getOrDefault(food, null);\\n        \\n        if(data!=null && csToData.containsKey(data.cuisine)) {\\n            TreeSet<Data> set = csToData.get(data.cuisine);\\n            if(set!=null) {\\n                set.remove(data);\\n                if(set.size()==0) {\\n                    csToData.remove(data.cuisine);\\n                }\\n            }\\n        }\\n        \\n        if(data == null) {\\n            data = new Data(food, cuisine, rating);\\n        }\\n        data.set(food, cuisine, rating);\\n        nameToData.put(food, data);\\n        if(!csToData.containsKey(cuisine)) {\\n            csToData.put(cuisine, new TreeSet<>((a,b)->{\\n                if(a.rating == b.rating) {\\n                    return -1*(a.food.compareTo(b.food));\\n                }\\n                return a.rating-b.rating;\\n            }));\\n        }\\n        csToData.get(cuisine).add(data);\\n    }\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        nameToData = new HashMap<>();\\n        csToData = new HashMap<>();\\n        for(int i=0;i<foods.length;i++) {\\n            add(foods[i], cuisines[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        add(food, nameToData.get(food).cuisine, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return csToData.get(cuisine).last().food;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325027,
                "title": "c-three-maps-easy-solution-o-n-logn",
                "content": "Take 3 maps\\n(i) Cuisine - priority_queue(rating,food)\\n(ii) Food - cuisine\\n(iii) Rating - Food\\n\\nSort the priority queue in order of highest rating and lexographically order of foods. \\nWhen changing the rating just change the rating of the food in rating map. No need to delete in priority queue.\\nIn highest rated function just check if the top rating coming is equal to the food\\'s rating in ratings map, if yes simply return else pop.\\n\\n```\\nstruct comp{\\n    bool operator() (pair<int,string> &a,pair<int,string> &b){\\n        if(a.first==b.first) return a.second>b.second;\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    \\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,comp>> mp;\\n    unordered_map<string,string> chk;\\n    unordered_map<string,int> rt;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<foods.size();i++){\\n            mp[c[i]].push({r[i],foods[i]});\\n            chk[foods[i]]=c[i];\\n            rt[foods[i]]=r[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        rt[food]=newRating;\\n        mp[chk[food]].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        string x = mp[cuisine].top().second;\\n        int y = mp[cuisine].top().first;\\n        while(rt[x]!=y){\\n            mp[cuisine].pop();\\n            x = mp[cuisine].top().second;\\n            y = mp[cuisine].top().first;\\n        }\\n        return mp[cuisine].top().second;\\n    }\\n};\\n```\\n\\nHope you understand it, if any doubt just comment.\\nThank You",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct comp{\\n    bool operator() (pair<int,string> &a,pair<int,string> &b){\\n        if(a.first==b.first) return a.second>b.second;\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    \\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,comp>> mp;\\n    unordered_map<string,string> chk;\\n    unordered_map<string,int> rt;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<foods.size();i++){\\n            mp[c[i]].push({r[i],foods[i]});\\n            chk[foods[i]]=c[i];\\n            rt[foods[i]]=r[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        rt[food]=newRating;\\n        mp[chk[food]].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        string x = mp[cuisine].top().second;\\n        int y = mp[cuisine].top().first;\\n        while(rt[x]!=y){\\n            mp[cuisine].pop();\\n            x = mp[cuisine].top().second;\\n            y = mp[cuisine].top().first;\\n        }\\n        return mp[cuisine].top().second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324748,
                "title": "simple-efficient-code",
                "content": "```\\nclass FoodRatings {\\n    typedef long long ll;\\n    typedef pair<string, ll> pi;\\n    class cmp {\\n    public:\\n        bool operator()(const pi& a, const pi& b)const {\\n            return (a.second == b.second ? a.first < b.first : a.second > b.second);\\n        }\\n    };\\n    unordered_map<string, pi>foods;\\n    unordered_map<string, set<pi, cmp>>cus;\\n    ll n;\\npublic:\\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        n = f.size();\\n        for (ll i = 0;i < n;++i) {\\n            foods[f[i]] = pi(c[i], r[i]);\\n            cus[c[i]].insert(pi(f[i], r[i]));\\n        }\\n    }\\n\\n    void changeRating(string food, int newRat) {\\n        string c = foods[food].first;\\n        ll oldRat = foods[food].second;\\n        foods[food].second = newRat;\\n        cus[c].erase({ food, oldRat });\\n        cus[c].insert({ food, newRat });\\n    }\\n\\n    string highestRated(string c) {\\n        return cus[c].begin()->first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    typedef long long ll;\\n    typedef pair<string, ll> pi;\\n    class cmp {\\n    public:\\n        bool operator()(const pi& a, const pi& b)const {\\n            return (a.second == b.second ? a.first < b.first : a.second > b.second);\\n        }\\n    };\\n    unordered_map<string, pi>foods;\\n    unordered_map<string, set<pi, cmp>>cus;\\n    ll n;\\npublic:\\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        n = f.size();\\n        for (ll i = 0;i < n;++i) {\\n            foods[f[i]] = pi(c[i], r[i]);\\n            cus[c[i]].insert(pi(f[i], r[i]));\\n        }\\n    }\\n\\n    void changeRating(string food, int newRat) {\\n        string c = foods[food].first;\\n        ll oldRat = foods[food].second;\\n        foods[food].second = newRat;\\n        cus[c].erase({ food, oldRat });\\n        cus[c].insert({ food, newRat });\\n    }\\n\\n    string highestRated(string c) {\\n        return cus[c].begin()->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324652,
                "title": "python-with-sorted-set",
                "content": "API docs: https://grantjenks.com/docs/sortedcontainers/.\\n\\n```\\nfrom sortedcontainers import SortedSet\\n\\n        \\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisine: List[str], ratings: List[int]):\\n        self.cuisines = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1])))\\n        self.food_to_cuisine = dict()\\n        self.food_to_rating = dict()\\n        \\n        for index in range(len(foods)):\\n            _cuisine, food, rating = cu[index], foods[index], ratings[index]\\n            \\n            self.cuisines[_cuisine].add((rating, food))\\n            self.food_to_cuisine[food] = _cuisine\\n            self.food_to_rating[food] = rating\\n            \\n    def changeRating(self, food: str, new_rating: int) -> None:\\n        old_rating = self.food_to_rating[food]\\n        cuisine = self.food_to_cuisine[food]\\n        \\n        self.cuisines[cuisine].discard((old_rating, food))\\n        self.cuisines[cuisine].add((new_rating, food))\\n        self.food_to_rating[food] = new_rating\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        return self.cuisines[cuisine][0][1]\\n```\\n\\nNote that for an interview, the better idea is to maintain a Heap and delete invalid ratings lazily. Checkout the following implementation for more: https://leetcode.com/problems/design-a-food-rating-system/discuss/2324852/Python-or-Hashmamp-+-Heap-extravaganza.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\n\\n        \\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisine: List[str], ratings: List[int]):\\n        self.cuisines = defaultdict(lambda: SortedSet(key=lambda x: (-x[0], x[1])))\\n        self.food_to_cuisine = dict()\\n        self.food_to_rating = dict()\\n        \\n        for index in range(len(foods)):\\n            _cuisine, food, rating = cu[index], foods[index], ratings[index]\\n            \\n            self.cuisines[_cuisine].add((rating, food))\\n            self.food_to_cuisine[food] = _cuisine\\n            self.food_to_rating[food] = rating\\n            \\n    def changeRating(self, food: str, new_rating: int) -> None:\\n        old_rating = self.food_to_rating[food]\\n        cuisine = self.food_to_cuisine[food]\\n        \\n        self.cuisines[cuisine].discard((old_rating, food))\\n        self.cuisines[cuisine].add((new_rating, food))\\n        self.food_to_rating[food] = new_rating\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        return self.cuisines[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325314,
                "title": "java-treeset-easy-understanding",
                "content": "One can use TreeSet instead of PriorityQueue to boost 3x faster:\\n```\\nclass FoodRatings {\\n\\tMap<String, TreeSet> cuisineMap;\\n\\tMap<String, Food> foodMap;\\n\\tTreeSet foodSet;\\n\\n\\tpublic FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\t\\tfoodMap = new HashMap<>();\\n\\t\\tcuisineMap = new HashMap<>();\\n\\n\\t\\tfor (int i = 0; i < foods.length; ++i) {\\n\\t\\t\\tFood food = new Food(foods[i], cuisines[i], ratings[i]);\\n\\t\\t\\tfoodMap.put(food.name, food);\\n\\t\\t\\tif (!cuisineMap.containsKey(food.cuisine)) {\\n\\t\\t\\t\\tcuisineMap.put(food.cuisine, new TreeSet<>((a, b) -> a.rating == b.rating ?\\n\\t\\t\\t\\t\\t\\ta.name.compareTo(b.name) : b.rating - a.rating));\\n\\t\\t\\t}\\n\\t\\t\\tcuisineMap.get(food.cuisine).add(food);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void changeRating(String food, int newRating) {\\n\\t\\tFood f = foodMap.get(food);\\n\\t\\tfoodSet = cuisineMap.get(f.cuisine);\\n\\t\\tfoodSet.remove(f);\\n\\t\\tf.rating = newRating;\\n\\t\\tfoodSet.add(f);\\n\\t}\\n\\n\\tpublic String highestRated(String cuisine) {\\n\\t\\tfoodSet = cuisineMap.get(cuisine);\\n\\t\\treturn foodSet.first().name;\\n\\t}\\n}\\n\\nclass Food {\\n\\tString name;\\n\\tString cuisine;\\n\\tint rating;\\n\\n\\tFood(String name, String cuisine, int rating) {\\n\\t\\tthis.name = name;\\n\\t\\tthis.rating = rating;\\n\\t\\tthis.cuisine = cuisine;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n\\tMap<String, TreeSet> cuisineMap;\\n\\tMap<String, Food> foodMap;\\n\\tTreeSet foodSet;\\n\\n\\tpublic FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\t\\tfoodMap = new HashMap<>();\\n\\t\\tcuisineMap = new HashMap<>();\\n\\n\\t\\tfor (int i = 0; i < foods.length; ++i) {\\n\\t\\t\\tFood food = new Food(foods[i], cuisines[i], ratings[i]);\\n\\t\\t\\tfoodMap.put(food.name, food);\\n\\t\\t\\tif (!cuisineMap.containsKey(food.cuisine)) {\\n\\t\\t\\t\\tcuisineMap.put(food.cuisine, new TreeSet<>((a, b) -> a.rating == b.rating ?\\n\\t\\t\\t\\t\\t\\ta.name.compareTo(b.name) : b.rating - a.rating));\\n\\t\\t\\t}\\n\\t\\t\\tcuisineMap.get(food.cuisine).add(food);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic void changeRating(String food, int newRating) {\\n\\t\\tFood f = foodMap.get(food);\\n\\t\\tfoodSet = cuisineMap.get(f.cuisine);\\n\\t\\tfoodSet.remove(f);\\n\\t\\tf.rating = newRating;\\n\\t\\tfoodSet.add(f);\\n\\t}\\n\\n\\tpublic String highestRated(String cuisine) {\\n\\t\\tfoodSet = cuisineMap.get(cuisine);\\n\\t\\treturn foodSet.first().name;\\n\\t}\\n}\\n\\nclass Food {\\n\\tString name;\\n\\tString cuisine;\\n\\tint rating;\\n\\n\\tFood(String name, String cuisine, int rating) {\\n\\t\\tthis.name = name;\\n\\t\\tthis.rating = rating;\\n\\t\\tthis.cuisine = cuisine;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325148,
                "title": "c-hashmap-commented-code",
                "content": "```\\nmap<string,int> rat; // this will pair food and ratings \\n    \\n    map<string,multiset<pair<int,string>>> bestRat; // this will keep country and pair which is ratings and food used multiset for finding best rating  of that specfic country\\n    map<string,string> foodCount;\\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& ratings) {\\n        for(int i=0;i<size(foods);i++)\\n        {\\n            rat[foods[i]]=ratings[i];\\n            // we are adding -ve rating bcz in multiset heighest rating is -ve than it is always first iterator\\n            bestRat[c[i]].insert({-ratings[i],foods[i]});\\n            foodCount[foods[i]]=c[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int curRat=rat[food]; \\n        // changed the current rating of food\\n        rat[food]=newRating;\\n        string country=foodCount[food]; // we have see the country which have that food\\n        // now we will find the pair of ratings and food and delete the previous and add the cur\\n       auto it= bestRat[country].find({-curRat,food});\\n        bestRat[country].erase(it);// erase that pair\\n        // now insert new pair\\n        bestRat[country].insert({-newRating,food});\\n        \\n        \\n    }\\n    \\n    string highestRated(string country) {\\n        // now best rating is in last in multiset\\n        return bestRat[country].begin()->second;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nmap<string,int> rat; // this will pair food and ratings \\n    \\n    map<string,multiset<pair<int,string>>> bestRat; // this will keep country and pair which is ratings and food used multiset for finding best rating  of that specfic country\\n    map<string,string> foodCount;\\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& ratings) {\\n        for(int i=0;i<size(foods);i++)\\n        {\\n            rat[foods[i]]=ratings[i];\\n            // we are adding -ve rating bcz in multiset heighest rating is -ve than it is always first iterator\\n            bestRat[c[i]].insert({-ratings[i],foods[i]});\\n            foodCount[foods[i]]=c[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int curRat=rat[food]; \\n        // changed the current rating of food\\n        rat[food]=newRating;\\n        string country=foodCount[food]; // we have see the country which have that food\\n        // now we will find the pair of ratings and food and delete the previous and add the cur\\n       auto it= bestRat[country].find({-curRat,food});\\n        bestRat[country].erase(it);// erase that pair\\n        // now insert new pair\\n        bestRat[country].insert({-newRating,food});\\n        \\n        \\n    }\\n    \\n    string highestRated(string country) {\\n        // now best rating is in last in multiset\\n        return bestRat[country].begin()->second;\\n        \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2324756,
                "title": "hashmap-treeset-and-a-comparator-set-o-log-n-get-o-1",
                "content": "The reason I chose **TreeSet** over **PriorityQueue** was :\\n\\nTreeSet **`remove(elem)`** : `O(log n)`\\nPriorityQueue **`remove(elem)`** : `O(n)`\\n\\nhttps://stackoverflow.com/questions/14379515/computational-complexity-of-treeset-methods-in-java\\nhttps://stackoverflow.com/questions/12719066/priority-queue-remove-complexity-time\\n\\n\\n```\\nclass FoodRatings {\\n    class Node{\\n        String food;\\n        String cuisine;\\n        int rating;\\n        \\n        Node(String food, int rating, String cuisine){\\n            this.food = food;\\n            this.rating = rating;\\n            this.cuisine = cuisine;\\n        }\\n    }\\n\\n    Map<String, TreeSet<Node>> map = new HashMap<>();\\n    Map<String, Node> nodes = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        Comparator<Node> comparator = (a,b) -> {\\n            return a.rating == b.rating ? a.food.compareTo(b.food) : b.rating - a.rating;\\n        };\\n        \\n        for(int i=0;i<foods.length;i++){\\n            String food = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            Node node = new Node(food, rating, cuisine);\\n            nodes.put(food, node);\\n                                                      \\n            map.computeIfAbsent(cuisine, a -> new TreeSet<Node>(comparator)).add(node);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Node node = nodes.get(food);\\n        TreeSet<Node> set = map.get(node.cuisine);\\n        set.remove(node);\\n        node.rating = newRating;\\n        set.add(node);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().food;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    class Node{\\n        String food;\\n        String cuisine;\\n        int rating;\\n        \\n        Node(String food, int rating, String cuisine){\\n            this.food = food;\\n            this.rating = rating;\\n            this.cuisine = cuisine;\\n        }\\n    }\\n\\n    Map<String, TreeSet<Node>> map = new HashMap<>();\\n    Map<String, Node> nodes = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        Comparator<Node> comparator = (a,b) -> {\\n            return a.rating == b.rating ? a.food.compareTo(b.food) : b.rating - a.rating;\\n        };\\n        \\n        for(int i=0;i<foods.length;i++){\\n            String food = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            Node node = new Node(food, rating, cuisine);\\n            nodes.put(food, node);\\n                                                      \\n            map.computeIfAbsent(cuisine, a -> new TreeSet<Node>(comparator)).add(node);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Node node = nodes.get(food);\\n        TreeSet<Node> set = map.get(node.cuisine);\\n        set.remove(node);\\n        node.rating = newRating;\\n        set.add(node);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().food;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324661,
                "title": "priority-queue-c",
                "content": "```\\nclass myComparator {\\n  public:\\n    bool operator() (pair<int,string> &p1, pair<int,string> &p2) {\\n      if(p1.first == p2.first) return p1.second > p2.second;\\n      \\n      return p1.first < p2.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,myComparator>\\n>mp;\\n    unordered_map<string,int>rate;\\n    unordered_map<string,string>cuis;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n        int n = foods.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            cuis[foods[i]] = cuisines[i];\\n            rate[foods[i]] = ratings[i];\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating)\\n    {\\n        rate[food] = newRating; \\n        string cuisine = cuis[food];\\n        mp[cuisine].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        while(1)\\n        {\\n            auto it = mp[cuisine].top();\\n            //cout<<it.second<<\" \"<<it.first<<\" \";\\n            if(rate[it.second] == it.first)return it.second;\\n            else mp[cuisine].pop();\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass myComparator {\\n  public:\\n    bool operator() (pair<int,string> &p1, pair<int,string> &p2) {\\n      if(p1.first == p2.first) return p1.second > p2.second;\\n      \\n      return p1.first < p2.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,myComparator>\\n>mp;\\n    unordered_map<string,int>rate;\\n    unordered_map<string,string>cuis;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n        int n = foods.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            cuis[foods[i]] = cuisines[i];\\n            rate[foods[i]] = ratings[i];\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating)\\n    {\\n        rate[food] = newRating; \\n        string cuisine = cuis[food];\\n        mp[cuisine].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        while(1)\\n        {\\n            auto it = mp[cuisine].top();\\n            //cout<<it.second<<\" \"<<it.first<<\" \";\\n            if(rate[it.second] == it.first)return it.second;\\n            else mp[cuisine].pop();\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324656,
                "title": "c-3-map-and-set-fast-simple",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    struct SortByYX\\n    {\\n      bool operator ()(const pair<int, string>& l, const pair<int, string>& r) const\\n      {\\n        if(l.first != r.first){\\n            return l.first > r.first;\\n        }\\n        else return l.second < r.second;\\n      }\\n    };\\n    \\n    unordered_map<string, set<pair<int, string>, SortByYX>> cuisinToFood;\\n    unordered_map<string, int> rate;\\n    unordered_map<string, string> foodToCuisin;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for(int i=0; i<f.size(); i++){\\n            cuisinToFood[c[i]].insert({r[i], f[i]});\\n            foodToCuisin.insert({f[i], c[i]});\\n            rate.insert({f[i], r[i]});\\n        }\\n    }\\n    \\n    void changeRating(string f, int nr) {\\n        string c = foodToCuisin[f];\\n        int r = rate[f];\\n        rate[f] = nr;\\n        cuisinToFood[c].erase({r, f});\\n        cuisinToFood[c].insert({nr, f});\\n    }\\n    \\n    string highestRated(string c) {\\n        \\n        pair<int, string> p = *(cuisinToFood[c].begin());\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "solutionTags": [
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    struct SortByYX\\n    {\\n      bool operator ()(const pair<int, string>& l, const pair<int, string>& r) const\\n      {\\n        if(l.first != r.first){\\n            return l.first > r.first;\\n        }\\n        else return l.second < r.second;\\n      }\\n    };\\n    \\n    unordered_map<string, set<pair<int, string>, SortByYX>> cuisinToFood;\\n    unordered_map<string, int> rate;\\n    unordered_map<string, string> foodToCuisin;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for(int i=0; i<f.size(); i++){\\n            cuisinToFood[c[i]].insert({r[i], f[i]});\\n            foodToCuisin.insert({f[i], c[i]});\\n            rate.insert({f[i], r[i]});\\n        }\\n    }\\n    \\n    void changeRating(string f, int nr) {\\n        string c = foodToCuisin[f];\\n        int r = rate[f];\\n        rate[f] = nr;\\n        cuisinToFood[c].erase({r, f});\\n        cuisinToFood[c].insert({nr, f});\\n    }\\n    \\n    string highestRated(string c) {\\n        \\n        pair<int, string> p = *(cuisinToFood[c].begin());\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2327199,
                "title": "maps-custom-comperator",
                "content": "* **Custom Comperator** stores the value of Food according to descending order of rating and in lexicographically smaller food name.\\n*  **Food** Structure stores the value of Food,Rating and Cuisine Type.\\n* **Food_Info** stores Food Info Corresponding to Cuisine type in Set Data structure.\\n* **food_to_cuisine**  Maps food to Cuisine and Rating\\n\\nIn **changeRating** function, we find old rating and cuisine type(from **food_to_cuisine** Map) and Updates the Rating in **Food_Info**.\\n```\\nstruct Food{\\n  string Name;\\n  string Cuisine;\\n  int rating;\\n    \\n    Food(string name_,string cuis_,int rating_)\\n    {\\n        Name=name_;\\n        Cuisine=cuis_;\\n        rating=rating_;\\n    }\\n    //Custom Comperator(Sorts Acc. to Descending Value of Rating  and lexicographically smaller food name)\\n    friend bool operator<(const Food &x,const Food &y)\\n    {\\n        if(x.rating==y.rating)\\n        {\\n\\t\\t//If Foods have same rating, More Priority to lexicographically smaller food name\\n            return x.Name<y.Name;\\n        }\\n        return x.rating>y.rating;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    map<string,set<Food>>Food_Info;//Map Cuisine to Food\\n    map<string, pair<string, int>> food_to_cuisine;//maps food To Cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n       for(int i=0;i<foods.size();i++)\\n       {\\n           food_to_cuisine[foods[i]] = {cuisines[i], ratings[i]};\\n           Food_Info[cuisines[i]].insert(Food(foods[i],cuisines[i],ratings[i]));\\n       }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        int old_rating=food_to_cuisine[food].second;\\n        string cuisine_=food_to_cuisine[food].first;\\n\\t\\t\\n\\t\\t//Updating Ratings\\n        Food_Info[cuisine_].erase(Food(food,cuisine_,old_rating));\\n        Food_Info[cuisine_].insert(Food(food,cuisine_,newRating));\\n        \\n\\t\\tfood_to_cuisine[food]={cuisine_,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return Food_Info[cuisine].begin()->Name;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nstruct Food{\\n  string Name;\\n  string Cuisine;\\n  int rating;\\n    \\n    Food(string name_,string cuis_,int rating_)\\n    {\\n        Name=name_;\\n        Cuisine=cuis_;\\n        rating=rating_;\\n    }\\n    //Custom Comperator(Sorts Acc. to Descending Value of Rating  and lexicographically smaller food name)\\n    friend bool operator<(const Food &x,const Food &y)\\n    {\\n        if(x.rating==y.rating)\\n        {\\n\\t\\t//If Foods have same rating, More Priority to lexicographically smaller food name\\n            return x.Name<y.Name;\\n        }\\n        return x.rating>y.rating;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    map<string,set<Food>>Food_Info;//Map Cuisine to Food\\n    map<string, pair<string, int>> food_to_cuisine;//maps food To Cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n       for(int i=0;i<foods.size();i++)\\n       {\\n           food_to_cuisine[foods[i]] = {cuisines[i], ratings[i]};\\n           Food_Info[cuisines[i]].insert(Food(foods[i],cuisines[i],ratings[i]));\\n       }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        int old_rating=food_to_cuisine[food].second;\\n        string cuisine_=food_to_cuisine[food].first;\\n\\t\\t\\n\\t\\t//Updating Ratings\\n        Food_Info[cuisine_].erase(Food(food,cuisine_,old_rating));\\n        Food_Info[cuisine_].insert(Food(food,cuisine_,newRating));\\n        \\n\\t\\tfood_to_cuisine[food]={cuisine_,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return Food_Info[cuisine].begin()->Name;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325434,
                "title": "javascript-max-heap-pq-lazy-removal-645ms",
                "content": "```\\nfunction FoodRatings(foods, cuisines, ratings) {\\n    let n = foods.length, cm = new Map(), fm = new Map(); // cm: cuisine map {cuisine: pq}, fm: food map {food: [cuisine, rating]}\\n    for (let i = 0; i < n; i++) {\\n        fm.set(foods[i], [cuisines[i], ratings[i]]);\\n        if (!cm.has(cuisines[i])) {\\n            let pq = new MaxPriorityQueue({\\n                compare: (x, y) => {\\n                    if (x[0] != y[0]) return y[0] - x[0]; // first priority: high rate comes first\\n                    return x[1].localeCompare(y[1]); // second priority: lexical smaller comes first\\n                }\\n            });\\n            cm.set(cuisines[i], pq);\\n        }\\n        cm.get(cuisines[i]).enqueue([ratings[i], foods[i]])\\n    }\\n    return { changeRating, highestRated }\\n    function changeRating(food, newRating) {\\n        let cur = fm.get(food), cuisine = cur[0];\\n        cur[1] = newRating;\\n        fm.set(food, cur);\\n        cm.get(cuisine).enqueue([newRating, food]);\\n    }\\n    function highestRated(cuisine) {\\n        let pq = cm.get(cuisine);\\n        while (fm.get(pq.front()[1])[1] != pq.front()[0]) pq.dequeue(); // lazy remove\\n        return pq.front()[1];\\n    }\\n}\\n```\\nSolution 2: use Java TreeSet Comparator:\\nhttps://leetcode.com/problems/design-a-food-rating-system/discuss/2325289/java-3-maps-420ms",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunction FoodRatings(foods, cuisines, ratings) {\\n    let n = foods.length, cm = new Map(), fm = new Map(); // cm: cuisine map {cuisine: pq}, fm: food map {food: [cuisine, rating]}\\n    for (let i = 0; i < n; i++) {\\n        fm.set(foods[i], [cuisines[i], ratings[i]]);\\n        if (!cm.has(cuisines[i])) {\\n            let pq = new MaxPriorityQueue({\\n                compare: (x, y) => {\\n                    if (x[0] != y[0]) return y[0] - x[0]; // first priority: high rate comes first\\n                    return x[1].localeCompare(y[1]); // second priority: lexical smaller comes first\\n                }\\n            });\\n            cm.set(cuisines[i], pq);\\n        }\\n        cm.get(cuisines[i]).enqueue([ratings[i], foods[i]])\\n    }\\n    return { changeRating, highestRated }\\n    function changeRating(food, newRating) {\\n        let cur = fm.get(food), cuisine = cur[0];\\n        cur[1] = newRating;\\n        fm.set(food, cur);\\n        cm.get(cuisine).enqueue([newRating, food]);\\n    }\\n    function highestRated(cuisine) {\\n        let pq = cm.get(cuisine);\\n        while (fm.get(pq.front()[1])[1] != pq.front()[0]) pq.dequeue(); // lazy remove\\n        return pq.front()[1];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325254,
                "title": "simple-python-solution-heap-hashmap",
                "content": "This is a slight variation of https://leetcode.com/problems/design-a-number-container-system/\\n\\nUse 3 hashmaps:\\n- ```f2r``` - key is food, value is rating\\n- ```f2c``` - key is food, value is cuisine\\n- ```c2rf``` - key is cuisine, value is a heap of tuple (-rating, food) - we use negative rating to make this a max heap based on rating\\n\\nWhen finding the highestRated cuisine, we check ```c2rf``` to see if the ```(rating, food)``` combination is found in ```f2r```. If the ```(rating, food)``` combination is not found, the ```rating``` has already been invalidated (updated), so we ignore the value (by popping the heap).\\n\\nSpace Complexity: O(N)\\nTime Complexity:\\n===========\\n- changeRating - O(logN)\\n- highestRated:\\n  - Average case - O(logN)\\n  - Worst case - O(NlogN)\\n\\n```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.f2r = defaultdict(int)\\n        self.f2c = {}\\n        self.c2rf = defaultdict(list)\\n        for i in range(len(foods)):\\n            self.f2c[foods[i]] = cuisines[i]\\n            heappush(self.c2rf[cuisines[i]], (-ratings[i], foods[i]))\\n            self.f2r[foods[i]] = -ratings[i]\\n            \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.f2r[food] = -newRating\\n        heappush(self.c2rf[self.f2c[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.c2rf[cuisine] and self.f2r[self.c2rf[cuisine][0][1]] !=  self.c2rf[cuisine][0][0]:\\n            heappop(self.c2rf[cuisine])\\n        return self.c2rf[cuisine][0][1]\\n```",
                "solutionTags": [],
                "code": "```f2r```\n```f2c```\n```c2rf```\n```c2rf```\n```(rating, food)```\n```f2r```\n```(rating, food)```\n```rating```\n```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.f2r = defaultdict(int)\\n        self.f2c = {}\\n        self.c2rf = defaultdict(list)\\n        for i in range(len(foods)):\\n            self.f2c[foods[i]] = cuisines[i]\\n            heappush(self.c2rf[cuisines[i]], (-ratings[i], foods[i]))\\n            self.f2r[foods[i]] = -ratings[i]\\n            \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.f2r[food] = -newRating\\n        heappush(self.c2rf[self.f2c[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.c2rf[cuisine] and self.f2r[self.c2rf[cuisine][0][1]] !=  self.c2rf[cuisine][0][0]:\\n            heappop(self.c2rf[cuisine])\\n        return self.c2rf[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324844,
                "title": "help-why-is-this-giving-tle-in-java-using-three-hashmaps-with-priority-queue",
                "content": "Does anyone know why this solution is giving TLE and how I can modify this to be accepted?\\n\\n```java\\nclass FoodRatings {\\n    Map<String, Integer> foodToRatingMap = new HashMap<>();\\n    Map<String, String> foodToCuisineMap = new HashMap<>();\\n    Map<String, Queue<String>> cuisineToPQMap = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n = foods.length;\\n        for(int i = 0; i < n ; i++) {\\n            String food = foods[i], cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            foodToRatingMap.put(food, rating);\\n            foodToCuisineMap.put(food, cuisine);\\n            if(!cuisineToPQMap.containsKey(cuisine)) cuisineToPQMap.put(cuisine, new PriorityQueue<String>((a, b) -> {\\n                int r1 = foodToRatingMap.get(a);\\n                int r2 = foodToRatingMap.get(b);\\n                if(r1 != r2) return r2 - r1;\\n                return a.compareTo(b);\\n            }));\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            String food = foods[i], cuisine = cuisines[i];\\n            cuisineToPQMap.get(cuisine).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodToCuisineMap.get(food);\\n        Queue<String> q = cuisineToPQMap.get(cuisine);\\n        \\n        q.remove(food);\\n        foodToRatingMap.put(food, newRating);\\n        q.offer(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineToPQMap.get(cuisine).peek();\\n    }\\n}\\n```\\n\\n**Note:**\\nCheck this solution by another person: https://leetcode.com/problems/design-a-food-rating-system/discuss/2324848/JAVA-oror-MAP-oror-PRIORITY-QUEUE\\n\\nThey are also using a similar solution and even for them, changeRating involves two log(n) operations, but their solution works fine(without TLE).",
                "solutionTags": [],
                "code": "```java\\nclass FoodRatings {\\n    Map<String, Integer> foodToRatingMap = new HashMap<>();\\n    Map<String, String> foodToCuisineMap = new HashMap<>();\\n    Map<String, Queue<String>> cuisineToPQMap = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n = foods.length;\\n        for(int i = 0; i < n ; i++) {\\n            String food = foods[i], cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            foodToRatingMap.put(food, rating);\\n            foodToCuisineMap.put(food, cuisine);\\n            if(!cuisineToPQMap.containsKey(cuisine)) cuisineToPQMap.put(cuisine, new PriorityQueue<String>((a, b) -> {\\n                int r1 = foodToRatingMap.get(a);\\n                int r2 = foodToRatingMap.get(b);\\n                if(r1 != r2) return r2 - r1;\\n                return a.compareTo(b);\\n            }));\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            String food = foods[i], cuisine = cuisines[i];\\n            cuisineToPQMap.get(cuisine).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodToCuisineMap.get(food);\\n        Queue<String> q = cuisineToPQMap.get(cuisine);\\n        \\n        q.remove(food);\\n        foodToRatingMap.put(food, newRating);\\n        q.offer(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineToPQMap.get(cuisine).peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324811,
                "title": "why-priorityqueue-cannot-get-the-right-order",
                "content": "Was trying to use a pq to maintain the sequence - sort the food by the score first, if they are same, then try to sort by the string order aka lexco order, but keep got the wrong order, does anyone know why??? Thanks!:\\n\\ninput:\\n[\"FoodRatings\",\"changeRating\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"highestRated\",\"highestRated\",\"changeRating\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"highestRated\",\"highestRated\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"highestRated\",\"changeRating\",\"changeRating\",\"changeRating\",\"changeRating\",\"highestRated\",\"highestRated\",\"changeRating\",\"changeRating\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\",\"changeRating\",\"changeRating\",\"highestRated\",\"highestRated\",\"highestRated\",\"highestRated\",\"changeRating\",\"highestRated\",\"highestRated\",\"highestRated\",\"highestRated\",\"changeRating\",\"changeRating\",\"changeRating\",\"highestRated\",\"changeRating\",\"highestRated\"]\\n[[[\"vhbibydfop\",\"ggtdlawxup\",\"lslcltacc\",\"bqgkfcy\",\"xxowyabq\",\"ezswv\",\"ewgvsuyvpo\",\"zgochpey\",\"epiaxxiv\",\"idpdiqlcp\",\"wqgrbvme\",\"wqxbxeovwe\",\"iduzk\",\"ahemklz\",\"ah\",\"rvuqnlydxu\",\"dldqmpheob\",\"lzeqwfb\",\"ykwjc\",\"dtrgnrcqr\",\"cwcgevzzz\",\"zejbynj\",\"ivhdsnjpho\",\"gsyewq\",\"ekqhtiijrj\",\"cthwbt\",\"gnbhjyhcil\",\"kkthw\",\"ktiqokzl\",\"zzroi\",\"cjwapjnzql\",\"hfum\",\"jrwby\",\"amhfyno\",\"bj\",\"fszije\",\"nbkpptir\",\"dgzmoxhhoe\",\"bnisfskgxi\",\"uepypxnsy\",\"afdz\",\"tdctkeg\",\"lfsohpzmk\",\"ewwqult\",\"iynyddno\",\"yyroyjzdg\",\"mcpea\",\"lzafjh\",\"jdvcxidtm\",\"qvkyqmupz\",\"kjop\",\"girgfkaib\",\"qecvnaxpsm\",\"itx\",\"xhjmq\",\"lwwbdxkz\",\"chthxuhex\",\"tghokrfica\",\"vrmjibxv\",\"oipnttbz\",\"yyfvlwvj\",\"erbtnw\",\"yezfiom\",\"ismarfqbuv\",\"vmfxlqbxwa\",\"pcwparohxf\",\"bpdrndbv\",\"owgjjitjfd\",\"fdwmxhli\",\"kffetdxvfx\",\"ruahmg\",\"aphbsbkimb\",\"nbkdfkgl\",\"rxehcqcrwu\",\"kxwlfxbe\",\"qukxd\",\"tewgnjuxnm\",\"jxfqwqe\",\"mdgwiok\",\"tbkmnx\",\"klzznopcn\",\"vjbcvddw\",\"yzhawtmpwp\",\"fhjichpi\",\"tapig\",\"glfbwolsoa\",\"xklqlzm\"],[\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\"],[146,562,428,619,731,483,598,619,950,446,630,556,894,911,537,359,863,995,417,702,689,667,502,691,896,582,111,319,182,953,131,372,563,963,300,42,829,187,676,509,259,688,897,614,392,170,392,1,134,79,995,371,886,430,72,830,871,758,247,333,128,987,659,933,640,198,638,585,825,904,729,214,974,935,581,985,85,987,51,174,301,635,148,492,200,275,101]],[\"nbkdfkgl\",908],[\"hfum\",256],[\"kggxajkarh\"],[\"dldqmpheob\",774],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"lfsohpzmk\",217],[\"yyfvlwvj\",372],[\"kggxajkarh\"],[\"owgjjitjfd\",652],[\"kggxajkarh\"],[\"uepypxnsy\",856],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"cwcgevzzz\",889],[\"kggxajkarh\"],[\"vrmjibxv\",228],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"tbkmnx\",963],[\"pcwparohxf\",710],[\"kjop\",89],[\"ah\",309],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"erbtnw\",501],[\"rxehcqcrwu\",306],[\"iynyddno\",260],[\"kggxajkarh\"],[\"jrwby\",205],[\"kggxajkarh\"],[\"wqgrbvme\",703],[\"qukxd\",234],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"jxfqwqe\",38],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"kggxajkarh\"],[\"epiaxxiv\",434],[\"zgochpey\",315],[\"vhbibydfop\",915],[\"kggxajkarh\"],[\"tapig\",793],[\"kggxajkarh\"]]\\n\\nOutput:\\n[null,null,null,\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,null,\"lzeqwfb\",null,\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",null,null,null,null,\"lzeqwfb\",\"lzeqwfb\",null,null,null,\"lzeqwfb\",null,\"lzeqwfb\",null,null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,null,null,\"lzeqwfb\",null,\"lzeqwfb\"]\\n\\nExpected:\\n[null,null,null,\"kjop\",null,\"kjop\",\"kjop\",\"kjop\",null,null,\"kjop\",null,\"kjop\",null,\"kjop\",\"kjop\",\"kjop\",null,\"kjop\",null,\"kjop\",\"kjop\",null,null,null,null,\"lzeqwfb\",\"lzeqwfb\",null,null,null,\"lzeqwfb\",null,\"lzeqwfb\",null,null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",\"lzeqwfb\",null,null,null,\"lzeqwfb\",null,\"lzeqwfb\"]\\n\\n```\\nclass FoodRatings {\\n    Map<String, Integer> foodToR;\\n    Map<String, String> foodToC;\\n    Map<String, PriorityQueue<String>> cToF;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodToR = new HashMap<>();\\n        foodToC = new HashMap<>();\\n        cToF = new HashMap<>();\\n        \\n        int len = foods.length;\\n        for (int i = 0; i < len; i++) {\\n            foodToR.put(foods[i], ratings[i]);\\n            foodToC.put(foods[i], cuisines[i]);\\n        }\\n        for (int i = 0 ; i < len; i++) {\\n            if (!cToF.containsKey(cuisines[i])) {\\n                PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> foodToR.get(a) == foodToR.get(b) ? a.compareTo(b) : foodToR.get(b) - foodToR.get(a));\\n                cToF.put(cuisines[i], pq);\\n            }\\n            cToF.get(cuisines[i]).add(foods[i]);\\n            // pq.add(foods[i]);\\n        }\\n        \\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodToR.put(food, newRating);\\n        String c = foodToC.get(food);\\n        cToF.get(c).remove(food);\\n        cToF.get(c).add(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cToF.get(cuisine).peek();\\n    }\\n}\\n```\\n\\n**What is wrong with the comparator here???**\\n```\\nPriorityQueue<String> pq = new PriorityQueue<>((a, b) -> foodToR.get(a) == foodToR.get(b) ? a.compareTo(b) : foodToR.get(b) - foodToR.get(a));\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\n    Map<String, Integer> foodToR;\\n    Map<String, String> foodToC;\\n    Map<String, PriorityQueue<String>> cToF;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodToR = new HashMap<>();\\n        foodToC = new HashMap<>();\\n        cToF = new HashMap<>();\\n        \\n        int len = foods.length;\\n        for (int i = 0; i < len; i++) {\\n            foodToR.put(foods[i], ratings[i]);\\n            foodToC.put(foods[i], cuisines[i]);\\n        }\\n        for (int i = 0 ; i < len; i++) {\\n            if (!cToF.containsKey(cuisines[i])) {\\n                PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> foodToR.get(a) == foodToR.get(b) ? a.compareTo(b) : foodToR.get(b) - foodToR.get(a));\\n                cToF.put(cuisines[i], pq);\\n            }\\n            cToF.get(cuisines[i]).add(foods[i]);\\n            // pq.add(foods[i]);\\n        }\\n        \\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodToR.put(food, newRating);\\n        String c = foodToC.get(food);\\n        cToF.get(c).remove(food);\\n        cToF.get(c).add(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cToF.get(cuisine).peek();\\n    }\\n}\\n```\n```\\nPriorityQueue<String> pq = new PriorityQueue<>((a, b) -> foodToR.get(a) == foodToR.get(b) ? a.compareTo(b) : foodToR.get(b) - foodToR.get(a));\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324804,
                "title": "c-dictionary-sortedset",
                "content": "```\\npublic class FoodRatings \\n{\\n    //Food -  (Rating - Cousine)\\n    Dictionary<string, (int, string)> foodRating;\\n    //Cousine - Sorted (rating, food)\\n    Dictionary<string, SortedSet<(int, string)>> cuisinesRatingFood;\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings)\\n    {\\n        foodRating = new Dictionary<string, (int, string)>();\\n        cuisinesRatingFood = new Dictionary<string, SortedSet<(int, string)>>();\\n\\n        for (int i = 0; i < foods.Length; i++)\\n        {\\n            foodRating.Add(foods[i], (ratings[i], cuisines[i]));\\n            cuisinesRatingFood.TryAdd(cuisines[i], new SortedSet<(int, string)>(Comparer<(int, string)>.Create((a, b) => a.Item1 != b.Item1 ? a.Item1.CompareTo(b.Item1) : b.Item2.CompareTo(a.Item2))));\\n            cuisinesRatingFood[cuisines[i]].Add((ratings[i], foods[i]));\\n        }\\n    }\\n\\n    public void ChangeRating(string food, int newRating)\\n    {\\n        string cuisine = foodRating[food].Item2;\\n        int oldRating = foodRating[food].Item1;\\n        foodRating[food] = (newRating, cuisine);\\n\\n        cuisinesRatingFood[cuisine].Remove((oldRating, food));\\n        cuisinesRatingFood[cuisine].Add((newRating, food));\\n    }\\n\\n    public string HighestRated(string cuisine)\\n    {\\n        return cuisinesRatingFood[cuisine].Max.Item2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class FoodRatings \\n{\\n    //Food -  (Rating - Cousine)\\n    Dictionary<string, (int, string)> foodRating;\\n    //Cousine - Sorted (rating, food)\\n    Dictionary<string, SortedSet<(int, string)>> cuisinesRatingFood;\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings)\\n    {\\n        foodRating = new Dictionary<string, (int, string)>();\\n        cuisinesRatingFood = new Dictionary<string, SortedSet<(int, string)>>();\\n\\n        for (int i = 0; i < foods.Length; i++)\\n        {\\n            foodRating.Add(foods[i], (ratings[i], cuisines[i]));\\n            cuisinesRatingFood.TryAdd(cuisines[i], new SortedSet<(int, string)>(Comparer<(int, string)>.Create((a, b) => a.Item1 != b.Item1 ? a.Item1.CompareTo(b.Item1) : b.Item2.CompareTo(a.Item2))));\\n            cuisinesRatingFood[cuisines[i]].Add((ratings[i], foods[i]));\\n        }\\n    }\\n\\n    public void ChangeRating(string food, int newRating)\\n    {\\n        string cuisine = foodRating[food].Item2;\\n        int oldRating = foodRating[food].Item1;\\n        foodRating[food] = (newRating, cuisine);\\n\\n        cuisinesRatingFood[cuisine].Remove((oldRating, food));\\n        cuisinesRatingFood[cuisine].Add((newRating, food));\\n    }\\n\\n    public string HighestRated(string cuisine)\\n    {\\n        return cuisinesRatingFood[cuisine].Max.Item2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491691,
                "title": "idea-explained-two-maps-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is to keep track of food and cuisine using food. This would help in updating ratings and get top rated food of particular.\\n\\n* To get highest rated food of given cuisine, we need a `cuisineMap` that would store `rating` and `food`. \\n\\t* **`{cuisine, set{rating, food}}`**\\n\\t* Each cuisine has a set that contains multiple foods and their ratings, sorted by ratings\\n\\t* This will be useful in getting top rated food.\\n* To update rating of given food, we need a `foodMap` that would store `rating` and `cuisine`. \\n\\t* **`{food, {rating, cuisine}}`**\\n\\t* We will use this cuisine value to update cuisine map as well with `newRating`\\n\\n*Note :* \\n* Store rating as `negative` value so we get highest rated food at the top of set in `cuisineMap`.\\n* SO in case of tie i.e same rating, we will get lexicographically smallest `food` string.\\n# Code :\\n\\n```\\nclass FoodRatings {\\n    unordered_map<string, set<pair<int, string>>> cuisineMap; // { cuisine, set{ rating, food } }\\n    unordered_map<string, pair<int, string>> foodMap; // { food, { rating, cuisine } }\\n    \\npublic:\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        \\n        // Create cuisines and foods mapping\\n        for(int i=0; i<n; i++) {\\n            cuisineMap[cuisines[i]].insert({-ratings[i], foods[i]}); // Cuisine -> {Rating, Food}\\n            foodMap[foods[i]] = {-ratings[i], cuisines[i]}; // Food -> {Rating, Food}\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [currentRating, cuisine] = foodMap[food]; // Get existing rating to find this food in cuisine\\n        \\n        foodMap[food] = {-newRating, cuisine}; // Update with new rating\\n            \\n        // Now update rating and food for particular cuisine\\n        cuisineMap[cuisine].erase({currentRating, food}); // Remove old value\\n        cuisineMap[cuisine].insert({-newRating, food}); // Insert new value\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        // First element in set of cuisine will be highest rated (-ve of rating is lowest)\\n        return cuisineMap[cuisine].begin()->second;\\n    }\\n};\\n```\\n\\n***If you find this solution helpful, do give it a like :)***",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    unordered_map<string, set<pair<int, string>>> cuisineMap; // { cuisine, set{ rating, food } }\\n    unordered_map<string, pair<int, string>> foodMap; // { food, { rating, cuisine } }\\n    \\npublic:\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        \\n        // Create cuisines and foods mapping\\n        for(int i=0; i<n; i++) {\\n            cuisineMap[cuisines[i]].insert({-ratings[i], foods[i]}); // Cuisine -> {Rating, Food}\\n            foodMap[foods[i]] = {-ratings[i], cuisines[i]}; // Food -> {Rating, Food}\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [currentRating, cuisine] = foodMap[food]; // Get existing rating to find this food in cuisine\\n        \\n        foodMap[food] = {-newRating, cuisine}; // Update with new rating\\n            \\n        // Now update rating and food for particular cuisine\\n        cuisineMap[cuisine].erase({currentRating, food}); // Remove old value\\n        cuisineMap[cuisine].insert({-newRating, food}); // Insert new value\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        // First element in set of cuisine will be highest rated (-ve of rating is lowest)\\n        return cuisineMap[cuisine].begin()->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332660,
                "title": "priority-queue-c",
                "content": "First time i spent 2+ hours for single question lol.......\\n\\n```\\nclass FoodRatings {\\npublic:\\n   class compare{\\n       public:\\n    bool operator() (pair<int,string>const&a,pair<int,string>const&b) {\\n        \\n        if(a.first==b.first){\\n            return a.second>=b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n       \\n   };        \\n   map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,compare>>m; \\n   map<string,int>mp;\\n   map<string,string>v;\\n    \\nFoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n       for(int i=0;i<foods.size();i++){\\n           mp[foods[i]]=ratings[i];\\n            v[foods[i]]=cuisines[i];\\n       }\\n       for(int i=0;i<foods.size();i++){\\n           m[cuisines[i]].push({ratings[i],foods[i]});\\n       }\\n    }\\n    \\n    \\n    void changeRating(string food, int newRating) {\\n        mp[food]=newRating;\\n        m[v[food]].push({newRating,food});\\n        \\n    }\\n    \\n    string highestRated(string cuisine) {\\n\\n        while(true){\\n            int rating=m[cuisine].top().first;\\n            string food=m[cuisine].top().second;\\n            cout<<rating<<\" \"<<food<<endl;\\n            if(mp[food]==rating){\\n                return food;\\n            }\\n            m[cuisine].pop();\\n            if(m[cuisine].empty())\\n                break;\\n        }\\n        return \"\";\\n     \\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n   class compare{\\n       public:\\n    bool operator() (pair<int,string>const&a,pair<int,string>const&b) {\\n        \\n        if(a.first==b.first){\\n            return a.second>=b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n       \\n   };        \\n   map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,compare>>m; \\n   map<string,int>mp;\\n   map<string,string>v;\\n    \\nFoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n       for(int i=0;i<foods.size();i++){\\n           mp[foods[i]]=ratings[i];\\n            v[foods[i]]=cuisines[i];\\n       }\\n       for(int i=0;i<foods.size();i++){\\n           m[cuisines[i]].push({ratings[i],foods[i]});\\n       }\\n    }\\n    \\n    \\n    void changeRating(string food, int newRating) {\\n        mp[food]=newRating;\\n        m[v[food]].push({newRating,food});\\n        \\n    }\\n    \\n    string highestRated(string cuisine) {\\n\\n        while(true){\\n            int rating=m[cuisine].top().first;\\n            string food=m[cuisine].top().second;\\n            cout<<rating<<\" \"<<food<<endl;\\n            if(mp[food]==rating){\\n                return food;\\n            }\\n            m[cuisine].pop();\\n            if(m[cuisine].empty())\\n                break;\\n        }\\n        return \"\";\\n     \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324989,
                "title": "python-using-sortedlist",
                "content": "Used `SortedList` for this problem. Any alternate approach without using built-in data structures is appreciated.\\n\\n**Code**\\n\\n```python\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.hmap_food = {}\\n        self.hmap_cuisine = collections.defaultdict(SortedList)\\n        \\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.hmap_food[f] = (c, r)\\n            self.hmap_cuisine[c].add((-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        o_c, o_r = self.hmap_food[food]\\n        self.hmap_cuisine[o_c].discard((-o_r, food))\\n        self.hmap_cuisine[o_c].add((-newRating, food))\\n        self.hmap_food[food] = (o_c, newRating)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        return self.hmap_cuisine[cuisine][0][1]\\n        \\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.hmap_food = {}\\n        self.hmap_cuisine = collections.defaultdict(SortedList)\\n        \\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.hmap_food[f] = (c, r)\\n            self.hmap_cuisine[c].add((-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        o_c, o_r = self.hmap_food[food]\\n        self.hmap_cuisine[o_c].discard((-o_r, food))\\n        self.hmap_cuisine[o_c].add((-newRating, food))\\n        self.hmap_food[food] = (o_c, newRating)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        return self.hmap_cuisine[cuisine][0][1]\\n        \\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324936,
                "title": "simple-map-solution-with-explanation",
                "content": "Why **-ratings[i] , as pushing negative value in set results in greater element at the beginning**\\nand **when ratings clash , set automatically sort on basis of second value**\\nand we needed to return which **food string is lexographically small**\\n\\n```\\n    unordered_map<string,string>cu; //food cusine\\n    unordered_map<string,set<pair<int,string>>>mp; // cusine , rating\\n    unordered_map<string,int>rat; // food rating\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            cu[foods[i]]=cuisines[i];\\n            mp[cuisines[i]].insert({-ratings[i],foods[i]});\\n            rat[foods[i]]=ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto cusine=cu[food];\\n        auto rating=rat[food];\\n        mp[cusine].erase({-rating,food});\\n        mp[cusine].insert({-newRating,food});\\n        rat[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].begin()->second;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    unordered_map<string,string>cu; //food cusine\\n    unordered_map<string,set<pair<int,string>>>mp; // cusine , rating\\n    unordered_map<string,int>rat; // food rating\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            cu[foods[i]]=cuisines[i];\\n            mp[cuisines[i]].insert({-ratings[i],foods[i]});\\n            rat[foods[i]]=ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto cusine=cu[food];\\n        auto rating=rat[food];\\n        mp[cusine].erase({-rating,food});\\n        mp[cusine].insert({-newRating,food});\\n        rat[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].begin()->second;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324742,
                "title": "python-sortedlist-three-maps",
                "content": "\\tfrom sortedcontainers import SortedList\\n\\tclass FoodRatings:\\n\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.a = defaultdict(SortedList)\\n\\t\\t\\tself.country = defaultdict(str)\\n\\t\\t\\tself.prevRating = defaultdict(int)\\n\\n\\t\\t\\tfor food,cuisine,rating in zip(foods,cuisines,ratings): \\n\\t\\t\\t\\tself.a[cuisine].add((-rating,food)) \\n\\t\\t\\t\\tself.country[food] = cuisine\\n\\t\\t\\t\\tself.prevRating[food] = rating\\n\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:  \\n\\t\\t\\tself.a[self.country[food]].remove((-self.prevRating[food],food)) \\n\\t\\t\\tself.prevRating[food] = newRating\\n\\t\\t\\tself.a[self.country[food]].add((-newRating,food))\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\treturn self.a[cuisine][0][1]\\n\\n\\n\\t# Your FoodRatings object will be instantiated and called as such:\\n\\t# obj = FoodRatings(foods, cuisines, ratings)\\n\\t# obj.changeRating(food,newRating)\\n\\t# param_2 = obj.highestRated(cuisine)",
                "solutionTags": [],
                "code": "\\tfrom sortedcontainers import SortedList\\n\\tclass FoodRatings:\\n\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.a = defaultdict(SortedList)\\n\\t\\t\\tself.country = defaultdict(str)\\n\\t\\t\\tself.prevRating = defaultdict(int)\\n\\n\\t\\t\\tfor food,cuisine,rating in zip(foods,cuisines,ratings): \\n\\t\\t\\t\\tself.a[cuisine].add((-rating,food)) \\n\\t\\t\\t\\tself.country[food] = cuisine\\n\\t\\t\\t\\tself.prevRating[food] = rating\\n\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:  \\n\\t\\t\\tself.a[self.country[food]].remove((-self.prevRating[food],food)) \\n\\t\\t\\tself.prevRating[food] = newRating\\n\\t\\t\\tself.a[self.country[food]].add((-newRating,food))\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\treturn self.a[cuisine][0][1]\\n\\n\\n\\t# Your FoodRatings object will be instantiated and called as such:\\n\\t# obj = FoodRatings(foods, cuisines, ratings)\\n\\t# obj.changeRating(food,newRating)\\n\\t# param_2 = obj.highestRated(cuisine)",
                "codeTag": "Java"
            },
            {
                "id": 3560243,
                "title": "java-simple-treeset-solution-100",
                "content": "```java\\nclass FoodRatings {\\n    private final Map<String, TreeSet<Food>> categories;\\n    private final Map<String, Food> meals;\\n\\n    public FoodRatings(final String[] foods, final String[] cuisines, final int[] ratings) {\\n        this.categories = new HashMap<>();\\n        this.meals = new HashMap<>();\\n\\n        for(int i = 0; i < cuisines.length; ++i) {\\n            final Food food = new Food(cuisines[i], foods[i], ratings[i]);\\n\\n            this.categories.putIfAbsent(cuisines[i], new TreeSet<>((a, b) -> a.rating() == b.rating() ? b.name().compareTo(a.name()) : a.rating() - b.rating()));\\n            this.categories.get(cuisines[i]).add(food);\\n            this.meals.put(foods[i], food);\\n        }\\n    }\\n    \\n    public void changeRating(final String food, final int newRating) {\\n        final Food meal = this.meals.get(food);\\n        final TreeSet<Food> category = categories.get(meal.category());\\n\\n        category.remove(meal);\\n\\n        meal.rating(newRating);\\n\\n        category.add(meal);\\n    }\\n    \\n    public String highestRated(final String cuisine) {\\n        return this.categories.get(cuisine).last().name();\\n    }\\n\\n    private final class Food {\\n        private final String category;\\n        private final String name;\\n        private int rating;\\n\\n        public Food(final String category, final String name, final int rating) {\\n            this.category = category;\\n            this.name = name;\\n            this.rating = rating;\\n        }\\n\\n        public void rating(final int rating) {\\n            this.rating = rating;\\n        }\\n\\n        public int rating() {\\n            return this.rating;\\n        }\\n\\n        public String category() {\\n            return this.category;\\n        }\\n\\n        public String name() {\\n            return this.name;\\n        }\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass FoodRatings {\\n    private final Map<String, TreeSet<Food>> categories;\\n    private final Map<String, Food> meals;\\n\\n    public FoodRatings(final String[] foods, final String[] cuisines, final int[] ratings) {\\n        this.categories = new HashMap<>();\\n        this.meals = new HashMap<>();\\n\\n        for(int i = 0; i < cuisines.length; ++i) {\\n            final Food food = new Food(cuisines[i], foods[i], ratings[i]);\\n\\n            this.categories.putIfAbsent(cuisines[i], new TreeSet<>((a, b) -> a.rating() == b.rating() ? b.name().compareTo(a.name()) : a.rating() - b.rating()));\\n            this.categories.get(cuisines[i]).add(food);\\n            this.meals.put(foods[i], food);\\n        }\\n    }\\n    \\n    public void changeRating(final String food, final int newRating) {\\n        final Food meal = this.meals.get(food);\\n        final TreeSet<Food> category = categories.get(meal.category());\\n\\n        category.remove(meal);\\n\\n        meal.rating(newRating);\\n\\n        category.add(meal);\\n    }\\n    \\n    public String highestRated(final String cuisine) {\\n        return this.categories.get(cuisine).last().name();\\n    }\\n\\n    private final class Food {\\n        private final String category;\\n        private final String name;\\n        private int rating;\\n\\n        public Food(final String category, final String name, final int rating) {\\n            this.category = category;\\n            this.name = name;\\n            this.rating = rating;\\n        }\\n\\n        public void rating(final int rating) {\\n            this.rating = rating;\\n        }\\n\\n        public int rating() {\\n            return this.rating;\\n        }\\n\\n        public String category() {\\n            return this.category;\\n        }\\n\\n        public String name() {\\n            return this.name;\\n        }\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419402,
                "title": "c-simple-map-solution-with-explanation",
                "content": "Approach:\\nThere are cuisines. Each cuisine has several foods. And each food has a rating (which can be updated).\\nWe are asked to create 2 functions - Change Rating of a food and Return Highest rated food of a given cuisine.\\nThis gives us the intuition to create a map that maps the cuisine to a priority queue(max heap) which will contain all the foods of that cuisine along with its rating.\\nFor changing the rating of a food, we keep another map, which maps the food item to it\\'s cuisine and it\\'s current rating. \\nSo, when we call highest rated food function, and use the top element of the priority queue, we match the rating of that item with it\\'s current rating. If it doesn\\'t match, keep popping untill you find one that matches.\\n\\n```\\n#define p pair<int,string> \\nstruct Comp{\\n    bool operator()(p a,p b){\\n        return a.first==b.first? a.second>b.second:a.first<b.first;\\n    }  \\n};\\nclass FoodRatings {\\npublic:\\n    map<string,priority_queue<p,vector<p>,Comp>>mp; //maps cuisine to priority queue of pairs of rating and food item name\\n    unordered_map<string,pair<int,string>>curr; //maps food item name to it\\'s current rating and cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            curr[foods[i]]={ratings[i],cuisines[i]};\\n        }\\n    }\\n    void changeRating(string food, int r) {\\n        string c=curr[food].second;\\n        curr[food]={r,c};\\n        mp[c].push({r,food});\\n    }\\n    string highestRated(string cuisine) {\\n        while(true){\\n            string food=mp[cuisine].top().second;\\n            int r=mp[cuisine].top().first;\\n            if(curr[food].first==r){\\n                break;\\n            }\\n            mp[cuisine].pop();\\n        }\\n        return mp[cuisine].top().second;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define p pair<int,string> \\nstruct Comp{\\n    bool operator()(p a,p b){\\n        return a.first==b.first? a.second>b.second:a.first<b.first;\\n    }  \\n};\\nclass FoodRatings {\\npublic:\\n    map<string,priority_queue<p,vector<p>,Comp>>mp; //maps cuisine to priority queue of pairs of rating and food item name\\n    unordered_map<string,pair<int,string>>curr; //maps food item name to it\\'s current rating and cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            curr[foods[i]]={ratings[i],cuisines[i]};\\n        }\\n    }\\n    void changeRating(string food, int r) {\\n        string c=curr[food].second;\\n        curr[food]={r,c};\\n        mp[c].push({r,food});\\n    }\\n    string highestRated(string cuisine) {\\n        while(true){\\n            string food=mp[cuisine].top().second;\\n            int r=mp[cuisine].top().first;\\n            if(curr[food].first==r){\\n                break;\\n            }\\n            mp[cuisine].pop();\\n        }\\n        return mp[cuisine].top().second;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382537,
                "title": "go-two-maps-and-a-heap-discussion",
                "content": "For these types of problems, consider:\\n\\n* How many elements are there?\\n* What are the access patterns?\\n* What is the worst-case scenario?\\n\\nIn a real-world scenario, the access patterns are more well-known.\\nFor example, ChangeRating may be called 100 times as often as HighestRated.\\n\\nSadly, on Leetcode, they rarely give this info, and test cases usually try all extremes,\\nso you are forced to find a generic solution to cater for all cases.\\n\\n`ChangeRating` is easy to solve - simply store all food items in a map.\\n\\n`HighestRated` needs to efficiently find the highest value, and so a heap is a good approach.\\n\\nWhen a food item changes, the rating will also affect the heap.\\nTo solve this, we may share the same food item between the map and the heap,\\nand use `heap.Fix(&h, idx)` to \"fix\" the heap after an item\\'s rating has changed.\\n\\nTo \"fix\" the heap, you must keep track of where the food item is in the heap.\\nFor this, the food item is given an auxiliary `heapIdx` field.\\n\\n**What if each cuisine only had one food item?**\\n\\nConsider the extreme case of having one food item per cuisine. \\nThen there is a lot of overhead in having one heap per item, right?\\n\\nActually, no. The heap is a pointer to a slice, which is a SliceHeader + uintptr.\\nIn total that is 256 bits of data, as opposed to 64 bits. Trading 192 bits for a heap is very cheap.\\n\\nThe real discussion is not in terms of performance but rather about complexity.\\nA heap is arguably more complex than a simple slice.\\nSo if it was known that it is exceedingly rare for a cuisine to have more than, say, 5 items each.\\nThen I\\'d go with a slice instead. Not because it\\'s faster, but because it\\'s simpler.\\n\\n```go\\ntype food struct {\\n\\tname    string\\n\\tcuisine string\\n\\trating  int\\n\\n\\theapIdx int // keep track of food item\\'s position in the heap\\n}\\n\\ntype FoodRatings struct {\\n\\tfoods    map[string]*food\\n\\tcuisines map[string]*foodHeap\\n}\\n\\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\\n\\t// The idea is to use pointers and heap.Fix to manage updates to the\\n\\t// heap and ratings of a given food.\\n\\tvar r FoodRatings\\n\\tr.cuisines = make(map[string]*foodHeap)\\n\\tr.foods = make(map[string]*food)\\n\\tfor i := range foods {\\n\\t\\tif _, exists := r.cuisines[cuisines[i]]; !exists {\\n\\t\\t\\tr.cuisines[cuisines[i]] = &foodHeap{}\\n\\t\\t}\\n\\t\\tf := &food{\\n\\t\\t\\tname:    foods[i],\\n\\t\\t\\tcuisine: cuisines[i],\\n\\t\\t\\trating:  ratings[i],\\n\\t\\t}\\n\\t\\theap.Push(r.cuisines[cuisines[i]], f)\\n\\t\\tr.foods[foods[i]] = f\\n\\t}\\n\\treturn r\\n}\\n\\nfunc (this *FoodRatings) ChangeRating(food string, newRating int) {\\n\\tf := this.foods[food]\\n\\tf.rating = newRating\\n\\theap.Fix(this.cuisines[f.cuisine], f.heapIdx)\\n}\\n\\nfunc (this *FoodRatings) HighestRated(cuisine string) string {\\n\\treturn (*this.cuisines[cuisine])[0].name\\n}\\n\\ntype foodHeap []*food\\n\\nfunc (h foodHeap) Len() int { return len(h) }\\nfunc (h foodHeap) Swap(i, j int) {\\n\\th[i], h[j] = h[j], h[i]\\n\\th[i].heapIdx = i\\n\\th[j].heapIdx = j\\n}\\nfunc (h foodHeap) Less(i, j int) bool {\\n\\tif h[i].rating == h[j].rating {\\n\\t\\treturn h[i].name < h[j].name\\n\\t}\\n\\treturn h[i].rating > h[j].rating\\n}\\nfunc (h *foodHeap) Push(x interface{}) {\\n\\ta := x.(*food)\\n\\ta.heapIdx = len(*h)\\n\\t*h = append(*h, a)\\n}\\nfunc (h *foodHeap) Pop() interface{} {\\n\\tn := len(*h)\\n\\tit := (*h)[n-1]\\n\\t*h = (*h)[:n-1]\\n\\treturn it\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype food struct {\\n\\tname    string\\n\\tcuisine string\\n\\trating  int\\n\\n\\theapIdx int // keep track of food item\\'s position in the heap\\n}\\n\\ntype FoodRatings struct {\\n\\tfoods    map[string]*food\\n\\tcuisines map[string]*foodHeap\\n}\\n\\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\\n\\t// The idea is to use pointers and heap.Fix to manage updates to the\\n\\t// heap and ratings of a given food.\\n\\tvar r FoodRatings\\n\\tr.cuisines = make(map[string]*foodHeap)\\n\\tr.foods = make(map[string]*food)\\n\\tfor i := range foods {\\n\\t\\tif _, exists := r.cuisines[cuisines[i]]; !exists {\\n\\t\\t\\tr.cuisines[cuisines[i]] = &foodHeap{}\\n\\t\\t}\\n\\t\\tf := &food{\\n\\t\\t\\tname:    foods[i],\\n\\t\\t\\tcuisine: cuisines[i],\\n\\t\\t\\trating:  ratings[i],\\n\\t\\t}\\n\\t\\theap.Push(r.cuisines[cuisines[i]], f)\\n\\t\\tr.foods[foods[i]] = f\\n\\t}\\n\\treturn r\\n}\\n\\nfunc (this *FoodRatings) ChangeRating(food string, newRating int) {\\n\\tf := this.foods[food]\\n\\tf.rating = newRating\\n\\theap.Fix(this.cuisines[f.cuisine], f.heapIdx)\\n}\\n\\nfunc (this *FoodRatings) HighestRated(cuisine string) string {\\n\\treturn (*this.cuisines[cuisine])[0].name\\n}\\n\\ntype foodHeap []*food\\n\\nfunc (h foodHeap) Len() int { return len(h) }\\nfunc (h foodHeap) Swap(i, j int) {\\n\\th[i], h[j] = h[j], h[i]\\n\\th[i].heapIdx = i\\n\\th[j].heapIdx = j\\n}\\nfunc (h foodHeap) Less(i, j int) bool {\\n\\tif h[i].rating == h[j].rating {\\n\\t\\treturn h[i].name < h[j].name\\n\\t}\\n\\treturn h[i].rating > h[j].rating\\n}\\nfunc (h *foodHeap) Push(x interface{}) {\\n\\ta := x.(*food)\\n\\ta.heapIdx = len(*h)\\n\\t*h = append(*h, a)\\n}\\nfunc (h *foodHeap) Pop() interface{} {\\n\\tn := len(*h)\\n\\tit := (*h)[n-1]\\n\\t*h = (*h)[:n-1]\\n\\treturn it\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2342927,
                "title": "rust-hashmap-and-btreeset",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/ood/lvl3/lc2353)\\n\\n<b>Problem List</b>\\n#HashMap - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_data_structure/map/hashmap)\\n#TreeSet - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/set/treeset.txt)\\n\\n```\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::{BTreeSet, HashMap};\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexities:\\n///     `new()`:            O(`len_fs`)\\n///     `change_rating`:    O(lg(`len_fs`))\\n///     `highest_rated`:    O(1)\\n/// Space Complexity:       O(`len_fs`)\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, BTreeSet<Food>>,\\n    name_to_food: HashMap<String, Food>,\\n    name_to_cuisine: HashMap<String, String>,\\n}\\n\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, BTreeSet<Food>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Food> = HashMap::new();\\n        let mut name_to_cuisine: HashMap<String, String> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: &String = &foods[idx];\\n            let cuisine: &String = &cuisines[idx];\\n            let rating: i32 = ratings[idx];\\n            let food: Food = Food {\\n                name: name.to_owned(),\\n                rating,\\n            };\\n            cuisine_to_foods\\n                .entry(cuisine.to_owned())\\n                .or_default()\\n                .insert(food.clone());\\n            name_to_cuisine.insert(name.to_owned(), cuisine.to_owned());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n            name_to_cuisine,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get_mut(&name) {\\n            if let Some(cuisine) = self.name_to_cuisine.get(&name) {\\n                if let Some(foods) = self.cuisine_to_foods.get_mut(cuisine) {\\n                    foods.remove(food);\\n                    food.rating = new_rating;\\n                    foods.insert(food.clone());\\n                }\\n            }\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(foods) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(last) = foods.iter().last() {\\n                return last.name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\n#[derive(Clone)]\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &other.name).cmp(&(other.rating, &self.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(other.name.cmp(&self.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```\\n\\nTo reply on vectors, with sorting them everytime one changing ratings, leads to TLE.\\n\\n```\\nuse std::cell::RefCell;\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::HashMap;\\nuse std::rc::Rc;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexities:\\n///     `new()`:            O(`len_fs`)\\n///     `change_rating`:    O(lg(`len_fs`))\\n///     `highest_rated`:    O(1)\\n/// Space Complexity:       O(`len_fs`)\\n#[allow(dead_code)]\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, Vec<Rc<RefCell<Food>>>>,\\n    name_to_food: HashMap<String, Rc<RefCell<Food>>>,\\n    name_to_cuisine: HashMap<String, String>,\\n}\\n\\n#[allow(dead_code)]\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, Vec<Rc<RefCell<Food>>>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Rc<RefCell<Food>>> = HashMap::new();\\n        let mut name_to_cuisine: HashMap<String, String> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: &String = &foods[idx];\\n            let cuisine: &String = &cuisines[idx];\\n            let rating: i32 = ratings[idx];\\n            let food: Rc<RefCell<Food>> = Rc::new(RefCell::new(Food {\\n                name: name.to_owned(),\\n                rating,\\n            }));\\n            cuisine_to_foods\\n                .entry(cuisine.to_owned())\\n                .or_default()\\n                .push(food.clone());\\n            name_to_cuisine.insert(name.to_owned(), cuisine.to_owned());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        for (_cuisine, foods) in cuisine_to_foods.iter_mut() {\\n            foods.sort();\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n            name_to_cuisine,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get(&name) {\\n            food.borrow_mut().rating = new_rating;\\n            if let Some(cuisine) = self.name_to_cuisine.get(&name) {\\n                if let Some(foods) = self.cuisine_to_foods.get_mut(cuisine) {\\n                    foods.sort();\\n                }\\n            }\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(foods) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(last) = foods.last() {\\n                return last.borrow().name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &other.name).cmp(&(other.rating, &self.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(other.name.cmp(&self.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```\\n\\nTo reply on heaps, even though to leverage interior mutability is technically feasible, it is <b>not</b> recommended to do so, and the order of elements in the heap does <b>not</b> change.\\n\\nThis is a wrong solution.\\n\\n```\\nuse std::cell::RefCell;\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::{BinaryHeap, HashMap};\\nuse std::rc::Rc;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexitiy:   N.A.\\n/// Space Complexity:   N.A.\\n/// Note:\\n/// this is a wrong solution.\\n/// Note - Lessons Learned:\\n/// https://stackoverflow.com/questions/58790368/updating-structs-inside-a-btreeset/58790477#58790477\\n/// https://stackoverflow.com/questions/53111721/can-i-modify-a-value-inside-a-binaryheap-that-isnt-the-top-value\\n#[allow(dead_code)]\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, BinaryHeap<Rc<RefCell<Food>>>>,\\n    name_to_food: HashMap<String, Rc<RefCell<Food>>>,\\n}\\n\\n#[allow(dead_code)]\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, BinaryHeap<Rc<RefCell<Food>>>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Rc<RefCell<Food>>> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: String = foods[idx].to_owned();\\n            let cuisine: String = cuisines[idx].to_owned();\\n            let rating: i32 = ratings[idx];\\n            let food: Rc<RefCell<Food>> = Rc::new(RefCell::new(Food {\\n                name: name.to_owned(),\\n                rating,\\n            }));\\n            cuisine_to_foods\\n                .entry(cuisine)\\n                .or_default()\\n                .push(food.clone());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get(&name) {\\n            food.clone().borrow_mut().rating = new_rating;\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(heap) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(top) = heap.peek() {\\n                return top.clone().borrow().name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &self.name).cmp(&(other.rating, &other.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(self.name.cmp(&other.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    #[should_panic]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::{BTreeSet, HashMap};\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexities:\\n///     `new()`:            O(`len_fs`)\\n///     `change_rating`:    O(lg(`len_fs`))\\n///     `highest_rated`:    O(1)\\n/// Space Complexity:       O(`len_fs`)\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, BTreeSet<Food>>,\\n    name_to_food: HashMap<String, Food>,\\n    name_to_cuisine: HashMap<String, String>,\\n}\\n\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, BTreeSet<Food>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Food> = HashMap::new();\\n        let mut name_to_cuisine: HashMap<String, String> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: &String = &foods[idx];\\n            let cuisine: &String = &cuisines[idx];\\n            let rating: i32 = ratings[idx];\\n            let food: Food = Food {\\n                name: name.to_owned(),\\n                rating,\\n            };\\n            cuisine_to_foods\\n                .entry(cuisine.to_owned())\\n                .or_default()\\n                .insert(food.clone());\\n            name_to_cuisine.insert(name.to_owned(), cuisine.to_owned());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n            name_to_cuisine,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get_mut(&name) {\\n            if let Some(cuisine) = self.name_to_cuisine.get(&name) {\\n                if let Some(foods) = self.cuisine_to_foods.get_mut(cuisine) {\\n                    foods.remove(food);\\n                    food.rating = new_rating;\\n                    foods.insert(food.clone());\\n                }\\n            }\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(foods) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(last) = foods.iter().last() {\\n                return last.name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\n#[derive(Clone)]\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &other.name).cmp(&(other.rating, &self.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(other.name.cmp(&self.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```\n```\\nuse std::cell::RefCell;\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::HashMap;\\nuse std::rc::Rc;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexities:\\n///     `new()`:            O(`len_fs`)\\n///     `change_rating`:    O(lg(`len_fs`))\\n///     `highest_rated`:    O(1)\\n/// Space Complexity:       O(`len_fs`)\\n#[allow(dead_code)]\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, Vec<Rc<RefCell<Food>>>>,\\n    name_to_food: HashMap<String, Rc<RefCell<Food>>>,\\n    name_to_cuisine: HashMap<String, String>,\\n}\\n\\n#[allow(dead_code)]\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, Vec<Rc<RefCell<Food>>>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Rc<RefCell<Food>>> = HashMap::new();\\n        let mut name_to_cuisine: HashMap<String, String> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: &String = &foods[idx];\\n            let cuisine: &String = &cuisines[idx];\\n            let rating: i32 = ratings[idx];\\n            let food: Rc<RefCell<Food>> = Rc::new(RefCell::new(Food {\\n                name: name.to_owned(),\\n                rating,\\n            }));\\n            cuisine_to_foods\\n                .entry(cuisine.to_owned())\\n                .or_default()\\n                .push(food.clone());\\n            name_to_cuisine.insert(name.to_owned(), cuisine.to_owned());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        for (_cuisine, foods) in cuisine_to_foods.iter_mut() {\\n            foods.sort();\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n            name_to_cuisine,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get(&name) {\\n            food.borrow_mut().rating = new_rating;\\n            if let Some(cuisine) = self.name_to_cuisine.get(&name) {\\n                if let Some(foods) = self.cuisine_to_foods.get_mut(cuisine) {\\n                    foods.sort();\\n                }\\n            }\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(foods) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(last) = foods.last() {\\n                return last.borrow().name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &other.name).cmp(&(other.rating, &self.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(other.name.cmp(&self.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```\n```\\nuse std::cell::RefCell;\\nuse std::cmp::{Ord, Ordering, PartialEq, PartialOrd};\\nuse std::collections::{BinaryHeap, HashMap};\\nuse std::rc::Rc;\\n\\n/// @author: Leon\\n/// https://leetcode.com/problems/design-a-food-rating-system/\\n/// Time Complexitiy:   N.A.\\n/// Space Complexity:   N.A.\\n/// Note:\\n/// this is a wrong solution.\\n/// Note - Lessons Learned:\\n/// https://stackoverflow.com/questions/58790368/updating-structs-inside-a-btreeset/58790477#58790477\\n/// https://stackoverflow.com/questions/53111721/can-i-modify-a-value-inside-a-binaryheap-that-isnt-the-top-value\\n#[allow(dead_code)]\\nstruct FoodRatings {\\n    cuisine_to_foods: HashMap<String, BinaryHeap<Rc<RefCell<Food>>>>,\\n    name_to_food: HashMap<String, Rc<RefCell<Food>>>,\\n}\\n\\n#[allow(dead_code)]\\nimpl FoodRatings {\\n    fn new(foods: Vec<String>, cuisines: Vec<String>, ratings: Vec<i32>) -> Self {\\n        let len_fs: usize = foods.len();\\n        let mut cuisine_to_foods: HashMap<String, BinaryHeap<Rc<RefCell<Food>>>> = HashMap::new();\\n        let mut name_to_food: HashMap<String, Rc<RefCell<Food>>> = HashMap::new();\\n        for idx in 0..len_fs {\\n            let name: String = foods[idx].to_owned();\\n            let cuisine: String = cuisines[idx].to_owned();\\n            let rating: i32 = ratings[idx];\\n            let food: Rc<RefCell<Food>> = Rc::new(RefCell::new(Food {\\n                name: name.to_owned(),\\n                rating,\\n            }));\\n            cuisine_to_foods\\n                .entry(cuisine)\\n                .or_default()\\n                .push(food.clone());\\n            name_to_food.insert(name.to_owned(), food.clone());\\n        }\\n        FoodRatings {\\n            cuisine_to_foods,\\n            name_to_food,\\n        }\\n    }\\n\\n    fn change_rating(&mut self, name: String, new_rating: i32) {\\n        if let Some(food) = self.name_to_food.get(&name) {\\n            food.clone().borrow_mut().rating = new_rating;\\n        }\\n    }\\n\\n    fn highest_rated(&self, cuisine: String) -> String {\\n        if let Some(heap) = self.cuisine_to_foods.get(&cuisine) {\\n            if let Some(top) = heap.peek() {\\n                return top.clone().borrow().name.to_owned();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n\\nstruct Food {\\n    name: String,\\n    rating: i32,\\n}\\n\\nimpl Ord for Food {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        (self.rating, &self.name).cmp(&(other.rating, &other.name))\\n    }\\n}\\n\\nimpl PartialOrd for Food {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        if self.rating != other.rating {\\n            Some(self.rating.cmp(&other.rating))\\n        } else {\\n            Some(self.name.cmp(&other.name))\\n        }\\n    }\\n}\\n\\nimpl Eq for Food {}\\n\\nimpl PartialEq for Food {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.name == other.name && self.rating == other.rating\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    #[test]\\n    #[should_panic]\\n    fn test_with_sample_input_1_should_return_expected() {\\n        let foods: Vec<String> = vec![\\n            \"kimchi\".to_owned(),\\n            \"miso\".to_owned(),\\n            \"sushi\".to_owned(),\\n            \"moussaka\".to_owned(),\\n            \"ramen\".to_owned(),\\n            \"bulgogi\".to_owned(),\\n        ];\\n        let cuisines: Vec<String> = vec![\\n            \"korean\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"greek\".to_owned(),\\n            \"japanese\".to_owned(),\\n            \"korean\".to_owned(),\\n        ];\\n        let ratings: Vec<i32> = vec![9, 12, 8, 15, 14, 7];\\n        let mut food_ratings: FoodRatings = FoodRatings::new(foods, cuisines, ratings);\\n        let expected1: String = \"kimchi\".to_owned();\\n        let actual1: String = food_ratings.highest_rated(\"korean\".to_owned());\\n        assert_eq!(expected1, actual1);\\n        let expected2: String = \"ramen\".to_owned();\\n        let actual2: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected2, actual2);\\n        food_ratings.change_rating(\"sushi\".to_owned(), 16);\\n        let expected3: String = \"sushi\".to_owned();\\n        let actual3: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected3, actual3);\\n        food_ratings.change_rating(\"ramen\".to_owned(), 16);\\n        let expected4: String = \"ramen\".to_owned();\\n        let actual4: String = food_ratings.highest_rated(\"japanese\".to_owned());\\n        assert_eq!(expected4, actual4);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334200,
                "title": "python-using-sortedlist-and-heap",
                "content": "### use SortedList\\n\\tfrom sortedcontainers import SortedList\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.f2c = {}\\n\\t\\t\\tself.c2rf = defaultdict(SortedList)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\tself.f2c[foods[i]] = (cuisines[i], ratings[i])\\n\\t\\t\\t\\tself.c2rf[cuisines[i]].add((-ratings[i], foods[i]))\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tcuisine, rating = self.f2c[food]\\n\\t\\t\\tself.c2rf[cuisine].remove((-rating, food))\\n\\t\\t\\tself.c2rf[cuisine].add((-newRating, food))\\n\\t\\t\\tself.f2c[food] = (cuisine, newRating)\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\treturn self.c2rf[cuisine][0][1]\\n\\n### use heap\\n\\tfrom collections import defaultdict\\n\\tfrom heapq import heappush, heappop\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.f2r = defaultdict(int)\\n\\t\\t\\tself.f2c = defaultdict(str)\\n\\t\\t\\tself.c2rf = defaultdict(list)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\tself.f2r[foods[i]] = ratings[i]\\n\\t\\t\\t\\tself.f2c[foods[i]] = cuisines[i]\\n\\t\\t\\t\\theappush(self.c2rf[cuisines[i]], (-ratings[i], foods[i]))\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tself.f2r[food] = newRating\\n\\t\\t\\theappush(self.c2rf[self.f2c[food]], (-newRating, food))\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\twhile (self.c2rf[cuisine]):\\n\\t\\t\\t\\tif (self.c2rf[cuisine][0][0] != -self.f2r[self.c2rf[cuisine][0][1]]):\\n\\t\\t\\t\\t\\theappop(self.c2rf[cuisine])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn self.c2rf[cuisine][0][1]",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "### use SortedList\\n\\tfrom sortedcontainers import SortedList\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.f2c = {}\\n\\t\\t\\tself.c2rf = defaultdict(SortedList)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\tself.f2c[foods[i]] = (cuisines[i], ratings[i])\\n\\t\\t\\t\\tself.c2rf[cuisines[i]].add((-ratings[i], foods[i]))\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tcuisine, rating = self.f2c[food]\\n\\t\\t\\tself.c2rf[cuisine].remove((-rating, food))\\n\\t\\t\\tself.c2rf[cuisine].add((-newRating, food))\\n\\t\\t\\tself.f2c[food] = (cuisine, newRating)\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\treturn self.c2rf[cuisine][0][1]\\n\\n### use heap\\n\\tfrom collections import defaultdict\\n\\tfrom heapq import heappush, heappop\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.f2r = defaultdict(int)\\n\\t\\t\\tself.f2c = defaultdict(str)\\n\\t\\t\\tself.c2rf = defaultdict(list)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\tself.f2r[foods[i]] = ratings[i]\\n\\t\\t\\t\\tself.f2c[foods[i]] = cuisines[i]\\n\\t\\t\\t\\theappush(self.c2rf[cuisines[i]], (-ratings[i], foods[i]))\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tself.f2r[food] = newRating\\n\\t\\t\\theappush(self.c2rf[self.f2c[food]], (-newRating, food))\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\twhile (self.c2rf[cuisine]):\\n\\t\\t\\t\\tif (self.c2rf[cuisine][0][0] != -self.f2r[self.c2rf[cuisine][0][1]]):\\n\\t\\t\\t\\t\\theappop(self.c2rf[cuisine])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn self.c2rf[cuisine][0][1]",
                "codeTag": "Java"
            },
            {
                "id": 2329658,
                "title": "priorityqueue-ordering-not-working-looking-for-help",
                "content": "Could anyone shed light on why is the custom sorting in the PriorityQueue not working?\\n\\nFor this ordering specifically,\\n```\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n            (a,b) -> (\\n                a.getValue() == b.getValue() ? \\n                b.getKey().compareTo(a.getKey()) : \\n                a.getValue() - b.getValue()\\n            )\\n        );\\n```\\nMap.Entry<String, Integer> [kjop=995] would come before [lzeqwfb=995]\\n\\n\\nInput:\\n```\\n[\"FoodRatings\",\"changeRating\",\"changeRating\",\"highestRated\"]\\n[[[\"vhbibydfop\",\"ggtdlawxup\",\"lslcltacc\",\"bqgkfcy\",\"xxowyabq\",\"ezswv\",\"ewgvsuyvpo\",\"zgochpey\",\"epiaxxiv\",\"idpdiqlcp\",\"wqgrbvme\",\"wqxbxeovwe\",\"iduzk\",\"ahemklz\",\"ah\",\"rvuqnlydxu\",\"dldqmpheob\",\"lzeqwfb\",\"ykwjc\",\"dtrgnrcqr\",\"cwcgevzzz\",\"zejbynj\",\"ivhdsnjpho\",\"gsyewq\",\"ekqhtiijrj\",\"cthwbt\",\"gnbhjyhcil\",\"kkthw\",\"ktiqokzl\",\"zzroi\",\"cjwapjnzql\",\"hfum\",\"jrwby\",\"amhfyno\",\"bj\",\"fszije\",\"nbkpptir\",\"dgzmoxhhoe\",\"bnisfskgxi\",\"uepypxnsy\",\"afdz\",\"tdctkeg\",\"lfsohpzmk\",\"ewwqult\",\"iynyddno\",\"yyroyjzdg\",\"mcpea\",\"lzafjh\",\"jdvcxidtm\",\"qvkyqmupz\",\"kjop\",\"girgfkaib\",\"qecvnaxpsm\",\"itx\",\"xhjmq\",\"lwwbdxkz\",\"chthxuhex\",\"tghokrfica\",\"vrmjibxv\",\"oipnttbz\",\"yyfvlwvj\",\"erbtnw\",\"yezfiom\",\"ismarfqbuv\",\"vmfxlqbxwa\",\"pcwparohxf\",\"bpdrndbv\",\"owgjjitjfd\",\"fdwmxhli\",\"kffetdxvfx\",\"ruahmg\",\"aphbsbkimb\",\"nbkdfkgl\",\"rxehcqcrwu\",\"kxwlfxbe\",\"qukxd\",\"tewgnjuxnm\",\"jxfqwqe\",\"mdgwiok\",\"tbkmnx\",\"klzznopcn\",\"vjbcvddw\",\"yzhawtmpwp\",\"fhjichpi\",\"tapig\",\"glfbwolsoa\",\"xklqlzm\"],[\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\"],[146,562,428,619,731,483,598,619,950,446,630,556,894,911,537,359,863,995,417,702,689,667,502,691,896,582,111,319,182,953,131,372,563,963,300,42,829,187,676,509,259,688,897,614,392,170,392,1,134,79,995,371,886,430,72,830,871,758,247,333,128,987,659,933,640,198,638,585,825,904,729,214,974,935,581,985,85,987,51,174,301,635,148,492,200,275,101]],[\"nbkdfkgl\",908],[\"hfum\",256],[\"kggxajkarh\"]]\\n```\\n\\nOutput:\\n```\\n[null,null,null,\"lzeqwfb\"]\\n```\\n\\nExpected:\\n```\\n[null,null,null,\"kjop\"]\\n```\\n\\nMy code:\\n```\\nclass FoodRatings {\\n    Map<String, Map<String, Integer>> cuisineMap;\\n    Map<String, String> foodCuisineMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineMap = new HashMap<String, Map<String, Integer>>();\\n        foodCuisineMap = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            cuisineMap.putIfAbsent(cuisines[i], new HashMap<String, Integer>());\\n            cuisineMap.get(cuisines[i]).put(foods[i], ratings[i]);\\n            \\n            foodCuisineMap.putIfAbsent(foods[i], cuisines[i]);\\n        }        \\n    }\\n    \\n    public void changeRating(String food, int newRating) { \\n        String cuisine = foodCuisineMap.get(food);\\n        if (cuisine == null) {\\n            return;\\n        }\\n        \\n        cuisineMap.get(cuisine).put(food, newRating);    \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        Map<String, Integer> entries = cuisineMap.get(cuisine);\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n            (a,b) -> (\\n                a.getValue() == b.getValue() ? \\n                b.getKey().compareTo(a.getKey()) : \\n                a.getValue() - b.getValue()\\n            )\\n        );\\n        \\n        for (Map.Entry<String, Integer> entry: entries.entrySet()) {\\n            pq.add(entry);\\n            \\n            if (pq.size() > 1) {\\n                pq.poll();\\n            }\\n        }\\n        \\n        // while (pq.size() > 0) {\\n        //     System.out.println(pq.poll());\\n        // }\\n        \\n        return pq.peek().getKey();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n            (a,b) -> (\\n                a.getValue() == b.getValue() ? \\n                b.getKey().compareTo(a.getKey()) : \\n                a.getValue() - b.getValue()\\n            )\\n        );\\n```\n```\\n[\"FoodRatings\",\"changeRating\",\"changeRating\",\"highestRated\"]\\n[[[\"vhbibydfop\",\"ggtdlawxup\",\"lslcltacc\",\"bqgkfcy\",\"xxowyabq\",\"ezswv\",\"ewgvsuyvpo\",\"zgochpey\",\"epiaxxiv\",\"idpdiqlcp\",\"wqgrbvme\",\"wqxbxeovwe\",\"iduzk\",\"ahemklz\",\"ah\",\"rvuqnlydxu\",\"dldqmpheob\",\"lzeqwfb\",\"ykwjc\",\"dtrgnrcqr\",\"cwcgevzzz\",\"zejbynj\",\"ivhdsnjpho\",\"gsyewq\",\"ekqhtiijrj\",\"cthwbt\",\"gnbhjyhcil\",\"kkthw\",\"ktiqokzl\",\"zzroi\",\"cjwapjnzql\",\"hfum\",\"jrwby\",\"amhfyno\",\"bj\",\"fszije\",\"nbkpptir\",\"dgzmoxhhoe\",\"bnisfskgxi\",\"uepypxnsy\",\"afdz\",\"tdctkeg\",\"lfsohpzmk\",\"ewwqult\",\"iynyddno\",\"yyroyjzdg\",\"mcpea\",\"lzafjh\",\"jdvcxidtm\",\"qvkyqmupz\",\"kjop\",\"girgfkaib\",\"qecvnaxpsm\",\"itx\",\"xhjmq\",\"lwwbdxkz\",\"chthxuhex\",\"tghokrfica\",\"vrmjibxv\",\"oipnttbz\",\"yyfvlwvj\",\"erbtnw\",\"yezfiom\",\"ismarfqbuv\",\"vmfxlqbxwa\",\"pcwparohxf\",\"bpdrndbv\",\"owgjjitjfd\",\"fdwmxhli\",\"kffetdxvfx\",\"ruahmg\",\"aphbsbkimb\",\"nbkdfkgl\",\"rxehcqcrwu\",\"kxwlfxbe\",\"qukxd\",\"tewgnjuxnm\",\"jxfqwqe\",\"mdgwiok\",\"tbkmnx\",\"klzznopcn\",\"vjbcvddw\",\"yzhawtmpwp\",\"fhjichpi\",\"tapig\",\"glfbwolsoa\",\"xklqlzm\"],[\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\",\"kggxajkarh\"],[146,562,428,619,731,483,598,619,950,446,630,556,894,911,537,359,863,995,417,702,689,667,502,691,896,582,111,319,182,953,131,372,563,963,300,42,829,187,676,509,259,688,897,614,392,170,392,1,134,79,995,371,886,430,72,830,871,758,247,333,128,987,659,933,640,198,638,585,825,904,729,214,974,935,581,985,85,987,51,174,301,635,148,492,200,275,101]],[\"nbkdfkgl\",908],[\"hfum\",256],[\"kggxajkarh\"]]\\n```\n```\\n[null,null,null,\"lzeqwfb\"]\\n```\n```\\n[null,null,null,\"kjop\"]\\n```\n```\\nclass FoodRatings {\\n    Map<String, Map<String, Integer>> cuisineMap;\\n    Map<String, String> foodCuisineMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineMap = new HashMap<String, Map<String, Integer>>();\\n        foodCuisineMap = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            cuisineMap.putIfAbsent(cuisines[i], new HashMap<String, Integer>());\\n            cuisineMap.get(cuisines[i]).put(foods[i], ratings[i]);\\n            \\n            foodCuisineMap.putIfAbsent(foods[i], cuisines[i]);\\n        }        \\n    }\\n    \\n    public void changeRating(String food, int newRating) { \\n        String cuisine = foodCuisineMap.get(food);\\n        if (cuisine == null) {\\n            return;\\n        }\\n        \\n        cuisineMap.get(cuisine).put(food, newRating);    \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        Map<String, Integer> entries = cuisineMap.get(cuisine);\\n        PriorityQueue<Map.Entry<String, Integer>> pq = new PriorityQueue<>(\\n            (a,b) -> (\\n                a.getValue() == b.getValue() ? \\n                b.getKey().compareTo(a.getKey()) : \\n                a.getValue() - b.getValue()\\n            )\\n        );\\n        \\n        for (Map.Entry<String, Integer> entry: entries.entrySet()) {\\n            pq.add(entry);\\n            \\n            if (pq.size() > 1) {\\n                pq.poll();\\n            }\\n        }\\n        \\n        // while (pq.size() > 0) {\\n        //     System.out.println(pq.poll());\\n        // }\\n        \\n        return pq.peek().getKey();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325377,
                "title": "three-maps-unordered-maps-in-c-explained-thought-process",
                "content": "The first thing is to solve this question is to take a paper and pen and try to write the info and given and functions required. This helped me as earlier i used to just think in my head and directly go on coding just to find later that i missed a requirement and start over again.\\n\\nOk, firstly two functions requirement: \\nchangeRating(food,newRating) -> void\\nhighestRated(cuisine) -> string food(in given cuisine)\\n\\nNow for the first requirement: \\nFirst thought might be simple unordered_map for fast updates of ratings\\n**unordered_map<string,int> foods_to_ratings**\\nNow the first requirement is easy and main bottleneck is second requirement. Also we need to keep in mind that we already choosen a **foods_to_ratings unordered_map** so we have to keep that updated too.\\n\\nSecond function takes a cuisine.\\n\\nWhat if keep **unordered_map<string,vector<pair<int,string>> cuisine_to_ratings_food** where **string is cuisine given** and **vector stores the pair<ratings,food>** \\nIt\\'s because i need to quickly decide which the highest rated food in **given cuisine** so i need **some food division based on cuisine**.\\nBut now for highestRated food in that vector of cuisine_to_ratings_food[given_cuisine] i had to go over the take the entire vector to find highest rated food which will be not good as in worst case all given food can belong to same cuisine and so **it will take O(n) for each call of function** where  **n can be upto 2x10^4**\\nAlso if any food ratings update by **changeRatings(food,newRatings)** then i need to \\n(1) find cuisine of that food \\n(2) remove the <Oldratings,food> pair from vector in cuisine_to_ratings_food[cusine]  \\n(3) add <needRatings,food> pair in that. ( Note [cuisine] in cuisinetoratingsfood used in operation (2) can be found by (1) operation and way to find (1) is given below) \\n(4) Update the food_to_ratings unordered_map which too quick\\n\\n### How to do (1) operation?\\nI need to find food\\'s cuisine so either i can keep unordered_map<food,cuisine> or map for the same.\\n \\n ### How to the (2) operation?\\n We can get the oldRatings of food by **food_to_Ratings unordered_map**\\n\\n### What\\'s the problem in this approach?\\nObviously the O(n) for findHighestRated(cuisine) is there iterating the vector.\\nAlso O(n) for deleting the pair<oldRatings,food> in changeRatings(food,newRatings) so that the findHighestRated() function works fine. \\n\\n### Where can we improve?\\nOk so i need to cut down the effort for finding the highest rated cuisine and also deletion of pair<ratings,food>. \\nHmm the pair<ratings,food> is unique right? Since for every food only one rating is there at  a time so pair<ratings,food> is unique.\\n### What datastructure is good in maintaining unique set of values in some order and give fast retrieval and updation?\\n### That\\'s set\\n\\n**So instead of vector what if we store the pairs in set<ratings,food> with custom comparator which keeps the highest ratings food at first and if the ratings of more than one food items are same then keep the food in lexicographical order.**\\n\\n**findHighestRated is O(1) since we just return the first pair of set in the cuisine division**.\\nAfter keeping set instead of vector let\\'s see operation of changeRatings(food,newRatings):\\n(1) find cuisine of food by food_to_cuisine unordered map\\n(2) remove the <Oldratings,food> pair from vector in cuisine_to_ratings_food[cusine] \\nin O(10.log(20000)) since for every comparison(in worst case) the strings time complexity for same ratings is O(10).\\n(3) add <needRatings,food> pair in that. ( same as removing a pair)\\n(4) Update the food_to_ratings unordered_map so that in operation (2) we can find OldRatings of food quickly.\\n\\n```cpp\\n//custom comparator\\nstruct Compare\\n{\\n    bool operator ()( const std::pair<int, string> &a, \\n                      const std::pair<int, string> &b ) const{\\n        return a.first!=b.first?a.first>b.first:a.second<b.second;\\n    }\\n};\\n\\n//f_t_r means food to ratings mapping\\n//f_t_c means food to cuisine mapping\\n//c_t_r_f means cuisine to pair<ratings,food> mapping\\n\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,int> f_t_r;\\n    unordered_map<string,string> f_t_c;\\n    unordered_map<string,set<pair<int,string>,Compare>> c_t_r_f;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i < foods.size();i++){\\n            f_t_c[foods[i]] = cuisines[i];\\n            f_t_r[foods[i]] = ratings[i];\\n            c_t_r_f[cuisines[i]].insert(make_pair(ratings[i],foods[i]));\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cuisine = f_t_c[food];\\n        int old_ratings = f_t_r[food];\\n        \\n        f_t_r[food] = newRating;\\n        c_t_r_f[cuisine].erase(make_pair(old_ratings,food));\\n        c_t_r_f[cuisine].insert(make_pair(newRating,food));\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return c_t_r_f[cuisine].begin()->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```\\n\\nAlso note that all the places you can replace unordered_map with map of same kind. It should work fine enough to pass.",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n//custom comparator\\nstruct Compare\\n{\\n    bool operator ()( const std::pair<int, string> &a, \\n                      const std::pair<int, string> &b ) const{\\n        return a.first!=b.first?a.first>b.first:a.second<b.second;\\n    }\\n};\\n\\n//f_t_r means food to ratings mapping\\n//f_t_c means food to cuisine mapping\\n//c_t_r_f means cuisine to pair<ratings,food> mapping\\n\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,int> f_t_r;\\n    unordered_map<string,string> f_t_c;\\n    unordered_map<string,set<pair<int,string>,Compare>> c_t_r_f;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i < foods.size();i++){\\n            f_t_c[foods[i]] = cuisines[i];\\n            f_t_r[foods[i]] = ratings[i];\\n            c_t_r_f[cuisines[i]].insert(make_pair(ratings[i],foods[i]));\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cuisine = f_t_c[food];\\n        int old_ratings = f_t_r[food];\\n        \\n        f_t_r[food] = newRating;\\n        c_t_r_f[cuisine].erase(make_pair(old_ratings,food));\\n        c_t_r_f[cuisine].insert(make_pair(newRating,food));\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return c_t_r_f[cuisine].begin()->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325023,
                "title": "java-clean-code-100-fastest",
                "content": "Tried my best to write modular maintainable code. Food and FoodComparator object can be expanded with extra properties as well as.\\n\\nImprovements are welcome and upvote if it helps.\\n\\n**PriorityQueue vs TreeSet**\\n* PQ remove(), i.e the top element is only O(log N), parameterized removal is O(N) to search the object and O(log N) to remove it. TreeSet is O(log N) removal.\\n* PQ allows duplicates while TS has to be unique. \\n* Actually we can use TS here as it\\'s objects we are storing and comparator takes care of order.\\n![image](https://assets.leetcode.com/users/images/b0c9b538-8a4d-48a2-9233-7404d915e45c_1658766363.7961705.png)\\n\\n*Using TreeSet instead of PriorityQueue made the solution 1500ms+ faster!*\\n\\n```\\nclass FoodRatings {\\n    \\n    class Food {\\n        private String food, cuisine;\\n        private int rating;\\n        Food(String food, String cuisine, int rating){\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    \\n    class FoodComparator implements Comparator<Food>{\\n        public int compare(Food s1, Food s2) {\\n            if (s1.rating < s2.rating)\\n                return 1;\\n            else if (s1.rating > s2.rating)\\n                return -1;\\n            return (s1.food).compareTo(s2.food); // if ratings are equal\\n        }\\n    }\\n    \\n    HashMap<String, Food> foodMap;\\n    HashMap<String, TreeSet<Food>> cuisineMap;\\n    TreeSet<Food> bestFoods;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n        \\n        for(int i=0; i<foods.length; i++){\\n            if(cuisineMap.containsKey(cuisines[i])){\\n                bestFoods = cuisineMap.get(cuisines[i]);\\n            } else{\\n                bestFoods = new TreeSet<>(new FoodComparator());\\n            }\\n            \\n            Food foodObj = new Food(foods[i], cuisines[i], ratings[i]);\\n            bestFoods.add(foodObj);\\n            cuisineMap.put(cuisines[i], bestFoods);\\n            foodMap.put(foods[i], foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String newFood, int newRating) {\\n        Food foodObj = foodMap.get(newFood);\\n        String cuisine = foodObj.cuisine;\\n        bestFoods = cuisineMap.get(cuisine);\\n        \\n        // recompute heap\\n        bestFoods.remove(foodObj);\\n        foodObj.rating = newRating;\\n        bestFoods.add(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        bestFoods = cuisineMap.get(cuisine);\\n        Food foodObj = bestFoods.first();\\n        return foodObj.food;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    \\n    class Food {\\n        private String food, cuisine;\\n        private int rating;\\n        Food(String food, String cuisine, int rating){\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    \\n    class FoodComparator implements Comparator<Food>{\\n        public int compare(Food s1, Food s2) {\\n            if (s1.rating < s2.rating)\\n                return 1;\\n            else if (s1.rating > s2.rating)\\n                return -1;\\n            return (s1.food).compareTo(s2.food); // if ratings are equal\\n        }\\n    }\\n    \\n    HashMap<String, Food> foodMap;\\n    HashMap<String, TreeSet<Food>> cuisineMap;\\n    TreeSet<Food> bestFoods;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n        \\n        for(int i=0; i<foods.length; i++){\\n            if(cuisineMap.containsKey(cuisines[i])){\\n                bestFoods = cuisineMap.get(cuisines[i]);\\n            } else{\\n                bestFoods = new TreeSet<>(new FoodComparator());\\n            }\\n            \\n            Food foodObj = new Food(foods[i], cuisines[i], ratings[i]);\\n            bestFoods.add(foodObj);\\n            cuisineMap.put(cuisines[i], bestFoods);\\n            foodMap.put(foods[i], foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String newFood, int newRating) {\\n        Food foodObj = foodMap.get(newFood);\\n        String cuisine = foodObj.cuisine;\\n        bestFoods = cuisineMap.get(cuisine);\\n        \\n        // recompute heap\\n        bestFoods.remove(foodObj);\\n        foodObj.rating = newRating;\\n        bestFoods.add(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        bestFoods = cuisineMap.get(cuisine);\\n        Food foodObj = bestFoods.first();\\n        return foodObj.food;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324952,
                "title": "c-three-maps",
                "content": "\\tclass FoodRatings {\\n\\tpublic:\\n\\t   unordered_map<string,string>focu; // stores food as key and cuisine as value\\n\\t\\tunordered_map<string,int>fRating; // stores food as key and rating as value\\n\\t\\tunordered_map<string,set<pair<int,string>>>focura; // strores cuisine as key and rating and food as value\\n\\t\\tFoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n\\t\\t\\tfor(int i=0;i<size(foods);i++){\\n\\t\\t\\t\\tfocu[foods[i]] = cuisines[i];\\n\\t\\t\\t\\tfRating[foods[i]] = ratings[i];\\n\\t\\t\\t\\tfocura[cuisines[i]].insert({ratings[i],foods[i]});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid changeRating(string food, int newRating) {\\n\\t\\t\\t   int num = fRating[food];\\n\\t\\t\\t\\tstring cu = focu[food];\\n\\t\\t\\t\\tfocura[cu].erase({num,food});\\n\\t\\t\\t\\tfocura[cu].insert({newRating,food});\\n\\t\\t\\t\\tfRating[food] = newRating;\\n\\t\\t}\\n\\n\\t\\tstring highestRated(string cuisine) {\\n\\t\\t\\tstring res = focura[cuisine].rbegin()->second;\\n\\t\\t\\tint cnt = focura[cuisine].rbegin()->first;\\n\\t\\t\\tfor(auto it = focura[cuisine].rbegin(); it!=focura[cuisine].rend();it++){\\n\\t\\t\\t\\tif(it->first==cnt){\\n\\t\\t\\t\\t\\tres = min(it->second,res);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [],
                "code": "\\tclass FoodRatings {\\n\\tpublic:\\n\\t   unordered_map<string,string>focu; // stores food as key and cuisine as value\\n\\t\\tunordered_map<string,int>fRating; // stores food as key and rating as value\\n\\t\\tunordered_map<string,set<pair<int,string>>>focura; // strores cuisine as key and rating and food as value\\n\\t\\tFoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n\\t\\t\\tfor(int i=0;i<size(foods);i++){\\n\\t\\t\\t\\tfocu[foods[i]] = cuisines[i];\\n\\t\\t\\t\\tfRating[foods[i]] = ratings[i];\\n\\t\\t\\t\\tfocura[cuisines[i]].insert({ratings[i],foods[i]});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvoid changeRating(string food, int newRating) {\\n\\t\\t\\t   int num = fRating[food];\\n\\t\\t\\t\\tstring cu = focu[food];\\n\\t\\t\\t\\tfocura[cu].erase({num,food});\\n\\t\\t\\t\\tfocura[cu].insert({newRating,food});\\n\\t\\t\\t\\tfRating[food] = newRating;\\n\\t\\t}\\n\\n\\t\\tstring highestRated(string cuisine) {\\n\\t\\t\\tstring res = focura[cuisine].rbegin()->second;\\n\\t\\t\\tint cnt = focura[cuisine].rbegin()->first;\\n\\t\\t\\tfor(auto it = focura[cuisine].rbegin(); it!=focura[cuisine].rend();it++){\\n\\t\\t\\t\\tif(it->first==cnt){\\n\\t\\t\\t\\t\\tres = min(it->second,res);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse break;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2324935,
                "title": "easy-java-solution-using-priority-queue-and-hashmap",
                "content": "``` java\\nclass FoodRatings {\\n\\n    class Food {\\n        String name;\\n        String cuisine;\\n        int rating;\\n\\n        public Food(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n\\n    Map<String, Food> map;\\n    Map<String, PriorityQueue<Food>> cuisineMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n        for (int i = 0; i < foods.length; i++) {\\n            Food food = new Food(foods[i], cuisines[i], ratings[i]);\\n            map.put(foods[i], food);\\n            if (!cuisineMap.containsKey(cuisines[i])) \\n                cuisineMap.put(cuisines[i], new PriorityQueue<>(\\n                    (a, b) -> b.rating == a.rating ? a.name.compareTo(b.name) : b.rating - a.rating\\n                ));\\n            cuisineMap.get(cuisines[i]).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        map.get(food).rating = newRating;\\n        PriorityQueue<Food> q = cuisineMap.get(map.get(food).cuisine);\\n        q.remove(map.get(food));\\n        q.offer(map.get(food));\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).peek().name;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass FoodRatings {\\n\\n    class Food {\\n        String name;\\n        String cuisine;\\n        int rating;\\n\\n        public Food(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n\\n    Map<String, Food> map;\\n    Map<String, PriorityQueue<Food>> cuisineMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n        for (int i = 0; i < foods.length; i++) {\\n            Food food = new Food(foods[i], cuisines[i], ratings[i]);\\n            map.put(foods[i], food);\\n            if (!cuisineMap.containsKey(cuisines[i])) \\n                cuisineMap.put(cuisines[i], new PriorityQueue<>(\\n                    (a, b) -> b.rating == a.rating ? a.name.compareTo(b.name) : b.rating - a.rating\\n                ));\\n            cuisineMap.get(cuisines[i]).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        map.get(food).rating = newRating;\\n        PriorityQueue<Food> q = cuisineMap.get(map.get(food).cuisine);\\n        q.remove(map.get(food));\\n        q.offer(map.get(food));\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).peek().name;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324901,
                "title": "c-three-maps",
                "content": "```\\nstruct comp {\\n bool operator()(const pair<int, string> &a, const pair<int, string> &b) const \\n    { \\n        if(a.first==b.first)\\n        {\\n            return a.second>b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    map<string, int> r; \\n    map<string, set<pair<int, string>, comp>> m;\\n    map<string, string> c;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            r[foods[i]]=ratings[i];\\n            m[cuisines[i]].insert({ratings[i], foods[i]});\\n            c[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[c[food]].erase({r[food], food});\\n        m[c[food]].insert({newRating, food});\\n        r[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--m[cuisine].end()).second;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct comp {\\n bool operator()(const pair<int, string> &a, const pair<int, string> &b) const \\n    { \\n        if(a.first==b.first)\\n        {\\n            return a.second>b.second;\\n        }\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    map<string, int> r; \\n    map<string, set<pair<int, string>, comp>> m;\\n    map<string, string> c;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            r[foods[i]]=ratings[i];\\n            m[cuisines[i]].insert({ratings[i], foods[i]});\\n            c[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[c[food]].erase({r[food], food});\\n        m[c[food]].insert({newRating, food});\\n        r[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--m[cuisine].end()).second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324694,
                "title": "two-maps",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    map<string,pair<int,string>> foodRating;\\n    map<string,map<int,set<string>>> cuisineRating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            foodRating[foods[i]] = {ratings[i],cuisines[i]};\\n            cuisineRating[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto it = foodRating[food];\\n        cuisineRating[it.second][it.first].erase(food);\\n        if(cuisineRating[it.second][it.first].size()==0){\\n            cuisineRating[it.second].erase(it.first);\\n        }\\n        cuisineRating[it.second][newRating].insert(food);\\n        foodRating[food] = {newRating,it.second};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = cuisineRating[cuisine].rbegin()->second;\\n        return *it.begin();\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    map<string,pair<int,string>> foodRating;\\n    map<string,map<int,set<string>>> cuisineRating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            foodRating[foods[i]] = {ratings[i],cuisines[i]};\\n            cuisineRating[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto it = foodRating[food];\\n        cuisineRating[it.second][it.first].erase(food);\\n        if(cuisineRating[it.second][it.first].size()==0){\\n            cuisineRating[it.second].erase(it.first);\\n        }\\n        cuisineRating[it.second][newRating].insert(food);\\n        foodRating[food] = {newRating,it.second};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = cuisineRating[cuisine].rbegin()->second;\\n        return *it.begin();\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324665,
                "title": "python-3-maps-heap-solution",
                "content": "```python\\nimport heapq\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_ratings = {food:-rating for food, rating in zip(foods, ratings)}\\n        \\n        self.food_cuisine = {food:cuisine for food, cuisine in zip(foods, cuisines)}\\n        \\n        self.cuisine_foods = collections.defaultdict(list)\\n        for cuisine, (food, rating) in zip(cuisines, zip(foods, ratings)):\\n            self.cuisine_foods[cuisine].append((-rating, food))\\n        for cuisine in self.cuisine_foods:\\n            heapq.heapify(self.cuisine_foods[cuisine])\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_ratings[food] = -newRating\\n        cuisine = self.food_cuisine[food]\\n        heapq.heappush(self.cuisine_foods[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.cuisine_foods[cuisine]:\\n            rating, food = self.cuisine_foods[cuisine][0]\\n            if self.food_ratings[food] != rating:\\n                heapq.heappop(self.cuisine_foods[cuisine])\\n            else:\\n                return food\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nimport heapq\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_ratings = {food:-rating for food, rating in zip(foods, ratings)}\\n        \\n        self.food_cuisine = {food:cuisine for food, cuisine in zip(foods, cuisines)}\\n        \\n        self.cuisine_foods = collections.defaultdict(list)\\n        for cuisine, (food, rating) in zip(cuisines, zip(foods, ratings)):\\n            self.cuisine_foods[cuisine].append((-rating, food))\\n        for cuisine in self.cuisine_foods:\\n            heapq.heapify(self.cuisine_foods[cuisine])\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_ratings[food] = -newRating\\n        cuisine = self.food_cuisine[food]\\n        heapq.heappush(self.cuisine_foods[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.cuisine_foods[cuisine]:\\n            rating, food = self.cuisine_foods[cuisine][0]\\n            if self.food_ratings[food] != rating:\\n                heapq.heappop(self.cuisine_foods[cuisine])\\n            else:\\n                return food\\n",
                "codeTag": "Java"
            },
            {
                "id": 2324636,
                "title": "priority-queue-for-every-cuisine",
                "content": "```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.deleted = defaultdict(int)\\n        self.cuisines = defaultdict(list)\\n        self.f2c = {}\\n        self.ratings = {}\\n        for i in range(n):\\n            heapq.heappush(self.cuisines[cuisines[i]], (-ratings[i], foods[i]))\\n            self.f2c[foods[i]] = cuisines[i]\\n            self.ratings[foods[i]] = ratings[i]\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.f2c[food]\\n        old = self.ratings[food]\\n        self.deleted[(cuisine, -old, food)] += 1\\n        self.ratings[food] = newRating\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisines[cuisine][0]\\n        while (cuisine, rating, food) in self.deleted:\\n            heapq.heappop(self.cuisines[cuisine])\\n            self.deleted[(cuisine, rating, food)] -= 1\\n            if self.deleted[(cuisine, rating, food)] == 0:\\n                del self.deleted[(cuisine, rating, food)]\\n            rating, food = self.cuisines[cuisine][0]\\n        return food\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.deleted = defaultdict(int)\\n        self.cuisines = defaultdict(list)\\n        self.f2c = {}\\n        self.ratings = {}\\n        for i in range(n):\\n            heapq.heappush(self.cuisines[cuisines[i]], (-ratings[i], foods[i]))\\n            self.f2c[foods[i]] = cuisines[i]\\n            self.ratings[foods[i]] = ratings[i]\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.f2c[food]\\n        old = self.ratings[food]\\n        self.deleted[(cuisine, -old, food)] += 1\\n        self.ratings[food] = newRating\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisines[cuisine][0]\\n        while (cuisine, rating, food) in self.deleted:\\n            heapq.heappop(self.cuisines[cuisine])\\n            self.deleted[(cuisine, rating, food)] -= 1\\n            if self.deleted[(cuisine, rating, food)] == 0:\\n                del self.deleted[(cuisine, rating, food)]\\n            rating, food = self.cuisines[cuisine][0]\\n        return food\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573300,
                "title": "python-with-sortedlist",
                "content": "`SortedList`\\xA0is a self-balanced tree with\\xA0`O(logK)`\\xA0insert and\\xA0`O(logK)`\\xA0remove.\\n\\n``` python\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuisine_to_ratings = defaultdict(SortedList)\\n        self.food_to_cuisine = dict()\\n        self.food_to_rating = dict()\\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            self.cuisine_to_ratings[cuisine].add([-rating, food])\\n            if food not in self.food_to_cuisine:\\n                self.food_to_cuisine[food] = cuisine\\n            if food not in self.food_to_rating:\\n                self.food_to_rating[food] = rating\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.food_to_cuisine[food]\\n        self.cuisine_to_ratings[cuisine].discard([-self.food_to_rating[food], food])\\n        self.food_to_rating[food] = newRating\\n        self.cuisine_to_ratings[cuisine].add([-newRating, food])\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if cuisine in self.cuisine_to_ratings:\\n            return self.cuisine_to_ratings[cuisine][0][1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` python\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuisine_to_ratings = defaultdict(SortedList)\\n        self.food_to_cuisine = dict()\\n        self.food_to_rating = dict()\\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            self.cuisine_to_ratings[cuisine].add([-rating, food])\\n            if food not in self.food_to_cuisine:\\n                self.food_to_cuisine[food] = cuisine\\n            if food not in self.food_to_rating:\\n                self.food_to_rating[food] = rating\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.food_to_cuisine[food]\\n        self.cuisine_to_ratings[cuisine].discard([-self.food_to_rating[food], food])\\n        self.food_to_rating[food] = newRating\\n        self.cuisine_to_ratings[cuisine].add([-newRating, food])\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if cuisine in self.cuisine_to_ratings:\\n            return self.cuisine_to_ratings[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498618,
                "title": "priority-queue-three-maps-c",
                "content": "```\\nclass dish{\\npublic:\\n    string food;\\n    int rating;\\n    \\n    dish(string food, int rating){\\n        this->food = food;\\n        this->rating = rating;\\n    }\\n};\\n\\nbool operator<(const dish &d1, const dish &d2){\\n    if(d1.rating == d2.rating) return d1.food > d2.food;\\n    return d1.rating < d2.rating;\\n}\\n\\nclass FoodRatings {\\nprivate:\\n    unordered_map<string, priority_queue<dish>> menuChart;\\n    unordered_map<string, int> foodRatingMap;\\n    unordered_map<string, string> foodCuisineMap;\\n    \\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        \\n        for(int i = 0; i < n; i++){\\n            string cuisine = cuisines[i];\\n            string food = foods[i];\\n            int rating = ratings[i];\\n            dish d = dish(food, rating);\\n            \\n            menuChart[cuisine].emplace(d);\\n            foodCuisineMap[food] = cuisine;\\n            foodRatingMap[food] = rating;\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        foodRatingMap[food] = newRating;\\n        string cuisine = foodCuisineMap[food];\\n        menuChart[cuisine].emplace(dish(food, newRating));\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        while(true){\\n            dish d = menuChart[cuisine].top();\\n            if(foodRatingMap[d.food] == d.rating) return d.food;\\n            else menuChart[cuisine].pop();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass dish{\\npublic:\\n    string food;\\n    int rating;\\n    \\n    dish(string food, int rating){\\n        this->food = food;\\n        this->rating = rating;\\n    }\\n};\\n\\nbool operator<(const dish &d1, const dish &d2){\\n    if(d1.rating == d2.rating) return d1.food > d2.food;\\n    return d1.rating < d2.rating;\\n}\\n\\nclass FoodRatings {\\nprivate:\\n    unordered_map<string, priority_queue<dish>> menuChart;\\n    unordered_map<string, int> foodRatingMap;\\n    unordered_map<string, string> foodCuisineMap;\\n    \\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        \\n        for(int i = 0; i < n; i++){\\n            string cuisine = cuisines[i];\\n            string food = foods[i];\\n            int rating = ratings[i];\\n            dish d = dish(food, rating);\\n            \\n            menuChart[cuisine].emplace(d);\\n            foodCuisineMap[food] = cuisine;\\n            foodRatingMap[food] = rating;\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        foodRatingMap[food] = newRating;\\n        string cuisine = foodCuisineMap[food];\\n        menuChart[cuisine].emplace(dish(food, newRating));\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        while(true){\\n            dish d = menuChart[cuisine].top();\\n            if(foodRatingMap[d.food] == d.rating) return d.food;\\n            else menuChart[cuisine].pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468117,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.size = len(foods)\\n        # foodToCuisine is a map where key will be the food item and value will be the cuisine\\n        # cuisineToFood will be a dict of minheaps were food and ratings are stored as a tuple in values with cuisine as key\\n        # ratingMap contains foods as key and their ratings as values\\n        self.foodToCuisine, self.ratingMap, self.cuisineToFood = self.initialize()\\n    \\n    #Method to initialize our 3 hashMaps\\n    def initialize(self):\\n        foodToCuisine, ratingMap = {}, {}\\n        cuisineToFood = defaultdict(list)\\n        for i in range(self.size):\\n            foodToCuisine[self.foods[i]] = self.cuisines[i]\\n            heapq.heappush(cuisineToFood[self.cuisines[i]], (-self.ratings[i], self.foods[i]))\\n            ratingMap[self.foods[i]] = self.ratings[i]\\n        return foodToCuisine, ratingMap, cuisineToFood\\n        \\n    # Due to cuisineToFood hashMap, this method becomes an easy O(log(n)) method while changing the rating is constant time because of ratingMap\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.ratingMap[food] = newRating\\n        # New rating is pushed in the heap\\n        heapq.heappush(self.cuisineToFood[self.foodToCuisine[food]], (-newRating, food))  \\n    \\n    # RatingMap contains the latest rating of the food whereas the cuisineToFood contains all the ratings.\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisineToFood[cuisine][0]\\n        #While loop to fetch the exact latest rating from all the ratings we have\\n        while -rating != self.ratingMap[food]:\\n            heapq.heappop(self.cuisineToFood[cuisine])\\n            rating,food = self.cuisineToFood[cuisine][0]\\n        return food\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.size = len(foods)\\n        # foodToCuisine is a map where key will be the food item and value will be the cuisine\\n        # cuisineToFood will be a dict of minheaps were food and ratings are stored as a tuple in values with cuisine as key\\n        # ratingMap contains foods as key and their ratings as values\\n        self.foodToCuisine, self.ratingMap, self.cuisineToFood = self.initialize()\\n    \\n    #Method to initialize our 3 hashMaps\\n    def initialize(self):\\n        foodToCuisine, ratingMap = {}, {}\\n        cuisineToFood = defaultdict(list)\\n        for i in range(self.size):\\n            foodToCuisine[self.foods[i]] = self.cuisines[i]\\n            heapq.heappush(cuisineToFood[self.cuisines[i]], (-self.ratings[i], self.foods[i]))\\n            ratingMap[self.foods[i]] = self.ratings[i]\\n        return foodToCuisine, ratingMap, cuisineToFood\\n        \\n    # Due to cuisineToFood hashMap, this method becomes an easy O(log(n)) method while changing the rating is constant time because of ratingMap\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.ratingMap[food] = newRating\\n        # New rating is pushed in the heap\\n        heapq.heappush(self.cuisineToFood[self.foodToCuisine[food]], (-newRating, food))  \\n    \\n    # RatingMap contains the latest rating of the food whereas the cuisineToFood contains all the ratings.\\n    def highestRated(self, cuisine: str) -> str:\\n        rating, food = self.cuisineToFood[cuisine][0]\\n        #While loop to fetch the exact latest rating from all the ratings we have\\n        while -rating != self.ratingMap[food]:\\n            heapq.heappop(self.cuisineToFood[cuisine])\\n            rating,food = self.cuisineToFood[cuisine][0]\\n        return food\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451220,
                "title": "two-maps-one-pair-one-treeset-java-o-nlogn",
                "content": "```\\nclass FoodRatings {\\n    // Lesson1, TreeSet && TreeMap don\\'t use hashcode() and equal() to avoid duplicates\\n    // they only use compare() method of Comparator interface OR compareTo() method of Comparable interface to avoid duplicates\\n    // For example, when we call set.remove(\"ABC\"), if set find there exist another elements that compareTo(\"ABC\") returns 0\\n    // -> set will consider these two elements are equal(duplicates)\\n    \\n    // Lesson2, there exists some food with same rating, and we need to return the item with the lexicographically smaller name\\n    // the rating in Map is Integer(which is an object), we need to use equals() instead of \"==\" to check this condition\\n    \\n    \\n    // food name - (cursine name - rating)\\n    Map<String, Pair<String, Integer>> foodMap;\\n    // cuisine - food name\\n    Map<String, TreeSet<String>> cuisinesMap;\\n    \\n    // initialization, O(n + nlogn) -> worst case O(nlogn), there is only 1 cuisine\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        // initialization for two maps\\n        for(int i = 0; i < foods.length; i++){\\n            foodMap.put(foods[i], new Pair(cuisines[i], ratings[i]));\\n            // new cuisine\\n            if(!cuisinesMap.containsKey(cuisines[i])){\\n                // a,b are food names\\n                cuisinesMap.put(cuisines[i], new TreeSet<>((a,b) -> {\\n                    Pair<String, Integer> food1 = foodMap.get(a);\\n                    Pair<String, Integer> food2 = foodMap.get(b);\\n                    // ratings are equal, compare lexicographical food name\\n                    // Integer is object class, use euqlas instead of ==\\n                    if(food1.getValue().equals(food2.getValue())) return a.compareTo(b);\\n                    else return food2.getValue() - food1.getValue();\\n                }));\\n            }\\n            cuisinesMap.get(cuisines[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    // O(logn) -> worst case, there is only 1 cuisine\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodMap.get(food).getKey();\\n        // update order in TreeSet, according to the lesson ->\\n        // we need to remove food from set first, then update rating in the foodmap\\n        // Otherwise, the compareTo() method won\\'t find the same object(returns 0) in set.remove()\\n        // thus we add duplicates to this set\\n        TreeSet<String> set = cuisinesMap.get(cuisine);\\n        // remove old data\\n        set.remove(food);\\n        \\n        // update rating\\n        foodMap.put(food, new Pair(cuisine, newRating));\\n        set.add(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n    // Lesson1, TreeSet && TreeMap don\\'t use hashcode() and equal() to avoid duplicates\\n    // they only use compare() method of Comparator interface OR compareTo() method of Comparable interface to avoid duplicates\\n    // For example, when we call set.remove(\"ABC\"), if set find there exist another elements that compareTo(\"ABC\") returns 0\\n    // -> set will consider these two elements are equal(duplicates)\\n    \\n    // Lesson2, there exists some food with same rating, and we need to return the item with the lexicographically smaller name\\n    // the rating in Map is Integer(which is an object), we need to use equals() instead of \"==\" to check this condition\\n    \\n    \\n    // food name - (cursine name - rating)\\n    Map<String, Pair<String, Integer>> foodMap;\\n    // cuisine - food name\\n    Map<String, TreeSet<String>> cuisinesMap;\\n    \\n    // initialization, O(n + nlogn) -> worst case O(nlogn), there is only 1 cuisine\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        // initialization for two maps\\n        for(int i = 0; i < foods.length; i++){\\n            foodMap.put(foods[i], new Pair(cuisines[i], ratings[i]));\\n            // new cuisine\\n            if(!cuisinesMap.containsKey(cuisines[i])){\\n                // a,b are food names\\n                cuisinesMap.put(cuisines[i], new TreeSet<>((a,b) -> {\\n                    Pair<String, Integer> food1 = foodMap.get(a);\\n                    Pair<String, Integer> food2 = foodMap.get(b);\\n                    // ratings are equal, compare lexicographical food name\\n                    // Integer is object class, use euqlas instead of ==\\n                    if(food1.getValue().equals(food2.getValue())) return a.compareTo(b);\\n                    else return food2.getValue() - food1.getValue();\\n                }));\\n            }\\n            cuisinesMap.get(cuisines[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    // O(logn) -> worst case, there is only 1 cuisine\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodMap.get(food).getKey();\\n        // update order in TreeSet, according to the lesson ->\\n        // we need to remove food from set first, then update rating in the foodmap\\n        // Otherwise, the compareTo() method won\\'t find the same object(returns 0) in set.remove()\\n        // thus we add duplicates to this set\\n        TreeSet<String> set = cuisinesMap.get(cuisine);\\n        // remove old data\\n        set.remove(food);\\n        \\n        // update rating\\n        foodMap.put(food, new Pair(cuisine, newRating));\\n        set.add(food);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363381,
                "title": "2-simple-c-solution-maps",
                "content": "**1. Using 3 Maps**\\n```\\nstruct comp{\\n    bool operator()(const pair<string,int> &a,const pair<string,int> &b)const{\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n        return a.second > b.second;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map <string,set<pair<string,int>,comp>> highestR;\\n    unordered_map <string,string> foodTocuisine;\\n    unordered_map <string,int> foodTorating;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            highestR[cuisines[i]].insert({foods[i],ratings[i]});\\n            foodTocuisine[foods[i]] = cuisines[i];\\n            foodTorating[foods[i]] = ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string tmpcui = foodTocuisine[food]; \\n        highestR[tmpcui].erase({food,foodTorating[food]});\\n        highestR[tmpcui].insert({food,newRating});\\n        foodTorating[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return highestR[cuisine].begin()->first;\\n    }\\n};\\n```\\n\\n**2. Using 2 Maps**\\n```\\nstruct comp{\\n    bool operator()(const pair<string,int> &a,const pair<string,int> &b)const{\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n        return a.second > b.second;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map <string,set<pair<string,int>,comp>> highestR;\\n    unordered_map <string,pair<string,int>> foodTocuisineRating;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            highestR[cuisines[i]].insert({foods[i],ratings[i]});\\n            foodTocuisineRating[foods[i]] = {cuisines[i],ratings[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto tmp = foodTocuisineRating[food]; \\n        highestR[tmp.first].erase({food,tmp.second});\\n        highestR[tmp.first].insert({food,newRating});\\n        foodTocuisineRating[food] = {tmp.first,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return highestR[cuisine].begin()->first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nstruct comp{\\n    bool operator()(const pair<string,int> &a,const pair<string,int> &b)const{\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n        return a.second > b.second;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map <string,set<pair<string,int>,comp>> highestR;\\n    unordered_map <string,string> foodTocuisine;\\n    unordered_map <string,int> foodTorating;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            highestR[cuisines[i]].insert({foods[i],ratings[i]});\\n            foodTocuisine[foods[i]] = cuisines[i];\\n            foodTorating[foods[i]] = ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string tmpcui = foodTocuisine[food]; \\n        highestR[tmpcui].erase({food,foodTorating[food]});\\n        highestR[tmpcui].insert({food,newRating});\\n        foodTorating[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return highestR[cuisine].begin()->first;\\n    }\\n};\\n```\n```\\nstruct comp{\\n    bool operator()(const pair<string,int> &a,const pair<string,int> &b)const{\\n        if(a.second == b.second)\\n            return a.first < b.first;\\n        return a.second > b.second;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map <string,set<pair<string,int>,comp>> highestR;\\n    unordered_map <string,pair<string,int>> foodTocuisineRating;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            highestR[cuisines[i]].insert({foods[i],ratings[i]});\\n            foodTocuisineRating[foods[i]] = {cuisines[i],ratings[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto tmp = foodTocuisineRating[food]; \\n        highestR[tmp.first].erase({food,tmp.second});\\n        highestR[tmp.first].insert({food,newRating});\\n        foodTocuisineRating[food] = {tmp.first,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return highestR[cuisine].begin()->first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362151,
                "title": "python-maps-and-heaps",
                "content": "```python\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        cmap, nmap, tmap = defaultdict(list), {}, {}\\n        for i in range(len(cuisines)):\\n            heappush(cmap[cuisines[i]], (-ratings[i], foods[i]))\\n            nmap[foods[i]], tmap[foods[i]] = ratings[i], cuisines[i]\\n        self.cmap, self.nmap, self.tmap = cmap, nmap, tmap\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        heappush(self.cmap[self.tmap[food]], (-newRating, food))\\n        self.nmap[food] = newRating\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.nmap[self.cmap[cuisine][0][1]] != -self.cmap[cuisine][0][0]:\\n            heappop(self.cmap[cuisine])\\n        return self.cmap[cuisine][0][1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        cmap, nmap, tmap = defaultdict(list), {}, {}\\n        for i in range(len(cuisines)):\\n            heappush(cmap[cuisines[i]], (-ratings[i], foods[i]))\\n            nmap[foods[i]], tmap[foods[i]] = ratings[i], cuisines[i]\\n        self.cmap, self.nmap, self.tmap = cmap, nmap, tmap\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        heappush(self.cmap[self.tmap[food]], (-newRating, food))\\n        self.nmap[food] = newRating\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.nmap[self.cmap[cuisine][0][1]] != -self.cmap[cuisine][0][0]:\\n            heappop(self.cmap[cuisine])\\n        return self.cmap[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358332,
                "title": "c-3-maps-set-custom-cmp",
                "content": "```\\n struct cmp{\\n      bool operator()(const pair<int,string>&a, const pair<int,string>&b)const{\\n          if(a.first==b.first){\\n              return a.second<b.second;\\n          }else{\\n              return a.first>b.first;\\n          }\\n      }  \\n    };\\n    unordered_map<string,set<pair<int,string>,cmp>>CTF;\\n    unordered_map<string,string>FTC;\\n    unordered_map<string,int>FTR;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            FTR[foods[i]]=ratings[i];\\n            FTC[foods[i]]=cuisines[i];\\n            CTF[cuisines[i]].insert({ratings[i],foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cui=FTC[food];\\n        int r=FTR[food];\\n        CTF[cui].erase({r,food});\\n        CTF[cui].insert({newRating,food});\\n        FTR[food]=newRating;\\n          \\n    }\\n    \\n    string highestRated(string cuisine) {\\n        for(auto it:CTF[cuisine]){\\n            return it.second;\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n struct cmp{\\n      bool operator()(const pair<int,string>&a, const pair<int,string>&b)const{\\n          if(a.first==b.first){\\n              return a.second<b.second;\\n          }else{\\n              return a.first>b.first;\\n          }\\n      }  \\n    };\\n    unordered_map<string,set<pair<int,string>,cmp>>CTF;\\n    unordered_map<string,string>FTC;\\n    unordered_map<string,int>FTR;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            FTR[foods[i]]=ratings[i];\\n            FTC[foods[i]]=cuisines[i];\\n            CTF[cuisines[i]].insert({ratings[i],foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cui=FTC[food];\\n        int r=FTR[food];\\n        CTF[cui].erase({r,food});\\n        CTF[cui].insert({newRating,food});\\n        FTR[food]=newRating;\\n          \\n    }\\n    \\n    string highestRated(string cuisine) {\\n        for(auto it:CTF[cuisine]){\\n            return it.second;\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345127,
                "title": "java-3-maps-solution",
                "content": "```\\nclass FoodRatings {\\n    \\n    private class Food {\\n        private String food;\\n        private String cuisine;\\n        private int rating;\\n        \\n        Food(String food, String cuisine, int rating) {\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    \\n    private final Map<String, TreeSet<Food>> cuisineFood;\\n    private final Map<String, Food> foodRating;\\n    private final Map<String, String> foodCuisine;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        final int n = foods.length;\\n        cuisineFood = new HashMap<>();\\n        foodRating = new HashMap<>();\\n        foodCuisine = new HashMap<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            final String food = foods[i];\\n            final String cuisine = cuisines[i];\\n            final int rating = ratings[i];\\n            \\n            final Food f = new Food(food, cuisine, rating);\\n            final TreeSet<Food> set = cuisineFood.computeIfAbsent(cuisine, c -> new TreeSet<>((f1, f2) -> {\\n                int diff = f2.rating - f1.rating;\\n                if (diff != 0) return diff;\\n                return f1.food.compareTo(f2.food);\\n            }));\\n            set.add(f);\\n            foodRating.put(food, f);\\n            foodCuisine.put(food, cuisine);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food f = foodRating.get(food);\\n        String cuisine = foodCuisine.get(food);\\n        TreeSet<Food> set = cuisineFood.get(cuisine);\\n        \\n        set.remove(f);\\n        f.rating = newRating;\\n        set.add(f);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineFood.get(cuisine).first().food;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\n    \\n    private class Food {\\n        private String food;\\n        private String cuisine;\\n        private int rating;\\n        \\n        Food(String food, String cuisine, int rating) {\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    \\n    private final Map<String, TreeSet<Food>> cuisineFood;\\n    private final Map<String, Food> foodRating;\\n    private final Map<String, String> foodCuisine;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        final int n = foods.length;\\n        cuisineFood = new HashMap<>();\\n        foodRating = new HashMap<>();\\n        foodCuisine = new HashMap<>();\\n        \\n        for (int i=0; i<n; i++) {\\n            final String food = foods[i];\\n            final String cuisine = cuisines[i];\\n            final int rating = ratings[i];\\n            \\n            final Food f = new Food(food, cuisine, rating);\\n            final TreeSet<Food> set = cuisineFood.computeIfAbsent(cuisine, c -> new TreeSet<>((f1, f2) -> {\\n                int diff = f2.rating - f1.rating;\\n                if (diff != 0) return diff;\\n                return f1.food.compareTo(f2.food);\\n            }));\\n            set.add(f);\\n            foodRating.put(food, f);\\n            foodCuisine.put(food, cuisine);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food f = foodRating.get(food);\\n        String cuisine = foodCuisine.get(food);\\n        TreeSet<Food> set = cuisineFood.get(cuisine);\\n        \\n        set.remove(f);\\n        f.rating = newRating;\\n        set.add(f);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineFood.get(cuisine).first().food;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2341407,
                "title": "python-heap-easy-code",
                "content": "```\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_cuisine = defaultdict(str)\\n        self.food_rating = defaultdict(int)\\n        for i, f in enumerate(foods):\\n            self.food_cuisine[f] = cuisines[i]\\n            self.food_rating[f] = ratings[i]\\n        self.cuisines_heap = defaultdict(list)\\n        for i, c in enumerate(cuisines):\\n            heappush(self.cuisines_heap[c], (-ratings[i],foods[i]))\\n            \\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_rating[food] = newRating\\n        heappush(self.cuisines_heap[self.food_cuisine[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.cuisines_heap[cuisine] and self.food_rating[self.cuisines_heap[cuisine][0][1]] != -self.cuisines_heap[cuisine][0][0]:\\n            heappop(self.cuisines_heap[cuisine])\\n        return self.cuisines_heap[cuisine][0][1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom heapq import heappush, heappop\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_cuisine = defaultdict(str)\\n        self.food_rating = defaultdict(int)\\n        for i, f in enumerate(foods):\\n            self.food_cuisine[f] = cuisines[i]\\n            self.food_rating[f] = ratings[i]\\n        self.cuisines_heap = defaultdict(list)\\n        for i, c in enumerate(cuisines):\\n            heappush(self.cuisines_heap[c], (-ratings[i],foods[i]))\\n            \\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_rating[food] = newRating\\n        heappush(self.cuisines_heap[self.food_cuisine[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.cuisines_heap[cuisine] and self.food_rating[self.cuisines_heap[cuisine][0][1]] != -self.cuisines_heap[cuisine][0][0]:\\n            heappop(self.cuisines_heap[cuisine])\\n        return self.cuisines_heap[cuisine][0][1]",
                "codeTag": "Java"
            },
            {
                "id": 2340226,
                "title": "using-sortedset",
                "content": "![image](https://assets.leetcode.com/users/images/fec04c07-4b8f-49d2-a48d-d04500970084_1658911623.1543102.png)\\n```\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedSet\\n\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str],\\n                 ratings: List[int]):\\n        self.f_dict = dict()\\n        self.c_dict = defaultdict(SortedSet)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.f_dict[f] = [-r, c]\\n            self.c_dict[c].add((-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        current_rating, current_cuisine = self.f_dict[food]\\n        self.f_dict[food][0] = -newRating\\n        self.c_dict[current_cuisine].remove((current_rating, food))\\n        self.c_dict[current_cuisine].add((-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.c_dict[cuisine][0][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedSet\\n\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str],\\n                 ratings: List[int]):\\n        self.f_dict = dict()\\n        self.c_dict = defaultdict(SortedSet)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.f_dict[f] = [-r, c]\\n            self.c_dict[c].add((-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        current_rating, current_cuisine = self.f_dict[food]\\n        self.f_dict[food][0] = -newRating\\n        self.c_dict[current_cuisine].remove((current_rating, food))\\n        self.c_dict[current_cuisine].add((-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.c_dict[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337961,
                "title": "python-simple-hashmap",
                "content": "\\n\\tfrom sortedcontainers import SortedList\\n\\n\\n    def __init__(self, foods, cuisines, ratings):\\n        self.dict1 = defaultdict(SortedList)\\n        self.dict2 = defaultdict(int)\\n        self.dict3 = defaultdict(int)\\n        \\n        for i in range(len(cuisines)):\\n            self.dict1[cuisines[i]].add((-ratings[i], foods[i]))\\n            self.dict2[foods[i]] = ratings[i]\\n            self.dict3[foods[i]] = cuisines[i]\\n            \\n    def changeRating(self, food, newRating):\\n        oldRating = self.dict2[food]\\n        cuisine = self.dict3[food]\\n        \\n        self.dict1[cuisine].discard((-oldRating, food))\\n        self.dict1[cuisine].add((-newRating, food))\\n        self.dict2[food] = newRating\\n        \\n    def highestRated(self, cuisine):\\n        return self.dict1[cuisine][0][1]",
                "solutionTags": [],
                "code": "\\n\\tfrom sortedcontainers import SortedList\\n\\n\\n    def __init__(self, foods, cuisines, ratings):\\n        self.dict1 = defaultdict(SortedList)\\n        self.dict2 = defaultdict(int)\\n        self.dict3 = defaultdict(int)\\n        \\n        for i in range(len(cuisines)):\\n            self.dict1[cuisines[i]].add((-ratings[i], foods[i]))\\n            self.dict2[foods[i]] = ratings[i]\\n            self.dict3[foods[i]] = cuisines[i]\\n            \\n    def changeRating(self, food, newRating):\\n        oldRating = self.dict2[food]\\n        cuisine = self.dict3[food]\\n        \\n        self.dict1[cuisine].discard((-oldRating, food))\\n        self.dict1[cuisine].add((-newRating, food))\\n        self.dict2[food] = newRating\\n        \\n    def highestRated(self, cuisine):\\n        return self.dict1[cuisine][0][1]",
                "codeTag": "Python3"
            },
            {
                "id": 2330091,
                "title": "c-solution-hashmap-explained",
                "content": "**Method:**\\n\\n* we will use 3 maps\\n* ```one map to store the {rating,food} pair for a particular cuisine = mp```\\n* ```one map to get the rating of a particular food = cs```\\n* ```one map to get the cuisine of a particular food = rt```\\n* as in the highest rated function we will want the highest rated food of that cuisine so we will use ordered_set so that ```{rating,food}``` pair will get stored in sorted order \\n* now the ordered_set stores it in increasing order of the rating so we will store ```{-rating,food}``` pair so that in the sorted order(increasing) we will get the pair with highest rating at first place\\n* ```For the changeRating operation```\\n\\t* we first get the cuisine and current rating for the food.\\n\\t* Then, we remove the old food rating from cuisine_ratings, and add the new one.\\n\\n**Code:**\\n\\n```\\nclass FoodRatings\\n{\\npublic:\\n    typedef pair<int, string> pi;\\n    unordered_map<string, set<pi>> mp;\\n    unordered_map<string, string> cs;\\n    unordered_map<string, int> rt;\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[cuisines[i]].insert({-ratings[i], foods[i]});\\n            cs[foods[i]] = cuisines[i];\\n            rt[foods[i]] = -ratings[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        string c = cs[food];\\n        int r = rt[food];\\n        mp[c].erase({r, food});\\n        mp[c].insert({-newRating, food});\\n        rt[food] = -newRating;\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        auto p = begin(mp[cuisine]);\\n        return p->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```one map to store the {rating,food} pair for a particular cuisine = mp```\n```one map to get the rating of a particular food = cs```\n```one map to get the cuisine of a particular food = rt```\n```{rating,food}```\n```{-rating,food}```\n```For the changeRating operation```\n```\\nclass FoodRatings\\n{\\npublic:\\n    typedef pair<int, string> pi;\\n    unordered_map<string, set<pi>> mp;\\n    unordered_map<string, string> cs;\\n    unordered_map<string, int> rt;\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[cuisines[i]].insert({-ratings[i], foods[i]});\\n            cs[foods[i]] = cuisines[i];\\n            rt[foods[i]] = -ratings[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        string c = cs[food];\\n        int r = rt[food];\\n        mp[c].erase({r, food});\\n        mp[c].insert({-newRating, food});\\n        rt[food] = -newRating;\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        auto p = begin(mp[cuisine]);\\n        return p->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329980,
                "title": "clean-solution-with-hash-map-and-tree-set",
                "content": "Similar question:\\nhttps://leetcode.com/problems/design-a-number-container-system/discuss/2326616/concise-solution-with-tree-set-and-explanation\\n```\\nclass FoodRatings {\\n\\n    Map<String, TreeSet<Food>> cuisineMap = new HashMap<String, TreeSet<Food>>();\\n    Map<String, Food> foodMap = new HashMap<String, Food>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n = foods.length;\\n        for(int i=0; i<n; i++) {\\n            String name = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            Food item = new Food(name, cuisine, rating);\\n            cuisineMap.putIfAbsent(cuisine, new TreeSet<Food> \\n                ((a,b) -> a.rating == b.rating ? a.name.compareTo(b.name) : b.rating - a.rating)\\n            );\\n            cuisineMap.get(cuisine).add(item);\\n            foodMap.put(name, item);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food item = foodMap.get(food);\\n        String cuisine = item.cuisine;\\n        cuisineMap.get(cuisine).remove(item);\\n        \\n        item.rating = newRating;\\n        foodMap.put(food, item);\\n        cuisineMap.get(cuisine).add(item);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).first().name;\\n    }\\n}\\n\\nclass Food {\\n    String name;\\n    String cuisine;\\n    int rating;\\n    \\n    Food(String name, String cuisine, int rating){\\n        this.name = name; this.rating = rating; this.cuisine = cuisine;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    Map<String, TreeSet<Food>> cuisineMap = new HashMap<String, TreeSet<Food>>();\\n    Map<String, Food> foodMap = new HashMap<String, Food>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n = foods.length;\\n        for(int i=0; i<n; i++) {\\n            String name = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            Food item = new Food(name, cuisine, rating);\\n            cuisineMap.putIfAbsent(cuisine, new TreeSet<Food> \\n                ((a,b) -> a.rating == b.rating ? a.name.compareTo(b.name) : b.rating - a.rating)\\n            );\\n            cuisineMap.get(cuisine).add(item);\\n            foodMap.put(name, item);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food item = foodMap.get(food);\\n        String cuisine = item.cuisine;\\n        cuisineMap.get(cuisine).remove(item);\\n        \\n        item.rating = newRating;\\n        foodMap.put(food, item);\\n        cuisineMap.get(cuisine).add(item);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).first().name;\\n    }\\n}\\n\\nclass Food {\\n    String name;\\n    String cuisine;\\n    int rating;\\n    \\n    Food(String name, String cuisine, int rating){\\n        this.name = name; this.rating = rating; this.cuisine = cuisine;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328993,
                "title": "java-solution-using-two-hashmaps-and-priorityqueue",
                "content": "```java\\nclass FoodRatings {\\n    Map<String, PriorityQueue<FoodCuisineRating>> cuisineMap;\\n    Map<String, FoodCuisineRating> foodMap;\\n    int n;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineMap = new HashMap<>();\\n        foodMap = new HashMap<>();\\n        n = foods.length;\\n        for(int i = 0; i < n; i++) {\\n            FoodCuisineRating fcr = new FoodCuisineRating(foods[i], cuisines[i], ratings[i]);\\n            cuisineMap.putIfAbsent(cuisines[i], new PriorityQueue<>((a, b) -> a.rating == b.rating ? a.food.compareTo(b.food) : b.rating - a.rating));\\n            PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(cuisines[i]);\\n            maxHeap.offer(fcr);\\n            foodMap.put(foods[i], fcr);\\n        }\\n    }\\n    public void changeRating(String food, int newRating) {\\n        FoodCuisineRating fcr = foodMap.get(food);\\n        PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(fcr.cuisine);\\n        maxHeap.remove(fcr);\\n        fcr.rating = newRating;\\n        maxHeap.offer(fcr);\\n    }\\n    public String highestRated(String cuisine) {\\n        PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(cuisine);\\n        FoodCuisineRating fcr = maxHeap.peek();\\n        String highestRatedFood = fcr.food;\\n        return highestRatedFood;\\n    }\\n    class FoodCuisineRating {\\n        String food;\\n        String cuisine;\\n        int rating;\\n        public FoodCuisineRating(String food, String cuisine, int rating) {\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n/*\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass FoodRatings {\\n    Map<String, PriorityQueue<FoodCuisineRating>> cuisineMap;\\n    Map<String, FoodCuisineRating> foodMap;\\n    int n;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineMap = new HashMap<>();\\n        foodMap = new HashMap<>();\\n        n = foods.length;\\n        for(int i = 0; i < n; i++) {\\n            FoodCuisineRating fcr = new FoodCuisineRating(foods[i], cuisines[i], ratings[i]);\\n            cuisineMap.putIfAbsent(cuisines[i], new PriorityQueue<>((a, b) -> a.rating == b.rating ? a.food.compareTo(b.food) : b.rating - a.rating));\\n            PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(cuisines[i]);\\n            maxHeap.offer(fcr);\\n            foodMap.put(foods[i], fcr);\\n        }\\n    }\\n    public void changeRating(String food, int newRating) {\\n        FoodCuisineRating fcr = foodMap.get(food);\\n        PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(fcr.cuisine);\\n        maxHeap.remove(fcr);\\n        fcr.rating = newRating;\\n        maxHeap.offer(fcr);\\n    }\\n    public String highestRated(String cuisine) {\\n        PriorityQueue<FoodCuisineRating> maxHeap = cuisineMap.get(cuisine);\\n        FoodCuisineRating fcr = maxHeap.peek();\\n        String highestRatedFood = fcr.food;\\n        return highestRatedFood;\\n    }\\n    class FoodCuisineRating {\\n        String food;\\n        String cuisine;\\n        int rating;\\n        public FoodCuisineRating(String food, String cuisine, int rating) {\\n            this.food = food;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n/*\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2327644,
                "title": "c-easy-solution-3-maps",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nstruct node {\\n    bool operator()(const pair<int, string> &a, const pair<int, string> &b) const { \\n        if(a.first==b.first) return a.second>b.second;\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\nprivate:\\n    map<string, string> cui;\\n    map<string, set<pair<int, string>, node>> mp;\\n    map<string, int> rate;\\n    \\npublic:\\n\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0; i<n; i++){\\n            rate[foods[i]]=ratings[i];\\n            mp[cuisines[i]].insert({ratings[i], foods[i]});\\n            cui[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        mp[cui[food]].erase({rate[food], food});\\n        mp[cui[food]].insert({newRating, food});\\n        rate[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--mp[cuisine].end()).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstruct node {\\n    bool operator()(const pair<int, string> &a, const pair<int, string> &b) const { \\n        if(a.first==b.first) return a.second>b.second;\\n        return a.first<b.first;\\n    }\\n};\\n\\nclass FoodRatings {\\nprivate:\\n    map<string, string> cui;\\n    map<string, set<pair<int, string>, node>> mp;\\n    map<string, int> rate;\\n    \\npublic:\\n\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0; i<n; i++){\\n            rate[foods[i]]=ratings[i];\\n            mp[cuisines[i]].insert({ratings[i], foods[i]});\\n            cui[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        mp[cui[food]].erase({rate[food], food});\\n        mp[cui[food]].insert({newRating, food});\\n        rate[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--mp[cuisine].end()).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326993,
                "title": "c-fully-explained-commented-set-2-map-good-application-of-map-data-structure",
                "content": "```\\n  map< string  , map< int , set< string> , greater<int> >> mp;\\n  \\n  // this above map has cuisine as key , then its inside there is another \\n  \\n  // map which stores rating as key & Stores Different foods for a particular rating in set \\n  \\n  // in lexographically order , smaller first\\n    \\n    unordered_map< string , pair< int , string> > mp1;\\n\\t\\n\\t// This map stores food as key & in the pair , it has rating & cuisine .\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            mp1[foods[i]]={r[i] , c[i]};\\n        }\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            mp[c[i]][r[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n\\t\\n\\t// For change of the  rating for a given food\\n\\t\\n\\t// Find the cuisine of that food & old rating in map mp1\\n\\t\\n\\t// Now we have to update the new rating , what we will do \\n\\t\\n\\t// for a old rating we will find the iterator in the map<int , set<string > , greater<int>> \\n\\t\\n\\t// embedded in the map , to check that food is present in the given old rating map inside it \\n\\t\\n\\t// if present remove that food from there , if there is no food for that rating , erase that old rating\\n\\t\\n\\t// Now insert the new rating with that food \\n\\t\\n\\t// Also update new rating with food in the map mp1 , as rating is changed for food\\n\\t\\n\\t\\n\\t\\n\\t\\n    \\n    void changeRating(string food, int rating) {\\n        // rating change \\n        \\n        string cu=mp1[food].second;\\n        \\n        int curr_rating=mp1[food].first;\\n        \\n         auto it=mp[cu][curr_rating].find(food);\\n        \\n         mp[cu][curr_rating].erase(it);\\n        \\n         if(mp[cu][curr_rating].size()==0)\\n         {\\n             mp[cu].erase(curr_rating);\\n         }\\n         \\n         mp[cu][rating].insert(food);\\n         \\n        mp1[food]={rating , cu};\\n        \\n    }\\n\\t\\n\\t// Highest rating will be that element which will be first in the \\n    \\n\\t// set of rating map of cuisine map -> named mp\\n\\t\\n    string highestRated(string cu) {\\n        if(mp.find(cu)!=mp.end())\\n        {\\n           auto it= mp[cu].begin();\\n            \\n            string ans=*it->second.begin();\\n            \\n            return ans;\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n  map< string  , map< int , set< string> , greater<int> >> mp;\\n  \\n  // this above map has cuisine as key , then its inside there is another \\n  \\n  // map which stores rating as key & Stores Different foods for a particular rating in set \\n  \\n  // in lexographically order , smaller first\\n    \\n    unordered_map< string , pair< int , string> > mp1;\\n\\t\\n\\t// This map stores food as key & in the pair , it has rating & cuisine .\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            mp1[foods[i]]={r[i] , c[i]};\\n        }\\n        \\n        for(int i=0;i<c.size();i++)\\n        {\\n            mp[c[i]][r[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n\\t\\n\\t// For change of the  rating for a given food\\n\\t\\n\\t// Find the cuisine of that food & old rating in map mp1\\n\\t\\n\\t// Now we have to update the new rating , what we will do \\n\\t\\n\\t// for a old rating we will find the iterator in the map<int , set<string > , greater<int>> \\n\\t\\n\\t// embedded in the map , to check that food is present in the given old rating map inside it \\n\\t\\n\\t// if present remove that food from there , if there is no food for that rating , erase that old rating\\n\\t\\n\\t// Now insert the new rating with that food \\n\\t\\n\\t// Also update new rating with food in the map mp1 , as rating is changed for food\\n\\t\\n\\t\\n\\t\\n\\t\\n    \\n    void changeRating(string food, int rating) {\\n        // rating change \\n        \\n        string cu=mp1[food].second;\\n        \\n        int curr_rating=mp1[food].first;\\n        \\n         auto it=mp[cu][curr_rating].find(food);\\n        \\n         mp[cu][curr_rating].erase(it);\\n        \\n         if(mp[cu][curr_rating].size()==0)\\n         {\\n             mp[cu].erase(curr_rating);\\n         }\\n         \\n         mp[cu][rating].insert(food);\\n         \\n        mp1[food]={rating , cu};\\n        \\n    }\\n\\t\\n\\t// Highest rating will be that element which will be first in the \\n    \\n\\t// set of rating map of cuisine map -> named mp\\n\\t\\n    string highestRated(string cu) {\\n        if(mp.find(cu)!=mp.end())\\n        {\\n           auto it= mp[cu].begin();\\n            \\n            string ans=*it->second.begin();\\n            \\n            return ans;\\n        }\\n        \\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326329,
                "title": "easy-c-2-maps-only-using-custom-comparator-of-set-new-for-begineers",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    \\n    struct compare\\n    {\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b) const\\n        { \\n          if(a.first == b.first)\\n             return a.second < b.second;\\n          else return a.first > b.first;\\n        }\\n    };\\n    \\n    int n;\\n    unordered_map<string, pair<string,int>>fc; // Distinct food, {cuisine, rating}       \\n    unordered_map<string, set<pair<int,string>, compare>>crf; // cuisine--->list{rating, food}\\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) \\n    {\\n        n=f.size();\\n        for(int i=0;i<n;i++){\\n            fc[f[i]] = {c[i],r[i]};\\n            crf[c[i]].insert({r[i], f[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        \\n        string cuisine = fc[food].first;\\n        int oldRating = fc[food].second;\\n        \\n        crf[cuisine].erase({oldRating, food});\\n        crf[cuisine].insert({newRating,food});\\n        fc[food] = {cuisine, newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        pair<int, string> p = *(crf[cuisine].begin());\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    \\n    struct compare\\n    {\\n        bool operator()(const pair<int, string>& a, const pair<int, string>& b) const\\n        { \\n          if(a.first == b.first)\\n             return a.second < b.second;\\n          else return a.first > b.first;\\n        }\\n    };\\n    \\n    int n;\\n    unordered_map<string, pair<string,int>>fc; // Distinct food, {cuisine, rating}       \\n    unordered_map<string, set<pair<int,string>, compare>>crf; // cuisine--->list{rating, food}\\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) \\n    {\\n        n=f.size();\\n        for(int i=0;i<n;i++){\\n            fc[f[i]] = {c[i],r[i]};\\n            crf[c[i]].insert({r[i], f[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        \\n        string cuisine = fc[food].first;\\n        int oldRating = fc[food].second;\\n        \\n        crf[cuisine].erase({oldRating, food});\\n        crf[cuisine].insert({newRating,food});\\n        fc[food] = {cuisine, newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        pair<int, string> p = *(crf[cuisine].begin());\\n        return p.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326281,
                "title": "two-maps-and-priority-queue-nlogn-tc",
                "content": "```\\nclass restu{\\n    String f,c;\\n    int r;\\n    public restu(String fo,String cu,int ra){\\n        f=fo;\\n        c=cu;\\n        r=ra;\\n    }\\n}\\n\\nclass The_Comparator implements Comparator<restu> {\\n    public int compare(restu ob1, restu ob2)  {\\n        return ob2.r==ob1.r?ob1.f.compareTo(ob2.f):ob2.r-ob1.r;\\n    }\\n}\\n\\nclass FoodRatings {\\n    HashMap<String,restu> map;\\n    HashMap<String,PriorityQueue<restu>> maq;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<String,restu>();\\n        maq = new HashMap<String,PriorityQueue<restu>>();\\n        int len=foods.length,i;\\n        for(i=0;i<len;i++){\\n            restu ob = new restu(foods[i],cuisines[i],ratings[i]);\\n            map.put(foods[i],ob);\\n            PriorityQueue<restu> q = maq.getOrDefault(cuisines[i],new PriorityQueue<restu>(new The_Comparator()));\\n            q.add(ob);\\n            maq.put(cuisines[i],q);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        restu ob = map.get(food);\\n        PriorityQueue<restu> pq = maq.get(ob.c);\\n        pq.remove(ob);\\n        ob.r=newRating;\\n        pq.add(ob);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return maq.get(cuisine).peek().f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass restu{\\n    String f,c;\\n    int r;\\n    public restu(String fo,String cu,int ra){\\n        f=fo;\\n        c=cu;\\n        r=ra;\\n    }\\n}\\n\\nclass The_Comparator implements Comparator<restu> {\\n    public int compare(restu ob1, restu ob2)  {\\n        return ob2.r==ob1.r?ob1.f.compareTo(ob2.f):ob2.r-ob1.r;\\n    }\\n}\\n\\nclass FoodRatings {\\n    HashMap<String,restu> map;\\n    HashMap<String,PriorityQueue<restu>> maq;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<String,restu>();\\n        maq = new HashMap<String,PriorityQueue<restu>>();\\n        int len=foods.length,i;\\n        for(i=0;i<len;i++){\\n            restu ob = new restu(foods[i],cuisines[i],ratings[i]);\\n            map.put(foods[i],ob);\\n            PriorityQueue<restu> q = maq.getOrDefault(cuisines[i],new PriorityQueue<restu>(new The_Comparator()));\\n            q.add(ob);\\n            maq.put(cuisines[i],q);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        restu ob = map.get(food);\\n        PriorityQueue<restu> pq = maq.get(ob.c);\\n        pq.remove(ob);\\n        ob.r=newRating;\\n        pq.add(ob);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return maq.get(cuisine).peek().f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326073,
                "title": "no-tle-with-priorityqueue-in-java",
                "content": "```\\nclass FoodRatings {\\n\\n    Map<String, PriorityQueue<Object[]>> map = new HashMap<>(); // two size array in pq, index 0 is rating, index 1 is name\\n    Map<String, Integer> foodRating = new HashMap<>(); // put latest rating here\\n    Map<String, String> foodCuisine = new HashMap<>(); // food cuisine map\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for (int i = 0; i < foods.length; i++) {\\n            foodCuisine.put(foods[i], cuisines[i]);\\n            \\n            map.putIfAbsent(cuisines[i], new PriorityQueue<>((a, b) -> {\\n                if (((int)a[1]) != (int)b[1]) {\\n                    return (int)b[1] - (int)a[1]; \\n                }\\n                \\n                return ((String)a[0]).compareTo((String)b[0]);\\n            }));\\n            \\n            PriorityQueue<Object[]> pq = map.get(cuisines[i]);\\n            pq.offer(new Object[] {foods[i], ratings[i]});\\n            \\n            map.put(cuisines[i], pq);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodCuisine.get(food);\\n        foodRating.put(food, newRating);\\n       \\n        PriorityQueue<Object[]> pq = map.get(cuisine);\\n\\t\\t// put the latest rating to pq\\n        pq.offer(new Object[] {food, newRating});\\n\\n        map.put(cuisine, pq);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Object[]> pq = map.get(cuisine);\\n        \\n        String result = null;\\n        \\n        while (!pq.isEmpty()) {\\n\\t\\t\\t// get the top result\\n            Object[] top = pq.peek();\\n            String food = (String)top[0];\\n            int rating = (int)top[1];\\n            \\n            result = food;\\n            \\n\\t\\t\\t// check if we have updated the rating of the food, if the rating is the latest one\\n            if (!foodRating.containsKey(food) || foodRating.get(food) == rating) {\\n                break;\\n            } \\n            pq.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    Map<String, PriorityQueue<Object[]>> map = new HashMap<>(); // two size array in pq, index 0 is rating, index 1 is name\\n    Map<String, Integer> foodRating = new HashMap<>(); // put latest rating here\\n    Map<String, String> foodCuisine = new HashMap<>(); // food cuisine map\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for (int i = 0; i < foods.length; i++) {\\n            foodCuisine.put(foods[i], cuisines[i]);\\n            \\n            map.putIfAbsent(cuisines[i], new PriorityQueue<>((a, b) -> {\\n                if (((int)a[1]) != (int)b[1]) {\\n                    return (int)b[1] - (int)a[1]; \\n                }\\n                \\n                return ((String)a[0]).compareTo((String)b[0]);\\n            }));\\n            \\n            PriorityQueue<Object[]> pq = map.get(cuisines[i]);\\n            pq.offer(new Object[] {foods[i], ratings[i]});\\n            \\n            map.put(cuisines[i], pq);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodCuisine.get(food);\\n        foodRating.put(food, newRating);\\n       \\n        PriorityQueue<Object[]> pq = map.get(cuisine);\\n\\t\\t// put the latest rating to pq\\n        pq.offer(new Object[] {food, newRating});\\n\\n        map.put(cuisine, pq);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Object[]> pq = map.get(cuisine);\\n        \\n        String result = null;\\n        \\n        while (!pq.isEmpty()) {\\n\\t\\t\\t// get the top result\\n            Object[] top = pq.peek();\\n            String food = (String)top[0];\\n            int rating = (int)top[1];\\n            \\n            result = food;\\n            \\n\\t\\t\\t// check if we have updated the rating of the food, if the rating is the latest one\\n            if (!foodRating.containsKey(food) || foodRating.get(food) == rating) {\\n                break;\\n            } \\n            pq.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326015,
                "title": "three-unordered-map-easy-solution",
                "content": "class FoodRatings {\\npublic:\\n    \\n    unordered_map<string,set<pair<int,string>>>mp;\\n    unordered_map<string,string> fc;\\n    unordered_map<string,int> fr;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        \\n        mp.clear();\\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].insert({ratings[i],foods[i]});\\n            \\n            fc[foods[i]]= cuisines[i];\\n            fr[foods[i]]= ratings[i];\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        \\n        if(fc.find(food)!=fc.end()){\\n            string cuisine = fc[food];\\n            int rating = fr[food];\\n            if(mp[cuisine].find({rating,food})!=mp[cuisine].end())\\n            mp[cuisine].erase({rating,food});\\n            fr[food] = newRating;\\n         mp[cuisine].insert({newRating,food});\\n        }\\n        \\n         \\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        if(mp[cuisine].size()==0){\\n            return \"\";\\n        }\\n        \\n        auto it =(mp[cuisine].end());\\n        it--;\\n        pair<int,string> temp = *it;\\n        \\n       // cout<< temp.second<<endl;\\n        string ans= temp.second;\\n        \\n        while(it!=mp[cuisine].begin() && it->first == temp.first){\\n          // cout<<it->first<<endl;\\n            ans = it->second;\\n          it--;\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */",
                "solutionTags": [
                    "C"
                ],
                "code": "class FoodRatings {\\npublic:\\n    \\n    unordered_map<string,set<pair<int,string>>>mp;\\n    unordered_map<string,string> fc;\\n    unordered_map<string,int> fr;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        \\n        mp.clear();\\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].insert({ratings[i],foods[i]});\\n            \\n            fc[foods[i]]= cuisines[i];\\n            fr[foods[i]]= ratings[i];\\n        }\\n        \\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        \\n        if(fc.find(food)!=fc.end()){\\n            string cuisine = fc[food];\\n            int rating = fr[food];\\n            if(mp[cuisine].find({rating,food})!=mp[cuisine].end())\\n            mp[cuisine].erase({rating,food});\\n            fr[food] = newRating;\\n         mp[cuisine].insert({newRating,food});\\n        }\\n        \\n         \\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        if(mp[cuisine].size()==0){\\n            return \"\";\\n        }\\n        \\n        auto it =(mp[cuisine].end());\\n        it--;\\n        pair<int,string> temp = *it;\\n        \\n       // cout<< temp.second<<endl;\\n        string ans= temp.second;\\n        \\n        while(it!=mp[cuisine].begin() && it->first == temp.first){\\n          // cout<<it->first<<endl;\\n            ans = it->second;\\n          it--;\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */",
                "codeTag": "C++"
            },
            {
                "id": 2325947,
                "title": "c-three-maps-easy-to-understand",
                "content": "\\n```\\nstruct comp{\\n    bool operator()(const pair<int,string> &p, const pair<int,string>&q) const\\n    {\\n        if(p.first == q.first)\\n        {\\n            return p.second > q.second;\\n        }\\n        \\n        return p.first < q.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    map<string,int> r;\\n    map<string,set<pair<int,string>,comp>> m;\\n    map<string,string> c;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for(int i=0;i<n;i++)\\n        {\\n         r[foods[i]] = ratings[i];\\n            m[cuisines[i]].insert({ratings[i],foods[i]});\\n            c[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[c[food]].erase({r[food],food});\\n        m[c[food]].insert({newRating,food});\\n        r[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--m[cuisine].end()).second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```\\n **Upvote if you like the solution**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct comp{\\n    bool operator()(const pair<int,string> &p, const pair<int,string>&q) const\\n    {\\n        if(p.first == q.first)\\n        {\\n            return p.second > q.second;\\n        }\\n        \\n        return p.first < q.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    map<string,int> r;\\n    map<string,set<pair<int,string>,comp>> m;\\n    map<string,string> c;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for(int i=0;i<n;i++)\\n        {\\n         r[foods[i]] = ratings[i];\\n            m[cuisines[i]].insert({ratings[i],foods[i]});\\n            c[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[c[food]].erase({r[food],food});\\n        m[c[food]].insert({newRating,food});\\n        r[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*--m[cuisine].end()).second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2325795,
                "title": "three-maps-set-with-custom-comparator-c",
                "content": "```\\nclass FoodRatings {\\n\\t// custom class to store information of the food\\n    class info{\\n        public:\\n            int rating;\\n            string food_name;\\n\\t\\t\\n        info(int r,string s) //constructor\\n        {\\n            rating = r;\\n            food_name=s;\\n        }\\n    };\\n    \\n\\t//custom comparator to maintan ordering in set...\\n    class comp{\\n        public:\\n            bool operator()(info a,info b)const\\n            {\\n                if(a.rating==b.rating)\\n                    return a.food_name<b.food_name;\\n                return a.rating>b.rating;\\n            }\\n    };\\n    \\n    map<string,string> which_cuisine; // mapping food with corresponding cuisine\\n    map<string,set<info,comp>> cuisine_info; // storing food information and mapping it to the corresponding cuisine\\n    map<string,int> curr_r; // a map to store the current rating of the food... \\n    \\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            curr_r[foods[i]]=ratings[i];\\n            which_cuisine[foods[i]]=cuisines[i];\\n            cuisine_info[cuisines[i]].insert(info(ratings[i],foods[i]));\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n\\t\\t//getting the current rating of the food\\n        int old_r=curr_r[food]; \\n        string cuisine = which_cuisine[food];\\n        \\n        cuisine_info[cuisine].erase(cuisine_info[cuisine].find(info(old_r,food))); //removing the food previous rating\\n        cuisine_info[cuisine].insert(info(newRating,food));\\n        curr_r[food]=newRating; //updating the current rating...\\n    }\\n    \\n    string highestRated(string cuisine) {\\n     \\n        info temp = *cuisine_info[cuisine].begin();\\n        return temp.food_name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n\\t// custom class to store information of the food\\n    class info{\\n        public:\\n            int rating;\\n            string food_name;\\n\\t\\t\\n        info(int r,string s) //constructor\\n        {\\n            rating = r;\\n            food_name=s;\\n        }\\n    };\\n    \\n\\t//custom comparator to maintan ordering in set...\\n    class comp{\\n        public:\\n            bool operator()(info a,info b)const\\n            {\\n                if(a.rating==b.rating)\\n                    return a.food_name<b.food_name;\\n                return a.rating>b.rating;\\n            }\\n    };\\n    \\n    map<string,string> which_cuisine; // mapping food with corresponding cuisine\\n    map<string,set<info,comp>> cuisine_info; // storing food information and mapping it to the corresponding cuisine\\n    map<string,int> curr_r; // a map to store the current rating of the food... \\n    \\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            curr_r[foods[i]]=ratings[i];\\n            which_cuisine[foods[i]]=cuisines[i];\\n            cuisine_info[cuisines[i]].insert(info(ratings[i],foods[i]));\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n\\t\\t//getting the current rating of the food\\n        int old_r=curr_r[food]; \\n        string cuisine = which_cuisine[food];\\n        \\n        cuisine_info[cuisine].erase(cuisine_info[cuisine].find(info(old_r,food))); //removing the food previous rating\\n        cuisine_info[cuisine].insert(info(newRating,food));\\n        curr_r[food]=newRating; //updating the current rating...\\n    }\\n    \\n    string highestRated(string cuisine) {\\n     \\n        info temp = *cuisine_info[cuisine].begin();\\n        return temp.food_name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325688,
                "title": "python-3-collections-defaultdict-heapq-priority-queue",
                "content": "Remove outdated ratings when you attempt to query highest rating.\\n\\n```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.foods = {foods[i]:ratings[i] for i in range(n)}\\n        self.cuisines = {foods[i]:cuisines[i] for i in range(n)}\\n        self.cuisine_rating = defaultdict(list)\\n        for i in range(n):\\n            heapq.heappush(self.cuisine_rating[cuisines[i]], (-1 * ratings[i], foods[i]))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.foods[food]=newRating\\n        heapq.heappush(self.cuisine_rating[self.cuisines[food]], (-1 * newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while  self.cuisine_rating[cuisine]:\\n            if -1 * self.cuisine_rating[cuisine][0][0] == self.foods[self.cuisine_rating[cuisine][0][1]]:\\n                return self.cuisine_rating[cuisine][0][1]\\n            else:\\n                heapq.heappop(self.cuisine_rating[cuisine])\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        n = len(foods)\\n        self.foods = {foods[i]:ratings[i] for i in range(n)}\\n        self.cuisines = {foods[i]:cuisines[i] for i in range(n)}\\n        self.cuisine_rating = defaultdict(list)\\n        for i in range(n):\\n            heapq.heappush(self.cuisine_rating[cuisines[i]], (-1 * ratings[i], foods[i]))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.foods[food]=newRating\\n        heapq.heappush(self.cuisine_rating[self.cuisines[food]], (-1 * newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while  self.cuisine_rating[cuisine]:\\n            if -1 * self.cuisine_rating[cuisine][0][0] == self.foods[self.cuisine_rating[cuisine][0][1]]:\\n                return self.cuisine_rating[cuisine][0][1]\\n            else:\\n                heapq.heappop(self.cuisine_rating[cuisine])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325584,
                "title": "weird-time-limit-exceeded-for-java-priorityqueue",
                "content": "Learned this in the hard way. In order to not have time limit exceeded, the code cannot find the object in PriorityQueue to remove by name comparison (String), but to only compare the object address (Integer). String comparison takes more time.\\nTo find the object to remove by address, it needs to keep the object address (reference) in a map indexed by the food name.\\n\\nI think this \"finding object only by reference can pass\" should not be the case when generating test cases. It should let both comparing object content or object address pass.\\n\\n```\\n    Map<String, String> cuisineByFood;\\n    Map<String, FoodAndRating> frByFood;\\n    Map<String, PriorityQueue<FoodAndRating>> pqByCuisine;\\n    \\n    class FoodAndRating implements Comparable<FoodAndRating> {\\n        String food;\\n        int rating;\\n        \\n        public FoodAndRating(String f, int r) {\\n            this.food = f;\\n            this.rating = r;\\n        }\\n        \\n        public String toString() {\\n            return \"[ \" + food + \", \" + rating + \" ]\";\\n        }\\n        \\n        @Override\\n        public int compareTo(FoodAndRating anotherFr) {\\n            if (this.rating == anotherFr.rating) {\\n                return this.food.compareTo(anotherFr.food);\\n            } else {\\n                return anotherFr.rating - this.rating;\\n            }\\n        }\\n\\n        @Override\\n        public boolean equals(Object object) {\\n            /////////////////////////////////////////////////// \\n            //                                               //\\n            //     Time Limit Exceeded at test case 74       //\\n            //                                               //\\n            ///////////////////////////////////////////////////\\n            // FoodAndRating fr = (FoodAndRating) object;\\n            // return this.food.equals(fr.food) && this.rating == fr.rating;\\n            \\n            /////////////////////////////////////////////////// \\n            //                                               //\\n            //               Works fine.                     //\\n            //     Time on creating more objects is OK.      //\\n            //                                               //\\n            ///////////////////////////////////////////////////\\n            return this == object;\\n        }\\n    }\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int m = foods.length;\\n        \\n        cuisineByFood = new HashMap<>(m);\\n        \\n        frByFood = new HashMap<>(m);\\n        pqByCuisine = new HashMap<>(m);\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            cuisineByFood.put(foods[i], cuisines[i]);\\n            \\n            FoodAndRating fr = new FoodAndRating(foods[i], ratings[i]);\\n            frByFood.put(foods[i], fr);\\n            pqByCuisine.putIfAbsent(cuisines[i], new PriorityQueue<FoodAndRating>());\\n            pqByCuisine.get(cuisines[i]).add(fr);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodAndRating fr = frByFood.get(food);\\n        String cuisine = cuisineByFood.get(food);\\n        PriorityQueue pq = pqByCuisine.get(cuisine);\\n        pq.remove(fr);\\n        FoodAndRating newFr = new FoodAndRating(food, newRating);\\n        frByFood.put(food, newFr);\\n        pq.add(newFr);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return pqByCuisine.get(cuisine).peek().food;\\n    }\\n```\\n\\nGive it a try. The TLE can be easily reproduced by changing the `equals` method in `FoodAndRating`.",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    Map<String, String> cuisineByFood;\\n    Map<String, FoodAndRating> frByFood;\\n    Map<String, PriorityQueue<FoodAndRating>> pqByCuisine;\\n    \\n    class FoodAndRating implements Comparable<FoodAndRating> {\\n        String food;\\n        int rating;\\n        \\n        public FoodAndRating(String f, int r) {\\n            this.food = f;\\n            this.rating = r;\\n        }\\n        \\n        public String toString() {\\n            return \"[ \" + food + \", \" + rating + \" ]\";\\n        }\\n        \\n        @Override\\n        public int compareTo(FoodAndRating anotherFr) {\\n            if (this.rating == anotherFr.rating) {\\n                return this.food.compareTo(anotherFr.food);\\n            } else {\\n                return anotherFr.rating - this.rating;\\n            }\\n        }\\n\\n        @Override\\n        public boolean equals(Object object) {\\n            /////////////////////////////////////////////////// \\n            //                                               //\\n            //     Time Limit Exceeded at test case 74       //\\n            //                                               //\\n            ///////////////////////////////////////////////////\\n            // FoodAndRating fr = (FoodAndRating) object;\\n            // return this.food.equals(fr.food) && this.rating == fr.rating;\\n            \\n            /////////////////////////////////////////////////// \\n            //                                               //\\n            //               Works fine.                     //\\n            //     Time on creating more objects is OK.      //\\n            //                                               //\\n            ///////////////////////////////////////////////////\\n            return this == object;\\n        }\\n    }\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int m = foods.length;\\n        \\n        cuisineByFood = new HashMap<>(m);\\n        \\n        frByFood = new HashMap<>(m);\\n        pqByCuisine = new HashMap<>(m);\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            cuisineByFood.put(foods[i], cuisines[i]);\\n            \\n            FoodAndRating fr = new FoodAndRating(foods[i], ratings[i]);\\n            frByFood.put(foods[i], fr);\\n            pqByCuisine.putIfAbsent(cuisines[i], new PriorityQueue<FoodAndRating>());\\n            pqByCuisine.get(cuisines[i]).add(fr);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodAndRating fr = frByFood.get(food);\\n        String cuisine = cuisineByFood.get(food);\\n        PriorityQueue pq = pqByCuisine.get(cuisine);\\n        pq.remove(fr);\\n        FoodAndRating newFr = new FoodAndRating(food, newRating);\\n        frByFood.put(food, newFr);\\n        pq.add(newFr);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return pqByCuisine.get(cuisine).peek().food;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325431,
                "title": "c-sortedset-solution",
                "content": "```\\npublic class FoodRatings {\\n    \\n    class Food {\\n        public string Name { get; set; }\\n        public int Rating { get; set; }\\n    }\\n    \\n    class FoodComparer : IComparer<Food>{\\n        public int Compare(Food a, Food b){\\n            if(a.Rating != b.Rating)\\n                return a.Rating-b.Rating;\\n            else\\n                return string.Compare(b.Name, a.Name);\\n        }\\n    }    \\n    \\n    Dictionary<string, SortedSet<Food>> cusineFoodList = new Dictionary<string, SortedSet<Food>>();\\n    Dictionary<string, string> foodCusine = new Dictionary<string, string>();\\n    Dictionary<string, Food> foodnameFood = new Dictionary<string, Food>();\\n\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.Length; i++){\\n            if(!cusineFoodList.ContainsKey(cuisines[i]))\\n                cusineFoodList.Add(cuisines[i], new SortedSet<Food>(new FoodComparer()));\\n            Food f = new Food() { Name = foods[i], Rating = ratings[i] };\\n            cusineFoodList[cuisines[i]].Add(f);\\n            foodnameFood.Add(foods[i], f);\\n            foodCusine.Add(foods[i], cuisines[i]);\\n        }\\n    }\\n    \\n    public void ChangeRating(string food, int newRating) {\\n        Food old = foodnameFood[food];\\n        Food f = new Food() { Name = food, Rating = newRating };\\n        cusineFoodList[foodCusine[food]].Remove(old);\\n        cusineFoodList[foodCusine[food]].Add(f);\\n        foodnameFood[food] = f;\\n    }\\n    \\n    public string HighestRated(string cuisine) {\\n        return cusineFoodList[cuisine].Max.Name;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class FoodRatings {\\n    \\n    class Food {\\n        public string Name { get; set; }\\n        public int Rating { get; set; }\\n    }\\n    \\n    class FoodComparer : IComparer<Food>{\\n        public int Compare(Food a, Food b){\\n            if(a.Rating != b.Rating)\\n                return a.Rating-b.Rating;\\n            else\\n                return string.Compare(b.Name, a.Name);\\n        }\\n    }    \\n    \\n    Dictionary<string, SortedSet<Food>> cusineFoodList = new Dictionary<string, SortedSet<Food>>();\\n    Dictionary<string, string> foodCusine = new Dictionary<string, string>();\\n    Dictionary<string, Food> foodnameFood = new Dictionary<string, Food>();\\n\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.Length; i++){\\n            if(!cusineFoodList.ContainsKey(cuisines[i]))\\n                cusineFoodList.Add(cuisines[i], new SortedSet<Food>(new FoodComparer()));\\n            Food f = new Food() { Name = foods[i], Rating = ratings[i] };\\n            cusineFoodList[cuisines[i]].Add(f);\\n            foodnameFood.Add(foods[i], f);\\n            foodCusine.Add(foods[i], cuisines[i]);\\n        }\\n    }\\n    \\n    public void ChangeRating(string food, int newRating) {\\n        Food old = foodnameFood[food];\\n        Food f = new Food() { Name = food, Rating = newRating };\\n        cusineFoodList[foodCusine[food]].Remove(old);\\n        cusineFoodList[foodCusine[food]].Add(f);\\n        foodnameFood[food] = f;\\n    }\\n    \\n    public string HighestRated(string cuisine) {\\n        return cusineFoodList[cuisine].Max.Name;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325281,
                "title": "python-solution-using-two-dictionaries-and-one-heap",
                "content": "Code:\\n\\n\\tfrom collections import defaultdict\\n\\timport heapq\\n\\n\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.food_data = dict()\\n\\t\\t\\tself.heaps_of_cuis = defaultdict(list)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\theapq.heappush(self.heaps_of_cuis[cuisines[i]], [-ratings[i], foods[i]])\\n\\t\\t\\t\\tself.food_data[foods[i]] = [cuisines[i], ratings[i]]\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tcuisine = self.food_data[food][0]\\n\\t\\t\\tself.food_data[food][1] = newRating\\n\\t\\t\\theapq.heappush(self.heaps_of_cuis[cuisine], [-newRating, food])\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\trating, food = self.heaps_of_cuis[cuisine][0]\\n\\t\\t\\twhile  -rating != self.food_data[food][1]:\\n\\t\\t\\t\\theapq.heappop(self.heaps_of_cuis[cuisine])\\n\\t\\t\\t\\trating, food = self.heaps_of_cuis[cuisine][0]\\n\\t\\t\\treturn food\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "Code:\\n\\n\\tfrom collections import defaultdict\\n\\timport heapq\\n\\n\\n\\tclass FoodRatings:\\n\\t\\tdef __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n\\t\\t\\tself.food_data = dict()\\n\\t\\t\\tself.heaps_of_cuis = defaultdict(list)\\n\\t\\t\\tfor i in range(len(foods)):\\n\\t\\t\\t\\theapq.heappush(self.heaps_of_cuis[cuisines[i]], [-ratings[i], foods[i]])\\n\\t\\t\\t\\tself.food_data[foods[i]] = [cuisines[i], ratings[i]]\\n\\n\\t\\tdef changeRating(self, food: str, newRating: int) -> None:\\n\\t\\t\\tcuisine = self.food_data[food][0]\\n\\t\\t\\tself.food_data[food][1] = newRating\\n\\t\\t\\theapq.heappush(self.heaps_of_cuis[cuisine], [-newRating, food])\\n\\n\\t\\tdef highestRated(self, cuisine: str) -> str:\\n\\t\\t\\trating, food = self.heaps_of_cuis[cuisine][0]\\n\\t\\t\\twhile  -rating != self.food_data[food][1]:\\n\\t\\t\\t\\theapq.heappop(self.heaps_of_cuis[cuisine])\\n\\t\\t\\t\\trating, food = self.heaps_of_cuis[cuisine][0]\\n\\t\\t\\treturn food\\n",
                "codeTag": "Java"
            },
            {
                "id": 2325196,
                "title": "c-easy-to-understand-using-map",
                "content": "```\\n// upvote if solution was helpful\\nclass FoodRatings {\\npublic:\\n    map<string, string>food; //food name, cuisine\\n    map<string, int>foodRating; // food name, rating\\n    map<string,map<int, set<string>, greater<int>>>m; // cuisine, rating, set of foods\\n\\t\\n\\t/*\\n\\tFor eg1:\\n\\tfood:\\n\\tkim->kor\\n\\tmis->jap\\n\\tsus->jap\\n\\tmou->gre\\n\\tram->jap\\n\\tbul->kor\\n\\t\\n\\tfoorRating:\\n\\tkim->9\\n\\tmis->12\\n\\tsus->8\\n\\tmou->15\\n\\tram->14\\n\\tbul->7\\n\\t\\n\\tm:\\n\\tgre-> 15->{mou}\\n\\tjap-> 14->{ram}\\n\\t      12->{mis}\\n\\t\\t  8->{sus}\\n\\tkor-> 9->{kim}\\n\\t      7->{bul}\\n\\t*/\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for(int i = 0;i<n;i++) {\\n            food[foods[i]] = cuisines[i];\\n            foodRating[foods[i]] = ratings[i];\\n            m[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n    \\n    void changeRating(string fod, int newRating) {\\n        string c = food[fod]; // cuisine of food\\n        int oldRating = foodRating[fod]; // old rating of food\\n        m[c][oldRating].erase(fod); // remove food from cuisine and old rating\\n        if(m[c][oldRating].empty()) m[c].erase(oldRating); // if old rating is empty, remove old rating\\n        m[c][newRating].insert(fod); // add food to new rating\\n        foodRating[fod] = newRating; // update food rating\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return *m[cuisine].begin()->second.begin();  // return highest rated food in cuisine\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// upvote if solution was helpful\\nclass FoodRatings {\\npublic:\\n    map<string, string>food; //food name, cuisine\\n    map<string, int>foodRating; // food name, rating\\n    map<string,map<int, set<string>, greater<int>>>m; // cuisine, rating, set of foods\\n\\t\\n\\t/*\\n\\tFor eg1:\\n\\tfood:\\n\\tkim->kor\\n\\tmis->jap\\n\\tsus->jap\\n\\tmou->gre\\n\\tram->jap\\n\\tbul->kor\\n\\t\\n\\tfoorRating:\\n\\tkim->9\\n\\tmis->12\\n\\tsus->8\\n\\tmou->15\\n\\tram->14\\n\\tbul->7\\n\\t\\n\\tm:\\n\\tgre-> 15->{mou}\\n\\tjap-> 14->{ram}\\n\\t      12->{mis}\\n\\t\\t  8->{sus}\\n\\tkor-> 9->{kim}\\n\\t      7->{bul}\\n\\t*/\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for(int i = 0;i<n;i++) {\\n            food[foods[i]] = cuisines[i];\\n            foodRating[foods[i]] = ratings[i];\\n            m[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n        \\n    }\\n    \\n    void changeRating(string fod, int newRating) {\\n        string c = food[fod]; // cuisine of food\\n        int oldRating = foodRating[fod]; // old rating of food\\n        m[c][oldRating].erase(fod); // remove food from cuisine and old rating\\n        if(m[c][oldRating].empty()) m[c].erase(oldRating); // if old rating is empty, remove old rating\\n        m[c][newRating].insert(fod); // add food to new rating\\n        foodRating[fod] = newRating; // update food rating\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return *m[cuisine].begin()->second.begin();  // return highest rated food in cuisine\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325115,
                "title": "very-easy-and-simple-to-understand-c-solution-detail-explanation",
                "content": "<b> Up Vote if you like the Solution\\n```\\nclass FoodRatings {\\npublic:\\n    //Rating is stored as -ve as to have the largest value at the begining\\n    //to store data in the format - coisines :{ {-rating1, food1}, {-rating1, food1} ...}\\n    //This map will be used to get the highest rating\\n    map<string, set<pair<int, string>>> smp; \\n    \\n    //to store maping of food to coisine type ( food -> coisine)\\n    map<string, string> tmp;\\n    \\n    // to store maping of last rating of a food ( food -> rating)\\n    map<string, int> rmp;\\n\\t\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings){\\n        //store all the data\\n        for(int i = 0; i < foods.size(); ++i){\\n            smp[cuisines[i]].insert({-ratings[i], foods[i]});\\n            tmp[foods[i]] = cuisines[i];\\n            rmp[foods[i]] = ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string ctype = tmp[food];\\n        int oldRating = rmp[food];  //get older rating of the food\\n        rmp[food] = newRating;      \\n        smp[ctype].erase({-oldRating, food});  //erase the older rating \\n        smp[ctype].insert({-newRating, food}); //iinsert the new one\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = smp[cuisine].begin(); //this will return a pointer to first {-rating, food}\\n        return (*it).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    //Rating is stored as -ve as to have the largest value at the begining\\n    //to store data in the format - coisines :{ {-rating1, food1}, {-rating1, food1} ...}\\n    //This map will be used to get the highest rating\\n    map<string, set<pair<int, string>>> smp; \\n    \\n    //to store maping of food to coisine type ( food -> coisine)\\n    map<string, string> tmp;\\n    \\n    // to store maping of last rating of a food ( food -> rating)\\n    map<string, int> rmp;\\n\\t\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings){\\n        //store all the data\\n        for(int i = 0; i < foods.size(); ++i){\\n            smp[cuisines[i]].insert({-ratings[i], foods[i]});\\n            tmp[foods[i]] = cuisines[i];\\n            rmp[foods[i]] = ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string ctype = tmp[food];\\n        int oldRating = rmp[food];  //get older rating of the food\\n        rmp[food] = newRating;      \\n        smp[ctype].erase({-oldRating, food});  //erase the older rating \\n        smp[ctype].insert({-newRating, food}); //iinsert the new one\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = smp[cuisine].begin(); //this will return a pointer to first {-rating, food}\\n        return (*it).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325102,
                "title": "3-maps-explanation-c",
                "content": "At first glace, it makes sense to use 2 maps for this problem. Why?\\n- Firstly, we need a map that stores the cuisine name for a given food.\\n- We need a map that takes the cuisine name and outputs two things: rating and food. \\nThe first map maps cuisine to food\\nThe second map is a little tricky because it needs to be sorted. We can use a set of type pair<rating, food> as the value and cuisine as the key. Note that a set will sort in ascending order (to get around this, I push -1\\\\*rating).\\n\\nThis might seem enough until you start coding the logic, after which you realise that you need a **third map**. Why?\\n\\n- While changing the rating of a food, we need to erase it from the set in the second map and push the new rating. In order to erase it from the set, we need to pass both the food and the previous rating to the erase function. To keep track of the previous rating we use another map.\\n\\n```\\n\\n\\nclass FoodRatings {\\npublic:\\n    // [food] = cuisine name\\n    unordered_map <string, string> getcus;\\n    // [cuisine] = <rating, food>\\n    unordered_map <string, set <pair<int, string>>> crf;\\n    // [food] = rating (used to remove pair from crf)\\n    unordered_map <string, int> foodrating;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++) {\\n            getcus[foods[i]] = cuisines[i];\\n            crf[cuisines[i]].insert({-ratings[i], foods[i]});\\n            foodrating[foods[i]] = -ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cus = getcus[food];\\n        int currating = foodrating[food];\\n        crf[cus].erase({currating, food});\\n        crf[cus].insert({-newRating, food});\\n        foodrating[food] = -newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        // just gets the first element from the iterator\\n        auto ans(crf[cuisine].begin());\\n        return (*ans).second;\\n    }\\n};\\n```\\n\\nSimilar (but slightly more complex) problem to try: [Design Movie Rental System](https://leetcode.com/problems/design-movie-rental-system/)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nclass FoodRatings {\\npublic:\\n    // [food] = cuisine name\\n    unordered_map <string, string> getcus;\\n    // [cuisine] = <rating, food>\\n    unordered_map <string, set <pair<int, string>>> crf;\\n    // [food] = rating (used to remove pair from crf)\\n    unordered_map <string, int> foodrating;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++) {\\n            getcus[foods[i]] = cuisines[i];\\n            crf[cuisines[i]].insert({-ratings[i], foods[i]});\\n            foodrating[foods[i]] = -ratings[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cus = getcus[food];\\n        int currating = foodrating[food];\\n        crf[cus].erase({currating, food});\\n        crf[cus].insert({-newRating, food});\\n        foodrating[food] = -newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        // just gets the first element from the iterator\\n        auto ans(crf[cuisine].begin());\\n        return (*ans).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324953,
                "title": "python-priority-queue-hashmap-100-faster",
                "content": "\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        \\n\\t\\t#store heap of food & rating linked to cusine \\n        self.cusine_heap_lookup = {}\\n\\t\\t\\n\\t\\t#store rating for easy update  : O(1)\\n        self.cusine_hash_lookup = {}\\n\\t\\t\\n\\t\\t#find out food by cusine : O(1)\\n        self.cusine_revese_lookup = {}\\n        \\n        for cusine in cuisines:\\n            self.cusine_heap_lookup[cusine] = []\\n            self.cusine_hash_lookup[cusine] = {}\\n            \\n        \\n        n = len(foods)\\n        for index in range(n):\\n            heap_lookup = self.cusine_heap_lookup[cuisines[index]]\\n            hash_lookup = self.cusine_hash_lookup[cuisines[index]] \\n            \\n            self.cusine_revese_lookup[foods[index]] = cuisines[index]\\n            heapq.heappush(heap_lookup,[-ratings[index], foods[index]])\\n            hash_lookup[foods[index]] = ratings[index]\\n           \\n\\t# TC : O(1) hashmap + O(1) heap insert\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        \\n        cusine = self.cusine_revese_lookup[food]\\n        heap_lookup = self.cusine_heap_lookup[cusine]\\n        hash_lookup = self.cusine_hash_lookup[cusine] \\n        \\n        heapq.heappush(heap_lookup,[-newRating,food])\\n        hash_lookup[food] = newRating\\n       \\n\\t# TC : O(1) hashmap + n.O(1) heap find \\n    def highestRated(self, cuisine: str) -> str:\\n        heap_lookup = self.cusine_heap_lookup[cuisine]\\n        hash_lookup = self.cusine_hash_lookup[cuisine]\\n        \\n\\t\\t#reject heap value until it\\'s invalid \\n        while heap_lookup and -heap_lookup[0][0] != hash_lookup[heap_lookup[0][1]]:\\n            heapq.heappop(heap_lookup)\\n        \\n        return heap_lookup[0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        \\n\\t\\t#store heap of food & rating linked to cusine \\n        self.cusine_heap_lookup = {}\\n\\t\\t\\n\\t\\t#store rating for easy update  : O(1)\\n        self.cusine_hash_lookup = {}\\n\\t\\t\\n\\t\\t#find out food by cusine : O(1)\\n        self.cusine_revese_lookup = {}\\n        \\n        for cusine in cuisines:\\n            self.cusine_heap_lookup[cusine] = []\\n            self.cusine_hash_lookup[cusine] = {}\\n            \\n        \\n        n = len(foods)\\n        for index in range(n):\\n            heap_lookup = self.cusine_heap_lookup[cuisines[index]]\\n            hash_lookup = self.cusine_hash_lookup[cuisines[index]] \\n            \\n            self.cusine_revese_lookup[foods[index]] = cuisines[index]\\n            heapq.heappush(heap_lookup,[-ratings[index], foods[index]])\\n            hash_lookup[foods[index]] = ratings[index]\\n           \\n\\t# TC : O(1) hashmap + O(1) heap insert\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        \\n        cusine = self.cusine_revese_lookup[food]\\n        heap_lookup = self.cusine_heap_lookup[cusine]\\n        hash_lookup = self.cusine_hash_lookup[cusine] \\n        \\n        heapq.heappush(heap_lookup,[-newRating,food])\\n        hash_lookup[food] = newRating\\n       \\n\\t# TC : O(1) hashmap + n.O(1) heap find \\n    def highestRated(self, cuisine: str) -> str:\\n        heap_lookup = self.cusine_heap_lookup[cuisine]\\n        hash_lookup = self.cusine_hash_lookup[cuisine]\\n        \\n\\t\\t#reject heap value until it\\'s invalid \\n        while heap_lookup and -heap_lookup[0][0] != hash_lookup[heap_lookup[0][1]]:\\n            heapq.heappop(heap_lookup)\\n        \\n        return heap_lookup[0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324944,
                "title": "java-2-hashmap-tree-set-comparable-approach",
                "content": "Using custom class to encapsulate fields- foodname and cuisine are declared final, rating is mutable\\n2 hashmaps to maintain a)foodname vs food and b)cuisine vs set of foods (naturally ordered by rating)\\n\\n```\\nclass Food implements Comparable{\\n    public final String food;\\n    public final String cuisine;\\n    public int rating;\\n    \\n    public Food(String food, String cuisine, int rating){\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    \\n    public int compareTo(Object other){\\n        Food otherFood =  ((Food)other);\\n        int ratingDiff = this.rating -otherFood.rating;\\n        return ratingDiff == 0 ? otherFood.food.compareTo(this.food) : ratingDiff;\\n    }\\n}\\n\\n\\nclass FoodRatings {\\n    \\n    Map<String,Food> foodMap = new HashMap<>();\\n    Map<String,TreeSet<Food>> cuisineToFoods = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0;i<foods.length;i++){\\n            Food f = new Food(foods[i],cuisines[i],ratings[i]);\\n            foodMap.put(foods[i],f);\\n            cuisineToFoods.putIfAbsent(cuisines[i],new TreeSet<Food>());\\n            cuisineToFoods.get(cuisines[i]).add(f);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food currFood = foodMap.get(food);\\n        cuisineToFoods.get(currFood.cuisine).remove(currFood);\\n        currFood.rating=newRating;\\n        cuisineToFoods.get(currFood.cuisine).add(currFood);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineToFoods.get(cuisine).last().food;\\n    }\\n}\\n```\\n\\nminor Improvement - can replace comparable with external comparator sort",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Food implements Comparable{\\n    public final String food;\\n    public final String cuisine;\\n    public int rating;\\n    \\n    public Food(String food, String cuisine, int rating){\\n        this.food = food;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    \\n    public int compareTo(Object other){\\n        Food otherFood =  ((Food)other);\\n        int ratingDiff = this.rating -otherFood.rating;\\n        return ratingDiff == 0 ? otherFood.food.compareTo(this.food) : ratingDiff;\\n    }\\n}\\n\\n\\nclass FoodRatings {\\n    \\n    Map<String,Food> foodMap = new HashMap<>();\\n    Map<String,TreeSet<Food>> cuisineToFoods = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0;i<foods.length;i++){\\n            Food f = new Food(foods[i],cuisines[i],ratings[i]);\\n            foodMap.put(foods[i],f);\\n            cuisineToFoods.putIfAbsent(cuisines[i],new TreeSet<Food>());\\n            cuisineToFoods.get(cuisines[i]).add(f);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food currFood = foodMap.get(food);\\n        cuisineToFoods.get(currFood.cuisine).remove(currFood);\\n        currFood.rating=newRating;\\n        cuisineToFoods.get(currFood.cuisine).add(currFood);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineToFoods.get(cuisine).last().food;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324896,
                "title": "java-3-map-treeset-why-pair-not-work-but-custom-class-does",
                "content": "Below is my code, 3 Maps with TreeSet, and passed the base test case. HOWEVER, it failed in the test case that \\'kjop\\' and \\'lzeqwfb\\' where these 2 has same rating. I MERELY want to know why this case failed. I cannot really find out the reasons. \\n\\n(I\\'ve tried different Comparator in comments, NOT WORK, WHY)\\n \\n```\\nclass FoodRatings {\\n    Map<String, String> dishSys;\\n    Map<String, Integer> dishPrice;\\n    Map<String, TreeSet<Pair<String, Integer>>> map; // cuisine --SortedList<Pair<String, Integer>>\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        dishSys = new HashMap<>();\\n        dishPrice = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            TreeSet<Pair<String, Integer>> set = map.getOrDefault(cuisines[i], new TreeSet(new Comparator<Pair<String, Integer>>(){\\n         @Override\\n         public int compare(Pair<String, Integer> o1, Pair<String, Integer> o2){\\n             if (o1.getValue() == o2.getValue())\\n                 return o1.getKey().compareTo(o2.getKey());\\n             // if (o1.getValue() == o2.getValue()){\\n             //     String s1 = o1.getKey();\\n             //     String s2 = o2.getKey();\\n             //     int i = 0, j = 0;\\n             //     while(i < s1.length() && j < s2.length()) {\\n             //         if(s1.charAt(i) > s2.charAt(j)) {\\n             //             return 1;\\n             //         }else if (s1.charAt(i) < s2.charAt(j)) {\\n             //             return -1;\\n             //         }\\n             //         i++;\\n             //         j++;\\n             //     }\\n             //     if (i == s1.length() && j < s2.length())\\n             //         return -1;\\n             //     if (i < s1.length() && j == s2.length())\\n             //         return 1;\\n             //     return 0;\\n             // }    \\n                 \\n             \\n             return o2.getValue() - o1.getValue();\\n         }\\n     }));\\n            set.add(new Pair(foods[i], ratings[i]));\\n            map.put(cuisines[i], set);\\n            dishSys.put(foods[i], cuisines[i]);\\n            dishPrice.put(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String belongSys = dishSys.get(food);\\n        Integer oldPrice = dishPrice.get(food);\\n        Pair<String, Integer> pair = new Pair(food, oldPrice);\\n        map.get(belongSys).remove(pair);\\n        map.get(belongSys).add(new Pair(food, newRating));\\n        dishPrice.put(food, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().getKey();\\n    }\\n}\\n```\\n\\n--------------------EDITED---------------------\\nfreakly weird! JUST create a custom class, and store the name String, it works, BUT if using Pair, It does NOT work. HELLLLLLLLLLLLLLLP!!! CAN anyone explain it to me? Thank you!!!!!!\\n\\n\\n```\\n    Map<String, String> dishSys;\\n    Map<String, Integer> dishPrice;\\n    Map<String, TreeSet<Food>> map; // cuisine --SortedList<Pair<String, Integer>>\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        dishSys = new HashMap<>();\\n        dishPrice = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            Food f = new Food(foods[i], ratings[i]);\\n            TreeSet<Food> set = map.getOrDefault(cuisines[i], new TreeSet(new Comparator<Food>(){\\n         @Override\\n         public int compare(Food o1, Food o2){\\n             if (o1.rate == o2.rate)\\n                 return o1.name.compareTo(o2.name);                 \\n             \\n             return o2.rate - o1.rate;\\n         }\\n     }));\\n            set.add(f);\\n            map.put(cuisines[i], set);\\n            dishSys.put(foods[i], cuisines[i]);\\n            dishPrice.put(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String belongSys = dishSys.get(food);\\n        Integer oldPrice = dishPrice.get(food);\\n        Food pair = new Food(food, oldPrice);\\n        map.get(belongSys).remove(pair);\\n        map.get(belongSys).add(new Food(food, newRating));\\n        dishPrice.put(food, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().name;\\n    }\\n    \\n    \\n    class Food{\\n        String name;\\n        int rate;\\n        \\n        public Food (String n, int r) {\\n            name = n;\\n            rate = r;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    Map<String, String> dishSys;\\n    Map<String, Integer> dishPrice;\\n    Map<String, TreeSet<Pair<String, Integer>>> map; // cuisine --SortedList<Pair<String, Integer>>\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        dishSys = new HashMap<>();\\n        dishPrice = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            TreeSet<Pair<String, Integer>> set = map.getOrDefault(cuisines[i], new TreeSet(new Comparator<Pair<String, Integer>>(){\\n         @Override\\n         public int compare(Pair<String, Integer> o1, Pair<String, Integer> o2){\\n             if (o1.getValue() == o2.getValue())\\n                 return o1.getKey().compareTo(o2.getKey());\\n             // if (o1.getValue() == o2.getValue()){\\n             //     String s1 = o1.getKey();\\n             //     String s2 = o2.getKey();\\n             //     int i = 0, j = 0;\\n             //     while(i < s1.length() && j < s2.length()) {\\n             //         if(s1.charAt(i) > s2.charAt(j)) {\\n             //             return 1;\\n             //         }else if (s1.charAt(i) < s2.charAt(j)) {\\n             //             return -1;\\n             //         }\\n             //         i++;\\n             //         j++;\\n             //     }\\n             //     if (i == s1.length() && j < s2.length())\\n             //         return -1;\\n             //     if (i < s1.length() && j == s2.length())\\n             //         return 1;\\n             //     return 0;\\n             // }    \\n                 \\n             \\n             return o2.getValue() - o1.getValue();\\n         }\\n     }));\\n            set.add(new Pair(foods[i], ratings[i]));\\n            map.put(cuisines[i], set);\\n            dishSys.put(foods[i], cuisines[i]);\\n            dishPrice.put(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String belongSys = dishSys.get(food);\\n        Integer oldPrice = dishPrice.get(food);\\n        Pair<String, Integer> pair = new Pair(food, oldPrice);\\n        map.get(belongSys).remove(pair);\\n        map.get(belongSys).add(new Pair(food, newRating));\\n        dishPrice.put(food, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().getKey();\\n    }\\n}\\n```\n```\\n    Map<String, String> dishSys;\\n    Map<String, Integer> dishPrice;\\n    Map<String, TreeSet<Food>> map; // cuisine --SortedList<Pair<String, Integer>>\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        dishSys = new HashMap<>();\\n        dishPrice = new HashMap<>();\\n        \\n        for (int i = 0; i < foods.length; i++) {\\n            Food f = new Food(foods[i], ratings[i]);\\n            TreeSet<Food> set = map.getOrDefault(cuisines[i], new TreeSet(new Comparator<Food>(){\\n         @Override\\n         public int compare(Food o1, Food o2){\\n             if (o1.rate == o2.rate)\\n                 return o1.name.compareTo(o2.name);                 \\n             \\n             return o2.rate - o1.rate;\\n         }\\n     }));\\n            set.add(f);\\n            map.put(cuisines[i], set);\\n            dishSys.put(foods[i], cuisines[i]);\\n            dishPrice.put(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String belongSys = dishSys.get(food);\\n        Integer oldPrice = dishPrice.get(food);\\n        Food pair = new Food(food, oldPrice);\\n        map.get(belongSys).remove(pair);\\n        map.get(belongSys).add(new Food(food, newRating));\\n        dishPrice.put(food, newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).first().name;\\n    }\\n    \\n    \\n    class Food{\\n        String name;\\n        int rate;\\n        \\n        public Food (String n, int r) {\\n            name = n;\\n            rate = r;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324860,
                "title": "c-priorityqueue-explained",
                "content": "```\\n    public class FoodRatings\\n    {\\n        private readonly Dictionary<string, int> dict;\\n        private readonly Dictionary<string, string> set;\\n\\t\\t//we donot design a new class, but using a string[2], string[0] is foodname, string[1] is rate.ToString()\\n        private readonly Dictionary<string, PriorityQueue<string[], string[]>> map;\\n        public FoodRatings(string[] foods, string[] cuisines, int[] ratings)\\n        {\\n            dict = new Dictionary<string, int>();\\n            set = new Dictionary<string, string>();\\n            map = new Dictionary<string, PriorityQueue<string[], string[]>>();\\n            int n = foods.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                dict.Add(foods[i], ratings[i]);//store {food,rating} pairs\\n                set.Add(foods[i], cuisines[i]);//store {food,cursine} pairs\\n                if (!map.ContainsKey(cuisines[i]))\\n                    map.Add(cuisines[i], new PriorityQueue<string[], string[]>(Comparer<string[]>.Create((x, y) =>\\n                    {\\n                        var rate1 = int.Parse(x[1]);\\n                        var rate2 = int.Parse(y[1]);\\n                        if (rate1 > rate2) return -1;//return better rating food of this cuisine type\\n                        else if (rate1 < rate2) return 1;\\n                        else return x[0].CompareTo(y[0]);//if two same rating existed, return smaller name\\n                    })));\\n\\t\\t\\t\\t//store string[]{ foods[i], ratings[i].ToString()} pairs\\n                map[cuisines[i]].Enqueue(new string[] { foods[i], ratings[i].ToString() }, new string[] { foods[i], ratings[i].ToString() });\\n            }\\n        }\\n\\n        public void ChangeRating(string food, int newRating)\\n        {\\n            dict[food] = newRating;\\n            var cuisine = set[food];\\n\\t\\t\\t//every time changing rating, Enqueue new one in map, old still in map but expired!\\n            map[cuisine].Enqueue(new string[] { food, newRating.ToString() }, new string[] { food, newRating.ToString() });\\n        }\\n\\n        public string HighestRated(string cuisine)\\n        {\\n            var pq = map[cuisine];\\n            while (pq.Count > 0)\\n            {\\n                var top = pq.Peek();\\n                var rate = int.Parse(top[1]);\\n                if (dict[top[0]] == rate) return top[0];//if current rating is correct, return top[0] as food name\\n                else pq.Dequeue();//if rating of this food - top[0] was changed, the discard this expired one\\n            }\\n            return \"\";//never go here\\n        }\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public class FoodRatings\\n    {\\n        private readonly Dictionary<string, int> dict;\\n        private readonly Dictionary<string, string> set;\\n\\t\\t//we donot design a new class, but using a string[2], string[0] is foodname, string[1] is rate.ToString()\\n        private readonly Dictionary<string, PriorityQueue<string[], string[]>> map;\\n        public FoodRatings(string[] foods, string[] cuisines, int[] ratings)\\n        {\\n            dict = new Dictionary<string, int>();\\n            set = new Dictionary<string, string>();\\n            map = new Dictionary<string, PriorityQueue<string[], string[]>>();\\n            int n = foods.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                dict.Add(foods[i], ratings[i]);//store {food,rating} pairs\\n                set.Add(foods[i], cuisines[i]);//store {food,cursine} pairs\\n                if (!map.ContainsKey(cuisines[i]))\\n                    map.Add(cuisines[i], new PriorityQueue<string[], string[]>(Comparer<string[]>.Create((x, y) =>\\n                    {\\n                        var rate1 = int.Parse(x[1]);\\n                        var rate2 = int.Parse(y[1]);\\n                        if (rate1 > rate2) return -1;//return better rating food of this cuisine type\\n                        else if (rate1 < rate2) return 1;\\n                        else return x[0].CompareTo(y[0]);//if two same rating existed, return smaller name\\n                    })));\\n\\t\\t\\t\\t//store string[]{ foods[i], ratings[i].ToString()} pairs\\n                map[cuisines[i]].Enqueue(new string[] { foods[i], ratings[i].ToString() }, new string[] { foods[i], ratings[i].ToString() });\\n            }\\n        }\\n\\n        public void ChangeRating(string food, int newRating)\\n        {\\n            dict[food] = newRating;\\n            var cuisine = set[food];\\n\\t\\t\\t//every time changing rating, Enqueue new one in map, old still in map but expired!\\n            map[cuisine].Enqueue(new string[] { food, newRating.ToString() }, new string[] { food, newRating.ToString() });\\n        }\\n\\n        public string HighestRated(string cuisine)\\n        {\\n            var pq = map[cuisine];\\n            while (pq.Count > 0)\\n            {\\n                var top = pq.Peek();\\n                var rate = int.Parse(top[1]);\\n                if (dict[top[0]] == rate) return top[0];//if current rating is correct, return top[0] as food name\\n                else pq.Dequeue();//if rating of this food - top[0] was changed, the discard this expired one\\n            }\\n            return \"\";//never go here\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324848,
                "title": "java-map-priority-queue",
                "content": "```\\nclass FoodRatings \\n{\\n    class Pair implements Comparable<Pair>\\n    {\\n        String s;int r;\\n        \\n        Pair(String a,int b)\\n        {\\n            s=a;\\n            r=b;\\n        }\\n        \\n        public int compareTo(Pair obj)\\n        {\\n            if(this.r!=obj.r)\\n            return obj.r-this.r;\\n            \\n            return this.s.compareTo(obj.s);\\n            \\n        }\\n    }\\n    \\n    Map<String,PriorityQueue<Pair>> map;\\n    Map<String,Integer> name;\\n    Map<String,String> c;\\n    Pair a[];\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) \\n    {\\n        int n=foods.length;\\n        \\n        map=new HashMap<>();\\n        name=new HashMap<>();\\n        c=new HashMap<>();\\n        \\n        a=new Pair[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=new Pair(foods[i],ratings[i]);\\n            \\n            name.put(foods[i],i);\\n            c.put(foods[i],cuisines[i]);\\n            \\n            if(!map.containsKey(cuisines[i]))\\n            map.put(cuisines[i],new PriorityQueue<>());\\n            \\n            PriorityQueue<Pair> temp=map.get(cuisines[i]);\\n            temp.offer(a[i]);\\n            map.put(cuisines[i],temp);\\n                \\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) \\n    {\\n        int pos=name.get(food);\\n        \\n        map.get(c.get(food)).remove(a[pos]);\\n        a[pos].r=newRating;\\n        map.get(c.get(food)).offer(a[pos]);\\n    }\\n    \\n    public String highestRated(String cuisine) \\n    {\\n        return map.get(cuisine).peek().s;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings \\n{\\n    class Pair implements Comparable<Pair>\\n    {\\n        String s;int r;\\n        \\n        Pair(String a,int b)\\n        {\\n            s=a;\\n            r=b;\\n        }\\n        \\n        public int compareTo(Pair obj)\\n        {\\n            if(this.r!=obj.r)\\n            return obj.r-this.r;\\n            \\n            return this.s.compareTo(obj.s);\\n            \\n        }\\n    }\\n    \\n    Map<String,PriorityQueue<Pair>> map;\\n    Map<String,Integer> name;\\n    Map<String,String> c;\\n    Pair a[];\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) \\n    {\\n        int n=foods.length;\\n        \\n        map=new HashMap<>();\\n        name=new HashMap<>();\\n        c=new HashMap<>();\\n        \\n        a=new Pair[n];\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            a[i]=new Pair(foods[i],ratings[i]);\\n            \\n            name.put(foods[i],i);\\n            c.put(foods[i],cuisines[i]);\\n            \\n            if(!map.containsKey(cuisines[i]))\\n            map.put(cuisines[i],new PriorityQueue<>());\\n            \\n            PriorityQueue<Pair> temp=map.get(cuisines[i]);\\n            temp.offer(a[i]);\\n            map.put(cuisines[i],temp);\\n                \\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) \\n    {\\n        int pos=name.get(food);\\n        \\n        map.get(c.get(food)).remove(a[pos]);\\n        a[pos].r=newRating;\\n        map.get(c.get(food)).offer(a[pos]);\\n    }\\n    \\n    public String highestRated(String cuisine) \\n    {\\n        return map.get(cuisine).peek().s;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324836,
                "title": "c-easy-solution-map",
                "content": "```\\nstruct compare\\n{\\n    bool operator()(const pair<int, string> &x, const pair<int, string> &y) const\\n    {\\n        if (x.first == y.first)\\n        {\\n            return x.second > y.second;\\n        }\\n        return x.first < y.first;\\n    }\\n};\\n\\n\\nclass FoodRatings\\n{\\npublic:\\n    map<string, int> Mapstr;\\n    map<string, string> Mapstrstr;\\n    map<string, set<pair<int, string>, compare>> MapSet;\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)\\n    {\\n        for (int i = 0; i < foods.size(); i++)\\n        {\\n            Mapstr[foods[i]] = ratings[i];\\n            MapSet[cuisines[i]].insert({ratings[i], foods[i]});\\n            Mapstrstr[foods[i]] = cuisines[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        MapSet[Mapstrstr[food]].erase({Mapstr[food], food});\\n        MapSet[Mapstrstr[food]].insert({newRating, food});\\n        Mapstr[food] = newRating;\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return (*--MapSet[cuisine].end()).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstruct compare\\n{\\n    bool operator()(const pair<int, string> &x, const pair<int, string> &y) const\\n    {\\n        if (x.first == y.first)\\n        {\\n            return x.second > y.second;\\n        }\\n        return x.first < y.first;\\n    }\\n};\\n\\n\\nclass FoodRatings\\n{\\npublic:\\n    map<string, int> Mapstr;\\n    map<string, string> Mapstrstr;\\n    map<string, set<pair<int, string>, compare>> MapSet;\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector<int> &ratings)\\n    {\\n        for (int i = 0; i < foods.size(); i++)\\n        {\\n            Mapstr[foods[i]] = ratings[i];\\n            MapSet[cuisines[i]].insert({ratings[i], foods[i]});\\n            Mapstrstr[foods[i]] = cuisines[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        MapSet[Mapstrstr[food]].erase({Mapstr[food], food});\\n        MapSet[Mapstrstr[food]].insert({newRating, food});\\n        Mapstr[food] = newRating;\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return (*--MapSet[cuisine].end()).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324733,
                "title": "easy-solution-with-two-maps-java",
                "content": "PQ with cuisinesMap to get largest\\nand foodMap get the object to update the rate.\\n\\n```\\nclass FoodRatings {\\n    \\n    Map<String, PriorityQueue<Food>> cuisinesMap;\\n    Map<String, Food> foodMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisinesMap = new HashMap<>();\\n        foodMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i++){\\n            String food = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            Food foodObj = new Food(food, rating, cuisine);\\n            if(!cuisinesMap.containsKey(cuisine)){\\n                PriorityQueue<Food> pq = new PriorityQueue<>((a, b) -> a.rate == b.rate ? a.name.compareTo(b.name) : b.rate - a.rate);\\n                cuisinesMap.put(cuisine, pq);\\n            }\\n            \\n            cuisinesMap.get(cuisine).offer(foodObj);\\n            foodMap.put(food, foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food foodObj = foodMap.get(food);\\n        foodObj.rate = newRating;\\n        PriorityQueue<Food> pq = cuisinesMap.get(foodObj.cuisine);\\n        pq.remove(foodObj);\\n        pq.offer(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Food> pq = cuisinesMap.get(cuisine);\\n        return pq.peek().name;\\n    }\\n    \\n    class Food{\\n        String name;\\n        int rate;\\n        String cuisine;\\n        \\n        Food(String n, int r, String c){\\n            this.name = n;\\n            this.rate = r;\\n            this.cuisine = c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings {\\n    \\n    Map<String, PriorityQueue<Food>> cuisinesMap;\\n    Map<String, Food> foodMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisinesMap = new HashMap<>();\\n        foodMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i++){\\n            String food = foods[i];\\n            String cuisine = cuisines[i];\\n            int rating = ratings[i];\\n            \\n            Food foodObj = new Food(food, rating, cuisine);\\n            if(!cuisinesMap.containsKey(cuisine)){\\n                PriorityQueue<Food> pq = new PriorityQueue<>((a, b) -> a.rate == b.rate ? a.name.compareTo(b.name) : b.rate - a.rate);\\n                cuisinesMap.put(cuisine, pq);\\n            }\\n            \\n            cuisinesMap.get(cuisine).offer(foodObj);\\n            foodMap.put(food, foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food foodObj = foodMap.get(food);\\n        foodObj.rate = newRating;\\n        PriorityQueue<Food> pq = cuisinesMap.get(foodObj.cuisine);\\n        pq.remove(foodObj);\\n        pq.offer(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Food> pq = cuisinesMap.get(cuisine);\\n        return pq.peek().name;\\n    }\\n    \\n    class Food{\\n        String name;\\n        int rate;\\n        String cuisine;\\n        \\n        Food(String n, int r, String c){\\n            this.name = n;\\n            this.rate = r;\\n            this.cuisine = c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324722,
                "title": "simple-set-hashmap-solution-c",
                "content": "```\\n    map<string,string>m3;\\n    map<string,set<pair<int,string>>>m1;\\n    map<string,int>m2;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n      \\n        for(int i=0;i<foods.size();i++){\\n            m2[foods[i]]=ratings[i];\\n            m1[cuisines[i]].insert({ratings[i],foods[i]});\\n            m3[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating)\\n    {\\n        auto it=m1[m3[food]].find({m2[food],food});\\n        m1[m3[food]].erase(*it);\\n        m1[m3[food]].insert({newRating,food});\\n        m2[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        int ans=0;\\n        string res;\\n        auto it=m1[cuisine].end();\\n        it--;\\n        pair<int,string>p=*it;\\n        res=p.second;\\n        while(1)\\n        {\\n            it--;\\n            pair<int,string>p1=*it;\\n            if(p1.first==p.first){\\n                res=p1.second;\\n                \\n            }\\n            else\\n            {\\n                break;\\n            }\\n            if(it==m1[cuisine].begin())break;\\n        }\\n      \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n    map<string,string>m3;\\n    map<string,set<pair<int,string>>>m1;\\n    map<string,int>m2;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n      \\n        for(int i=0;i<foods.size();i++){\\n            m2[foods[i]]=ratings[i];\\n            m1[cuisines[i]].insert({ratings[i],foods[i]});\\n            m3[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating)\\n    {\\n        auto it=m1[m3[food]].find({m2[food],food});\\n        m1[m3[food]].erase(*it);\\n        m1[m3[food]].insert({newRating,food});\\n        m2[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        int ans=0;\\n        string res;\\n        auto it=m1[cuisine].end();\\n        it--;\\n        pair<int,string>p=*it;\\n        res=p.second;\\n        while(1)\\n        {\\n            it--;\\n            pair<int,string>p1=*it;\\n            if(p1.first==p.first){\\n                res=p1.second;\\n                \\n            }\\n            else\\n            {\\n                break;\\n            }\\n            if(it==m1[cuisine].begin())break;\\n        }\\n      \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324703,
                "title": "javascript-priority-queue-w-lazy-removal",
                "content": "**Solution: Priority Queue w/ Lazy Removal**\\n\\nFor each cuisine, keep a priority queue of `[food, rating]` ordered by rating (desc) and food in lexicographical order.\\nUse a hashmap to keep track of the rating and cuisine of each food.\\nWhen a rating is updated, update the hashmap and add `[food, newRating]` to the priority queue.\\nWhen getting the highest rated food, remove all foods with an outdated rating before getting the topmost food.\\n\\n**Time Complexity**: \\n  initialization: `O(n log(n))`\\n  changeRating: `O(log(n))`\\n  highestRated: `O(m log(m))` worst case, but will never be more than `O(m log(m))` for the total number of calls (`m` is the number of calls)\\n**Space Complexity**: `O(n)`\\n```\\nvar FoodRatings = function(foods, cuisines, ratings) {\\n  this.heaps = {}, this.foods = {};\\n  let n = foods.length;\\n  for (let i = 0; i < n; i++) {\\n    let food = foods[i], cuisine = cuisines[i], rating = ratings[i];\\n    if (!this.heaps[cuisine]) this.heaps[cuisine] = new PriorityQueue((a, b) => { // [food, rating]\\n      return a[1] === b[1] ? a[0].localeCompare(b[0]) : b[1] - a[1];\\n    })\\n    this.heaps[cuisine].add([food, rating]);\\n    this.foods[food] = { cuisine, rating };\\n  } \\n};\\n\\nFoodRatings.prototype.changeRating = function(food, newRating) {\\n  this.foods[food].rating = newRating;\\n  let { cuisine } = this.foods[food];\\n  this.heaps[cuisine].add([food, newRating]);\\n};\\n\\nFoodRatings.prototype.highestRated = function(cuisine) {\\n  let heap = this.heaps[cuisine];  \\n  while (this.foods[heap.top()[0]].rating !== heap.top()[1]) {\\n    heap.remove();\\n  }\\n  return heap.top()[0];\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar FoodRatings = function(foods, cuisines, ratings) {\\n  this.heaps = {}, this.foods = {};\\n  let n = foods.length;\\n  for (let i = 0; i < n; i++) {\\n    let food = foods[i], cuisine = cuisines[i], rating = ratings[i];\\n    if (!this.heaps[cuisine]) this.heaps[cuisine] = new PriorityQueue((a, b) => { // [food, rating]\\n      return a[1] === b[1] ? a[0].localeCompare(b[0]) : b[1] - a[1];\\n    })\\n    this.heaps[cuisine].add([food, rating]);\\n    this.foods[food] = { cuisine, rating };\\n  } \\n};\\n\\nFoodRatings.prototype.changeRating = function(food, newRating) {\\n  this.foods[food].rating = newRating;\\n  let { cuisine } = this.foods[food];\\n  this.heaps[cuisine].add([food, newRating]);\\n};\\n\\nFoodRatings.prototype.highestRated = function(cuisine) {\\n  let heap = this.heaps[cuisine];  \\n  while (this.foods[heap.top()[0]].rating !== heap.top()[1]) {\\n    heap.remove();\\n  }\\n  return heap.top()[0];\\n};\\n\\nclass PriorityQueue {\\n  constructor(comparator = ((a, b) => a - b)) {\\n    this.values = [];\\n    this.comparator = comparator;\\n    this.size = 0;\\n  }\\n  add(val) {\\n    this.size++;\\n    this.values.push(val);\\n    let idx = this.size - 1, parentIdx = Math.floor((idx - 1) / 2);\\n    while (parentIdx >= 0 && this.comparator(this.values[parentIdx], this.values[idx]) > 0) {\\n      [this.values[parentIdx], this.values[idx]] = [this.values[idx], this.values[parentIdx]];\\n      idx = parentIdx;\\n      parentIdx = Math.floor((idx - 1) / 2);\\n    }\\n  }\\n  remove() {\\n    if (this.size === 0) return -1;\\n    this.size--;\\n    if (this.size === 0) return this.values.pop();\\n    let removedVal = this.values[0];\\n    this.values[0] = this.values.pop();\\n    let idx = 0;\\n    while (idx < this.size && idx < Math.floor(this.size / 2)) {\\n      let leftIdx = idx * 2 + 1, rightIdx = idx * 2 + 2;\\n      if (rightIdx === this.size) {\\n        if (this.comparator(this.values[leftIdx], this.values[idx]) > 0) break;\\n        [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n        idx = leftIdx;\\n      } else if (this.comparator(this.values[leftIdx], this.values[idx]) < 0 || this.comparator(this.values[rightIdx], this.values[idx]) < 0) {\\n        if (this.comparator(this.values[leftIdx], this.values[rightIdx]) <= 0) {\\n          [this.values[leftIdx], this.values[idx]] = [this.values[idx], this.values[leftIdx]];\\n          idx = leftIdx;\\n        } else {\\n          [this.values[rightIdx], this.values[idx]] = [this.values[idx], this.values[rightIdx]];\\n          idx = rightIdx;\\n        }\\n      } else {\\n        break;\\n      }\\n    }\\n    return removedVal;\\n  }\\n  top() {\\n    return this.values[0];\\n  }\\n  isEmpty() {\\n    return this.size === 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324702,
                "title": "map-set-c",
                "content": "```\\nclass FoodRatings {\\nprivate:\\n    map<string,int> m;\\n    set<pair<int,string>> f[100];\\n    map<string,pair<int,int>> ff;\\n    int size = 0;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<ratings.size();++i){\\n            \\n            if(m.find(cuisines[i])!= m.end()){\\n                f[m[cuisines[i]]].insert({-1*ratings[i],foods[i]});\\n            }else{\\n                set<int,string> temp;\\n                m[cuisines[i]] = size;\\n                f[size].insert({-1*ratings[i],foods[i]});\\n                ++size;\\n            }\\n            ff[foods[i]] = {ratings[i],m[cuisines[i]]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int nrr) {\\n        pair<int,int> remp = ff[food];\\n        int orr = remp.first, i = remp.second;\\n        f[i].erase({-1*orr,food});\\n        f[i].insert({-1*nrr,food});\\n        ff[food] = {nrr,i};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        int i = m[cuisine];\\n        auto it = f[i].begin();\\n        \\n        pair<int,string> temp = *it;\\n        \\n        return temp.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FoodRatings {\\nprivate:\\n    map<string,int> m;\\n    set<pair<int,string>> f[100];\\n    map<string,pair<int,int>> ff;\\n    int size = 0;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<ratings.size();++i){\\n            \\n            if(m.find(cuisines[i])!= m.end()){\\n                f[m[cuisines[i]]].insert({-1*ratings[i],foods[i]});\\n            }else{\\n                set<int,string> temp;\\n                m[cuisines[i]] = size;\\n                f[size].insert({-1*ratings[i],foods[i]});\\n                ++size;\\n            }\\n            ff[foods[i]] = {ratings[i],m[cuisines[i]]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int nrr) {\\n        pair<int,int> remp = ff[food];\\n        int orr = remp.first, i = remp.second;\\n        f[i].erase({-1*orr,food});\\n        f[i].insert({-1*nrr,food});\\n        ff[food] = {nrr,i};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        int i = m[cuisine];\\n        auto it = f[i].begin();\\n        \\n        pair<int,string> temp = *it;\\n        \\n        return temp.second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324676,
                "title": "c-easy-2-maps-with-explanation",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    //cuis -> map[rating -> set[dish]]\\n    map<string, map<int,set<string>>> mc;\\n    //dish -> pair of {rating, cuisine}\\n    map<string, pair<int,string>> md;\\n    FoodRatings(vector<string>& food, vector<string>& cuisine, vector<int>& rating) {\\n        for(int i=0;i<food.size();i++){                      //insert in maps\\n            mc[cuisine[i]][rating[i]].insert(food[i]);\\n            md[food[i]]={rating[i],cuisine[i]};\\n        }\\n    }\\n    \\n    void changeRating(string f, int n) {\\n        if(md.find(f)==md.end()) return;  // if this food don\\'t exsist \\n        auto p=md[f];\\n        int rate=p.first;\\n        string cuise=p.second;\\n        \\n        mc[cuise][rate].erase(f);    //update cuisine map\\n        mc[cuise][n].insert(f);\\n        if(mc[cuise][rate].size()==0) mc[cuise].erase(rate);   //if rate set has size zero, then remove that rating entry for that cuisine\\n        \\n        md[f].first=n;    //update food map\\n    }\\n    \\n    string highestRated(string c) {\\n        if(mc.find(c)==mc.end()) return \"\";   //if cuisine don\\'t exist\\n        auto i = mc[c].rbegin();                // fetch last rating(highest) of that cuisne\\n        auto st=i->second;                    // fetch set (foods) with that rating\\n        return *st.begin();                      // return first food (lexo. smallest)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    //cuis -> map[rating -> set[dish]]\\n    map<string, map<int,set<string>>> mc;\\n    //dish -> pair of {rating, cuisine}\\n    map<string, pair<int,string>> md;\\n    FoodRatings(vector<string>& food, vector<string>& cuisine, vector<int>& rating) {\\n        for(int i=0;i<food.size();i++){                      //insert in maps\\n            mc[cuisine[i]][rating[i]].insert(food[i]);\\n            md[food[i]]={rating[i],cuisine[i]};\\n        }\\n    }\\n    \\n    void changeRating(string f, int n) {\\n        if(md.find(f)==md.end()) return;  // if this food don\\'t exsist \\n        auto p=md[f];\\n        int rate=p.first;\\n        string cuise=p.second;\\n        \\n        mc[cuise][rate].erase(f);    //update cuisine map\\n        mc[cuise][n].insert(f);\\n        if(mc[cuise][rate].size()==0) mc[cuise].erase(rate);   //if rate set has size zero, then remove that rating entry for that cuisine\\n        \\n        md[f].first=n;    //update food map\\n    }\\n    \\n    string highestRated(string c) {\\n        if(mc.find(c)==mc.end()) return \"\";   //if cuisine don\\'t exist\\n        auto i = mc[c].rbegin();                // fetch last rating(highest) of that cuisne\\n        auto st=i->second;                    // fetch set (foods) with that rating\\n        return *st.begin();                      // return first food (lexo. smallest)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324670,
                "title": "c-set-map-easy-solution-no-compare-function",
                "content": "```\\n#include <type_traits>\\nclass FoodRatings {\\npublic:\\n \\n    map<string,set<pair<int,string>>>mp;\\n    map<string,pair<string,int>>mp1;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        mp.clear();\\n        mp1.clear();\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            string a = foods[i];\\n            string b = cuisines[i];\\n            int c = ratings[i];\\n            mp1[a]={b,c};\\n            mp[b].insert({c,a});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string a = mp1[food].first;\\n        int b = mp1[food].second;\\n       \\n        mp[a].erase({b,food});\\n        mp[a].insert({newRating,food});\\n        mp1[food]={a,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n\\n        auto s1 = (mp[cuisine].end());\\n        s1--;\\n        int s = s1->first;\\n        auto it = mp[cuisine].lower_bound({s,\"a\"});\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n#include <type_traits>\\nclass FoodRatings {\\npublic:\\n \\n    map<string,set<pair<int,string>>>mp;\\n    map<string,pair<string,int>>mp1;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        mp.clear();\\n        mp1.clear();\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            string a = foods[i];\\n            string b = cuisines[i];\\n            int c = ratings[i];\\n            mp1[a]={b,c};\\n            mp[b].insert({c,a});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string a = mp1[food].first;\\n        int b = mp1[food].second;\\n       \\n        mp[a].erase({b,food});\\n        mp[a].insert({newRating,food});\\n        mp1[food]={a,newRating};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n\\n        auto s1 = (mp[cuisine].end());\\n        s1--;\\n        int s = s1->first;\\n        auto it = mp[cuisine].lower_bound({s,\"a\"});\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324640,
                "title": "hashmap-set-c",
                "content": "```\\nclass FoodRatings {\\nprivate:\\n    struct cmp{\\n        bool operator()(const pair<int,string> &p1,const pair<int,string> &p2) const{\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;\\n        }\\n    };    \\n    \\n    unordered_map<string,unordered_map<string,int>> mp1; // cuisine -> {food, rating}\\n    unordered_map<string,set<pair<int,string>,cmp>> mp2; // cuisine -> {rating,food} - in decreasing order of rating and incr. order of name\\n    unordered_map<string,string> mp3; // food -> cuisine    \\npublic:    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            auto &mp = mp1[cuisines[i]];\\n            mp[foods[i]] = ratings[i];       \\n            \\n            auto &st = mp2[cuisines[i]];\\n            st.insert({ratings[i],foods[i]});            \\n            \\n            mp3[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto &name = mp3[food];\\n        auto &rating = mp1[name][food];\\n        \\n        auto &st = mp2[name];\\n        st.erase({rating,food});\\n        st.insert({newRating,food});\\n        \\n        mp1[name][food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*(mp2[cuisine].begin())).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\nprivate:\\n    struct cmp{\\n        bool operator()(const pair<int,string> &p1,const pair<int,string> &p2) const{\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;\\n        }\\n    };    \\n    \\n    unordered_map<string,unordered_map<string,int>> mp1; // cuisine -> {food, rating}\\n    unordered_map<string,set<pair<int,string>,cmp>> mp2; // cuisine -> {rating,food} - in decreasing order of rating and incr. order of name\\n    unordered_map<string,string> mp3; // food -> cuisine    \\npublic:    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            auto &mp = mp1[cuisines[i]];\\n            mp[foods[i]] = ratings[i];       \\n            \\n            auto &st = mp2[cuisines[i]];\\n            st.insert({ratings[i],foods[i]});            \\n            \\n            mp3[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto &name = mp3[food];\\n        auto &rating = mp1[name][food];\\n        \\n        auto &st = mp2[name];\\n        st.erase({rating,food});\\n        st.insert({newRating,food});\\n        \\n        mp1[name][food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*(mp2[cuisine].begin())).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088068,
                "title": "c-python-heap-binary-search-tree-solution-with-explanation",
                "content": "### max heap + lazy remove\\nwe have 3 tables,\\nmx_heap record each cuisine\\'s max heap,\\ncuisines record each food\\'s cuisine,\\nfoods record each food\\'s rating.\\n\\nchangeRating just change food\\'s rating in table foods,\\nand push a new food and new rating pair into max heap.\\n\\nhighestRated find the max rating food in max heap,\\nif rating top of heap != rating in table foods, this pair is invalid, pop it until we meet a valid pair.\\n\\ntc of highestRated and changeRating is O(logn), sc is O(n).\\n\\n### python\\n\\n```python\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.mx_heap = defaultdict(list)\\n        self.cuisines = {}\\n        self.foods = {}\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.mx_heap[c].append((-r, f))\\n            self.cuisines[f] = c\\n            self.foods[f] = r\\n        for h in self.mx_heap.values():\\n            heapify(h)\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.foods[food] = newRating\\n        heappush(self.mx_heap[self.cuisines[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        h = self.mx_heap[cuisine]\\n        while h and -h[0][0] != self.foods[h[0][1]]:\\n            heappop(h)\\n        return h[0][1]\\n```\\n\\n### c++\\n```cpp\\nclass FoodRatings {\\n    unordered_map<string, int> food_;\\n    unordered_map<string, string> cuisine_;\\n    unordered_map<string, priority_queue<pair<int, string>, vector<pair<int, string>>, greater<>>> mn_heap;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); i+=1) {\\n            string& f = foods[i], &c = cuisines[i];\\n            int& r = ratings[i];\\n            food_[f] = r;\\n            cuisine_[f] = c;\\n            mn_heap[c].emplace(-r, f);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        food_[food] = newRating;\\n        mn_heap[cuisine_[food]].emplace(-newRating, food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto& h = mn_heap[cuisine];\\n        while (!h.empty() && -h.top().first != food_[h.top().second])\\n            h.pop();\\n        return h.top().second;\\n    }\\n};\\n```\\n\\n### binary search tree\\n```python\\nfrom sortedcontainers import SortedSet\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.bst = defaultdict(SortedSet)\\n        self.food = {}\\n        self.cuisine = {}\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.cuisine[f] = c\\n            self.food[f] = r\\n            self.bst[c].add((-r, f))\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.bst[self.cuisine[food]].remove((-self.food[food], food))\\n        self.food[food] = newRating\\n        self.bst[self.cuisine[food]].add((-newRating, food));\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.bst[cuisine][0][1]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.mx_heap = defaultdict(list)\\n        self.cuisines = {}\\n        self.foods = {}\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.mx_heap[c].append((-r, f))\\n            self.cuisines[f] = c\\n            self.foods[f] = r\\n        for h in self.mx_heap.values():\\n            heapify(h)\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.foods[food] = newRating\\n        heappush(self.mx_heap[self.cuisines[food]], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        h = self.mx_heap[cuisine]\\n        while h and -h[0][0] != self.foods[h[0][1]]:\\n            heappop(h)\\n        return h[0][1]\\n```\n```cpp\\nclass FoodRatings {\\n    unordered_map<string, int> food_;\\n    unordered_map<string, string> cuisine_;\\n    unordered_map<string, priority_queue<pair<int, string>, vector<pair<int, string>>, greater<>>> mn_heap;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); i+=1) {\\n            string& f = foods[i], &c = cuisines[i];\\n            int& r = ratings[i];\\n            food_[f] = r;\\n            cuisine_[f] = c;\\n            mn_heap[c].emplace(-r, f);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        food_[food] = newRating;\\n        mn_heap[cuisine_[food]].emplace(-newRating, food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto& h = mn_heap[cuisine];\\n        while (!h.empty() && -h.top().first != food_[h.top().second])\\n            h.pop();\\n        return h.top().second;\\n    }\\n};\\n```\n```python\\nfrom sortedcontainers import SortedSet\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.bst = defaultdict(SortedSet)\\n        self.food = {}\\n        self.cuisine = {}\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.cuisine[f] = c\\n            self.food[f] = r\\n            self.bst[c].add((-r, f))\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.bst[self.cuisine[food]].remove((-self.food[food], food))\\n        self.food[food] = newRating\\n        self.bst[self.cuisine[food]].add((-newRating, food));\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.bst[cuisine][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078961,
                "title": "python3-very-easy-heap-and-lazy-deletion",
                "content": "```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.f2c = {}\\n        self.f2r = defaultdict(int)\\n        self.c2fr = defaultdict(list)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.f2c[f] = c\\n            self.f2r[f] = r\\n            heappush(self.c2fr[c], (-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        if newRating == self.f2r[food]:\\n            return\\n        heap = self.c2fr[self.f2c[food]]\\n        heappush(heap, (-newRating, food))\\n        self.f2r[food] = newRating\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        heap = self.c2fr[cuisine]\\n        while self.f2r[heap[0][1]] != -heap[0][0]:\\n            heappop(heap)\\n        return heap[0][1]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.f2c = {}\\n        self.f2r = defaultdict(int)\\n        self.c2fr = defaultdict(list)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.f2c[f] = c\\n            self.f2r[f] = r\\n            heappush(self.c2fr[c], (-r, f))\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        if newRating == self.f2r[food]:\\n            return\\n        heap = self.c2fr[self.f2c[food]]\\n        heappush(heap, (-newRating, food))\\n        self.f2r[food] = newRating\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        heap = self.c2fr[cuisine]\\n        while self.f2r[heap[0][1]] != -heap[0][0]:\\n            heappop(heap)\\n        return heap[0][1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014627,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass FoodRatings {\\n\\n    private HashMap<String, TreeMap<Integer, TreeSet<String>>> map;\\n    private HashMap<String, List<String>> pairs;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = initialize(foods, cuisines, ratings);\\n    }\\n\\n    private HashMap<String, TreeMap<Integer, TreeSet<String>>> initialize(String[] food, String[] cuisine, int[] rating) {\\n        pairs = new HashMap<>();\\n        map = new HashMap<>();\\n        for (int i = 0; i < cuisine.length; i++) {\\n            map.putIfAbsent(cuisine[i], new TreeMap<>());\\n            map.get(cuisine[i]).putIfAbsent(rating[i], new TreeSet<>());\\n            map.get(cuisine[i]).get(rating[i]).add(food[i]);\\n            pairs.put(food[i], List.of(String.valueOf(rating[i]), cuisine[i]));\\n        }\\n        return map;\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = pairs.get(food).get(1);\\n        int rating = Integer.parseInt(pairs.get(food).get(0));\\n        pairs.put(food, List.of(String.valueOf(newRating), cuisine));\\n        if (map.get(cuisine).get(rating).size() == 1) {\\n            map.get(cuisine).remove(rating);\\n        } else {\\n            map.get(cuisine).get(rating).remove(food);\\n        }\\n        map.get(cuisine).putIfAbsent(newRating, new TreeSet<>());\\n        map.get(cuisine).get(newRating).add(food);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).get(map.get(cuisine).lastKey()).first();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    private HashMap<String, TreeMap<Integer, TreeSet<String>>> map;\\n    private HashMap<String, List<String>> pairs;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = initialize(foods, cuisines, ratings);\\n    }\\n\\n    private HashMap<String, TreeMap<Integer, TreeSet<String>>> initialize(String[] food, String[] cuisine, int[] rating) {\\n        pairs = new HashMap<>();\\n        map = new HashMap<>();\\n        for (int i = 0; i < cuisine.length; i++) {\\n            map.putIfAbsent(cuisine[i], new TreeMap<>());\\n            map.get(cuisine[i]).putIfAbsent(rating[i], new TreeSet<>());\\n            map.get(cuisine[i]).get(rating[i]).add(food[i]);\\n            pairs.put(food[i], List.of(String.valueOf(rating[i]), cuisine[i]));\\n        }\\n        return map;\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = pairs.get(food).get(1);\\n        int rating = Integer.parseInt(pairs.get(food).get(0));\\n        pairs.put(food, List.of(String.valueOf(newRating), cuisine));\\n        if (map.get(cuisine).get(rating).size() == 1) {\\n            map.get(cuisine).remove(rating);\\n        } else {\\n            map.get(cuisine).get(rating).remove(food);\\n        }\\n        map.get(cuisine).putIfAbsent(newRating, new TreeSet<>());\\n        map.get(cuisine).get(newRating).add(food);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        return map.get(cuisine).get(map.get(cuisine).lastKey()).first();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967710,
                "title": "java-clean-3-maps-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1) for highestRated\\nO(Log(ratings)) for changeRating\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\n     Map<String, Integer> foodToRating = new HashMap();\\n  Map<String, String> foodToCuisine = new HashMap();\\n  Map<String, TreeMap<Integer, Set<String>>> cuisineToRating = new HashMap();\\n\\n  public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n    for(int i=0; i< foods.length; i++){\\n      var food = foods[i];\\n      var rating = ratings[i];\\n      var cuisine = cuisines[i];\\n      foodToRating.put(food, rating);\\n      foodToCuisine.put(food, cuisine);\\n\\n      cuisineToRating.putIfAbsent(cuisine, new TreeMap(Collections.reverseOrder()));\\n      cuisineToRating.get(cuisine).putIfAbsent(rating, new TreeSet());\\n      cuisineToRating.get(cuisine).get(rating).add(food);\\n\\n    }\\n  }\\n\\n  public void changeRating(String food, int newRating) {\\n    var oldRating = foodToRating.get(food);\\n           if(oldRating==newRating) return;\\n\\n\\n    foodToRating.put(food, newRating);\\n    var cuisine = foodToCuisine.get(food);\\n    cuisineToRating.get(cuisine).putIfAbsent(newRating, new TreeSet());\\n    cuisineToRating.get(cuisine).get(newRating).add(food);\\n\\n    cuisineToRating.get(cuisine).get(oldRating).remove(food);\\n    if(cuisineToRating.get(cuisine).get(oldRating).size()==0){\\n      cuisineToRating.get(cuisine).remove(oldRating);\\n    }\\n  }\\n\\n  public String highestRated(String cuisine) {\\n    Set<String> names = cuisineToRating.get(cuisine).firstEntry().getValue();\\n    return names.iterator().next();\\n  }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n     Map<String, Integer> foodToRating = new HashMap();\\n  Map<String, String> foodToCuisine = new HashMap();\\n  Map<String, TreeMap<Integer, Set<String>>> cuisineToRating = new HashMap();\\n\\n  public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n    for(int i=0; i< foods.length; i++){\\n      var food = foods[i];\\n      var rating = ratings[i];\\n      var cuisine = cuisines[i];\\n      foodToRating.put(food, rating);\\n      foodToCuisine.put(food, cuisine);\\n\\n      cuisineToRating.putIfAbsent(cuisine, new TreeMap(Collections.reverseOrder()));\\n      cuisineToRating.get(cuisine).putIfAbsent(rating, new TreeSet());\\n      cuisineToRating.get(cuisine).get(rating).add(food);\\n\\n    }\\n  }\\n\\n  public void changeRating(String food, int newRating) {\\n    var oldRating = foodToRating.get(food);\\n           if(oldRating==newRating) return;\\n\\n\\n    foodToRating.put(food, newRating);\\n    var cuisine = foodToCuisine.get(food);\\n    cuisineToRating.get(cuisine).putIfAbsent(newRating, new TreeSet());\\n    cuisineToRating.get(cuisine).get(newRating).add(food);\\n\\n    cuisineToRating.get(cuisine).get(oldRating).remove(food);\\n    if(cuisineToRating.get(cuisine).get(oldRating).size()==0){\\n      cuisineToRating.get(cuisine).remove(oldRating);\\n    }\\n  }\\n\\n  public String highestRated(String cuisine) {\\n    Set<String> names = cuisineToRating.get(cuisine).firstEntry().getValue();\\n    return names.iterator().next();\\n  }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922674,
                "title": "heap-hashmap-python3-solution",
                "content": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.rating = {}\\n        self.cuisines = defaultdict(list)\\n        self.food_cuisine = {}\\n        \\n        for i in range(len(foods)):\\n            food, r, cuisine = foods[i], ratings[i], cuisines[i]\\n            self.rating[food] = -r\\n            self.food_cuisine[food] = cuisine\\n            heapq.heappush(self.cuisines[cuisine], (-r, food))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.rating[food] = -newRating\\n        cuisine = self.food_cuisine[food]\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.rating[self.cuisines[cuisine][0][1]] != self.cuisines[cuisine][0][0]:\\n            heapq.heappop(self.cuisines[cuisine])\\n            \\n        return self.cuisines[cuisine][0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.rating = {}\\n        self.cuisines = defaultdict(list)\\n        self.food_cuisine = {}\\n        \\n        for i in range(len(foods)):\\n            food, r, cuisine = foods[i], ratings[i], cuisines[i]\\n            self.rating[food] = -r\\n            self.food_cuisine[food] = cuisine\\n            heapq.heappush(self.cuisines[cuisine], (-r, food))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.rating[food] = -newRating\\n        cuisine = self.food_cuisine[food]\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.rating[self.cuisines[cuisine][0][1]] != self.cuisines[cuisine][0][0]:\\n            heapq.heappop(self.cuisines[cuisine])\\n            \\n        return self.cuisines[cuisine][0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906313,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass FoodRatings {\\n    HashMap<String,ArrayList<Integer>> cuisineRatingMap;\\n    HashMap<String,HashMap<Integer,TreeMap<String,Integer>>> map;\\n    HashMap<String,String> foodCusineMap=new HashMap<String,String>();\\n    HashMap<String,Integer> foodRatingMap=new HashMap<String,Integer>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineRatingMap=new HashMap<String,ArrayList<Integer>>();\\n        map=new HashMap<String,HashMap<Integer,TreeMap<String,Integer>>>();\\n        for(int i=0;i<foods.length;i++)\\n        {\\n            foodCusineMap.put(foods[i],cuisines[i]);\\n            foodRatingMap.put(foods[i],ratings[i]);\\n            if(!map.containsKey(cuisines[i]))\\n            {\\n                HashMap<Integer,TreeMap<String,Integer>> h=new HashMap<Integer,TreeMap<String,Integer>>();\\n                TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n                tmap.put(foods[i],1);\\n                h.put(ratings[i],tmap);\\n                map.put(cuisines[i],h);\\n            }\\n            else\\n            {\\n                HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisines[i]);\\n                if(h.containsKey(ratings[i]))\\n                {\\n                    TreeMap<String,Integer> tmap=h.get(ratings[i]);\\n                    tmap.put(foods[i],1);\\n                    h.put(ratings[i],tmap);\\n                    map.put(cuisines[i],h);\\n                }\\n                else\\n                {\\n                    TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n                    tmap.put(foods[i],1);\\n                    h.put(ratings[i],tmap);\\n                    map.put(cuisines[i],h);\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<cuisines.length;i++)\\n        {\\n            if(!cuisineRatingMap.containsKey(cuisines[i]))\\n            {\\n                ArrayList<Integer> l=new ArrayList<Integer>();\\n                l.add(ratings[i]);\\n                cuisineRatingMap.put(cuisines[i],l);\\n            }\\n            else\\n            {\\n                ArrayList<Integer> l=cuisineRatingMap.get(cuisines[i]);\\n                int low=0,high=l.size()-1,index=0;\\n                while(low<=high)\\n                {\\n                    int mid=(low+high)/2;\\n                    if(l.get(mid)>ratings[i])\\n                    {\\n                        index=mid;\\n                        high=mid-1;\\n                    }\\n                    else\\n                    {\\n                        index=mid+1;\\n                        low=mid+1;\\n                    }\\n                }\\n                l.add(index,ratings[i]);\\n                cuisineRatingMap.put(cuisines[i],l);\\n            }\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine=foodCusineMap.get(food);\\n        int prevRating=foodRatingMap.get(food);\\n        foodRatingMap.put(food,newRating);\\n        ArrayList<Integer> l=cuisineRatingMap.get(cuisine);\\n        int low=0,high=l.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(l.get(mid)==prevRating)\\n            {\\n                l.remove(mid);\\n                break;\\n            }\\n            else if(l.get(mid)>prevRating)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        low=0;\\n        high=l.size()-1;\\n        int index=0;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(l.get(mid)>newRating)\\n            {\\n                index=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                index=mid+1;\\n                low=mid+1;\\n            }\\n        }\\n        l.add(index,newRating);\\n        cuisineRatingMap.put(cuisine,l);\\n        HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisine);\\n        h.get(prevRating).remove(food);\\n        if(h.get(prevRating).size()==0)\\n        {\\n            h.remove(prevRating);\\n        }\\n        if(!h.containsKey(newRating))\\n        {\\n            TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n            tmap.put(food,1);\\n            h.put(newRating,tmap);\\n        }\\n        else\\n        {\\n            TreeMap<String,Integer> tmap=h.get(newRating);\\n            tmap.put(food,1);\\n            h.put(newRating,tmap);\\n        }\\n         map.put(cuisine,h);\\n        \\n\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        ArrayList<Integer> l=cuisineRatingMap.get(cuisine);\\n        int highestRating= l.get(l.size()-1);\\n        HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisine);\\n        return h.get(highestRating).firstKey();\\n\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n    HashMap<String,ArrayList<Integer>> cuisineRatingMap;\\n    HashMap<String,HashMap<Integer,TreeMap<String,Integer>>> map;\\n    HashMap<String,String> foodCusineMap=new HashMap<String,String>();\\n    HashMap<String,Integer> foodRatingMap=new HashMap<String,Integer>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisineRatingMap=new HashMap<String,ArrayList<Integer>>();\\n        map=new HashMap<String,HashMap<Integer,TreeMap<String,Integer>>>();\\n        for(int i=0;i<foods.length;i++)\\n        {\\n            foodCusineMap.put(foods[i],cuisines[i]);\\n            foodRatingMap.put(foods[i],ratings[i]);\\n            if(!map.containsKey(cuisines[i]))\\n            {\\n                HashMap<Integer,TreeMap<String,Integer>> h=new HashMap<Integer,TreeMap<String,Integer>>();\\n                TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n                tmap.put(foods[i],1);\\n                h.put(ratings[i],tmap);\\n                map.put(cuisines[i],h);\\n            }\\n            else\\n            {\\n                HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisines[i]);\\n                if(h.containsKey(ratings[i]))\\n                {\\n                    TreeMap<String,Integer> tmap=h.get(ratings[i]);\\n                    tmap.put(foods[i],1);\\n                    h.put(ratings[i],tmap);\\n                    map.put(cuisines[i],h);\\n                }\\n                else\\n                {\\n                    TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n                    tmap.put(foods[i],1);\\n                    h.put(ratings[i],tmap);\\n                    map.put(cuisines[i],h);\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<cuisines.length;i++)\\n        {\\n            if(!cuisineRatingMap.containsKey(cuisines[i]))\\n            {\\n                ArrayList<Integer> l=new ArrayList<Integer>();\\n                l.add(ratings[i]);\\n                cuisineRatingMap.put(cuisines[i],l);\\n            }\\n            else\\n            {\\n                ArrayList<Integer> l=cuisineRatingMap.get(cuisines[i]);\\n                int low=0,high=l.size()-1,index=0;\\n                while(low<=high)\\n                {\\n                    int mid=(low+high)/2;\\n                    if(l.get(mid)>ratings[i])\\n                    {\\n                        index=mid;\\n                        high=mid-1;\\n                    }\\n                    else\\n                    {\\n                        index=mid+1;\\n                        low=mid+1;\\n                    }\\n                }\\n                l.add(index,ratings[i]);\\n                cuisineRatingMap.put(cuisines[i],l);\\n            }\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cuisine=foodCusineMap.get(food);\\n        int prevRating=foodRatingMap.get(food);\\n        foodRatingMap.put(food,newRating);\\n        ArrayList<Integer> l=cuisineRatingMap.get(cuisine);\\n        int low=0,high=l.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(l.get(mid)==prevRating)\\n            {\\n                l.remove(mid);\\n                break;\\n            }\\n            else if(l.get(mid)>prevRating)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        low=0;\\n        high=l.size()-1;\\n        int index=0;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(l.get(mid)>newRating)\\n            {\\n                index=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                index=mid+1;\\n                low=mid+1;\\n            }\\n        }\\n        l.add(index,newRating);\\n        cuisineRatingMap.put(cuisine,l);\\n        HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisine);\\n        h.get(prevRating).remove(food);\\n        if(h.get(prevRating).size()==0)\\n        {\\n            h.remove(prevRating);\\n        }\\n        if(!h.containsKey(newRating))\\n        {\\n            TreeMap<String,Integer> tmap=new TreeMap<String,Integer>();\\n            tmap.put(food,1);\\n            h.put(newRating,tmap);\\n        }\\n        else\\n        {\\n            TreeMap<String,Integer> tmap=h.get(newRating);\\n            tmap.put(food,1);\\n            h.put(newRating,tmap);\\n        }\\n         map.put(cuisine,h);\\n        \\n\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        ArrayList<Integer> l=cuisineRatingMap.get(cuisine);\\n        int highestRating= l.get(l.size()-1);\\n        HashMap<Integer,TreeMap<String,Integer>> h=map.get(cuisine);\\n        return h.get(highestRating).firstKey();\\n\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894400,
                "title": "solution-via-a-ptr-to-structure",
                "content": "# Intuition\\nLet\\'s have a look at the required Interface. We have to implement 2 functions.\\nhighestRated - supposed to return best in cuisine, so it leads to the thought that it would be nice to take this value from some container that is already sorted. Since we get as an argument about cuisine, the container is supposed to be like cuisine - set<Food*>. For Food* we can use sort of a structure with overwritten operator<(or something similar).\\nAs fields we can take name and rating since they both take part in comparison\\\\sorting.\\nWe only need to take care of updating it in the set.\\n <!-- Describe your first thoughts on how to solve this problem. -->\\n\\n # Approach\\n The real issue comes when we want to update our rating.\\n 1. We need to have an access cuisine - set<Food*> when we update. So this \\n particular struct Food* has to be found in the whole structure(cuisine - set<Food*>).\\n 2. Even if we have Food* we still need to know the cuisine to know in which set we shall seek.\\n\\n Since changeRating accepts food\\'s name, we can connect food - Food* as well.\\n Thus we get by 1nd obstacle. The 2nd obstacle can be managed by adding cuisine to the field of Food*. Thus knowing the name of food, we can access it in cuisine - set<Food*>. Having access we can simply remove, update Food* ptr with a new rating(no need to create a new object), and insert it back.\\n\\n We end up with 2 containers:\\n <food - Food*> m_foods;\\n <cusine - set<Food*>> m_chart;\\n For both, unordered_map is a good solution. (Since we need mostly to find elements)\\n\\n For putting Food* (pointers) in the set, we also will write a custom comparator with the overloaded operator() for the set. Implementation of operator() has logic described in the task itself(bigger rating first but if ratings are same, return lexically higher).\\n\\n <!-- Describe your approach to solving the problem. -->\\n\\n # Complexity\\n - Time complexity:\\n - FoodRatings - O(n * log n)\\n We have a cycle, and on each iteration, we have log i complexity. We have log i complexity because we insert in set, and the worst case is when we have only one type of kitchen. It leads to Log(1*2*3*..n) -> (Stirling\\'s formula, approx.) = n log(n). \\n - changeRating - O(log n).\\n Delete and insert have O(log n) complexity, all the rest is constant.\\n - highestRated - O(1).\\n <!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n), to be more precise O(2n) since we have 2 unordered_maps + ~O(3n)\\n- space for Food struct. And don\\'t forget to clean up the space in the real world or wrap up raw pointers!\\n <!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\n    struct Food{\\n        string name;\\n        string cusine;\\n        int rating;\\n\\n        Food(){\\n        }\\n\\n        Food(const string& _name, int _rating, const string& _cusine){\\n            name = _name;\\n            rating = _rating;\\n            cusine = _cusine;\\n        }\\n    };\\n\\n    struct CustomCmp {\\n    bool operator()(const Food* lhs, const Food* rhs) const { \\n            if(lhs->rating == rhs->rating)\\n                return lhs->name < rhs->name;\\n            return lhs->rating > rhs->rating;\\n    }\\n};\\n    unordered_map<string, Food*> m_cuisines; // food Food*\\n    unordered_map<string, set<Food*, CustomCmp>> m_chart; // cousine - set(of foods*)\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0; i != foods.size(); ++i){\\n            Food* f = new Food(foods[i], ratings[i], cuisines[i]);\\n            m_cuisines[foods[i]] = f;\\n            m_chart[cuisines[i]].insert(f);\\n        }\\n    }\\n\\n    void changeRating(const string &food, int newRating) {\\n        auto f = m_cuisines[food];\\n        m_chart[f->cusine].erase(f);\\n        f->rating = newRating;\\n        m_chart[f->cusine].insert(f);\\n\\n    }\\n\\n    string highestRated(const string& cuisine) {\\n        return (*m_chart[cuisine].begin())->name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\n    struct Food{\\n        string name;\\n        string cusine;\\n        int rating;\\n\\n        Food(){\\n        }\\n\\n        Food(const string& _name, int _rating, const string& _cusine){\\n            name = _name;\\n            rating = _rating;\\n            cusine = _cusine;\\n        }\\n    };\\n\\n    struct CustomCmp {\\n    bool operator()(const Food* lhs, const Food* rhs) const { \\n            if(lhs->rating == rhs->rating)\\n                return lhs->name < rhs->name;\\n            return lhs->rating > rhs->rating;\\n    }\\n};\\n    unordered_map<string, Food*> m_cuisines; // food Food*\\n    unordered_map<string, set<Food*, CustomCmp>> m_chart; // cousine - set(of foods*)\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0; i != foods.size(); ++i){\\n            Food* f = new Food(foods[i], ratings[i], cuisines[i]);\\n            m_cuisines[foods[i]] = f;\\n            m_chart[cuisines[i]].insert(f);\\n        }\\n    }\\n\\n    void changeRating(const string &food, int newRating) {\\n        auto f = m_cuisines[food];\\n        m_chart[f->cusine].erase(f);\\n        f->rating = newRating;\\n        m_chart[f->cusine].insert(f);\\n\\n    }\\n\\n    string highestRated(const string& cuisine) {\\n        return (*m_chart[cuisine].begin())->name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834831,
                "title": "c-faster-than-100-using-2-maps",
                "content": "```\\n#define pii pair<int,string>\\nclass Compare\\n{\\npublic:\\n    bool operator() (pii p1,pii p2)\\n    {\\n        if(p1.first<p2.first)\\n            return true;\\n        else if(p1.first==p2.first)\\n        {\\n            return (p1.second>p2.second);\\n        }\\n        return false;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,pair<int,string>>m;\\n    unordered_map<string,priority_queue<pii,vector<pii>,Compare>>mcu;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<f.size();i++)\\n        {\\n            m[f[i]]={r[i],c[i]};\\n            mcu[c[i]].push({r[i],f[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[food].first=newRating;\\n        mcu[m[food].second].push({newRating,food});\\n    }\\n    \\n    string highestRated(string c) {\\n        \\n        while(!mcu[c].empty())\\n        {\\n            auto [rating,food]=mcu[c].top();\\n            if(m[food].first!=rating)\\n                mcu[c].pop();\\n            else\\n            {\\n                return food;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int,string>\\nclass Compare\\n{\\npublic:\\n    bool operator() (pii p1,pii p2)\\n    {\\n        if(p1.first<p2.first)\\n            return true;\\n        else if(p1.first==p2.first)\\n        {\\n            return (p1.second>p2.second);\\n        }\\n        return false;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,pair<int,string>>m;\\n    unordered_map<string,priority_queue<pii,vector<pii>,Compare>>mcu;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for(int i=0;i<f.size();i++)\\n        {\\n            m[f[i]]={r[i],c[i]};\\n            mcu[c[i]].push({r[i],f[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        m[food].first=newRating;\\n        mcu[m[food].second].push({newRating,food});\\n    }\\n    \\n    string highestRated(string c) {\\n        \\n        while(!mcu[c].empty())\\n        {\\n            auto [rating,food]=mcu[c].top();\\n            if(m[food].first!=rating)\\n                mcu[c].pop();\\n            else\\n            {\\n                return food;\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3757385,
                "title": "java-easy-change-rating-o-log-n-highestrated-o-1-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThinking in faster retrival perspective, Constructor initalized one time can take more time to load. Post construct, methods should return result faster.\\n\\nUsed multiple `hashtable` to know `cuisine` against `food`, `rating` aginst `food` and `food-rating` collection against `cuisine` (Collections thought for faster response of `highestRated` method.).\\n\\nPriorityQueue for storing food rating in sorted manner\\n`new PriorityQueue<FoodRating>((p1, p2) -> (p1.rating==p2.rating) ? p1.food.compareTo(p2.food) : p2.rating-p1.rating)`\\n\\n# Complexity\\n- Time complexity: $$Constructor = O(n*log(n) \\n- changeRating = O(log(n)) \\n- highestRated = O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\n\\n    class FoodRating {\\n        String food;\\n        int rating;\\n        FoodRating(String food, int rating){\\n            this.food = food;\\n            this.rating = rating;\\n        }\\n    }\\n\\n    Map<String, String> foodCuisineMap = new HashMap<>();\\n    Map<String, FoodRating> foodRatingMap = new HashMap<>();\\n    Map<String, PriorityQueue<FoodRating>> cuisineFoodRatingMap \\n        = new HashMap<>();\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodRatingMap = new HashMap<>();\\n        cuisineFoodRatingMap = new HashMap<>();\\n        foodCuisineMap = new HashMap<>();\\n\\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            foodCuisineMap.put(foods[i], cuisines[i]);\\n            FoodRating fr = new FoodRating(foods[i], ratings[i]);\\n            foodRatingMap.put(foods[i], fr);\\n            PriorityQueue<FoodRating> pq = cuisineFoodRatingMap.getOrDefault(cuisines[i], new PriorityQueue<FoodRating>((p1, p2) -> (p1.rating==p2.rating) ? p1.food.compareTo(p2.food) : p2.rating-p1.rating));\\n            pq.offer(fr);\\n            cuisineFoodRatingMap.put(cuisines[i], pq);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        \\n        FoodRating foodRatingInstance = foodRatingMap.get(food);\\n        String cuisine = foodCuisineMap.get(food);\\n        \\n        PriorityQueue<FoodRating> pq = cuisineFoodRatingMap.get(cuisine);\\n        pq.remove(foodRatingInstance);\\n\\n        FoodRating newInstance = new FoodRating(food, newRating);\\n        pq.offer(newInstance); \\n\\n        cuisineFoodRatingMap.put(food, pq);\\n        foodRatingMap.put(food, newInstance);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineFoodRatingMap.get(cuisine).peek().food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    class FoodRating {\\n        String food;\\n        int rating;\\n        FoodRating(String food, int rating){\\n            this.food = food;\\n            this.rating = rating;\\n        }\\n    }\\n\\n    Map<String, String> foodCuisineMap = new HashMap<>();\\n    Map<String, FoodRating> foodRatingMap = new HashMap<>();\\n    Map<String, PriorityQueue<FoodRating>> cuisineFoodRatingMap \\n        = new HashMap<>();\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodRatingMap = new HashMap<>();\\n        cuisineFoodRatingMap = new HashMap<>();\\n        foodCuisineMap = new HashMap<>();\\n\\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            foodCuisineMap.put(foods[i], cuisines[i]);\\n            FoodRating fr = new FoodRating(foods[i], ratings[i]);\\n            foodRatingMap.put(foods[i], fr);\\n            PriorityQueue<FoodRating> pq = cuisineFoodRatingMap.getOrDefault(cuisines[i], new PriorityQueue<FoodRating>((p1, p2) -> (p1.rating==p2.rating) ? p1.food.compareTo(p2.food) : p2.rating-p1.rating));\\n            pq.offer(fr);\\n            cuisineFoodRatingMap.put(cuisines[i], pq);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        \\n        FoodRating foodRatingInstance = foodRatingMap.get(food);\\n        String cuisine = foodCuisineMap.get(food);\\n        \\n        PriorityQueue<FoodRating> pq = cuisineFoodRatingMap.get(cuisine);\\n        pq.remove(foodRatingInstance);\\n\\n        FoodRating newInstance = new FoodRating(food, newRating);\\n        pq.offer(newInstance); \\n\\n        cuisineFoodRatingMap.put(food, pq);\\n        foodRatingMap.put(food, newInstance);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineFoodRatingMap.get(cuisine).peek().food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686669,
                "title": "ordered-unordered-set-and-maps-red",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,string> fc; \\n    unordered_map<string,int> fr;\\n    unordered_map<string,map<int,set<string>,greater<int>>> built;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n        // food to cuisine\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            fc[foods[i]]=cuisines[i];\\n            fr[foods[i]]=ratings[i];\\n            built[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        built[fc[food]][fr[food]].erase(food); // erase food from previous rating \\n        if(built[fc[food]][fr[food]].empty())\\n        {\\n            built[fc[food]].erase(fr[food]);\\n        }\\n        \\n        built[fc[food]][newRating].insert(food);  // insert food from new rating \\n        fr[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        return *built[cuisine].begin()->second.begin();\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,string> fc; \\n    unordered_map<string,int> fr;\\n    unordered_map<string,map<int,set<string>,greater<int>>> built;\\n    \\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {\\n        // food to cuisine\\n        for(int i=0;i<foods.size();i++)\\n        {\\n            fc[foods[i]]=cuisines[i];\\n            fr[foods[i]]=ratings[i];\\n            built[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        built[fc[food]][fr[food]].erase(food); // erase food from previous rating \\n        if(built[fc[food]][fr[food]].empty())\\n        {\\n            built[fc[food]].erase(fr[food]);\\n        }\\n        \\n        built[fc[food]][newRating].insert(food);  // insert food from new rating \\n        fr[food]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        return *built[cuisine].begin()->second.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638815,
                "title": "simple-solution-using-sortedset-red-black-tree-in-c",
                "content": "### Time complexity \\n    => O(NLOGN) => initialzaiton\\n    => O(1) HighestRated => OLOGN for ChangeRating\\n  sortedset add operation takes O(LogN) time\\n  Therefore,  during initialization it takes O(NLogN) time beacuase of for loop and sortedset element addition\\n\\n# Code\\n```\\npublic class FoodRatings {\\n\\n // custom comparer class is required because we want to sort our red-black tree or sorted set \\n//in such a way that lexicographical ordering is followed.\\n     class Cmp:IComparer<(int r, string f)> {\\n        public int Compare((int r, string f) o1, (int r, string f) o2) {\\n            if(o1.r > o2.r) return 1;\\n            else if(o1.r < o2.r) return -1;\\n            else {\\n                return o2.f.CompareTo(o1.f);\\n            }\\n        }\\n    }\\n\\n    private Dictionary<string, SortedSet<(int rating, string food)>> map;\\n    private Dictionary<string, int> mapFood;\\n    private Dictionary<string ,string> mapFoodKit;\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\\n        map = new Dictionary<string, SortedSet<(int, string)>>();\\n        mapFood = new Dictionary<string, int>();\\n         mapFoodKit = new Dictionary<string, string>();\\n        for(int i=0;i<foods.Length;i++){\\n             mapFood[foods[i]] = ratings[i];\\n            mapFoodKit[foods[i]] = cuisines[i];\\n            if(map.ContainsKey(cuisines[i])){\\n                 map[cuisines[i]].Add((ratings[i], foods[i]));\\n            }\\n            else{\\n                SortedSet<(int rating, string food)> s = new SortedSet<(int, string)>(new Cmp());\\n                s.Add((ratings[i], foods[i]));\\n                map.Add(cuisines[i], s);\\n            }\\n        }\\n    }\\n    \\n    public void ChangeRating(string food, int newRating) {\\n        if(mapFood.ContainsKey(food)){\\n            int ir = mapFood[food];\\n            mapFood[food] = newRating;\\n            string cuisine = mapFoodKit[food];\\n            var s = map[cuisine];\\n             s.Remove((ir, food));\\n             s.Add((newRating, food));\\n        }\\n    }\\n    \\n    public string HighestRated(string cuisine) {\\n        var s = map[cuisine].Max;\\n        return s.food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.ChangeRating(food,newRating);\\n * string param_2 = obj.HighestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Ordered Set"
                ],
                "code": "```\\npublic class FoodRatings {\\n\\n // custom comparer class is required because we want to sort our red-black tree or sorted set \\n//in such a way that lexicographical ordering is followed.\\n     class Cmp:IComparer<(int r, string f)> {\\n        public int Compare((int r, string f) o1, (int r, string f) o2) {\\n            if(o1.r > o2.r) return 1;\\n            else if(o1.r < o2.r) return -1;\\n            else {\\n                return o2.f.CompareTo(o1.f);\\n            }\\n        }\\n    }\\n\\n    private Dictionary<string, SortedSet<(int rating, string food)>> map;\\n    private Dictionary<string, int> mapFood;\\n    private Dictionary<string ,string> mapFoodKit;\\n    public FoodRatings(string[] foods, string[] cuisines, int[] ratings) {\\n        map = new Dictionary<string, SortedSet<(int, string)>>();\\n        mapFood = new Dictionary<string, int>();\\n         mapFoodKit = new Dictionary<string, string>();\\n        for(int i=0;i<foods.Length;i++){\\n             mapFood[foods[i]] = ratings[i];\\n            mapFoodKit[foods[i]] = cuisines[i];\\n            if(map.ContainsKey(cuisines[i])){\\n                 map[cuisines[i]].Add((ratings[i], foods[i]));\\n            }\\n            else{\\n                SortedSet<(int rating, string food)> s = new SortedSet<(int, string)>(new Cmp());\\n                s.Add((ratings[i], foods[i]));\\n                map.Add(cuisines[i], s);\\n            }\\n        }\\n    }\\n    \\n    public void ChangeRating(string food, int newRating) {\\n        if(mapFood.ContainsKey(food)){\\n            int ir = mapFood[food];\\n            mapFood[food] = newRating;\\n            string cuisine = mapFoodKit[food];\\n            var s = map[cuisine];\\n             s.Remove((ir, food));\\n             s.Add((newRating, food));\\n        }\\n    }\\n    \\n    public string HighestRated(string cuisine) {\\n        var s = map[cuisine].Max;\\n        return s.food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.ChangeRating(food,newRating);\\n * string param_2 = obj.HighestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633839,
                "title": "swift-sorted-array-implementation",
                "content": "# Swift: Two Maps\\n```\\nstruct FoodRating: Comparable {\\n    let name: String\\n    let rating: Int\\n\\n    static func < (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.rating, lhs.name) < (rhs.rating, rhs.name)\\n    }\\n\\n    static func == (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.rating, lhs.name) == (rhs.rating, rhs.name)\\n    }\\n}\\n\\nclass FoodRatings {\\n    var foodRating: [String: SortedArray<FoodRating>]\\n    var foodStat: [String: (String, Int)]\\n    init(_ foods: [String], _ cuisines: [String], _ ratings: [Int]) {\\n        foodRating = [:]\\n        foodStat = [:]\\n        for (cuisine, (food, rating)) in zip(cuisines, zip(foods, ratings)) {\\n            foodRating[cuisine, default: SortedArray()].insert(FoodRating(name: food, rating: -rating))\\n            foodStat[food] = (cuisine, -rating)\\n        }\\n    }\\n    \\n    func changeRating(_ food: String, _ newRating: Int) {\\n        let (cuisine, rating) = foodStat[food]!\\n        foodStat[food] = (cuisine, -newRating)\\n        foodRating[cuisine]!.remove(FoodRating(name: food, rating: rating))\\n        foodRating[cuisine]!.insert(FoodRating(name: food, rating: -newRating))\\n    }\\n    \\n    func highestRated(_ cuisine: String) -> String {\\n        foodRating[cuisine]!.min()!.name\\n    }\\n}\\n\\nstruct SortedArray<T: Comparable> {\\n    private var arr: [T]\\n    var count: Int {\\n        arr.count\\n    }\\n    init(_ arr: [T]? = []) {\\n        self.arr = []\\n        for ele in arr ?? [] {\\n            self.insert(ele)\\n        }\\n    }\\n    \\n    mutating func insert(_ element: T) {\\n        let i = bisectRight(element)\\n        arr.insert(element, at: i)\\n    }\\n    \\n    mutating func remove(_ value: T) {\\n        let i = bisectRight(value) - 1\\n        arr.remove(at: i)\\n    }\\n    \\n    private func bisectRight(_ target: T) -> Int {\\n        var (lo, hi) = (0, count)\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2\\n            if arr[mid] <= target {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        return lo\\n    }\\n    \\n    func min() -> T? {\\n        arr.min()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nstruct FoodRating: Comparable {\\n    let name: String\\n    let rating: Int\\n\\n    static func < (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.rating, lhs.name) < (rhs.rating, rhs.name)\\n    }\\n\\n    static func == (lhs: Self, rhs: Self) -> Bool {\\n        (lhs.rating, lhs.name) == (rhs.rating, rhs.name)\\n    }\\n}\\n\\nclass FoodRatings {\\n    var foodRating: [String: SortedArray<FoodRating>]\\n    var foodStat: [String: (String, Int)]\\n    init(_ foods: [String], _ cuisines: [String], _ ratings: [Int]) {\\n        foodRating = [:]\\n        foodStat = [:]\\n        for (cuisine, (food, rating)) in zip(cuisines, zip(foods, ratings)) {\\n            foodRating[cuisine, default: SortedArray()].insert(FoodRating(name: food, rating: -rating))\\n            foodStat[food] = (cuisine, -rating)\\n        }\\n    }\\n    \\n    func changeRating(_ food: String, _ newRating: Int) {\\n        let (cuisine, rating) = foodStat[food]!\\n        foodStat[food] = (cuisine, -newRating)\\n        foodRating[cuisine]!.remove(FoodRating(name: food, rating: rating))\\n        foodRating[cuisine]!.insert(FoodRating(name: food, rating: -newRating))\\n    }\\n    \\n    func highestRated(_ cuisine: String) -> String {\\n        foodRating[cuisine]!.min()!.name\\n    }\\n}\\n\\nstruct SortedArray<T: Comparable> {\\n    private var arr: [T]\\n    var count: Int {\\n        arr.count\\n    }\\n    init(_ arr: [T]? = []) {\\n        self.arr = []\\n        for ele in arr ?? [] {\\n            self.insert(ele)\\n        }\\n    }\\n    \\n    mutating func insert(_ element: T) {\\n        let i = bisectRight(element)\\n        arr.insert(element, at: i)\\n    }\\n    \\n    mutating func remove(_ value: T) {\\n        let i = bisectRight(value) - 1\\n        arr.remove(at: i)\\n    }\\n    \\n    private func bisectRight(_ target: T) -> Int {\\n        var (lo, hi) = (0, count)\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2\\n            if arr[mid] <= target {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        return lo\\n    }\\n    \\n    func min() -> T? {\\n        arr.min()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557765,
                "title": "easy-solution-using-priorityqueue-and-hashmap-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Food {\\n    int rating;\\n    String food,cuisine;\\n    Food(String food,String cuisine,int rating){\\n        this.rating = rating;\\n        this.food = food;\\n        this.cuisine = cuisine;\\n    }\\n}\\nclass FoodRatings {\\n    Map<String,PriorityQueue<Food>> cuisineMap;\\n    Map<String,Food> foodMap;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n       cuisineMap = new HashMap<>();\\n       foodMap = new HashMap<>();\\n       for(int i=0;i<foods.length;i++){\\n           Food f = new Food(foods[i],cuisines[i],ratings[i]);\\n            cuisineMap.putIfAbsent(cuisines[i],new PriorityQueue<>((a,b) -> b.rating == a.rating ? a.food.compareTo(b.food) : b.rating - a.rating));\\n            PriorityQueue pq = cuisineMap.get(cuisines[i]);\\n            pq.add(f);\\n            foodMap.put(foods[i],f);\\n       }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food f = foodMap.get(food);\\n        PriorityQueue pq = cuisineMap.get(f.cuisine);\\n        pq.remove(f);\\n        f.rating = newRating;\\n        pq.add(f);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).peek().food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n /*             TLE             */\\n /*\\n class Node <String,Integer>{\\n    private String cuisine;\\n    private int rating;\\n    Node(String cuisine,int rating){\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public void setCuisine(String cuisine){\\n        this.cuisine = cuisine;\\n    }\\n    public String getCuisine(){\\n        return this.cuisine;\\n    }\\n    public void setRating(int rating){\\n        this.rating = rating;\\n    }\\n    public int getRating(){\\n        return this.rating;\\n    }\\n}\\nclass FoodRatings {\\n    HashMap<String,Node<String,Integer>> food; // SC : O (length of foods array)\\n    HashMap<String,List<String>> cuisineToFood; // Sc : O(length of cuisine)\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        food = new HashMap<>();\\n        cuisineToFood = new HashMap<>();\\n        for(int i=0;i<foods.length;i++){\\n            Node<String,Integer> p = new Node<>(cuisines[i],ratings[i]);\\n            food.put(foods[i],p);\\n            if(!cuisineToFood.containsKey(cuisines[i])){\\n                cuisineToFood.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineToFood.get(cuisines[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food1, int newRating) {\\n        food.get(food1).setRating(newRating);\\n        // TC : O(1)\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Node<String,Integer>> pq = new PriorityQueue<>((a,b) -> b.getRating() - a.getRating());\\n        for(String f : cuisineToFood.get(cuisine)){\\n                pq.offer(new Node<>(f,food.get(f).getRating()));\\n        }\\n        List<String> list = new ArrayList<>();\\n        if(!pq.isEmpty()){\\n            int highVal = pq.peek().getRating();\\n            list.add(pq.remove().getCuisine());\\n            while(!pq.isEmpty() && pq.peek().getRating() == highVal){\\n                list.add(pq.remove().getCuisine());\\n            }\\n            Collections.sort(list);\\n        }\\n        if(list.size() > 0){\\n            return list.get(0);\\n        }\\n        return \"\";\\n    }\\n}\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Food {\\n    int rating;\\n    String food,cuisine;\\n    Food(String food,String cuisine,int rating){\\n        this.rating = rating;\\n        this.food = food;\\n        this.cuisine = cuisine;\\n    }\\n}\\nclass FoodRatings {\\n    Map<String,PriorityQueue<Food>> cuisineMap;\\n    Map<String,Food> foodMap;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n       cuisineMap = new HashMap<>();\\n       foodMap = new HashMap<>();\\n       for(int i=0;i<foods.length;i++){\\n           Food f = new Food(foods[i],cuisines[i],ratings[i]);\\n            cuisineMap.putIfAbsent(cuisines[i],new PriorityQueue<>((a,b) -> b.rating == a.rating ? a.food.compareTo(b.food) : b.rating - a.rating));\\n            PriorityQueue pq = cuisineMap.get(cuisines[i]);\\n            pq.add(f);\\n            foodMap.put(foods[i],f);\\n       }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food f = foodMap.get(food);\\n        PriorityQueue pq = cuisineMap.get(f.cuisine);\\n        pq.remove(f);\\n        f.rating = newRating;\\n        pq.add(f);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).peek().food;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n /*             TLE             */\\n /*\\n class Node <String,Integer>{\\n    private String cuisine;\\n    private int rating;\\n    Node(String cuisine,int rating){\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n    public void setCuisine(String cuisine){\\n        this.cuisine = cuisine;\\n    }\\n    public String getCuisine(){\\n        return this.cuisine;\\n    }\\n    public void setRating(int rating){\\n        this.rating = rating;\\n    }\\n    public int getRating(){\\n        return this.rating;\\n    }\\n}\\nclass FoodRatings {\\n    HashMap<String,Node<String,Integer>> food; // SC : O (length of foods array)\\n    HashMap<String,List<String>> cuisineToFood; // Sc : O(length of cuisine)\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        food = new HashMap<>();\\n        cuisineToFood = new HashMap<>();\\n        for(int i=0;i<foods.length;i++){\\n            Node<String,Integer> p = new Node<>(cuisines[i],ratings[i]);\\n            food.put(foods[i],p);\\n            if(!cuisineToFood.containsKey(cuisines[i])){\\n                cuisineToFood.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineToFood.get(cuisines[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food1, int newRating) {\\n        food.get(food1).setRating(newRating);\\n        // TC : O(1)\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        PriorityQueue<Node<String,Integer>> pq = new PriorityQueue<>((a,b) -> b.getRating() - a.getRating());\\n        for(String f : cuisineToFood.get(cuisine)){\\n                pq.offer(new Node<>(f,food.get(f).getRating()));\\n        }\\n        List<String> list = new ArrayList<>();\\n        if(!pq.isEmpty()){\\n            int highVal = pq.peek().getRating();\\n            list.add(pq.remove().getCuisine());\\n            while(!pq.isEmpty() && pq.peek().getRating() == highVal){\\n                list.add(pq.remove().getCuisine());\\n            }\\n            Collections.sort(list);\\n        }\\n        if(list.size() > 0){\\n            return list.get(0);\\n        }\\n        return \"\";\\n    }\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549644,
                "title": "java-solution-using-hashmap-and-treemap",
                "content": "# Code\\n```\\nclass FoodRatings {\\n\\n    private Map<String, Map<String, Integer>> map;\\n    private Map<String, String> mapFC;\\n    private TreeMap<Integer, TreeMap<String, String>> mapR;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        mapFC = new HashMap<>();\\n        mapR = new TreeMap<>(Comparator.reverseOrder());\\n        for (int i = 0; i < foods.length; i++) {\\n            if (!map.containsKey(cuisines[i])) map.put(cuisines[i], new TreeMap<>());\\n            map.get(cuisines[i]).put(foods[i], ratings[i]);\\n            mapFC.put(foods[i], cuisines[i]);\\n\\n            if (!mapR.containsKey(ratings[i])) mapR.put(ratings[i], new TreeMap<>());\\n            mapR.get(ratings[i]).put(foods[i], cuisines[i]);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = mapFC.get(food);\\n        int oldRating = map.get(cuisine).get(food);\\n        map.get(cuisine).put(food, newRating);\\n\\n        mapR.get(oldRating).remove(food);\\n        if (!mapR.containsKey(newRating)) mapR.put(newRating, new TreeMap<>());\\n        mapR.get(newRating).put(food, cuisine);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        for (int r : mapR.keySet()) {\\n            Map<String, String> map1 = mapR.get(r);\\n            for (String food : map1.keySet()) if (map1.get(food).equals(cuisine)) return food;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    private Map<String, Map<String, Integer>> map;\\n    private Map<String, String> mapFC;\\n    private TreeMap<Integer, TreeMap<String, String>> mapR;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        map = new HashMap<>();\\n        mapFC = new HashMap<>();\\n        mapR = new TreeMap<>(Comparator.reverseOrder());\\n        for (int i = 0; i < foods.length; i++) {\\n            if (!map.containsKey(cuisines[i])) map.put(cuisines[i], new TreeMap<>());\\n            map.get(cuisines[i]).put(foods[i], ratings[i]);\\n            mapFC.put(foods[i], cuisines[i]);\\n\\n            if (!mapR.containsKey(ratings[i])) mapR.put(ratings[i], new TreeMap<>());\\n            mapR.get(ratings[i]).put(foods[i], cuisines[i]);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = mapFC.get(food);\\n        int oldRating = map.get(cuisine).get(food);\\n        map.get(cuisine).put(food, newRating);\\n\\n        mapR.get(oldRating).remove(food);\\n        if (!mapR.containsKey(newRating)) mapR.put(newRating, new TreeMap<>());\\n        mapR.get(newRating).put(food, cuisine);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        for (int r : mapR.keySet()) {\\n            Map<String, String> map1 = mapR.get(r);\\n            for (String food : map1.keySet()) if (map1.get(food).equals(cuisine)) return food;\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462740,
                "title": "design-a-food-rating-system",
                "content": "-------------- Easy C++ Solution ----------------------\\n\\n# Code\\n```\\nclass FoodRatings {\\npublic:\\n  FoodRatings(vector<string>& foods, vector<string>& cuisines,vector<int>& ratings){\\n    for (int i=0; i<foods.size();++i) {\\n      cuisineToRatingAndFoods[cuisines[i]].insert({-ratings[i], foods[i]});\\n      foodToCuisine[foods[i]]=cuisines[i];\\n      foodToRating[foods[i]]=ratings[i];\\n    }\\n  }\\n\\n  void changeRating(string food, int newRating) {\\n    const string cuisine = foodToCuisine[food];\\n    const int oldRating = foodToRating[food];\\n    auto& ratingAndFoods = cuisineToRatingAndFoods[cuisine];\\n    ratingAndFoods.erase({-oldRating, food});\\n    ratingAndFoods.insert({-newRating, food});\\n    foodToRating[food] = newRating;\\n  }\\n\\n  string highestRated(string cuisine) {\\n    return begin(cuisineToRatingAndFoods[cuisine])->second;\\n  }\\n\\n private:\\n  unordered_map<string, set<pair<int, string>>> cuisineToRatingAndFoods;\\n  unordered_map<string, string> foodToCuisine;\\n  unordered_map<string, int> foodToRating;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n  FoodRatings(vector<string>& foods, vector<string>& cuisines,vector<int>& ratings){\\n    for (int i=0; i<foods.size();++i) {\\n      cuisineToRatingAndFoods[cuisines[i]].insert({-ratings[i], foods[i]});\\n      foodToCuisine[foods[i]]=cuisines[i];\\n      foodToRating[foods[i]]=ratings[i];\\n    }\\n  }\\n\\n  void changeRating(string food, int newRating) {\\n    const string cuisine = foodToCuisine[food];\\n    const int oldRating = foodToRating[food];\\n    auto& ratingAndFoods = cuisineToRatingAndFoods[cuisine];\\n    ratingAndFoods.erase({-oldRating, food});\\n    ratingAndFoods.insert({-newRating, food});\\n    foodToRating[food] = newRating;\\n  }\\n\\n  string highestRated(string cuisine) {\\n    return begin(cuisineToRatingAndFoods[cuisine])->second;\\n  }\\n\\n private:\\n  unordered_map<string, set<pair<int, string>>> cuisineToRatingAndFoods;\\n  unordered_map<string, string> foodToCuisine;\\n  unordered_map<string, int> foodToRating;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459829,
                "title": "python-simple-hashmap-and-heapq",
                "content": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        f = self.food = defaultdict(tuple)\\n        c = self.cuis = defaultdict(list)\\n        for fd, cu, rt in zip(foods, cuisines, ratings):\\n            f[fd] = [cu, -rt]\\n            heappush(c[cu], (-rt, fd))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        newRating *= -1\\n        f = self.food\\n        c = self.cuis\\n        if f[food][-1] == newRating:\\n            return\\n        f[food][-1] = newRating\\n        heappush(c[f[food][0]], (newRating, food))\\n        \\n\\n    def highestRated(self, cui: str) -> str:\\n        f = self.food\\n        c = self.cuis\\n        rt, fd = c[cui][0]\\n        while f[fd][-1] != rt:\\n            heappop(c[cui])\\n            rt, fd = c[cui][0]\\n        return fd\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        f = self.food = defaultdict(tuple)\\n        c = self.cuis = defaultdict(list)\\n        for fd, cu, rt in zip(foods, cuisines, ratings):\\n            f[fd] = [cu, -rt]\\n            heappush(c[cu], (-rt, fd))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        newRating *= -1\\n        f = self.food\\n        c = self.cuis\\n        if f[food][-1] == newRating:\\n            return\\n        f[food][-1] = newRating\\n        heappush(c[f[food][0]], (newRating, food))\\n        \\n\\n    def highestRated(self, cui: str) -> str:\\n        f = self.food\\n        c = self.cuis\\n        rt, fd = c[cui][0]\\n        while f[fd][-1] != rt:\\n            heappop(c[cui])\\n            rt, fd = c[cui][0]\\n        return fd\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414877,
                "title": "c-maps",
                "content": "\\n# Code\\n```\\nclass FoodRatings {\\n\\nprivate:\\n\\nmap<string, map<int, set<string>>> mp;\\nunordered_map<string, string> c;\\nunordered_map<string, int> r;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n            for(int i = 0; i < foods.size(); i++){\\n                mp[cuisines[i]][ratings[i]].insert(foods[i]);\\n                c[foods[i]] = cuisines[i];\\n                r[foods[i]] = ratings[i];\\n            }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cuisine = c[food];\\n        int rating = r[food];\\n        r[food] = newRating;\\n        mp[cuisine][rating].erase(food);\\n        if(mp[cuisine][rating].size() == 0) mp[cuisine].erase(rating);\\n        mp[cuisine][newRating].insert(food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mp[cuisine].rbegin();\\n        return *(it->second.begin());\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\n\\nprivate:\\n\\nmap<string, map<int, set<string>>> mp;\\nunordered_map<string, string> c;\\nunordered_map<string, int> r;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n            for(int i = 0; i < foods.size(); i++){\\n                mp[cuisines[i]][ratings[i]].insert(foods[i]);\\n                c[foods[i]] = cuisines[i];\\n                r[foods[i]] = ratings[i];\\n            }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string cuisine = c[food];\\n        int rating = r[food];\\n        r[food] = newRating;\\n        mp[cuisine][rating].erase(food);\\n        if(mp[cuisine][rating].size() == 0) mp[cuisine].erase(rating);\\n        mp[cuisine][newRating].insert(food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mp[cuisine].rbegin();\\n        return *(it->second.begin());\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370498,
                "title": "lazy-but-easy",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} foods\\n * @param {string[]} cuisines\\n * @param {number[]} ratings\\n */\\nvar FoodRatings = function(foods, cuisines, ratings) {\\n        this.foods= foods\\n        this.cuisines= cuisines\\n        this.ratings= ratings\\n};\\n\\n/** \\n * @param {string} food \\n * @param {number} newRating\\n * @return {void}\\n */\\nFoodRatings.prototype.changeRating = function(food, newRating) {\\n    let idx =this.foods.indexOf(food)\\n    this.ratings[idx]= newRating\\n};\\n\\n/** \\n * @param {string} cuisine\\n * @return {string}\\n */\\nFoodRatings.prototype.highestRated = function(cuisine) {\\n     let cuisineFoods =[]\\n     let cuisineRating =[]\\n     this.cuisines.forEach((ele,idx)=>{\\n         \\n        if(ele == cuisine && (cuisineRating[cuisineRating.length-1]<= this.ratings[idx] || !cuisineRating.length )){\\n            if(cuisineRating.length && cuisineRating[cuisineRating.length-1]< this.ratings[idx]){\\n                cuisineFoods=[]\\n                cuisineRating=[]\\n            }\\n\\n            cuisineFoods.push(this.foods[idx]) \\n            cuisineRating.push(this.ratings[idx]) \\n        }\\n    })\\n\\n       return cuisineFoods.sort()[0]\\n\\n};\\n\\n/** \\n * Your FoodRatings object will be instantiated and called as such:\\n * var obj = new FoodRatings(foods, cuisines, ratings)\\n * obj.changeRating(food,newRating)\\n * var param_2 = obj.highestRated(cuisine)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} foods\\n * @param {string[]} cuisines\\n * @param {number[]} ratings\\n */\\nvar FoodRatings = function(foods, cuisines, ratings) {\\n        this.foods= foods\\n        this.cuisines= cuisines\\n        this.ratings= ratings\\n};\\n\\n/** \\n * @param {string} food \\n * @param {number} newRating\\n * @return {void}\\n */\\nFoodRatings.prototype.changeRating = function(food, newRating) {\\n    let idx =this.foods.indexOf(food)\\n    this.ratings[idx]= newRating\\n};\\n\\n/** \\n * @param {string} cuisine\\n * @return {string}\\n */\\nFoodRatings.prototype.highestRated = function(cuisine) {\\n     let cuisineFoods =[]\\n     let cuisineRating =[]\\n     this.cuisines.forEach((ele,idx)=>{\\n         \\n        if(ele == cuisine && (cuisineRating[cuisineRating.length-1]<= this.ratings[idx] || !cuisineRating.length )){\\n            if(cuisineRating.length && cuisineRating[cuisineRating.length-1]< this.ratings[idx]){\\n                cuisineFoods=[]\\n                cuisineRating=[]\\n            }\\n\\n            cuisineFoods.push(this.foods[idx]) \\n            cuisineRating.push(this.ratings[idx]) \\n        }\\n    })\\n\\n       return cuisineFoods.sort()[0]\\n\\n};\\n\\n/** \\n * Your FoodRatings object will be instantiated and called as such:\\n * var obj = new FoodRatings(foods, cuisines, ratings)\\n * obj.changeRating(food,newRating)\\n * var param_2 = obj.highestRated(cuisine)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337463,
                "title": "c-map-of-map-of-set",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    // for each type of cuisine\\n        // maintain a list of ratings, food\\n        // foods at each rating should be stored\\n        // using a set\\n    //            cuisine,    rating, foods at rating\\n    unordered_map<string, map<int, set<string>>> m;\\n    //            food, cuisine, rating\\n    unordered_map<string, pair<string, int>> fc;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for (int i = 0; i < f.size(); ++i){\\n            m[c[i]][r[i]].insert(f[i]);\\n            fc[f[i]] = {c[i], r[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n                    auto [s, i] = fc[food];\\n                    m[s][i].erase(food);\\n                    if (m[s][i].size() == 0) m[s].erase(i);\\n                    m[s][newRating].insert(food);\\n                    fc[food].second = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto& it = m[cuisine];\\n        auto itr = it.rbegin();\\n        auto& s = itr->second;\\n        return *s.begin();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    // for each type of cuisine\\n        // maintain a list of ratings, food\\n        // foods at each rating should be stored\\n        // using a set\\n    //            cuisine,    rating, foods at rating\\n    unordered_map<string, map<int, set<string>>> m;\\n    //            food, cuisine, rating\\n    unordered_map<string, pair<string, int>> fc;\\n    \\n    FoodRatings(vector<string>& f, vector<string>& c, vector<int>& r) {\\n        for (int i = 0; i < f.size(); ++i){\\n            m[c[i]][r[i]].insert(f[i]);\\n            fc[f[i]] = {c[i], r[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n                    auto [s, i] = fc[food];\\n                    m[s][i].erase(food);\\n                    if (m[s][i].size() == 0) m[s].erase(i);\\n                    m[s][newRating].insert(food);\\n                    fc[food].second = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto& it = m[cuisine];\\n        auto itr = it.rbegin();\\n        auto& s = itr->second;\\n        return *s.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330763,
                "title": "java-comparator-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass FoodRatings {\\n    private Map<String, Food> foodNameMappedToFood = new HashMap<>();\\n    private Map<String, Queue<Food>> cuisinesMappedToFood = new HashMap<>();\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for (int i = 0; i < foods.length; i++) {\\n            Food food = new Food(foods[i], cuisines[i], ratings[i]);\\n            cuisinesMappedToFood.putIfAbsent(cuisines[i], \\n            new PriorityQueue<>(new FoodComparator()));\\n            cuisinesMappedToFood.get(cuisines[i]).add(food);\\n            foodNameMappedToFood.put(foods[i], food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food foodObj = foodNameMappedToFood.get(food);\\n        String cuisine = foodNameMappedToFood.get(food).cuisine;\\n        cuisinesMappedToFood.get(cuisine).remove(foodObj);\\n        foodObj.rating = newRating;\\n        cuisinesMappedToFood.get(cuisine).add(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMappedToFood.get(cuisine).peek().name;\\n    }\\n\\n    \\n}\\n\\nclass FoodComparator implements Comparator<Food> {\\n    @Override\\n    public int compare(Food first, Food second) {\\n        if (first.rating == second.rating)\\n            return first.name.compareTo(second.name);\\n        return second.rating - first.rating;\\n    }\\n}\\n\\nclass Food {\\n    public String name;\\n    public String cuisine;\\n    public int rating;\\n\\n    public Food(String name, String cuisine, int rating) {\\n        this.name = name;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n    private Map<String, Food> foodNameMappedToFood = new HashMap<>();\\n    private Map<String, Queue<Food>> cuisinesMappedToFood = new HashMap<>();\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for (int i = 0; i < foods.length; i++) {\\n            Food food = new Food(foods[i], cuisines[i], ratings[i]);\\n            cuisinesMappedToFood.putIfAbsent(cuisines[i], \\n            new PriorityQueue<>(new FoodComparator()));\\n            cuisinesMappedToFood.get(cuisines[i]).add(food);\\n            foodNameMappedToFood.put(foods[i], food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food foodObj = foodNameMappedToFood.get(food);\\n        String cuisine = foodNameMappedToFood.get(food).cuisine;\\n        cuisinesMappedToFood.get(cuisine).remove(foodObj);\\n        foodObj.rating = newRating;\\n        cuisinesMappedToFood.get(cuisine).add(foodObj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMappedToFood.get(cuisine).peek().name;\\n    }\\n\\n    \\n}\\n\\nclass FoodComparator implements Comparator<Food> {\\n    @Override\\n    public int compare(Food first, Food second) {\\n        if (first.rating == second.rating)\\n            return first.name.compareTo(second.name);\\n        return second.rating - first.rating;\\n    }\\n}\\n\\nclass Food {\\n    public String name;\\n    public String cuisine;\\n    public int rating;\\n\\n    public Food(String name, String cuisine, int rating) {\\n        this.name = name;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303198,
                "title": "ood-object-oriented-design-solution",
                "content": "\\n# Code\\n```\\nclass FoodRatings {\\n    class FoodItem {\\n        private final String foodName;\\n        private final String cuisineType;\\n        private int rating;\\n        public FoodItem(String food, String cuisine, int rating) {\\n            this.foodName = food;\\n            this.cuisineType = cuisine;\\n            this.rating = rating;\\n        }\\n\\n        public void updateRating(int newRating) {\\n            this.rating = newRating;\\n        }\\n\\n        public int getRating() {\\n            return rating;\\n        }\\n\\n        public String getFoodName() {\\n            return foodName;\\n        }\\n\\n        public String getCuisineType() {\\n            return cuisineType;\\n        }\\n    }\\n    \\n    public class FoodItemComparator implements Comparator<FoodItem> {\\n        @Override\\n        public int compare(FoodItem food1, FoodItem food2) {\\n            if (food1.getRating() != food2.getRating()) {\\n                return Integer.compare(food2.getRating(), food1.getRating());\\n            }\\n            return food1.getFoodName().compareTo(food2.getFoodName());\\n        }\\n    }\\n\\n    Map<String, FoodItem> foodMap;\\n    Map<String, TreeSet<FoodItem>> cuisineMap;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n\\n        for (int i = 0; i < foods.length; i++) {\\n            FoodItem newFood = new FoodItem(foods[i], cuisines[i], ratings[i]);\\n            foodMap.put(foods[i], newFood);\\n            cuisineMap.computeIfAbsent(cuisines[i], k -> new TreeSet<FoodItem>(new FoodItemComparator())).add(newFood);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodItem foodItem = foodMap.get(food);\\n        TreeSet<FoodItem> sortedFood = cuisineMap.get(foodItem.getCuisineType());\\n        sortedFood.remove(foodItem);\\n        foodItem.updateRating(newRating);\\n        sortedFood.add(foodItem);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).first().getFoodName();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FoodRatings {\\n    class FoodItem {\\n        private final String foodName;\\n        private final String cuisineType;\\n        private int rating;\\n        public FoodItem(String food, String cuisine, int rating) {\\n            this.foodName = food;\\n            this.cuisineType = cuisine;\\n            this.rating = rating;\\n        }\\n\\n        public void updateRating(int newRating) {\\n            this.rating = newRating;\\n        }\\n\\n        public int getRating() {\\n            return rating;\\n        }\\n\\n        public String getFoodName() {\\n            return foodName;\\n        }\\n\\n        public String getCuisineType() {\\n            return cuisineType;\\n        }\\n    }\\n    \\n    public class FoodItemComparator implements Comparator<FoodItem> {\\n        @Override\\n        public int compare(FoodItem food1, FoodItem food2) {\\n            if (food1.getRating() != food2.getRating()) {\\n                return Integer.compare(food2.getRating(), food1.getRating());\\n            }\\n            return food1.getFoodName().compareTo(food2.getFoodName());\\n        }\\n    }\\n\\n    Map<String, FoodItem> foodMap;\\n    Map<String, TreeSet<FoodItem>> cuisineMap;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodMap = new HashMap<>();\\n        cuisineMap = new HashMap<>();\\n\\n        for (int i = 0; i < foods.length; i++) {\\n            FoodItem newFood = new FoodItem(foods[i], cuisines[i], ratings[i]);\\n            foodMap.put(foods[i], newFood);\\n            cuisineMap.computeIfAbsent(cuisines[i], k -> new TreeSet<FoodItem>(new FoodItemComparator())).add(newFood);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodItem foodItem = foodMap.get(food);\\n        TreeSet<FoodItem> sortedFood = cuisineMap.get(foodItem.getCuisineType());\\n        sortedFood.remove(foodItem);\\n        foodItem.updateRating(newRating);\\n        sortedFood.add(foodItem);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisineMap.get(cuisine).first().getFoodName();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288993,
                "title": "fast-c-custom-max-heap-implementation-logn-update-o-1-getmax",
                "content": "```\\nclass FoodPQ\\n{\\n    vector<pair<string, int>> v;\\n    unordered_map<string, int> mp;\\t// food to idx_in_heap\\n    public:\\n        FoodPQ() {}\\n    void push(pair<string, int> p)\\n    {\\n        v.push_back(p);\\n        mp[p.first] = v.size()-1;\\n    }\\n    bool isLeftBigger(pair<string, int> a, pair<string, int> b)\\n    {\\n        if (a.second != b.second) return a.second > b.second;\\n        return a.first < b.first;\\n    }\\n    void swapper(int idx1, int idx2)\\n    {\\n        mp[v[idx1].first] = idx2;\\n        mp[v[idx2].first] = idx1;\\n        swap(v[idx1], v[idx2]);\\n    }\\n    bool isV(int idx){\\n        return idx>=0 && idx<v.size();\\n    }\\n    void bubbleUp(int idx)\\n    {\\n       \\t// i -> 2i+1, 2i+2\\n       \\t// child-1/2 = parent\\n        int par = (idx - 1) / 2;\\n        if (isV(par) && isLeftBigger(v[idx], v[par]))\\n        {\\n            swapper(idx, par);\\n            bubbleUp(par);\\n        }\\n        \\n    }\\n    void bubbleDn(int idx)\\n    {\\n       \\t// i -> 2i+1, 2i+2\\n       \\t// child-1/2 = parent\\n        int c1 = 2 *idx + 1;\\n        int c2 = 2 *idx + 2;\\n        int n = v.size();\\n\\n        if (isV(c1)==false || isLeftBigger(v[idx], v[c1]))  // cant go c1 side\\n        {\\n           \\t// can only go c2 side\\n            if (isV(c2) && (!isLeftBigger(v[idx], v[c2])))\\n            {\\n                swapper(idx, c2);\\n                bubbleDn(c2);\\n            }\\n        }\\n        else\\n        {\\n           \\t// can go c1 side\\n            if ( isV(c2)==false || isLeftBigger(v[idx], v[c2]))\\t// cant go c2 side \\n            {\\n                swapper(idx, c1);\\n                bubbleDn(c1);\\n            }\\n            else\\n            {\\n               \\t// might go either c1/c2\\n                if ( isV(c2) && isLeftBigger(v[c1], v[c2]) )\\n                {\\n                   \\t// go down c1 side \\n                    swapper(idx, c1);\\n                    bubbleDn(c1);\\n                }\\n                else\\n                {\\n                   \\t// go c2 side\\n                    swapper(idx, c2);\\n                    bubbleDn(c2);\\n                }\\n            }\\n        }\\n    }\\n    void heapify()\\n    {\\n        for(int i = v.size()-1;i>=0;i--){\\n            bubbleDn(i);\\n        }\\n    }\\n    void update(string food, int r)\\n    {\\n        int idx = mp[food];\\n        int orgR = v[idx].second;\\n        v[idx].second = r;\\n        if(r>orgR)\\n        bubbleUp(idx);\\n        else bubbleDn(idx);\\n    }\\n    string getMax()\\n    {\\n        return v[0].first;\\n    }\\n};\\nclass FoodRatings\\n{\\n    unordered_map<string, FoodPQ*> mp;\\t// cuisine -> pq_of_foods_of_a_particular_cuisine\\n    unordered_map<string, string> ftc;\\t// food -> cuisine\\n    public:\\n        FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n        {\\n            int n = foods.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                ftc[foods[i]] = cuisines[i];\\n                if(!mp.count(cuisines[i]))\\n                mp[cuisines[i]] = new FoodPQ();\\n                mp[cuisines[i]]->push({ foods[i],ratings[i] });\\n            }\\n            for(auto it:mp){\\n                mp[it.first]->heapify();\\n            }\\n        }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        mp[ftc[food]]->update(food, newRating);\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return mp[cuisine]->getMax();\\n    }\\n};\\n\\n/**\\n *Your FoodRatings object will be instantiated and called as such:\\n *FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n *obj->changeRating(food,newRating);\\n *string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FoodPQ\\n{\\n    vector<pair<string, int>> v;\\n    unordered_map<string, int> mp;\\t// food to idx_in_heap\\n    public:\\n        FoodPQ() {}\\n    void push(pair<string, int> p)\\n    {\\n        v.push_back(p);\\n        mp[p.first] = v.size()-1;\\n    }\\n    bool isLeftBigger(pair<string, int> a, pair<string, int> b)\\n    {\\n        if (a.second != b.second) return a.second > b.second;\\n        return a.first < b.first;\\n    }\\n    void swapper(int idx1, int idx2)\\n    {\\n        mp[v[idx1].first] = idx2;\\n        mp[v[idx2].first] = idx1;\\n        swap(v[idx1], v[idx2]);\\n    }\\n    bool isV(int idx){\\n        return idx>=0 && idx<v.size();\\n    }\\n    void bubbleUp(int idx)\\n    {\\n       \\t// i -> 2i+1, 2i+2\\n       \\t// child-1/2 = parent\\n        int par = (idx - 1) / 2;\\n        if (isV(par) && isLeftBigger(v[idx], v[par]))\\n        {\\n            swapper(idx, par);\\n            bubbleUp(par);\\n        }\\n        \\n    }\\n    void bubbleDn(int idx)\\n    {\\n       \\t// i -> 2i+1, 2i+2\\n       \\t// child-1/2 = parent\\n        int c1 = 2 *idx + 1;\\n        int c2 = 2 *idx + 2;\\n        int n = v.size();\\n\\n        if (isV(c1)==false || isLeftBigger(v[idx], v[c1]))  // cant go c1 side\\n        {\\n           \\t// can only go c2 side\\n            if (isV(c2) && (!isLeftBigger(v[idx], v[c2])))\\n            {\\n                swapper(idx, c2);\\n                bubbleDn(c2);\\n            }\\n        }\\n        else\\n        {\\n           \\t// can go c1 side\\n            if ( isV(c2)==false || isLeftBigger(v[idx], v[c2]))\\t// cant go c2 side \\n            {\\n                swapper(idx, c1);\\n                bubbleDn(c1);\\n            }\\n            else\\n            {\\n               \\t// might go either c1/c2\\n                if ( isV(c2) && isLeftBigger(v[c1], v[c2]) )\\n                {\\n                   \\t// go down c1 side \\n                    swapper(idx, c1);\\n                    bubbleDn(c1);\\n                }\\n                else\\n                {\\n                   \\t// go c2 side\\n                    swapper(idx, c2);\\n                    bubbleDn(c2);\\n                }\\n            }\\n        }\\n    }\\n    void heapify()\\n    {\\n        for(int i = v.size()-1;i>=0;i--){\\n            bubbleDn(i);\\n        }\\n    }\\n    void update(string food, int r)\\n    {\\n        int idx = mp[food];\\n        int orgR = v[idx].second;\\n        v[idx].second = r;\\n        if(r>orgR)\\n        bubbleUp(idx);\\n        else bubbleDn(idx);\\n    }\\n    string getMax()\\n    {\\n        return v[0].first;\\n    }\\n};\\nclass FoodRatings\\n{\\n    unordered_map<string, FoodPQ*> mp;\\t// cuisine -> pq_of_foods_of_a_particular_cuisine\\n    unordered_map<string, string> ftc;\\t// food -> cuisine\\n    public:\\n        FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n        {\\n            int n = foods.size();\\n            for (int i = 0; i < n; i++)\\n            {\\n                ftc[foods[i]] = cuisines[i];\\n                if(!mp.count(cuisines[i]))\\n                mp[cuisines[i]] = new FoodPQ();\\n                mp[cuisines[i]]->push({ foods[i],ratings[i] });\\n            }\\n            for(auto it:mp){\\n                mp[it.first]->heapify();\\n            }\\n        }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        mp[ftc[food]]->update(food, newRating);\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return mp[cuisine]->getMax();\\n    }\\n};\\n\\n/**\\n *Your FoodRatings object will be instantiated and called as such:\\n *FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n *obj->changeRating(food,newRating);\\n *string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282417,
                "title": "lazy-updation-with-heaps-and-sets-python3",
                "content": "\\n# Code\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.map = {}\\n        self.cusineratings = defaultdict(set)\\n        self.heaps = defaultdict(list)\\n        self.foodrating = defaultdict(int)\\n        for food,cuisine,rating in zip(foods,cuisines,ratings):\\n            self.map[food] = cuisine\\n            self.cusineratings[cuisine].add((-rating,food))\\n            heappush(self.heaps[cuisine],(-rating,food))\\n            self.foodrating[food] = -rating\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        if food in self.map:  \\n            cuisine = self.map[food]\\n            prev = self.foodrating[food]\\n            self.cusineratings[cuisine].remove((prev,food))\\n            self.cusineratings[cuisine].add((-newRating,food))\\n            heappush(self.heaps[cuisine],(-newRating,food))\\n            self.foodrating[food] = -newRating\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        while self.heaps[cuisine] and self.heaps[cuisine][0] not in self.cusineratings[cuisine]:\\n            heappop(self.heaps[cuisine])\\n        return self.heaps[cuisine][0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.map = {}\\n        self.cusineratings = defaultdict(set)\\n        self.heaps = defaultdict(list)\\n        self.foodrating = defaultdict(int)\\n        for food,cuisine,rating in zip(foods,cuisines,ratings):\\n            self.map[food] = cuisine\\n            self.cusineratings[cuisine].add((-rating,food))\\n            heappush(self.heaps[cuisine],(-rating,food))\\n            self.foodrating[food] = -rating\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        if food in self.map:  \\n            cuisine = self.map[food]\\n            prev = self.foodrating[food]\\n            self.cusineratings[cuisine].remove((prev,food))\\n            self.cusineratings[cuisine].add((-newRating,food))\\n            heappush(self.heaps[cuisine],(-newRating,food))\\n            self.foodrating[food] = -newRating\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        while self.heaps[cuisine] and self.heaps[cuisine][0] not in self.cusineratings[cuisine]:\\n            heappop(self.heaps[cuisine])\\n        return self.heaps[cuisine][0][1]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251845,
                "title": "hashmap-simple-java-solution-hashing",
                "content": "# Complexity\\n- Time complexity:\\nO(no of calls)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass FoodRatings {\\n    HashMap<String,String> map = new HashMap<>();\\n    HashMap<String,Integer>rating;\\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> highrated;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        this.rating = new HashMap<>();\\n        this.highrated = new HashMap<>();\\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            rating.put(foods[i],ratings[i]);\\n            map.put(foods[i],cuisines[i]);\\n           if(!highrated.containsKey(cuisines[i])){\\n                TreeMap<Integer,TreeSet<String>> tree = new TreeMap<>();\\n                TreeSet<String> str = new TreeSet<>();\\n                tree.put(ratings[i],str);\\n                highrated.put(cuisines[i],tree);\\n            }\\n            if(!highrated.get(cuisines[i]).containsKey(ratings[i])){\\n                TreeSet<String> st = new TreeSet<>();\\n                highrated.get(cuisines[i]).put(ratings[i],st);\\n            }\\n            highrated.get(cuisines[i]).get(ratings[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        int x = rating.get(food);\\n        String t = map.get(food);\\n        highrated.get(t).get(x).remove(food);\\n        if(highrated.get(t).get(x).size()==0) highrated.get(t).remove(x);\\n        if(!highrated.get(t).containsKey(newRating)){\\n            TreeSet<String> str = new TreeSet<>();\\n            highrated.get(t).put(newRating,str);\\n        }\\n        highrated.get(t).get(newRating).add(food);\\n        rating.put(food,newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        int y = highrated.get(cuisine).lastKey();\\n        return highrated.get(cuisine).get(y).first();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    HashMap<String,String> map = new HashMap<>();\\n    HashMap<String,Integer>rating;\\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> highrated;\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        this.rating = new HashMap<>();\\n        this.highrated = new HashMap<>();\\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            rating.put(foods[i],ratings[i]);\\n            map.put(foods[i],cuisines[i]);\\n           if(!highrated.containsKey(cuisines[i])){\\n                TreeMap<Integer,TreeSet<String>> tree = new TreeMap<>();\\n                TreeSet<String> str = new TreeSet<>();\\n                tree.put(ratings[i],str);\\n                highrated.put(cuisines[i],tree);\\n            }\\n            if(!highrated.get(cuisines[i]).containsKey(ratings[i])){\\n                TreeSet<String> st = new TreeSet<>();\\n                highrated.get(cuisines[i]).put(ratings[i],st);\\n            }\\n            highrated.get(cuisines[i]).get(ratings[i]).add(foods[i]);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        int x = rating.get(food);\\n        String t = map.get(food);\\n        highrated.get(t).get(x).remove(food);\\n        if(highrated.get(t).get(x).size()==0) highrated.get(t).remove(x);\\n        if(!highrated.get(t).containsKey(newRating)){\\n            TreeSet<String> str = new TreeSet<>();\\n            highrated.get(t).put(newRating,str);\\n        }\\n        highrated.get(t).get(newRating).add(food);\\n        rating.put(food,newRating);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        int y = highrated.get(cuisine).lastKey();\\n        return highrated.get(cuisine).get(y).first();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249446,
                "title": "python3-max-heap-lazy-delete",
                "content": "```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuisines = defaultdict(list)   # cuisine -> max heap of (rating, food)\\n        self.foods = defaultdict(str)       # food -> cuisine\\n        self.ratings = defaultdict(int)     # food -> rating \\n\\n        # build mappings \\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            rating = -rating\\n            self.foods[food] = cuisine\\n            self.cuisines[cuisine] += [(rating, food)]\\n            self.ratings[food] = rating\\n\\n        # heapify ratings \\n        for ratings in self.cuisines.values():\\n            heapify(ratings)\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        # update food rating\\n        rating = -newRating\\n        self.ratings[food] = rating\\n        # push new heap element \\n        cuisine = self.foods[food]\\n        heappush(self.cuisines[cuisine], (rating, food))\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        # get max heap\\n        heap = self.cuisines[cuisine]\\n        # lazy delete changed ratings \\n        while heap and self.ratings[heap[0][-1]] != heap[0][0]:\\n            heappop(heap)\\n        # return food of max rating \\n        return heap[0][-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.cuisines = defaultdict(list)   # cuisine -> max heap of (rating, food)\\n        self.foods = defaultdict(str)       # food -> cuisine\\n        self.ratings = defaultdict(int)     # food -> rating \\n\\n        # build mappings \\n        for food, cuisine, rating in zip(foods, cuisines, ratings):\\n            rating = -rating\\n            self.foods[food] = cuisine\\n            self.cuisines[cuisine] += [(rating, food)]\\n            self.ratings[food] = rating\\n\\n        # heapify ratings \\n        for ratings in self.cuisines.values():\\n            heapify(ratings)\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        # update food rating\\n        rating = -newRating\\n        self.ratings[food] = rating\\n        # push new heap element \\n        cuisine = self.foods[food]\\n        heappush(self.cuisines[cuisine], (rating, food))\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        # get max heap\\n        heap = self.cuisines[cuisine]\\n        # lazy delete changed ratings \\n        while heap and self.ratings[heap[0][-1]] != heap[0][0]:\\n            heappop(heap)\\n        # return food of max rating \\n        return heap[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169604,
                "title": "c-easy-solution-using-2-maps-top-99-runtime-top-97-memory-420ms",
                "content": "# Code\\n```\\nstruct compare {\\n    bool operator() (const pair<int, string>& a, const pair<int, string>& b) const{\\n        if ( a.first > b.first ) return true;\\n        else if ( a.first == b.first ) return a.second < b.second ? true : false;\\n        return false;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map<string, pair<int, string>> m; // keep track of the rating and cuisine of each food\\n    unordered_map<string, set<pair<int, string>, compare>> c; // keep track of an ordered set for each cuisine\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for ( int i = 0; i < foods.size(); ++i )\\n        {\\n            m[foods[i]] = { ratings[i], cuisines[i] };\\n            c[cuisines[i]].insert({ratings[i], foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if ( m.find(food) == m.end() ) return;\\n\\n        auto [oldRating, cuisine] = m.find(food)->second; // get the rating and cuisine for this food\\n        m[food].first = newRating;\\n\\n        // Let\\'s update the rating in the cuisine map\\n        c.find(cuisine)->second.erase(c.find(cuisine)->second.find({oldRating, food}));\\n        c.find(cuisine)->second.insert({newRating, food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return c.find(cuisine)->second.begin()->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct compare {\\n    bool operator() (const pair<int, string>& a, const pair<int, string>& b) const{\\n        if ( a.first > b.first ) return true;\\n        else if ( a.first == b.first ) return a.second < b.second ? true : false;\\n        return false;\\n    }\\n};\\n\\nclass FoodRatings {\\n    unordered_map<string, pair<int, string>> m; // keep track of the rating and cuisine of each food\\n    unordered_map<string, set<pair<int, string>, compare>> c; // keep track of an ordered set for each cuisine\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for ( int i = 0; i < foods.size(); ++i )\\n        {\\n            m[foods[i]] = { ratings[i], cuisines[i] };\\n            c[cuisines[i]].insert({ratings[i], foods[i]});\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if ( m.find(food) == m.end() ) return;\\n\\n        auto [oldRating, cuisine] = m.find(food)->second; // get the rating and cuisine for this food\\n        m[food].first = newRating;\\n\\n        // Let\\'s update the rating in the cuisine map\\n        c.find(cuisine)->second.erase(c.find(cuisine)->second.find({oldRating, food}));\\n        c.find(cuisine)->second.insert({newRating, food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return c.find(cuisine)->second.begin()->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162174,
                "title": "c-unordered-map-string-map-int-set-string-greater",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            cuis[foods[i]] = cuisines[i];\\n            rates[foods[i]] = ratings[i];\\n            mm[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int p = rates[food];\\n        auto& m = mm[cuis[food]];\\n        m[p].erase(food);\\n        if(m[p].empty()) m.erase(p);\\n        m[newRating].insert(food);\\n        rates[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mm[cuisine].begin();\\n        return *it->second.begin();\\n    }\\n\\n    unordered_map<string, string> cuis; //{food, cuisines}\\n    unordered_map<string, map<int, set<string>, greater<>>> mm; //cuisines, {rate, {foot}}\\n    unordered_map<string, int> rates;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            cuis[foods[i]] = cuisines[i];\\n            rates[foods[i]] = ratings[i];\\n            mm[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int p = rates[food];\\n        auto& m = mm[cuis[food]];\\n        m[p].erase(food);\\n        if(m[p].empty()) m.erase(p);\\n        m[newRating].insert(food);\\n        rates[food] = newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mm[cuisine].begin();\\n        return *it->second.begin();\\n    }\\n\\n    unordered_map<string, string> cuis; //{food, cuisines}\\n    unordered_map<string, map<int, set<string>, greater<>>> mm; //cuisines, {rate, {foot}}\\n    unordered_map<string, int> rates;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148193,
                "title": "c-three-maps-consider-one-food-can-be-present-in-multiple-cuisines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\nprivate:\\n    class Comp {\\n    public:\\n        bool operator()(const pair<int, string>& p1, const pair<int, string>& p2) const {\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;   \\n        } \\n    };\\n\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; ++i) {\\n            auto p = cuisineMap[cuisines[i]].insert({ratings[i], foods[i]});\\n            cuisineFoodMap[cuisines[i]][foods[i]] = p.first;\\n            foodCuisineMap[foods[i]].push_back(cuisines[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        const auto& cuisines = foodCuisineMap[food];\\n        for (const auto & cs : cuisines) {\\n            auto iter = cuisineFoodMap[cs][food];\\n            cuisineMap[cs].erase(iter);\\n            auto p = cuisineMap[cs].insert({newRating, food});\\n            cuisineFoodMap[cs][food] = p.first;\\n        }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return cuisineMap[cuisine].begin()->second;\\n    }\\n\\nprivate:\\n    std::unordered_map<string, std::set<pair<int, string>, Comp>> cuisineMap;\\n    std::unordered_map<string, std::unordered_map<std::string, std::set<pair<int, string>>::iterator>> cuisineFoodMap;\\n    std::unordered_map<string, vector<string>> foodCuisineMap;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\nprivate:\\n    class Comp {\\n    public:\\n        bool operator()(const pair<int, string>& p1, const pair<int, string>& p2) const {\\n            return p1.first == p2.first ? p1.second < p2.second : p1.first > p2.first;   \\n        } \\n    };\\n\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n = foods.size();\\n        for (int i = 0; i < n; ++i) {\\n            auto p = cuisineMap[cuisines[i]].insert({ratings[i], foods[i]});\\n            cuisineFoodMap[cuisines[i]][foods[i]] = p.first;\\n            foodCuisineMap[foods[i]].push_back(cuisines[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        const auto& cuisines = foodCuisineMap[food];\\n        for (const auto & cs : cuisines) {\\n            auto iter = cuisineFoodMap[cs][food];\\n            cuisineMap[cs].erase(iter);\\n            auto p = cuisineMap[cs].insert({newRating, food});\\n            cuisineFoodMap[cs][food] = p.first;\\n        }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return cuisineMap[cuisine].begin()->second;\\n    }\\n\\nprivate:\\n    std::unordered_map<string, std::set<pair<int, string>, Comp>> cuisineMap;\\n    std::unordered_map<string, std::unordered_map<std::string, std::set<pair<int, string>>::iterator>> cuisineFoodMap;\\n    std::unordered_map<string, vector<string>> foodCuisineMap;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129093,
                "title": "python-hashmaps-heap-no-comparator-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We know we need to track \"highest\" rated for a collection of items. A heap seems like a good candidate here. \\n\\n- We know we need to get the \"highest\" rated for a cuisine. So we can maintain a dictionary of cuisine to a heap of foods with their ratings.\\n\\n- We also know we need to update the ratings for a food item so we can maintain a dictionary for that as well.\\n\\nUpdating a value in a heap is expensive because we have to iterate through the heap, update the value, and reheapify. \\n\\nWe can maintain some other dictionary to track food and rating and only insert into the heap which is an O(nlogn) operation. When grabbing a value from our heap, we can check to make sure the rating is what we expect in our dictionary. If it\\'s not it will be \"lazy\" deleted from our heap.\\n\\nWhen calling `changeRating` we only get the food and newRating. After updating the rating we need to insert the food and newRating into our heap. We need to figure out which cuisine a food item belongs to so we can track that as well.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will need:\\n\\n1. Dictionary to track food to rating & cuisine\\n2. Dictionary to track cuisine -> heap of (rating, food)\\n\\n`changeRating` will update value in dictionary and insert into heap in cuisine map. \\n\\n`highestRated` will pop the max in the cuisine heap. If the rating matches what we have in the dictionary then it\\'s valid otherwise we ignore that value and keep looking.\\n\\nheapq in python by default implements a min heap. If we are inserting tuples into our min heap we can negate the rating (highest rating) and in case of a tie it will return the lexographically smaller food item so we don\\'t need a special comparator or class.\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        # Map FoodInfo -> Rating, Cuisine\\n        self.foodInfo = defaultdict(list)\\n        # Map Cuisine -> Heap of (rating, food)\\n        self.cuisines = defaultdict(list)\\n\\n        for i in range(len(foods)):\\n            self.foodInfo[foods[i]] = [ratings[i], cuisines[i]]\\n            # We want max for the rating & lex. min for the item so negate rating as heapq is a min heap.\\n            heapq.heappush(self.cuisines[cuisines[i]], (-ratings[i], foods[i]))\\n\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        # Update food to rating in map. Push the new rating and food into the heap for the respective cuisine.\\n        cuisine = self.foodInfo[food][1]\\n        self.foodInfo[food] = [newRating, cuisine]\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while True:\\n            # Pop the heap for the topRated item in the cuisine map. \\n            topRatedValue, foodItem = heapq.heappop(self.cuisines[cuisine])\\n            # If the rating is the same as the value we have in the foodInfo map, we know its up to date.\\n            # Push it back into the heap since it\\'s current. If we get one where the rating is not current\\n            # with what we have in our foodInfo map the item will be lazy deleted from the heap.  \\n            if self.foodInfo[foodItem][0] == -topRatedValue:\\n                heapq.heappush(self.cuisines[cuisine], (topRatedValue, foodItem))\\n                return foodItem\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport heapq\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        # Map FoodInfo -> Rating, Cuisine\\n        self.foodInfo = defaultdict(list)\\n        # Map Cuisine -> Heap of (rating, food)\\n        self.cuisines = defaultdict(list)\\n\\n        for i in range(len(foods)):\\n            self.foodInfo[foods[i]] = [ratings[i], cuisines[i]]\\n            # We want max for the rating & lex. min for the item so negate rating as heapq is a min heap.\\n            heapq.heappush(self.cuisines[cuisines[i]], (-ratings[i], foods[i]))\\n\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        # Update food to rating in map. Push the new rating and food into the heap for the respective cuisine.\\n        cuisine = self.foodInfo[food][1]\\n        self.foodInfo[food] = [newRating, cuisine]\\n        heapq.heappush(self.cuisines[cuisine], (-newRating, food))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while True:\\n            # Pop the heap for the topRated item in the cuisine map. \\n            topRatedValue, foodItem = heapq.heappop(self.cuisines[cuisine])\\n            # If the rating is the same as the value we have in the foodInfo map, we know its up to date.\\n            # Push it back into the heap since it\\'s current. If we get one where the rating is not current\\n            # with what we have in our foodInfo map the item will be lazy deleted from the heap.  \\n            if self.foodInfo[foodItem][0] == -topRatedValue:\\n                heapq.heappush(self.cuisines[cuisine], (topRatedValue, foodItem))\\n                return foodItem\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118050,
                "title": "treemap-java",
                "content": "```\\nclass FoodRatings {\\n\\n   class Node {\\n        Map<String, Integer> foodRatingMap;\\n        Map<Integer, TreeSet<String>> ratingFoodMap;\\n        \\n        public Node(){\\n            foodRatingMap = new HashMap<>();\\n            ratingFoodMap = new TreeMap<>(Comparator.reverseOrder());\\n        }\\n    }\\n\\n    private Map<String, String> foodCusineMap;\\n    private Map<String, Node> cusineFoodRatingMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodCusineMap = new HashMap<>();\\n        cusineFoodRatingMap = new HashMap<>();\\n        for (int i = 0; i < foods.length; i++){\\n            String food = foods[i];\\n            String cusine = cuisines[i];\\n            int rating = ratings[i];\\n            foodCusineMap.put(food, cusine);\\n            \\n            if(cusineFoodRatingMap.get(cusine) == null){\\n                cusineFoodRatingMap.put(cusine, new Node());\\n            }\\n\\n            Map<String, Integer> foodRatingMap = cusineFoodRatingMap.get(cusine).foodRatingMap;\\n            Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cusine).ratingFoodMap;\\n\\n            foodRatingMap.put(food, rating);\\n            TreeSet<String> set = ratingFoodMap.getOrDefault(rating, new TreeSet<>());\\n            set.add(food);\\n            ratingFoodMap.put(rating, set);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cusine = foodCusineMap.get(food);\\n\\n        Map<String, Integer> foodRatingMap = cusineFoodRatingMap.get(cusine).foodRatingMap;\\n        Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cusine).ratingFoodMap;\\n        \\n        int currRating = foodRatingMap.get(food);\\n        //remove the food from the current rating map\\n        TreeSet<String> set = ratingFoodMap.getOrDefault(currRating, new TreeSet<>());\\n        set.remove(food);\\n        if(set.isEmpty()) //caution , to remove the key if the set size if 0\\n            ratingFoodMap.remove(currRating);\\n        else \\n            ratingFoodMap.put(currRating, set);\\n\\n        //update the mapping\\n        foodRatingMap.put(food, newRating);\\n\\n        //add the food in the current rating \\n        TreeSet<String> newFoodSet = ratingFoodMap.getOrDefault(currRating, new TreeSet<>());\\n        newFoodSet.add(food);\\n        ratingFoodMap.put(newRating, newFoodSet);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cuisine).ratingFoodMap;\\n        int highestRating = ratingFoodMap.keySet().iterator().next(); //first item in the map\\n        TreeSet<String> foodSet = ratingFoodMap.get(highestRating);\\n        return foodSet.iterator().next();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\n\\n   class Node {\\n        Map<String, Integer> foodRatingMap;\\n        Map<Integer, TreeSet<String>> ratingFoodMap;\\n        \\n        public Node(){\\n            foodRatingMap = new HashMap<>();\\n            ratingFoodMap = new TreeMap<>(Comparator.reverseOrder());\\n        }\\n    }\\n\\n    private Map<String, String> foodCusineMap;\\n    private Map<String, Node> cusineFoodRatingMap;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodCusineMap = new HashMap<>();\\n        cusineFoodRatingMap = new HashMap<>();\\n        for (int i = 0; i < foods.length; i++){\\n            String food = foods[i];\\n            String cusine = cuisines[i];\\n            int rating = ratings[i];\\n            foodCusineMap.put(food, cusine);\\n            \\n            if(cusineFoodRatingMap.get(cusine) == null){\\n                cusineFoodRatingMap.put(cusine, new Node());\\n            }\\n\\n            Map<String, Integer> foodRatingMap = cusineFoodRatingMap.get(cusine).foodRatingMap;\\n            Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cusine).ratingFoodMap;\\n\\n            foodRatingMap.put(food, rating);\\n            TreeSet<String> set = ratingFoodMap.getOrDefault(rating, new TreeSet<>());\\n            set.add(food);\\n            ratingFoodMap.put(rating, set);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        String cusine = foodCusineMap.get(food);\\n\\n        Map<String, Integer> foodRatingMap = cusineFoodRatingMap.get(cusine).foodRatingMap;\\n        Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cusine).ratingFoodMap;\\n        \\n        int currRating = foodRatingMap.get(food);\\n        //remove the food from the current rating map\\n        TreeSet<String> set = ratingFoodMap.getOrDefault(currRating, new TreeSet<>());\\n        set.remove(food);\\n        if(set.isEmpty()) //caution , to remove the key if the set size if 0\\n            ratingFoodMap.remove(currRating);\\n        else \\n            ratingFoodMap.put(currRating, set);\\n\\n        //update the mapping\\n        foodRatingMap.put(food, newRating);\\n\\n        //add the food in the current rating \\n        TreeSet<String> newFoodSet = ratingFoodMap.getOrDefault(currRating, new TreeSet<>());\\n        newFoodSet.add(food);\\n        ratingFoodMap.put(newRating, newFoodSet);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        Map<Integer, TreeSet<String>> ratingFoodMap = cusineFoodRatingMap.get(cuisine).ratingFoodMap;\\n        int highestRating = ratingFoodMap.keySet().iterator().next(); //first item in the map\\n        TreeSet<String> foodSet = ratingFoodMap.get(highestRating);\\n        return foodSet.iterator().next();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111164,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings {\\npublic:\\n    map<string,set<int>>mp;\\n    map<pair<string,int>,set<string>>m;\\n    map<string,int>r;\\n    map<string,string>c;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++) {\\n            mp[cuisines[i]].insert({ratings[i]});\\n            m[{cuisines[i],ratings[i]}].insert(foods[i]);\\n            r[foods[i]] = ratings[i];\\n            c[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int old_rating = r[food];\\n        string cuisine = c[food];\\n        r[food] = newRating;\\n        m[{cuisine,old_rating}].erase(food);\\n        if(m[{cuisine,old_rating}].empty()) {\\n            m.erase({cuisine,old_rating});\\n            mp[cuisine].erase(old_rating);\\n        }\\n        mp[cuisine].insert(newRating);\\n        m[{cuisine, newRating}].insert(food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mp[cuisine].end();\\n        it--;\\n        int rating = *it;\\n        auto it1 = m[{cuisine,rating}].begin();\\n        return *it1;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    map<string,set<int>>mp;\\n    map<pair<string,int>,set<string>>m;\\n    map<string,int>r;\\n    map<string,string>c;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++) {\\n            mp[cuisines[i]].insert({ratings[i]});\\n            m[{cuisines[i],ratings[i]}].insert(foods[i]);\\n            r[foods[i]] = ratings[i];\\n            c[foods[i]] = cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int old_rating = r[food];\\n        string cuisine = c[food];\\n        r[food] = newRating;\\n        m[{cuisine,old_rating}].erase(food);\\n        if(m[{cuisine,old_rating}].empty()) {\\n            m.erase({cuisine,old_rating});\\n            mp[cuisine].erase(old_rating);\\n        }\\n        mp[cuisine].insert(newRating);\\n        m[{cuisine, newRating}].insert(food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = mp[cuisine].end();\\n        it--;\\n        int rating = *it;\\n        auto it1 = m[{cuisine,rating}].begin();\\n        return *it1;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067080,
                "title": "javascript-avl-tree-761ms",
                "content": "```\\n///////////////////////////// Template ///////////////////////////////\\nclass AVLNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.left = null;\\n        this.right = null;\\n        this.height = 1;\\n        this.cnt = 1;\\n        this.SubTreeNodes = 1;\\n    }\\n}\\n\\nclass AVLTree {\\n    constructor(comparator = null) {\\n        this.root = null;\\n        this.nodeCount = 0;\\n        this.tot = 0;\\n        this.comparator = comparator ? comparator : (x, y) => x - y;\\n    }\\n    cmp(x, y) { // compare nodes: x is inserted item\\n        if (x == null || y == null) return 0;\\n        if (Array.isArray(x) || Number.isInteger(x)) x = new AVLNode(x);\\n        if (Array.isArray(y) || Number.isInteger(y)) y = new AVLNode(y);\\n        if (Array.isArray(x.val) || Array.isArray(y.val)) {\\n            if (Array.isArray(x.val) && Array.isArray(y.val)) {\\n                return this.comparator(x.val, y.val);\\n            } else {\\n                return 0;\\n            }\\n        } else if (Number.isInteger(x.val) || Number.isInteger(y.val)) {\\n            if (Number.isInteger(x.val) && Number.isInteger(y.val)) {\\n                return this.comparator(x.val, y.val);\\n            } else {\\n                return 0;\\n            }\\n        }\\n        return 0;\\n    }\\n    getHeight(node) {\\n        return node != null ? node.height : 0;\\n    }\\n    getBalance(node) {\\n        return node != null ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\\n    }\\n    update(node) {\\n        let leftHeight = this.getHeight(node.left), rightHeight = this.getHeight(node.right);\\n        node.height = 1 + Math.max(leftHeight, rightHeight);\\n        node.SubTreeNodes = 1 + (node.left != null ? node.left.SubTreeNodes : 0) + (node.right != null ? node.right.SubTreeNodes : 0);\\n    }\\n    LR(z) {\\n        let y = z.right;\\n        let T2 = y.left;\\n        y.left = z;\\n        z.right = T2;\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    RR(z) {\\n        let y = z.left;\\n        let T3 = y.right;\\n        y.right = z\\n        z.left = T3\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    insert(item) {\\n        this.root = this.insertUtil(this.root, item);\\n    }\\n    insertUtil(node, item) {\\n        if (node == null) { // find place to insert\\n            this.nodeCount++;\\n            this.tot++;\\n            return new AVLNode(item);\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.insertUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.insertUtil(node.right, item);\\n        } else {\\n            node.cnt++;\\n            this.tot++;\\n            return node;\\n        }\\n        this.update(node);\\n        return this.rebalanceAfterInsert(node, item);\\n    }\\n    remove(v) {\\n        this.root = this.removeUtil(this.root, v);\\n    }\\n    removeUtil(node, item) {\\n        if (node == null) {\\n            return node;\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.removeUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.removeUtil(node.right, item);\\n        } else { // find node\\n            if (node.cnt > 1) { // current node > 1, remove 1, tree size keep the same\\n                node.cnt--;\\n                this.tot--;\\n                return node;\\n            } else { // current node == 1, delete, tree size--\\n                this.nodeCount--;\\n                this.tot--;\\n            }\\n            // delete process\\n            if (node.left == null) {\\n                let tmp = node.right;\\n                node = null;\\n                return tmp;\\n            } else if (node.right == null) {\\n                let tmp = node.left;\\n                node = null;\\n                return tmp;\\n            }\\n            let tmp = this.findFirst(node.right);\\n            node.val = tmp.val;\\n            node.right = this.removeUtil(node.right, tmp.val);\\n        }\\n        if (node == null) return node;\\n        this.update(node);\\n        return this.rebalanceAfterDeletion(node, item);\\n    }\\n    rebalanceAfterInsert(node, item) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.cmp(item, node.left) < 0) return this.RR(node);\\n        if (bal < -1 && this.cmp(item, node.right) > 0) return this.LR(node);\\n        if (bal > 1 && this.cmp(item, node.left) > 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.cmp(item, node.right) < 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    rebalanceAfterDeletion(node) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.getBalance(node.left) >= 0) return this.RR(node);\\n        if (bal < -1 && this.getBalance(node.right) <= 0) return this.LR(node);\\n        if (bal > 1 && this.getBalance(node.left) < 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.getBalance(node.right) > 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    find(item) {\\n        return this.findFirstOf(item);\\n    }\\n    findFirstOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    higher(item) {// > upper_bound\\n        let node = this.findSuccessorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findSuccessorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        return res;\\n    }\\n    lower(item) { // < \\n        let node = this.findPrecursorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findPrecursorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) > 0) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    findKth(k) { // (1-indexed)  unique\\n        let res = this.findKthNode(k);\\n        return res == null ? null : res.val;\\n    }\\n    findKthNode(k) {\\n        return this.size() < k ? null : this.KthUtil(this.root, k);\\n    }\\n    KthUtil(node, k) {\\n        let leftCount = node.left ? node.left.SubTreeNodes : 0;\\n        if (leftCount + 1 === k) return node;\\n        if (leftCount + 1 < k) return this.KthUtil(node.right, k - leftCount - 1);\\n        return this.KthUtil(node.left, k);\\n    }\\n    rankOf(item) { // unique value treeset    total elements in tree with val < item\\n        let x = this.findPrecursorOf(item);\\n        return x == null ? 0 : this.findRankOf(x, this.root) + 1;\\n    }\\n    findRankOf(item, node) {\\n        let rank = 0;\\n        while (node != null) {\\n            let leftSubtreeNodes = node.left != null ? node.left.SubTreeNodes : 0;\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                rank += leftSubtreeNodes + 1;\\n                node = node.right;\\n            } else {\\n                return rank + leftSubtreeNodes;\\n            }\\n        }\\n        return 0;\\n    }\\n    has(item) {\\n        return this.count(item) > 0;\\n    }\\n    count(item) {\\n        let node = this.find(item);\\n        return node == null ? 0 : node.cnt;\\n    }\\n    first() {\\n        let node = this.findFirst(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    last() {\\n        let node = this.findLast(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    poll() {\\n        let res = this.first();\\n        this.remove(res);\\n        return res;\\n    }\\n    pollLast() {\\n        let res = this.last();\\n        this.remove(res);\\n        return res;\\n    }\\n    findFirst(node) {\\n        return node == null || node.left == null ? node : this.findFirst(node.left);\\n    }\\n    findLast(node) {\\n        return node == null || node.right == null ? node : this.findLast(node.right);\\n    }\\n    size() {\\n        return this.nodeCount;\\n    }\\n    total() {\\n        return this.tot;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() { // inorder\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n    showAll() {\\n        let d = this.show(), res = [];\\n        for (const x of d) {\\n            for (let i = 0; i < this.count(x); i++) res.push(x);\\n        }\\n        return res;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////////\\n\\nconst lexical_smallest_comp = (x, y) => x < y ? -1 : x > y ? 1 : 0;\\n\\nfunction FoodRatings(foods, cuisines, ratings) {\\n    let n = foods.length, cm = new Map(), fm = new Map(), rm = new Map();\\n    for (let i = 0; i < n; i++) {\\n        fm.set(foods[i], cuisines[i]);\\n        rm.set(foods[i], ratings[i]);\\n        if (!cm.has(cuisines[i])) {\\n            let tree = new AVLTree((x, y) => {\\n                if (x[0] != y[0]) return y[0] - x[0]; // first priority higher rating comes first\\n                return lexical_smallest_comp(x[1], y[1]); // second priority lexical small comes first\\n            });\\n            cm.set(cuisines[i], tree);\\n        }\\n        cm.get(cuisines[i]).insert([ratings[i], foods[i]]);\\n    }\\n    return { changeRating, highestRated }\\n    function changeRating(food, newRating) {\\n        let cuisine = fm.get(food);\\n        cm.get(cuisine).remove([rm.get(food), food]);\\n        rm.set(food, newRating);\\n        cm.get(cuisine).insert([rm.get(food), food]);\\n    }\\n    function highestRated(cuisine) {\\n        return cm.get(cuisine).first()[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Search Tree",
                    "Ordered Map"
                ],
                "code": "```\\n///////////////////////////// Template ///////////////////////////////\\nclass AVLNode {\\n    constructor(val) {\\n        this.val = val;\\n        this.left = null;\\n        this.right = null;\\n        this.height = 1;\\n        this.cnt = 1;\\n        this.SubTreeNodes = 1;\\n    }\\n}\\n\\nclass AVLTree {\\n    constructor(comparator = null) {\\n        this.root = null;\\n        this.nodeCount = 0;\\n        this.tot = 0;\\n        this.comparator = comparator ? comparator : (x, y) => x - y;\\n    }\\n    cmp(x, y) { // compare nodes: x is inserted item\\n        if (x == null || y == null) return 0;\\n        if (Array.isArray(x) || Number.isInteger(x)) x = new AVLNode(x);\\n        if (Array.isArray(y) || Number.isInteger(y)) y = new AVLNode(y);\\n        if (Array.isArray(x.val) || Array.isArray(y.val)) {\\n            if (Array.isArray(x.val) && Array.isArray(y.val)) {\\n                return this.comparator(x.val, y.val);\\n            } else {\\n                return 0;\\n            }\\n        } else if (Number.isInteger(x.val) || Number.isInteger(y.val)) {\\n            if (Number.isInteger(x.val) && Number.isInteger(y.val)) {\\n                return this.comparator(x.val, y.val);\\n            } else {\\n                return 0;\\n            }\\n        }\\n        return 0;\\n    }\\n    getHeight(node) {\\n        return node != null ? node.height : 0;\\n    }\\n    getBalance(node) {\\n        return node != null ? this.getHeight(node.left) - this.getHeight(node.right) : 0;\\n    }\\n    update(node) {\\n        let leftHeight = this.getHeight(node.left), rightHeight = this.getHeight(node.right);\\n        node.height = 1 + Math.max(leftHeight, rightHeight);\\n        node.SubTreeNodes = 1 + (node.left != null ? node.left.SubTreeNodes : 0) + (node.right != null ? node.right.SubTreeNodes : 0);\\n    }\\n    LR(z) {\\n        let y = z.right;\\n        let T2 = y.left;\\n        y.left = z;\\n        z.right = T2;\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    RR(z) {\\n        let y = z.left;\\n        let T3 = y.right;\\n        y.right = z\\n        z.left = T3\\n        this.update(z);\\n        this.update(y);\\n        return y;\\n    }\\n    insert(item) {\\n        this.root = this.insertUtil(this.root, item);\\n    }\\n    insertUtil(node, item) {\\n        if (node == null) { // find place to insert\\n            this.nodeCount++;\\n            this.tot++;\\n            return new AVLNode(item);\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.insertUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.insertUtil(node.right, item);\\n        } else {\\n            node.cnt++;\\n            this.tot++;\\n            return node;\\n        }\\n        this.update(node);\\n        return this.rebalanceAfterInsert(node, item);\\n    }\\n    remove(v) {\\n        this.root = this.removeUtil(this.root, v);\\n    }\\n    removeUtil(node, item) {\\n        if (node == null) {\\n            return node;\\n        } else if (this.cmp(item, node) < 0) {\\n            node.left = this.removeUtil(node.left, item);\\n        } else if (this.cmp(item, node) > 0) {\\n            node.right = this.removeUtil(node.right, item);\\n        } else { // find node\\n            if (node.cnt > 1) { // current node > 1, remove 1, tree size keep the same\\n                node.cnt--;\\n                this.tot--;\\n                return node;\\n            } else { // current node == 1, delete, tree size--\\n                this.nodeCount--;\\n                this.tot--;\\n            }\\n            // delete process\\n            if (node.left == null) {\\n                let tmp = node.right;\\n                node = null;\\n                return tmp;\\n            } else if (node.right == null) {\\n                let tmp = node.left;\\n                node = null;\\n                return tmp;\\n            }\\n            let tmp = this.findFirst(node.right);\\n            node.val = tmp.val;\\n            node.right = this.removeUtil(node.right, tmp.val);\\n        }\\n        if (node == null) return node;\\n        this.update(node);\\n        return this.rebalanceAfterDeletion(node, item);\\n    }\\n    rebalanceAfterInsert(node, item) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.cmp(item, node.left) < 0) return this.RR(node);\\n        if (bal < -1 && this.cmp(item, node.right) > 0) return this.LR(node);\\n        if (bal > 1 && this.cmp(item, node.left) > 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.cmp(item, node.right) < 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    rebalanceAfterDeletion(node) {\\n        let bal = this.getBalance(node);\\n        if (bal > 1 && this.getBalance(node.left) >= 0) return this.RR(node);\\n        if (bal < -1 && this.getBalance(node.right) <= 0) return this.LR(node);\\n        if (bal > 1 && this.getBalance(node.left) < 0) {\\n            node.left = this.LR(node.left);\\n            return this.RR(node);\\n        }\\n        if (bal < -1 && this.getBalance(node.right) > 0) {\\n            node.right = this.RR(node.right);\\n            return this.LR(node);\\n        }\\n        return node;\\n    }\\n    find(item) {\\n        return this.findFirstOf(item);\\n    }\\n    findFirstOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                node = node.right;\\n            } else {\\n                res = node;\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    higher(item) {// > upper_bound\\n        let node = this.findSuccessorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findSuccessorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) < 0) {\\n                res = node;\\n                node = node.left;\\n            } else {\\n                node = node.right;\\n            }\\n        }\\n        return res;\\n    }\\n    lower(item) { // < \\n        let node = this.findPrecursorOf(item);\\n        return node == null ? null : (node.val);\\n    }\\n    findPrecursorOf(item) {\\n        let node = this.root, res = null;\\n        while (node != null) {\\n            if (this.cmp(item, node) > 0) {\\n                res = node;\\n                node = node.right;\\n            } else {\\n                node = node.left;\\n            }\\n        }\\n        return res;\\n    }\\n    findKth(k) { // (1-indexed)  unique\\n        let res = this.findKthNode(k);\\n        return res == null ? null : res.val;\\n    }\\n    findKthNode(k) {\\n        return this.size() < k ? null : this.KthUtil(this.root, k);\\n    }\\n    KthUtil(node, k) {\\n        let leftCount = node.left ? node.left.SubTreeNodes : 0;\\n        if (leftCount + 1 === k) return node;\\n        if (leftCount + 1 < k) return this.KthUtil(node.right, k - leftCount - 1);\\n        return this.KthUtil(node.left, k);\\n    }\\n    rankOf(item) { // unique value treeset    total elements in tree with val < item\\n        let x = this.findPrecursorOf(item);\\n        return x == null ? 0 : this.findRankOf(x, this.root) + 1;\\n    }\\n    findRankOf(item, node) {\\n        let rank = 0;\\n        while (node != null) {\\n            let leftSubtreeNodes = node.left != null ? node.left.SubTreeNodes : 0;\\n            if (this.cmp(item, node) < 0) {\\n                node = node.left;\\n            } else if (this.cmp(item, node) > 0) {\\n                rank += leftSubtreeNodes + 1;\\n                node = node.right;\\n            } else {\\n                return rank + leftSubtreeNodes;\\n            }\\n        }\\n        return 0;\\n    }\\n    has(item) {\\n        return this.count(item) > 0;\\n    }\\n    count(item) {\\n        let node = this.find(item);\\n        return node == null ? 0 : node.cnt;\\n    }\\n    first() {\\n        let node = this.findFirst(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    last() {\\n        let node = this.findLast(this.root);\\n        return node == null ? null : node.val;\\n    }\\n    poll() {\\n        let res = this.first();\\n        this.remove(res);\\n        return res;\\n    }\\n    pollLast() {\\n        let res = this.last();\\n        this.remove(res);\\n        return res;\\n    }\\n    findFirst(node) {\\n        return node == null || node.left == null ? node : this.findFirst(node.left);\\n    }\\n    findLast(node) {\\n        return node == null || node.right == null ? node : this.findLast(node.right);\\n    }\\n    size() {\\n        return this.nodeCount;\\n    }\\n    total() {\\n        return this.tot;\\n    }\\n    isEmpty() {\\n        return this.root == null;\\n    }\\n    show() { // inorder\\n        let res = [];\\n        const dfs = (x) => {\\n            if (x == null) return;\\n            dfs(x.left);\\n            res.push(x.val);\\n            dfs(x.right);\\n        };\\n        dfs(this.root);\\n        return res;\\n    }\\n    showAll() {\\n        let d = this.show(), res = [];\\n        for (const x of d) {\\n            for (let i = 0; i < this.count(x); i++) res.push(x);\\n        }\\n        return res;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////////\\n\\nconst lexical_smallest_comp = (x, y) => x < y ? -1 : x > y ? 1 : 0;\\n\\nfunction FoodRatings(foods, cuisines, ratings) {\\n    let n = foods.length, cm = new Map(), fm = new Map(), rm = new Map();\\n    for (let i = 0; i < n; i++) {\\n        fm.set(foods[i], cuisines[i]);\\n        rm.set(foods[i], ratings[i]);\\n        if (!cm.has(cuisines[i])) {\\n            let tree = new AVLTree((x, y) => {\\n                if (x[0] != y[0]) return y[0] - x[0]; // first priority higher rating comes first\\n                return lexical_smallest_comp(x[1], y[1]); // second priority lexical small comes first\\n            });\\n            cm.set(cuisines[i], tree);\\n        }\\n        cm.get(cuisines[i]).insert([ratings[i], foods[i]]);\\n    }\\n    return { changeRating, highestRated }\\n    function changeRating(food, newRating) {\\n        let cuisine = fm.get(food);\\n        cm.get(cuisine).remove([rm.get(food), food]);\\n        rm.set(food, newRating);\\n        cm.get(cuisine).insert([rm.get(food), food]);\\n    }\\n    function highestRated(cuisine) {\\n        return cm.get(cuisine).first()[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013131,
                "title": "using-priority-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTotal number of calls made to changeRating/highestRated is 2*10^4, so we need to make sure that the worst case time complexity of these two functions should be less then O(n).\\n\\nPriority is decided based on the rating followed by lexicographically smaller string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the highest rating is decided based on the crusine, so PQ for each crusine would be different. \\n\\nTime complexity of changeRating is O(log n), as we are overriding the existing rating with \"#REMOVED\" and then inserting a new rating in the heap.\\n\\nTime Complexity for highestRated function will be O(log n) assuming there are several redundant enteries present at the top.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, f: List[str], c: List[str], r: List[int]):\\n        self.fr = {}\\n        self.cf = defaultdict(list)\\n        for i in range(len(f)):\\n            self.fr[f[i]] = [-r[i], f[i], c[i]]\\n            heappush(self.cf[c[i]], self.fr[f[i]])\\n\\n    def changeRating(self, f: str, nr: int) -> None:\\n        e = self.fr[f]\\n        e[-2] = \"#REMOVED\"\\n        ne = [-nr, f, e[-1]]\\n        heappush(self.cf[e[-1]], ne)\\n        self.fr[f] = ne\\n\\n    def highestRated(self, c: str) -> str:\\n        while self.cf[c][0][-2] == \"#REMOVED\":\\n            heappop(self.cf[c])\\n\\n        return self.cf[c][0][-2]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, f: List[str], c: List[str], r: List[int]):\\n        self.fr = {}\\n        self.cf = defaultdict(list)\\n        for i in range(len(f)):\\n            self.fr[f[i]] = [-r[i], f[i], c[i]]\\n            heappush(self.cf[c[i]], self.fr[f[i]])\\n\\n    def changeRating(self, f: str, nr: int) -> None:\\n        e = self.fr[f]\\n        e[-2] = \"#REMOVED\"\\n        ne = [-nr, f, e[-1]]\\n        heappush(self.cf[e[-1]], ne)\\n        self.fr[f] = ne\\n\\n    def highestRated(self, c: str) -> str:\\n        while self.cf[c][0][-2] == \"#REMOVED\":\\n            heappop(self.cf[c])\\n\\n        return self.cf[c][0][-2]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979785,
                "title": "c-unordered-map-of-food-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nFoodRating: O(nlogn)\\nchangeRating: O(logn)\\nhighestRated: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct FoodRating {\\n    std::string food;\\n    int rating;\\n    bool operator<(const FoodRating& o) const {\\n        if (rating == o.rating) {\\n            return food.compare(o.food) < 0;\\n        }\\n        return rating > o.rating;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        const auto sz = foods.size();\\n        for (int i=0;i<sz;++i) {\\n            CuisineToFood[cuisines[i]].insert({foods[i], ratings[i]});\\n            FoodToCuisine[foods[i]] = {ratings[i], cuisines[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto it = FoodToCuisine.find(food);\\n        const auto& cuisine = it->second.second;\\n\\n        FoodRating fr{food, it->second.first};\\n        CuisineToFood[cuisine].erase(fr);\\n        CuisineToFood[cuisine].insert({food, newRating});\\n\\n        FoodToCuisine[food] = {newRating, it->second.second};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        const auto& p = CuisineToFood.find(cuisine);\\n        return p->second.begin()->food;\\n    }\\n\\nprivate:\\n    // cuisine --> food set\\n    std::unordered_map<std::string, std::set<FoodRating>> CuisineToFood;\\n    std::unordered_map<string, std::pair<int, std::string>> FoodToCuisine;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct FoodRating {\\n    std::string food;\\n    int rating;\\n    bool operator<(const FoodRating& o) const {\\n        if (rating == o.rating) {\\n            return food.compare(o.food) < 0;\\n        }\\n        return rating > o.rating;\\n    }\\n};\\n\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        const auto sz = foods.size();\\n        for (int i=0;i<sz;++i) {\\n            CuisineToFood[cuisines[i]].insert({foods[i], ratings[i]});\\n            FoodToCuisine[foods[i]] = {ratings[i], cuisines[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto it = FoodToCuisine.find(food);\\n        const auto& cuisine = it->second.second;\\n\\n        FoodRating fr{food, it->second.first};\\n        CuisineToFood[cuisine].erase(fr);\\n        CuisineToFood[cuisine].insert({food, newRating});\\n\\n        FoodToCuisine[food] = {newRating, it->second.second};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        const auto& p = CuisineToFood.find(cuisine);\\n        return p->second.begin()->food;\\n    }\\n\\nprivate:\\n    // cuisine --> food set\\n    std::unordered_map<std::string, std::set<FoodRating>> CuisineToFood;\\n    std::unordered_map<string, std::pair<int, std::string>> FoodToCuisine;\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965199,
                "title": "ruby-982-ms-using-crbtreemap",
                "content": "```ruby\\nclass FoodRatings\\n\\n    def initialize f, c, r\\n        @c, @f = {}, {}\\n        f.each_with_index do | f, i |\\n            @f[f] = [c[i], -r[i]]\\n            @c[c[i]] ||= CRBTreeMap.new\\n            @c[c[i]].push [-r[i], f], true\\n        end\\n    end\\n\\n    def change_rating f, n\\n        c, p = @f[f]\\n        n = -n\\n        if p != n\\n            @f[f] = [c, n]\\n            @c[c].delete [p, f]\\n            @c[c].push [n, f], true\\n        end\\n    end\\n\\n    def highest_rated(c) = @c[c].min_key.last\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass FoodRatings\\n\\n    def initialize f, c, r\\n        @c, @f = {}, {}\\n        f.each_with_index do | f, i |\\n            @f[f] = [c[i], -r[i]]\\n            @c[c[i]] ||= CRBTreeMap.new\\n            @c[c[i]].push [-r[i], f], true\\n        end\\n    end\\n\\n    def change_rating f, n\\n        c, p = @f[f]\\n        n = -n\\n        if p != n\\n            @f[f] = [c, n]\\n            @c[c].delete [p, f]\\n            @c[c].push [n, f], true\\n        end\\n    end\\n\\n    def highest_rated(c) = @c[c].min_key.last\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943270,
                "title": "python-fast-solution-using-priority-and-lazy-delete-90-fast",
                "content": "# Approach\\n1) First we create several mapping in order to get fast which cuisine the food is and it\\'s priority (which version of rating is actual)\\n2) On each update we change priority, rating and push new value to necessary $$heap$$\\n3) To get correct $$highest$$ rating firstly we clean top value from heap which are not actual and only after that we can get the answer\\n\\n# Complexity\\n- Time complexity: $$O(Nlog(N))$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nimport heapq\\n\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.heaps = defaultdict(list)\\n        self.food_mapping = defaultdict(str)\\n        self.food_priorities = defaultdict(int)\\n        self._build(foods, cuisines, ratings)\\n    \\n\\n    def _build(self, foods, cuisines, ratings):\\n        for ind, rating in enumerate(ratings):\\n            self.food_mapping[foods[ind]] = cuisines[ind]\\n            self.food_priorities[foods[ind]] = 1\\n            heapq.heappush(self.heaps[cuisines[ind]], (-rating, foods[ind], -1))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        new_priority = self.food_priorities[food] + 1\\n        self.food_priorities[food] = new_priority\\n        cuisine = self.food_mapping[food]\\n        heapq.heappush(self.heaps[cuisine], (-newRating, food, -new_priority))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.heaps[cuisine]:\\n            top = self.heaps[cuisine][0]\\n            if -top[2] != self.food_priorities[top[1]]:\\n                heapq.heappop(self.heaps[cuisine])\\n            else:\\n                break\\n        return self.heaps[cuisine][0][1]\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.heaps = defaultdict(list)\\n        self.food_mapping = defaultdict(str)\\n        self.food_priorities = defaultdict(int)\\n        self._build(foods, cuisines, ratings)\\n    \\n\\n    def _build(self, foods, cuisines, ratings):\\n        for ind, rating in enumerate(ratings):\\n            self.food_mapping[foods[ind]] = cuisines[ind]\\n            self.food_priorities[foods[ind]] = 1\\n            heapq.heappush(self.heaps[cuisines[ind]], (-rating, foods[ind], -1))\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        new_priority = self.food_priorities[food] + 1\\n        self.food_priorities[food] = new_priority\\n        cuisine = self.food_mapping[food]\\n        heapq.heappush(self.heaps[cuisine], (-newRating, food, -new_priority))\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        while self.heaps[cuisine]:\\n            top = self.heaps[cuisine][0]\\n            if -top[2] != self.food_priorities[top[1]]:\\n                heapq.heappop(self.heaps[cuisine])\\n            else:\\n                break\\n        return self.heaps[cuisine][0][1]\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936408,
                "title": "simple-heap-solution-ood",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##high level:\\n## 1. food needs to be separate class. In a real system, this needs to be a table. \\n## 2. ranking, heap is data structure to use. for each type, we keep a heap. \\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## tricky part is when rating is changed, how do we update the heap. \\n## heap is not opertimized for searching an item. so for performance, we can just update it in the food class then everytime, we visit heap, check if the rating is matching with food, if not,just ignore it and delete it from heap\\n\\n## other things to consider when you see this Question in an interview\\n## 1. cuisions can be enum instead, easier for searching\\n## 2. ranking can be async jobs, in system design, this is the topK problem. Take a look at the min sketch algorism.  \\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ninit o(nlogn)\\nget_top o(lgm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\n##high level:\\n## 1. food needs to be separate class. In a real system, this needs to be a table. \\n## 2. ranking, heap is data structure to use. for each type, we keep a heap. \\n## tricky part is when rating is changed, how do we update the heap. \\n## heap is not opertimized for searching an item. so for performance, we can just update it in the food class then everytime, we visit heap, check if the rating is matching with food, if not,just ignore it and delete it from heap\\n\\n## other things to consider when you see this Question in an interview\\n## 1. cuisions can be enum instead, easier for searching\\n## 2. ranking can be async jobs, in system design, this is the topK problem. Take a look at the min sketch algorism.  \\n \\nclass Food:\\n    def __init__(self, name: str, cuisine: str, rating: int):\\n        self.name = name\\n        self.cuisine =  cuisine\\n        self.rating = rating\\n\\nclass CuisineRanking:\\n    def __init__(self) -> None:\\n        self.food = []\\n    \\n    def add(self, food: Food) -> None:\\n        heappush(self.food, (-food.rating, food.name, food))\\n    \\n    def get_top(self) -> Food:\\n        while self.food and self.food[0][0] != -self.food[0][2].rating:\\n            heappop(self.food)\\n        if not self.food:\\n            return None\\n        return self.food[0][2]\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.all_food = defaultdict(Food)\\n        self.rankers = defaultdict(CuisineRanking)\\n        for i in range(len(foods)):\\n            food = Food(foods[i], cuisines[i], ratings[i])\\n            self.all_food[foods[i]] = food\\n            self.rankers[cuisines[i]].add(food)\\n\\n    def changeRating(self, food_name: str, newRating: int) -> None:\\n        if food_name not in self.all_food:\\n            return None\\n        food = self.all_food[food_name]\\n        food.rating = newRating\\n        self.rankers[food.cuisine].add(food)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        if cuisine not in self.rankers:\\n            return \"not valid\"\\n        top_food = self.rankers[cuisine].get_top()\\n        if not top_food:\\n            return \"not valid\"\\n        return top_food.name\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n##high level:\\n## 1. food needs to be separate class. In a real system, this needs to be a table. \\n## 2. ranking, heap is data structure to use. for each type, we keep a heap. \\n## tricky part is when rating is changed, how do we update the heap. \\n## heap is not opertimized for searching an item. so for performance, we can just update it in the food class then everytime, we visit heap, check if the rating is matching with food, if not,just ignore it and delete it from heap\\n\\n## other things to consider when you see this Question in an interview\\n## 1. cuisions can be enum instead, easier for searching\\n## 2. ranking can be async jobs, in system design, this is the topK problem. Take a look at the min sketch algorism.  \\n \\nclass Food:\\n    def __init__(self, name: str, cuisine: str, rating: int):\\n        self.name = name\\n        self.cuisine =  cuisine\\n        self.rating = rating\\n\\nclass CuisineRanking:\\n    def __init__(self) -> None:\\n        self.food = []\\n    \\n    def add(self, food: Food) -> None:\\n        heappush(self.food, (-food.rating, food.name, food))\\n    \\n    def get_top(self) -> Food:\\n        while self.food and self.food[0][0] != -self.food[0][2].rating:\\n            heappop(self.food)\\n        if not self.food:\\n            return None\\n        return self.food[0][2]\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.all_food = defaultdict(Food)\\n        self.rankers = defaultdict(CuisineRanking)\\n        for i in range(len(foods)):\\n            food = Food(foods[i], cuisines[i], ratings[i])\\n            self.all_food[foods[i]] = food\\n            self.rankers[cuisines[i]].add(food)\\n\\n    def changeRating(self, food_name: str, newRating: int) -> None:\\n        if food_name not in self.all_food:\\n            return None\\n        food = self.all_food[food_name]\\n        food.rating = newRating\\n        self.rankers[food.cuisine].add(food)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        if cuisine not in self.rankers:\\n            return \"not valid\"\\n        top_food = self.rankers[cuisine].get_top()\\n        if not top_food:\\n            return \"not valid\"\\n        return top_food.name\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926648,
                "title": "c-modern-clean-solution-with-3-hash-maps-and-a-sorted-hash-set-beats-92",
                "content": "# Code\\n```\\nclass Compare {\\n public:\\n  // If same rating, return lexicalgraphically smaller food.\\n  // NOTE: parameters must be const, and function itself must also be const.\\n  bool operator()(const pair<string, int>& p1,\\n                  const pair<string, int>& p2) const {\\n    if (p1.second == p2.second) {\\n      return p1.first < p2.first;\\n    }\\n    return p1.second > p2.second;\\n  }\\n};\\n\\nclass FoodRatings {\\n public:\\n  FoodRatings(const vector<string>& foods,\\n              const vector<string>& cuisines,\\n              const vector<int>& ratings) {\\n    for (int i = 0, n = int(foods.size()); i < n; ++i) {\\n      auto food = foods[i];\\n      auto cuisine = cuisines[i];\\n      auto rating = ratings[i];\\n\\n      food_to_cuisine[food] = cuisine;\\n      food_to_rating[food] = rating;\\n      cuisine_to_sorted_set[cuisine].insert({food, rating});\\n    }\\n  }\\n\\n  void changeRating(const string& food, int new_rating) {\\n    auto cuisine = food_to_cuisine[food];\\n    auto& old_rating = food_to_rating[food];\\n\\n    cuisine_to_sorted_set[cuisine].erase({food, old_rating});\\n    cuisine_to_sorted_set[cuisine].insert({food, new_rating});\\n\\n    old_rating = new_rating;  // Don\\'t forget to update here.\\n  }\\n\\n  string highestRated(const string& cuisine) {\\n    return cuisine_to_sorted_set[cuisine].begin()->first;\\n  }\\n\\n private:\\n  unordered_map<string, string> food_to_cuisine;\\n  unordered_map<string, int> food_to_rating;\\n  unordered_map<string, set<pair<string, int>, Compare>> cuisine_to_sorted_set;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Compare {\\n public:\\n  // If same rating, return lexicalgraphically smaller food.\\n  // NOTE: parameters must be const, and function itself must also be const.\\n  bool operator()(const pair<string, int>& p1,\\n                  const pair<string, int>& p2) const {\\n    if (p1.second == p2.second) {\\n      return p1.first < p2.first;\\n    }\\n    return p1.second > p2.second;\\n  }\\n};\\n\\nclass FoodRatings {\\n public:\\n  FoodRatings(const vector<string>& foods,\\n              const vector<string>& cuisines,\\n              const vector<int>& ratings) {\\n    for (int i = 0, n = int(foods.size()); i < n; ++i) {\\n      auto food = foods[i];\\n      auto cuisine = cuisines[i];\\n      auto rating = ratings[i];\\n\\n      food_to_cuisine[food] = cuisine;\\n      food_to_rating[food] = rating;\\n      cuisine_to_sorted_set[cuisine].insert({food, rating});\\n    }\\n  }\\n\\n  void changeRating(const string& food, int new_rating) {\\n    auto cuisine = food_to_cuisine[food];\\n    auto& old_rating = food_to_rating[food];\\n\\n    cuisine_to_sorted_set[cuisine].erase({food, old_rating});\\n    cuisine_to_sorted_set[cuisine].insert({food, new_rating});\\n\\n    old_rating = new_rating;  // Don\\'t forget to update here.\\n  }\\n\\n  string highestRated(const string& cuisine) {\\n    return cuisine_to_sorted_set[cuisine].begin()->first;\\n  }\\n\\n private:\\n  unordered_map<string, string> food_to_cuisine;\\n  unordered_map<string, int> food_to_rating;\\n  unordered_map<string, set<pair<string, int>, Compare>> cuisine_to_sorted_set;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895531,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Map;\\nimport java.util.HashMap;\\nimport java.util.TreeSet;\\n\\npublic class FoodRatings {\\n\\n    private final Map<String, FoodData> foodNameToFoodData;\\n    private final Map<String, TreeSet<FoodData>> cuisineNameToSortedFoodData;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodNameToFoodData = new HashMap<>();\\n        cuisineNameToSortedFoodData = new HashMap<>();\\n\\n        for (int i = 0; i < foods.length; ++i) {\\n            FoodData current = new FoodData(foods[i], cuisines[i], ratings[i]);\\n            foodNameToFoodData.put(foods[i], current);\\n            cuisineNameToSortedFoodData.computeIfAbsent(cuisines[i], orderedFoodData -> new TreeSet<>()).add(current);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        FoodData toUpdate = foodNameToFoodData.get(food);\\n        cuisineNameToSortedFoodData.get(toUpdate.cuisine).remove(toUpdate);\\n        toUpdate.rating = newRating;\\n        cuisineNameToSortedFoodData.get(toUpdate.cuisine).add(toUpdate);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        return cuisineNameToSortedFoodData.get(cuisine).first().name;\\n    }\\n\\n}\\n\\nclass FoodData implements Comparable<FoodData> {\\n\\n    String name;\\n    String cuisine;\\n    int rating;\\n\\n    FoodData(String name, String cuisine, int rating) {\\n        this.name = name;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n\\n    @Override\\n    public int compareTo(FoodData other) {\\n        if (this.rating == other.rating) {\\n            return this.name.compareTo(other.name);\\n        }\\n        return other.rating - this.rating;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/*\\n @param{string}name\\n @param{string}cuisine\\n @param{number}rating\\n */\\nfunction FoodData(name, cuisine, rating) {\\n    this.name = name;\\n    this.cuisine = cuisine;\\n    this.rating = rating;\\n}\\n\\nclass FoodRatings {\\n\\n    /*\\n     @param{string[]}foods\\n     @param{string[]}cuisines\\n     @param{number[]}ratings\\n     */\\n    constructor(foods, cuisines, ratings) {\\n        //Map<string, FoodData>\\n        this.foodNameToFoodData = new Map();\\n        //const {MaxPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n        //Map<string, MaxPriorityQueue<FoodData>>, lazy update for MaxPriorityQueue<FoodData> in method \\'highestRated(cuisine)\\'\\n        this.cuisineNameToHeapifiedFoodData = new Map();\\n\\n        for (let i = 0; i < foods.length; ++i) {\\n            let currentFood = new FoodData(foods[i], cuisines[i], ratings[i]);\\n            this.foodNameToFoodData.set(foods[i], currentFood);\\n            if (!this.cuisineNameToHeapifiedFoodData.has(cuisines[i])) {\\n                this.cuisineNameToHeapifiedFoodData.set(cuisines[i],\\n                        new MaxPriorityQueue({compare: (x, y) => (x.rating === y.rating) ? x.name.localeCompare(y.name) : (y.rating - x.rating)}));\\n            }\\n            this.cuisineNameToHeapifiedFoodData.get(cuisines[i]).enqueue(currentFood);\\n        }\\n    }\\n\\n    /**\\n     *@param{string}food\\n     *@param{number}newRating\\n     *@return{void}\\n     */\\n    changeRating(food, newRating) {\\n        let toUpdate = this.foodNameToFoodData.get(food);\\n        let updated = new FoodData(toUpdate.name, toUpdate.cuisine, newRating);\\n        this.foodNameToFoodData.set(food, updated);\\n        this.cuisineNameToHeapifiedFoodData.get(toUpdate.cuisine).enqueue(updated);\\n    }\\n\\n    /**\\n     *@param{string}cuisine\\n     *@return{string}\\n     */\\n    highestRated(cuisine) {\\n        let highestRatedFoodForCuisine = \"\";\\n        while (true) {\\n            let food = this.cuisineNameToHeapifiedFoodData.get(cuisine).front();\\n            if (food.rating !== this.foodNameToFoodData.get(food.name).rating) {\\n                this.cuisineNameToHeapifiedFoodData.get(cuisine).dequeue();\\n            } else {\\n                highestRatedFoodForCuisine = food.name;\\n                break;\\n            }\\n        }\\n        return highestRatedFoodForCuisine;\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <set>\\n#include <string>\\nusing namespace std;\\n\\nstruct FoodData {\\n    string name;\\n    string cuisine;\\n    int rating{};\\n\\n    FoodData() = default;\\n    FoodData(string name, string cuisine, int rating) : name{name}, cuisine{cuisine}, rating{rating}{}\\n\\n    bool operator<(const FoodData& first) const {\\n        if (rating == first.rating) {\\n            return name < first.name;\\n        }\\n        return rating > first.rating;\\n    }\\n};\\n\\nclass FoodRatings {\\n    \\n    unordered_map<string, FoodData> foodNameToFoodData;\\n    unordered_map<string, set<FoodData>> cuisineNameToSortedFoodData;\\n\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (size_t i = 0; i < foods.size(); ++i) {\\n            foodNameToFoodData.emplace(foods[i], FoodData(foods[i], cuisines[i], ratings[i]));\\n            cuisineNameToSortedFoodData[cuisines[i]].emplace(foods[i], cuisines[i], ratings[i]);\\n        }\\n    }\\n\\n    void changeRating(const string& food, int newRating) {\\n        FoodData& toUpdate = foodNameToFoodData[food];\\n        cuisineNameToSortedFoodData[toUpdate.cuisine].erase(toUpdate);\\n        toUpdate.rating = newRating;\\n        cuisineNameToSortedFoodData[toUpdate.cuisine].insert(toUpdate);\\n    }\\n\\n    string highestRated(const string& cuisine) const {\\n        return cuisineNameToSortedFoodData.at(cuisine).begin()->name;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nimport java.util.Map;\\nimport java.util.HashMap;\\nimport java.util.TreeSet;\\n\\npublic class FoodRatings {\\n\\n    private final Map<String, FoodData> foodNameToFoodData;\\n    private final Map<String, TreeSet<FoodData>> cuisineNameToSortedFoodData;\\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodNameToFoodData = new HashMap<>();\\n        cuisineNameToSortedFoodData = new HashMap<>();\\n\\n        for (int i = 0; i < foods.length; ++i) {\\n            FoodData current = new FoodData(foods[i], cuisines[i], ratings[i]);\\n            foodNameToFoodData.put(foods[i], current);\\n            cuisineNameToSortedFoodData.computeIfAbsent(cuisines[i], orderedFoodData -> new TreeSet<>()).add(current);\\n        }\\n    }\\n\\n    public void changeRating(String food, int newRating) {\\n        FoodData toUpdate = foodNameToFoodData.get(food);\\n        cuisineNameToSortedFoodData.get(toUpdate.cuisine).remove(toUpdate);\\n        toUpdate.rating = newRating;\\n        cuisineNameToSortedFoodData.get(toUpdate.cuisine).add(toUpdate);\\n    }\\n\\n    public String highestRated(String cuisine) {\\n        return cuisineNameToSortedFoodData.get(cuisine).first().name;\\n    }\\n\\n}\\n\\nclass FoodData implements Comparable<FoodData> {\\n\\n    String name;\\n    String cuisine;\\n    int rating;\\n\\n    FoodData(String name, String cuisine, int rating) {\\n        this.name = name;\\n        this.cuisine = cuisine;\\n        this.rating = rating;\\n    }\\n\\n    @Override\\n    public int compareTo(FoodData other) {\\n        if (this.rating == other.rating) {\\n            return this.name.compareTo(other.name);\\n        }\\n        return other.rating - this.rating;\\n    }\\n}\\n```\n```\\n/*\\n @param{string}name\\n @param{string}cuisine\\n @param{number}rating\\n */\\nfunction FoodData(name, cuisine, rating) {\\n    this.name = name;\\n    this.cuisine = cuisine;\\n    this.rating = rating;\\n}\\n\\nclass FoodRatings {\\n\\n    /*\\n     @param{string[]}foods\\n     @param{string[]}cuisines\\n     @param{number[]}ratings\\n     */\\n    constructor(foods, cuisines, ratings) {\\n        //Map<string, FoodData>\\n        this.foodNameToFoodData = new Map();\\n        //const {MaxPriorityQueue} = require(\\'@datastructures-js/priority-queue\\');\\n        //Map<string, MaxPriorityQueue<FoodData>>, lazy update for MaxPriorityQueue<FoodData> in method \\'highestRated(cuisine)\\'\\n        this.cuisineNameToHeapifiedFoodData = new Map();\\n\\n        for (let i = 0; i < foods.length; ++i) {\\n            let currentFood = new FoodData(foods[i], cuisines[i], ratings[i]);\\n            this.foodNameToFoodData.set(foods[i], currentFood);\\n            if (!this.cuisineNameToHeapifiedFoodData.has(cuisines[i])) {\\n                this.cuisineNameToHeapifiedFoodData.set(cuisines[i],\\n                        new MaxPriorityQueue({compare: (x, y) => (x.rating === y.rating) ? x.name.localeCompare(y.name) : (y.rating - x.rating)}));\\n            }\\n            this.cuisineNameToHeapifiedFoodData.get(cuisines[i]).enqueue(currentFood);\\n        }\\n    }\\n\\n    /**\\n     *@param{string}food\\n     *@param{number}newRating\\n     *@return{void}\\n     */\\n    changeRating(food, newRating) {\\n        let toUpdate = this.foodNameToFoodData.get(food);\\n        let updated = new FoodData(toUpdate.name, toUpdate.cuisine, newRating);\\n        this.foodNameToFoodData.set(food, updated);\\n        this.cuisineNameToHeapifiedFoodData.get(toUpdate.cuisine).enqueue(updated);\\n    }\\n\\n    /**\\n     *@param{string}cuisine\\n     *@return{string}\\n     */\\n    highestRated(cuisine) {\\n        let highestRatedFoodForCuisine = \"\";\\n        while (true) {\\n            let food = this.cuisineNameToHeapifiedFoodData.get(cuisine).front();\\n            if (food.rating !== this.foodNameToFoodData.get(food.name).rating) {\\n                this.cuisineNameToHeapifiedFoodData.get(cuisine).dequeue();\\n            } else {\\n                highestRatedFoodForCuisine = food.name;\\n                break;\\n            }\\n        }\\n        return highestRatedFoodForCuisine;\\n    }\\n}\\n```\n```\\n#include <set>\\n#include <string>\\nusing namespace std;\\n\\nstruct FoodData {\\n    string name;\\n    string cuisine;\\n    int rating{};\\n\\n    FoodData() = default;\\n    FoodData(string name, string cuisine, int rating) : name{name}, cuisine{cuisine}, rating{rating}{}\\n\\n    bool operator<(const FoodData& first) const {\\n        if (rating == first.rating) {\\n            return name < first.name;\\n        }\\n        return rating > first.rating;\\n    }\\n};\\n\\nclass FoodRatings {\\n    \\n    unordered_map<string, FoodData> foodNameToFoodData;\\n    unordered_map<string, set<FoodData>> cuisineNameToSortedFoodData;\\n\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (size_t i = 0; i < foods.size(); ++i) {\\n            foodNameToFoodData.emplace(foods[i], FoodData(foods[i], cuisines[i], ratings[i]));\\n            cuisineNameToSortedFoodData[cuisines[i]].emplace(foods[i], cuisines[i], ratings[i]);\\n        }\\n    }\\n\\n    void changeRating(const string& food, int newRating) {\\n        FoodData& toUpdate = foodNameToFoodData[food];\\n        cuisineNameToSortedFoodData[toUpdate.cuisine].erase(toUpdate);\\n        toUpdate.rating = newRating;\\n        cuisineNameToSortedFoodData[toUpdate.cuisine].insert(toUpdate);\\n    }\\n\\n    string highestRated(const string& cuisine) const {\\n        return cuisineNameToSortedFoodData.at(cuisine).begin()->name;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2887449,
                "title": "three-maps",
                "content": "\\n# Complexity\\n- Time complexity:\\n   O(n)+O(log n)\\n\\n# Code\\n```\\nclass FoodRatings {\\n    HashMap<String,Integer> foodRating=new HashMap<>();\\n    HashMap<String,String> foodCuisine=new HashMap<>();\\n    HashMap<String, SortedSet<Pair<String,Integer>>> cuisineToFoodMap=new HashMap<>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n=foods.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            foodRating.put(foods[i],ratings[i]);\\n            foodCuisine.put(foods[i],cuisines[i]);\\n            if(!cuisineToFoodMap.containsKey(cuisines[i]))\\n            {\\n                cuisineToFoodMap.put(cuisines[i], new TreeSet<Pair<String,Integer>>(\\n                    (a,b)->\\n                    (int)a.getValue()==(int)b.getValue()? a.getKey().toString().compareTo(b.getKey().toString()):\\n                    (int)b.getValue()-(int)a.getValue()\\n                    )\\n                    );\\n            }\\n            Pair<String,Integer> temp=new Pair<>(foods[i],ratings[i]);\\n            cuisineToFoodMap.get(cuisines[i]).add(temp);\\n        }\\n        // System.out.println( cuisineToFoodMap);\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cui=foodCuisine.get(food);\\n        int rate=foodRating.get(food);\\n        cuisineToFoodMap.get(cui).remove(new Pair<String,Integer>(food,rate));\\n        cuisineToFoodMap.get(cui).add(new Pair<String,Integer>(food,newRating));\\n        // System.out.println( cuisineToFoodMap);\\n       foodRating.put(food,newRating); \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        return  cuisineToFoodMap.get(cuisine).first().getKey();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    HashMap<String,Integer> foodRating=new HashMap<>();\\n    HashMap<String,String> foodCuisine=new HashMap<>();\\n    HashMap<String, SortedSet<Pair<String,Integer>>> cuisineToFoodMap=new HashMap<>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        int n=foods.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            foodRating.put(foods[i],ratings[i]);\\n            foodCuisine.put(foods[i],cuisines[i]);\\n            if(!cuisineToFoodMap.containsKey(cuisines[i]))\\n            {\\n                cuisineToFoodMap.put(cuisines[i], new TreeSet<Pair<String,Integer>>(\\n                    (a,b)->\\n                    (int)a.getValue()==(int)b.getValue()? a.getKey().toString().compareTo(b.getKey().toString()):\\n                    (int)b.getValue()-(int)a.getValue()\\n                    )\\n                    );\\n            }\\n            Pair<String,Integer> temp=new Pair<>(foods[i],ratings[i]);\\n            cuisineToFoodMap.get(cuisines[i]).add(temp);\\n        }\\n        // System.out.println( cuisineToFoodMap);\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        String cui=foodCuisine.get(food);\\n        int rate=foodRating.get(food);\\n        cuisineToFoodMap.get(cui).remove(new Pair<String,Integer>(food,rate));\\n        cuisineToFoodMap.get(cui).add(new Pair<String,Integer>(food,newRating));\\n        // System.out.println( cuisineToFoodMap);\\n       foodRating.put(food,newRating); \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        return  cuisineToFoodMap.get(cuisine).first().getKey();\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800606,
                "title": "simplified-solution",
                "content": "```\\nclass FoodRatings\\n{\\n    public:\\n    unordered_map<string, int> mp; // for ratings\\n    unordered_map<string, string> mp2; // for cuisins\\n    unordered_map<string, set<pair<int, string>>> hrating;\\n\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[foods[i]] = ratings[i]; // O(N)\\n            mp2[foods[i]] = cuisines[i]; // O(N)\\n            hrating[cuisines[i]].insert({ -ratings[i], foods[i] }); // O(N log M) M => size(set)\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        string t = mp2[food];  // O(1)\\n        int tmp = mp[food]; //  O(1)\\n        mp[food] = newRating; // O(1)\\n        hrating[t].erase(hrating[t].find({ -tmp, food }));  // O(log M)\\n        hrating[t].insert({ -newRating, food }); // O(log M)\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n\\n        string res = \"\";\\n        auto anss = *(hrating[cuisine].begin());  // O(1)\\n        res = anss.second;\\n        return res;\\n    }\\n};\\n\\n/*\\n    Time Complexity => ~ O(N log N)\\n    Space Complexity => 3 * O(N)\\n*/\\n\\n\\n// class Food\\n// {\\n//     int rating;\\n//     string name, cuisine;\\n//     Food(string name, string cuisine, int rating)\\n//     {\\n//         name = name; rating = rating; cuisine = cuisine;\\n//     }\\n// }\\n\\n/**\\n *Your FoodRatings object will be instantiated and called as such:\\n *FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n *obj->changeRating(food,newRating);\\n *string param_2 = obj->highestRated(cuisine);\\n */\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings\\n{\\n    public:\\n    unordered_map<string, int> mp; // for ratings\\n    unordered_map<string, string> mp2; // for cuisins\\n    unordered_map<string, set<pair<int, string>>> hrating;\\n\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[foods[i]] = ratings[i]; // O(N)\\n            mp2[foods[i]] = cuisines[i]; // O(N)\\n            hrating[cuisines[i]].insert({ -ratings[i], foods[i] }); // O(N log M) M => size(set)\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        string t = mp2[food];  // O(1)\\n        int tmp = mp[food]; //  O(1)\\n        mp[food] = newRating; // O(1)\\n        hrating[t].erase(hrating[t].find({ -tmp, food }));  // O(log M)\\n        hrating[t].insert({ -newRating, food }); // O(log M)\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n\\n        string res = \"\";\\n        auto anss = *(hrating[cuisine].begin());  // O(1)\\n        res = anss.second;\\n        return res;\\n    }\\n};\\n\\n/*\\n    Time Complexity => ~ O(N log N)\\n    Space Complexity => 3 * O(N)\\n*/\\n\\n\\n// class Food\\n// {\\n//     int rating;\\n//     string name, cuisine;\\n//     Food(string name, string cuisine, int rating)\\n//     {\\n//         name = name; rating = rating; cuisine = cuisine;\\n//     }\\n// }\\n\\n/**\\n *Your FoodRatings object will be instantiated and called as such:\\n *FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n *obj->changeRating(food,newRating);\\n *string param_2 = obj->highestRated(cuisine);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779058,
                "title": "best-solution-in-c-heap",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass FoodRatings {\\npublic:\\n    class comp{\\n        public:\\n            bool operator()(pair<int,string> p1,pair<int,string> p2){\\n                if(p1.first>p2.first)\\n                    return false;\\n                if(p1.first==p2.first){\\n                    if(p1.second<p2.second)\\n                        return false;\\n                }\\n                return true;\\n            }\\n    };\\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,comp>> mp;\\n    unordered_map<string,pair<int,string>> mm;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            mm[foods[i]].first=ratings[i];\\n            mm[foods[i]].second=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        mm[food].first=newRating;\\n        string req_cuisine=mm[food].second;\\n        mp[req_cuisine].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        while(mp[cuisine].size()){\\n            pair<int,string> p=mp[cuisine].top();\\n            string s=p.second;\\n            int r=p.first;\\n            if(mm[s].first==r)\\n                return s;\\n            mp[cuisine].pop();\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    class comp{\\n        public:\\n            bool operator()(pair<int,string> p1,pair<int,string> p2){\\n                if(p1.first>p2.first)\\n                    return false;\\n                if(p1.first==p2.first){\\n                    if(p1.second<p2.second)\\n                        return false;\\n                }\\n                return true;\\n            }\\n    };\\n    unordered_map<string,priority_queue<pair<int,string>,vector<pair<int,string>>,comp>> mp;\\n    unordered_map<string,pair<int,string>> mm;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            mp[cuisines[i]].push({ratings[i],foods[i]});\\n            mm[foods[i]].first=ratings[i];\\n            mm[foods[i]].second=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        mm[food].first=newRating;\\n        string req_cuisine=mm[food].second;\\n        mp[req_cuisine].push({newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        while(mp[cuisine].size()){\\n            pair<int,string> p=mp[cuisine].top();\\n            string s=p.second;\\n            int r=p.first;\\n            if(mm[s].first==r)\\n                return s;\\n            mp[cuisine].pop();\\n        }\\n        return \"\";\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760987,
                "title": "c-887-ms",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(const vector<string>& foods,\\n                const vector<string>& cuisines,\\n                const vector<int>&    ratings  ) {\\n        \\n        for(size_t i=0; i<foods.size(); ++i) {\\n            cuisineTable[foods[i]] = cuisines[i];\\n            ratingTable [foods[i]] = ratings[i];\\n            dataTable[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(const string& food, int newRating) {\\n        int rating = ratingTable[food];\\n        string cuisine = cuisineTable[food];\\n        \\n        if(dataTable[cuisine][rating].size()==1)\\n            dataTable[cuisine].erase(rating);\\n        else dataTable[cuisine][rating].erase(food);\\n            \\n        dataTable[cuisine][newRating].insert(food);\\n        ratingTable[food] = newRating;\\n    }\\n    \\n    string highestRated(const string& cuisine) {\\n        return *dataTable[cuisine].rbegin()->second.begin();\\n    }\\n    \\nprivate:\\n    unordered_map<string, string>                cuisineTable; //food,cuisine\\n    unordered_map<string, int>                   ratingTable; //food,raiting\\n    unordered_map<string, map<int,set<string>>>  dataTable;  //cuisine,rating,foods\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(const vector<string>& foods,\\n                const vector<string>& cuisines,\\n                const vector<int>&    ratings  ) {\\n        \\n        for(size_t i=0; i<foods.size(); ++i) {\\n            cuisineTable[foods[i]] = cuisines[i];\\n            ratingTable [foods[i]] = ratings[i];\\n            dataTable[cuisines[i]][ratings[i]].insert(foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(const string& food, int newRating) {\\n        int rating = ratingTable[food];\\n        string cuisine = cuisineTable[food];\\n        \\n        if(dataTable[cuisine][rating].size()==1)\\n            dataTable[cuisine].erase(rating);\\n        else dataTable[cuisine][rating].erase(food);\\n            \\n        dataTable[cuisine][newRating].insert(food);\\n        ratingTable[food] = newRating;\\n    }\\n    \\n    string highestRated(const string& cuisine) {\\n        return *dataTable[cuisine].rbegin()->second.begin();\\n    }\\n    \\nprivate:\\n    unordered_map<string, string>                cuisineTable; //food,cuisine\\n    unordered_map<string, int>                   ratingTable; //food,raiting\\n    unordered_map<string, map<int,set<string>>>  dataTable;  //cuisine,rating,foods\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701008,
                "title": "solution-1-sorted-list-solution-2-heap-python",
                "content": "**Sorted List** solution:\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.ratings = defaultdict(SortedList) # c --> [(-r, f), ...]\\n        self.frc = {} # f --> (c, r)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.ratings[c].add((-r, f))\\n            self.frc[f] = c, r\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, oldRating = self.frc[food]\\n        self.ratings[cuisine].remove((-oldRating, food))\\n        self.ratings[cuisine].add((-newRating, food))       \\n        self.frc[food] = (cuisine, newRating)\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.ratings[cuisine][0][1]\\n```\\n\\\\\\n**Heap** solution:\\n```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.ratings = defaultdict(list) # c --> [[-r, f], ...]\\n        self.frc = {} # f --> r, c\\n        \\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.ratings[c].append([-r, f])\\n            self.frc[f] = r, c\\n            \\n        for h in self.ratings.values():\\n            heapify(h)\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.frc[food][1]\\n        heappush(self.ratings[cuisine], [-newRating, food])\\n        self.frc[food] = (newRating, cuisine)    \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        heap = self.ratings[cuisine]\\n        while self.frc[heap[0][1]][0] != -heap[0][0]:\\n            heappop(heap)\\n        return heap[0][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.ratings = defaultdict(SortedList) # c --> [(-r, f), ...]\\n        self.frc = {} # f --> (c, r)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.ratings[c].add((-r, f))\\n            self.frc[f] = c, r\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, oldRating = self.frc[food]\\n        self.ratings[cuisine].remove((-oldRating, food))\\n        self.ratings[cuisine].add((-newRating, food))       \\n        self.frc[food] = (cuisine, newRating)\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        return self.ratings[cuisine][0][1]\\n```\n```\\nclass FoodRatings:\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.ratings = defaultdict(list) # c --> [[-r, f], ...]\\n        self.frc = {} # f --> r, c\\n        \\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.ratings[c].append([-r, f])\\n            self.frc[f] = r, c\\n            \\n        for h in self.ratings.values():\\n            heapify(h)\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine = self.frc[food][1]\\n        heappush(self.ratings[cuisine], [-newRating, food])\\n        self.frc[food] = (newRating, cuisine)    \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        heap = self.ratings[cuisine]\\n        while self.frc[heap[0][1]][0] != -heap[0][0]:\\n            heappop(heap)\\n        return heap[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694641,
                "title": "python3-priority-queue-and-three-hashmaps",
                "content": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n      self.data_ = {}\\n      self.valid_ = defaultdict(int)\\n      self.lookup_ = defaultdict(str)\\n      for i in range(len(foods)):\\n        f, c, r = foods[i], cuisines[i], ratings[i]\\n        self.valid_[f] = -r\\n        self.lookup_[f] = c\\n        if c not in self.data_:\\n          self.data_[c] = [(-r, f)]\\n        else:\\n          self.data_[c].append((-r, f))\\n      for key in self.data_.keys():\\n        self.data_[key].sort(key = lambda x: (x[0], x[1]))\\n        heapify(self.data_[key])\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n      self.valid_[food] = -newRating\\n      heappush(self.data_[self.lookup_[food]], (-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n      while True:\\n        r, f = self.data_[cuisine][0]\\n        if self.valid_[f] == r:\\n          return f\\n        else:\\n          heappop(self.data_[cuisine])\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n      self.data_ = {}\\n      self.valid_ = defaultdict(int)\\n      self.lookup_ = defaultdict(str)\\n      for i in range(len(foods)):\\n        f, c, r = foods[i], cuisines[i], ratings[i]\\n        self.valid_[f] = -r\\n        self.lookup_[f] = c\\n        if c not in self.data_:\\n          self.data_[c] = [(-r, f)]\\n        else:\\n          self.data_[c].append((-r, f))\\n      for key in self.data_.keys():\\n        self.data_[key].sort(key = lambda x: (x[0], x[1]))\\n        heapify(self.data_[key])\\n        \\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n      self.valid_[food] = -newRating\\n      heappush(self.data_[self.lookup_[food]], (-newRating, food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n      while True:\\n        r, f = self.data_[cuisine][0]\\n        if self.valid_[f] == r:\\n          return f\\n        else:\\n          heappop(self.data_[cuisine])\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674015,
                "title": "golang-369-ms-20-mb",
                "content": "```\\ntype Food struct {\\n\\tname       string\\n\\trating     int32\\n\\tcuisineIdx int16\\n\\tcuisinePos int16\\n}\\n\\ntype Cuisine []*Food\\n\\nfunc (c Cuisine) Len() int { return len(c) }\\nfunc (c Cuisine) Less(i, j int) bool {\\n\\treturn c[i].rating > c[j].rating || (c[i].rating == c[j].rating && c[i].name < c[j].name)\\n}\\nfunc (c Cuisine) Swap(i, j int) {\\n\\tc[i].cuisinePos = int16(j)\\n\\tc[j].cuisinePos = int16(i)\\n\\tc[i], c[j] = c[j], c[i]\\n}\\nfunc (c *Cuisine) Push(x interface{}) { *c = append(*c, x.(*Food)) }\\nfunc (c *Cuisine) Pop() interface{} {\\n\\told := *c\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*c = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype FoodRatings struct {\\n\\tfoodNameToIdx    map[string]int16\\n\\tfoods            []Food\\n\\tcuisineNameToIdx map[string]int16\\n\\tcuisines         []Cuisine\\n}\\n\\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\\n\\tfoodsSl := make([]Food, len(foods))\\n\\tfoodsM := make(map[string]int16, len(foods))\\n\\tcuisineM := make(map[string]int16)\\n\\n\\tfor i := 0; i < len(foods); i++ {\\n\\t\\tfoodsSl[i].name = foods[i]\\n\\t\\tfoodsSl[i].rating = int32(ratings[i])\\n\\t\\tfoodsM[foods[i]] = int16(i)\\n\\t\\tcuisineM[cuisines[i]]++\\n\\t}\\n\\n\\tcuisinesSl := make([]Cuisine, 0, len(cuisineM))\\n\\tfor cuisine, count := range cuisineM {\\n\\t\\tcuisineIdx := int16(len(cuisinesSl))\\n\\t\\tcuisinesSl = append(cuisinesSl, make([]*Food, 0, count))\\n\\t\\tcuisineM[cuisine] = cuisineIdx\\n\\t}\\n\\n\\tfor i := 0; i < len(foods); i++ {\\n\\t\\tcuisineIdx := cuisineM[cuisines[i]]\\n\\t\\tfoodsSl[i].cuisineIdx = cuisineIdx\\n\\t\\tfoodsSl[i].cuisinePos = int16(len(cuisinesSl[cuisineIdx]))\\n\\t\\tcuisinesSl[cuisineIdx] = append(cuisinesSl[cuisineIdx], &foodsSl[i])\\n\\t}\\n\\n\\tfor i := 0; i < len(cuisinesSl); i++ {\\n\\t\\theap.Init(&cuisinesSl[i])\\n\\t}\\n\\n\\treturn FoodRatings{\\n\\t\\tfoodNameToIdx:    foodsM,\\n\\t\\tfoods:            foodsSl,\\n\\t\\tcuisineNameToIdx: cuisineM,\\n\\t\\tcuisines:         cuisinesSl,\\n\\t}\\n}\\n\\nfunc (f FoodRatings) ChangeRating(foodName string, newRating int) {\\n\\tfoodIdx := f.foodNameToIdx[foodName]\\n\\tif f.foods[foodIdx].rating != int32(newRating) {\\n\\t\\tf.foods[foodIdx].rating = int32(newRating)\\n\\t\\theap.Fix(&f.cuisines[f.foods[foodIdx].cuisineIdx], int(f.foods[foodIdx].cuisinePos))\\n\\t}\\n}\\n\\nfunc (f FoodRatings) HighestRated(cuisine string) string {\\n\\treturn f.cuisines[f.cuisineNameToIdx[cuisine]][0].name\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Food struct {\\n\\tname       string\\n\\trating     int32\\n\\tcuisineIdx int16\\n\\tcuisinePos int16\\n}\\n\\ntype Cuisine []*Food\\n\\nfunc (c Cuisine) Len() int { return len(c) }\\nfunc (c Cuisine) Less(i, j int) bool {\\n\\treturn c[i].rating > c[j].rating || (c[i].rating == c[j].rating && c[i].name < c[j].name)\\n}\\nfunc (c Cuisine) Swap(i, j int) {\\n\\tc[i].cuisinePos = int16(j)\\n\\tc[j].cuisinePos = int16(i)\\n\\tc[i], c[j] = c[j], c[i]\\n}\\nfunc (c *Cuisine) Push(x interface{}) { *c = append(*c, x.(*Food)) }\\nfunc (c *Cuisine) Pop() interface{} {\\n\\told := *c\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*c = old[0 : n-1]\\n\\treturn x\\n}\\n\\ntype FoodRatings struct {\\n\\tfoodNameToIdx    map[string]int16\\n\\tfoods            []Food\\n\\tcuisineNameToIdx map[string]int16\\n\\tcuisines         []Cuisine\\n}\\n\\nfunc Constructor(foods []string, cuisines []string, ratings []int) FoodRatings {\\n\\tfoodsSl := make([]Food, len(foods))\\n\\tfoodsM := make(map[string]int16, len(foods))\\n\\tcuisineM := make(map[string]int16)\\n\\n\\tfor i := 0; i < len(foods); i++ {\\n\\t\\tfoodsSl[i].name = foods[i]\\n\\t\\tfoodsSl[i].rating = int32(ratings[i])\\n\\t\\tfoodsM[foods[i]] = int16(i)\\n\\t\\tcuisineM[cuisines[i]]++\\n\\t}\\n\\n\\tcuisinesSl := make([]Cuisine, 0, len(cuisineM))\\n\\tfor cuisine, count := range cuisineM {\\n\\t\\tcuisineIdx := int16(len(cuisinesSl))\\n\\t\\tcuisinesSl = append(cuisinesSl, make([]*Food, 0, count))\\n\\t\\tcuisineM[cuisine] = cuisineIdx\\n\\t}\\n\\n\\tfor i := 0; i < len(foods); i++ {\\n\\t\\tcuisineIdx := cuisineM[cuisines[i]]\\n\\t\\tfoodsSl[i].cuisineIdx = cuisineIdx\\n\\t\\tfoodsSl[i].cuisinePos = int16(len(cuisinesSl[cuisineIdx]))\\n\\t\\tcuisinesSl[cuisineIdx] = append(cuisinesSl[cuisineIdx], &foodsSl[i])\\n\\t}\\n\\n\\tfor i := 0; i < len(cuisinesSl); i++ {\\n\\t\\theap.Init(&cuisinesSl[i])\\n\\t}\\n\\n\\treturn FoodRatings{\\n\\t\\tfoodNameToIdx:    foodsM,\\n\\t\\tfoods:            foodsSl,\\n\\t\\tcuisineNameToIdx: cuisineM,\\n\\t\\tcuisines:         cuisinesSl,\\n\\t}\\n}\\n\\nfunc (f FoodRatings) ChangeRating(foodName string, newRating int) {\\n\\tfoodIdx := f.foodNameToIdx[foodName]\\n\\tif f.foods[foodIdx].rating != int32(newRating) {\\n\\t\\tf.foods[foodIdx].rating = int32(newRating)\\n\\t\\theap.Fix(&f.cuisines[f.foods[foodIdx].cuisineIdx], int(f.foods[foodIdx].cuisinePos))\\n\\t}\\n}\\n\\nfunc (f FoodRatings) HighestRated(cuisine string) string {\\n\\treturn f.cuisines[f.cuisineNameToIdx[cuisine]][0].name\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2663919,
                "title": "hashmap-and-ordered-set-c-easy-implementation",
                "content": "```\\nclass FoodRatings\\n{\\n    public:\\n\\n        unordered_map<string, int> food_rating;\\n    unordered_map<string, set<pair<int, string>>> cousin_rating;\\n    unordered_map<string, string> food_cousin;\\n\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            food_rating[foods[i]] = ratings[i];\\n            cousin_rating[cuisines[i]].insert({ -ratings[i],\\n                foods[i] });\\n            food_cousin[foods[i]] = cuisines[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        int curr_rating = food_rating[food];\\n\\n        food_rating[food] = newRating;\\n\\n        string find_cusine = food_cousin[food];\\n\\n       \\t\\n        cousin_rating[find_cusine].erase({ -curr_rating,\\n            food });\\n\\n        cousin_rating[find_cusine].insert({ -newRating,\\n            food });\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return cousin_rating[cuisine].begin()->second;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings\\n{\\n    public:\\n\\n        unordered_map<string, int> food_rating;\\n    unordered_map<string, set<pair<int, string>>> cousin_rating;\\n    unordered_map<string, string> food_cousin;\\n\\n    FoodRatings(vector<string> &foods, vector<string> &cuisines, vector< int > &ratings)\\n    {\\n        int n = foods.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            food_rating[foods[i]] = ratings[i];\\n            cousin_rating[cuisines[i]].insert({ -ratings[i],\\n                foods[i] });\\n            food_cousin[foods[i]] = cuisines[i];\\n        }\\n    }\\n\\n    void changeRating(string food, int newRating)\\n    {\\n        int curr_rating = food_rating[food];\\n\\n        food_rating[food] = newRating;\\n\\n        string find_cusine = food_cousin[food];\\n\\n       \\t\\n        cousin_rating[find_cusine].erase({ -curr_rating,\\n            food });\\n\\n        cousin_rating[find_cusine].insert({ -newRating,\\n            food });\\n    }\\n\\n    string highestRated(string cuisine)\\n    {\\n        return cousin_rating[cuisine].begin()->second;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659084,
                "title": "three-map-custom-set-comparator-c",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    struct cmp{\\n        bool operator()(const pair<int,string> &a,const pair<int,string>& b)\\n        const {\\n            if(a.first!=b.first)\\n            {\\n                return a.first>b.first;\\n            }\\n            return a.second<b.second;\\n        }\\n    };\\n    \\n    unordered_map<string,set<pair<int,string>,cmp>> m;\\n    unordered_map<string,string> m2;\\n    unordered_map<string,pair<int,string>> m3;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<ratings.size();++i)\\n        {\\n            m[cuisines[i]].insert({ratings[i],foods[i]});\\n            m2[foods[i]]=cuisines[i];\\n            m3[foods[i]]={ratings[i],foods[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string& cuisi=m2[food];\\n        pair<int,string>& oldfood=m3[food];\\n        m[cuisi].erase(oldfood);\\n        m[cuisi].insert({newRating,food});\\n        m3[food]={newRating,food};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*(m[cuisine].begin())).second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    struct cmp{\\n        bool operator()(const pair<int,string> &a,const pair<int,string>& b)\\n        const {\\n            if(a.first!=b.first)\\n            {\\n                return a.first>b.first;\\n            }\\n            return a.second<b.second;\\n        }\\n    };\\n    \\n    unordered_map<string,set<pair<int,string>,cmp>> m;\\n    unordered_map<string,string> m2;\\n    unordered_map<string,pair<int,string>> m3;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<ratings.size();++i)\\n        {\\n            m[cuisines[i]].insert({ratings[i],foods[i]});\\n            m2[foods[i]]=cuisines[i];\\n            m3[foods[i]]={ratings[i],foods[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        string& cuisi=m2[food];\\n        pair<int,string>& oldfood=m3[food];\\n        m[cuisi].erase(oldfood);\\n        m[cuisi].insert({newRating,food});\\n        m3[food]={newRating,food};\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return (*(m[cuisine].begin())).second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610520,
                "title": "using-two-maps-oops-two-different-implementations-treeset-pq",
                "content": "```\\nUsing TreeSet + HashTable : Much Faster Than PriorityQueue Approach(Removal in TreeSet is Fast)\\n```\\n\\n```\\nclass FoodRatings {\\n    \\n    //Used to uniquely identfied the [food, rating] inside TreeSet to make\\n    //the search easier inside TreeSet\\n    private Map<String, FoodInfo> foodInfos; \\n    \\n    private Map<String, TreeSet<FoodInfo>> cuisinesMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisine, int[] ratings) {\\n        foodInfos = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            String name = foods[i], foodStyle = cuisine[i];\\n            int rating = ratings[i];\\n            \\n            FoodInfo foodObj = new FoodInfo(name, foodStyle, rating);\\n            \\n            cuisinesMap.putIfAbsent(foodStyle, new TreeSet<>((a, b) -> {\\n                if(a.rating == b.rating) return a.name.compareTo(b.name);\\n                return Integer.compare(b.rating, a.rating);\\n            }));\\n            \\n            cuisinesMap.get(foodStyle).add(foodObj);\\n            foodInfos.put(name, foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodInfo obj = foodInfos.get(food);\\n        TreeSet<FoodInfo> nameRatings = cuisinesMap.get(obj.cuisine);\\n        //Removal & Insertion : This step must be done to re-arrange the data [name, ratings] in TreeSet\\n        //After Updation in Rating.\\n        nameRatings.remove(obj);\\n        obj.rating = newRating;\\n        nameRatings.add(obj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first().name;\\n    }\\n    \\n    private class FoodInfo {\\n        String name;\\n        String cuisine;\\n        int rating;\\n        \\n        FoodInfo(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n```\\n\\n```\\nUsing PriorityQueue + HashTable\\n```\\n\\n```\\nclass FoodRatings {\\n\\n    private Map<String, FoodInfo> foodInfos;\\n    private Map<String, PriorityQueue<FoodInfo>> cuisinesMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisine, int[] ratings) {\\n        foodInfos = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            FoodInfo foodObj = new FoodInfo(foods[i], cuisine[i], ratings[i]);\\n            \\n            cuisinesMap.putIfAbsent(cuisine[i], new PriorityQueue<>((a, b) -> {\\n                if(a.rating == b.rating) return a.name.compareTo(b.name);\\n                return Integer.compare(b.rating, a.rating);\\n            }));\\n            \\n            cuisinesMap.get(cuisine[i]).offer(foodObj);\\n            foodInfos.put(foods[i], foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodInfo obj = foodInfos.get(food);\\n        PriorityQueue<FoodInfo> nameRatings = cuisinesMap.get(obj.cuisine);\\n        nameRatings.remove(obj); //This step makes this approach slower than TreeSet Approach\\n        obj.rating = newRating;\\n        nameRatings.offer(obj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).peek().name;\\n    }\\n    \\n    private class FoodInfo {\\n        String name;\\n        String cuisine;\\n        int rating;\\n        \\n        FoodInfo(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nUsing TreeSet + HashTable : Much Faster Than PriorityQueue Approach(Removal in TreeSet is Fast)\\n```\n```\\nclass FoodRatings {\\n    \\n    //Used to uniquely identfied the [food, rating] inside TreeSet to make\\n    //the search easier inside TreeSet\\n    private Map<String, FoodInfo> foodInfos; \\n    \\n    private Map<String, TreeSet<FoodInfo>> cuisinesMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisine, int[] ratings) {\\n        foodInfos = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            String name = foods[i], foodStyle = cuisine[i];\\n            int rating = ratings[i];\\n            \\n            FoodInfo foodObj = new FoodInfo(name, foodStyle, rating);\\n            \\n            cuisinesMap.putIfAbsent(foodStyle, new TreeSet<>((a, b) -> {\\n                if(a.rating == b.rating) return a.name.compareTo(b.name);\\n                return Integer.compare(b.rating, a.rating);\\n            }));\\n            \\n            cuisinesMap.get(foodStyle).add(foodObj);\\n            foodInfos.put(name, foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodInfo obj = foodInfos.get(food);\\n        TreeSet<FoodInfo> nameRatings = cuisinesMap.get(obj.cuisine);\\n        //Removal & Insertion : This step must be done to re-arrange the data [name, ratings] in TreeSet\\n        //After Updation in Rating.\\n        nameRatings.remove(obj);\\n        obj.rating = newRating;\\n        nameRatings.add(obj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first().name;\\n    }\\n    \\n    private class FoodInfo {\\n        String name;\\n        String cuisine;\\n        int rating;\\n        \\n        FoodInfo(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n```\n```\\nUsing PriorityQueue + HashTable\\n```\n```\\nclass FoodRatings {\\n\\n    private Map<String, FoodInfo> foodInfos;\\n    private Map<String, PriorityQueue<FoodInfo>> cuisinesMap;\\n    \\n    public FoodRatings(String[] foods, String[] cuisine, int[] ratings) {\\n        foodInfos = new HashMap<>();\\n        cuisinesMap = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            FoodInfo foodObj = new FoodInfo(foods[i], cuisine[i], ratings[i]);\\n            \\n            cuisinesMap.putIfAbsent(cuisine[i], new PriorityQueue<>((a, b) -> {\\n                if(a.rating == b.rating) return a.name.compareTo(b.name);\\n                return Integer.compare(b.rating, a.rating);\\n            }));\\n            \\n            cuisinesMap.get(cuisine[i]).offer(foodObj);\\n            foodInfos.put(foods[i], foodObj);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        FoodInfo obj = foodInfos.get(food);\\n        PriorityQueue<FoodInfo> nameRatings = cuisinesMap.get(obj.cuisine);\\n        nameRatings.remove(obj); //This step makes this approach slower than TreeSet Approach\\n        obj.rating = newRating;\\n        nameRatings.offer(obj);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).peek().name;\\n    }\\n    \\n    private class FoodInfo {\\n        String name;\\n        String cuisine;\\n        int rating;\\n        \\n        FoodInfo(String name, String cuisine, int rating) {\\n            this.name = name;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609133,
                "title": "using-three-maps-self-descriptive-codes-all-operations-are-in-proportion-to-log-items",
                "content": "```\\nclass FoodRatings {\\n\\n    //Used to hold [food_name ==> cuisine_type]\\n    private Map<String, String> typeOf;\\n    \\n    //Used to hold [cuisine_type => [(food_name, food_rating)]]\\n    private Map<String, TreeSet<Pair<String, Integer>>> cuisinesMap;\\n    \\n    //Used to hold food_name -> reference_of_food_info_in_treeSet\\n    private Map<String, Pair<String, Integer>> foodToInfo;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisinesMap = new HashMap<>();\\n        foodToInfo = new HashMap<>();\\n        typeOf = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            String foodName = foods[i], foodStyle = cuisines[i];\\n            int foodRating = ratings[i];\\n            cuisinesMap.putIfAbsent(foodStyle, new TreeSet<>((a, b) -> {\\n                Integer r1 = a.second, r2 = b.second;\\n                if(r1.equals(r2)) return a.first.compareTo(b.first); \\n                return Integer.compare(r2, r1);\\n            }));\\n            Pair<String, Integer> foodInfo = new Pair<>(foodName, foodRating);\\n            typeOf.put(foodName, foodStyle);\\n            cuisinesMap.get(foodStyle).add(foodInfo);\\n            foodToInfo.put(foodName, foodInfo);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Pair<String, Integer> foodInfo = foodToInfo.get(food);\\n        String foodStyle = typeOf.get(food);\\n         //removal & addition required to re-arrange the data in TreeSet\\n        cuisinesMap.get(foodStyle).remove(foodInfo);\\n        foodInfo.second = newRating;\\n        cuisinesMap.get(foodStyle).add(foodInfo);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first().first;\\n    }\\n    \\n    private static class Pair<T1, T2> {\\n\\t\\tT1 first;\\n\\t\\tT2 second;\\n\\n\\t\\tPair(T1 _first, T2 _second) {\\n\\t\\t\\tfirst = _first;\\n\\t\\t\\tsecond = _second;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"[\" + first.toString() + \",\" + second.toString() + \"]\";\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic int hashCode() {\\n\\t\\t\\treturn 31 * second.hashCode() + first.hashCode();\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic boolean equals(Object obj) {\\n\\t\\t\\tif(obj == null || obj.getClass() != this.getClass()) return false;\\n\\t\\t\\tif(obj == this) return true;\\n\\t\\t\\tPair<?, ?> p = (Pair)obj;\\n\\t\\t\\treturn this.first.equals(p.first) && this.second.equals(p.second);\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FoodRatings {\\n\\n    //Used to hold [food_name ==> cuisine_type]\\n    private Map<String, String> typeOf;\\n    \\n    //Used to hold [cuisine_type => [(food_name, food_rating)]]\\n    private Map<String, TreeSet<Pair<String, Integer>>> cuisinesMap;\\n    \\n    //Used to hold food_name -> reference_of_food_info_in_treeSet\\n    private Map<String, Pair<String, Integer>> foodToInfo;\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        cuisinesMap = new HashMap<>();\\n        foodToInfo = new HashMap<>();\\n        typeOf = new HashMap<>();\\n        \\n        for(int i = 0; i < foods.length; i += 1) {\\n            String foodName = foods[i], foodStyle = cuisines[i];\\n            int foodRating = ratings[i];\\n            cuisinesMap.putIfAbsent(foodStyle, new TreeSet<>((a, b) -> {\\n                Integer r1 = a.second, r2 = b.second;\\n                if(r1.equals(r2)) return a.first.compareTo(b.first); \\n                return Integer.compare(r2, r1);\\n            }));\\n            Pair<String, Integer> foodInfo = new Pair<>(foodName, foodRating);\\n            typeOf.put(foodName, foodStyle);\\n            cuisinesMap.get(foodStyle).add(foodInfo);\\n            foodToInfo.put(foodName, foodInfo);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Pair<String, Integer> foodInfo = foodToInfo.get(food);\\n        String foodStyle = typeOf.get(food);\\n         //removal & addition required to re-arrange the data in TreeSet\\n        cuisinesMap.get(foodStyle).remove(foodInfo);\\n        foodInfo.second = newRating;\\n        cuisinesMap.get(foodStyle).add(foodInfo);\\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cuisinesMap.get(cuisine).first().first;\\n    }\\n    \\n    private static class Pair<T1, T2> {\\n\\t\\tT1 first;\\n\\t\\tT2 second;\\n\\n\\t\\tPair(T1 _first, T2 _second) {\\n\\t\\t\\tfirst = _first;\\n\\t\\t\\tsecond = _second;\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic String toString() {\\n\\t\\t\\treturn \"[\" + first.toString() + \",\" + second.toString() + \"]\";\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic int hashCode() {\\n\\t\\t\\treturn 31 * second.hashCode() + first.hashCode();\\n\\t\\t}\\n\\n\\t\\t@Override\\n\\t\\tpublic boolean equals(Object obj) {\\n\\t\\t\\tif(obj == null || obj.getClass() != this.getClass()) return false;\\n\\t\\t\\tif(obj == this) return true;\\n\\t\\t\\tPair<?, ?> p = (Pair)obj;\\n\\t\\t\\treturn this.first.equals(p.first) && this.second.equals(p.second);\\n\\t\\t}\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555337,
                "title": "unordered-map-set-98-faster-c",
                "content": "```\\nstruct comp{\\n    bool operator()(const pair<int,string>& a,const pair<int,string>& b) const{\\n        return a.first==b.first ? a.second<b.second : a.first>b.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,set<pair<int,string>,comp>> m;\\n    unordered_map<string,int> index;\\n    vector<string> c;\\n    vector<int> r;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        c=cuisines;\\n        r=ratings;\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            m[cuisines[i]].insert(make_pair(ratings[i],foods[i]));\\n            index[foods[i]]=i;\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int i=index[food];\\n        string cuisine = c[i];\\n        m[cuisine].erase(make_pair(r[i],food));\\n        m[cuisine].insert(make_pair(newRating,food));\\n        r[i]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = m[cuisine].begin();\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nstruct comp{\\n    bool operator()(const pair<int,string>& a,const pair<int,string>& b) const{\\n        return a.first==b.first ? a.second<b.second : a.first>b.first;\\n    }\\n};\\nclass FoodRatings {\\npublic:\\n    unordered_map<string,set<pair<int,string>,comp>> m;\\n    unordered_map<string,int> index;\\n    vector<string> c;\\n    vector<int> r;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        c=cuisines;\\n        r=ratings;\\n        int n=foods.size();\\n        for(int i=0;i<n;i++){\\n            m[cuisines[i]].insert(make_pair(ratings[i],foods[i]));\\n            index[foods[i]]=i;\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int i=index[food];\\n        string cuisine = c[i];\\n        m[cuisine].erase(make_pair(r[i],food));\\n        m[cuisine].insert(make_pair(newRating,food));\\n        r[i]=newRating;\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        auto it = m[cuisine].begin();\\n        return it->second;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545864,
                "title": "2-maps-used-c-simple-and-clean",
                "content": "class FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int,string>>> cuisineMP; // cuisine -> (raintg,food)\\n    unordered_map<string,pair<int,string>> foodMP; // food -> (rating,cuisine)\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        \\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            // pushing the food and cuisine in negative rating so that the highest rating is on top\\n            cuisineMP[cuisines[i]].insert({-ratings[i],foods[i]});\\n            foodMP[foods[i]] = {-ratings[i],cuisines[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [currRating,cuisine] = foodMP[food];\\n        \\n        foodMP[food] = {-newRating,cuisine};\\n        \\n        cuisineMP[cuisine].erase({currRating,food});\\n        cuisineMP[cuisine].insert({-newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        return cuisineMP[cuisine].begin()->second;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int,string>>> cuisineMP; // cuisine -> (raintg,food)\\n    unordered_map<string,pair<int,string>> foodMP; // food -> (rating,cuisine)\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        \\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++){\\n            // pushing the food and cuisine in negative rating so that the highest rating is on top\\n            cuisineMP[cuisines[i]].insert({-ratings[i],foods[i]});\\n            foodMP[foods[i]] = {-ratings[i],cuisines[i]};\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        auto [currRating,cuisine] = foodMP[food];\\n        \\n        foodMP[food] = {-newRating,cuisine};\\n        \\n        cuisineMP[cuisine].erase({currRating,food});\\n        cuisineMP[cuisine].insert({-newRating,food});\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        \\n        return cuisineMP[cuisine].begin()->second;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2519918,
                "title": "3-maps-used-most-simple-c-solution",
                "content": "class FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int, string>>> cuisine_ratings;\\n    unordered_map<string, string> food_cuisine;\\n    unordered_map<string, int> food_rating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); ++i) {\\n            cuisine_ratings[cuisines[i]].insert({ -ratings[i], foods[i] });\\n            food_cuisine[foods[i]] = cuisines[i];\\n            food_rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto &cuisine = food_cuisine.find(food)->second;\\n        cuisine_ratings[cuisine].erase({ -food_rating[food], food });\\n        cuisine_ratings[cuisine].insert({ -newRating, food });\\n        food_rating[food] = newRating;\\n    }\\n    string highestRated(string cuisine) {\\n        return cuisine_ratings[cuisine].begin()->second;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "class FoodRatings {\\npublic:\\n    unordered_map<string, set<pair<int, string>>> cuisine_ratings;\\n    unordered_map<string, string> food_cuisine;\\n    unordered_map<string, int> food_rating;\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < foods.size(); ++i) {\\n            cuisine_ratings[cuisines[i]].insert({ -ratings[i], foods[i] });\\n            food_cuisine[foods[i]] = cuisines[i];\\n            food_rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto &cuisine = food_cuisine.find(food)->second;\\n        cuisine_ratings[cuisine].erase({ -food_rating[food], food });\\n        cuisine_ratings[cuisine].insert({ -newRating, food });\\n        food_rating[food] = newRating;\\n    }\\n    string highestRated(string cuisine) {\\n        return cuisine_ratings[cuisine].begin()->second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2507622,
                "title": "two-maps",
                "content": "```\\n\\nclass FoodRatings {\\n    unordered_map<string,pair<string,int>> food;\\n    unordered_map<string,set<pair<int,string>>> cuisine;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            food[foods[i]] = {cuisines[i],ratings[i]} ;\\n            \\n            cuisine[cuisines[i]].insert( {-ratings[i],foods[i]} );\\n        }\\n    }\\n    \\n    void changeRating(string f, int newRating) {\\n        \\n        string c = food[f].first;\\n        cuisine[c].erase({-food[f].second,f});\\n        food[f].second = newRating;\\n        cuisine[c].insert({-newRating,f});\\n    }\\n    \\n    string highestRated(string c) {\\n       return begin(cuisine[c])->second;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\nclass FoodRatings {\\n    unordered_map<string,pair<string,int>> food;\\n    unordered_map<string,set<pair<int,string>>> cuisine;\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i=0;i<foods.size();i++){\\n            food[foods[i]] = {cuisines[i],ratings[i]} ;\\n            \\n            cuisine[cuisines[i]].insert( {-ratings[i],foods[i]} );\\n        }\\n    }\\n    \\n    void changeRating(string f, int newRating) {\\n        \\n        string c = food[f].first;\\n        cuisine[c].erase({-food[f].second,f});\\n        food[f].second = newRating;\\n        cuisine[c].insert({-newRating,f});\\n    }\\n    \\n    string highestRated(string c) {\\n       return begin(cuisine[c])->second;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2502142,
                "title": "python-hashmap-maxheap-solution",
                "content": "This problem can be solved with exactly the same algorithm with [Leetcode 2349](https://leetcode.com/problems/design-a-number-container-system/discuss/2502175/Python-hashmap-%2B-min_heap-solution) \\n\\n```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food2cui = dict(zip(foods, cuisines))\\n        self.cui2heap = defaultdict(list)   # {cuisine:[(-rate, food)]}\\n        self.rate = defaultdict(dict)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.rate[c][f] = -r\\n            heappush(self.cui2heap[c], (-r, f))\\n\\n    def changeRating(self, f: str, r: int) -> None:\\n        c = self.food2cui[f]\\n        self.rate[c][f] = -r\\n        heappush(self.cui2heap[c], (-r, f))\\n\\n    def highestRated(self, c: str) -> str:\\n\\t\\t# remove the top element with unmatched rate in self.rate \\n        while(self.rate[c][self.cui2heap[c][0][1]]!=self.cui2heap[c][0][0]):\\n            heappop(self.cui2heap[c])\\n        return self.cui2heap[c][0][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food2cui = dict(zip(foods, cuisines))\\n        self.cui2heap = defaultdict(list)   # {cuisine:[(-rate, food)]}\\n        self.rate = defaultdict(dict)\\n        for f, c, r in zip(foods, cuisines, ratings):\\n            self.rate[c][f] = -r\\n            heappush(self.cui2heap[c], (-r, f))\\n\\n    def changeRating(self, f: str, r: int) -> None:\\n        c = self.food2cui[f]\\n        self.rate[c][f] = -r\\n        heappush(self.cui2heap[c], (-r, f))\\n\\n    def highestRated(self, c: str) -> str:\\n\\t\\t# remove the top element with unmatched rate in self.rate \\n        while(self.rate[c][self.cui2heap[c][0][1]]!=self.cui2heap[c][0][0]):\\n            heappop(self.cui2heap[c])\\n        return self.cui2heap[c][0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501823,
                "title": "c-string-view",
                "content": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < size(foods); i++) {\\n            f2c[foods[i]] = cuisines[i];\\n            f2r[foods[i]] = ratings[i];\\n            c2r[cuisines[i]].emplace(-ratings[i], foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int r = exchange(f2r[food], newRating);\\n        auto& c = f2c[food];\\n        auto it = c2r.find(c);\\n        it->second.erase({-r, food});\\n        it->second.emplace(-newRating, food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return begin(c2r[cuisine])->second;\\n    }\\nprivate:\\n    unordered_map<string_view, string_view> f2c;\\n    unordered_map<string_view, int> f2r;\\n    unordered_map<string_view, set<pair<int, string>>> c2r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for (int i = 0; i < size(foods); i++) {\\n            f2c[foods[i]] = cuisines[i];\\n            f2r[foods[i]] = ratings[i];\\n            c2r[cuisines[i]].emplace(-ratings[i], foods[i]);\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        int r = exchange(f2r[food], newRating);\\n        auto& c = f2c[food];\\n        auto it = c2r.find(c);\\n        it->second.erase({-r, food});\\n        it->second.emplace(-newRating, food);\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return begin(c2r[cuisine])->second;\\n    }\\nprivate:\\n    unordered_map<string_view, string_view> f2c;\\n    unordered_map<string_view, int> f2r;\\n    unordered_map<string_view, set<pair<int, string>>> c2r;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475611,
                "title": "python-help",
                "content": "I am alway take Time exceed error but code is working. How can I edit this code to be fast.\\n\\n```\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food = foods #to find exact index. I think it is easy way\\n        self.Cus  = cuisines\\n        self.Rates = ratings\\n        self.SizeFoods = len(foods)\\n        self.FandRC = {i:[j, k] for i, j, k in zip(foods, cuisines, ratings)}\\n    \\n    def changeRating(self, food: str, newRating: int) -> None:        \\n        indexF = self.food.index(food)\\n        self.Rates[indexF] = newRating \\n        self.FandRC[food][1] = newRating\\n        \\n        #We have changed rate of food.\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        \\n        FoodNames = list()\\n        MaxRate    =  max([i[1] for i in self.FandRC.values() if i[0] == cuisine])\\n        constrain = self.Cus.count(cuisine)\\n        counter = 0\\n        i = self.Rates.index(MaxRate)\\n        while counter < constrain:\\n          \\n            if self.Cus[i] == cuisine:\\n                    FoodNames.append(self.food[i])\\n                    FoodNames = list(set(FoodNames))\\n                    counter +=1\\n            \\n            if MaxRate not in self.Rates[i+1:]:\\n                break\\n            \\n            i = self.Rates[i+1:].index(MaxRate) + i + 1\\n            \\n                    \\n        \\n        \\n        \\n        \\n        return sorted(FoodNames)[0]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food = foods #to find exact index. I think it is easy way\\n        self.Cus  = cuisines\\n        self.Rates = ratings\\n        self.SizeFoods = len(foods)\\n        self.FandRC = {i:[j, k] for i, j, k in zip(foods, cuisines, ratings)}\\n    \\n    def changeRating(self, food: str, newRating: int) -> None:        \\n        indexF = self.food.index(food)\\n        self.Rates[indexF] = newRating \\n        self.FandRC[food][1] = newRating\\n        \\n        #We have changed rate of food.\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        \\n        FoodNames = list()\\n        MaxRate    =  max([i[1] for i in self.FandRC.values() if i[0] == cuisine])\\n        constrain = self.Cus.count(cuisine)\\n        counter = 0\\n        i = self.Rates.index(MaxRate)\\n        while counter < constrain:\\n          \\n            if self.Cus[i] == cuisine:\\n                    FoodNames.append(self.food[i])\\n                    FoodNames = list(set(FoodNames))\\n                    counter +=1\\n            \\n            if MaxRate not in self.Rates[i+1:]:\\n                break\\n            \\n            i = self.Rates[i+1:].index(MaxRate) + i + 1\\n            \\n                    \\n        \\n        \\n        \\n        \\n        return sorted(FoodNames)[0]\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415059,
                "title": "java-solution-custom-class-priorityqueue-custom-sorting-2-hashmap",
                "content": "```\\nclass FoodRatings {\\n    class Food{\\n        String foodItem;\\n        String cuisine;\\n        int rating;\\n        Food(String foodItem,String cuisine,int rating){\\n            this.foodItem = foodItem;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    HashMap<String,Food> foodItems;\\n    HashMap<String,PriorityQueue<Food>> highestRatingFood;    \\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodItems = new HashMap<>();\\n        highestRatingFood = new HashMap<>();\\n        \\n        for(int i=0;i<foods.length;i++){\\n            Food food = new Food(foods[i],cuisines[i],ratings[i]);\\n            foodItems.put(foods[i],food); // Since its gaurenteed all foods[i] is unique, directly adding in the hashmap.\\n            PriorityQueue<Food> pq;\\n            if(highestRatingFood.containsKey(cuisines[i]))\\n                pq = highestRatingFood.get(cuisines[i]);\\n            else\\n                pq = new PriorityQueue<>((a,b)->b.rating == a.rating ? a.foodItem.compareTo(b.foodItem) : b.rating-a.rating); // Desc Order.\\n            pq.add(food);\\n            highestRatingFood.put(cuisines[i],pq);\\n        }\\n    }\\n    public void changeRating(String food, int newRating) {\\n        Food prevHistory = foodItems.get(food);\\n        PriorityQueue<Food> pq = highestRatingFood.get(prevHistory.cuisine);\\n        pq.remove(prevHistory); //Removing the old value\\n        prevHistory.rating = newRating;  //Updating Rating\\n        pq.add(prevHistory); //Adding it back\\n        highestRatingFood.put(prevHistory.cuisine,pq); // Updating cuising\\n        foodItems.put(food,prevHistory); // Not needed yet updated.\\n    }\\n    public String highestRated(String cuisine) {\\n        return highestRatingFood.get(cuisine).peek().foodItem;\\n    }    \\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n\\n// kimchi 9\\n// bulgogi 7\\n// AAAA\\n\\n// ramen 14\\n// miso 12\\n// sushi 8\\n// AAAA\\n\\n// sushi 16\\n// AAAA\\n// ramen 16\\n// AAAA\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\n    class Food{\\n        String foodItem;\\n        String cuisine;\\n        int rating;\\n        Food(String foodItem,String cuisine,int rating){\\n            this.foodItem = foodItem;\\n            this.cuisine = cuisine;\\n            this.rating = rating;\\n        }\\n    }\\n    HashMap<String,Food> foodItems;\\n    HashMap<String,PriorityQueue<Food>> highestRatingFood;    \\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        foodItems = new HashMap<>();\\n        highestRatingFood = new HashMap<>();\\n        \\n        for(int i=0;i<foods.length;i++){\\n            Food food = new Food(foods[i],cuisines[i],ratings[i]);\\n            foodItems.put(foods[i],food); // Since its gaurenteed all foods[i] is unique, directly adding in the hashmap.\\n            PriorityQueue<Food> pq;\\n            if(highestRatingFood.containsKey(cuisines[i]))\\n                pq = highestRatingFood.get(cuisines[i]);\\n            else\\n                pq = new PriorityQueue<>((a,b)->b.rating == a.rating ? a.foodItem.compareTo(b.foodItem) : b.rating-a.rating); // Desc Order.\\n            pq.add(food);\\n            highestRatingFood.put(cuisines[i],pq);\\n        }\\n    }\\n    public void changeRating(String food, int newRating) {\\n        Food prevHistory = foodItems.get(food);\\n        PriorityQueue<Food> pq = highestRatingFood.get(prevHistory.cuisine);\\n        pq.remove(prevHistory); //Removing the old value\\n        prevHistory.rating = newRating;  //Updating Rating\\n        pq.add(prevHistory); //Adding it back\\n        highestRatingFood.put(prevHistory.cuisine,pq); // Updating cuising\\n        foodItems.put(food,prevHistory); // Not needed yet updated.\\n    }\\n    public String highestRated(String cuisine) {\\n        return highestRatingFood.get(cuisine).peek().foodItem;\\n    }    \\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n\\n// kimchi 9\\n// bulgogi 7\\n// AAAA\\n\\n// ramen 14\\n// miso 12\\n// sushi 8\\n// AAAA\\n\\n// sushi 16\\n// AAAA\\n// ramen 16\\n// AAAA\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411832,
                "title": "c-solution",
                "content": "We avoid TLE via an *ordered* set for logarithmic indels (insertions/deletions), ie. we store foods sorted by rating per cuisine in a `bucket`.\\n\\n```\\nclass FoodRatings {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    using Pair = pair<int, string>; // rating, food\\n    struct Comp {\\n        bool operator()(const Pair& a, const Pair& b) const {\\n            return a.first == b.first ? a.second < b.second : b.first < a.first;\\n        }\\n    };\\n    using Set = set<Pair, Comp>;\\n    using CuisineFoods = unordered_map<string, Set>;   // cuisine -> foods\\n    using FoodCuisine = unordered_map<string, string>; // food -> cuisine\\n    using FoodRating = unordered_map<string, int>;     // food -> rating\\n    CuisineFoods bucket;\\n    FoodCuisine type;\\n    FoodRating rating;\\n    FoodRatings(VS& foods, VS& cuisines, VI& ratings) {\\n        int N = foods.size();\\n        for (auto i{ 0 }; i < N; ++i) {\\n            bucket[cuisines[i]].emplace(ratings[i], foods[i]);\\n            type[foods[i]] = cuisines[i];\\n            rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto oldRating = rating[food];\\n        rating[food] = newRating;\\n        auto cuisine = type[food];\\n        bucket[cuisine].erase({oldRating, food});\\n        bucket[cuisine].emplace(newRating, food);\\n    }\\n    string highestRated(string cuisine) {\\n        auto it = bucket[cuisine].begin();\\n        auto [_, food] = make_pair(it->first, it->second);\\n        return food;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FoodRatings {\\npublic:\\n    using VI = vector<int>;\\n    using VS = vector<string>;\\n    using Pair = pair<int, string>; // rating, food\\n    struct Comp {\\n        bool operator()(const Pair& a, const Pair& b) const {\\n            return a.first == b.first ? a.second < b.second : b.first < a.first;\\n        }\\n    };\\n    using Set = set<Pair, Comp>;\\n    using CuisineFoods = unordered_map<string, Set>;   // cuisine -> foods\\n    using FoodCuisine = unordered_map<string, string>; // food -> cuisine\\n    using FoodRating = unordered_map<string, int>;     // food -> rating\\n    CuisineFoods bucket;\\n    FoodCuisine type;\\n    FoodRating rating;\\n    FoodRatings(VS& foods, VS& cuisines, VI& ratings) {\\n        int N = foods.size();\\n        for (auto i{ 0 }; i < N; ++i) {\\n            bucket[cuisines[i]].emplace(ratings[i], foods[i]);\\n            type[foods[i]] = cuisines[i];\\n            rating[foods[i]] = ratings[i];\\n        }\\n    }\\n    void changeRating(string food, int newRating) {\\n        auto oldRating = rating[food];\\n        rating[food] = newRating;\\n        auto cuisine = type[food];\\n        bucket[cuisine].erase({oldRating, food});\\n        bucket[cuisine].emplace(newRating, food);\\n    }\\n    string highestRated(string cuisine) {\\n        auto it = bucket[cuisine].begin();\\n        auto [_, food] = make_pair(it->first, it->second);\\n        return food;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411061,
                "title": "java-custom-food-class-comparable-interface-hashmap-treeset",
                "content": "**Time Complexity:**\\n*changeRating* can be done in *O(log(N))* complexity where N is total number of foods (length of foods array)\\n*highest rated food can be retrived in O(1)* complexity\\n\\nFoodRatings class initialization thorugh constructor takes O(N * log(N) time;\\n\\n**Space Complexity :**\\n3 hashMaps of N lengths\\nfor each key in one hashmap we have a TreeSet of average length 1;\\nO(3N+N) > O(4N) > *O(N)*\\n\\n```\\nclass FoodRatings {\\n    \\n    //custom Food class to store food name and rating\\n    private class Food implements Comparable<Food>{\\n        String name;\\n        int rating;\\n        \\n        Food(String name, int rating){\\n            this.name = name;\\n            this.rating = rating;\\n        }\\n        \\n        public int compareTo(Food food){\\n            if(this.rating == food.rating)\\n                return this.name.compareTo(food.name);\\n            return food.rating-this.rating;\\n        }\\n    }\\n    \\n    //this hashMap will map foods according to cuisine\\n    //used treeSet so we always get highest priority food  ( Treating it like priorit queue)\\n    //used Custom Food class which implements Comparable<T> interface, compareTo Method is written keeping in mind that, food should be sorted based on desc order of rating and then as per lexicographical order of food name\\n    HashMap<String, TreeSet<Food>> cuisineToFoods = new HashMap<>();\\n    \\n    //this hashMap maps food to cuisine\\n    HashMap<String, String> foodToCuisine = new HashMap<>();\\n    \\n    //this hashMap maps food to its rating\\n    HashMap<String, Integer> foodToRating = new HashMap<>();\\n    \\n    //initializes above defined maps\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.length; i++){\\n            foodToCuisine.put(foods[i], cuisines[i]);\\n            \\n            Food f = new Food(foods[i], ratings[i]);\\n            \\n            TreeSet<Food> tempSet = cuisineToFoods.getOrDefault(cuisines[i], new TreeSet<>());\\n            tempSet.add(f);\\n            cuisineToFoods.put(cuisines[i], tempSet);\\n            foodToRating.putIfAbsent(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    // takes out food from tempSet (TreeSet) O(Log(N)) timeComplexity\\n    // adds food with new Rating to tempSet o(Log(N)) timeComplexity\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodToCuisine.get(food);\\n        TreeSet<Food> tempSet = cuisineToFoods.get(cuisine);\\n        \\n        int rating = foodToRating.get(food);\\n        Food crit = new Food(food,rating);\\n        //System.out.println(\"Rating will be removed for food:\"+ food +\" with crit as follows\");\\n        //System.out.println(crit.name+\" \"+ crit.rating);\\n        //System.out.println(\"size before\"+ tempSet.size());\\n        tempSet.remove(crit);\\n        //System.out.println(\"size after\"+tempSet.size());\\n        crit.rating = newRating;\\n        tempSet.add(crit);\\n        foodToRating.put(food,newRating);\\n        return;\\n    }\\n    \\n    //Retrives in constant time O(1) time complexity\\n    public String highestRated(String cuisine) {\\n        TreeSet<Food> tempSet = cuisineToFoods.get(cuisine);\\n        \\n        return tempSet.first().name;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    \\n    //custom Food class to store food name and rating\\n    private class Food implements Comparable<Food>{\\n        String name;\\n        int rating;\\n        \\n        Food(String name, int rating){\\n            this.name = name;\\n            this.rating = rating;\\n        }\\n        \\n        public int compareTo(Food food){\\n            if(this.rating == food.rating)\\n                return this.name.compareTo(food.name);\\n            return food.rating-this.rating;\\n        }\\n    }\\n    \\n    //this hashMap will map foods according to cuisine\\n    //used treeSet so we always get highest priority food  ( Treating it like priorit queue)\\n    //used Custom Food class which implements Comparable<T> interface, compareTo Method is written keeping in mind that, food should be sorted based on desc order of rating and then as per lexicographical order of food name\\n    HashMap<String, TreeSet<Food>> cuisineToFoods = new HashMap<>();\\n    \\n    //this hashMap maps food to cuisine\\n    HashMap<String, String> foodToCuisine = new HashMap<>();\\n    \\n    //this hashMap maps food to its rating\\n    HashMap<String, Integer> foodToRating = new HashMap<>();\\n    \\n    //initializes above defined maps\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i = 0; i < foods.length; i++){\\n            foodToCuisine.put(foods[i], cuisines[i]);\\n            \\n            Food f = new Food(foods[i], ratings[i]);\\n            \\n            TreeSet<Food> tempSet = cuisineToFoods.getOrDefault(cuisines[i], new TreeSet<>());\\n            tempSet.add(f);\\n            cuisineToFoods.put(cuisines[i], tempSet);\\n            foodToRating.putIfAbsent(foods[i], ratings[i]);\\n        }\\n    }\\n    \\n    // takes out food from tempSet (TreeSet) O(Log(N)) timeComplexity\\n    // adds food with new Rating to tempSet o(Log(N)) timeComplexity\\n    public void changeRating(String food, int newRating) {\\n        String cuisine = foodToCuisine.get(food);\\n        TreeSet<Food> tempSet = cuisineToFoods.get(cuisine);\\n        \\n        int rating = foodToRating.get(food);\\n        Food crit = new Food(food,rating);\\n        //System.out.println(\"Rating will be removed for food:\"+ food +\" with crit as follows\");\\n        //System.out.println(crit.name+\" \"+ crit.rating);\\n        //System.out.println(\"size before\"+ tempSet.size());\\n        tempSet.remove(crit);\\n        //System.out.println(\"size after\"+tempSet.size());\\n        crit.rating = newRating;\\n        tempSet.add(crit);\\n        foodToRating.put(food,newRating);\\n        return;\\n    }\\n    \\n    //Retrives in constant time O(1) time complexity\\n    public String highestRated(String cuisine) {\\n        TreeSet<Food> tempSet = cuisineToFoods.get(cuisine);\\n        \\n        return tempSet.first().name;\\n    }\\n}\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401281,
                "title": "design-the-system-using-multiset-map",
                "content": "```\\nstruct person {\\n        string name;\\n        int value;\\n    };\\n\\nbool operator< (person a, person b)\\n    {\\n        if(a.value!=b.value)\\n            return a.value>b.value;\\n        string t_a = a.name, t_b = b.name;\\n        return lexicographical_compare(t_a.begin(), t_a.end(),\\n                                      t_b.begin(), t_b.end());\\n    }\\n\\nclass FoodRatings {\\npublic:\\n    \\n    //Change Rating: Unordered Map\\n    // Highest Rated: Heap\\n    \\n    // Problem? If rating change is O(1), then Highest Rated would be O(n)\\n    \\n    // i_to_s -> map int to cusine\\n    // s_to_i -> reverse of i_to_s\\n    \\n    // food_to_i -> map food to its corresponding rating\\n    unordered_map<int, string>i_to_s; unordered_map<string, int>s_to_i, food_to_i;\\n    \\n    // Would map food to its corresponding cuision\\n    unordered_map<string, string>food_to_cuisine;    \\n    \\n    // Would contain the sorted value by rating\\n    vector<multiset<person>>v;    \\n\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {   \\n        int count = 0; int food_id = 0;\\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            food_to_i[foods[i]] = ratings[i];\\n            food_to_cuisine[foods[i]] = cuisines[i];\\n            \\n            if(s_to_i.find(cuisines[i]) == s_to_i.end())\\n            {\\n                i_to_s[count] = cuisines[i];\\n                s_to_i[cuisines[i]] = count;\\n                count++;\\n                person p; p.name = foods[i];\\n                p.value = ratings[i];\\n                multiset<person>ms; ms.insert(p);\\n                v.push_back(ms);\\n            }\\n            else\\n            {\\n                person p; p.name = foods[i];\\n                p.value = ratings[i];\\n                v[s_to_i[cuisines[i]]].insert(p);\\n            }            \\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        // Getting the current rating\\n        int curr_rate = food_to_i[food];\\n        food_to_i[food] = newRating;\\n        \\n        // Getting the cuisine of the food\\n        int cuisine = s_to_i[food_to_cuisine[food]];\\n        \\n        // Erasing the old rating\\n        person p; p.value = curr_rate, p.name = food;\\n        v[cuisine].erase(v[cuisine].find(p));\\n        \\n        // Inserting the new rating\\n        p.value = newRating;\\n        v[cuisine].insert(p);\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        if(s_to_i.find(cuisine) == s_to_i.end())\\n                return \"None\";\\n        int cu = s_to_i[cuisine];\\n        // for(auto &itr: v[cu])\\n        //     cout<<itr.name<<\" \"<<itr.value<<endl;\\n        return (v[cu].begin())->name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nstruct person {\\n        string name;\\n        int value;\\n    };\\n\\nbool operator< (person a, person b)\\n    {\\n        if(a.value!=b.value)\\n            return a.value>b.value;\\n        string t_a = a.name, t_b = b.name;\\n        return lexicographical_compare(t_a.begin(), t_a.end(),\\n                                      t_b.begin(), t_b.end());\\n    }\\n\\nclass FoodRatings {\\npublic:\\n    \\n    //Change Rating: Unordered Map\\n    // Highest Rated: Heap\\n    \\n    // Problem? If rating change is O(1), then Highest Rated would be O(n)\\n    \\n    // i_to_s -> map int to cusine\\n    // s_to_i -> reverse of i_to_s\\n    \\n    // food_to_i -> map food to its corresponding rating\\n    unordered_map<int, string>i_to_s; unordered_map<string, int>s_to_i, food_to_i;\\n    \\n    // Would map food to its corresponding cuision\\n    unordered_map<string, string>food_to_cuisine;    \\n    \\n    // Would contain the sorted value by rating\\n    vector<multiset<person>>v;    \\n\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) \\n    {   \\n        int count = 0; int food_id = 0;\\n        int n = foods.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            food_to_i[foods[i]] = ratings[i];\\n            food_to_cuisine[foods[i]] = cuisines[i];\\n            \\n            if(s_to_i.find(cuisines[i]) == s_to_i.end())\\n            {\\n                i_to_s[count] = cuisines[i];\\n                s_to_i[cuisines[i]] = count;\\n                count++;\\n                person p; p.name = foods[i];\\n                p.value = ratings[i];\\n                multiset<person>ms; ms.insert(p);\\n                v.push_back(ms);\\n            }\\n            else\\n            {\\n                person p; p.name = foods[i];\\n                p.value = ratings[i];\\n                v[s_to_i[cuisines[i]]].insert(p);\\n            }            \\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) \\n    {\\n        // Getting the current rating\\n        int curr_rate = food_to_i[food];\\n        food_to_i[food] = newRating;\\n        \\n        // Getting the cuisine of the food\\n        int cuisine = s_to_i[food_to_cuisine[food]];\\n        \\n        // Erasing the old rating\\n        person p; p.value = curr_rate, p.name = food;\\n        v[cuisine].erase(v[cuisine].find(p));\\n        \\n        // Inserting the new rating\\n        p.value = newRating;\\n        v[cuisine].insert(p);\\n    }\\n    \\n    string highestRated(string cuisine) \\n    {\\n        if(s_to_i.find(cuisine) == s_to_i.end())\\n                return \"None\";\\n        int cu = s_to_i[cuisine];\\n        // for(auto &itr: v[cu])\\n        //     cout<<itr.name<<\" \"<<itr.value<<endl;\\n        return (v[cu].begin())->name;\\n    }\\n};\\n\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\\n * obj->changeRating(food,newRating);\\n * string param_2 = obj->highestRated(cuisine);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2396100,
                "title": "python-single-source-of-truth",
                "content": "```class FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.size = len(foods)\\n        self.foodToCuisine,self.ratingMap,self.cuisineToFood = self.getMaps()\\n\\n    def getMaps(self):\\n        ftc = {}\\n        r = {}\\n        ctf = defaultdict(list)\\n        for i in range(self.size):\\n            ftc[self.foods[i]] = self.cuisines[i]\\n            heapq.heappush(ctf[self.cuisines[i]],(-self.ratings[i],self.foods[i]))\\n            r[self.foods[i]] = self.ratings[i]\\n        return ftc,r,ctf\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.ratingMap[food] = newRating\\n        heapq.heappush(self.cuisineToFood[self.foodToCuisine[food]],(-newRating,food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating,food = self.cuisineToFood[cuisine][0]\\n        while -rating != self.ratingMap[food]:\\n            heapq.heappop(self.cuisineToFood[cuisine])\\n            rating,food = self.cuisineToFood[cuisine][0]\\n        return food\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.size = len(foods)\\n        self.foodToCuisine,self.ratingMap,self.cuisineToFood = self.getMaps()\\n\\n    def getMaps(self):\\n        ftc = {}\\n        r = {}\\n        ctf = defaultdict(list)\\n        for i in range(self.size):\\n            ftc[self.foods[i]] = self.cuisines[i]\\n            heapq.heappush(ctf[self.cuisines[i]],(-self.ratings[i],self.foods[i]))\\n            r[self.foods[i]] = self.ratings[i]\\n        return ftc,r,ctf\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.ratingMap[food] = newRating\\n        heapq.heappush(self.cuisineToFood[self.foodToCuisine[food]],(-newRating,food))\\n        \\n\\n    def highestRated(self, cuisine: str) -> str:\\n        rating,food = self.cuisineToFood[cuisine][0]\\n        while -rating != self.ratingMap[food]:\\n            heapq.heappop(self.cuisineToFood[cuisine])\\n            rating,food = self.cuisineToFood[cuisine][0]\\n        return food\\n        \\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)",
                "codeTag": "Java"
            },
            {
                "id": 2394925,
                "title": "soln-using-dictionaries",
                "content": "```\\nclass FoodRatings:\\n    from sortedcontainers import SortedList\\n        \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.dp = defaultdict()\\n        self.f_c = defaultdict()\\n        self.f_r = defaultdict()\\n        for food, cuisine, rating in zip(foods,cuisines,ratings):\\n            #print(food, cuisine, rating)\\n            self.f_c[food] = [cuisine,rating]\\n            \\n            if cuisine in self.dp:\\n                d = self.dp[cuisine]\\n                d1 = self.f_r[cuisine]\\n                if rating in d:\\n                    sorted_list =  d[rating]\\n                    sorted_list.add(food)\\n                else:\\n                    sorted_list = SortedList()\\n                    sorted_list.add(food)\\n                    d[rating] = sorted_list\\n                    d1.add(rating)\\n            else:\\n                from sortedcontainers import SortedList\\n                sorted_r = SortedList()\\n                sorted_list = SortedList()\\n                sorted_list.add(food)\\n                sorted_r.add(rating)\\n                d = defaultdict(SortedList)\\n                d[rating] = sorted_list\\n                self.dp[cuisine] = d\\n                self.f_r[cuisine] = sorted_r\\n                \\n                \\n        #for i in self.f_r:\\n        #    print(i,self.f_r[i])\\n        \\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, rating = self.f_c[food]\\n        rl = self.f_r[cuisine]\\n        f_r = self.dp[cuisine]\\n        self.f_c[food]= [cuisine, newRating]\\n        if newRating in f_r:\\n            sorted_list =  f_r[newRating]\\n            sorted_list.add(food)\\n        else:\\n            from sortedcontainers import SortedList\\n\\n            sorted_list = SortedList()\\n            sorted_list.add(food)\\n            f_r[newRating] = sorted_list\\n            rl.add(newRating)\\n            \\n        s = f_r[rating]\\n        s.discard(food)\\n        if len(s) ==0:\\n            f_r.pop(rating)\\n            rl.discard(rating)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        f_r = self.dp[cuisine]\\n        r_d = self.f_r[cuisine]\\n        #f_r = dict(sorted(f_r.items(), key=lambda item: item[0], reverse=True) )\\n        #print(f_r)\\n        #print(r_d)\\n        r = r_d[-1]\\n        return f_r[r][0]\\n        #key = next(iter(f_r))\\n        #return f_r[key][0]\\n        #return \"\"\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FoodRatings:\\n    from sortedcontainers import SortedList\\n        \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.dp = defaultdict()\\n        self.f_c = defaultdict()\\n        self.f_r = defaultdict()\\n        for food, cuisine, rating in zip(foods,cuisines,ratings):\\n            #print(food, cuisine, rating)\\n            self.f_c[food] = [cuisine,rating]\\n            \\n            if cuisine in self.dp:\\n                d = self.dp[cuisine]\\n                d1 = self.f_r[cuisine]\\n                if rating in d:\\n                    sorted_list =  d[rating]\\n                    sorted_list.add(food)\\n                else:\\n                    sorted_list = SortedList()\\n                    sorted_list.add(food)\\n                    d[rating] = sorted_list\\n                    d1.add(rating)\\n            else:\\n                from sortedcontainers import SortedList\\n                sorted_r = SortedList()\\n                sorted_list = SortedList()\\n                sorted_list.add(food)\\n                sorted_r.add(rating)\\n                d = defaultdict(SortedList)\\n                d[rating] = sorted_list\\n                self.dp[cuisine] = d\\n                self.f_r[cuisine] = sorted_r\\n                \\n                \\n        #for i in self.f_r:\\n        #    print(i,self.f_r[i])\\n        \\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        cuisine, rating = self.f_c[food]\\n        rl = self.f_r[cuisine]\\n        f_r = self.dp[cuisine]\\n        self.f_c[food]= [cuisine, newRating]\\n        if newRating in f_r:\\n            sorted_list =  f_r[newRating]\\n            sorted_list.add(food)\\n        else:\\n            from sortedcontainers import SortedList\\n\\n            sorted_list = SortedList()\\n            sorted_list.add(food)\\n            f_r[newRating] = sorted_list\\n            rl.add(newRating)\\n            \\n        s = f_r[rating]\\n        s.discard(food)\\n        if len(s) ==0:\\n            f_r.pop(rating)\\n            rl.discard(rating)\\n        \\n    def highestRated(self, cuisine: str) -> str:\\n        f_r = self.dp[cuisine]\\n        r_d = self.f_r[cuisine]\\n        #f_r = dict(sorted(f_r.items(), key=lambda item: item[0], reverse=True) )\\n        #print(f_r)\\n        #print(r_d)\\n        r = r_d[-1]\\n        return f_r[r][0]\\n        #key = next(iter(f_r))\\n        #return f_r[key][0]\\n        #return \"\"\\n\\n\\n# Your FoodRatings object will be instantiated and called as such:\\n# obj = FoodRatings(foods, cuisines, ratings)\\n# obj.changeRating(food,newRating)\\n# param_2 = obj.highestRated(cuisine)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386591,
                "title": "simple-java-code-2-hashmaps-and-treeset-faster-than-98-codes-239-ms",
                "content": "```\\nclass FoodRatings {\\n    HashMap<String, TreeSet<Food>> cus = new HashMap<>();\\n    HashMap<String, Food> f = new HashMap<>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0; i<foods.length; i++){\\n            Food food = new Food(foods[i], ratings[i], cuisines[i]);\\n            f.put(foods[i], food);\\n            if(cus.containsKey(cuisines[i])){\\n                cus.get(cuisines[i]).add(food);\\n            } else {\\n                TreeSet<Food> pq = new TreeSet<>(new Comp());\\n                pq.add(food);\\n                cus.put(cuisines[i], pq);\\n            }\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food dish = f.get(food);\\n        TreeSet<Food> pq = cus.get(dish.cus);\\n        pq.remove(dish);\\n        dish.rating = newRating;\\n        pq.add(dish);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cus.get(cuisine).first().food;\\n    }\\n}\\n\\nclass Comp implements Comparator<Food>{\\n    public int compare(Food f1, Food f2){\\n        if(f1.rating == f2.rating)\\n            return f1.food.compareTo(f2.food);\\n        return Integer.compare(f2.rating, f1.rating);\\n    }\\n}\\n\\nclass Food{\\n    String food, cus;\\n    int rating;\\n    Food(String food, int rating, String cus){\\n        this.food = food;\\n        this.rating = rating;\\n        this.cus = cus;\\n    }\\n}\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass FoodRatings {\\n    HashMap<String, TreeSet<Food>> cus = new HashMap<>();\\n    HashMap<String, Food> f = new HashMap<>();\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        for(int i=0; i<foods.length; i++){\\n            Food food = new Food(foods[i], ratings[i], cuisines[i]);\\n            f.put(foods[i], food);\\n            if(cus.containsKey(cuisines[i])){\\n                cus.get(cuisines[i]).add(food);\\n            } else {\\n                TreeSet<Food> pq = new TreeSet<>(new Comp());\\n                pq.add(food);\\n                cus.put(cuisines[i], pq);\\n            }\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        Food dish = f.get(food);\\n        TreeSet<Food> pq = cus.get(dish.cus);\\n        pq.remove(dish);\\n        dish.rating = newRating;\\n        pq.add(dish);\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        return cus.get(cuisine).first().food;\\n    }\\n}\\n\\nclass Comp implements Comparator<Food>{\\n    public int compare(Food f1, Food f2){\\n        if(f1.rating == f2.rating)\\n            return f1.food.compareTo(f2.food);\\n        return Integer.compare(f2.rating, f1.rating);\\n    }\\n}\\n\\nclass Food{\\n    String food, cus;\\n    int rating;\\n    Food(String food, int rating, String cus){\\n        this.food = food;\\n        this.rating = rating;\\n        this.cus = cus;\\n    }\\n}\\n/**\\n * Your FoodRatings object will be instantiated and called as such:\\n * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);\\n * obj.changeRating(food,newRating);\\n * String param_2 = obj.highestRated(cuisine);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385943,
                "title": "simple-java-design-using-priority-queue",
                "content": "```\\n  //cuisineId :: Food with highest rating in front\\n    Map<String,PriorityQueue<Food>> cuisinesMap = new HashMap<>();\\n    \\n    //FoodId::Food reference to enable disable food\\n    Map<String,Food> refMap = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        \\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            \\n            Food food = new Food(foods[i],cuisines[i],ratings[i],true);\\n            \\n            refMap.put(foods[i],food);\\n            cuisinesMap.putIfAbsent(cuisines[i],new PriorityQueue<>());\\n            cuisinesMap.get(cuisines[i]).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n       \\n        Food foodRef = refMap.get(food);\\n        if(foodRef!=null){\\n            foodRef.enabled = false;\\n            \\n            Food newFood = new Food(food,foodRef.cuisineId,newRating,true);\\n            cuisinesMap.get(foodRef.cuisineId).offer(newFood);\\n            refMap.put(food,newFood);\\n        }\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        Food found = null;\\n        PriorityQueue<Food> queue = cuisinesMap.get(cuisine);\\n        \\n        while(found==null && !queue.isEmpty()){\\n            \\n            Food food = queue.peek();\\n            if(food.enabled){\\n                found = food;\\n            }else{\\n                queue.poll();\\n            }\\n        }\\n        \\n        \\n        return found == null ? null : found.foodId;\\n    }\\n    \\n    private static class Food implements Comparable<Food>{\\n        \\n        public String foodId;\\n        public String cuisineId;\\n        public Integer rating;\\n        public boolean enabled;\\n        \\n        public Food(String foodId,String cuisineId,Integer rating,boolean enabled){\\n            this.foodId = foodId;\\n            this.cuisineId = cuisineId;\\n            this.rating = rating;\\n            this.enabled = enabled;\\n        }\\n        \\n        @Override\\n        public int compareTo(Food obj2){\\n            \\n            if(obj2.rating.compareTo(this.rating) == 0){\\n                return this.foodId.compareTo(obj2.foodId);\\n            }\\n            \\n            return obj2.rating.compareTo(this.rating);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n  //cuisineId :: Food with highest rating in front\\n    Map<String,PriorityQueue<Food>> cuisinesMap = new HashMap<>();\\n    \\n    //FoodId::Food reference to enable disable food\\n    Map<String,Food> refMap = new HashMap<>();\\n    \\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n        \\n        int n = foods.length;\\n        for(int i=0;i<n;i++){\\n            \\n            Food food = new Food(foods[i],cuisines[i],ratings[i],true);\\n            \\n            refMap.put(foods[i],food);\\n            cuisinesMap.putIfAbsent(cuisines[i],new PriorityQueue<>());\\n            cuisinesMap.get(cuisines[i]).offer(food);\\n        }\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n       \\n        Food foodRef = refMap.get(food);\\n        if(foodRef!=null){\\n            foodRef.enabled = false;\\n            \\n            Food newFood = new Food(food,foodRef.cuisineId,newRating,true);\\n            cuisinesMap.get(foodRef.cuisineId).offer(newFood);\\n            refMap.put(food,newFood);\\n        }\\n        \\n    }\\n    \\n    public String highestRated(String cuisine) {\\n        \\n        Food found = null;\\n        PriorityQueue<Food> queue = cuisinesMap.get(cuisine);\\n        \\n        while(found==null && !queue.isEmpty()){\\n            \\n            Food food = queue.peek();\\n            if(food.enabled){\\n                found = food;\\n            }else{\\n                queue.poll();\\n            }\\n        }\\n        \\n        \\n        return found == null ? null : found.foodId;\\n    }\\n    \\n    private static class Food implements Comparable<Food>{\\n        \\n        public String foodId;\\n        public String cuisineId;\\n        public Integer rating;\\n        public boolean enabled;\\n        \\n        public Food(String foodId,String cuisineId,Integer rating,boolean enabled){\\n            this.foodId = foodId;\\n            this.cuisineId = cuisineId;\\n            this.rating = rating;\\n            this.enabled = enabled;\\n        }\\n        \\n        @Override\\n        public int compareTo(Food obj2){\\n            \\n            if(obj2.rating.compareTo(this.rating) == 0){\\n                return this.foodId.compareTo(obj2.foodId);\\n            }\\n            \\n            return obj2.rating.compareTo(this.rating);\\n        }\\n    }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2049312,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1995740,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1794448,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1780923,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1771448,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1731468,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1723297,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            },
            {
                "id": 1700667,
                "content": [
                    {
                        "username": "kartikdangi01",
                        "content": "learnt how to implement a custom comparator for sets."
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its a great question, will use multiple maps and comparator function to solve..."
                    },
                    {
                        "username": "supernes",
                        "content": "While the number of food items can get very big, there\\'s a sufficiently small number of top rated items in each cuisine that can pass all tests."
                    },
                    {
                        "username": "chrismv48",
                        "content": "Can anyone explain the Big(O) for solutions using lazy deletion from a heap? It intuitively feels like it will be O(N) at worst, but the amortized/average runtime will be much faster if not constant?"
                    },
                    {
                        "username": "Zephyr_8",
                        "content": "Can anybody share thoughts why my below answer is wrong?(72/77 passed)\\n\\n `\\n    Map<String,Integer> foodRatings;\\n    Map<String,List<String>> cuisineFoodList;\\n\\n    class myComparator implements Comparator<String>{\\n\\n\\n        public int compare(String s1,String s2){\\n            if(foodRatings.get(s1)!=foodRatings.get(s2)){\\n                return foodRatings.get(s1)-foodRatings.get(s2);\\n            }else{\\n                return s2.compareTo(s1);\\n            } \\n        }\\n\\n\\n    }\\n    \\n\\n    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {\\n\\n        foodRatings = new HashMap<>();\\n        cuisineFoodList = new HashMap<>();\\n        for(int i = 0;i<foods.length;i++){\\n            foodRatings.put(foods[i],ratings[i]);\\n            if(!cuisineFoodList.containsKey(cuisines[i])){\\n                cuisineFoodList.put(cuisines[i],new ArrayList<>());\\n            }\\n            cuisineFoodList.get(cuisines[i]).add(foods[i]);\\n        }\\n\\n    }\\n    \\n    public void changeRating(String food, int newRating) {\\n        foodRatings.put(food,newRating);\\n    }\\n\\n    \\n    public String highestRated(String cuisine) {\\n        List<String> l = cuisineFoodList.get(cuisine);\\n        myComparator mycomparrator = new myComparator();\\n        Collections.sort(l,mycomparrator);\\n        return l.get(l.size()-1);  \\n    }\\n\\n`"
                    },
                    {
                        "username": "laeeqa222",
                        "content": "``class FoodRatings {\n    HashMap<String,TreeMap<Integer,TreeSet<String>>> t=new HashMap<>();\n    HashMap<String,Integer> h=new HashMap<>();\n    HashMap<String,String> h1=new HashMap<>();\n    public FoodRatings(String[] food, String[] c, int[] rank) {\n        for(int i=0;i<food.length;i++){\n             t.putIfAbsent(c[i],new TreeMap<>());\n             t.get(c[i]).putIfAbsent(rank[i],new TreeSet<>());\n             t.get(c[i]).get(rank[i]).add(food[i]);\n             h.put(food[i],rank[i]);\n             h1.put(food[i],c[i]);\n        }\n    }\n    public void changeRating(String food, int nr) {\n            int rank=h.get(food);\n            String s=h1.get(food);\n            h.put(food,nr);\n            if(t.get(s).get(rank).size()==1){\n                t.get(s).remove(rank);\n            }else{\n                t.get(s).get(rank).remove(food);\n            }\n             t.get(s).putIfAbsent(nr,new TreeSet<>());\n             t.get(s).get(nr).add(food);\n    }\n    \n    public String highestRated(String c) {\n        return t.get(c).get(t.get(c).lastKey()).first();\n    }\n}\n\n``\n"
                    },
                    {
                        "username": "Aniket1509",
                        "content": " ```\\nclass Food:\\n    def __init__(self, foodName):\\n        self.foodName = foodName\\n        self.type = None\\n        self.rating = None\\n\\n    def __str__(self):\\n        return (self.foodName, self.rating)\\n        \\nclass FoodRatings:\\n   \\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.foods = foods\\n        self.cuisines = cuisines\\n        self.ratings = ratings\\n        self.foodMap = collections.defaultdict(list)\\n        self.foodList = []\\n        self.foodIndex = collections.defaultdict(int)\\n        \\n        self.create_food_indexing()\\n\\n        self.create_food_mapping()\\n\\n    def create_food_indexing(self):\\n        for i,v in enumerate(self.foods):\\n            self.foodIndex[v] = i\\n\\n       \\n\\n    def create_food_mapping(self):\\n        for i in range(len(self.foods)):\\n            food = Food(self.foods[i])\\n            food.type = self.cuisines[i]\\n            food.rating = self.ratings[i]\\n            self.foodList.append(food)\\n\\n        \\n    def changeRating(self, food: str, newRating: int) -> None:\\n        index = self.foodIndex[food]\\n        foodItem = self.foodList[index]\\n        foodItem.rating = newRating\\n        # print(\"Food item rating change: \", foodItem.foodName)\\n        pass\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        ll = []\\n        max_rating_so_far = 0\\n        # for i in self.foodList:\\n        #     print(i.__str__(), end=\" \")\\n        for food in self.foodList:\\n            if food.type == cuisine:\\n                if food.rating > max_rating_so_far:\\n                    ll.clear()\\n                    ll.append((food.rating, food.foodName))\\n                    max_rating_so_far = food.rating\\n                elif food.rating == max_rating_so_far:\\n                    ll.append((food.rating, food.foodName))\\n\\n        # print(ll)\\n        if len(ll) > 1:\\n            ll.sort(key=lambda x:x[1])\\n            return ll[0][1]\\n        return ll[0][1]\\n        pass\\n\\n```\\nYour FoodRatings object will be instantiated and called as such:\\n```\\nobj = FoodRatings(foods, cuisines, ratings)\\nobj.changeRating(food,newRating)\\nparam_2 = obj.highestRated(cuisine)\\n```\\n\\nI am getting TLE after 73 test cases, can somebody explain it to me that wht might be problem in this approach"
                    },
                    {
                        "username": "kinetic_dev",
                        "content": " What\\'s wrong with this ??\\n\\n```class FoodRatings {\\npublic:\\n    unordered_map<string,pair<string,int>> mp;\\n    //crusine => food , rating\\n    unordered_map<string,string> check;\\n    //food=>cuisine\\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\\n        for(int i = 0;i<foods.size();i++){\\n            if(mp[cuisines[i]].second<ratings[i]){\\n                mp[cuisines[i]].first = foods[i];\\n                mp[cuisines[i]].second = ratings[i];\\n            }\\n            else if(mp[cuisines[i]].second==ratings[i]){\\n                if(mp[cuisines[i]].first>foods[i]){\\n                     mp[cuisines[i]].first = foods[i];\\n                }\\n            }\\n            check[foods[i]]=cuisines[i];\\n        }\\n    }\\n    \\n    void changeRating(string food, int newRating) {\\n        if(mp[check[food]].second < newRating){\\n                mp[check[food]].first = food;\\n                mp[check[food]].second = newRating;\\n            }\\n        else if(mp[check[food]].second == newRating){\\n                if(mp[check[food]].first > food){\\n                     mp[check[food]].first = food;\\n                }\\n            }\\n    }\\n    \\n    string highestRated(string cuisine) {\\n        return mp[cuisine].first;\\n    }\\n};```"
                    },
                    {
                        "username": "khandelwalyash999",
                        "content": "## My code is stuck after 73 testcases, it keeps showing Time Limit Error.  Need Help!\\n\\n `from heapq import *\\nclass FoodRatings:\\n\\n    def __init__(self, foods: List[str], cuisines: List[str], ratings: List[int]):\\n        self.food_d = {}\\n        self.cuisine_d = {}\\n        for i in range(len(foods)):\\n            self.food_d[foods[i]] = [ratings[i], cuisines[i]]\\n            if cuisines[i] in self.cuisine_d:\\n                self.cuisine_d[cuisines[i]][0].append((-1*ratings[i], foods[i]))\\n            else:\\n                self.cuisine_d[cuisines[i]] = [[(-1*ratings[i], foods[i])], 0]\\n        for key in self.cuisine_d:\\n            heapify(self.cuisine_d[key][0])\\n\\n    def changeRating(self, food: str, newRating: int) -> None:\\n        self.food_d[food][0] = newRating\\n        ele_d = self.cuisine_d[self.food_d[food][1]][0]\\n        for i in range(len(ele_d)):\\n            if ele_d[i][1] == food:\\n                ele_d[i] = (-1*newRating, food)\\n                break\\n        self.cuisine_d[self.food_d[food][1]][1] = 1\\n\\n    def highestRated(self, cuisine: str) -> str:\\n        if self.cuisine_d[cuisine][1] == 1:\\n            heapify(self.cuisine_d[cuisine][0])\\n            self.cuisine_d[cuisine][1] = 0\\n        ele = heappop(self.cuisine_d[cuisine][0])\\n        heappush(self.cuisine_d[cuisine][0], ele)\\n        return ele[1]`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Excellent Pairs",
        "question_content": "<p>You are given a <strong>0-indexed</strong> positive integer array <code>nums</code> and a positive integer <code>k</code>.</p>\n\n<p>A pair of numbers <code>(num1, num2)</code> is called <strong>excellent</strong> if the following conditions are satisfied:</p>\n\n<ul>\n\t<li><strong>Both</strong> the numbers <code>num1</code> and <code>num2</code> exist in the array <code>nums</code>.</li>\n\t<li>The sum of the number of set bits in <code>num1 OR num2</code> and <code>num1 AND num2</code> is greater than or equal to <code>k</code>, where <code>OR</code> is the bitwise <strong>OR</strong> operation and <code>AND</code> is the bitwise <strong>AND</strong> operation.</li>\n</ul>\n\n<p>Return <em>the number of <strong>distinct</strong> excellent pairs</em>.</p>\n\n<p>Two pairs <code>(a, b)</code> and <code>(c, d)</code> are considered distinct if either <code>a != c</code> or <code>b != d</code>. For example, <code>(1, 2)</code> and <code>(2, 1)</code> are distinct.</p>\n\n<p><strong>Note</strong> that a pair <code>(num1, num2)</code> such that <code>num1 == num2</code> can also be excellent if you have at least <strong>one</strong> occurrence of <code>num1</code> in the array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1], k = 3\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The excellent pairs are the following:\n- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.\n- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\n- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.\nSo the number of excellent pairs is 5.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,1,1], k = 10\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no excellent pairs for this array.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 60</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2324984,
                "title": "java-c-python-inclusion-exclusion-principle",
                "content": "# **Intuition**\\nThe Inclusion-Exclusion Principle\\n`bits(num1 OR num2) + bits(num1 AND num2) = bits(num1) + bits(num2)`\\n<br>\\n\\n# **Explanation**\\nFor all different `a` in `nums`,\\ncounts its number of `bits`.\\n\\nEnumearte the number of bits `k1` and `k2`,\\nif `k1 + k2 >= k`,\\nwe accumulate `count[k1] * count[k2]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long countExcellentPairs(int[] A, int k) {\\n        long cnt[] = new long[30], res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int a : A)\\n            set.add(a);\\n        for (int a : set)\\n            cnt[Integer.bitCount(a)]++;\\n        for (int i = 1; i < 30; ++i)\\n            for (int j = 1; j < 30; ++j)\\n                if (i + j >= k)\\n                    res += cnt[i] * cnt[j];\\n        return res;\\n    }\\n```\\n**C++**\\nimproved from @votrubac\\n```c++\\n    long long countExcellentPairs(vector<int>& A, int k) {\\n        long long cnt[30] = {}, res = 0;\\n        for (int a : unordered_set<int>(begin(A), end(A)))\\n            ++cnt[__builtin_popcount(a)];\\n        for (int i = 1; i < 30; ++i)\\n            for (int j = 1; j < 30; ++j)\\n                if (i + j >= k)\\n                    res += cnt[i] * cnt[j];\\n        return res;\\n    }\\n```\\n**Python3**\\n```py\\n    def countExcellentPairs(self, A: List[int], k: int) -> int:\\n        c = Counter(map(int.bit_count, set(A)))\\n        return sum(c[k1] * c[k2] for k1 in c for k2 in c if k1 + k2 >= k)\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long countExcellentPairs(int[] A, int k) {\\n        long cnt[] = new long[30], res = 0;\\n        Set<Integer> set = new HashSet<>();\\n        for (int a : A)\\n            set.add(a);\\n        for (int a : set)\\n            cnt[Integer.bitCount(a)]++;\\n        for (int i = 1; i < 30; ++i)\\n            for (int j = 1; j < 30; ++j)\\n                if (i + j >= k)\\n                    res += cnt[i] * cnt[j];\\n        return res;\\n    }\\n```\n```c++\\n    long long countExcellentPairs(vector<int>& A, int k) {\\n        long long cnt[30] = {}, res = 0;\\n        for (int a : unordered_set<int>(begin(A), end(A)))\\n            ++cnt[__builtin_popcount(a)];\\n        for (int i = 1; i < 30; ++i)\\n            for (int j = 1; j < 30; ++j)\\n                if (i + j >= k)\\n                    res += cnt[i] * cnt[j];\\n        return res;\\n    }\\n```\n```py\\n    def countExcellentPairs(self, A: List[int], k: int) -> int:\\n        c = Counter(map(int.bit_count, set(A)))\\n        return sum(c[k1] * c[k2] for k1 in c for k2 in c if k1 + k2 >= k)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2324634,
                "title": "formula",
                "content": "The important point to realize is that the sum of OR and AND is just the sum of bits of two numbers.\\n    \\nWe dedup the input array, and count numbers containing `n` bits (where n is [1..29]);\\n    \\nThen, we pick any combination of bits `i` and `j`, such that `i + j >= k`.\\n\\nIf `i != j`, the number of pairs is `cnt[i] * cnt[j] * 2`; numbers for `i` and `j` are different, so they form two pairs.\\n \\nIf `i == j`, the number of pairs is `cnt[i] * cnt[i]`. This is different from above, so that pairs with the same number are counted once. \\n\\n> If `i == j` the number of pairs is `n * (n + 1) / 2`. Then, we multiply it by 2, and we get `n * (n + 1)`. \\n> Now, we need to remove `n` elements as they only form one pair. Thus, we get `n * n`.\\n\\n**Java**\\n```java\\npublic long countExcellentPairs(int[] nums, int k) {\\n    long res = 0, cnt[] = new long[30]; \\n    for (int n : Arrays.stream(nums).distinct().toArray()) {\\n        ++cnt[Integer.bitCount(n)];\\n    }\\n    for (int i = 1; i < 30; ++i)\\n        for (int j = Math.max(i, k - i); j < 30; ++j)\\n            res += cnt[i] * cnt[j] * (i == j ? 1 : 2);\\n    return res;\\n}\\n```\\n**C++**\\n```cpp\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n    long long cnt[30] = {}, res = 0;\\n    for (int n : unordered_set<int>(begin(nums), end(nums)))\\n        ++cnt[__builtin_popcount(n)];\\n    for (int i = 1; i < 30; ++i)\\n        for (int j = max(i, k - i); j < 30; ++j)\\n            res += cnt[i] * cnt[j] * (i == j ? 1 : 2);\\n    return res;\\n}\\n```\\n**Python 3**\\nBorrowed from @lee215.\\n```python\\n  def countExcellentPairs(self, nums, k):\\n       c = Counter(map(lambda x: x.bit_count(), set(nums)))\\n       return sum(c[k1] * c[k2] for k1 in c for k2 in c if k1 + k2 >= k)\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic long countExcellentPairs(int[] nums, int k) {\\n    long res = 0, cnt[] = new long[30]; \\n    for (int n : Arrays.stream(nums).distinct().toArray()) {\\n        ++cnt[Integer.bitCount(n)];\\n    }\\n    for (int i = 1; i < 30; ++i)\\n        for (int j = Math.max(i, k - i); j < 30; ++j)\\n            res += cnt[i] * cnt[j] * (i == j ? 1 : 2);\\n    return res;\\n}\\n```\n```cpp\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n    long long cnt[30] = {}, res = 0;\\n    for (int n : unordered_set<int>(begin(nums), end(nums)))\\n        ++cnt[__builtin_popcount(n)];\\n    for (int i = 1; i < 30; ++i)\\n        for (int j = max(i, k - i); j < 30; ++j)\\n            res += cnt[i] * cnt[j] * (i == j ? 1 : 2);\\n    return res;\\n}\\n```\n```python\\n  def countExcellentPairs(self, nums, k):\\n       c = Counter(map(lambda x: x.bit_count(), set(nums)))\\n       return sum(c[k1] * c[k2] for k1 in c for k2 in c if k1 + k2 >= k)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2324647,
                "title": "easy-c-set-bits-logic",
                "content": "First we find the distinct elements from the given vector as duplicates are unnecessary.\\nThen we find the setBits of each and every number and store them in a vector.\\n    \\n**Let two numbers be x and y.**\\n**setBits(BITWISE AND of x,y) + setBits(BITWISE OR of x,y) = setBits(x) + setBits(y)**\\n\\n***Explanation:***\\nLet setBits in x = a, setBits in y = b\\nBitwise AND represents setBits common in x and y. Let setBits in (x&y) = c\\nBitwise OR represents setBits which are either in x or y. So setBits in (x|y) = (setBits in x) + (setBits in y) - common setBits = a+b-c\\nTherefore, setBits(BITWISE AND of x,y) + setBits(BITWISE OR of x,y) = c + (a+b-c) = (a+b) = setBits(x) + setBits(y).\\n    \\nTo evaluate answer, we need to find the excellent pairs. i.e pairs whose (setBits of AND of 2 numbers) + (setBits of OR of 2 numbers) greater than k. \\nWe sort the vector in which we stored the setBits.\\nWe find the lower_bound for k-v[i], now all the numbers to the right of the lower_bound will form an excellent pair.\\n\\n**Time complexity: O(N logN)**\\n**Space Complexity: O(N)**\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int setbits(int n){\\n        int cnt = 0;\\n        while(n){\\n            cnt += (n%2);\\n            n /= 2;\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        vector<int> v;\\n        for(auto& i: s){\\n            int x = setbits(i);\\n            v.push_back(x);\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        ll ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            auto it = lower_bound(v.begin(),v.end(),k-v[i]);\\n            ans += (v.end()-it);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**Upvote if it helps!**",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int setbits(int n){\\n        int cnt = 0;\\n        while(n){\\n            cnt += (n%2);\\n            n /= 2;\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        vector<int> v;\\n        for(auto& i: s){\\n            int x = setbits(i);\\n            v.push_back(x);\\n        }\\n        sort(v.begin(),v.end());\\n        \\n        ll ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            auto it = lower_bound(v.begin(),v.end(),k-v[i]);\\n            ans += (v.end()-it);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324633,
                "title": "java-hashmap",
                "content": "For any number `num`, we need another number having atleast `max(0,k-SetbitCount(num))` set bits in it. It doesn\\'t matter where those bits are set at that number.\\nFor uniqueness we only count such unique numbers through set. \\n```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashMap<Integer,Set<Integer>> map = new HashMap<>();\\n        for(int i : nums){\\n            int x = Integer.bitCount(i);\\n            map.putIfAbsent(x,new HashSet<>());\\n            map.get(x).add(i);\\n        }\\n        long ans = 0;\\n        HashSet<Integer> vis = new HashSet<>();\\n        for(int i : nums){\\n            if(vis.contains(i)) continue;\\n            int need = Math.max(0,k-Integer.bitCount(i));\\n            for(int key : map.keySet())   // runs at max 30 times\\n\\t\\t\\t\\tif(key >= need) ans += (long) map.get(key).size();\\n            vis.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashMap<Integer,Set<Integer>> map = new HashMap<>();\\n        for(int i : nums){\\n            int x = Integer.bitCount(i);\\n            map.putIfAbsent(x,new HashSet<>());\\n            map.get(x).add(i);\\n        }\\n        long ans = 0;\\n        HashSet<Integer> vis = new HashSet<>();\\n        for(int i : nums){\\n            if(vis.contains(i)) continue;\\n            int need = Math.max(0,k-Integer.bitCount(i));\\n            for(int key : map.keySet())   // runs at max 30 times\\n\\t\\t\\t\\tif(key >= need) ans += (long) map.get(key).size();\\n            vis.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324685,
                "title": "python-explanation-with-pictures-two-pointers",
                "content": "Notice that for two number `A` and `B`, the number of bits from `A AND B` + `A OR B` equals the number of bits in `A` (in binary representation) plus the number of bits in `B`. Thus we just need to collected the sum of bits of each distinct number from `nums`. \\n\\n![image](https://assets.leetcode.com/users/images/cbef8fbf-2a50-42eb-be00-bfed83e59bca_1658635281.6611814.png)\\n\\n\\nWe could use two pointers to find all such pairs. \\n\\n![image](https://assets.leetcode.com/users/images/8aebfa2c-6fac-41e4-8e11-4c17aaccb1c2_1658635285.4133282.png)\\n\\nA detailed example of how we move two pointers:\\n\\n![image](https://assets.leetcode.com/users/images/ae57f868-4864-43da-b858-305388e0c9be_1658635289.0178986.png)\\n\\nOR just use binary search to locate the index `j`, since we have already used O(NlogN) on sorting **Bits**, it doesn\\'t bring a larger time complexity.\\n\\n```\\nclass Solution:\\n    def countExcellentPairs(self, A: List[int], k: int) -> int:\\n        # Count number of bits in (n) in binary\\n        def numOfBits(n):\\n            ans = 0\\n            while n:\\n                ans += (n & 1)\\n                n >>= 1\\n            return ans\\n        \\n        # Sort the number of bits of each distinct number from A\\n        B = sorted([numOfBits(a) for a in set(A)])\\n        \\n        # Right pointer start at n - 1.\\n        n, j, ans = len(B), len(B) - 1, 0\\n\\n        for i in range(n):\\n            # If the starting i, j don\\'t meet the condition, continue for the next i.\\n            if B[i] + B[j] < k: \\n                continue\\n            \\n            # Move until j = 0 or B[i] + B[j] < k\\n            while j >= 1 and B[i] + B[j - 1] >= k:\\n                j -= 1\\n                \\n            # All the number to the right of the pointer j (inclusive) make no less\\n            # sum of bits with B[i]\\n            ans += n - j\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, A: List[int], k: int) -> int:\\n        # Count number of bits in (n) in binary\\n        def numOfBits(n):\\n            ans = 0\\n            while n:\\n                ans += (n & 1)\\n                n >>= 1\\n            return ans\\n        \\n        # Sort the number of bits of each distinct number from A\\n        B = sorted([numOfBits(a) for a in set(A)])\\n        \\n        # Right pointer start at n - 1.\\n        n, j, ans = len(B), len(B) - 1, 0\\n\\n        for i in range(n):\\n            # If the starting i, j don\\'t meet the condition, continue for the next i.\\n            if B[i] + B[j] < k: \\n                continue\\n            \\n            # Move until j = 0 or B[i] + B[j] < k\\n            while j >= 1 and B[i] + B[j - 1] >= k:\\n                j -= 1\\n                \\n            # All the number to the right of the pointer j (inclusive) make no less\\n            # sum of bits with B[i]\\n            ans += n - j\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324641,
                "title": "python3-sorting-hamming-weights-binary-search-with-detailed-explanations",
                "content": "I have to say that the problem description is a little bit confusing, so let\\'s clarify it together.\\n\\n**Observations & Explanations**\\n1. The problem asks for the number of **distinct** excellent pairs, therefore duplicated `num` in the `nums` array does not matter and we only need to look at unique `num` appeared in the array.\\n2. The excellent pair **can** include a `num` paired with itself.\\n3. For any pair of bits `(b1, b2)`, where `b1` and `b2` can take `0` or `1`, we have `(b1 OR b2) + (b1 AND b2) = b1 + b2`. Specifically,\\n* \\t`(0 OR 0) + (0 AND 0) = 0 + 0 = 0 = 0 + 0`;\\n* \\t`(0 OR 1) + (0 AND 1) = 1 + 0 = 1 = 0 + 1`;\\n* \\t`(1 OR 0) + (1 AND 0) = 1 + 0 = 1 = 1 + 0`;\\n* \\t`(1 OR 1) + (1 AND 1) = 1 + 1 = 2 = 1 + 1`.\\n4. From above, we have that for any pair `(num1, num2)`, the sum of the number of set bits in `num1 OR num2` and `num1 AND num2` is the same as the number of set bits in `num1` and `num2` themselves. Therefore, we don\\'t actually need to calculate the `OR/AND` operations but just need to store the hamming weight, `hamming`, for each of the unique `num` in the `nums` array.\\n5. After we have the `hamming` array, the problem essentially becomes a \"Two Sum Greater Than K\" type of problem, where we can sort the `hamming` array first, and then use a binary search to get the number of \"Excellent Pairs\" in the original `nums` array.\\n\\n**Complexity Analysis**\\nTime: `O(NlogN + NlogM)`, where `M = max(nums)`.\\nSpace: `O(N)`, for storing the hamming weights;\\n\\n**Solution**\\nPlease upvote if you find this solution helpful. Thanks!\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        hamming = sorted([self.hammingWeight(num) for num in set(nums)])\\n        ans = 0\\n        for h in hamming:\\n            ans += len(hamming) - bisect.bisect_left(hamming, k - h)\\n        return ans\\n        \\n    def hammingWeight(self, n):\\n        ans = 0\\n        while n:\\n            n &= (n - 1)\\n            ans += 1\\n        return ans\\n```\\n\\n**Remark 1**: Above is a solution (~2000 ms) implemented with binary search after sorting the `hamming` array. One can also use two pointers to get the number of \"Excellent Pairs\" in the original `nums` array. However, the time complexity would not change since sorting the `hamming` array requires `O(NlogN)` time complexity.\\n\\n**Remark 2**: Shorter and faster solution (1435 ms) using Python 3.10\\'s [new built-in method](https://docs.python.org/3/library/stdtypes.html#int.bit_count) `int.bit_count()`.\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        hamming = sorted([num.bit_count() for num in set(nums)])\\n        ans = 0\\n        for h in hamming:\\n            ans += len(hamming) - bisect.bisect_left(hamming, k - h)\\n        return ans\\n```\\n\\n**Remark 3**: Another short and fast solution (1129 ms) using `Counter` (hashmap).\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        hamming = Counter([num.bit_count() for num in set(nums)])\\n        ans = 0\\n        for h1 in hamming:\\n            for h2 in hamming:\\n                if h1 + h2 < k:\\n                    continue\\n                ans += hamming[h1] * hamming[h2]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        hamming = sorted([self.hammingWeight(num) for num in set(nums)])\\n        ans = 0\\n        for h in hamming:\\n            ans += len(hamming) - bisect.bisect_left(hamming, k - h)\\n        return ans\\n        \\n    def hammingWeight(self, n):\\n        ans = 0\\n        while n:\\n            n &= (n - 1)\\n            ans += 1\\n        return ans\\n```\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        hamming = sorted([num.bit_count() for num in set(nums)])\\n        ans = 0\\n        for h in hamming:\\n            ans += len(hamming) - bisect.bisect_left(hamming, k - h)\\n        return ans\\n```\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        hamming = Counter([num.bit_count() for num in set(nums)])\\n        ans = 0\\n        for h1 in hamming:\\n            for h2 in hamming:\\n                if h1 + h2 < k:\\n                    continue\\n                ans += hamming[h1] * hamming[h2]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324658,
                "title": "java-o-n-simple-explanation",
                "content": "EXPLANATION :\\nfirst we have to find the unique elements to remove duplicates element,\\nthen we have to just count the no of set bits in each element , \\nthen we have to hashing, \\narr[i] will store, the no elements having the set bits equal to, i\\n\\nthen by using the same array, i calculate the suffix sum,\\nnow the definition of array (arr) changes, \\ni.e, arr[i] will store, the no elements having the set bits equal to or greater than i,\\n\\nthen at last, i traverse to all the unique elements,\\neach element will make pair with other element only if, the count of set bit of both element will be equal to or greater then K,\\n\\nso i just again count the sets bit of each element , and update ans with \\n int req=Math.max(0,k-c);\\n ans+=arr[req];\\n \\n HAPPY CODING :)\\n \\n **IF YOU LEARN SOMETHING FROM THIS POST, DO UPVOTE :)**\\n\\n```\\npublic long countExcellentPairs(int[] nums, int k) {\\n        \\n        Set<Integer> set=new HashSet<>();\\n        for(int a:nums){\\n            set.add(a);\\n        }\\n        long arr[]=new long[32];\\n        Set<Integer> s1=new HashSet<>();\\n        for(Integer a:set){\\n            int c=0;\\n            while(a!=0){\\n                c+=a%2;\\n\\t\\t\\t   a/=2;\\n            }\\n            arr[c]++;\\n        }\\n        long ans=0;\\n        for(int i=30;i>=0;i--){\\n            arr[i]+=arr[i+1];\\n        }\\n        for(Integer a:set){\\n            int c=0;\\n            while(a!=0){\\n               c+=a%2;\\n\\t\\t\\t   a/=2;\\n            }\\n            int req=Math.max(0,k-c);\\n            ans+=arr[req];\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long countExcellentPairs(int[] nums, int k) {\\n        \\n        Set<Integer> set=new HashSet<>();\\n        for(int a:nums){\\n            set.add(a);\\n        }\\n        long arr[]=new long[32];\\n        Set<Integer> s1=new HashSet<>();\\n        for(Integer a:set){\\n            int c=0;\\n            while(a!=0){\\n                c+=a%2;\\n\\t\\t\\t   a/=2;\\n            }\\n            arr[c]++;\\n        }\\n        long ans=0;\\n        for(int i=30;i>=0;i--){\\n            arr[i]+=arr[i+1];\\n        }\\n        for(Integer a:set){\\n            int c=0;\\n            while(a!=0){\\n               c+=a%2;\\n\\t\\t\\t   a/=2;\\n            }\\n            int req=Math.max(0,k-c);\\n            ans+=arr[req];\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324673,
                "title": "cpp-easy-o-nlogn-time-o-n-space",
                "content": "Intuition : Sum of bits will remain constant \\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& v, int k) {\\n        ll ans=0;\\n        sort(v.begin(),v.end());\\n        v.resize(unique(v.begin(),v.end())-v.begin());\\n        int n=v.size();\\n        vector<ll> dp(n);\\n        for(int i=0;i<n;i++){\\n            dp[i]=__builtin_popcount(v[i]);\\n        }\\n        sort(dp.begin(),dp.end());\\n        for(int i=0;i<n;i++){\\n            ans+=n-(lower_bound(dp.begin(),dp.end(),k-dp[i])-dp.begin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& v, int k) {\\n        ll ans=0;\\n        sort(v.begin(),v.end());\\n        v.resize(unique(v.begin(),v.end())-v.begin());\\n        int n=v.size();\\n        vector<ll> dp(n);\\n        for(int i=0;i<n;i++){\\n            dp[i]=__builtin_popcount(v[i]);\\n        }\\n        sort(dp.begin(),dp.end());\\n        for(int i=0;i<n;i++){\\n            ans+=n-(lower_bound(dp.begin(),dp.end(),k-dp[i])-dp.begin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370663,
                "title": "c-logic-explained-with-pictures",
                "content": "The key to this solution lies in the fact that for any two numbers a and b, the sum of number of set bits in (a AND b) and (a OR b) = sum of number of set bits in a and b individually.\\n\\nBut why is this true? If we look closely at how AND and OR operations work, we can find out.\\n\\nConsider a number A which has x set bits in its binary representation and a number B which has y set bits in its binary representation. Also suppose that at k places the set bits of A and B coincide.\\n\\n![image](https://assets.leetcode.com/users/images/c038def1-371b-4af4-bf1a-f47b2738fe7e_1659461999.0725431.png)\\n\\nNow if we take A OR B, the number of set bits in the answer will be (x+y-k). This is because in the OR operation, if either of the bits is 1, the resultant bit at that position is also set. This means that for A, there will be a contribution of x set bits to the result and from B, a contibution of y set bits. But the places where the set bits of A and B coincide must\\'ve been counted twice in the result as they will produce only one set bit in the answer. Hence, to accomodate this we subtract k from (x+y).\\n\\n![image](https://assets.leetcode.com/users/images/c24d7aab-3a81-4ab5-a029-f8603cecc336_1659462034.1279852.png)\\n\\nFor AND operation, the number of set bits in the answer will simply be k as this the number of bits where both the bits in A as well as B are 1.\\n\\n![image](https://assets.leetcode.com/users/images/ad71bed0-2de9-4126-a4c2-697fe211cc7a_1659462050.6592577.png)\\n\\nHence, sum of the number of set bits in (A OR B) and (A AND B)  = x+y-k+k = x+y = sum of set bits in A and B.\\n\\nNow, this problem simply reduces to finding the number of distinct pairs such that the sum of number of set bits in both the number is >= k.\\n\\nIf we just had to find the number of distinct pairs where the sum is equal to k, we could have used a hashmap, but we also need to find the pairs where the sum is greater than k. \\n\\nWe can utilise the fact that any number in the given input range will have at most 32 bits. So if we have an array where we count how many numbers in the array have *i* bits set in their binary representation, where 0 <= i <= 31, then we can easily calculate the number of distinct pairs whose sum of set bits is >= k by looping through this array twice, and just with a complexity of O(32 * 32). Also, we need to make sure we keep a count of only distinct numbers in this array as we need to form distinct pairs. We can use a set for this.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int count_bits(int num)\\n    {  \\n        int sum = 0;\\n         \\n        for(int i=0;i<32;i++)\\n        {\\n            sum += (((1<<i)&num)!=0); \\n        }\\n        \\n        return sum;   \\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k)\\n    {\\n        \\n        long long int ans = 0;\\n    \\n        vector<int>bit_freq(32,0);\\n        set<int>distinct;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(distinct.find(nums[i])==distinct.end())\\n            {  \\n                distinct.insert(nums[i]);\\n                int set_bits = count_bits(nums[i]);\\n                bit_freq[set_bits]++;\\n            }\\n        }\\n        \\n        for(int first=0;first<32;first++)\\n        {\\n            for(int second=0;second<32;second++)\\n            {\\n                if(first+second>=k)\\n                {\\n                    ans += (1ll*bit_freq[first]*bit_freq[second]);\\n                }  \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n\\n- Time Complexity: O(32 * n + 32 * 32). Here, n is the size of the given array. We iterate over the array once and to find the number of set bits we iterate over each number\\'s 32 bits. After that we have two nested for loops over the bit frequency array which accounts for the term 32 * 32.\\n- Space Complexity: O(n + 32). We use a set to keep track of the distinct elements in the array which takes O(n) space and an array for bit frequency of length 32 which takes O(32) space.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int count_bits(int num)\\n    {  \\n        int sum = 0;\\n         \\n        for(int i=0;i<32;i++)\\n        {\\n            sum += (((1<<i)&num)!=0); \\n        }\\n        \\n        return sum;   \\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k)\\n    {\\n        \\n        long long int ans = 0;\\n    \\n        vector<int>bit_freq(32,0);\\n        set<int>distinct;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(distinct.find(nums[i])==distinct.end())\\n            {  \\n                distinct.insert(nums[i]);\\n                int set_bits = count_bits(nums[i]);\\n                bit_freq[set_bits]++;\\n            }\\n        }\\n        \\n        for(int first=0;first<32;first++)\\n        {\\n            for(int second=0;second<32;second++)\\n            {\\n                if(first+second>=k)\\n                {\\n                    ans += (1ll*bit_freq[first]*bit_freq[second]);\\n                }  \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324745,
                "title": "c",
                "content": "Lets assume,\\nA -> 101011\\nB ->  100011\\n\\nset bits in A&B = no_of_set_bits(B);\\nset bits in A|B = no_of_set_bits(A);\\n\\nTotal Set Bits = ( A&B + A|B )  = ( no_of_set_bits(B) + no_of_set_bits(A) );\\n\\n\\n```\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_map<int,set<int>> umap;\\n        for(auto i:nums){\\n            int a = __builtin_popcount(i);\\n            umap[a].insert(i);\\n        }\\n        long long ans=0;\\n        for(auto& i:umap){\\n            for(auto& j:umap){\\n                if((i.first+j.first)>=k){                 \\n                    int n1 = i.second.size();\\n                    int n2 = j.second.size();\\n                    ans+= (n1*n2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "Lets assume,\\nA -> 101011\\nB ->  100011\\n\\nset bits in A&B = no_of_set_bits(B);\\nset bits in A|B = no_of_set_bits(A);\\n\\nTotal Set Bits = ( A&B + A|B )  = ( no_of_set_bits(B) + no_of_set_bits(A) );\\n\\n\\n```\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_map<int,set<int>> umap;\\n        for(auto i:nums){\\n            int a = __builtin_popcount(i);\\n            umap[a].insert(i);\\n        }\\n        long long ans=0;\\n        for(auto& i:umap){\\n            for(auto& j:umap){\\n                if((i.first+j.first)>=k){                 \\n                    int n1 = i.second.size();\\n                    int n2 = j.second.size();\\n                    ans+= (n1*n2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2324724,
                "title": "c-binary-search-in-set-bits-of-each-unique-number",
                "content": "**Main Logic -**\\nConsider Two Numbers A and B\\n**Setbits( A or B) + Setbits( A and B) = Setbits(A) + Setbits(B)**\\n\\nApproach -\\n* First We will Find the Set Bits of each Unique Number in array and store them in a seperate array\\n* We are finding set bits of unique numbers only to avoid duplicate pairs\\n* Now sort the array which contain number of setbits of each unique number\\n* Now for each set bit x find another set bit y such that x + y >= k so x and y will form a pair  (To find Y we will use binary search)\\n* Since array is sorted in ascending order so each element after y will also form pair with x\\n* So for x total pairs will be add arr.size() - index of y  add this to the ans\\n* Find pairs for each x in array of setbits and add them to the ans\\n\\n**Complexity**\\nTime - O(NlogN)\\nSpace - O(N)\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n      \\n        for(int i=0; i<n; i++)\\n            mp[nums[i]] =  __builtin_popcount(nums[i]);       //store set bits of each unique number in nums[i]\\n        \\n        vector<int> v;\\n        for(auto &x:mp)\\n            v.push_back(x.second);                //push set bits or each unique number of nums[i] in a vector\\n        sort(v.begin(), v.end());            //sort the vector\\n        \\n\\t\\t//Now for each set bit x find a corresponding set bit y such that x + y >= k\\n\\t\\t// if x = v[i] then y = v[i] - k\\n\\t\\t//since the vector is sorted so for each x find y using binary search\\n\\t\\t//now x and y will form a pair but each element after y will also form a pair with x because vector is sorted in ascending order \\n\\t\\t//so if x + y >= k then for each z > y     x +z >= k \\n\\t\\t//so in ans add v.size() - index of y\\n\\t\\t\\n        long long ans = 0;\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            auto it = lower_bound(v.begin(), v.end(), k - v[i]);\\n            ans += (v.end() - it);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Clean Code Without Comments**\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n      \\n        for(int i=0; i<n; i++)\\n            mp[nums[i]] =  __builtin_popcount(nums[i]);\\n\\t\\t\\t\\n        vector<int> v;\\n        for(auto &x:mp)\\n            v.push_back(x.second);\\n\\t\\t\\t\\n        sort(v.begin(), v.end());\\n        long long ans = 0;\\n\\t\\t\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            auto it = lower_bound(v.begin(), v.end(), k - v[i]);\\n            ans += (v.end() - it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n      \\n        for(int i=0; i<n; i++)\\n            mp[nums[i]] =  __builtin_popcount(nums[i]);       //store set bits of each unique number in nums[i]\\n        \\n        vector<int> v;\\n        for(auto &x:mp)\\n            v.push_back(x.second);                //push set bits or each unique number of nums[i] in a vector\\n        sort(v.begin(), v.end());            //sort the vector\\n        \\n\\t\\t//Now for each set bit x find a corresponding set bit y such that x + y >= k\\n\\t\\t// if x = v[i] then y = v[i] - k\\n\\t\\t//since the vector is sorted so for each x find y using binary search\\n\\t\\t//now x and y will form a pair but each element after y will also form a pair with x because vector is sorted in ascending order \\n\\t\\t//so if x + y >= k then for each z > y     x +z >= k \\n\\t\\t//so in ans add v.size() - index of y\\n\\t\\t\\n        long long ans = 0;\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            auto it = lower_bound(v.begin(), v.end(), k - v[i]);\\n            ans += (v.end() - it);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n      \\n        for(int i=0; i<n; i++)\\n            mp[nums[i]] =  __builtin_popcount(nums[i]);\\n\\t\\t\\t\\n        vector<int> v;\\n        for(auto &x:mp)\\n            v.push_back(x.second);\\n\\t\\t\\t\\n        sort(v.begin(), v.end());\\n        long long ans = 0;\\n\\t\\t\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            auto it = lower_bound(v.begin(), v.end(), k - v[i]);\\n            ans += (v.end() - it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324683,
                "title": "python3-clean-o-n-o-1-solution-with-explanation",
                "content": "* Observations: \\n\\t1. Number of bit of `A OR B` and `A AND B` = number of bit of A + number of bit of B.\\n    Proof:\\n        * `bit_count(A) = common + delta_a`\\n        * `bit_count(B) = common + delta_b`\\n        * `bit_count((A OR B) + (A AND B)) = (common + delta_a + delta_b) + (common) = bit_count(A) + bit_count(B)`\\n\\t2. Only need to care distinct number in `nums`\\n\\n* Solution:\\n\\t* Define a counter, where `counter[i]` is number of num in `nums` such that number of bit one of num is `i`\\n    * Now, just need to count the number of pair `i, j` in counter, such that `i + j >= k`\\n\\n<iframe src=\"https://leetcode.com/playground/VY8UQEh9/shared\" frameBorder=\"0\" width=\"700\" height=\"450\"></iframe>\\n\\n**Complexity analysis:**\\n* Time: `O(N)`\\n* Space : `O(1)`",
                "solutionTags": [],
                "code": "* Observations: \\n\\t1. Number of bit of `A OR B` and `A AND B` = number of bit of A + number of bit of B.\\n    Proof:\\n        * `bit_count(A) = common + delta_a`\\n        * `bit_count(B) = common + delta_b`\\n        * `bit_count((A OR B) + (A AND B)) = (common + delta_a + delta_b) + (common) = bit_count(A) + bit_count(B)`\\n\\t2. Only need to care distinct number in `nums`\\n\\n* Solution:\\n\\t* Define a counter, where `counter[i]` is number of num in `nums` such that number of bit one of num is `i`\\n    * Now, just need to count the number of pair `i, j` in counter, such that `i + j >= k`\\n\\n<iframe src=\"https://leetcode.com/playground/VY8UQEh9/shared\" frameBorder=\"0\" width=\"700\" height=\"450\"></iframe>\\n\\n**Complexity analysis:**\\n* Time: `O(N)`\\n* Space : `O(1)`",
                "codeTag": "Unknown"
            },
            {
                "id": 2325268,
                "title": "simple-two-pointers-c-o-nlogn-time-o-n-space",
                "content": "Problem asks the number of pairs such that set bits(num1 and num2) + set bits(num1 or num2) must be >=k.\\n\\n**Observations:**\\nOne simple observation is that\\n**set_bits(num1 and num2) + set_bits(num1 or num2) is equal to set_bits(num1)+set_bits(num2) .**\\n\\nWe store each element\\'s set bits count and element itself in a set so as to have unique pairs and also sorted pairs in order of their set bits count.\\n\\nwe copy the set to the vector so that we can perform two pointers method to count desired pairs.\\n\\n**Working:**\\nNow answer of how two pointers method works \\n\\nex. test case: nums = [1,2,3,1], k = 3\\nPairs stored in vector: [{1,1},{1,2},{2,3}]\\ntaking p=0 and q=vector_size -1\\n\\nNow if(v[p].first+v[q].first>=k) \\ntaking q as a element of pair we can easily consider all indexes which are >=p to make pair with index q so ans=ans+2*(q-p).\\nMultiplied by 2  as for example (1,3) and (3,1) would count as 2 pairs.\\n \\nAlso one case  is that when q makes pair with itself so if v[q].first*2>=k then ans=ans+1.\\n\\n**Complexity:**\\nTime complexity: O(nlogn)\\nspace complexity: O(n)\\n\\n**C++ Code:**\\n```\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        // initializing a set to only have unique pairs \\n        // first element in a pair of set represent number of set bits \\n        // second element in a pair of set represent number of number itself \\n        set <pair<int,int>> s;\\n        \\n\\t\\t//__builtin_popcount(int x) is a method used to count number of set bits in integer x\\n        for(int i=0;i<nums.size();i++){\\n            s.insert({__builtin_popcount(nums[i]),nums[i]});\\n        }\\n        \\n        // now coping the set to vector so that we can take 2 pointers \\n        vector <pair<int,int>> v;\\n        for(auto it:s){\\n            v.push_back(it);\\n        }\\n        \\n        int p=0,q=v.size()-1;\\n        // ans stores the number of pairs\\n        while(p<=q){\\n            if(v[p].first+v[q].first>=k){\\n                if(2*v[q].first>=k){\\n                    ans++;\\n                }\\n                ans+=2*(q-p);\\n                q--;\\n            }\\n            else{\\n                p++;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        // initializing a set to only have unique pairs \\n        // first element in a pair of set represent number of set bits \\n        // second element in a pair of set represent number of number itself \\n        set <pair<int,int>> s;\\n        \\n\\t\\t//__builtin_popcount(int x) is a method used to count number of set bits in integer x\\n        for(int i=0;i<nums.size();i++){\\n            s.insert({__builtin_popcount(nums[i]),nums[i]});\\n        }\\n        \\n        // now coping the set to vector so that we can take 2 pointers \\n        vector <pair<int,int>> v;\\n        for(auto it:s){\\n            v.push_back(it);\\n        }\\n        \\n        int p=0,q=v.size()-1;\\n        // ans stores the number of pairs\\n        while(p<=q){\\n            if(v[p].first+v[q].first>=k){\\n                if(2*v[q].first>=k){\\n                    ans++;\\n                }\\n                ans+=2*(q-p);\\n                q--;\\n            }\\n            else{\\n                p++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2723414,
                "title": "python-3-8-lines-w-example-t-m-98-44",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        \\n        bits, ans = defaultdict(int), 0         #  Ex:  nums = [1,2,9,1,3,4,9]\\n                                                #\\n        for num in set(nums):                   #  set(nums) = {1, 2, 3, 4, 9}      \\n            bits[num.bit_count()] += 1          #  no. of bits: 1  1  2  1  2  =>  bits = {1:3, 2:2}\\n            \\n        for i in bits:                          #    i   j  i+j>=k  ans\\n            for j in bits:                      #   \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                if i + j >= k:                  #    1   1   False    0\\n                    ans+= bits[i] * bits[j]     #    1   2   True     0 + 3*2 = 6\\n                                                #    2   1   True     6 + 2*3 = 12\\n        return ans                              #    2   2   True    12 + 2*2 = 16 <-- ans    \\n```\\n[https://leetcode.com/submissions/detail/826134852/](http://)",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        \\n        bits, ans = defaultdict(int), 0         #  Ex:  nums = [1,2,9,1,3,4,9]\\n                                                #\\n        for num in set(nums):                   #  set(nums) = {1, 2, 3, 4, 9}      \\n            bits[num.bit_count()] += 1          #  no. of bits: 1  1  2  1  2  =>  bits = {1:3, 2:2}\\n            \\n        for i in bits:                          #    i   j  i+j>=k  ans\\n            for j in bits:                      #   \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013 \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                if i + j >= k:                  #    1   1   False    0\\n                    ans+= bits[i] * bits[j]     #    1   2   True     0 + 3*2 = 6\\n                                                #    2   1   True     6 + 2*3 = 12\\n        return ans                              #    2   2   True    12 + 2*2 = 16 <-- ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353661,
                "title": "python-o-nlogn-sorting-binary-search-solution-explained",
                "content": "For me, the key insight into this problem was the realization that the test we were provided to determine if a pair is excellent can be greatly simplified. The alternate test the simplification leads to can then be reverse to quickly construct and count excellent pairs.\\n\\n## Checking if a Pair is Excellent\\nBefore discussing how to simplify the test, I want to define a couple functions which will be helpful in this discussion:\\n* **bits(n) = {the set of all \\'1\\' bits in the binary representation of n}**\\n* **f(m, n) = |bits(m | n)| + |bits(m & n)|**\\nwhere |A| is the number of elements in the set A, | is bitwise OR, and & is bitwise AND\\n(also note that a pair (m, n) is excellent if f(m, n) >= k)\\n\\n\\nNext, for a bit to be in bits(m | n) it must either be in bits(m) or bits(n). This means that **bits(m | n) = bits(m) \\u222A bits(n)**. From here we can compute an alternate method to compute the size of this set, since **|bits(m) \\u222A bits(n)| = |bits(m)| + |bits(n)| - |bits(m) \\u2229 bits(n)|**. (basically, this means that the size of the set (bits(m) \\u222A bits(n)) is the size of bits(m) plus the size of bits(n) minus any double-counting)\\n\\nThen, for a bit to be in bits(m & n) it must be in both bits(m) and bits(n). Or, in set notation: **bits(m & n) = bits(m) \\u2229 bits(n)**. This means that **|bits(m & n)| = |bits(m) \\u2229 bits(n)|**.\\n\\nSubbing these results into our original expression for f(m, n) gives:\\n\\n**f(m, n) = |bits(m | n)| + |bits(m & n)| = |bits(m)| + |bits(n)| - |bits(m) \\u2229 bits(n)| + |bits(m) \\u2229 bits(n)|**\\n\\nAnd finally, the intersection terms cancel out, leaving:\\n\\n**f(m, n) = |bits(m)| + |bits(n)|**\\n\\nThis equation is nice, because it implies that f(m, n) doesn\\'t include any difficult interations between the bits of m and n, instead it only depends on how many \\'1\\' bits are in m and n separately, which is a much easier function to work with.\\n\\n## The Algorithm\\nPrecomputation: O(nlogn)\\n1. Throw out any duplicates since we only care about unique pairs.\\n2. Compute the number of \\'1\\' bits for each number in nums. I\\'ll call the resulting list *B*.\\n3. Count the number of occurences of each value *b* in *B*. This will give us a list *counts* which contains tuples of (# bits, occurences).\\n4. Sort *counts* for easier lookup later (either with a bianry sort, or a 2-pointer approach).\\n5. Compute the reversed prefix sum of the occurences. This is useful, because if a collection of numbers with i bits and a collection of numbers with j bits has k or more bits, then every collection of numbers with more than j bits will also form valid pairs with numbers with i bits. So pre-computing this avoids expensive re-computation later. In my code I called this array *sums* for lack of a better name.\\n\\nPair Counting: O(nlogn)\\n1. Select a *(b, c) = (# bits, occurences)* item from *counts*.\\n2. Use a bisection search on counts to find the index *i* of the smallest existing group of numbers which for excellent pairs with numbers containing *b* bits (i.e. the smalles *i* such that b + counts[i][0] >= k).\\n3. Compute the number of valid pairs which can be made where the first number has *b* bits using the expression: *c\\\\*sums[i]* (i.e. to make a valid group you can choose any number with *b* bits, and any number with at least *k - b* bits, so the number of pairs which start with *b* bits is equal to the number of numbers with *b* bits times the number of numbers with at least *k - b* bits).\\n4. Repeat steps 1-3 for all items in *counts*, summing the result.\\n\\n## Code\\nFirst Run Performance: 1102 ms / 32 MB\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(n)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef countExcellentPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t\\t# Count the Number of Bits in Each Unique Number - O(n)\\n\\t\\t\\t# Tally the Number of Times Each Bit Count Occurs - O(n)\\n\\t\\t\\t# Sort the (bit count, tally) pairs by bit count - O(nlogn)\\n\\t\\t\\tcounts = sorted(Counter(map(int.bit_count, set(nums))).items()) # (I am fully aware that this line of code is really doing too much work)\\n\\n\\t\\t\\t# Compute the Reversed Prefix Sum of the Tallies (i.e. sums[i] is how many numbers have at least counts[i][0] \\'1\\' bits) - O(n)\\n\\t\\t\\tsums = [0]*len(counts)\\n\\t\\t\\tsums[-1] = counts[-1][1]\\n\\t\\t\\tfor i in range(len(sums) - 2, -1, -1):\\n\\t\\t\\t\\tsums[i] += counts[i][1] + sums[i + 1]\\n\\n\\t\\t\\t# Choose Each Number as the First Number of a Pair - O(nlogn)\\n\\t\\t\\tpairs = 0\\n\\t\\t\\tfor n, c in counts:\\n\\t\\t\\t\\t# Find the Smallest Number Which Forms a Valid Pair - O(logn)\\n\\t\\t\\t\\ti = bisect_left(counts, k - n, key = lambda x: x[0])\\n\\n\\t\\t\\t\\t# Check if Any Pairs Can be Formed\\n\\t\\t\\t\\tif i < len(sums):\\n\\t\\t\\t\\t\\t# Compute the Number of Pairs Which Start With the Given Collection of Numbers\\n\\t\\t\\t\\t\\tpairs += c*sums[i]\\n\\n\\t\\t\\t# Return the Number of Pairs\\n\\t\\t\\treturn pairs\\n\\'\\'\\'\\n\\n## Notes\\nThe pair counting can also be done with a 2-pointer approach, which reduces the time complexity for that section to O(n), since each pointer makes exactly 1 pass through *counts*.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "For me, the key insight into this problem was the realization that the test we were provided to determine if a pair is excellent can be greatly simplified. The alternate test the simplification leads to can then be reverse to quickly construct and count excellent pairs.\\n\\n## Checking if a Pair is Excellent\\nBefore discussing how to simplify the test, I want to define a couple functions which will be helpful in this discussion:\\n* **bits(n) = {the set of all \\'1\\' bits in the binary representation of n}**\\n* **f(m, n) = |bits(m | n)| + |bits(m & n)|**\\nwhere |A| is the number of elements in the set A, | is bitwise OR, and & is bitwise AND\\n(also note that a pair (m, n) is excellent if f(m, n) >= k)\\n\\n\\nNext, for a bit to be in bits(m | n) it must either be in bits(m) or bits(n). This means that **bits(m | n) = bits(m) \\u222A bits(n)**. From here we can compute an alternate method to compute the size of this set, since **|bits(m) \\u222A bits(n)| = |bits(m)| + |bits(n)| - |bits(m) \\u2229 bits(n)|**. (basically, this means that the size of the set (bits(m) \\u222A bits(n)) is the size of bits(m) plus the size of bits(n) minus any double-counting)\\n\\nThen, for a bit to be in bits(m & n) it must be in both bits(m) and bits(n). Or, in set notation: **bits(m & n) = bits(m) \\u2229 bits(n)**. This means that **|bits(m & n)| = |bits(m) \\u2229 bits(n)|**.\\n\\nSubbing these results into our original expression for f(m, n) gives:\\n\\n**f(m, n) = |bits(m | n)| + |bits(m & n)| = |bits(m)| + |bits(n)| - |bits(m) \\u2229 bits(n)| + |bits(m) \\u2229 bits(n)|**\\n\\nAnd finally, the intersection terms cancel out, leaving:\\n\\n**f(m, n) = |bits(m)| + |bits(n)|**\\n\\nThis equation is nice, because it implies that f(m, n) doesn\\'t include any difficult interations between the bits of m and n, instead it only depends on how many \\'1\\' bits are in m and n separately, which is a much easier function to work with.\\n\\n## The Algorithm\\nPrecomputation: O(nlogn)\\n1. Throw out any duplicates since we only care about unique pairs.\\n2. Compute the number of \\'1\\' bits for each number in nums. I\\'ll call the resulting list *B*.\\n3. Count the number of occurences of each value *b* in *B*. This will give us a list *counts* which contains tuples of (# bits, occurences).\\n4. Sort *counts* for easier lookup later (either with a bianry sort, or a 2-pointer approach).\\n5. Compute the reversed prefix sum of the occurences. This is useful, because if a collection of numbers with i bits and a collection of numbers with j bits has k or more bits, then every collection of numbers with more than j bits will also form valid pairs with numbers with i bits. So pre-computing this avoids expensive re-computation later. In my code I called this array *sums* for lack of a better name.\\n\\nPair Counting: O(nlogn)\\n1. Select a *(b, c) = (# bits, occurences)* item from *counts*.\\n2. Use a bisection search on counts to find the index *i* of the smallest existing group of numbers which for excellent pairs with numbers containing *b* bits (i.e. the smalles *i* such that b + counts[i][0] >= k).\\n3. Compute the number of valid pairs which can be made where the first number has *b* bits using the expression: *c\\\\*sums[i]* (i.e. to make a valid group you can choose any number with *b* bits, and any number with at least *k - b* bits, so the number of pairs which start with *b* bits is equal to the number of numbers with *b* bits times the number of numbers with at least *k - b* bits).\\n4. Repeat steps 1-3 for all items in *counts*, summing the result.\\n\\n## Code\\nFirst Run Performance: 1102 ms / 32 MB\\nTime Complexity: O(nlogn)\\nSpace Complexity: O(n)\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef countExcellentPairs(self, nums: List[int], k: int) -> int:\\n\\t\\t\\t# Count the Number of Bits in Each Unique Number - O(n)\\n\\t\\t\\t# Tally the Number of Times Each Bit Count Occurs - O(n)\\n\\t\\t\\t# Sort the (bit count, tally) pairs by bit count - O(nlogn)\\n\\t\\t\\tcounts = sorted(Counter(map(int.bit_count, set(nums))).items()) # (I am fully aware that this line of code is really doing too much work)\\n\\n\\t\\t\\t# Compute the Reversed Prefix Sum of the Tallies (i.e. sums[i] is how many numbers have at least counts[i][0] \\'1\\' bits) - O(n)\\n\\t\\t\\tsums = [0]*len(counts)\\n\\t\\t\\tsums[-1] = counts[-1][1]\\n\\t\\t\\tfor i in range(len(sums) - 2, -1, -1):\\n\\t\\t\\t\\tsums[i] += counts[i][1] + sums[i + 1]\\n\\n\\t\\t\\t# Choose Each Number as the First Number of a Pair - O(nlogn)\\n\\t\\t\\tpairs = 0\\n\\t\\t\\tfor n, c in counts:\\n\\t\\t\\t\\t# Find the Smallest Number Which Forms a Valid Pair - O(logn)\\n\\t\\t\\t\\ti = bisect_left(counts, k - n, key = lambda x: x[0])\\n\\n\\t\\t\\t\\t# Check if Any Pairs Can be Formed\\n\\t\\t\\t\\tif i < len(sums):\\n\\t\\t\\t\\t\\t# Compute the Number of Pairs Which Start With the Given Collection of Numbers\\n\\t\\t\\t\\t\\tpairs += c*sums[i]\\n\\n\\t\\t\\t# Return the Number of Pairs\\n\\t\\t\\treturn pairs\\n\\'\\'\\'\\n\\n## Notes\\nThe pair counting can also be done with a 2-pointer approach, which reduces the time complexity for that section to O(n), since each pointer makes exactly 1 pass through *counts*.",
                "codeTag": "Java"
            },
            {
                "id": 2353127,
                "title": "swift-fully-explained",
                "content": "**Brute Force approach O(n^2)  (Time Limit Exceeded)**\\n```\\nclass Solution {\\n    func countExcellentPairs(_ nums: [Int], _ k: Int) -> Int {\\n        let nums = Set(nums).map { $0.nonzeroBitCount }\\n        var counter = 0\\n        for i in nums {\\n            for j in nums where i + j >= k {\\xA0\\n                counter += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```\\n\\n**Optimized approach O(n)  (Accepted Answer)**\\n```\\nclass Solution {\\n    func countExcellentPairs(_ nums: [Int], _ k: Int) -> Int {\\n        let nums = Set(nums).map{ $0.nonzeroBitCount }.sorted()\\n        var counter = nums.reduce(0) { $0 + ($1*2 >= k ? 1 : 0) } \\n        var left = 0, right = nums.count - 1\\n        while left < right {\\n            if nums[left] + nums[right] >= k {\\n                counter += (right - left) * 2\\n                right -= 1\\n            } else {\\n                left += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```\\n\\n**OPTIMIZED SOLUTION EXPLANATION**\\n\\n**1) Rewrite Problem Statement**\\n\\nThe problem expects us to find pairs (or single elements doubled up) where the bit counts of `OR`ing and `AND`ing add up to at least `k`:\\n\\n```\\ncountbits(nums[i] | nums[j]) + countbits(nums[i] & nums[j]) >= k\\n```\\n\\nMathematically, this is a disguised version of simple addition:\\n\\n```\\ncountbits(nums[i]) + countbits(nums[j]) >= k\\n```\\n\\nWe can use the simple addition approach to rewrite the problem statement with two requirements:\\n**Requirement 1)** We want to count each unique individual element whose bit count doubled up is greater than or equal to `k`\\n**Requirement 2)** We want to count each unique distinct pair of elements whose bit counts added together is greater than or equal to `k`. Each distinct pair counts twice to the solution, e.g`(nums[i], nums[j])` and `(nums[j], nums[i])` since both need to be included in the count.\\n\\n**2) Implement Solution**\\n1) Create an array of unique elements of `nums`. In Swift, this is easy to do: `Array(Set(nums))`\\n2) Convert all elements in the set to bit counts. Also, easy: `.map { $0.nonzeroBitCount }`. Since this uses a Swift library function to count bits, we may get asked to count bits in hand-generated code: \\n```\\n.map{ num -> Int in\\n\\tvar count = 0, num = num\\n\\twhile num > 0 {\\n\\t\\tcount += num & 1\\n\\t\\tnum >>= 1\\n\\t}\\n\\treturn count\\n }\\n```\\n3) Finally, this unique element bit count array needs to be sorted so we can optimize the naive ***O(n^2)*** algorithm to an ***O(n)*** algorithm.\\n\\nSteps 1 - 3 can be written in one line:\\n```\\nlet nums = Set(nums).map{ $0.nonzeroBitCount }.sorted()\\n```\\n\\n4) Next, we can implement **Requirement 1** by counting up how many individual element bit counts in `nums`, when doubled, are at least `k`:\\n```\\nvar counter = nums.reduce(0) { $0 + ($1*2 >= k ? 1 : 0) } \\n```\\nor, alternatively:\\n```\\nvar counter = nums.filter { $0*2 >= k }.count \\n```\\n\\n5) Next, we can implement **Requirement 2** with a ***O(n)*** algorithm that uses a sliding window technique. There is a low pointer `left` and a high pointer `right`. If `nums[left] + nums[right] >= k`, then we also know that every element between `left + 1` and `right - 1` when added to `nums[right]` will also be greater than or equal to `k` . When this is the case we add `left-right` to our `counter`, and then multiply by two because both permutations are required to be counted in the result.\\n6) The `left` and `right` pointers are stepped incrementally, instead of half-wise like a binary search, so the complexity order is ***O(n)*** instead of ***O(log2 n)*** . \\n7) When the `left` and `right` pointers converge, we are finished and return `counter`.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func countExcellentPairs(_ nums: [Int], _ k: Int) -> Int {\\n        let nums = Set(nums).map { $0.nonzeroBitCount }\\n        var counter = 0\\n        for i in nums {\\n            for j in nums where i + j >= k {\\xA0\\n                counter += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func countExcellentPairs(_ nums: [Int], _ k: Int) -> Int {\\n        let nums = Set(nums).map{ $0.nonzeroBitCount }.sorted()\\n        var counter = nums.reduce(0) { $0 + ($1*2 >= k ? 1 : 0) } \\n        var left = 0, right = nums.count - 1\\n        while left < right {\\n            if nums[left] + nums[right] >= k {\\n                counter += (right - left) * 2\\n                right -= 1\\n            } else {\\n                left += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```\n```\\ncountbits(nums[i] | nums[j]) + countbits(nums[i] & nums[j]) >= k\\n```\n```\\ncountbits(nums[i]) + countbits(nums[j]) >= k\\n```\n```\\n.map{ num -> Int in\\n\\tvar count = 0, num = num\\n\\twhile num > 0 {\\n\\t\\tcount += num & 1\\n\\t\\tnum >>= 1\\n\\t}\\n\\treturn count\\n }\\n```\n```\\nlet nums = Set(nums).map{ $0.nonzeroBitCount }.sorted()\\n```\n```\\nvar counter = nums.reduce(0) { $0 + ($1*2 >= k ? 1 : 0) } \\n```\n```\\nvar counter = nums.filter { $0*2 >= k }.count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325637,
                "title": "cpp-easy-solution",
                "content": "Let f(n)=number of set bits in n\\nThen\\nf(a|b)=f(a)+f(b)-f(a&b). ....(1)\\nNow we need\\nf(a|b)+f(a&b)>=k\\nUsing equation 1\\nf(a)+f(b)>=k.\\n\\nNow we can solve using bruteforce by storing elements that have f(x)=i\\n\\nCode based on the above idea\\n```cpp\\nclass Solution {\\n    int set_bits(int n)\\n    {\\n        int k=0;\\n        while(n>0)\\n        {\\n            k+=n%2;\\n            n=n/2;\\n        }\\n        return k;\\n    }\\n    \\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0ll;\\n        vector<long long> freq(40,0);\\n        set<int> s;\\n        \\n        for(auto ele : nums)\\n            s.insert(ele);\\n        \\n        for(auto ele : s)\\n        {\\n            int temp=set_bits(ele);\\n            freq[temp]++;\\n        }\\n        \\n        for(auto ele : s)\\n        {\\n            int temp=set_bits(ele);\\n            int t=ans;\\n            for(int i=std::max(0,k-temp);i<40;i++)\\n                ans=ans+freq[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\n    int set_bits(int n)\\n    {\\n        int k=0;\\n        while(n>0)\\n        {\\n            k+=n%2;\\n            n=n/2;\\n        }\\n        return k;\\n    }\\n    \\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0ll;\\n        vector<long long> freq(40,0);\\n        set<int> s;\\n        \\n        for(auto ele : nums)\\n            s.insert(ele);\\n        \\n        for(auto ele : s)\\n        {\\n            int temp=set_bits(ele);\\n            freq[temp]++;\\n        }\\n        \\n        for(auto ele : s)\\n        {\\n            int temp=set_bits(ele);\\n            int t=ans;\\n            for(int i=std::max(0,k-temp);i<40;i++)\\n                ans=ans+freq[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324632,
                "title": "c-easy-solution-o-n",
                "content": "\\n\\nNotice that `OR(num1, num2) + AND(num1, num2) = sum_of_bits(num1) + sum_of_bits(num2)`.\\n\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<long long> cnt(32);\\n        set<int> s;\\n        for(auto n : nums) {\\n            s.insert(n);\\n        }\\n        for(auto n : s) {\\n            ++cnt[__builtin_popcount(n)];\\n        }\\n        long long ans = 0;\\n        \\n        for(auto n : s) {\\n            int bits = __builtin_popcount(n);\\n            int r = max(0, k - bits);\\n            for(int i = r; i < 32; i++) {\\n                ans += cnt[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<long long> cnt(32);\\n        set<int> s;\\n        for(auto n : nums) {\\n            s.insert(n);\\n        }\\n        for(auto n : s) {\\n            ++cnt[__builtin_popcount(n)];\\n        }\\n        long long ans = 0;\\n        \\n        for(auto n : s) {\\n            int bits = __builtin_popcount(n);\\n            int r = max(0, k - bits);\\n            for(int i = r; i < 32; i++) {\\n                ans += cnt[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330729,
                "title": "go-246ms-combinatorics-full-explanation",
                "content": "**Observations:**\\n\\nThe second condition given details things regarding the AND and OR operators, as well as the total bit count of the results. Let\\'s inspect the two bitwise operations:\\n```\\n  1010      1010\\n& 1100    | 1100\\n------    ------\\n  1000      1110\\n```\\n\\nFrom this, we can observe that we will get a `1` in the AND if it is `1` in both of the inputs only, and we get a `1` in the OR if either input has a `1` at that position. Let\\'s inspect how the sum of the set bits in the AND and the OR is affected position by position:\\n\\nIf a position has two 1s, we increase the sum of the number of set bits by 2 -- 1 for the AND and 1 for the OR. If a position has a 1 and a 0, we increase the sum by 1 for the OR only. If a position has two 0s, we don\\'t increase the sum, since both the AND and the OR are 0 at this position. Notice that the amount we increase the sum for a position is always equal to the number of 1s at this position!\\n\\nTherefore, we want the number of ordered pairs of numbers `(a, b)` such that `popcount(a) + popcount(b) >= k`, where `popcount` represents a function that returns the number of 1 bits in a number.\\n\\nThis suggests a combinatorial approach of sorts. We\\'ll keep the number of distinct elements from `nums` with `i` 1 bits in `bits[i]`. Then for each pair `(x, y)` where `x + y >= k`, we can multiply `bits[x] * bits[y]` to get the number of pairs corresponding to this. Note that we only want distinct elements, since having (for example) `210` twice is meaningless -- the second instance of `210` is not used in any pairs, since any pairs it is in could already have been made with the first `210`.\\n\\nTo convince ourselves this works, let\\'s look at pairs in the result. A pair `(a, b)` where `a` and `b` have different numbers of 1 counts (call these `x` and `y` as before) will have to be counted once -- namely, counted when we multiply `bits[x] * bits[y]`. The pair `(b, a)` likewise is counted when we add on `bits[y] * bits[x]` -- these are done in separate multiplications. If `a` and `b` both have `x` 1 bits set, then the multiplication `bits[x] * bits[x]` will include both `(a, b)` and `(b, a)`, since the first number in the pair is one of `bits[x]` choices and the second number is another one such choice. Finally, all pairs in the form `(a, a)` are supposed to be counted exactly once -- reversing the numbers does not create a distinct pair -- and it is, in fact, only counted once in the product `bits[x] * bits[x]` as desired.\\n\\n**Implementation:**\\n\\nWe first will need a function to count the number of 1 bits set in a number. In C++, this would be accomplished by just calling `__builtin_popcount`, but Go doesn\\'t give us something like this, so we get to build it ourselves! We could loop through each bit individually and maintain a sum, but this is slow, so we do it in parallel instead. In particular, the first step is used to make the number stored in the highest 2 bits equal to the number of 1s in the highest 2 bits. In the second step, the number stored in the highest 4 bits is equal to the number of 1s in the highest 4 bits of the original integer, and so on until the last step has the highest 32 bits equal to the number of 1s in the highest 32 bits of the original integer -- namely, the whole thing. This allows us to do the popcount in only 20 operations and 5 assignments.\\n\\nFor our main function, we proceed mostly as described previously. To store the integers that we already have (to avoid duplicates), we use a `map[int]bool`, which is set to true for any integers that we have already added. All other integers are not in the map and therefore map to the default value of false when acessed. The `bits` array is used to store the number of distinct elements of `nums` with each number of 1 bits. We then iterate through `nums` and use our `popcount` function from earlier to increment the corresponding value when necessary. This takes O(n) time.\\n\\nWe then iterate through all possible combinations of `i` and `j` such that `0 <= i, j < 32` and `i, j >= k`. Note that we don\\'t need to check `32` for either `i` or `j`, because that implies the sign bit is set in the original number in `nums`, however, we know that all elements are positive as given. For each, we multiply and add to our total as described earlier. We perform at most `32 * 32 = 1024` multiplications and additions, so this step is `O(1)` as it\\'s not dependent on the size of any of the inputs.\\n\\n**Code:**\\n```\\nfunc popcount(n int) int {\\n    n = (n & 0x55555555) + ((n >> 1) & 0x55555555)\\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\\n    n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f)\\n    n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff)\\n    return (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff)\\n}\\n\\nfunc max(a int, b int) int {\\n    if (a > b) {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n    used := make(map[int]bool)\\n    bits := make([]int, 32)\\n    for _, x := range nums {\\n        if(used[x]) {\\n            continue\\n        }\\n        used[x] = true\\n        bits[popcount(x)]++\\n    }\\n    res := int64(0)\\n    for i := 0; i < 32; i++ {\\n        for j := max(0, k - i); j < 32; j++ {\\n            res += int64(bits[i] * bits[j])\\n        }\\n    }\\n    return res\\n}\\n```\\n\\nIf this helped you, please upvote!",
                "solutionTags": [
                    "Go",
                    "Combinatorics"
                ],
                "code": "```\\n  1010      1010\\n& 1100    | 1100\\n------    ------\\n  1000      1110\\n```\n```\\nfunc popcount(n int) int {\\n    n = (n & 0x55555555) + ((n >> 1) & 0x55555555)\\n    n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\\n    n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f)\\n    n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff)\\n    return (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff)\\n}\\n\\nfunc max(a int, b int) int {\\n    if (a > b) {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n    used := make(map[int]bool)\\n    bits := make([]int, 32)\\n    for _, x := range nums {\\n        if(used[x]) {\\n            continue\\n        }\\n        used[x] = true\\n        bits[popcount(x)]++\\n    }\\n    res := int64(0)\\n    for i := 0; i < 32; i++ {\\n        for j := max(0, k - i); j < 32; j++ {\\n            res += int64(bits[i] * bits[j])\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325403,
                "title": "bits-set-logic-simple-and-cool",
                "content": "```\\nclass Solution {\\n\\tpublic long countExcellentPairs(int[] arr, int k) {\\n\\t\\tlong temp[] = new long[32];\\n        int count = 0;\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tset.add(arr[i]);\\n\\t\\t}\\n\\t\\tfor (int val : set) {\\n\\t\\t\\ttemp[Integer.bitCount(val)]++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tfor (int j = 0; j < 32; j++) {\\n\\t\\t\\t\\tif (i + j >= k) {\\n\\t\\t\\t\\t\\tcount += temp[i] * temp[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long countExcellentPairs(int[] arr, int k) {\\n\\t\\tlong temp[] = new long[32];\\n        int count = 0;\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tset.add(arr[i]);\\n\\t\\t}\\n\\t\\tfor (int val : set) {\\n\\t\\t\\ttemp[Integer.bitCount(val)]++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < 32; i++) {\\n\\t\\t\\tfor (int j = 0; j < 32; j++) {\\n\\t\\t\\t\\tif (i + j >= k) {\\n\\t\\t\\t\\t\\tcount += temp[i] * temp[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324913,
                "title": "explanation-with-diagram-c-code-set-theory",
                "content": "Let\\u2019s say \\n**n(A)** denotes the number of set bits in **\\u2018A\\u2019**.\\n**n(B)** denotes the number of set bits in **\\u2018B\\u2019**.\\n\\nThen **n( A & B )** denotes the number of set bits in **\\u2018A&B\\u2019**.\\nAnd **n( A | B)** denotes the number of set bits in **\\u2018A|B\\u2019**.\\n\\nIf we convert this problem to set theory, \\nThen it will look like this.\\n\\n![image](https://assets.leetcode.com/users/images/34825a73-a4f2-461b-b267-700c9864ccda_1658635426.6096902.jpeg)\\n\\n\\n\\n**n(A)** \\t    will be \\u201CBlue+Yellow\\u201D\\n**n(B)** \\t    will be \\u201CYellow+Green\\u201D\\n**n( A&B )**  will be \\u201CYellow\\u201D\\n**n( A|B )**    will be \\u201CBlue+Yellow+Green\\u201D\\n\\nNow, what we want is,\\n**n( A&B ) + n( A|B ) >=k**\\n\\n**\\u201CYellow\\u201D + \\u201CBlue+Yellow+Green\\u201D >=k**\\n\\nIt is same as,\\n**\\u201CBlue + Yellow\\u201D + \\u201CYellow + Green\\u201D>=k**\\n\\n**n(A) + n(B) >=k**.\\n\\nSo, our ultimate target is to calculate number of distinct pairs (a,b) where \\n(number of set bits of a + number of set bits of b) >=k.\\n\\n**Step 1:** Maintain one set of given numbers to avoid duplicates.\\n**Step 2:** Maintain the frequency array. Where freq[i] denotes the number of elements having i number of set bits.\\n**Step 3:** Now we want to calculate the pairs (a,b) such that, n(a) + n(b) >=k\\n**Step 4:** For this, iterate over every element of the set(mentioned in Step 1). Let\\u2019s say the current number is \\u2018curr\\u2019, and it is having a \\u2018cnt\\u2019 number of set bits. A pair (curr,x) is valid, if n(x)>=k-cnt. Now we want to find the number of elements having set bits count greater than (k-cnt). Evaluate it using, freq array.\\n\\n```\\nclass Solution {\\npublic:\\n    int cntSetBits(int n){\\n        int ans=0;\\n        // cout<<n<<\\' \\';\\n        while(n){\\n            if(n&1){\\n                ans++;\\n            }\\n            n=(n>>1);\\n        }\\n        // cout<<ans<<\\'\\\\n\\';\\n        return ans;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        vector<long long>freq(63);\\n        set<int>st(nums.begin(),nums.end());\\n        for(auto n:st){\\n            freq[cntSetBits(n)]++;\\n        }\\n        for(auto n:st){\\n            int my=cntSetBits(n);\\n            int least=max(0,k-my);\\n            for(int i=least;i<63;i++){\\n                ans+=freq[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cntSetBits(int n){\\n        int ans=0;\\n        // cout<<n<<\\' \\';\\n        while(n){\\n            if(n&1){\\n                ans++;\\n            }\\n            n=(n>>1);\\n        }\\n        // cout<<ans<<\\'\\\\n\\';\\n        return ans;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        vector<long long>freq(63);\\n        set<int>st(nums.begin(),nums.end());\\n        for(auto n:st){\\n            freq[cntSetBits(n)]++;\\n        }\\n        for(auto n:st){\\n            int my=cntSetBits(n);\\n            int least=max(0,k-my);\\n            for(int i=least;i<63;i++){\\n                ans+=freq[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324864,
                "title": "cpp-o-n-log-n-time-o-n-space",
                "content": "Since we have number of \\nbits set in ( a | b ) + bits set in ( a & b ) = bits set in a + bits set in b\\n```\\nint bits(int a){\\n    int cnt = 0;\\n    while(a) a&=a-1,cnt++;\\n    return cnt;\\n}\\n// Number of bits set in a\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<pair<int,int>> A;\\n        int x = -1;\\n        sort(nums.begin(),nums.end());\\n        for(int a : nums) if(x == a) continue; else x = a,A.push_back({bits(a),a});\\n        // removed any repitions, A[i] = {number of set bits in x , x }\\n\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\n        long long ans = 0;\\n        int i = 0 , j = A.size()-1,n = A.size();\\n\\t\\t// Using 2 pointers\\n        while(i<n){\\n            while(j>=0 and k <= A[j].first+A[i].first)\\n                --j;\\n            ans += n - j - 1;//for all index > j, condition is true for index i.\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nint bits(int a){\\n    int cnt = 0;\\n    while(a) a&=a-1,cnt++;\\n    return cnt;\\n}\\n// Number of bits set in a\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<pair<int,int>> A;\\n        int x = -1;\\n        sort(nums.begin(),nums.end());\\n        for(int a : nums) if(x == a) continue; else x = a,A.push_back({bits(a),a});\\n        // removed any repitions, A[i] = {number of set bits in x , x }\\n\\t\\tsort(A.begin(),A.end());\\n\\t\\t\\n        long long ans = 0;\\n        int i = 0 , j = A.size()-1,n = A.size();\\n\\t\\t// Using 2 pointers\\n        while(i<n){\\n            while(j>=0 and k <= A[j].first+A[i].first)\\n                --j;\\n            ans += n - j - 1;//for all index > j, condition is true for index i.\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324682,
                "title": "python-easy-to-understand-2-pointer-solution-w-explanation",
                "content": "The key part for the quesiton is to understand the value `The sum of the number of set bits in num1 OR num2 and num1 AND num2` is actually the sum of count of 1 in bit representative of 2 number\\nThen if we change the array to be counts of 1 in bit representative of each number, sort the array,  it change to a 2-pointer question.\\nWe could first consider the counts of paris formed by different number, then consider the pairs formed by same number \\n``` Python\\n        \\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        A  = sorted([bin(n).count(\\'1\\') for n in set(nums)])\\n        res = 0\\n        p1, p2 = 0, len(A) - 1\\n        while p1 < p2:\\n            if A[p1] + A[p2] >= k:\\n                res += (p2 - p1) * 2 # *2 because it can be either (a, b) or (b,a)\\n                p2 -= 1\\n            else:\\n                p1 += 1\\n        \\n        for n in A:\\n            if 2 * n >= k:\\n                res += 1\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "``` Python\\n        \\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        A  = sorted([bin(n).count(\\'1\\') for n in set(nums)])\\n        res = 0\\n        p1, p2 = 0, len(A) - 1\\n        while p1 < p2:\\n            if A[p1] + A[p2] >= k:\\n                res += (p2 - p1) * 2 # *2 because it can be either (a, b) or (b,a)\\n                p2 -= 1\\n            else:\\n                p1 += 1\\n        \\n        for n in A:\\n            if 2 * n >= k:\\n                res += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558654,
                "title": "very-simple-c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int> s;\\n        for(auto &i: nums)s.insert(i);\\n        vector<int> v(32,0);\\n        int x = 0;\\n        for(auto i: s){\\n            x = 0;\\n            while(i){\\n                x += (i&1);\\n                i >>= 1;\\n            }\\n            v[x]++;\\n        }\\n        long long int ans = 0;\\n        int i,j;\\n        for(i = 0; i < 32; i++){\\n            for(j = 0; j < 32; j++){\\n                if(i+j>=k)\\n                    ans += v[i]*1LL*v[j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int> s;\\n        for(auto &i: nums)s.insert(i);\\n        vector<int> v(32,0);\\n        int x = 0;\\n        for(auto i: s){\\n            x = 0;\\n            while(i){\\n                x += (i&1);\\n                i >>= 1;\\n            }\\n            v[x]++;\\n        }\\n        long long int ans = 0;\\n        int i,j;\\n        for(i = 0; i < 32; i++){\\n            for(j = 0; j < 32; j++){\\n                if(i+j>=k)\\n                    ans += v[i]*1LL*v[j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359052,
                "title": "time-o-max-nlogn-n-60-c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> v(61,0);\\n        long long int ans = 0,y=0,n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < n; i++){\\n            while(i<n-1&&nums[i]==nums[i+1])i++;\\n            int x = 0,a = nums[i];\\n            while(a){\\n                x += (a&1);\\n                a >>= 1;\\n            }\\n            if(x*2>=k){\\n                y++;\\n            }\\n            for(int i = max(k-x,0); i<= 60; i++){\\n                ans += v[i];\\n            }\\n            v[x]++;\\n        }\\n        return ans*2+y;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> v(61,0);\\n        long long int ans = 0,y=0,n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < n; i++){\\n            while(i<n-1&&nums[i]==nums[i+1])i++;\\n            int x = 0,a = nums[i];\\n            while(a){\\n                x += (a&1);\\n                a >>= 1;\\n            }\\n            if(x*2>=k){\\n                y++;\\n            }\\n            for(int i = max(k-x,0); i<= 60; i++){\\n                ans += v[i];\\n            }\\n            v[x]++;\\n        }\\n        return ans*2+y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403301,
                "title": "easy-solution-cpp",
                "content": "**Please Upvote......**\\n```\\nclass Solution {\\npublic:\\n    int countbits(int ele,long long &ans,int k){\\n        int ct=0;\\n        while(ele){\\n            ct++;\\n            ele=ele&(ele-1);\\n        }\\n        \\n        if(2*ct>=k)ans++;\\n        \\n        return ct;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        \\n        unordered_set<int>s;\\n        for(auto ele:nums){\\n            s.insert(ele);\\n        }\\n        \\n        vector<int>v;\\n        for(auto ele:s){\\n            v.push_back(countbits(ele,ans,k));\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        int start=0,end=v.size()-1;\\n        \\n        while(start<end){\\n            if(v[start]+v[end]>=k){\\n                ans+=2*(end-start);\\n                end--;\\n            }\\n            \\n            else start++;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int countbits(int ele,long long &ans,int k){\\n        int ct=0;\\n        while(ele){\\n            ct++;\\n            ele=ele&(ele-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2339350,
                "title": "from-raw-thoughts-to-a-solution-o-nlogn-time",
                "content": "**What we need** \\nWe need to find distinct pairs of (a, b) from nums such that set bit in a&b and set bits in a|b is >= k\\n\\n**Raw thought on a and b**\\nThink in a way that what is contribution of a set bit from a or from b to this sum that is needed >= k.\\nA bit can contribute a plus one in a&b operation else it will definately contribute a plus in a|b.\\nAssume two numbers in binary:\\n\\t00001111  -> a\\n\\t11110000 -> b\\n\\t\\n\\ta&b = 00000000 \\n\\ta|b = 11111111\\n\\nIf somewhere a\\'s bit is at at position i, and b\\'s bit is not set, then a will not contribute in a&b but will contribute in sum a plus one in a|b. Now, the other case would if a\\'s i-th bit is set and b\\'s i-th bit is also set then total contribution in sum would be plus 2, i.e. one from a&b and one from a|b, we can say that a will contribute a plus one and b will contribute a plus one in sum. So, if a bit is set in a number it will definately contribute a plus one in sum of number of bits in a&b and a|b.\\n\\nTotal sum required is >= k. If a contributes i bits (assuming a has i set bits), then b must contribute atleast (k - i) therefore b must have k - i set bits, can have greater than too as we need total sum >= k.\\nI have made a bits vector that denotes numbers of unique values in nums having i bits set. As we need a b for an a such that it has >= (k - i) set bits, hence I have also done a prefix sum backwards.\\n\\nHere\\'s the code :\\n\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector <long long> bits(65, 0);\\n        unordered_map <int, int> mp;\\n        for(auto &num : nums){\\n            mp[num]++;\\n            if(mp[num] == 1){\\n                //saving uniques values in nums according to set bits in bits vector\\n                bits[__builtin_popcount(num)]++;\\n            } \\n        }\\n        \\n        \\n        for(int i = 63; i>=0; i--){\\n            bits[i] += bits[i+1];\\n        }\\n        \\n        long long ans = 0;\\n        \\n        //iterating for number of set bits in a\\n        for(int i = 0; i<=64; i++){\\n            int setbitsInb = (k - i >= 0 ? k - i : 0);\\n            long long NumOfb = bits[setbitsInb], NumOfa = (i != 64 ? bits[i] - bits[i+1] : bits[i]);\\n            ans += (NumOfa*NumOfb);\\n            \\n        }\\n \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector <long long> bits(65, 0);\\n        unordered_map <int, int> mp;\\n        for(auto &num : nums){\\n            mp[num]++;\\n            if(mp[num] == 1){\\n                //saving uniques values in nums according to set bits in bits vector\\n                bits[__builtin_popcount(num)]++;\\n            } \\n        }\\n        \\n        \\n        for(int i = 63; i>=0; i--){\\n            bits[i] += bits[i+1];\\n        }\\n        \\n        long long ans = 0;\\n        \\n        //iterating for number of set bits in a\\n        for(int i = 0; i<=64; i++){\\n            int setbitsInb = (k - i >= 0 ? k - i : 0);\\n            long long NumOfb = bits[setbitsInb], NumOfa = (i != 64 ? bits[i] - bits[i+1] : bits[i]);\\n            ans += (NumOfa*NumOfb);\\n            \\n        }\\n \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331238,
                "title": "c-bit-solution-hashing-using-c-easy-to-understand",
                "content": "\\nThe Inclusion-Exclusion Principle\\nbits(num1 OR num2) + bits(num1 AND num2) = bits(num1) + bits(num2)\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) \\n    {\\n        vector<long long> cnt(30,0);\\n        long long ans=0;\\n        for(auto &x:unordered_set(nums.begin(),nums.end()))\\n        {\\n            cnt[__builtin_popcount(x)]++;\\n        }\\n        for(int i=0;i<30;i++)\\n        {\\n            for(int j=0;j<30;j++)\\n            {\\n                if(i+j>=k)\\n                {\\n                    ans+=cnt[i]*cnt[j];\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) \\n    {\\n        vector<long long> cnt(30,0);\\n        long long ans=0;\\n        for(auto &x:unordered_set(nums.begin(),nums.end()))\\n        {\\n            cnt[__builtin_popcount(x)]++;\\n        }\\n        for(int i=0;i<30;i++)\\n        {\\n            for(int j=0;j<30;j++)\\n            {\\n                if(i+j>=k)\\n                {\\n                    ans+=cnt[i]*cnt[j];\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330919,
                "title": "proof-with-explanation-simple-intuition",
                "content": "In this problem if we fix a particular number then can we predict anothe number ?\\n\\nConvert the question into two cases:\\n1. **Non Overlapping Case**: (Means the number of set bits are not overlapping):\\n       N1 = 1010101\\n\\t   N2 = 0101010\\n\\tAND = 0000000  (Since Overlapping is zero)\\n\\tOR   = 11111111 \\n\\tSuppose **if number of set bits in N1 are n1 and number of set bits in N2 are n2** then in above non overlapping case AND = 0 and OR = n1 + n2:\\n\\tSo -> AND + OR = n1 + n2  ..... (1)\\n\\t\\n2. **Overlapping Case**:(Means the number of set bits are overlapping):\\n       N1 = 101110100\\n\\t   N2 = 001010101\\n\\t   \\n  AND = overlapping set bits \\n  OR = n1 + n2 - (overlapping set bits)\\n  \\n  If we add both of them then :\\n     AND + OR = n1 + n2   ....  (2)\\n\\t \\n-> From equation 1 and 2 we can deduce that the summation of AND and OR only depends on the number of set bits in number 1 and number of set bits in number 2.\\n\\nNow u can follow this code : \\nCode: \\nhttps://leetcode.com/contest/weekly-contest-303/submissions/detail/755078727/\\n\\nhttps://leetcode.com/problems/number-of-excellent-pairs/discuss/2324745/c\\n\\n\\t \\n\\t   \\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "In this problem if we fix a particular number then can we predict anothe number ?\\n\\nConvert the question into two cases:\\n1. **Non Overlapping Case**: (Means the number of set bits are not overlapping):\\n       N1 = 1010101\\n\\t   N2 = 0101010\\n\\tAND = 0000000  (Since Overlapping is zero)\\n\\tOR   = 11111111 \\n\\tSuppose **if number of set bits in N1 are n1 and number of set bits in N2 are n2** then in above non overlapping case AND = 0 and OR = n1 + n2:\\n\\tSo -> AND + OR = n1 + n2  ..... (1)\\n\\t\\n2. **Overlapping Case**:(Means the number of set bits are overlapping):\\n       N1 = 101110100\\n\\t   N2 = 001010101\\n\\t   \\n  AND = overlapping set bits \\n  OR = n1 + n2 - (overlapping set bits)\\n  \\n  If we add both of them then :\\n     AND + OR = n1 + n2   ....  (2)\\n\\t \\n-> From equation 1 and 2 we can deduce that the summation of AND and OR only depends on the number of set bits in number 1 and number of set bits in number 2.\\n\\nNow u can follow this code : \\nCode: \\nhttps://leetcode.com/contest/weekly-contest-303/submissions/detail/755078727/\\n\\nhttps://leetcode.com/problems/number-of-excellent-pairs/discuss/2324745/c\\n\\n\\t \\n\\t   \\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2328330,
                "title": "simple-solution-in-o-nlog-n-cpp-bits-set-bit-logic",
                "content": "My logic is based on the fact that ,\\n\\t\\t\\t   **setbit(a | b) = setbit(a) + setbit(b) - setbit(a & b)**\\n   So,\\n\\t\\t\\t   **setbit( a&b) + setbit(a|b) = setbit(a) + setbit(b)** \\n\\t   \\n   In the below solution we have tried to make pair of setbit with sum greater than k also we have not considered repeated element as we need unique pair.\\n   \\n\\tint countSetBit(int n){\\n        int count = 0;\\n        while (n) {\\n            count += (n & 1);\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n\\t\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> v(33,0);\\n        set<int> st;\\n        \\n        for(int &x:nums){\\n            if(st.find(x)==st.end())\\n                st.insert(x);\\n            else\\n                continue;\\n            \\n            v[countSetBit(x)]++;\\n        }\\n        long long ans =0;\\n        \\n        for(int i=0;i<=32;i++){\\n            for(int j=0;j<=32;j++){\\n                if(i+j>=k){\\n                    ans += (v[i]*1LL*v[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\nIf you liked it, Please do upvote.\\nIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "My logic is based on the fact that ,\\n\\t\\t\\t   **setbit(a | b) = setbit(a) + setbit(b) - setbit(a & b)**\\n   So,\\n\\t\\t\\t   **setbit( a&b) + setbit(a|b) = setbit(a) + setbit(b)** \\n\\t   \\n   In the below solution we have tried to make pair of setbit with sum greater than k also we have not considered repeated element as we need unique pair.\\n   \\n\\tint countSetBit(int n){\\n        int count = 0;\\n        while (n) {\\n            count += (n & 1);\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n\\t\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> v(33,0);\\n        set<int> st;\\n        \\n        for(int &x:nums){\\n            if(st.find(x)==st.end())\\n                st.insert(x);\\n            else\\n                continue;\\n            \\n            v[countSetBit(x)]++;\\n        }\\n        long long ans =0;\\n        \\n        for(int i=0;i<=32;i++){\\n            for(int j=0;j<=32;j++){\\n                if(i+j>=k){\\n                    ans += (v[i]*1LL*v[j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\nIf you liked it, Please do upvote.\\nIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47",
                "codeTag": "Unknown"
            },
            {
                "id": 2326755,
                "title": "simple-python-solution-with-explanation-binary-search-3-lines-of-code",
                "content": "Basic idea:\\n=======\\n1. Notice that \\n\\t```(# of bits of x AND y) + (# of bits of x AND y) = (# of bits of x) + (# of bits of y)```\\n\\n2. With knowledge of the relationship in #1, we first ensure all numbers in ```nums``` are unique. Then we create an list whose elements are a tuple of:\\n- the number of ```1``` bits for each unique number in ```nums```\\n- the number itself\\n\\n3. For each number with ```bit``` 1 bits, use binary search to find the ```k - bit``` bit value in the list.\\n\\n**Time complexity** - O(NlogN)\\n**Space complexity** - O(N)\\n\\n**Easier to read version of solution:**\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        total = 0\\n        nums_set = set(nums)\\n        nums1bits = sorted([(Counter(str(bin(num)))[\\'1\\'], num) for num in nums_set])\\n        \\n        for bit, num in nums1bits:\\n            total += len(nums_set) - bisect_left(nums1bits, (k-bit, 0))\\n        \\n        return total\\n```\\n\\n**3-lines of code Solution:**\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        total, nums_set = 0, set(nums)\\n        nums1bits = sorted([(Counter(str(bin(num)))[\\'1\\'], num) for num in nums_set])\\n        return sum([len(nums_set) - bisect_left(nums1bits, (k-bit, 0)) for bit, num in nums1bits])\\n```\\n\\n",
                "solutionTags": [],
                "code": "```(# of bits of x AND y) + (# of bits of x AND y) = (# of bits of x) + (# of bits of y)```\n```nums```\n```1```\n```nums```\n```bit```\n```k - bit```\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        total = 0\\n        nums_set = set(nums)\\n        nums1bits = sorted([(Counter(str(bin(num)))[\\'1\\'], num) for num in nums_set])\\n        \\n        for bit, num in nums1bits:\\n            total += len(nums_set) - bisect_left(nums1bits, (k-bit, 0))\\n        \\n        return total\\n```\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        total, nums_set = 0, set(nums)\\n        nums1bits = sorted([(Counter(str(bin(num)))[\\'1\\'], num) for num in nums_set])\\n        return sum([len(nums_set) - bisect_left(nums1bits, (k-bit, 0)) for bit, num in nums1bits])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325283,
                "title": "best-way-to-understand-this-problem",
                "content": "**KEY IDEA :   n(A \\u222A B) = n(A) + n(B) \\u2013 n(A \\u2229 B)**\\nIt is required in the problem that we have to find count of pairs where \\nnumber of set bits of (A | B)  + number of set bits of (A & B) >= k\\nas  **union** in mathematics implies  **OR** in boolean algebra and **intersection** implies **AND** operation in boolean algebra.\\ntherefore: \\nn(A | B)= n(A) + n( B) - n( A & B)\\n**n(A) +n (B) = n(A| B) + n(A& B)**\\n which imples \\n number of set bits of A + number of set bits of B = number of set bits (A) **OR** number of set bits of (B) + number of set bits( A) **AND** number of set bits(B) \\n Algorithm :\\n*  make a unique set of given integers and a initialize variable ans= 0.\\n*  Build a 32 size integer array to store the frequency of the numbers having same number of bits. ( An integer can hold up to 32 bits therefore 32 size array is used) .\\n*  Now we use two nested loops with iteration from 1 to 32 , to make pairs of A and B  and check if ( setbits(A ) + setBits (B) >=k) then ans = ans+ frequency[ bits(A) ]* freq[ bits(B)]\\n*  return the answer\\n\\n   C++ code\\n ```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n      long long ans=0;\\n      int freq[31]={};\\n        set<int>s(nums.begin(),nums.end());\\n        for(int i:s)\\n            freq[cnt(i)]++;\\n        for(int i=1;i<=30;i++){\\n            for(int j=1;j<=30;j++){\\n                if(i+j>=k)\\n                    ans+=freq[i]*freq[j];\\n            }\\n        }\\n        return ans;\\n    }\\n    int cnt(int n){\\n        int c=0;\\n        while(n){\\n            n=n&n-1;\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n\\n**PLEASE UPVOTE IF YOU FIND IT HELPFUL**\\n\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n      long long ans=0;\\n      int freq[31]={};\\n        set<int>s(nums.begin(),nums.end());\\n        for(int i:s)\\n            freq[cnt(i)]++;\\n        for(int i=1;i<=30;i++){\\n            for(int j=1;j<=30;j++){\\n                if(i+j>=k)\\n                    ans+=freq[i]*freq[j];\\n            }\\n        }\\n        return ans;\\n    }\\n    int cnt(int n){\\n        int c=0;\\n        while(n){\\n            n=n&n-1;\\n            c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325096,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        mapp = defaultdict(set)\\n        ans = 0\\n        last = None\\n        for i in nums:\\n            if i==last:\\n                continue\\n            b = format(i,\\'b\\').count(\\'1\\')\\n            mapp[b].add(i)\\n            t = k-b\\n            for j in range(max(0,t),31):\\n                ans+=len(mapp[j])*2\\n                if i in mapp[j]:\\n                    ans-=1\\n            last = i\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        mapp = defaultdict(set)\\n        ans = 0\\n        last = None\\n        for i in nums:\\n            if i==last:\\n                continue\\n            b = format(i,\\'b\\').count(\\'1\\')\\n            mapp[b].add(i)\\n            t = k-b\\n            for j in range(max(0,t),31):\\n                ans+=len(mapp[j])*2\\n                if i in mapp[j]:\\n                    ans-=1\\n            last = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324990,
                "title": "c-separately-solving-smaller-and-larger-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0 , size=0  ;\\n        unordered_map<int,int> m;\\n        vector<long long> v;\\n        for(auto it : nums)\\n        {\\n           if(m[it]==0)\\n           {\\n               long long t=__builtin_popcount(it);\\n               if(t<k)\\n               v.emplace_back(t);\\n               size++;\\n           }\\n            m[it]=1;\\n        }\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            long long x= k-v[i];\\n            auto add =lower_bound(v.begin(), v.end(), x);\\n            long long y= (add-v.begin());\\n            ans+=(n-y);\\n        }\\n       // cout<<size<<\" \"<<n;\\n        ans+= ((size-n)*n*2);\\n        size=size-n;\\n        ans+= size*(size-1);\\n        ans+= size;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0 , size=0  ;\\n        unordered_map<int,int> m;\\n        vector<long long> v;\\n        for(auto it : nums)\\n        {\\n           if(m[it]==0)\\n           {\\n               long long t=__builtin_popcount(it);\\n               if(t<k)\\n               v.emplace_back(t);\\n               size++;\\n           }\\n            m[it]=1;\\n        }\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            long long x= k-v[i];\\n            auto add =lower_bound(v.begin(), v.end(), x);\\n            long long y= (add-v.begin());\\n            ans+=(n-y);\\n        }\\n       // cout<<size<<\" \"<<n;\\n        ans+= ((size-n)*n*2);\\n        size=size-n;\\n        ans+= size*(size-1);\\n        ans+= size;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2324943,
                "title": "set-c",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countBit(int num){\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile(num){\\n\\t\\t\\t\\tnum &= (num - 1);\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tlong long countExcellentPairs(vector<int>& nums, int k) {\\n\\t\\t\\tll res = 0;\\n\\t\\t\\tunordered_set<int>s;\\n\\t\\t\\tvector<int>val;\\n\\t\\t\\tfor(auto x:nums){\\n\\t\\t\\t\\tif(s.count(x)) continue;\\n\\t\\t\\t\\tval.push_back(countBit(x));\\n\\t\\t\\t\\ts.insert(x);\\n\\t\\t\\t}\\n\\t\\t\\tsort(begin(val),end(val));\\n\\t\\t\\tfor(auto x:val){\\n\\t\\t\\t\\tauto it = end(val) - lower_bound(begin(val),end(val),k-x);\\n\\t\\t\\t\\tres+= it;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countBit(int num){\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile(num){\\n\\t\\t\\t\\tnum &= (num - 1);\\n\\t\\t\\t\\tres++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2324934,
                "title": "just-count-set-bits-o-n-python-8-lines",
                "content": "* We want the number of set bits in `(a | b)` + number of set bits in `(a & b)`.\\n\\n* Set bits in `a | b` = (Set bits in `a`) + (Set bits in `b`) - (Set bits in `a&b`).\\n\\nTherefore:\\nnumber of set bits in `(a | b)` + number of set bits in `(a & b)` =\\nnumber of set bits in `a` + number of set bits in `b`\\n****\\n**Python**\\n```python\\nclass Solution:\\n\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        count_set_bits = defaultdict(set)\\n        for x in nums:\\n            count_set_bits[x.bit_count()].add(x)\\n\\n        answer = 0\\n        for nbits1, nbits2 in product(count_set_bits, count_set_bits):\\n            if nbits1 + nbits2 >= k:\\n                answer += len(count_set_bits[nbits1]) * len(count_set_bits[nbits2])\\n        return answer\\n```\\n`O(n)` time and space, as each number has at most 30 bits.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        count_set_bits = defaultdict(set)\\n        for x in nums:\\n            count_set_bits[x.bit_count()].add(x)\\n\\n        answer = 0\\n        for nbits1, nbits2 in product(count_set_bits, count_set_bits):\\n            if nbits1 + nbits2 >= k:\\n                answer += len(count_set_bits[nbits1]) * len(count_set_bits[nbits2])\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324798,
                "title": "explained-short-c-solution",
                "content": "The main idea is that any 2 numbers & and | operations set bit count will be equal to the sum of their bit counts.\\nWe pre calculated the bit count and saved it in an array.\\nNow we will do the number of pairs greater than k to find the ans in nlog (n) time .\\nFor that we will first sort the array and the find the array greater than or equal to k-arr[i] using lower_bound function. all the elements after that element will also be in our answer so we will add arr.size()-j to our answer.\\nComplexity - nlog(n)\\n```\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int>arr;\\n        set<int>st(nums.begin(),nums.end());\\n\\n        for(auto i=st.begin();i!=st.end();i++){\\n                auto a = *i;\\n                int count=0;\\n                for(int j=0;j<32;j++){\\n                    if(*i & (1<<j))count++;\\n                    \\n                }\\n            arr.push_back(count);\\n        }\\n        long long ans=0;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        for (int i = 0; i < arr.size(); ++i) {\\n\\n        int j = lower_bound(arr.begin(), arr.end(), k-arr[i]) - arr.begin();\\n \\n\\n        ans += arr.size()-j;\\n    }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int>arr;\\n        set<int>st(nums.begin(),nums.end());\\n\\n        for(auto i=st.begin();i!=st.end();i++){\\n                auto a = *i;\\n                int count=0;\\n                for(int j=0;j<32;j++){\\n                    if(*i & (1<<j))count++;\\n                    \\n                }\\n            arr.push_back(count);\\n        }\\n        long long ans=0;\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        for (int i = 0; i < arr.size(); ++i) {\\n\\n        int j = lower_bound(arr.begin(), arr.end(), k-arr[i]) - arr.begin();\\n \\n\\n        ans += arr.size()-j;\\n    }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324642,
                "title": "o-n-solution-explaination-simple-set-theory-solution",
                "content": "A very basic set theory principle states that for an overlapping set, the following holds true\\n\\t\\t\\t**n ( P \\u222A Q ) = n(P) + n(Q) \\u2013 n ( P \\u2229 Q)**\\n\\t\\t\\twhere n() represent the size of set\\n\\nnow if we consider all the numbers as a set itself with each of its one bit as its element, \\nthen the question is basically asking ask to find the number of pairs of (P, Q) such that **n ( P \\u222A Q )+n ( P \\u2229 Q) >= k**, \\nwhich using set theory principle easily translates to finding pairs such that  **n(P)+n (Q) >= k**\\n\\nIn our case, n(P) is nothing but number of set bits in P. \\n\\nLet me know if there is some doubt\\n**Golang**\\n```\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n  count := [32]int{}\\n  m := map[int]bool{}\\n  for i:= 0;i<len(nums);i++{\\n    if m[nums[i]]{\\n      continue\\n    }\\n    m[nums[i]] = true\\n    l := bits.OnesCount(uint(nums[i]))\\n    count[l]++\\n  }\\n  res := 0\\n  for i:= 0;i<=31;i++{\\n    if i+i >=k{\\n    res += count[i]*count[i]}\\n    for j:= i+1;j<=31;j++{\\n      if i+j>=k {\\n        res += 2*count[i]*count[j]\\n      }\\n    }\\n  }\\n  return int64(res)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Ordered Set"
                ],
                "code": "```\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n  count := [32]int{}\\n  m := map[int]bool{}\\n  for i:= 0;i<len(nums);i++{\\n    if m[nums[i]]{\\n      continue\\n    }\\n    m[nums[i]] = true\\n    l := bits.OnesCount(uint(nums[i]))\\n    count[l]++\\n  }\\n  res := 0\\n  for i:= 0;i<=31;i++{\\n    if i+i >=k{\\n    res += count[i]*count[i]}\\n    for j:= i+1;j<=31;j++{\\n      if i+j>=k {\\n        res += 2*count[i]*count[j]\\n      }\\n    }\\n  }\\n  return int64(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659859,
                "title": "easy-c-solution-with-approach-explained-in-detail",
                "content": "\\n# Approach\\nFirst Thought is that how to reduce the calculation of OR and AND of 2 number repeatedly. We know the inclusion exclusion formula for two numbers\\nf(a OR b) = f(a) + f(b) - f(a AND b)\\n\\nLet f(x) be defined as set bits in number x. Then we can write the same formula for the above case.\\nf(a OR b) + f(a AND b) = f(a) + f(b)\\nSo this means sum of set bits in OR and AND of 2 numbers is same as sum of setbits of those 2 numbers only So no need of OR and AND operations.\\n\\nAs we have to find distinct pairs so we will store all numbers in set data structure. We will also keep a vector which will keep count of setbits of numbers in set.\\n\\nFinally if we get the setbits now OUR PROBLEM GOT REDUCED TO finding number of distinct pairs of numbers in array whose sum is >=k. Its simple, we will sort the array and use two pointer technique.\\nAs (1,3) and (3,1) are distinct (as given in question) so we will multiply our ans by 2 as we count in array.\\n\\nBUT THERE IS A CATCH. They are counting (a,a) as a pair too. So we have to keep a track of this too. As it will result in only a single such pair so we will add that in our countsetbits function only.\\nLike if (2*setbits_in_nums[i]>=k) then ans++.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN). As we are sorting the array.\\n\\n- Space complexity:\\nO(N). As we are using set data structure.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countsetbits(int num, long long &ans, int k){\\n        int set1= 0;\\n        for(int i =0;i<32;i++)\\n        {\\n            if((1<<i)&num)\\n                set1++;\\n        }\\n        if(2*set1>=k) ans++;\\n        return set1;\\n    }\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        vector<int> setbits; \\n        for(auto it: s){\\n           int bits=countsetbits(it,ans,k);\\n           setbits.push_back(bits);\\n        }\\n\\n        sort(setbits.begin(), setbits.end());\\n        int start=0;\\n        int end=setbits.size()-1;\\n        while(start<end){\\n            if(setbits[start]+setbits[end]>=k){\\n                ans+=(end-start)*2;\\n                end--;\\n            }\\n            else{\\n                start++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countsetbits(int num, long long &ans, int k){\\n        int set1= 0;\\n        for(int i =0;i<32;i++)\\n        {\\n            if((1<<i)&num)\\n                set1++;\\n        }\\n        if(2*set1>=k) ans++;\\n        return set1;\\n    }\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        vector<int> setbits; \\n        for(auto it: s){\\n           int bits=countsetbits(it,ans,k);\\n           setbits.push_back(bits);\\n        }\\n\\n        sort(setbits.begin(), setbits.end());\\n        int start=0;\\n        int end=setbits.size()-1;\\n        while(start<end){\\n            if(setbits[start]+setbits[end]>=k){\\n                ans+=(end-start)*2;\\n                end--;\\n            }\\n            else{\\n                start++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569656,
                "title": "brute-force-o-n-n-number-to-optimized-o-n-log-number-code-with-all-the-logics-and-algorithms-used",
                "content": "# 1. Brute Force Code\\n### Approach\\nChecking all the possible pairs along with trivial function to finds the count of set bits in binary representation of a decimal number.\\n\\n### Complexity\\n- Time complexity: O(n * n * number)\\n\\n- Space complexity: O(n * 2)\\n\\n```\\nclass Solution {\\n    private static int countSetBits(int number){\\n        int count = 0;\\n        for(int bit=1;bit<=32;bit++){\\n            count += (number & 1);\\n            number >>= 1;\\n        }\\n        return count;\\n    }\\n\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int index1=0;index1<nums.length;index1++){\\n            for(int index2=0;index2<nums.length;index2++){\\n                int num1 = (nums[index1]|nums[index2]), num2 = (nums[index1]&nums[index2]);\\n                int setBitsInNum1 = countSetBits(num1), setBitsInNum2 = countSetBits(num2);\\n                if(setBitsInNum1 + setBitsInNum2 >= k){set.add(Arrays.asList(nums[index1],nums[index2]));}\\n            }\\n        }\\n        return (long)set.size();\\n    }\\n}\\n\\n// Brute Force Approach - TLE\\n// Time Complexity : O(n*n*number)\\n// Space Complexity : O(n*2)\\n```\\n \\n\\n# 2. Brute Force Code With countBits Function Optimization \\n### Approach\\nChecking all the possible pairs along with Brian Kernighan\\u2019s Algorithm to finds the count of set bits in binary representation of a decimal number instead of using trivial function.\\n\\n### Complexity\\n- Time complexity: O(n * n * log(number))\\n\\n- Space complexity: O(n * 2)\\n```\\nclass Solution {\\n\\n    // Brian Kernighan\\u2019s Algorithm\\n    private static int countSetBits(int number){\\n        int count = 0;\\n        while(number != 0){\\n            number = (number)&(number-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int index1=0;index1<nums.length;index1++){\\n            for(int index2=0;index2<nums.length;index2++){\\n                int num1 = nums[index1], num2 = nums[index2];\\n                int setBitsInNum1 = countSetBits(num1), setBitsInNum2 = countSetBits(num2);\\n                if(setBitsInNum1 + setBitsInNum2 >= k){set.add(Arrays.asList(nums[index1],nums[index2]));}\\n            }\\n        }\\n        return (long)set.size();\\n    }\\n}\\n\\n// Brute Force Approach - TLE\\n// Time Complexity : O(n*n*log(number))\\n// Space Complexity : O(n*2)\\n\\n```\\n\\n# 3. Code By Storing The setBits \\n### Approach\\nStoring The setBits Of All The Numbers Of The Array And THen Applying The Two Sum Analogy.\\n\\n### Complexity\\n- Time complexity: O(n * n * log(number))\\n\\n- Space complexity: O(n *2)\\n```\\nclass Solution {\\n\\n    // Brian Kernighan\\u2019s Algorithm\\n    private static int countSetBits(int number){\\n        int count = 0;\\n        while(number != 0){\\n            number = (number)&(number-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    private static int[] storeSetBits(int[] nums){\\n        int[] store = new int[nums.length];\\n        for(int index=0;index<nums.length;index++){store[index] = countSetBits(nums[index]);}\\n        return store;\\n    }\\n\\n    private static long twoSumAnalogy(int[] nums, int[] store, int target){\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int index1=0,len=store.length;index1<len;index1++){\\n            for(int index2=0;index2<len;index2++){\\n                if(store[index1] + store[index2] >= target){\\n                    set.add(Arrays.asList(nums[index1],nums[index2]));\\n                }\\n            }\\n        }\\n        return (long)set.size();\\n    }\\n\\n    public long countExcellentPairs(int[] nums, int k) {\\n        int[] store = new int[nums.length];\\n        store = storeSetBits(nums);\\n        return twoSumAnalogy(nums,store,k);\\n    }\\n}\\n\\n// Brute Force Approach - TLE\\n// Time Complexity : O(n*n*log(number))\\n// Space Complexity : O(n*2)\\n\\n```\\n\\n# 4. Optimized Code Using The Counting Sort \\n### Approach\\n- The Inclusion-Exclusion Principle\\n```\\nbits(num1 OR num2) + bits(num1 AND num2) = bits(num1) + bits(num2)\\n```\\n- Working \\n\\n    For all different ```a``` in ```nums```, counts its number of bits.\\n\\n    Enumearte the number of bits ```k1``` and ```k2```,\\n    if ```k1 + k2 >= k```, we accumulate ``` count[k1] * count[k2] ```.\\n- Why we made countArray of size 30?\\n    Because it is given that ```max(nums[i]) = 1e9```, and we knwo that to represent any number in binary we needs a maximum of ```[log2(number)] + 1``` bits. Hence ```log2(10^9) ~ 9*log2(10) ~ 9*3.322 ~ 29.8 => [29.8] + 1 = 30```.\\n\\n### Complexity\\n- Time complexity: O(n * log(number))\\n\\n- Space complexity: O(n)\\n```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long countArray[] = new long[30], count = 0;\\n        Set<Integer> set = new HashSet<>(); \\n        for(int num : nums) set.add(num);                                    // O(n)    \\n        for(int num : set) countArray[Integer.bitCount(num)]++;              // O(nlog(number))\\n        for(int bit=1;bit<30;bit++){\\n            for(int bit_=1;bit_<30;bit_++){\\n                if(bit+bit_>=k) count += countArray[bit]*countArray[bit_];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n// Counting Sort Optimized Code \\n// Time Complexity : O(n + nlog(number))\\n// Space Complexity : O(n) \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static int countSetBits(int number){\\n        int count = 0;\\n        for(int bit=1;bit<=32;bit++){\\n            count += (number & 1);\\n            number >>= 1;\\n        }\\n        return count;\\n    }\\n\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int index1=0;index1<nums.length;index1++){\\n            for(int index2=0;index2<nums.length;index2++){\\n                int num1 = (nums[index1]|nums[index2]), num2 = (nums[index1]&nums[index2]);\\n                int setBitsInNum1 = countSetBits(num1), setBitsInNum2 = countSetBits(num2);\\n                if(setBitsInNum1 + setBitsInNum2 >= k){set.add(Arrays.asList(nums[index1],nums[index2]));}\\n            }\\n        }\\n        return (long)set.size();\\n    }\\n}\\n\\n// Brute Force Approach - TLE\\n// Time Complexity : O(n*n*number)\\n// Space Complexity : O(n*2)\\n```\n```\\nclass Solution {\\n\\n    // Brian Kernighan\\u2019s Algorithm\\n    private static int countSetBits(int number){\\n        int count = 0;\\n        while(number != 0){\\n            number = (number)&(number-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int index1=0;index1<nums.length;index1++){\\n            for(int index2=0;index2<nums.length;index2++){\\n                int num1 = nums[index1], num2 = nums[index2];\\n                int setBitsInNum1 = countSetBits(num1), setBitsInNum2 = countSetBits(num2);\\n                if(setBitsInNum1 + setBitsInNum2 >= k){set.add(Arrays.asList(nums[index1],nums[index2]));}\\n            }\\n        }\\n        return (long)set.size();\\n    }\\n}\\n\\n// Brute Force Approach - TLE\\n// Time Complexity : O(n*n*log(number))\\n// Space Complexity : O(n*2)\\n\\n```\n```\\nclass Solution {\\n\\n    // Brian Kernighan\\u2019s Algorithm\\n    private static int countSetBits(int number){\\n        int count = 0;\\n        while(number != 0){\\n            number = (number)&(number-1);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    private static int[] storeSetBits(int[] nums){\\n        int[] store = new int[nums.length];\\n        for(int index=0;index<nums.length;index++){store[index] = countSetBits(nums[index]);}\\n        return store;\\n    }\\n\\n    private static long twoSumAnalogy(int[] nums, int[] store, int target){\\n        Set<List<Integer>> set = new HashSet<>();\\n        for(int index1=0,len=store.length;index1<len;index1++){\\n            for(int index2=0;index2<len;index2++){\\n                if(store[index1] + store[index2] >= target){\\n                    set.add(Arrays.asList(nums[index1],nums[index2]));\\n                }\\n            }\\n        }\\n        return (long)set.size();\\n    }\\n\\n    public long countExcellentPairs(int[] nums, int k) {\\n        int[] store = new int[nums.length];\\n        store = storeSetBits(nums);\\n        return twoSumAnalogy(nums,store,k);\\n    }\\n}\\n\\n// Brute Force Approach - TLE\\n// Time Complexity : O(n*n*log(number))\\n// Space Complexity : O(n*2)\\n\\n```\n```\\nbits(num1 OR num2) + bits(num1 AND num2) = bits(num1) + bits(num2)\\n```\n```a```\n```nums```\n```k1```\n```k2```\n```k1 + k2 >= k```\n``` count[k1] * count[k2] ```\n```max(nums[i]) = 1e9```\n```[log2(number)] + 1```\n```log2(10^9) ~ 9*log2(10) ~ 9*3.322 ~ 29.8 => [29.8] + 1 = 30```\n```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long countArray[] = new long[30], count = 0;\\n        Set<Integer> set = new HashSet<>(); \\n        for(int num : nums) set.add(num);                                    // O(n)    \\n        for(int num : set) countArray[Integer.bitCount(num)]++;              // O(nlog(number))\\n        for(int bit=1;bit<30;bit++){\\n            for(int bit_=1;bit_<30;bit_++){\\n                if(bit+bit_>=k) count += countArray[bit]*countArray[bit_];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n// Counting Sort Optimized Code \\n// Time Complexity : O(n + nlog(number))\\n// Space Complexity : O(n) \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472142,
                "title": "python-solution-brute-force-optimized-o-n",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        n=len(nums)\\n        \\n        # Brute Force\\n        # s=set()\\n        # for i in range(n):\\n        #     for j in range(n):\\n        #         a=nums[i] | nums[j]\\n        #         b=nums[i] & nums[j]\\n        #         a_count=bin(a).count(\\'1\\')\\n        #         b_count=bin(b).count(\\'1\\')\\n        #         if a_count+b_count>=k and (nums[i], nums[j]) not in s:\\n        #             s.add((nums[i], nums[j]))\\n        #             count+=1\\n        # return count\\n        \\n        arr=[]\\n        for num in set(nums):\\n            arr.append(bin(num).count(\\'1\\'))\\n        arr.sort()\\n        l=0\\n        r=len(arr)-1\\n        ans=0\\n        while l<=r:\\n            if arr[l]+arr[r]>=k:\\n                ans+=(r-l)*2 + 1\\n                r-=1\\n            else:\\n                l+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        n=len(nums)\\n        \\n        # Brute Force\\n        # s=set()\\n        # for i in range(n):\\n        #     for j in range(n):\\n        #         a=nums[i] | nums[j]\\n        #         b=nums[i] & nums[j]\\n        #         a_count=bin(a).count(\\'1\\')\\n        #         b_count=bin(b).count(\\'1\\')\\n        #         if a_count+b_count>=k and (nums[i], nums[j]) not in s:\\n        #             s.add((nums[i], nums[j]))\\n        #             count+=1\\n        # return count\\n        \\n        arr=[]\\n        for num in set(nums):\\n            arr.append(bin(num).count(\\'1\\'))\\n        arr.sort()\\n        l=0\\n        r=len(arr)-1\\n        ans=0\\n        while l<=r:\\n            if arr[l]+arr[r]>=k:\\n                ans+=(r-l)*2 + 1\\n                r-=1\\n            else:\\n                l+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432888,
                "title": "python-3-lines",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums, k):\\n        b2n = [0] * 31\\n        for a in set(nums): b2n[bin(a).count(\\'1\\')] += 1\\n        return sum(b2n[i] * b2n[j] for i in range(31) for j in range(31) if i + j >= k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums, k):\\n        b2n = [0] * 31\\n        for a in set(nums): b2n[bin(a).count(\\'1\\')] += 1\\n        return sum(b2n[i] * b2n[j] for i in range(31) for j in range(31) if i + j >= k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368970,
                "title": "c-simple-c-code-o-nlogn-time-no-binary-search",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    long long int Count(int n)\\n    {\\n        long long int count = 0;\\n        while(n) \\n        {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> um;\\n        vector<int> sum;\\n        long long int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            um[nums[i]] = 1;\\n        }\\n        for(auto &[fst,_] : um)\\n        {\\n            sum.push_back(Count(fst));\\n        }\\n        sort(sum.begin(), sum.end());\\n        int i = 0, j = sum.size()-1;\\n        while(i <= j)\\n        {\\n            if(sum[i] + sum[j] >= k)\\n            {\\n                ans += 2*(j - i) + 1;\\n                j--;\\n            }\\n            else\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    long long int Count(int n)\\n    {\\n        long long int count = 0;\\n        while(n) \\n        {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int, int> um;\\n        vector<int> sum;\\n        long long int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            um[nums[i]] = 1;\\n        }\\n        for(auto &[fst,_] : um)\\n        {\\n            sum.push_back(Count(fst));\\n        }\\n        sort(sum.begin(), sum.end());\\n        int i = 0, j = sum.size()-1;\\n        while(i <= j)\\n        {\\n            if(sum[i] + sum[j] >= k)\\n            {\\n                ans += 2*(j - i) + 1;\\n                j--;\\n            }\\n            else\\n                i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367276,
                "title": "c-o-nlogn-solution",
                "content": "**I think to solve this question the most important thing was to observe that sum of \\n(A OR B) + (A AND B) will be equal to the sum of the set bit in (A)+ set bit in (B) and rest its simple.\\nOne more important thing is to remove the duplicates from the initial array at the starting only because if suppose we have array like ->[1,2,5,1]. In this case (1,2) and (2,1) both can be formed using indx 0 and 1 but the same 2 pairs can also be formed using index (1 and 3 ).\\nSo you need to take care of that.\\nOnce you find out their set bits counts then you just sort them and by using Binary search you can just count how many elements are their that can sum up with current element to form number greater than K.\\nAlso i have used vector and not set when i am storing the count of each distinct element that was present in initial array Nums ,this is because 2 distinct element can have same number of set bits and if i use set we would lost out one element so inorder to avoid this thing i have used vector.\\nCODE FOR THE FOLLOWING APPROACH**\\n\\n\\nclass Solution {\\npublic:\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int> s;\\n        vector<int> v;\\n\\t\\tfor(auto x: nums){        //Removing Duplicates using set\\n            s.insert(x);\\n        }\\n\\t\\t\\n        auto it=s.begin();\\n        while(it!=s.end()){\\n            int n=*it,cnt=0;\\n\\t\\t\\twhile(n>0){                //Finding count of set bit of the remaining distinct elements and storing them in vector\\n                if(n&1){\\n                    cnt++;\\n                }\\n                n=n>>1;\\n            }\\n            it++;\\n            v.push_back(cnt);\\n        }\\n\\t\\t\\n        long long ans=0;\\n        int sze=v.size();\\n\\t\\t\\n        sort(v.begin(),v.end());       //Sorting the count array(Set bits count)\\n        for(int i=0;i<sze;i++){\\n\\t\\t //Here Suppose k=3 and our current count is 2 then we need elements     \\n\\t\\t // having count atleast >=1 inorder to Fullfill the criteria given\\n\\t\\t \\n            int rem=k-v[i];          \\n            if(rem<=0){            \\n\\t\\t\\t //But Suppose we have a elements that has set bit greater than K \\n\\t\\t\\t in that case any element can make pair with him so we add whole array.\\n\\t\\t\\t \\n                ans+=sze;      \\n            }else{\\n                int idx=v.end()-lower_bound(v.begin(),v.end(),rem); //if that is not the case then we need \\n                ans+=idx;   // to find the least idx that can fullfill our criteria.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int> s;\\n        vector<int> v;\\n\\t\\tfor(auto x: nums){        //Removing Duplicates using set\\n            s.insert(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2341403,
                "title": "binary-search-o-nlogn-solution-using-bit-manipulation",
                "content": "First of all, remove the duplicates from the array, since we only want unique answers. We can use map or set to get unique elements. There is a property that the sum of the number of set bits in ```num1 | num2``` and ```num1 & num2``` is equal to the set bits in the sum of the two number.\\nFor example: if num1 = 4, num2 = 8 then the set bits in ```num1 | num2``` is 2 and set bits in ```num1 & num2``` is 0. The sum of the number num1 and num2, ```12``` also contains 2 + 0 set bits.\\nWe can use this property to solve the question optimally.\\n\\n Now, we make another array which contains set bits of the numbers. \\n If the given array was ```[1,2,3,1,536870911]```, then we can make another array ```[1,1,2,29]```. Now we will operate on this array only. We first sort the array. Then we can use binary search to find the lower bound of (k - nums[i]) to find the number of possible answer for that index. Below is the code.\\n \\n ```\\n class Solution {\\npublic:\\n\\t// Function to find number of set bits in a number\\n    int setBits(int n) {\\n        int count = 0;\\n        while (n) {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) {\\n            mp[nums[i]] = 1;\\n        }\\n        vector<int> realNums; // new array which contains set bits\\n        for(auto &it: mp) {\\n            realNums.push_back(setBits(it.first)); // store set bits\\n        }\\n        sort(realNums.begin(), realNums.end()); // sort the array to perform binary search\\n        long long ans = 0;\\n        for(int i=0;i<realNums.size();i++) {\\n            int curr = realNums[i];\\n\\t\\t\\t   int target = k - curr;\\n            int j = lower_bound(realNums.begin() + i, realNums.end(), target) - realNums.begin(); // find target in the right part of the array, we will not consider left part.\\n            long long total = realNums.size() - j; // total numbers lying on right part satisfying the condition\\n           // If the same number also satisfy the condition then we dont want to consider it twice\\n\\t\\t\\t   if(j == i) { \\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tif(total-1) {\\n\\t\\t\\t\\t\\t\\tans += 2 * (total-1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n            else {\\n                ans += 2*total; // (num1,num2) and (num2,num1) both possibility\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```num1 | num2```\n```num1 & num2```\n```num1 | num2```\n```num1 & num2```\n```12```\n```[1,2,3,1,536870911]```\n```[1,1,2,29]```\n```\\n class Solution {\\npublic:\\n\\t// Function to find number of set bits in a number\\n    int setBits(int n) {\\n        int count = 0;\\n        while (n) {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) {\\n            mp[nums[i]] = 1;\\n        }\\n        vector<int> realNums; // new array which contains set bits\\n        for(auto &it: mp) {\\n            realNums.push_back(setBits(it.first)); // store set bits\\n        }\\n        sort(realNums.begin(), realNums.end()); // sort the array to perform binary search\\n        long long ans = 0;\\n        for(int i=0;i<realNums.size();i++) {\\n            int curr = realNums[i];\\n\\t\\t\\t   int target = k - curr;\\n            int j = lower_bound(realNums.begin() + i, realNums.end(), target) - realNums.begin(); // find target in the right part of the array, we will not consider left part.\\n            long long total = realNums.size() - j; // total numbers lying on right part satisfying the condition\\n           // If the same number also satisfy the condition then we dont want to consider it twice\\n\\t\\t\\t   if(j == i) { \\n\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\tif(total-1) {\\n\\t\\t\\t\\t\\t\\tans += 2 * (total-1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n            else {\\n                ans += 2*total; // (num1,num2) and (num2,num1) both possibility\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2339986,
                "title": "c-using-stack-and-math-formula-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& a, int k) {\\n        int n = a.size();\\n        vector<long long> cnt;\\n        set<int> s;\\n        for(int i = 0; i < n; i++) s.insert(a[i]);\\n        for(auto i = s.begin(); i != s.end(); i++) {\\n            cnt.push_back(__builtin_popcount(*i));\\n        }\\n        sort(cnt.begin(), cnt.end(), greater<int>());\\n        stack<int> st;\\n        long long ans = 0;\\n        for(int i = 0; i < cnt.size(); i++) {\\n            while(!st.empty() && cnt[st.top()] + cnt[i] < k) st.pop();\\n            if(!st.empty()) ans += (1 + st.top()) * 2LL;\\n            if(2 * cnt[i] >= k) ans++;\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& a, int k) {\\n        int n = a.size();\\n        vector<long long> cnt;\\n        set<int> s;\\n        for(int i = 0; i < n; i++) s.insert(a[i]);\\n        for(auto i = s.begin(); i != s.end(); i++) {\\n            cnt.push_back(__builtin_popcount(*i));\\n        }\\n        sort(cnt.begin(), cnt.end(), greater<int>());\\n        stack<int> st;\\n        long long ans = 0;\\n        for(int i = 0; i < cnt.size(); i++) {\\n            while(!st.empty() && cnt[st.top()] + cnt[i] < k) st.pop();\\n            if(!st.empty()) ans += (1 + st.top()) * 2LL;\\n            if(2 * cnt[i] >= k) ans++;\\n            st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333308,
                "title": "java-short-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashMap<Integer, Long> map = new HashMap<>();\\n        \\n        long result = 0;\\n        HashSet<Integer> noDuplicate = new HashSet<>();\\n        ArrayList<Integer> newNums = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (noDuplicate.add(nums[i])) {\\n                newNums.add(nums[i]);\\n            }\\n        }\\n    \\n        for (Integer newNum : newNums) {\\n            int bits = getBits(newNum);\\n            long numbersHave = map.getOrDefault(bits, 0l);\\n            map.put(bits, numbersHave + 1);\\n        }\\n        long sum = 0;\\n    \\n        for (Integer newNum : newNums) {\\n            int bits = getBits(newNum);\\n            for (Integer key : map.keySet()) {\\n                if (key + bits >= k) sum += map.get(key);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int getBits(int i) {\\n        int count = 0;\\n        while (i > 0) {\\n            i = i & (i - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashMap<Integer, Long> map = new HashMap<>();\\n        \\n        long result = 0;\\n        HashSet<Integer> noDuplicate = new HashSet<>();\\n        ArrayList<Integer> newNums = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (noDuplicate.add(nums[i])) {\\n                newNums.add(nums[i]);\\n            }\\n        }\\n    \\n        for (Integer newNum : newNums) {\\n            int bits = getBits(newNum);\\n            long numbersHave = map.getOrDefault(bits, 0l);\\n            map.put(bits, numbersHave + 1);\\n        }\\n        long sum = 0;\\n    \\n        for (Integer newNum : newNums) {\\n            int bits = getBits(newNum);\\n            for (Integer key : map.keySet()) {\\n                if (key + bits >= k) sum += map.get(key);\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int getBits(int i) {\\n        int count = 0;\\n        while (i > 0) {\\n            i = i & (i - 1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327948,
                "title": "clean-solution-with-binary-search",
                "content": "Notice that:\\nnumber of set bits in (a OR b) and (a AND b) = number of set bits in a + number of set bits in b\\n```\\nclass Solution {\\n    func countExcellentPairs(_ nums: [Int], _ k: Int) -> Int {\\n        // distinct numbers\\n        let set = Set<Int>(nums)\\n        let n = set.count\\n        \\n        // store the number of `1` bit of each item in the set  \\n        var array = Array(repeating: 0, count: n) \\n        var i = 0\\n        for num in set {\\n            var num = num\\n            var count = 0\\n            while num > 0 {\\n                count += num & 1\\n                num = num >> 1\\n            }\\n            array[i] = count\\n            i += 1\\n        }\\n        \\n        var res = 0\\n        let sorted = array.sorted()\\n        for i in 0..<n {\\n            // Use binary search to find the index of the smallest number which satisfy the condition.\\n            var left = 0\\n            var right = n-1\\n            var id = -1\\n            while left <= right {\\n                let mid = left + (right - left) / 2\\n                if sorted[i] + sorted[mid] >= k {\\n                    id = mid\\n                    right = mid - 1\\n                } else {\\n                    left = mid + 1\\n                }\\n            }\\n            if id != -1 { // found the index\\n                res += n - id\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func countExcellentPairs(_ nums: [Int], _ k: Int) -> Int {\\n        // distinct numbers\\n        let set = Set<Int>(nums)\\n        let n = set.count\\n        \\n        // store the number of `1` bit of each item in the set  \\n        var array = Array(repeating: 0, count: n) \\n        var i = 0\\n        for num in set {\\n            var num = num\\n            var count = 0\\n            while num > 0 {\\n                count += num & 1\\n                num = num >> 1\\n            }\\n            array[i] = count\\n            i += 1\\n        }\\n        \\n        var res = 0\\n        let sorted = array.sorted()\\n        for i in 0..<n {\\n            // Use binary search to find the index of the smallest number which satisfy the condition.\\n            var left = 0\\n            var right = n-1\\n            var id = -1\\n            while left <= right {\\n                let mid = left + (right - left) / 2\\n                if sorted[i] + sorted[mid] >= k {\\n                    id = mid\\n                    right = mid - 1\\n                } else {\\n                    left = mid + 1\\n                }\\n            }\\n            if id != -1 { // found the index\\n                res += n - id\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327144,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting And Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for counting no. of set bits in num\\n    \\n    int find_set_bits(int num)\\n    {\\n        int count = 0;\\n        \\n        while(num)\\n        {\\n            count++;\\n            \\n            num = (num & (num - 1));\\n        }\\n        \\n        return count;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // make unique array, to avoid duplicates pairs\\n        \\n        vector<int> arr;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            while(i < n - 1 && nums[i] == nums[i + 1])\\n            {\\n                i++;\\n            }\\n            \\n            arr.push_back(nums[i]);\\n            \\n            i++;\\n        }\\n        \\n        // set_bit array will store the no. of set bits presents in arr[i]\\n       \\n        vector<int> set_bit;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            int count = find_set_bits(arr[i]);\\n           \\n            set_bit.push_back(count);\\n        }\\n        \\n        // sort the set_bit array\\n        \\n        sort(set_bit.begin(), set_bit.end());\\n        \\n        // find all the unique pairs\\n        \\n        long long count = 0;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            // no. of minimum set bits required, so that sum can be greater than k\\n            \\n            int need = k - set_bit[i];\\n            \\n            // upply lower bound on set_bits\\n            \\n            int idx = lower_bound(set_bit.begin(), set_bit.end(), need) - set_bit.begin();\\n            \\n            // update the count\\n            \\n            count += set_bit.size() - idx;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Bit Manipulation",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for counting no. of set bits in num\\n    \\n    int find_set_bits(int num)\\n    {\\n        int count = 0;\\n        \\n        while(num)\\n        {\\n            count++;\\n            \\n            num = (num & (num - 1));\\n        }\\n        \\n        return count;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // make unique array, to avoid duplicates pairs\\n        \\n        vector<int> arr;\\n        \\n        int i = 0;\\n        \\n        while(i < n)\\n        {\\n            while(i < n - 1 && nums[i] == nums[i + 1])\\n            {\\n                i++;\\n            }\\n            \\n            arr.push_back(nums[i]);\\n            \\n            i++;\\n        }\\n        \\n        // set_bit array will store the no. of set bits presents in arr[i]\\n       \\n        vector<int> set_bit;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            int count = find_set_bits(arr[i]);\\n           \\n            set_bit.push_back(count);\\n        }\\n        \\n        // sort the set_bit array\\n        \\n        sort(set_bit.begin(), set_bit.end());\\n        \\n        // find all the unique pairs\\n        \\n        long long count = 0;\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            // no. of minimum set bits required, so that sum can be greater than k\\n            \\n            int need = k - set_bit[i];\\n            \\n            // upply lower bound on set_bits\\n            \\n            int idx = lower_bound(set_bit.begin(), set_bit.end(), need) - set_bit.begin();\\n            \\n            // update the count\\n            \\n            count += set_bit.size() - idx;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326808,
                "title": "questions-are-not-hard-just-tricky-and-when-you-get-stuck-try-to-observe-pattern",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        for i in range(len(nums)):\\n            b=bin(nums[i])\\n            nums[i]=b.count(\"1\")\\n        nums.sort()\\n        count=0\\n        \\n        left=0\\n        right=len(nums)-1\\n       \\n        while(left<=right and right>=0):\\n            if nums[left]+nums[right]>=k:\\n                    count=count + (right-left)*2 +1\\n                    right-=1\\n            else:\\n                left+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums=list(set(nums))\\n        for i in range(len(nums)):\\n            b=bin(nums[i])\\n            nums[i]=b.count(\"1\")\\n        nums.sort()\\n        count=0\\n        \\n        left=0\\n        right=len(nums)-1\\n       \\n        while(left<=right and right>=0):\\n            if nums[left]+nums[right]>=k:\\n                    count=count + (right-left)*2 +1\\n                    right-=1\\n            else:\\n                left+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326260,
                "title": "explanation-with-pen-and-paper-for-beginners-c-binary-search",
                "content": "**The major problem in this question to see what will be the value of  and(a,b) + or(a,b)**\\nLet\\'s take a example and learn from it\\n\\nex =>\\n  ![image](https://assets.leetcode.com/users/images/e07845e3-e0a9-4601-8b8c-d19ec3560966_1658652424.4231122.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int setbits(int n) {\\n        int cnt = 0;\\n        while(n) {\\n            cnt += n&1;\\n            n = n >> 1;\\n        }\\n        return cnt;\\n    }\\n    \\n    \\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n\\t   // we are using set just to remove duplicates \\n        unordered_set<int> set;\\n        for(int& i : nums) {\\n            set.insert(i);\\n        }\\n        nums.clear();\\n        for(auto&it: set) nums.push_back(it);\\n        int n = nums.size();\\n\\t\\t// here i am not using any extra space for storing the setbits count for each value in the nums\\n        for(int i = 0; i < n ;i++) {\\n            nums[i] = setbits(nums[i]);\\n        }\\n\\t\\t// sorting the function because of lower_bound function\\n\\t\\t// if     nums[i] + any found number in nums >= k than we can definately say that \\n\\t\\t// all the number after this any found number in nums will also satisfy the condition\\n\\t\\t// so apply lower_bound there\\n        sort(nums.begin(), nums.end());          \\n        long long ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            ans += n-(lower_bound(nums.begin(), nums.end(), k-nums[i])-nums.begin());\\n        }\\n        return ans;\\n    }\\n};\\n```\\nif you have any doubts then ask me.\\nUpvote if you lilke my post.\\n\\n```\\nT.C. = O(nlogn)\\nSC = O(n)    because of set \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int setbits(int n) {\\n        int cnt = 0;\\n        while(n) {\\n            cnt += n&1;\\n            n = n >> 1;\\n        }\\n        return cnt;\\n    }\\n    \\n    \\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n\\t   // we are using set just to remove duplicates \\n        unordered_set<int> set;\\n        for(int& i : nums) {\\n            set.insert(i);\\n        }\\n        nums.clear();\\n        for(auto&it: set) nums.push_back(it);\\n        int n = nums.size();\\n\\t\\t// here i am not using any extra space for storing the setbits count for each value in the nums\\n        for(int i = 0; i < n ;i++) {\\n            nums[i] = setbits(nums[i]);\\n        }\\n\\t\\t// sorting the function because of lower_bound function\\n\\t\\t// if     nums[i] + any found number in nums >= k than we can definately say that \\n\\t\\t// all the number after this any found number in nums will also satisfy the condition\\n\\t\\t// so apply lower_bound there\\n        sort(nums.begin(), nums.end());          \\n        long long ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            ans += n-(lower_bound(nums.begin(), nums.end(), k-nums[i])-nums.begin());\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nT.C. = O(nlogn)\\nSC = O(n)    because of set \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326101,
                "title": "c-easy-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     long long countSetBits(long long n)\\n    {\\n        long long count = 0;\\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n         \\n        return count;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n        auto ip = unique(nums.begin(), nums.end());  \\n        nums.resize(distance(nums.begin(), ip));\\n\\t\\t//  It removes all the adjacent similar elements from the vector giving us the distinct elements. (make sure to sort first).\\n         \\n     \\n        vector<int> vec;\\n        long long n = nums.size();\\n        for (long long i = 0 ; i < n ; i++){\\n            vec.push_back(countSetBits(nums[i])); // count set bits in each element.\\n        }\\n        \\n        sort(vec.begin(), vec.end()); \\n        \\n        long long result = 0;\\n        n = vec.size();\\n        \\n        for (long long i = 0; i < vec.size() ; i++){\\n            long long val = vec[i];\\n            \\n            long long idx = lower_bound(vec.begin(), vec.end(), max(k - val, 0LL)) - vec.begin();  \\n\\t\\t\\t// max(k - val, 0LL))  to handle values that are greater than k hence total no. of pairs they can make is from index 0 to all values till n.\\n            \\n\\t\\t\\tresult += n - idx;\\n\\t\\t\\t// adding total pairs that single value can make. \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long countSetBits(long long n)\\n    {\\n        long long count = 0;\\n        while (n) {\\n            n &= (n - 1);\\n            count++;\\n        }\\n         \\n        return count;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(), nums.end());\\n\\t\\t\\n        auto ip = unique(nums.begin(), nums.end());  \\n        nums.resize(distance(nums.begin(), ip));\\n\\t\\t//  It removes all the adjacent similar elements from the vector giving us the distinct elements. (make sure to sort first).\\n         \\n     \\n        vector<int> vec;\\n        long long n = nums.size();\\n        for (long long i = 0 ; i < n ; i++){\\n            vec.push_back(countSetBits(nums[i])); // count set bits in each element.\\n        }\\n        \\n        sort(vec.begin(), vec.end()); \\n        \\n        long long result = 0;\\n        n = vec.size();\\n        \\n        for (long long i = 0; i < vec.size() ; i++){\\n            long long val = vec[i];\\n            \\n            long long idx = lower_bound(vec.begin(), vec.end(), max(k - val, 0LL)) - vec.begin();  \\n\\t\\t\\t// max(k - val, 0LL))  to handle values that are greater than k hence total no. of pairs they can make is from index 0 to all values till n.\\n            \\n\\t\\t\\tresult += n - idx;\\n\\t\\t\\t// adding total pairs that single value can make. \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326062,
                "title": "c-set-bits-easy-to-understand",
                "content": "Intuition\\nThe Inclusion-Exclusion Principle\\nbits(num1 OR num2) + bits(num1 AND num2) = bits(num1) + bits(num2)\\n\\n\\nExplanation\\nFor all different a in nums,\\ncounts its number of bits.\\n\\nEnumearte the number of bits k1 and k2,\\nif k1 + k2 >= k,\\nwe accumulate count[k1] * count[k2].\\n\\nCode  :\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long cnt[30] = {};\\n\\t\\t\\n        long long ans = 0;\\n        \\n        for(int it:unordered_set<int> (begin(nums),end(nums)))\\n\\t\\t{\\n            ++cnt[__builtin_popcount(it)];\\n        }\\n        \\n        for(int i=1;i<30;i++){\\n            for(int j=1;j<30;j++)\\n            {\\n                if(i + j >= k)\\n                {\\n                    ans += cnt[i]*cnt[j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nComplexity\\nTime O(nlogn)\\nSpace O(n)\\n\\n**Upvote if you like the solution**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long cnt[30] = {};\\n\\t\\t\\n        long long ans = 0;\\n        \\n        for(int it:unordered_set<int> (begin(nums),end(nums)))\\n\\t\\t{\\n            ++cnt[__builtin_popcount(it)];\\n        }\\n        \\n        for(int i=1;i<30;i++){\\n            for(int j=1;j<30;j++)\\n            {\\n                if(i + j >= k)\\n                {\\n                    ans += cnt[i]*cnt[j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325758,
                "title": "java-solution-using-inclusion-exclusion-principle-and-map",
                "content": "**Inclusion Exclusion Priniciple**\\n*setBits(A&B)+setBits(A|B) = setBits(A) + setBits(B)*\\nThis is the basic principle which will be used to solve the problem.\\nWe will store the quantity of different number of set bits obtained from the given array of numbers. The only remaining catch is that we must avoid increasing the set bits count for duplicate elements in the array.\\nThe data will be stored in a map and we will keep adding the transversed elements in a set and we will only increase the count if and only if the element is not present in the set.\\nAt last we will traverse through the different key sets of the map and we will check the pairs where the sum of keys is greater than equal to k.\\n\\n**TC: O(n)**\\n```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0;i<nums.length;i++){\\n            int bitCounts = Integer.bitCount(nums[i]);\\n            if(!set.contains(nums[i])&&map.containsKey(bitCounts)){\\n                set.add(nums[i]);\\n                map.put(bitCounts, map.get(bitCounts)+1);\\n            }\\n            else{\\n                if(!set.contains(nums[i])){\\n                    map.put(bitCounts, 1);\\n                    set.add(nums[i]);\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for(int i: map.keySet()){\\n            for(int j : map.keySet()){\\n                if(i+j>=k){\\n                    ans+=map.get(i)*map.get(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        Set<Integer> set = new HashSet<>();\\n        for(int i = 0;i<nums.length;i++){\\n            int bitCounts = Integer.bitCount(nums[i]);\\n            if(!set.contains(nums[i])&&map.containsKey(bitCounts)){\\n                set.add(nums[i]);\\n                map.put(bitCounts, map.get(bitCounts)+1);\\n            }\\n            else{\\n                if(!set.contains(nums[i])){\\n                    map.put(bitCounts, 1);\\n                    set.add(nums[i]);\\n                }\\n            }\\n        }\\n        long ans = 0;\\n        for(int i: map.keySet()){\\n            for(int j : map.keySet()){\\n                if(i+j>=k){\\n                    ans+=map.get(i)*map.get(j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325735,
                "title": "simple-solution-binary-search",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long countExcellentPairs(vector<int>& v, int k) {\\n\\t\\t\\tsort(v.begin(),v.end());\\n\\t\\t\\tv.resize(unique(v.begin(),v.end())-v.begin());\\n\\t\\t\\tint n=v.size();\\n\\t\\t\\tvector<int> t(n);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tt[i] = __builtin_popcount(v[i]);\\n\\t\\t\\t}\\n\\t\\t\\tsort(t.begin(),t.end());\\n\\t\\t\\tlong long cnt=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint res=(lower_bound(t.begin(),t.end(), k-t[i]) - t.begin());\\n\\t\\t\\t\\tcnt +=n - res;\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long countExcellentPairs(vector<int>& v, int k) {\\n\\t\\t\\tsort(v.begin(),v.end());\\n\\t\\t\\tv.resize(unique(v.begin(),v.end())-v.begin());\\n\\t\\t\\tint n=v.size();\\n\\t\\t\\tvector<int> t(n);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tt[i] = __builtin_popcount(v[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2325541,
                "title": "javascript-bit-count-242ms",
                "content": "```\\nconst bitCount = (n) => { n = n - ((n >> 1) & 0x55555555); n = (n & 0x33333333) + ((n >> 2) & 0x33333333); return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24; };\\n\\nconst countExcellentPairs = (a, k) => {\\n    let u = [...new Set(a)], f = Array(30).fill(0), res = 0;\\n    for (const x of u) {\\n        let cnt = bitCount(x);\\n        f[cnt]++;\\n    }\\n    for (let i = 0; i < 30; i++) {\\n        for (let j = 0; j < 30; j++) {\\n            if (i + j >= k) res += f[i] * f[j];\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst bitCount = (n) => { n = n - ((n >> 1) & 0x55555555); n = (n & 0x33333333) + ((n >> 2) & 0x33333333); return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24; };\\n\\nconst countExcellentPairs = (a, k) => {\\n    let u = [...new Set(a)], f = Array(30).fill(0), res = 0;\\n    for (const x of u) {\\n        let cnt = bitCount(x);\\n        f[cnt]++;\\n    }\\n    for (let i = 0; i < 30; i++) {\\n        for (let j = 0; j < 30; j++) {\\n            if (i + j >= k) res += f[i] * f[j];\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325486,
                "title": "c-two-sum-variation",
                "content": "```\\nonly important thing to observe is \\n(number of set bit of (A & B) )+(number of set bit of (A | B))= number of set bit in A +number of set bit in B\\nbecause\\nA&B=common set_bit in A and  B (let say X)\\nA|B =number of set bit in A + number of set bit in B - common set_bit in A and B(X) \\n after adding these\\n A&B +A|B =number of set bit in A + number of set bit in B + X - X \\n A&B +A|B=number of set bit in A + number of set bit in B \\n \\n```\\n \\n```\\n \\n \\n class Solution {\\npublic:\\n    int num_set_bit(int num)\\n    {\\n        int cnt=0;\\n        while(num)\\n        {\\n            if(num&1)\\n            {\\n                cnt++;\\n            }\\n            num=num>>1;\\n        }\\n        return cnt;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int>v;\\n        set<pair<int,int>>s;\\n        for(auto x:nums)\\n        {\\n            int val=num_set_bit(x);\\n            if(s.find({val,x})==s.end())\\n            {\\n                s.insert({val,x});\\n                v.push_back(val);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        // (a+b>=k)\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int x=k-v[i];\\n            auto it=lower_bound(v.begin(),v.end(),x);\\n            if(it!=v.end())\\n            {\\n                int idx=it-v.begin();\\n                ans+=(v.size()-idx)*1LL;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nonly important thing to observe is \\n(number of set bit of (A & B) )+(number of set bit of (A | B))= number of set bit in A +number of set bit in B\\nbecause\\nA&B=common set_bit in A and  B (let say X)\\nA|B =number of set bit in A + number of set bit in B - common set_bit in A and B(X) \\n after adding these\\n A&B +A|B =number of set bit in A + number of set bit in B + X - X \\n A&B +A|B=number of set bit in A + number of set bit in B \\n \\n```\n```\\n \\n \\n class Solution {\\npublic:\\n    int num_set_bit(int num)\\n    {\\n        int cnt=0;\\n        while(num)\\n        {\\n            if(num&1)\\n            {\\n                cnt++;\\n            }\\n            num=num>>1;\\n        }\\n        return cnt;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int>v;\\n        set<pair<int,int>>s;\\n        for(auto x:nums)\\n        {\\n            int val=num_set_bit(x);\\n            if(s.find({val,x})==s.end())\\n            {\\n                s.insert({val,x});\\n                v.push_back(val);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        // (a+b>=k)\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int x=k-v[i];\\n            auto it=lower_bound(v.begin(),v.end(),x);\\n            if(it!=v.end())\\n            {\\n                int idx=it-v.begin();\\n                ans+=(v.size()-idx)*1LL;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325367,
                "title": "java-easy-and-understandable-solution-bit-manipulation-binary-search",
                "content": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int n: nums) set.add(n);\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int n: set){\\n            list.add(getBitCount(n));\\n        }\\n        Collections.sort(list);\\n        long res = 0;\\n        for(int i = 0; i< list.size(); i++){\\n            int lo = i, hi = list.size()-1;\\n            long cur = list.size();\\n            while(lo <= hi){\\n                int md = lo + (hi - lo)/2;\\n                if(list.get(md) + list.get(i) >=k){\\n                    cur = md;\\n                    hi = md - 1;\\n                }else{\\n                    lo = md + 1;\\n                }\\n            }\\n            res += 2 * (list.size() - cur);\\n            if(i == cur) res -= 1;\\n        }\\n        return res;\\n    }\\n    \\n    private int getBitCount(int n){\\n        int count = 0;\\n        while(n!=0){\\n            count += (n&1);\\n            n>>=1;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Bit Manipulation",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int n: nums) set.add(n);\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int n: set){\\n            list.add(getBitCount(n));\\n        }\\n        Collections.sort(list);\\n        long res = 0;\\n        for(int i = 0; i< list.size(); i++){\\n            int lo = i, hi = list.size()-1;\\n            long cur = list.size();\\n            while(lo <= hi){\\n                int md = lo + (hi - lo)/2;\\n                if(list.get(md) + list.get(i) >=k){\\n                    cur = md;\\n                    hi = md - 1;\\n                }else{\\n                    lo = md + 1;\\n                }\\n            }\\n            res += 2 * (list.size() - cur);\\n            if(i == cur) res -= 1;\\n        }\\n        return res;\\n    }\\n    \\n    private int getBitCount(int n){\\n        int count = 0;\\n        while(n!=0){\\n            count += (n&1);\\n            n>>=1;\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325234,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long[] arr = new long[33];\\n        Set<Integer> visited = new HashSet();\\n        for(int i : nums) {\\n            int count = 0;\\n            if(visited.contains(i)) {\\n                continue;\\n            }\\n            \\n            visited.add(i);\\n            while(i > 0) {\\n                if((i&1) == 1) {\\n                    count++;\\n                }\\n                i >>= 1;\\n            }\\n            arr[count]++;\\n        }\\n        \\n        long res = 0;\\n        for(int i=1; i<arr.length; i++) {\\n            int j = Math.max(k-i,1);\\n            for(; j<arr.length; j++) {\\n                res += arr[i]*arr[j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long[] arr = new long[33];\\n        Set<Integer> visited = new HashSet();\\n        for(int i : nums) {\\n            int count = 0;\\n            if(visited.contains(i)) {\\n                continue;\\n            }\\n            \\n            visited.add(i);\\n            while(i > 0) {\\n                if((i&1) == 1) {\\n                    count++;\\n                }\\n                i >>= 1;\\n            }\\n            arr[count]++;\\n        }\\n        \\n        long res = 0;\\n        for(int i=1; i<arr.length; i++) {\\n            int j = Math.max(k-i,1);\\n            for(; j<arr.length; j++) {\\n                res += arr[i]*arr[j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325169,
                "title": "nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        vector<int> v;\\n        for(auto& i: s){\\n            int x = __builtin_popcountll(i);\\n            v.push_back(x);\\n        }\\n        sort(v.begin(),v.end());//1 1 2\\n        \\n        long long ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            auto it = lower_bound(v.begin(),v.end(),k-v[i]);\\n            // all values including the it and after satisfies the condition\\n            ans += (v.end()-it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        vector<int> v;\\n        for(auto& i: s){\\n            int x = __builtin_popcountll(i);\\n            v.push_back(x);\\n        }\\n        sort(v.begin(),v.end());//1 1 2\\n        \\n        long long ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            auto it = lower_bound(v.begin(),v.end(),k-v[i]);\\n            // all values including the it and after satisfies the condition\\n            ans += (v.end()-it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325168,
                "title": "c-count",
                "content": "```\\n    public long CountExcellentPairs(int[] nums, int k)\\n    {\\n        long[] count = new long[30];\\n        foreach (int num in nums.Distinct())\\n        {\\n            int onesCount = Convert.ToString(num, 2).Count(a => a == \\'1\\');\\n            count[onesCount]++;\\n        }\\n\\n        long result = 0;\\n        for (int i = 1; i < 30; ++i)\\n            for (int j = 1; j < 30; ++j)\\n                if (i + j >= k)\\n                    result += count[i] * count[j];\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long CountExcellentPairs(int[] nums, int k)\\n    {\\n        long[] count = new long[30];\\n        foreach (int num in nums.Distinct())\\n        {\\n            int onesCount = Convert.ToString(num, 2).Count(a => a == \\'1\\');\\n            count[onesCount]++;\\n        }\\n\\n        long result = 0;\\n        for (int i = 1; i < 30; ++i)\\n            for (int j = 1; j < 30; ++j)\\n                if (i + j >= k)\\n                    result += count[i] * count[j];\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325137,
                "title": "easy-c-set-count-set-bits-sort-o-nlogn",
                "content": "OR + AND is basically sum of count bits of a and b;\\n(a OR b) = count(a) + count(b) - count(common(a,b)\\n(a AND b) = count(common(a,b)\\n\\nTherefore, (a OR b) + (a AND b) = count(a) + count(b)\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll countSetBits(ll n) {\\n    if (n == 0)\\n        return 0;\\n    else\\n        return 1 + countSetBits(n & (n - 1));\\n    }\\n    \\n    ll countExcellentPairs(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n        \\n        set<ll> vis;\\n        vector<ll> v;\\n        \\n        for(ll i=0;i<n;i++){\\n            // count set bits of unique elements and push it into vector\\n            if(vis.find(nums[i]) == vis.end()){\\n                vis.insert(nums[i]);\\n                ll x = countSetBits(nums[i]);\\n                v.push_back(x);\\n            }\\n        }\\n        \\n        // sort the vector\\n        sort(v.begin(), v.end());\\n        \\n        // stores final answer\\n        ll cnt = 0;\\n        \\n        ll m = v.size();\\n        \\n        for(int i=0;i<m;i++){\\n            ll x = v[i];\\n            \\n            // if set bits is >= k\\n            if(x >= k){\\n                // for current take 1 and for rest 2 {(3,3) - 1}, {(2,3), (3,2)} - 2\\n                ll a = m - i - 1;\\n                cnt += (2*a+1);\\n            } else {\\n                ll rem = k-x;\\n                ll y = lower_bound(v.begin()+i, v.end(), rem) - v.begin();\\n                \\n                if(y == i){\\n                    ll a = m-y-1;\\n                    cnt += (2*a + 1);\\n                    \\n                } else {\\n                    ll a = m-y;\\n                    cnt += (2*a);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll countSetBits(ll n) {\\n    if (n == 0)\\n        return 0;\\n    else\\n        return 1 + countSetBits(n & (n - 1));\\n    }\\n    \\n    ll countExcellentPairs(vector<int>& nums, int k) {\\n        ll n = nums.size();\\n        \\n        set<ll> vis;\\n        vector<ll> v;\\n        \\n        for(ll i=0;i<n;i++){\\n            // count set bits of unique elements and push it into vector\\n            if(vis.find(nums[i]) == vis.end()){\\n                vis.insert(nums[i]);\\n                ll x = countSetBits(nums[i]);\\n                v.push_back(x);\\n            }\\n        }\\n        \\n        // sort the vector\\n        sort(v.begin(), v.end());\\n        \\n        // stores final answer\\n        ll cnt = 0;\\n        \\n        ll m = v.size();\\n        \\n        for(int i=0;i<m;i++){\\n            ll x = v[i];\\n            \\n            // if set bits is >= k\\n            if(x >= k){\\n                // for current take 1 and for rest 2 {(3,3) - 1}, {(2,3), (3,2)} - 2\\n                ll a = m - i - 1;\\n                cnt += (2*a+1);\\n            } else {\\n                ll rem = k-x;\\n                ll y = lower_bound(v.begin()+i, v.end(), rem) - v.begin();\\n                \\n                if(y == i){\\n                    ll a = m-y-1;\\n                    cnt += (2*a + 1);\\n                    \\n                } else {\\n                    ll a = m-y;\\n                    cnt += (2*a);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325038,
                "title": "simple-java-solution-with-explanation-bitwise-operator-equation",
                "content": "```\\nclass Solution {\\n    \\n    Map<Integer, Integer> setBitsDP = new HashMap<>();\\n    \\n    public long countExcellentPairs(int[] nums, int k) {\\n        \\n        /*\\n        countSetBits(a & b) = count set bits of a + count set bits of b - common set bits between a and b\\n        countSetBits(a | b) = common set bits between a and b\\n        countSetBits(a & b) + countSetBits(a | b) = countSetBits(a) + countSetBits(b)\\n        */\\n        Map<Integer, Set<Integer>> container = new HashMap<>();\\n        for (int num : nums) {\\n            int currCount = Integer.bitCount(num);\\n            container.putIfAbsent(currCount, new HashSet<>());\\n            container.get(currCount).add(num);\\n        }\\n        \\n        // since Integer is 32 bits\\n        long ans = 0;\\n        for (int i = 1; i < 32; i++) {\\n            for (int j = i; j < 32; j++) {\\n                if (container.containsKey(i) && container.containsKey(j) && (i + j) >= k) {\\n                    if (i == j) {\\n\\t\\t\\t\\t\\t    // count only once like (3, 3)\\n                        ans += (long)(container.get(i).size() * container.get(j).size());\\n                    } else {\\n                        // both ways permutation like (1, 2) and (2, 1)\\n                        ans += (long)(container.get(i).size() * container.get(j).size() * 2);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, Integer> setBitsDP = new HashMap<>();\\n    \\n    public long countExcellentPairs(int[] nums, int k) {\\n        \\n        /*\\n        countSetBits(a & b) = count set bits of a + count set bits of b - common set bits between a and b\\n        countSetBits(a | b) = common set bits between a and b\\n        countSetBits(a & b) + countSetBits(a | b) = countSetBits(a) + countSetBits(b)\\n        */\\n        Map<Integer, Set<Integer>> container = new HashMap<>();\\n        for (int num : nums) {\\n            int currCount = Integer.bitCount(num);\\n            container.putIfAbsent(currCount, new HashSet<>());\\n            container.get(currCount).add(num);\\n        }\\n        \\n        // since Integer is 32 bits\\n        long ans = 0;\\n        for (int i = 1; i < 32; i++) {\\n            for (int j = i; j < 32; j++) {\\n                if (container.containsKey(i) && container.containsKey(j) && (i + j) >= k) {\\n                    if (i == j) {\\n\\t\\t\\t\\t\\t    // count only once like (3, 3)\\n                        ans += (long)(container.get(i).size() * container.get(j).size());\\n                    } else {\\n                        // both ways permutation like (1, 2) and (2, 1)\\n                        ans += (long)(container.get(i).size() * container.get(j).size() * 2);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325011,
                "title": "java-count-set-ones-sort-binarysearch-nlogn",
                "content": "```\\nclass Solution {\\n  public long countExcellentPairs(int[] nums, int k) {\\n    int n = nums.length;\\n\\n    HashSet<Integer> set = new HashSet<>();\\n    for (int i = n - 1; i >= 0; i--) set.add(nums[i]);\\n\\n    n = set.size();\\n    int[] dist = new int[n];\\n    int i = 0;\\n    for (int next : set) dist[i++] = Integer.bitCount(next);\\n\\n    Arrays.sort(dist);\\n    long ans = 0;\\n\\n    for (i = 0; i < n; i++) {\\n      int ind = bsearch(dist, k - dist[i]);\\n\\n      if (ind >= 0) ans += (n - ind + 0l);\\n    }\\n\\n    return ans;\\n  }\\n\\n  public int bsearch(int[] d, int t) {\\n    int l = 0;\\n    int r = d.length - 1;\\n    int ans = -1;\\n    while (l <= r) {\\n      int mid = (l + r) / 2;\\n\\n      if (d[mid] < t)\\n        l = mid + 1;\\n      else {\\n        ans = mid;\\n        r = mid - 1;\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  public long countExcellentPairs(int[] nums, int k) {\\n    int n = nums.length;\\n\\n    HashSet<Integer> set = new HashSet<>();\\n    for (int i = n - 1; i >= 0; i--) set.add(nums[i]);\\n\\n    n = set.size();\\n    int[] dist = new int[n];\\n    int i = 0;\\n    for (int next : set) dist[i++] = Integer.bitCount(next);\\n\\n    Arrays.sort(dist);\\n    long ans = 0;\\n\\n    for (i = 0; i < n; i++) {\\n      int ind = bsearch(dist, k - dist[i]);\\n\\n      if (ind >= 0) ans += (n - ind + 0l);\\n    }\\n\\n    return ans;\\n  }\\n\\n  public int bsearch(int[] d, int t) {\\n    int l = 0;\\n    int r = d.length - 1;\\n    int ans = -1;\\n    while (l <= r) {\\n      int mid = (l + r) / 2;\\n\\n      if (d[mid] < t)\\n        l = mid + 1;\\n      else {\\n        ans = mid;\\n        r = mid - 1;\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324816,
                "title": "python3-sum-of-set-bits",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/d61cd3ed09bbf59fd619802a6e861a516ec17094) for solutions of weekly 303. \\n\\nThe key info of this problem is that the sum of set bits of `x or y` and `x and y` is the the sum of set bits of `x` and `y`. With that this can be solved efficiently via freq array and prefix sum array. \\n\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums = set(nums)\\n        freq = [0]*30\\n        for x in nums: freq[bin(x).count(\\'1\\')] += 1\\n        prefix = list(accumulate(freq, initial=0))\\n        ans = 0 \\n        for x in nums: \\n            bits = bin(x).count(\\'1\\')\\n            lo = min(30, max(0, k-bits))\\n            ans += prefix[-1] - prefix[lo]\\n        return ans \\n```\\n\\nBased on @lee215\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        freq = Counter(map(int.bit_count, set(nums)))\\n        return sum(v1*v2 for k1, v1 in freq.items() for k2, v2 in freq.items() if k1+k2 >= k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums = set(nums)\\n        freq = [0]*30\\n        for x in nums: freq[bin(x).count(\\'1\\')] += 1\\n        prefix = list(accumulate(freq, initial=0))\\n        ans = 0 \\n        for x in nums: \\n            bits = bin(x).count(\\'1\\')\\n            lo = min(30, max(0, k-bits))\\n            ans += prefix[-1] - prefix[lo]\\n        return ans \\n```\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        freq = Counter(map(int.bit_count, set(nums)))\\n        return sum(v1*v2 for k1, v1 in freq.items() for k2, v2 in freq.items() if k1+k2 >= k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324815,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> v;\\n        set<int> st;\\n        for(int &x:nums)\\n        {\\n            st.insert(x);\\n        }\\n        ll ans=0;\\n        for(auto it=st.begin();it!=st.end();it++)\\n        {\\n            int c=0;\\n            int num=*it;\\n            for(int j=0;j<32;j++)\\n            {\\n                if(num&(1<<j))\\n                {\\n                    c++;\\n                }\\n            }\\n            if(2*c>=k)\\n            {\\n                ans++;\\n            }\\n            v.push_back(c);\\n        }\\n        sort(v.begin(),v.end());\\n        ll i,j;\\n        i=0;\\n        j=v.size()-1;\\n        while(i<j)\\n        {\\n            if(v[i]+v[j]<k)\\n            {\\n                i++;\\n                continue;\\n            }\\n            ans+=2*1ll*(j-i);\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> v;\\n        set<int> st;\\n        for(int &x:nums)\\n        {\\n            st.insert(x);\\n        }\\n        ll ans=0;\\n        for(auto it=st.begin();it!=st.end();it++)\\n        {\\n            int c=0;\\n            int num=*it;\\n            for(int j=0;j<32;j++)\\n            {\\n                if(num&(1<<j))\\n                {\\n                    c++;\\n                }\\n            }\\n            if(2*c>=k)\\n            {\\n                ans++;\\n            }\\n            v.push_back(c);\\n        }\\n        sort(v.begin(),v.end());\\n        ll i,j;\\n        i=0;\\n        j=v.size()-1;\\n        while(i<j)\\n        {\\n            if(v[i]+v[j]<k)\\n            {\\n                i++;\\n                continue;\\n            }\\n            ans+=2*1ll*(j-i);\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324813,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> s;\\n        unordered_set<int> p;\\n        long long ans = 0ll;\\n        for (auto n : nums) {\\n            if (p.find(n) == p.end())\\n                s.push_back(__builtin_popcount(n));\\n            p.insert(n);\\n        }\\n        sort(s.begin(), s.end());\\n        for (auto n : s) {\\n            ans += s.size() - (lower_bound(s.begin(), s.end(), k-n) - s.begin());\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> s;\\n        unordered_set<int> p;\\n        long long ans = 0ll;\\n        for (auto n : nums) {\\n            if (p.find(n) == p.end())\\n                s.push_back(__builtin_popcount(n));\\n            p.insert(n);\\n        }\\n        sort(s.begin(), s.end());\\n        for (auto n : s) {\\n            ans += s.size() - (lower_bound(s.begin(), s.end(), k-n) - s.begin());\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324712,
                "title": "python-5-lines-with-explanations",
                "content": "Important logic: **number_set_bit(X&Y)+number_set_bit(X|Y) = number_set_bit(X) + number_set_bit(Y)**\\n\\nFor example:\\nX = 010101\\nY = 010011\\nnumber_set_bit(X&Y) = number_set_bit(010001) = 2\\nnumber_set_bit(X&Y) = number_set_bit(010111) = 4\\nnumber_set_bit(X) = 3\\nnumber_set_bit(Y) = 3\\n\\nThe reason is **and** will count \"both 1 in same loc\" once.\\n**or** will count number of **and** plus \"each single 1\" once.\\n\\n\\n```\\n        x = sorted([bin(v).count(\"1\") for v in set(nums)])\\n\\t\\t\\n        res = 0\\n        for v in x:\\n            res += len(x) - bisect.bisect_left(x, k-v)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n        x = sorted([bin(v).count(\"1\") for v in set(nums)])\\n\\t\\t\\n        res = 0\\n        for v in x:\\n            res += len(x) - bisect.bisect_left(x, k-v)\\n        \\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324680,
                "title": "c-prefix-sum-solution-o-n",
                "content": "```C++\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& A, int k) {\\n        unordered_map<int, int> pcnt;\\n        vector<int> psum(66);\\n        for(auto& a : A) pcnt[a] = __builtin_popcount(a);\\n        for(auto [_,v] : pcnt) psum[v] += 1;\\n        for(int i = 1; i < 66; i++) psum[i] += psum[i-1];\\n\\n        long long res = 0;\\n        for(auto [me, cnt] : pcnt) {\\n            res += psum.back() - psum[max(k-cnt-1,0)];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& A, int k) {\\n        unordered_map<int, int> pcnt;\\n        vector<int> psum(66);\\n        for(auto& a : A) pcnt[a] = __builtin_popcount(a);\\n        for(auto [_,v] : pcnt) psum[v] += 1;\\n        for(int i = 1; i < 66; i++) psum[i] += psum[i-1];\\n\\n        long long res = 0;\\n        for(auto [me, cnt] : pcnt) {\\n            res += psum.back() - psum[max(k-cnt-1,0)];\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078015,
                "title": "o-n-log-n-solution-in-python-only-2-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is very easy if you observe the property of `num1 AND num2` + `num1 OR num2` = `num1 + num2`. With this knowledge, this problem is surprisingly easy to find all pairs of numbers that the sum of their set bits >= `k`, very similar to the first Leetcode problem [Two Sum](https://leetcode.com/problems/two-sum/)!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the numbers by their set bits and do binary search (or two points if you like) to find the number of pairs with the sum >= `k`.\\n\\n# Complexity\\n- Time complexity: $$O(N \\\\log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Additional space is only $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums = sorted([x.bit_count() for x in set(nums)])\\n        return sum(len(nums) - bisect_left(nums, k-x) for x in nums)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums = sorted([x.bit_count() for x in set(nums)])\\n        return sum(len(nums) - bisect_left(nums, k-x) for x in nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051752,
                "title": "two-pointer-approach-c-python-easy-understanding",
                "content": "# Intuition\\nThe problem asks to find the number of unique pairs of numbers such that the sum of set bits in the OR of the numbers in the pair and the AND of the numbers in the pair is greater than or equal to k.\\nNow after some playing around with some small pairs we can conclude that \\n1. The number of set bits in OR is\\n    n1=(set bits in the first number)+(set bits in the second number)-\\n    (set bits in both the numbers)\\n2. The  number of set bits in AND is\\n    n2=(number of common set bits)\\n3. So n1+n2=(set bits in the first number)+(set bits in the second number)\\nEg:\\n(2,3)\\n10 OR 11=11\\n10 AND 11=10\\nTotal =3 (sum of set bits in 2 and 3)\\n\\n\\n# Approach\\nI found the unique elements in the array. Then found the bit count of every element. Sorted the bitcounts. Then used two pointers to find the number of pairs whose sum is greater than or equal to k. It can also be done using binary search.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity:O(n)\\n\\n# Code`\\n```C++ []\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int bitcount(int n) //find the bitcount\\n    {\\n        int count=0;\\n\\n        while(n)\\n        {\\n            count++;\\n            n=n&(n-1);\\n        }\\n        return count;\\n    }\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        ll ans=0;\\n        set<int>s;\\n        for(auto i:nums) //unique elements\\n        {\\n            s.insert(i);\\n        }\\n        \\n        vector<int>a; //to store the bitcounts\\n        for(auto it:s)\\n        {\\n            a.push_back(bitcount(it));\\n        }\\n        sort(a.begin(),a.end());\\n\\n        int l=0;\\n        int r=a.size()-1;\\n\\n       \\n        while(l<=r)//find the number of pairs\\n        {\\n            if(a[l]+a[r]<k)\\n            {\\n                l++;\\n            }\\n            else {\\n                ans+=2*(r-l)+1;\\n                r--;\\n                l=0;\\n            }\\n        }\\n```\\n```Python []\\nclass Solution:\\n    def bitcount(self, n):\\n        count = 0\\n        while n:\\n            count += 1\\n            n = n & (n - 1)\\n        return count\\n    \\n    def countExcellentPairs(self, nums, k):\\n        ans = 0\\n        s = set(nums)\\n        a = [self.bitcount(it) for it in s]\\n        a.sort()\\n        l = 0\\n        r = len(a) - 1\\n        while l <= r:\\n            if a[l] + a[r] < k:\\n                l += 1\\n            else:\\n                ans += 2 * (r - l) + 1\\n                r -= 1\\n                l = 0\\n        return ans\\n        \\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Array",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int bitcount(int n) //find the bitcount\\n    {\\n        int count=0;\\n\\n        while(n)\\n        {\\n            count++;\\n            n=n&(n-1);\\n        }\\n        return count;\\n    }\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        ll ans=0;\\n        set<int>s;\\n        for(auto i:nums) //unique elements\\n        {\\n            s.insert(i);\\n        }\\n        \\n        vector<int>a; //to store the bitcounts\\n        for(auto it:s)\\n        {\\n            a.push_back(bitcount(it));\\n        }\\n        sort(a.begin(),a.end());\\n\\n        int l=0;\\n        int r=a.size()-1;\\n\\n       \\n        while(l<=r)//find the number of pairs\\n        {\\n            if(a[l]+a[r]<k)\\n            {\\n                l++;\\n            }\\n            else {\\n                ans+=2*(r-l)+1;\\n                r--;\\n                l=0;\\n            }\\n        }\\n```\n```Python []\\nclass Solution:\\n    def bitcount(self, n):\\n        count = 0\\n        while n:\\n            count += 1\\n            n = n & (n - 1)\\n        return count\\n    \\n    def countExcellentPairs(self, nums, k):\\n        ans = 0\\n        s = set(nums)\\n        a = [self.bitcount(it) for it in s]\\n        a.sort()\\n        l = 0\\n        r = len(a) - 1\\n        while l <= r:\\n            if a[l] + a[r] < k:\\n                l += 1\\n            else:\\n                ans += 2 * (r - l) + 1\\n                r -= 1\\n                l = 0\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996218,
                "title": "bit-manipulation-hashmap-linear-time-and-space",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n  public long countExcellentPairs(int[] nums, int k) {\\n    Map<Integer, Set<Integer>> bitCountMap = new HashMap<>();\\n    long countEP = 0;\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      int acc = nums[i];\\n      int cntSet = 0;\\n      while (acc != 0) {\\n        cntSet += ((acc & 1) == 1 ? 1 : 0);\\n        acc = acc >> 1;\\n      }\\n\\n      if (bitCountMap.containsKey(cntSet) && bitCountMap.get(cntSet).contains(nums[i])) {\\n        continue;\\n      }\\n\\n      if (bitCountMap.containsKey(cntSet)) {\\n        bitCountMap.get(cntSet).add(nums[i]);\\n      } else {\\n        Set<Integer> b = new HashSet<>();\\n        b.add(nums[i]);\\n        bitCountMap.put(cntSet, b);\\n      }\\n\\n      if (2 * cntSet >= k) {\\n        countEP += 2 * bitCountMap.get(cntSet).size() - 1;\\n      }\\n    }\\n\\n    for (int j = 1; j <= 32; j++) {\\n      if (bitCountMap.containsKey(j) && k - j < j) {\\n        long s = 0;\\n        int t = Math.max(k - j, 1);\\n        while (t < j) {\\n          if (bitCountMap.containsKey(t)) {\\n            s += bitCountMap.get(t).size();\\n          }\\n          t++;\\n        }\\n\\n        countEP += 2 * bitCountMap.get(j).size() * s;\\n      }\\n    }\\n\\n    return countEP;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n  public long countExcellentPairs(int[] nums, int k) {\\n    Map<Integer, Set<Integer>> bitCountMap = new HashMap<>();\\n    long countEP = 0;\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      int acc = nums[i];\\n      int cntSet = 0;\\n      while (acc != 0) {\\n        cntSet += ((acc & 1) == 1 ? 1 : 0);\\n        acc = acc >> 1;\\n      }\\n\\n      if (bitCountMap.containsKey(cntSet) && bitCountMap.get(cntSet).contains(nums[i])) {\\n        continue;\\n      }\\n\\n      if (bitCountMap.containsKey(cntSet)) {\\n        bitCountMap.get(cntSet).add(nums[i]);\\n      } else {\\n        Set<Integer> b = new HashSet<>();\\n        b.add(nums[i]);\\n        bitCountMap.put(cntSet, b);\\n      }\\n\\n      if (2 * cntSet >= k) {\\n        countEP += 2 * bitCountMap.get(cntSet).size() - 1;\\n      }\\n    }\\n\\n    for (int j = 1; j <= 32; j++) {\\n      if (bitCountMap.containsKey(j) && k - j < j) {\\n        long s = 0;\\n        int t = Math.max(k - j, 1);\\n        while (t < j) {\\n          if (bitCountMap.containsKey(t)) {\\n            s += bitCountMap.get(t).size();\\n          }\\n          t++;\\n        }\\n\\n        countEP += 2 * bitCountMap.get(j).size() * s;\\n      }\\n    }\\n\\n    return countEP;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990265,
                "title": "rust-binary-search-no-hashmap-beats-100",
                "content": "# Intuition\\n\\nThe key to solving this problem is to realize that for any number `op_0: u32` and `op_1: u32`,\\n```rust\\nlet target = (op_0 & op_1).count_ones() + (op_0 | op_1).count_ones()\\nlet sum_of_set_bits = op_0.count_ones() + op_1.count_ones();\\n\\nassert_eq!(target, sum_of_set_bits);\\n```\\n\\n(why??)\\n\\n# Approach\\n\\nSince we are counting the number of **distinct** pairs, we should deduplicate the array first. Then we can just use **binary search** to count the number of excellent pairs for a given element.\\n\\nAlternatively, we can use a **segment tree** to count the number of valid elements.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$ from the deduplication.\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```rust\\nimpl Solution {\\n    // Hint: (op_0 & op_1).count_ones() + (op_0 | op_1).count_ones()\\n    //       == op_0.count_ones() + op_1.count_ones() !!\\n    pub fn count_excellent_pairs(vec: Vec<i32>, k: i32) -> i64 {\\n        let k = k as usize;\\n\\n        // pass 0: remove duplicates, O(n log n)\\n        let mut vec = vec.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n        vec.dedup();\\n\\n        // pass 1: map each element to its number of set bits\\n        //         also we sort the vector for binary search\\n        let mut vec = vec.into_iter()\\n            .map(|e| e.count_ones() as usize)\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n        vec.reverse();\\n\\n        let ret = vec.iter()\\n            .map(|&e| vec.partition_point(\\n                |&e_prev| e_prev + e >= k\\n            ))\\n            .sum::<usize>();\\n\\n        ret as i64\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```rust\\nlet target = (op_0 & op_1).count_ones() + (op_0 | op_1).count_ones()\\nlet sum_of_set_bits = op_0.count_ones() + op_1.count_ones();\\n\\nassert_eq!(target, sum_of_set_bits);\\n```\n```rust\\nimpl Solution {\\n    // Hint: (op_0 & op_1).count_ones() + (op_0 | op_1).count_ones()\\n    //       == op_0.count_ones() + op_1.count_ones() !!\\n    pub fn count_excellent_pairs(vec: Vec<i32>, k: i32) -> i64 {\\n        let k = k as usize;\\n\\n        // pass 0: remove duplicates, O(n log n)\\n        let mut vec = vec.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n        vec.dedup();\\n\\n        // pass 1: map each element to its number of set bits\\n        //         also we sort the vector for binary search\\n        let mut vec = vec.into_iter()\\n            .map(|e| e.count_ones() as usize)\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n        vec.reverse();\\n\\n        let ret = vec.iter()\\n            .map(|&e| vec.partition_point(\\n                |&e_prev| e_prev + e >= k\\n            ))\\n            .sum::<usize>();\\n\\n        ret as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850019,
                "title": "easiest-solution-c",
                "content": "man lete hai ki ham do number let hain 3 and 4 thik h.....\\n3 ko binary me 11 and 4 ko 100 lete hai jab ham iska and karege then 0 aayega and or karege to  7 aayega jisme 3 set bit hai jo ki dono ke set bit ke sum ke barabar hai ....similarly ek or example lete hain \\n\\nnum1=5(number of set bit=2) num2=6 (number of set bit=2)\\nnum1 & num2=4(number of set bit=1)  \\nnum1 | num2=7 (number of set bit=3)\\n\\nav sum of number of set bit in & and | ==number of set bit in num1+number of set bit in number 2\\n\\n\\nto bas yhi tha intution baki code dekh ke smjh lo \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int>st;\\n        for(auto x:nums)\\n        st.insert(x);\\n\\n        vector<int>res;\\n      for(auto x:st){\\n            int count=__builtin_popcount(x);\\n            res.push_back(count);\\n        }\\n        long long int ans=0;\\n        sort(res.begin(),res.end());\\n    int n=res.size();\\n        for(int i=0;i<res.size();i++){\\n        int index=lower_bound(res.begin(),res.end(),k-res[i])-res.begin();\\n        ans+=n-index;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int>st;\\n        for(auto x:nums)\\n        st.insert(x);\\n\\n        vector<int>res;\\n      for(auto x:st){\\n            int count=__builtin_popcount(x);\\n            res.push_back(count);\\n        }\\n        long long int ans=0;\\n        sort(res.begin(),res.end());\\n    int n=res.size();\\n        for(int i=0;i<res.size();i++){\\n        int index=lower_bound(res.begin(),res.end(),k-res[i])-res.begin();\\n        ans+=n-index;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810552,
                "title": "c-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOr + And of two numbers is same as bit count of Both numbers \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will find set bits of all the numbers. And then go through the sorted array and find the sum >= k. We can also use Binary search to find the res. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), iteration is once(O(n) set, O(n) in bit vector)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), storing in set \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findSetBit(int x){\\n        int cnt = 0;\\n        for(int i=0; i<32; i++){\\n            if(x & (1 << i)) cnt++; //if bit is set\\n        }\\n        return cnt;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int> st; //to store unique elements\\n        for(auto i: nums) st.insert(i);\\n\\n        vector<int> bit;\\n\\n        for(auto i: st){\\n            int setBit = findSetBit(i);\\n            bit.push_back(setBit); //pusing set bits count of each number\\n        }\\n        sort(bit.begin(), bit.end());\\n\\n        int n = bit.size();   \\n        int l= 0; \\n        int r = n-1; \\n        long long res = 0;\\n        while(l < n && r >= 0){ //as two way res works 1,2  n  2,1\\n            int sum = bit[l] + bit[r]; //sum of bit cnt of two numsj = num1 OR num2 + num1 AND num2 \\n\\n            if(sum < k){\\n                l++; //increase value and explore\\n            }\\n            else{ //if >= k\\n                res += (n - l); //+ values in the subarray\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSetBit(int x){\\n        int cnt = 0;\\n        for(int i=0; i<32; i++){\\n            if(x & (1 << i)) cnt++; //if bit is set\\n        }\\n        return cnt;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int> st; //to store unique elements\\n        for(auto i: nums) st.insert(i);\\n\\n        vector<int> bit;\\n\\n        for(auto i: st){\\n            int setBit = findSetBit(i);\\n            bit.push_back(setBit); //pusing set bits count of each number\\n        }\\n        sort(bit.begin(), bit.end());\\n\\n        int n = bit.size();   \\n        int l= 0; \\n        int r = n-1; \\n        long long res = 0;\\n        while(l < n && r >= 0){ //as two way res works 1,2  n  2,1\\n            int sum = bit[l] + bit[r]; //sum of bit cnt of two numsj = num1 OR num2 + num1 AND num2 \\n\\n            if(sum < k){\\n                l++; //increase value and explore\\n            }\\n            else{ //if >= k\\n                res += (n - l); //+ values in the subarray\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804287,
                "title": "beats-100-ruby-easy-to-understand-2354-number-of-excellent-pairs",
                "content": "# Approach\\n- Using hashing techniques\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef count_excellent_pairs(nums, k)\\n    hash1={}\\n    total=0\\n    for i in nums.uniq\\n        hash1[i.to_s(2).count(\"1\")] = hash1[i.to_s(2).count(\"1\")].to_i + 1\\n    end\\n    hash1.each do |key1,val1|\\n        hash1.each do |key2,val2|\\n            total += val1*val2 if key1 + key2 >= k\\n        end\\n    end\\n    return total\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Hash Table",
                    "Iterator"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Integer}\\ndef count_excellent_pairs(nums, k)\\n    hash1={}\\n    total=0\\n    for i in nums.uniq\\n        hash1[i.to_s(2).count(\"1\")] = hash1[i.to_s(2).count(\"1\")].to_i + 1\\n    end\\n    hash1.each do |key1,val1|\\n        hash1.each do |key2,val2|\\n            total += val1*val2 if key1 + key2 >= k\\n        end\\n    end\\n    return total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3610693,
                "title": "bit-count-frequency-table-prefix-sum-o-n",
                "content": "* Let `bits(num1) = a, bit(num2) = b`.  be the bits set in `nums1` and `nums2`\\n* Let `bits(num1&num2) = c`, the number of set bits in both numbers.\\n* We want to compute `bits(num1&num2) + bits(num1|num2) `\\n* Let us partition each of the 32 bit positions into one of four cases and consider their contributions to the expression `bits(num1&num2) + bits(num1|num2)`:\\n* \\n    |bit set in? |times counted in expression?| weight | total |\\n    |---|---|---|----|\\n    | `num1` only | counted in `num1|num2`| 1 | `a-c`\\n\\t| `num2` only | counted in `num1|num2`| 1 | `b-c`\\n\\t| `num1` & `num2` | counted in `num1&num2` and `num1|num2`| 2| `2c` \\n\\t| neither num1 nor num2 | 0| 0| 0\\nTherefore \\n* `bits(num1&num2) + bits(num1|num2) = `\\n* `(a-c) + (b-c) + 2c = `\\n*  `a + b`.\\n\\nSo given `nums1` with `bits(nums1) = a`, we need to find how many unique `nums2` exist such that `bits(nums) >= b`. \\nWe can use a set to dedupe the numbers, and a table `cnt` where `cnt[i] = b` counts how many numbers have exactly `b` bits.\\nFinally, we can use a prefix sum `prefix[i] = cnt[0] + cnt[1] ... cnt[i-1]` to find our answer quickly.\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> cnt(61);\\n        map<int,int> d; // deduplicate\\n        for(int n: nums){\\n            if(!d[n]++){\\n                ++cnt[bits(n)];\\n            }\\n        }\\n        vector<int> prefix(62);\\n        for(int i=1;i<62;++i){\\n            prefix[i] = cnt[i-1] + prefix[i-1];\\n        }\\n        long long sm = 0;\\n        int N = d.size();\\n        assert(prefix[0] == 0);\\n        assert(prefix.back() == N);\\n        for(auto [n, _]: d){\\n            int b = bits(n);\\n            int a = max(0, k-b);\\n            sm += N - prefix[a];\\n        }\\n        return sm;\\n    }\\n    int bits(int n){\\n        return __builtin_popcount(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> cnt(61);\\n        map<int,int> d; // deduplicate\\n        for(int n: nums){\\n            if(!d[n]++){\\n                ++cnt[bits(n)];\\n            }\\n        }\\n        vector<int> prefix(62);\\n        for(int i=1;i<62;++i){\\n            prefix[i] = cnt[i-1] + prefix[i-1];\\n        }\\n        long long sm = 0;\\n        int N = d.size();\\n        assert(prefix[0] == 0);\\n        assert(prefix.back() == N);\\n        for(auto [n, _]: d){\\n            int b = bits(n);\\n            int a = max(0, k-b);\\n            sm += N - prefix[a];\\n        }\\n        return sm;\\n    }\\n    int bits(int n){\\n        return __builtin_popcount(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549162,
                "title": "c-stl-beating-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    inline static int num_bits(int x){\\n        int res = 0;\\n        while(x){\\n            res += x & 1;\\n            x >>= 1;\\n        }\\n        return res;\\n    }\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        sort(begin(nums), end(nums));\\n        nums.erase(unique(begin(nums), end(nums)), end(nums));\\n\\n        vector<tuple<int, int>> bnums(nums.size());\\n        transform(begin(nums), end(nums), begin(bnums), [](auto x) { return make_tuple(x, num_bits(x)); });\\n        sort(begin(bnums), end(bnums), [](auto a, auto b){return get<1>(a) < get<1>(b);});\\n\\n        long long res = 0;\\n        for(auto it = begin(bnums); it != end(bnums); ++it){\\n            if(2 * get<1>(*it) >= k){\\n                long long n = distance(it, end(bnums));\\n                return res + n * n;\\n            }\\n            auto it_start = lower_bound(next(it), end(bnums), k - get<1>(*it), [](auto a, auto b){return get<1>(a) < b;});\\n            res += distance(it_start, end(bnums)) * 2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    inline static int num_bits(int x){\\n        int res = 0;\\n        while(x){\\n            res += x & 1;\\n            x >>= 1;\\n        }\\n        return res;\\n    }\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        sort(begin(nums), end(nums));\\n        nums.erase(unique(begin(nums), end(nums)), end(nums));\\n\\n        vector<tuple<int, int>> bnums(nums.size());\\n        transform(begin(nums), end(nums), begin(bnums), [](auto x) { return make_tuple(x, num_bits(x)); });\\n        sort(begin(bnums), end(bnums), [](auto a, auto b){return get<1>(a) < get<1>(b);});\\n\\n        long long res = 0;\\n        for(auto it = begin(bnums); it != end(bnums); ++it){\\n            if(2 * get<1>(*it) >= k){\\n                long long n = distance(it, end(bnums));\\n                return res + n * n;\\n            }\\n            auto it_start = lower_bound(next(it), end(bnums), k - get<1>(*it), [](auto a, auto b){return get<1>(a) < b;});\\n            res += distance(it_start, end(bnums)) * 2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498429,
                "title": "two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- arr is the bit 1 count of each num in a set of nums, this can avoid duplicate\\n- arr.sort, use 2 pointers\\n- e.g. arr = [1, 2, 2, 3, 4, 5], k = 4, if l = 1, r = 5\\n- res += (5 - 1) * 2 + 1, final + 1 is (5, 5), then r -= 1\\n- l = r, because, (3, 3) can be an answer\\n- res += (r - l) * 2 + 1, because (1, 3), (3, 1) and (3, 3)\\n- in side array even (2, 2) can be 3, because 2 is just an representation of nums, for the 2 numbers, it can be(3, 5), so the formular res += (r - l) * 2 + 1 always works\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        arr=[bin(num).count(\\'1\\') for num in set(nums)]\\n        arr.sort()\\n        l, r, res = 0, len(arr) - 1, 0\\n        while l <= r:\\n            if arr[l] + arr[r] >= k:\\n                res += (r - l) * 2 + 1\\n                r -= 1\\n            else:\\n                l += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        arr=[bin(num).count(\\'1\\') for num in set(nums)]\\n        arr.sort()\\n        l, r, res = 0, len(arr) - 1, 0\\n        while l <= r:\\n            if arr[l] + arr[r] >= k:\\n                res += (r - l) * 2 + 1\\n                r -= 1\\n            else:\\n                l += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464185,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int arr[31]={};\\n        unordered_set<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            if(st.find(nums[i])==st.end()){\\n                int cnt=0;\\n                int num=nums[i];\\n                while(nums[i]){\\n                    if(nums[i]&1) cnt++;\\n                    nums[i]=nums[i]>>1;\\n                }\\n                arr[cnt]++;\\n                st.insert(num);\\n            }\\n        } \\n        long long ans=0;\\n        int pre[31]={};\\n\\n        for(int i=1;i<31;i++) pre[i]=arr[i]+pre[i-1];\\n        for(int i=0;i<31;i++){\\n            if(arr[i]>0 && k-i<=30){\\n                ans+=arr[i]*(pre[30]-((k>i)?pre[k-i-1]:0));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int arr[31]={};\\n        unordered_set<int> st;\\n        for(int i=0;i<nums.size();i++){\\n            if(st.find(nums[i])==st.end()){\\n                int cnt=0;\\n                int num=nums[i];\\n                while(nums[i]){\\n                    if(nums[i]&1) cnt++;\\n                    nums[i]=nums[i]>>1;\\n                }\\n                arr[cnt]++;\\n                st.insert(num);\\n            }\\n        } \\n        long long ans=0;\\n        int pre[31]={};\\n\\n        for(int i=1;i<31;i++) pre[i]=arr[i]+pre[i-1];\\n        for(int i=0;i<31;i++){\\n            if(arr[i]>0 && k-i<=30){\\n                ans+=arr[i]*(pre[30]-((k>i)?pre[k-i-1]:0));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340890,
                "title": "easy-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, we defined a set for removing the duplicate element from array.\\nThen we create a vector for storing the set bits of every elemnt of the array.Then we sort the array and use simple two pointer approch to count the pairs whose sum greater than or equal to k. We can also use binary search in place of two pointer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int>st;\\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n        }\\n        vector<int>noofbits;\\n        for(auto it:st){\\n            int val= __builtin_popcount(it);\\n        //__builtin_popcount(int num) is a function use for counting the set bit in an integer.\\n            noofbits.push_back(val);\\n\\n        }\\n        sort(noofbits.begin(), noofbits.end());\\n\\n        int n=noofbits.size();\\n        int l=0;\\n        int r=n-1;\\n        long long res=0;\\n\\n        while(l<n && r>=0){\\n            if(noofbits[l]+noofbits[r]<k){\\n                l++;\\n            }else{\\n                res+=(n-l);\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please upvote :)**",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int>st;\\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n        }\\n        vector<int>noofbits;\\n        for(auto it:st){\\n            int val= __builtin_popcount(it);\\n        //__builtin_popcount(int num) is a function use for counting the set bit in an integer.\\n            noofbits.push_back(val);\\n\\n        }\\n        sort(noofbits.begin(), noofbits.end());\\n\\n        int n=noofbits.size();\\n        int l=0;\\n        int r=n-1;\\n        long long res=0;\\n\\n        while(l<n && r>=0){\\n            if(noofbits[l]+noofbits[r]<k){\\n                l++;\\n            }else{\\n                res+=(n-l);\\n                r--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325810,
                "title": "swift-accepted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func countExcellentPairs(_ nums: [Int], _ k: Int) -> Int {\\n          let nums = Set(nums).map{ $0.nonzeroBitCount }.sorted()\\n        var counter = nums.reduce(0) { $0 + ($1*2 >= k ? 1 : 0) } \\n        var left = 0, right = nums.count - 1\\n        while left < right {\\n            if nums[left] + nums[right] >= k {\\n                counter += (right - left) * 2\\n                right -= 1\\n            } else {\\n                left += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countExcellentPairs(_ nums: [Int], _ k: Int) -> Int {\\n          let nums = Set(nums).map{ $0.nonzeroBitCount }.sorted()\\n        var counter = nums.reduce(0) { $0 + ($1*2 >= k ? 1 : 0) } \\n        var left = 0, right = nums.count - 1\\n        while left < right {\\n            if nums[left] + nums[right] >= k {\\n                counter += (right - left) * 2\\n                right -= 1\\n            } else {\\n                left += 1\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307762,
                "title": "easy-c-solution-must-see-with-explanation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    unordered_set<int>st;\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        // set bits of num1 or num2 + set bits of num1 & num2 = set bits\\n        // of num1 + set bits of num2\\n        // or will preserve the max(num1,num2) set bits\\n        // & will preserve the common set bits of num1 and num2\\n        // we will make a list which will store set bits of ele,ele\\n        // sort the list and apply binary search on it to find all\\n        // distinct pairs\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(st.find(nums[i])==st.end())\\n            {\\n                v.push_back({bit_count(nums[i]),nums[i]});\\n                st.insert(nums[i]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans=ans+fun(v[i][1],k);\\n        }\\n        return ans;\\n    }\\n    long long int fun(int &num,int &k)\\n    {\\n        int start=0;\\n        int end=v.size()-1;\\n        int mid;\\n        long long int ans=0;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if((bit_count(num)+v[mid][0])>=k)\\n            {\\n                ans=ans+(end-mid+1);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int bit_count(int &n)\\n    {\\n        int temp=n;\\n        int ans=0;\\n        while(temp)\\n        {\\n            ans++;\\n            temp=temp-(temp & (-1*temp));\\n        }\\n        //cout<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    unordered_set<int>st;\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        // set bits of num1 or num2 + set bits of num1 & num2 = set bits\\n        // of num1 + set bits of num2\\n        // or will preserve the max(num1,num2) set bits\\n        // & will preserve the common set bits of num1 and num2\\n        // we will make a list which will store set bits of ele,ele\\n        // sort the list and apply binary search on it to find all\\n        // distinct pairs\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(st.find(nums[i])==st.end())\\n            {\\n                v.push_back({bit_count(nums[i]),nums[i]});\\n                st.insert(nums[i]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        long long int ans=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans=ans+fun(v[i][1],k);\\n        }\\n        return ans;\\n    }\\n    long long int fun(int &num,int &k)\\n    {\\n        int start=0;\\n        int end=v.size()-1;\\n        int mid;\\n        long long int ans=0;\\n        while(start<=end)\\n        {\\n            mid=(start+end)/2;\\n            if((bit_count(num)+v[mid][0])>=k)\\n            {\\n                ans=ans+(end-mid+1);\\n                end=mid-1;\\n            }\\n            else\\n            {\\n                start=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int bit_count(int &n)\\n    {\\n        int temp=n;\\n        int ans=0;\\n        while(temp)\\n        {\\n            ans++;\\n            temp=temp-(temp & (-1*temp));\\n        }\\n        //cout<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3165022,
                "title": "o-n-x",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int setBits(int n){ // returns count of set bits(1-s) in binary representation of n \\n        int res = 0;\\n        for(; n; n >>= 1) res += n & 1;\\n        return res;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int cnt[31] = {}, i, j; long long res = 0LL;\\n        unordered_set<int> seen;\\n        for(int& num : nums){\\n            // we must AVOID double count duplicates (for instance if we have number 13 multiple times, we should only consider setBits(13) only once)\\n            if(!seen.count(num)){\\n                cnt[setBits(num)]++; \\n                seen.insert(num);\\n            }\\n        }\\n        for(i = 2; i < 31; i++) cnt[i] += cnt[i - 1]; // make prefix sum\\n        // after making prefix sum: previous cnt[i] -> cnt[i] - cnt[i - 1]\\n        for(i = max(1, k - 30); i < 31; i++){\\n            /* for each number in nums we can make a pair (num, num) by description (even if we dont have more than 1 occurence of num). so add all \"same pairs\" \\n\\t\\t\\t   plus add all pairs made-by numbers with total i set bits (of course only do them if i + i >= k)*/\\n            if((i << 1) >= k) res += (cnt[i] - cnt[i - 1]) + (cnt[i] - cnt[i - 1]) * (cnt[i] - cnt[i - 1] - 1);\\n            j = k - i > i ? k - i : i + 1; // find first j > i such that i + j >= k\\n            res += (cnt[i] - cnt[i - 1]) * (cnt[30] - cnt[j - 1]) * 2; // multiply by 2 because (i, j) != (j, i) by description\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int setBits(int n){ // returns count of set bits(1-s) in binary representation of n \\n        int res = 0;\\n        for(; n; n >>= 1) res += n & 1;\\n        return res;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int cnt[31] = {}, i, j; long long res = 0LL;\\n        unordered_set<int> seen;\\n        for(int& num : nums){\\n            // we must AVOID double count duplicates (for instance if we have number 13 multiple times, we should only consider setBits(13) only once)\\n            if(!seen.count(num)){\\n                cnt[setBits(num)]++; \\n                seen.insert(num);\\n            }\\n        }\\n        for(i = 2; i < 31; i++) cnt[i] += cnt[i - 1]; // make prefix sum\\n        // after making prefix sum: previous cnt[i] -> cnt[i] - cnt[i - 1]\\n        for(i = max(1, k - 30); i < 31; i++){\\n            /* for each number in nums we can make a pair (num, num) by description (even if we dont have more than 1 occurence of num). so add all \"same pairs\" \\n\\t\\t\\t   plus add all pairs made-by numbers with total i set bits (of course only do them if i + i >= k)*/\\n            if((i << 1) >= k) res += (cnt[i] - cnt[i - 1]) + (cnt[i] - cnt[i - 1]) * (cnt[i] - cnt[i - 1] - 1);\\n            j = k - i > i ? k - i : i + 1; // find first j > i such that i + j >= k\\n            res += (cnt[i] - cnt[i - 1]) * (cnt[30] - cnt[j - 1]) * 2; // multiply by 2 because (i, j) != (j, i) by description\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159818,
                "title": "best-solution-explained",
                "content": "\\n```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n    long res = 0, cnt[] = new long[30]; \\n    for (int n : Arrays.stream(nums).distinct().toArray()) {\\n        ++cnt[Integer.bitCount(n)];\\n    }\\n    for (int i = 1; i < 30; ++i)\\n        for (int j = Math.max(i, k - i); j < 30; ++j)\\n            res += cnt[i] * cnt[j] * (i == j ? 1 : 2);\\n    return res;\\n}\\n}\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Go",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n    long res = 0, cnt[] = new long[30]; \\n    for (int n : Arrays.stream(nums).distinct().toArray()) {\\n        ++cnt[Integer.bitCount(n)];\\n    }\\n    for (int i = 1; i < 30; ++i)\\n        for (int j = Math.max(i, k - i); j < 30; ++j)\\n            res += cnt[i] * cnt[j] * (i == j ? 1 : 2);\\n    return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096219,
                "title": "c-easy-fast-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bit(int n)\\n    {\\n        int cnt=0;\\n        while(n!=0)\\n        {\\n            if(n%2!=0)\\n            cnt++;\\n            n=n/2;\\n        }\\n        return cnt;\\n    }\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(n);\\n        unordered_set<int> s;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp[i]=bit(nums[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(nums[i])==s.end())\\n            {\\n                s.insert(nums[i]);\\n                mp[temp[i]]++;\\n            }\\n        }\\n        unordered_set<int> s1;\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s1.find(nums[i])==s1.end())\\n            {\\n                s1.insert(nums[i]);\\n                int curr=temp[i];\\n                int req=k-curr;\\n                for(auto x:mp)\\n                {\\n                    if(x.first>=req)\\n                    {\\n                        ans+=x.second;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bit(int n)\\n    {\\n        int cnt=0;\\n        while(n!=0)\\n        {\\n            if(n%2!=0)\\n            cnt++;\\n            n=n/2;\\n        }\\n        return cnt;\\n    }\\n\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(n);\\n        unordered_set<int> s;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp[i]=bit(nums[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(nums[i])==s.end())\\n            {\\n                s.insert(nums[i]);\\n                mp[temp[i]]++;\\n            }\\n        }\\n        unordered_set<int> s1;\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s1.find(nums[i])==s1.end())\\n            {\\n                s1.insert(nums[i]);\\n                int curr=temp[i];\\n                int req=k-curr;\\n                for(auto x:mp)\\n                {\\n                    if(x.first>=req)\\n                    {\\n                        ans+=x.second;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081663,
                "title": "beautiful-approach-c-bits-sorting-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool Sort(int &a, int &b)\\n    {\\n        return __builtin_popcount(a) < __builtin_popcount(b);\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int> st;\\n        for(auto &x : nums)st.insert(x);\\n        vector<int> v1;\\n        for(auto &x : st)v1.push_back(x);\\n        sort(v1.begin(),v1.end(),Sort);\\n        long long cnt = 0;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            int cnt1 = __builtin_popcount(v1[i]);\\n            int req = k-cnt1;\\n            int l=i, r = v1.size()-1, res = r+1;\\n            while(l <= r)\\n            {\\n                int mid = (l+r)/2;\\n                if(__builtin_popcount(v1[mid]) >= req)\\n                {\\n                    res = mid;\\n                    r = mid-1;\\n                }\\n                else l= mid+1;\\n            }\\n            cnt += (1LL*(v1.size()-res)*2);\\n            if(res == i)cnt--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool Sort(int &a, int &b)\\n    {\\n        return __builtin_popcount(a) < __builtin_popcount(b);\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int> st;\\n        for(auto &x : nums)st.insert(x);\\n        vector<int> v1;\\n        for(auto &x : st)v1.push_back(x);\\n        sort(v1.begin(),v1.end(),Sort);\\n        long long cnt = 0;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            int cnt1 = __builtin_popcount(v1[i]);\\n            int req = k-cnt1;\\n            int l=i, r = v1.size()-1, res = r+1;\\n            while(l <= r)\\n            {\\n                int mid = (l+r)/2;\\n                if(__builtin_popcount(v1[mid]) >= req)\\n                {\\n                    res = mid;\\n                    r = mid-1;\\n                }\\n                else l= mid+1;\\n            }\\n            cnt += (1LL*(v1.size()-res)*2);\\n            if(res == i)cnt--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011829,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums, k):\\n        nums, dict1, total = list(set(nums)), collections.defaultdict(int), 0\\n\\n        for i in nums:\\n            dict1[bin(i)[2:].count(\"1\")] += 1\\n\\n        for key1,val1 in dict1.items():\\n            for key2,val2 in dict1.items():\\n                if key1 + key2 >= k:\\n                    total += val1*val2\\n\\n        return total\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums, k):\\n        nums, dict1, total = list(set(nums)), collections.defaultdict(int), 0\\n\\n        for i in nums:\\n            dict1[bin(i)[2:].count(\"1\")] += 1\\n\\n        for key1,val1 in dict1.items():\\n            for key2,val2 in dict1.items():\\n                if key1 + key2 >= k:\\n                    total += val1*val2\\n\\n        return total\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006688,
                "title": "simple-bits-count-sorting-c",
                "content": "please upvote you like \\uD83D\\uDC4D\\nit keeps me motivated \\uD83D\\uDE03\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find all distinct elements (use set)\\n2. push the set bit cnt to new vector \\n3. sort new vector containing the bits cnt\\n4. traverse the vector and find lowerbound idx for (k-v[i]) all elements after the lowerbound considering the itself are a valid pair \\n5. increse the cnt\\n6. return cnt\\n\\nNote : for getting setbit cnt inbuild C++ STL __builtin_popcount();\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O{n(log n)}\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& arr, int k) {\\n\\n        long long cnt=0;\\n        unordered_set<int> s;\\n        for(auto i:arr)s.insert(i);\\n\\n        vector<int> v;\\n        for(auto& i: s)v.push_back(__builtin_popcount(i));\\n\\n        sort(v.begin(),v.end());\\n        \\n        for(auto i:v){\\n            auto it = lower_bound(v.begin(),v.end(),k-i);\\n            cnt += (v.end()-it);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& arr, int k) {\\n\\n        long long cnt=0;\\n        unordered_set<int> s;\\n        for(auto i:arr)s.insert(i);\\n\\n        vector<int> v;\\n        for(auto& i: s)v.push_back(__builtin_popcount(i));\\n\\n        sort(v.begin(),v.end());\\n        \\n        for(auto i:v){\\n            auto it = lower_bound(v.begin(),v.end(),k-i);\\n            cnt += (v.end()-it);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828352,
                "title": "two-pointer-solution-python",
                "content": "`sum of set bits in [a&b , a|b] = sum of set bits [a , b]`\\nSo if you just sort nums based on number of set bits,\\nyou can apply two pointer technique or binary search to count\\nthe number of elements each element `nums[i]` can pair with. \\n```\\ndef countExcellentPairs(self, nums: List[int], k: int) -> int:\\n    nums = sorted(set(nums), key=lambda num: num.bit_count())\\n    n = len(nums)\\n\\n    count = 0\\n    i = 0\\n    j = n-1\\n    while j >= 0 and i < n:\\n        a, b = nums[i], nums[j]\\n        if a.bit_count() + b.bit_count() < k:\\n            i += 1\\n        else:\\n            count += n - i\\n            j -= 1\\n    return count\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef countExcellentPairs(self, nums: List[int], k: int) -> int:\\n    nums = sorted(set(nums), key=lambda num: num.bit_count())\\n    n = len(nums)\\n\\n    count = 0\\n    i = 0\\n    j = n-1\\n    while j >= 0 and i < n:\\n        a, b = nums[i], nums[j]\\n        if a.bit_count() + b.bit_count() < k:\\n            i += 1\\n        else:\\n            count += n - i\\n            j -= 1\\n    return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2800513,
                "title": "c-bit-manipulation-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // number of set bits in a|b + number of set bits in a&b = number of sets bits in a + number of set bits in b\\n    \\n    int bc(int num){\\n        int cnt = 0;\\n        for(int i=0;i<31;i++){\\n            if((num&(1<<i))) cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int>st;\\n        for(auto &val:nums) st.insert(val);\\n        vector<int> v;\\n        for(auto &val:st) v.push_back(val);\\n        vector<int> x;\\n        for(auto &val:v){\\n            x.push_back(bc(val));\\n        }\\n        sort(x.begin(),x.end());\\n        long long ans = 0;\\n        int n = x.size();\\n        for(int i=0;i<n;i++){\\n            auto it = x.begin()+i+1;\\n            int idx = lower_bound(it,x.end(),k-x[i])-x.begin();\\n            if(idx>=i){\\n                ans+= 1LL*(n-idx);\\n            }\\n        }\\n        ans*=2LL;\\n        // handles the cases where same element forms pair\\n        for(auto &val:x){\\n            if(2*val>=k) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // number of set bits in a|b + number of set bits in a&b = number of sets bits in a + number of set bits in b\\n    \\n    int bc(int num){\\n        int cnt = 0;\\n        for(int i=0;i<31;i++){\\n            if((num&(1<<i))) cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int>st;\\n        for(auto &val:nums) st.insert(val);\\n        vector<int> v;\\n        for(auto &val:st) v.push_back(val);\\n        vector<int> x;\\n        for(auto &val:v){\\n            x.push_back(bc(val));\\n        }\\n        sort(x.begin(),x.end());\\n        long long ans = 0;\\n        int n = x.size();\\n        for(int i=0;i<n;i++){\\n            auto it = x.begin()+i+1;\\n            int idx = lower_bound(it,x.end(),k-x[i])-x.begin();\\n            if(idx>=i){\\n                ans+= 1LL*(n-idx);\\n            }\\n        }\\n        ans*=2LL;\\n        // handles the cases where same element forms pair\\n        for(auto &val:x){\\n            if(2*val>=k) ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727243,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        unordered_map<int, int> c;\\n        unordered_map<int, int> visited;\\n        \\n        for(int num: nums) {\\n            if(visited[num]++) continue;\\n            \\n            int count = 0;\\n            for(; num; num >>= 1) if(num & 1) m[++count]++;\\n            c[count]++;\\n        }\\n        \\n        long long res = 0;\\n        for(int i = 60; i >= 1; i--) \\n\\t\\t\\tres += c[i] * m[max(1, k - i)];\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_map<int, int> m;\\n        unordered_map<int, int> c;\\n        unordered_map<int, int> visited;\\n        \\n        for(int num: nums) {\\n            if(visited[num]++) continue;\\n            \\n            int count = 0;\\n            for(; num; num >>= 1) if(num & 1) m[++count]++;\\n            c[count]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2701110,
                "title": "simple-python-solution-python-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        count = Counter(bin(n).count(\\'1\\') for n in set(nums))\\n        ans = 0\\n        for k1, v1 in count.items():\\n            for k2, v2 in count.items():\\n                if k1 + k2 >= k:\\n                    ans += v1 * v2\\n        return ans\\n    # Time: O(n) where n is the length of nums\\n    # Space: O(1) count has a constant number of keys\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        count = Counter(bin(n).count(\\'1\\') for n in set(nums))\\n        ans = 0\\n        for k1, v1 in count.items():\\n            for k2, v2 in count.items():\\n                if k1 + k2 >= k:\\n                    ans += v1 * v2\\n        return ans\\n    # Time: O(n) where n is the length of nums\\n    # Space: O(1) count has a constant number of keys\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665516,
                "title": "c-bitmasking-sorting-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int> st;\\n        for(int a: nums) \\n            st.insert(a);\\n        \\n        vector<int> cnts;\\n        for(int i: st)\\n            cnts.push_back(__builtin_popcount(i));\\n        \\n        sort(cnts.begin(), cnts.end());\\n        \\n        long long ans = 0;\\n        int n = cnts.size();\\n        int l = 0, r = n - 1;\\n        while(l < r && l < n) {\\n            if(cnts[l]+cnts[r] >= k) {\\n                ans += (2*(r-l));\\n                r -= 1;\\n            } else {\\n                l += 1;\\n            }\\n        }\\n        \\n        for(int i: cnts) {\\n            if(i+i >= k)\\n                ans += 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<int> st;\\n        for(int a: nums) \\n            st.insert(a);\\n        \\n        vector<int> cnts;\\n        for(int i: st)\\n            cnts.push_back(__builtin_popcount(i));\\n        \\n        sort(cnts.begin(), cnts.end());\\n        \\n        long long ans = 0;\\n        int n = cnts.size();\\n        int l = 0, r = n - 1;\\n        while(l < r && l < n) {\\n            if(cnts[l]+cnts[r] >= k) {\\n                ans += (2*(r-l));\\n                r -= 1;\\n            } else {\\n                l += 1;\\n            }\\n        }\\n        \\n        for(int i: cnts) {\\n            if(i+i >= k)\\n                ans += 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639881,
                "title": "java-o-n-count-the-bit-easy-to-understand",
                "content": "```Java\\nclass Solution {\\n/*\\n\\tnumOfSetBits(a & b) + numOfSetBits(a | b) == numOfSetBits(a) + numOfSetBits(b), because:\\n\\ta=0,b=0, a&b = 0, a|b = 0\\n\\ta=0,b=1, a&b = 0, a|b = 1\\n\\ta=1,b=1, a&b = 1, a|b = 1\\n*/\\n    public long countExcellentPairs(int[] nums, int k) {\\n        \\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>(); // (numOfSetBits, [numbers....])\\n\\t\\t// time O(n)\\n        for (int i = 0; i < nums.length; i++){\\n            int n = numOfSetBits(nums[i]);\\n            if (!map.containsKey(n)) map.put(n, new HashSet<>());\\n            map.get(n).add(nums[i]);\\n        }\\n        \\n        long res = 0;\\n        \\n        // numOfSetBits(a & b) + numOfSetBits(a | b) == numOfSetBits(a) + numOfSetBits(b)\\n\\t\\t// time O(1), because  0 <= i, j <= 32\\n        for (int i : map.keySet()) {\\n            for (int j : map.keySet()) {\\n                if (i + j >= k) {\\n                    int si = map.get(i).size();\\n                    int sj = map.get(j).size();\\n                    res += si * sj;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // time O(1)\\n    private int numOfSetBits(int n) {\\n        int res = 0;\\n        while (n > 0) {\\n            if ((n & 1) == 1) res++;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n/*\\n\\tnumOfSetBits(a & b) + numOfSetBits(a | b) == numOfSetBits(a) + numOfSetBits(b), because:\\n\\ta=0,b=0, a&b = 0, a|b = 0\\n\\ta=0,b=1, a&b = 0, a|b = 1\\n\\ta=1,b=1, a&b = 1, a|b = 1\\n*/\\n    public long countExcellentPairs(int[] nums, int k) {\\n        \\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>(); // (numOfSetBits, [numbers....])\\n\\t\\t// time O(n)\\n        for (int i = 0; i < nums.length; i++){\\n            int n = numOfSetBits(nums[i]);\\n            if (!map.containsKey(n)) map.put(n, new HashSet<>());\\n            map.get(n).add(nums[i]);\\n        }\\n        \\n        long res = 0;\\n        \\n        // numOfSetBits(a & b) + numOfSetBits(a | b) == numOfSetBits(a) + numOfSetBits(b)\\n\\t\\t// time O(1), because  0 <= i, j <= 32\\n        for (int i : map.keySet()) {\\n            for (int j : map.keySet()) {\\n                if (i + j >= k) {\\n                    int si = map.get(i).size();\\n                    int sj = map.get(j).size();\\n                    res += si * sj;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // time O(1)\\n    private int numOfSetBits(int n) {\\n        int res = 0;\\n        while (n > 0) {\\n            if ((n & 1) == 1) res++;\\n            n >>= 1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577281,
                "title": "c-time-o-n-k-space-o-n",
                "content": "Last part of the solution can be done in O(k^2) Time. Improving it to O(k) isn\\'t affecting runtime that much, but is good exercise for prefix sums. \\n```\\nclass Solution {\\npublic:\\n    int setBits(int n){ // returns count of set bits(1-s) in binary representation of n \\n        int res = 0;\\n        for(; n; n >>= 1) res += n & 1;\\n        return res;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int cnt[31] = {}, i, j; long long res = 0LL;\\n        unordered_set<int> seen;\\n        for(int& num : nums){\\n            // we must AVOID double count duplicates (for instance if we have number 13 multiple times, we should only consider setBits(13) only once)\\n            if(!seen.count(num)){\\n                cnt[setBits(num)]++; \\n                seen.insert(num);\\n            }\\n        }\\n        for(i = 2; i < 31; i++) cnt[i] += cnt[i - 1]; // make prefix sum\\n        // after making prefix sum: previous cnt[i] -> cnt[i] - cnt[i - 1]\\n        for(i = max(1, k - 30); i < 31; i++){\\n            /* for each number in nums we can make a pair (num, num) by description (even if we dont have more than 1 occurence of num). so add all \"same pairs\" \\n\\t\\t\\t   plus add all pairs made-by numbers with total i set bits (of course only do them if i + i >= k)*/\\n            if((i << 1) >= k) res += (cnt[i] - cnt[i - 1]) + (cnt[i] - cnt[i - 1]) * (cnt[i] - cnt[i - 1] - 1);\\n            j = k - i > i ? k - i : i + 1; // find first j > i such that i + j >= k\\n            res += (cnt[i] - cnt[i - 1]) * (cnt[30] - cnt[j - 1]) * 2; // multiply by 2 because (i, j) != (j, i) by description\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int setBits(int n){ // returns count of set bits(1-s) in binary representation of n \\n        int res = 0;\\n        for(; n; n >>= 1) res += n & 1;\\n        return res;\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int cnt[31] = {}, i, j; long long res = 0LL;\\n        unordered_set<int> seen;\\n        for(int& num : nums){\\n            // we must AVOID double count duplicates (for instance if we have number 13 multiple times, we should only consider setBits(13) only once)\\n            if(!seen.count(num)){\\n                cnt[setBits(num)]++; \\n                seen.insert(num);\\n            }\\n        }\\n        for(i = 2; i < 31; i++) cnt[i] += cnt[i - 1]; // make prefix sum\\n        // after making prefix sum: previous cnt[i] -> cnt[i] - cnt[i - 1]\\n        for(i = max(1, k - 30); i < 31; i++){\\n            /* for each number in nums we can make a pair (num, num) by description (even if we dont have more than 1 occurence of num). so add all \"same pairs\" \\n\\t\\t\\t   plus add all pairs made-by numbers with total i set bits (of course only do them if i + i >= k)*/\\n            if((i << 1) >= k) res += (cnt[i] - cnt[i - 1]) + (cnt[i] - cnt[i - 1]) * (cnt[i] - cnt[i - 1] - 1);\\n            j = k - i > i ? k - i : i + 1; // find first j > i such that i + j >= k\\n            res += (cnt[i] - cnt[i - 1]) * (cnt[30] - cnt[j - 1]) * 2; // multiply by 2 because (i, j) != (j, i) by description\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570408,
                "title": "python-o-n-solution-better-than-70",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        uniqueNums, noOfBitsOfNums, suffix = set(nums), [0] * 32, [0] * 32\\n        for num in uniqueNums:\\n            noOfBitsOfNums[bin(num).count(\\'1\\')] += 1\\n        accumulate, ans = 0, 0\\n        for i in range(31, -1, -1):\\n            accumulate += noOfBitsOfNums[i]\\n            suffix[i] = accumulate\\n        for i in range(1, 32):\\n            if k - i >= 32:\\n                continue\\n            if k - i < 1:\\n                ans += suffix[1] * noOfBitsOfNums[i]\\n            else:\\n                ans += suffix[k - i] * noOfBitsOfNums[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        uniqueNums, noOfBitsOfNums, suffix = set(nums), [0] * 32, [0] * 32\\n        for num in uniqueNums:\\n            noOfBitsOfNums[bin(num).count(\\'1\\')] += 1\\n        accumulate, ans = 0, 0\\n        for i in range(31, -1, -1):\\n            accumulate += noOfBitsOfNums[i]\\n            suffix[i] = accumulate\\n        for i in range(1, 32):\\n            if k - i >= 32:\\n                continue\\n            if k - i < 1:\\n                ans += suffix[1] * noOfBitsOfNums[i]\\n            else:\\n                ans += suffix[k - i] * noOfBitsOfNums[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500484,
                "title": "java-javascript-golang-o-n-time-o-n-space-with-explanation",
                "content": "#### **Intuition:**\\n***We don\\'t need to calculate each pair separately***\\nIf we try to calculate, for each pair, `bits(a AND b) + bits(a OR b)`, it is going to take us O(n\\xB2) to do it and we are going to run out of time. Fortunately, we don\\'t need to do it: `bits(a OR b) = bits(a) + bits(b) - bits(a AND b)` (the bits of each number minus those we counted twice), and therefore, for each pair:\\n\\n```bits(a AND b) + bits(a OR b) = bits(a AND b) + bits(a) + bits(b) - bits(a AND b) = bits(a) + bits(b)```\\n<br>\\n![image](https://assets.leetcode.com/users/images/7186dfc2-abcc-4e11-af7d-91b97d096bde_1661797225.3014474.gif)\\n\\n\\n***Nums contains duplicates***\\nWe can maintain a Set of numbers already present and create a new array `arr` where we add every new number.\\n\\n***Once we have converted the array to bit amounts, we can use a two-pointer strategy to move from O(n\\xB2) towards O(n log n)***\\nIf the set doesn\\'t contain the number, we just add `bits(number)` to `arr`. All of this takes us [ O(n) ] time. Then we sort [ O(n log n) ] and use the two pointers strategy [ O(n) ].\\n\\n***We don\\'t care about the actual numbers, only the amount of \"1\\'s\". We can exploit this to optimize the solution towards O(n) time***\\nInstead of adding `bits(number)` to the array as a new element, we can count how many distinct elements of `nums` have that many bits. `arr` will have, then, size 31, and for each unique element of nums, `arr[bits(number)]++`. Then the rest will be [ O(1) ] whatever the strategy we choose, and we can brute-force the solution (31x31 calculations => O(1)), or we can use two pointers, or we can use an inverse prefix-sum calculation since the problem asks for `bits(a) + bits(b) >= k` and not just ` == k`\\n\\nWith this strategy we avoid having to sort anything.\\n\\n***This problem asks us for a long***\\n...but we mostly don\\'t really care about that and can just add up the solution into a long at the end\\n\\n***As a general rule we need to care for the corner cases AKA the case where a == b***\\nHere, fortunately, it sorts itself out with no additional code :)\\n\\n#### **Solution**\\n**Java**\\n```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        \\n        Set<Integer> uniques = new HashSet();\\n        int[] arr = new int[32]; // first element is unused, but it makes for code that is a bit cleaner\\n        \\n        for( int num : nums ) {\\n            if(!uniques.contains(num)) {\\n                uniques.add(num);\\n                arr[bits(num)]++;\\n            }\\n        }\\n        \\n        int acc = 0;\\n        int[] suffix = new int[32];\\n        for(int i = arr.length - 1; i >= 0; i--) {\\n            acc += arr[i];\\n            suffix[i] = acc;\\n        }\\n        \\n        long ans = 0; // This is a long\\n        \\n        for(int i = 1; i < 32; i++) {\\n            \\n            if(k - i >= 32) {\\n                continue;\\n            }\\n            if(k - i < 1) {\\n                ans += arr[i] * suffix[1];\\n            } else {\\n                ans += arr[i] * suffix[k - i];\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int bits(int num) {\\n        int ans = 0;\\n        while(num > 0) {\\n            if(num%2 != 0) {\\n                ans++;\\n            }\\n            num/=2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar countExcellentPairs = function(nums, k) {\\n    let uniques = new Set();\\n    let arr = new Array(32);\\n    arr.fill(0);\\n    \\n    for( let num of nums ) {\\n        if(uniques.has(num)) continue;\\n        uniques.add(num);\\n        arr[bits(num)]++;\\n    }\\n    \\n    let acc = 0;\\n    let suffix = new Array(32);\\n    \\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        acc += arr[i];\\n        suffix[i] = acc;\\n    }\\n    \\n    let ans = 0;\\n        \\n    for(let i = 1; i < 32; i++) {\\n\\n        if(k - i >= 32) {\\n            continue;\\n        }\\n        if(k - i < 1) {\\n            ans += arr[i] * suffix[1];\\n        } else {\\n            ans += arr[i] * suffix[k - i];\\n        }\\n\\n    }\\n        \\n    return ans;\\n};\\n    \\nfunction bits(num) {\\n    let ans = 0;\\n    while(num > 0) {\\n        if(num%2 != 0) {\\n            ans++;\\n        }\\n        num>>=1;\\n    }\\n\\n    return ans;\\n};\\n```\\n**Golang**\\n```\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n    uniques := make(map[int]bool)\\n    arr := make([]int, 32)\\n    \\n    for _, v := range nums {\\n        if _, ok := uniques[v]; !ok {\\n            uniques[v] = true\\n            arr[bits(v)]++\\n        }\\n    }\\n    \\n    acc := 0\\n    suffix := make([]int, 32)\\n    \\n    for i := 31; i >= 0; i-- {\\n        acc += arr[i]\\n        suffix[i] = acc\\n    }\\n    \\n    var ans int64 = 0\\n    \\n    for i := range arr {\\n        if(k - i >= 32) {\\n            continue\\n        }\\n        if(k - i < 1) {\\n            ans += int64(arr[i] * suffix[1])\\n        } else {\\n            ans += int64(arr[i] * suffix[k - i])\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc bits(num int) int {\\n    ans := 0\\n    for num > 0 {\\n        if num%2 != 0 {\\n            ans++\\n        }\\n        num /= 2\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Go"
                ],
                "code": "```bits(a AND b) + bits(a OR b) = bits(a AND b) + bits(a) + bits(b) - bits(a AND b) = bits(a) + bits(b)```\n```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        \\n        Set<Integer> uniques = new HashSet();\\n        int[] arr = new int[32]; // first element is unused, but it makes for code that is a bit cleaner\\n        \\n        for( int num : nums ) {\\n            if(!uniques.contains(num)) {\\n                uniques.add(num);\\n                arr[bits(num)]++;\\n            }\\n        }\\n        \\n        int acc = 0;\\n        int[] suffix = new int[32];\\n        for(int i = arr.length - 1; i >= 0; i--) {\\n            acc += arr[i];\\n            suffix[i] = acc;\\n        }\\n        \\n        long ans = 0; // This is a long\\n        \\n        for(int i = 1; i < 32; i++) {\\n            \\n            if(k - i >= 32) {\\n                continue;\\n            }\\n            if(k - i < 1) {\\n                ans += arr[i] * suffix[1];\\n            } else {\\n                ans += arr[i] * suffix[k - i];\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int bits(int num) {\\n        int ans = 0;\\n        while(num > 0) {\\n            if(num%2 != 0) {\\n                ans++;\\n            }\\n            num/=2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nvar countExcellentPairs = function(nums, k) {\\n    let uniques = new Set();\\n    let arr = new Array(32);\\n    arr.fill(0);\\n    \\n    for( let num of nums ) {\\n        if(uniques.has(num)) continue;\\n        uniques.add(num);\\n        arr[bits(num)]++;\\n    }\\n    \\n    let acc = 0;\\n    let suffix = new Array(32);\\n    \\n    for(let i = arr.length - 1; i >= 0; i--) {\\n        acc += arr[i];\\n        suffix[i] = acc;\\n    }\\n    \\n    let ans = 0;\\n        \\n    for(let i = 1; i < 32; i++) {\\n\\n        if(k - i >= 32) {\\n            continue;\\n        }\\n        if(k - i < 1) {\\n            ans += arr[i] * suffix[1];\\n        } else {\\n            ans += arr[i] * suffix[k - i];\\n        }\\n\\n    }\\n        \\n    return ans;\\n};\\n    \\nfunction bits(num) {\\n    let ans = 0;\\n    while(num > 0) {\\n        if(num%2 != 0) {\\n            ans++;\\n        }\\n        num>>=1;\\n    }\\n\\n    return ans;\\n};\\n```\n```\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n    uniques := make(map[int]bool)\\n    arr := make([]int, 32)\\n    \\n    for _, v := range nums {\\n        if _, ok := uniques[v]; !ok {\\n            uniques[v] = true\\n            arr[bits(v)]++\\n        }\\n    }\\n    \\n    acc := 0\\n    suffix := make([]int, 32)\\n    \\n    for i := 31; i >= 0; i-- {\\n        acc += arr[i]\\n        suffix[i] = acc\\n    }\\n    \\n    var ans int64 = 0\\n    \\n    for i := range arr {\\n        if(k - i >= 32) {\\n            continue\\n        }\\n        if(k - i < 1) {\\n            ans += int64(arr[i] * suffix[1])\\n        } else {\\n            ans += int64(arr[i] * suffix[k - i])\\n        }\\n    }\\n    \\n    return ans\\n}\\n\\nfunc bits(num int) int {\\n    ans := 0\\n    for num > 0 {\\n        if num%2 != 0 {\\n            ans++\\n        }\\n        num /= 2\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477515,
                "title": "java-hashset-prefix-count-array-o-n-time-90-faster",
                "content": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] count = new int[32];  // count[i] denotes count of numbers with no. of set bits i.\\n        Set<Integer> unique = new HashSet<>();\\n        for(int num:nums){\\n            if(unique.contains(num)) continue;\\n            count[noOfSetBits(num)]++;\\n            unique.add(num);\\n        }\\n        for(int i=1;i<32;i++){\\n            count[i] += count[i-1];  // Prefix array calculation for count. \\n        }\\n        // System.out.println(Arrays.toString(count));\\n        long ans = 0;\\n        for(int num:unique){\\n            int target = Math.max(1,k - noOfSetBits(num));\\n            if(target > 32){\\n                continue;\\n            }\\n            ans += count[31] - count[target-1];\\n        }\\n        \\n        return ans;\\n    }\\n    private int noOfSetBits(int n){\\n        int c = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] count = new int[32];  // count[i] denotes count of numbers with no. of set bits i.\\n        Set<Integer> unique = new HashSet<>();\\n        for(int num:nums){\\n            if(unique.contains(num)) continue;\\n            count[noOfSetBits(num)]++;\\n            unique.add(num);\\n        }\\n        for(int i=1;i<32;i++){\\n            count[i] += count[i-1];  // Prefix array calculation for count. \\n        }\\n        // System.out.println(Arrays.toString(count));\\n        long ans = 0;\\n        for(int num:unique){\\n            int target = Math.max(1,k - noOfSetBits(num));\\n            if(target > 32){\\n                continue;\\n            }\\n            ans += count[31] - count[target-1];\\n        }\\n        \\n        return ans;\\n    }\\n    private int noOfSetBits(int n){\\n        int c = 0;\\n        while(n!=0){\\n            n = n&(n-1);\\n            c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395002,
                "title": "python-counting",
                "content": "```class Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        \\n        def count(n,ans):\\n            i = 0\\n            while n:\\n                if n&1:\\n                    i+=1\\n                n >>= 1\\n            if 2*i >= k:\\n                ans[0] += 1\\n            return i\\n        nums = set(nums)\\n        bits = []\\n        ans = [0]\\n        for i in nums:\\n            bits += [count(i,ans)]\\n        i = 0\\n        e = len(bits)-1\\n        bits.sort()\\n        while i < e:\\n            if bits[i]+bits[e] >= k:\\n                ans[0] += (e-i)*2\\n                e -= 1\\n            else:\\n                i += 1\\n        \\n        return ans[0]\\n        \\n                \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        \\n        def count(n,ans):\\n            i = 0\\n            while n:\\n                if n&1:\\n                    i+=1\\n                n >>= 1\\n            if 2*i >= k:\\n                ans[0] += 1\\n            return i\\n        nums = set(nums)\\n        bits = []\\n        ans = [0]\\n        for i in nums:\\n            bits += [count(i,ans)]\\n        i = 0\\n        e = len(bits)-1\\n        bits.sort()\\n        while i < e:\\n            if bits[i]+bits[e] >= k:\\n                ans[0] += (e-i)*2\\n                e -= 1\\n            else:\\n                i += 1\\n        \\n        return ans[0]\\n        \\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 2393807,
                "title": "python-go-bit-manipulation-w-hashmap-o-n-vs-binary-search-o-nlogn",
                "content": "*Python* solution w/ hashmap\\n\\n```python\\ndef countExcellentPairs(self, nums, k):                                              # O(N): 1liner\\n    return sum(\\n        x * y\\n        for (i, x), (j, y) in itertools.product(collections.Counter(map(int.bit_count, set(nums))).items(), repeat=2)\\n        if i + j >= k\\n    )\\n\\n\\ndef countExcellentPairs(self, nums, k):                                              # O(N)\\n    C = collections.Counter(map(int.bit_count, set(nums)))                           # O(N)\\n    return sum(C[i] * C[j] for i, j in itertools.product(C, repeat=2) if i + j >= k) # O(1): len(C) < 32\\n```\\n\\n*Python* solution w/ binary search\\n\\n```python\\ndef countExcellentPairs(self, nums, k):                                              # O(NlogN)\\n    A = sorted(map(int.bit_count, set(nums)))                                        # O(NlogN)\\n    return sum(len(A) - bisect.bisect_left(A, k - x) for x in A)                     # O(NlogN)\\n```\\n\\n*Go* solution w/ hashmap in 149ms\\n\\n```go\\ntype none struct{}\\n\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n\\tvar (\\n\\t\\tres  int64\\n\\t\\tC    = make(map[int]int)\\n\\t\\tuniq = make(map[int]none)\\n\\t)\\n\\tfor _, num := range nums {\\n\\t\\tif _, ok := uniq[num]; !ok {\\n\\t\\t\\tuniq[num] = none{}\\n\\t\\t\\tk := bits.OnesCount(uint(num))\\n\\t\\t\\tif _, ok := C[k]; ok {\\n\\t\\t\\t\\tC[k]++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tC[k] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor i, x := range C {\\n\\t\\tfor j, y := range C {\\n\\t\\t\\tif i+j >= k {\\n\\t\\t\\t\\tres += int64(x * y)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef countExcellentPairs(self, nums, k):                                              # O(N): 1liner\\n    return sum(\\n        x * y\\n        for (i, x), (j, y) in itertools.product(collections.Counter(map(int.bit_count, set(nums))).items(), repeat=2)\\n        if i + j >= k\\n    )\\n\\n\\ndef countExcellentPairs(self, nums, k):                                              # O(N)\\n    C = collections.Counter(map(int.bit_count, set(nums)))                           # O(N)\\n    return sum(C[i] * C[j] for i, j in itertools.product(C, repeat=2) if i + j >= k) # O(1): len(C) < 32\\n```\n```python\\ndef countExcellentPairs(self, nums, k):                                              # O(NlogN)\\n    A = sorted(map(int.bit_count, set(nums)))                                        # O(NlogN)\\n    return sum(len(A) - bisect.bisect_left(A, k - x) for x in A)                     # O(NlogN)\\n```\n```go\\ntype none struct{}\\n\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n\\tvar (\\n\\t\\tres  int64\\n\\t\\tC    = make(map[int]int)\\n\\t\\tuniq = make(map[int]none)\\n\\t)\\n\\tfor _, num := range nums {\\n\\t\\tif _, ok := uniq[num]; !ok {\\n\\t\\t\\tuniq[num] = none{}\\n\\t\\t\\tk := bits.OnesCount(uint(num))\\n\\t\\t\\tif _, ok := C[k]; ok {\\n\\t\\t\\t\\tC[k]++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tC[k] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor i, x := range C {\\n\\t\\tfor j, y := range C {\\n\\t\\t\\tif i+j >= k {\\n\\t\\t\\t\\tres += int64(x * y)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2392918,
                "title": "o-1-space-n-log-n-log-n-yes-just-using-5-variables-with-proof",
                "content": "\\\\#OR + \\\\#AND = (\\\\#one + \\\\#two -common_bits)+common_bits= \\\\#one + \\\\#two \\n(\\\\#=no of bits)\\n```\\nas\\n#OR= (#one + #two -common_bits)\\n```\\n\\n```\\nlong long countExcellentPairs(vector<int>&a, int k) {\\n        sort(a.begin(),a.end());\\n        auto itr=unique(a.begin(),a.end());\\n        a.resize(itr-a.begin());\\n        sort(a.begin(),a.end(),\\n             [](int x,int y){return __builtin_popcount(x)<__builtin_popcount(y);});\\n        long long  ans=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(__builtin_popcount(a[i])>=k){ans++;ans+=2*((int)a.size()-i-1);continue;}\\n            if(2*__builtin_popcount(a[i])>=k)ans++;\\n            int l=i+1,r=(int)a.size()-1,target=k-__builtin_popcount(a[i]);\\n            if(target>__builtin_popcount(a.back()))continue;\\n            while(l<r)\\n            {\\n                int m=l+(r-l)/2;\\n                if(__builtin_popcount(a[m])>=target)\\n                    r=m;\\n                else l=m+1;\\n            }\\n            ans+=2*((int)a.size()-l);\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nas\\n#OR= (#one + #two -common_bits)\\n```\n```\\nlong long countExcellentPairs(vector<int>&a, int k) {\\n        sort(a.begin(),a.end());\\n        auto itr=unique(a.begin(),a.end());\\n        a.resize(itr-a.begin());\\n        sort(a.begin(),a.end(),\\n             [](int x,int y){return __builtin_popcount(x)<__builtin_popcount(y);});\\n        long long  ans=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(__builtin_popcount(a[i])>=k){ans++;ans+=2*((int)a.size()-i-1);continue;}\\n            if(2*__builtin_popcount(a[i])>=k)ans++;\\n            int l=i+1,r=(int)a.size()-1,target=k-__builtin_popcount(a[i]);\\n            if(target>__builtin_popcount(a.back()))continue;\\n            while(l<r)\\n            {\\n                int m=l+(r-l)/2;\\n                if(__builtin_popcount(a[m])>=target)\\n                    r=m;\\n                else l=m+1;\\n            }\\n            ans+=2*((int)a.size()-l);\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2392441,
                "title": "java-45-ms-faster-than-98-27-less-than-97-85",
                "content": "EX: Two integers, a = 17, b = 24\\n\\na = 10001 -> 2 bits\\nb = 11000 -> 2 bits\\n\\nor = a | b = 11001 -> 3 bits, exist at least onnce\\nand = a & b = 10000 -> 1 bit, exist twice, represents the duplictaed 1\\'s bit\\n\\nor + and = a + b\\n-> Just need to group numbers by number of bits and count the bit sum over K\\n\\n```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        int maxDigits = Math.min(k, 30);\\n        // digits -> number of dist num\\n        int[] counts = new int[maxDigits+1];\\n        // dist num\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (!set.add(num)) continue;\\n            int temp = num;\\n            int count = 0;\\n            while (num > 0) {\\n                count += num & 1;\\n                num >>= 1;\\n            }\\n            count = Math.min(maxDigits, count);\\n            counts[count]++;\\n        }\\n        \\n        \\n        long pairs = 0;\\n        for (int i = 1; i <= maxDigits; i++) {\\n            int start = Math.max(i, k-i);\\n            for (int j = start; j <= maxDigits; j++) pairs += i == j ? (long) counts[i]*counts[j] : 2* (long)counts[i]*counts[j];\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        int maxDigits = Math.min(k, 30);\\n        // digits -> number of dist num\\n        int[] counts = new int[maxDigits+1];\\n        // dist num\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (!set.add(num)) continue;\\n            int temp = num;\\n            int count = 0;\\n            while (num > 0) {\\n                count += num & 1;\\n                num >>= 1;\\n            }\\n            count = Math.min(maxDigits, count);\\n            counts[count]++;\\n        }\\n        \\n        \\n        long pairs = 0;\\n        for (int i = 1; i <= maxDigits; i++) {\\n            int start = Math.max(i, k-i);\\n            for (int j = start; j <= maxDigits; j++) pairs += i == j ? (long) counts[i]*counts[j] : 2* (long)counts[i]*counts[j];\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368991,
                "title": "c-o-n-count-bits",
                "content": "```\\nCountBits( nums[x] & nums[y] ) + CountBits( nums[x] | nums[y] ) can be simplified to CountBits( nums[x] ) + CountBits( nums[y] )\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> count(33, 0), mp;\\n        unordered_map<int, int> is;\\n        long long res=0;\\n        for(auto num: nums)\\n        {\\n            if(is[num])\\n                continue;\\n            is[num]=1;\\n            int bits=0;\\n            for(int i=0; i<32; i++)\\n                if((1<<i)&num)\\n                    bits++;\\n            count[bits]++;\\n            mp.push_back(bits);\\n        }\\n        for(int i=31; i>=0; i--)\\n            count[i]+=count[i+1];\\n        for(int i=0; i<mp.size(); i++)\\n        {\\n            if(k-mp[i]<=0)\\n                res+=(long long)count[0];\\n            else if(k-mp[i]<=32)\\n                res+=(long long)count[k-mp[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nCountBits( nums[x] & nums[y] ) + CountBits( nums[x] | nums[y] ) can be simplified to CountBits( nums[x] ) + CountBits( nums[y] )\\n```\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> count(33, 0), mp;\\n        unordered_map<int, int> is;\\n        long long res=0;\\n        for(auto num: nums)\\n        {\\n            if(is[num])\\n                continue;\\n            is[num]=1;\\n            int bits=0;\\n            for(int i=0; i<32; i++)\\n                if((1<<i)&num)\\n                    bits++;\\n            count[bits]++;\\n            mp.push_back(bits);\\n        }\\n        for(int i=31; i>=0; i--)\\n            count[i]+=count[i+1];\\n        for(int i=0; i<mp.size(); i++)\\n        {\\n            if(k-mp[i]<=0)\\n                res+=(long long)count[0];\\n            else if(k-mp[i]<=32)\\n                res+=(long long)count[k-mp[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368965,
                "title": "python-count-bits",
                "content": "One key concept: a|b + a&b = a\\'s set bit count + b\\'s set bit counts\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums = list(set(nums)) # return a list with unique values\\n        n = len(nums)\\n        for i in range(n):\\n            nums[i] = nums[i].bit_count() # replace each element with the number of bits it have\\n        nums.sort()\\n        res = 0\\n        for i in nums:\\n            idx = bisect.bisect_left(nums, k - i) # find how many elements with at least k - i set bits\\n            res += (n - idx) \\n        return res\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums = list(set(nums)) # return a list with unique values\\n        n = len(nums)\\n        for i in range(n):\\n            nums[i] = nums[i].bit_count() # replace each element with the number of bits it have\\n        nums.sort()\\n        res = 0\\n        for i in nums:\\n            idx = bisect.bisect_left(nums, k - i) # find how many elements with at least k - i set bits\\n            res += (n - idx) \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365984,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        count = [0]*30\\n        res = 0\\n        for elem in set(nums):\\n            count[elem.bit_count()] += 1\\n        s = sum(count[k:])\\n        for i in range(len(count)):\\n            res += count[i]*s\\n            if 0<=k-1-i<30:\\n                s += count[k-1-i]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        count = [0]*30\\n        res = 0\\n        for elem in set(nums):\\n            count[elem.bit_count()] += 1\\n        s = sum(count[k:])\\n        for i in range(len(count)):\\n            res += count[i]*s\\n            if 0<=k-1-i<30:\\n                s += count[k-1-i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355861,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        # sort bits, remove duplicated numbers:\\n        new_nums = set()\\n        for n in nums:\\n            new_nums.add(n)\\n            \\n        freq = defaultdict(int)\\n        bits = []\\n        for n in new_nums:\\n            x = self.numToBits(n)\\n            freq[x] += 1\\n            if freq[x] == 1:\\n                bits.append(x)\\n        bits = sorted(bits)\\n        \\n        # count how many different numbers are there greater than bits[i]\\n        postsum = [0]*len(bits)\\n        i = len(bits)-1\\n        postsum[i] = freq[bits[i]]\\n        i -= 1\\n        while i>=0:\\n            postsum[i] = postsum[i+1] + freq[bits[i]]\\n            i -= 1\\n        \\n        ans = 0\\n        # use two pointers to find if bits[left] + bits[right] >= k\\n        c = 0\\n        left = 0\\n        right = len(bits)-1\\n        while (left<len(bits)) & (right>=0):\\n            if bits[left] + bits[right] >= k:\\n                ans += freq[bits[left]] * (c + freq[bits[right]])\\n                right -= 1\\n                c = 0\\n            else:\\n                left += 1\\n                if right<len(bits)-1:\\n                    right += 1\\n                c = postsum[right] - freq[bits[right]]\\n        if right==-1:\\n            if left<len(bits)-1:\\n                ans += postsum[left+1] * postsum[0]\\n        return ans\\n        \\n    def numToBits(self, num: int) -> int:\\n        ans = 0\\n        while num>0:\\n            ans += num%2\\n            num = num//2\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        # sort bits, remove duplicated numbers:\\n        new_nums = set()\\n        for n in nums:\\n            new_nums.add(n)\\n            \\n        freq = defaultdict(int)\\n        bits = []\\n        for n in new_nums:\\n            x = self.numToBits(n)\\n            freq[x] += 1\\n            if freq[x] == 1:\\n                bits.append(x)\\n        bits = sorted(bits)\\n        \\n        # count how many different numbers are there greater than bits[i]\\n        postsum = [0]*len(bits)\\n        i = len(bits)-1\\n        postsum[i] = freq[bits[i]]\\n        i -= 1\\n        while i>=0:\\n            postsum[i] = postsum[i+1] + freq[bits[i]]\\n            i -= 1\\n        \\n        ans = 0\\n        # use two pointers to find if bits[left] + bits[right] >= k\\n        c = 0\\n        left = 0\\n        right = len(bits)-1\\n        while (left<len(bits)) & (right>=0):\\n            if bits[left] + bits[right] >= k:\\n                ans += freq[bits[left]] * (c + freq[bits[right]])\\n                right -= 1\\n                c = 0\\n            else:\\n                left += 1\\n                if right<len(bits)-1:\\n                    right += 1\\n                c = postsum[right] - freq[bits[right]]\\n        if right==-1:\\n            if left<len(bits)-1:\\n                ans += postsum[left+1] * postsum[0]\\n        return ans\\n        \\n    def numToBits(self, num: int) -> int:\\n        ans = 0\\n        while num>0:\\n            ans += num%2\\n            num = num//2\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2355640,
                "title": "most-simplest-and-easy-to-understand-solution-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n// To count number of set bits in a integer\\n    int sb(int x){\\n        int nsb=0;\\n        while(x!=0){\\n            if(x%2==1){\\n                nsb++;\\n            }\\n            x = x/2;\\n        }\\n        return nsb;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        \\n        vector<int> num2;\\n        set<int> st;\\n\\t\\t// Removing the duplicates\\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n        }\\n        nums.clear();\\n        for(auto i:st){\\n            nums.push_back(i);\\n        }\\n\\t\\t// Storing the set bits of each number in a vector\\n        for(int i=0;i<nums.size();i++){\\n            int x = sb(nums[i]);\\n            num2.push_back(x);\\n        }\\n        int n = nums.size();\\n\\t\\t// Sort the vector containing set bits\\n        sort(num2.begin(),num2.end());\\n        long long ans=0;\\n        for(int i=0;i<num2.size();i++){\\n            \\n            int x = num2[i];\\n            int y = k-num2[i];\\n            int idx = lower_bound(num2.begin(),num2.end(),y)-num2.begin();\\n            ans += n - idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// To count number of set bits in a integer\\n    int sb(int x){\\n        int nsb=0;\\n        while(x!=0){\\n            if(x%2==1){\\n                nsb++;\\n            }\\n            x = x/2;\\n        }\\n        return nsb;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        \\n        vector<int> num2;\\n        set<int> st;\\n\\t\\t// Removing the duplicates\\n        for(int i=0;i<nums.size();i++){\\n            st.insert(nums[i]);\\n        }\\n        nums.clear();\\n        for(auto i:st){\\n            nums.push_back(i);\\n        }\\n\\t\\t// Storing the set bits of each number in a vector\\n        for(int i=0;i<nums.size();i++){\\n            int x = sb(nums[i]);\\n            num2.push_back(x);\\n        }\\n        int n = nums.size();\\n\\t\\t// Sort the vector containing set bits\\n        sort(num2.begin(),num2.end());\\n        long long ans=0;\\n        for(int i=0;i<num2.size();i++){\\n            \\n            int x = num2[i];\\n            int y = k-num2[i];\\n            int idx = lower_bound(num2.begin(),num2.end(),y)-num2.begin();\\n            ans += n - idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354899,
                "title": "c-solution-using-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long sol = 0;\\n        set<int> num;\\n        for (int i : nums) num.insert(i);\\n        vector<long long> bitFreq(31);\\n        for (int i : num) {\\n            int bit = __builtin_popcount(i);\\n            ++bitFreq[bit];\\n        }\\n        for (int i = 29; i >= 0; i--) {\\n            bitFreq[i] += bitFreq[i + 1];\\n        }\\n        for (int i : num) {\\n            int bit = __builtin_popcount(i);\\n            int need = max(0, k - bit);\\n            if (need <= 30)\\n                sol += bitFreq[need];\\n        }\\n        return sol;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long sol = 0;\\n        set<int> num;\\n        for (int i : nums) num.insert(i);\\n        vector<long long> bitFreq(31);\\n        for (int i : num) {\\n            int bit = __builtin_popcount(i);\\n            ++bitFreq[bit];\\n        }\\n        for (int i = 29; i >= 0; i--) {\\n            bitFreq[i] += bitFreq[i + 1];\\n        }\\n        for (int i : num) {\\n            int bit = __builtin_popcount(i);\\n            int need = max(0, k - bit);\\n            if (need <= 30)\\n                sol += bitFreq[need];\\n        }\\n        return sol;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350753,
                "title": "c-easy-to-understand-brute-force-and-optimized",
                "content": "```\\nint setbits(int n){\\n        int cnt = 0;\\n        while(n){\\n            cnt += (n%2);\\n            n /= 2;\\n        }\\n        return cnt;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        set<int>s;\\n        vector<int>num;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        for(auto x:s){\\n            num.push_back(x);\\n        }\\n        for(int i=0;i<num.size();i++){\\n            int ors=0,ands=0;\\n            for(int j=0;j<num.size();j++){\\n                ors=num[i] | num[j];\\n                ands=num[i] & num[j];\\n                if(setbits(ors)+setbits(ands)>=k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n//OPTIMIZED\\n```\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int>s(nums.begin(),nums.end());\\n        vector<int>vc;\\n        long long ans=0;\\n        for(auto i=s.begin();i!=s.end();i++){\\n            vc.push_back(countbits(*i,ans,k));\\n        }\\n        sort(vc.begin(),vc.end());\\n        int lo=0,hi=vc.size()-1;\\n        while(lo<hi){\\n            if(vc[lo]+vc[hi]>=k){\\n                ans+=(hi-lo)*2;\\n                hi--;\\n            }\\n            else{\\n                lo++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int countbits(int n ,long long &ans,int k){\\n        int count=0;\\n        while(n){\\n            count+=n%2;\\n            n/=2;\\n        }\\n        if(2*count>=k)ans++;\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint setbits(int n){\\n        int cnt = 0;\\n        while(n){\\n            cnt += (n%2);\\n            n /= 2;\\n        }\\n        return cnt;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans=0;\\n        set<int>s;\\n        vector<int>num;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n        }\\n        for(auto x:s){\\n            num.push_back(x);\\n        }\\n        for(int i=0;i<num.size();i++){\\n            int ors=0,ands=0;\\n            for(int j=0;j<num.size();j++){\\n                ors=num[i] | num[j];\\n                ands=num[i] & num[j];\\n                if(setbits(ors)+setbits(ands)>=k){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\nlong long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int>s(nums.begin(),nums.end());\\n        vector<int>vc;\\n        long long ans=0;\\n        for(auto i=s.begin();i!=s.end();i++){\\n            vc.push_back(countbits(*i,ans,k));\\n        }\\n        sort(vc.begin(),vc.end());\\n        int lo=0,hi=vc.size()-1;\\n        while(lo<hi){\\n            if(vc[lo]+vc[hi]>=k){\\n                ans+=(hi-lo)*2;\\n                hi--;\\n            }\\n            else{\\n                lo++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int countbits(int n ,long long &ans,int k){\\n        int count=0;\\n        while(n){\\n            count+=n%2;\\n            n/=2;\\n        }\\n        if(2*count>=k)ans++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2344815,
                "title": "python-sorting-and-2-pointer-o-nlogn",
                "content": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        st = list(set(nums))\\n        \\n        pp = []\\n        for n in st: # O(n)\\n            pp.append(n.bit_count())\\n        \\n        pp.sort(reverse=True) # O(nlogn)\\n        \\n        i = 0\\n        j = len(pp) - 1\\n        \\n        ans = 0\\n        while i <= j: # O(n)\\n            while j >= i and pp[j] + pp[i] < k:\\n                j -=1\\n            \\n            if j >= i:\\n                ans += (2 * (j - i + 1) - 1)\\n            \\n            i +=1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        st = list(set(nums))\\n        \\n        pp = []\\n        for n in st: # O(n)\\n            pp.append(n.bit_count())\\n        \\n        pp.sort(reverse=True) # O(nlogn)\\n        \\n        i = 0\\n        j = len(pp) - 1\\n        \\n        ans = 0\\n        while i <= j: # O(n)\\n            while j >= i and pp[j] + pp[i] < k:\\n                j -=1\\n            \\n            if j >= i:\\n                ans += (2 * (j - i + 1) - 1)\\n            \\n            i +=1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343939,
                "title": "c-builtin-popcount",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n\\t\\tunordered_set<int> st;\\n\\t\\tfor (int &x: nums) {\\n\\t\\t\\tst.insert(x);\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t    \\n        nums.clear();\\n        for (const int &x: st) {\\n\\t\\t\\tnums.push_back(__builtin_popcount(x));\\n\\t\\t}\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tauto get = [&](int x) {\\n\\t\\t\\tint t = k - x;\\n\\t\\t\\tint lo = 0, hi = (int) nums.size() - 1;\\n\\t\\t\\twhile (lo < hi) {\\n\\t\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\t\\tif (nums[mid] >= t) hi = mid;\\n\\t\\t\\t\\telse lo = mid + 1;\\n\\t\\t\\t}\\n            \\n\\t\\t\\tif (nums[lo] < t) {\\n                return 0;\\n            }\\n\\t\\t\\treturn (int) nums.size() - lo;\\n\\t\\t};\\n\\t\\tfor (int &x: nums) ans += get(x);\\n\\t\\treturn ans;\\n    } \\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n\\t\\tunordered_set<int> st;\\n\\t\\tfor (int &x: nums) {\\n\\t\\t\\tst.insert(x);\\n\\t\\t}\\n\\t\\tlong long ans = 0;\\n\\t    \\n        nums.clear();\\n        for (const int &x: st) {\\n\\t\\t\\tnums.push_back(__builtin_popcount(x));\\n\\t\\t}\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tauto get = [&](int x) {\\n\\t\\t\\tint t = k - x;\\n\\t\\t\\tint lo = 0, hi = (int) nums.size() - 1;\\n\\t\\t\\twhile (lo < hi) {\\n\\t\\t\\t\\tint mid = lo + (hi - lo) / 2;\\n\\t\\t\\t\\tif (nums[mid] >= t) hi = mid;\\n\\t\\t\\t\\telse lo = mid + 1;\\n\\t\\t\\t}\\n            \\n\\t\\t\\tif (nums[lo] < t) {\\n                return 0;\\n            }\\n\\t\\t\\treturn (int) nums.size() - lo;\\n\\t\\t};\\n\\t\\tfor (int &x: nums) ans += get(x);\\n\\t\\treturn ans;\\n    } \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341399,
                "title": "python-number-of-1-bits-easy-and-clean-code-o-nlogn",
                "content": "sum of set bits of (num1 or num2) and (num1 and num2) is same as the number of 1-bits in num1 and num2.\\nSo we count the number of 1-bits in each number.\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums = set(nums)\\n        nums = sorted([bin(num).count(\\'1\\') for num in nums])\\n        n = len(nums)\\n        j = n - 1\\n        res = 0\\n        for i in range(n):\\n            while j >= 0 and nums[i]+nums[j] >= k:\\n                j -= 1\\n            res += n-1-j\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "sum of set bits of (num1 or num2) and (num1 and num2) is same as the number of 1-bits in num1 and num2.\\nSo we count the number of 1-bits in each number.\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        nums = set(nums)\\n        nums = sorted([bin(num).count(\\'1\\') for num in nums])\\n        n = len(nums)\\n        j = n - 1\\n        res = 0\\n        for i in range(n):\\n            while j >= 0 and nums[i]+nums[j] >= k:\\n                j -= 1\\n            res += n-1-j\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2341067,
                "title": "easy-faster-efficient-java-soln",
                "content": "```\\nclass Solution {\\n    private int countSetBits(int n){\\n        int count = 0;\\n        while(n != 0){\\n            int rsbm = (n & (-n));\\n            n = (n - rsbm);\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    private int binarySearch(List<Integer> al, int hi, int x){\\n        int lo = 0;\\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(al.get(mid) >= x){\\n                ans = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int val : nums){\\n            set.add(val);\\n        }\\n        int [] arr = new int[set.size()];\\n        int c = 0;\\n        for(int val : set){\\n            // System.out.print(val + \" \");\\n            arr[c++] = val;\\n        }\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int val : arr){\\n            int setBits = countSetBits(val);\\n            list.add(setBits);\\n        }\\n        Collections.sort(list);\\n        long ans = 0;\\n        \\n        for(int i = 0; i < list.size(); i++){\\n            int val = list.get(i);\\n            if(val >= k){\\n                ans += i * 2 + 1;\\n            } else {\\n                int idx = binarySearch(list, i, k - val);\\n                if(idx != -1){\\n                    ans = ans + (i - idx) * 2 + 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int countSetBits(int n){\\n        int count = 0;\\n        while(n != 0){\\n            int rsbm = (n & (-n));\\n            n = (n - rsbm);\\n            count++;\\n        }\\n        return count;\\n    }\\n    \\n    private int binarySearch(List<Integer> al, int hi, int x){\\n        int lo = 0;\\n        int ans = -1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if(al.get(mid) >= x){\\n                ans = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public long countExcellentPairs(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int val : nums){\\n            set.add(val);\\n        }\\n        int [] arr = new int[set.size()];\\n        int c = 0;\\n        for(int val : set){\\n            // System.out.print(val + \" \");\\n            arr[c++] = val;\\n        }\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int val : arr){\\n            int setBits = countSetBits(val);\\n            list.add(setBits);\\n        }\\n        Collections.sort(list);\\n        long ans = 0;\\n        \\n        for(int i = 0; i < list.size(); i++){\\n            int val = list.get(i);\\n            if(val >= k){\\n                ans += i * 2 + 1;\\n            } else {\\n                int idx = binarySearch(list, i, k - val);\\n                if(idx != -1){\\n                    ans = ans + (i - idx) * 2 + 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339679,
                "title": "golang-sort-by-number-of-1-then-binary-search",
                "content": "```\\nfunc CountExcellentPairs(nums []int, k int) int64 {\\n\\tvar record map[int]int = make(map[int]int) //number: count of \\'1\\'\\n\\tvar l int = len(nums)\\n\\tfor i := 0;i < l;i++{\\n\\t\\tn := nums[i]\\n\\t\\tif _,ok := record[n];!ok{\\n\\t\\t\\tvar one_cnt int = 0\\n\\t\\t\\tfor n > 0{\\n\\t\\t\\t\\tif n | 1 == n{\\n\\t\\t\\t\\t\\tone_cnt++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn >>= 1\\n\\t\\t\\t}\\n\\t\\t\\trecord[nums[i]] = one_cnt\\n\\t\\t}\\n\\t}\\n\\tvar cnt_num [][2]int //count of \\'1\\' and number ascending order\\n\\tfor k,v := range record{\\n\\t\\tcnt_num = append(cnt_num,[2]int{v,k})\\n\\t}\\n\\tsort.Slice(cnt_num, func(i, j int) bool {\\n\\t\\treturn cnt_num[i][0] < cnt_num[j][0]\\n\\t})\\n\\tvar res int64 = 0\\n\\tvar l2 int = len(cnt_num)\\n\\t//binary search\\n\\tfor i := 0;i < l2;i++{\\n\\t\\tcnt1 := cnt_num[i][0]\\n\\t\\tnum1 := cnt_num[i][1]\\n\\t\\tif cnt1 * 2 >= k{\\n\\t\\t\\tres += int64(l2 - i - 1) * 2 + 1\\n\\t\\t}else{\\n\\t\\t\\tfind_idx := sort.Search(l2, func(j int) bool {\\n\\t\\t\\t\\treturn cnt1 + cnt_num[j][0] >= k\\n\\t\\t\\t})\\n\\t\\t\\tif find_idx < l2 && find_idx >= i{\\n\\t\\t\\t\\tres += int64(l2 - find_idx) * 2\\n\\t\\t\\t\\tif num1 == cnt_num[find_idx][1]{\\n\\t\\t\\t\\t\\tres--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}",
                "solutionTags": [
                    "Go",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nfunc CountExcellentPairs(nums []int, k int) int64 {\\n\\tvar record map[int]int = make(map[int]int) //number: count of \\'1\\'\\n\\tvar l int = len(nums)\\n\\tfor i := 0;i < l;i++{\\n\\t\\tn := nums[i]\\n\\t\\tif _,ok := record[n];!ok{\\n\\t\\t\\tvar one_cnt int = 0\\n\\t\\t\\tfor n > 0{\\n\\t\\t\\t\\tif n | 1 == n{\\n\\t\\t\\t\\t\\tone_cnt++\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tn >>= 1\\n\\t\\t\\t}\\n\\t\\t\\trecord[nums[i]] = one_cnt\\n\\t\\t}\\n\\t}\\n\\tvar cnt_num [][2]int //count of \\'1\\' and number ascending order\\n\\tfor k,v := range record{\\n\\t\\tcnt_num = append(cnt_num,[2]int{v,k})\\n\\t}\\n\\tsort.Slice(cnt_num, func(i, j int) bool {\\n\\t\\treturn cnt_num[i][0] < cnt_num[j][0]\\n\\t})\\n\\tvar res int64 = 0\\n\\tvar l2 int = len(cnt_num)\\n\\t//binary search\\n\\tfor i := 0;i < l2;i++{\\n\\t\\tcnt1 := cnt_num[i][0]\\n\\t\\tnum1 := cnt_num[i][1]\\n\\t\\tif cnt1 * 2 >= k{\\n\\t\\t\\tres += int64(l2 - i - 1) * 2 + 1\\n\\t\\t}else{\\n\\t\\t\\tfind_idx := sort.Search(l2, func(j int) bool {\\n\\t\\t\\t\\treturn cnt1 + cnt_num[j][0] >= k\\n\\t\\t\\t})\\n\\t\\t\\tif find_idx < l2 && find_idx >= i{\\n\\t\\t\\t\\tres += int64(l2 - find_idx) * 2\\n\\t\\t\\t\\tif num1 == cnt_num[find_idx][1]{\\n\\t\\t\\t\\t\\tres--\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2339538,
                "title": "easy-to-understand-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // comparetor for sorting based on no. of set bits\\n    bool static cmp(int &x, int &y){\\n        return __builtin_popcount(x) < __builtin_popcount(y);\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        // unique removes consecutive duplicates(that\\'s why first sorted the vector)\\n        auto itr2FirstDuplicate = unique(nums.begin(), nums.end());\\n        \\n        // resizing it to non duplicates\\n        nums.resize(distance(nums.begin(), itr2FirstDuplicate));\\n        \\n        // sorting based on no. of set bits\\n        sort(nums.begin(), nums.end(), cmp);\\n        \\n        \\n        // now problem reduced to count no of pairs with sum greater than or equal to given target \\n        int n = nums.size();\\n        int i=0, j=n-1;\\n        \\n        // we don\\'t take long long as expected then runtime error at 51/56\\n        long long count = 0;\\n        while(i <= j){\\n            if(__builtin_popcount(nums[i]) + __builtin_popcount(nums[j]) < k){\\n                i++;\\n            }\\n            else{\\n                // multiplied by 2 bcz (2,1) and (1,2) are distinct pairs\\n                count += (2*(j-i)+1);\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // comparetor for sorting based on no. of set bits\\n    bool static cmp(int &x, int &y){\\n        return __builtin_popcount(x) < __builtin_popcount(y);\\n    }\\n    \\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        // unique removes consecutive duplicates(that\\'s why first sorted the vector)\\n        auto itr2FirstDuplicate = unique(nums.begin(), nums.end());\\n        \\n        // resizing it to non duplicates\\n        nums.resize(distance(nums.begin(), itr2FirstDuplicate));\\n        \\n        // sorting based on no. of set bits\\n        sort(nums.begin(), nums.end(), cmp);\\n        \\n        \\n        // now problem reduced to count no of pairs with sum greater than or equal to given target \\n        int n = nums.size();\\n        int i=0, j=n-1;\\n        \\n        // we don\\'t take long long as expected then runtime error at 51/56\\n        long long count = 0;\\n        while(i <= j){\\n            if(__builtin_popcount(nums[i]) + __builtin_popcount(nums[j]) < k){\\n                i++;\\n            }\\n            else{\\n                // multiplied by 2 bcz (2,1) and (1,2) are distinct pairs\\n                count += (2*(j-i)+1);\\n                j--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338943,
                "title": "java-36ms",
                "content": "1. Sort.\\n2. Skip duplicates.\\n3. Increament for each bitcount. No numbers below 1,000,000,000 use more than 29 bits.\\n4. Multiply each counts for pairs with bits above k. There are no 0 bits numbers.\\n\\n```\\nclass Solution {\\n\\tpublic long countExcellentPairs(int[] nums, int k) {\\n\\t\\tjava.util.Arrays.sort(nums);\\n\\t\\tint[] c = new int[30];\\n\\t\\tfor (int i = 0, n = nums.length, w = 0; i < n; ++i) {\\n\\t\\t\\tint v = nums[i];\\n\\t\\t\\tif (w != v)\\n\\t\\t\\t\\t++c[Integer.bitCount(w = v)];\\n\\t\\t}\\n\\t\\tlong a = 0;\\n\\t\\tfor (int i = Math.max(k - 30, 1); i < 30; ++i) {\\n\\t\\t\\tlong d = c[i];\\n\\t\\t\\tfor (int j = Math.max(k - i, 1); j < 30; ++j)\\n\\t\\t\\t\\ta += d * c[j];\\n\\t\\t}\\n\\t\\treturn a;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic long countExcellentPairs(int[] nums, int k) {\\n\\t\\tjava.util.Arrays.sort(nums);\\n\\t\\tint[] c = new int[30];\\n\\t\\tfor (int i = 0, n = nums.length, w = 0; i < n; ++i) {\\n\\t\\t\\tint v = nums[i];\\n\\t\\t\\tif (w != v)\\n\\t\\t\\t\\t++c[Integer.bitCount(w = v)];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2338784,
                "title": "c-binary-search-696ms",
                "content": "\\'\\'\\'public class Solution {\\n    int bits(int d)\\n    {\\n        int s = 0;\\n        while(d > 0)\\n        {\\n            if( ( d & 1 ) > 0 ) s++;\\n            d = d >> 1;\\n        }\\n        return s;\\n    }\\n    \\n    public long CountExcellentPairs(int[] nums, int k) {\\n        SortedSet<int> ss = new SortedSet<int>();\\n        foreach(int i in nums)\\n            if(!ss.Contains(i)) ss.Add(i);\\n        \\n        int n = ss.Count;\\n        float[] ns = new float[n]; \\n        int a = 0;\\n        foreach(int i in ss)\\n            ns[a++] = bits(i);\\n        \\n        long res = 0;\\n        Array.Sort(ns);\\n        float m = ns[n-1];\\n        float  k1 = k-(float)0.5;\\n        for(int i = 0; i < n; i++)\\n        {\\n            float d1 = ns[i];\\n            float d2 = k1-d1;\\n            if(d2 > m)continue;\\n            int j = Array.BinarySearch(ns, d2);\\n            \\n            if(j < 0)j = ~j;                       \\n            res += n-j;            \\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int bits(int d)\\n    {\\n        int s = 0;\\n        while(d > 0)\\n        {\\n            if( ( d & 1 ) > 0 ) s++;\\n            d = d >> 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2338275,
                "title": "c-281-ms-faster-than-100-clean-code",
                "content": "num_set_bits(a AND b) + num_set_bits(a OR b) is equal to num_set_bits(a) + num_set_bits(b)\\nSo you need to count the number of pairs of such that `num_set_bits(a) + num_set_bits(b) >= k`\\n\\n```\\nclass Solution {\\n    int pop(unsigned x)\\n    {\\n        x = x - ((x >> 1) & 0x55555555);\\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\\n        x = x + (x >> 8);\\n        x = x + (x >> 16);\\n        return x & 0x0000003F;\\n    }\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k)\\n    {\\n        // remove repeated values\\n        unordered_set<int> numSet(nums.begin(), nums.end());\\n        \\n        // count bits\\n        vector<int> c(33, 0);\\n        for(auto n : numSet)\\n            //c[popcount(n)]++;   // C++20\\n            c[pop(n)]++;            \\n        \\n        long long ret = 0;\\n        for(int i=0; i<=32; i++)\\n            for(int j=max(k-i, 0); j<=32; j++)\\n                ret += ((long long) c[i]) * c[j];\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    int pop(unsigned x)\\n    {\\n        x = x - ((x >> 1) & 0x55555555);\\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\\n        x = x + (x >> 8);\\n        x = x + (x >> 16);\\n        return x & 0x0000003F;\\n    }\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k)\\n    {\\n        // remove repeated values\\n        unordered_set<int> numSet(nums.begin(), nums.end());\\n        \\n        // count bits\\n        vector<int> c(33, 0);\\n        for(auto n : numSet)\\n            //c[popcount(n)]++;   // C++20\\n            c[pop(n)]++;            \\n        \\n        long long ret = 0;\\n        for(int i=0; i<=32; i++)\\n            for(int j=max(k-i, 0); j<=32; j++)\\n                ret += ((long long) c[i]) * c[j];\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337415,
                "title": "c-number-of-set-bits",
                "content": "![image](https://assets.leetcode.com/users/images/b48b076a-82fa-41c8-8030-c44ef766ce3a_1658854624.649241.jpeg)\\nAttaching code for reference\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<long long>s;\\n        for(auto i:nums) s.insert(i);\\n        vector<long long>setBits;\\n        for(auto it:s){\\n            // long long cnt = 0;\\n            // while(it>0){\\n            //     if((it&1)==1){\\n            //          cnt++;\\n            //     }\\n            //     it = it>>1;\\n            // }\\n            int cnt = __builtin_popcountll(it);\\n            setBits.push_back(cnt);\\n        }\\n        long long ans = 0;\\n        int n = setBits.size();\\n        sort(setBits.begin(),setBits.end());\\n        for(int i=0;i<setBits.size();i++){\\n           int idx = lower_bound(setBits.begin(),setBits.end(),k-setBits[i])-setBits.begin();\\n            ans += (n-idx);          \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        set<long long>s;\\n        for(auto i:nums) s.insert(i);\\n        vector<long long>setBits;\\n        for(auto it:s){\\n            // long long cnt = 0;\\n            // while(it>0){\\n            //     if((it&1)==1){\\n            //          cnt++;\\n            //     }\\n            //     it = it>>1;\\n            // }\\n            int cnt = __builtin_popcountll(it);\\n            setBits.push_back(cnt);\\n        }\\n        long long ans = 0;\\n        int n = setBits.size();\\n        sort(setBits.begin(),setBits.end());\\n        for(int i=0;i<setBits.size();i++){\\n           int idx = lower_bound(setBits.begin(),setBits.end(),k-setBits[i])-setBits.begin();\\n            ans += (n-idx);          \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335091,
                "title": "c-builtin-popcount-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        map<int,set<int>> mp;\\n        int n = nums.size();\\n        for(auto it:nums)\\n        {\\n            int val = __builtin_popcount(it);\\n            mp[val].insert(it);\\n        }\\n        long long ans = 0;\\n        for(auto &i:mp)\\n        {\\n            for(auto &j:mp)\\n            {\\n                if(i.first + j.first >= k)\\n                {\\n                    int a = i.second.size();\\n                    int b = j.second.size();\\n                    ans += (a*b);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        map<int,set<int>> mp;\\n        int n = nums.size();\\n        for(auto it:nums)\\n        {\\n            int val = __builtin_popcount(it);\\n            mp[val].insert(it);\\n        }\\n        long long ans = 0;\\n        for(auto &i:mp)\\n        {\\n            for(auto &j:mp)\\n            {\\n                if(i.first + j.first >= k)\\n                {\\n                    int a = i.second.size();\\n                    int b = j.second.size();\\n                    ans += (a*b);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334644,
                "title": "java-70ms-o-n-k-2",
                "content": "```\\npublic long countExcellentPairs(int[] nums, int k) {\\n\\tSet<Integer> s = new HashSet();\\n\\tint[] m = new int[k+1];\\n\\n\\tfor(int i:nums){\\n\\t\\tif(!s.contains(i)){\\n\\t\\t\\ts.add(i);\\n\\t\\t\\tm[Math.min(k,Integer.bitCount(i))]++;            \\n\\t\\t}\\n\\t}\\n\\tlong result = 0;\\n\\tlong sum = 0;\\n\\tfor(int i = k; i>(k+1)/2; i--){\\n\\t\\tsum += m[i];\\n\\t\\tresult+= sum*2*(m[i-1]+m[k-i])+((long)m[i])*m[i];\\n\\t}\\n\\tlong j = m[(k+1)/2];\\n\\tresult+=j*j;\\n\\tif((k&1)==1) {\\n\\t  sum+=j;\\n\\t  result+=sum*2*m[k/2];              \\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic long countExcellentPairs(int[] nums, int k) {\\n\\tSet<Integer> s = new HashSet();\\n\\tint[] m = new int[k+1];\\n\\n\\tfor(int i:nums){\\n\\t\\tif(!s.contains(i)){\\n\\t\\t\\ts.add(i);\\n\\t\\t\\tm[Math.min(k,Integer.bitCount(i))]++;            \\n\\t\\t}\\n\\t}\\n\\tlong result = 0;\\n\\tlong sum = 0;\\n\\tfor(int i = k; i>(k+1)/2; i--){\\n\\t\\tsum += m[i];\\n\\t\\tresult+= sum*2*(m[i-1]+m[k-i])+((long)m[i])*m[i];\\n\\t}\\n\\tlong j = m[(k+1)/2];\\n\\tresult+=j*j;\\n\\tif((k&1)==1) {\\n\\t  sum+=j;\\n\\t  result+=sum*2*m[k/2];              \\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2334405,
                "title": "rust-2-sum-two-pointers-o-n",
                "content": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_excellent_pairs(nums: Vec<i32>, k: i32) -> i64 {\\n        let xs: HashSet<i32> = nums.into_iter().collect();\\n        let mut bs: Vec<i32> = xs.iter().map(|x|{\\n            let mut cnt = 0;\\n            for i in 0..32 {\\n                if x>>i & 1 == 1 {\\n                    cnt += 1;\\n                }\\n            }\\n            cnt\\n        }).collect();\\n        bs.sort();\\n        // println!(\"bs {bs:#?}\");\\n        \\n        let mut ans = 0_i64;\\n        let (mut l, mut r) = (0, bs.len()-1);\\n        while l <= r {\\n            if bs[l] + bs[r] >= k {\\n                ans += ((r - l) * 2 + 1) as i64;\\n                if let None = r.checked_sub(1) {\\n                    break;\\n                }\\n                r -= 1;\\n            } else {\\n                l += 1;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn count_excellent_pairs(nums: Vec<i32>, k: i32) -> i64 {\\n        let xs: HashSet<i32> = nums.into_iter().collect();\\n        let mut bs: Vec<i32> = xs.iter().map(|x|{\\n            let mut cnt = 0;\\n            for i in 0..32 {\\n                if x>>i & 1 == 1 {\\n                    cnt += 1;\\n                }\\n            }\\n            cnt\\n        }).collect();\\n        bs.sort();\\n        // println!(\"bs {bs:#?}\");\\n        \\n        let mut ans = 0_i64;\\n        let (mut l, mut r) = (0, bs.len()-1);\\n        while l <= r {\\n            if bs[l] + bs[r] >= k {\\n                ans += ((r - l) * 2 + 1) as i64;\\n                if let None = r.checked_sub(1) {\\n                    break;\\n                }\\n                r -= 1;\\n            } else {\\n                l += 1;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2333738,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    \\n    long long sch(int c,int r,vector<int> &b){\\n        int l=0;\\n        int ans=-1;\\n        while(l<=r){\\n            int m=(l+((r-l)>>1));\\n            if(b[m]>=c){\\n                ans=m;\\n                r=m-1;\\n            }\\n            else l=m+1;\\n        }\\n        return ans;\\n    }\\n    long long countExcellentPairs(vector<int>& a, int k) {\\n        int n=a.size();\\n        map<int,int> m;\\n        for(int i=0;i<n;i++){\\n            m[a[i]]=__builtin_popcount(a[i]);\\n        }\\n        vector<int> b;\\n        for(auto i:m){\\n            b.push_back(i.second);\\n        }\\n        sort(b.begin(),b.end());\\n        long long c=0;\\n        for(long long i=0;i<b.size();i++){\\n            if(b[i]>=k){\\n                c+=(i*2)+1;\\n            }\\n            else{\\n                long long idx=sch(k-b[i],i,b);\\n                if(idx!=-1){\\n                    c+=(i-idx)*2+1;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    long long sch(int c,int r,vector<int> &b){\\n        int l=0;\\n        int ans=-1;\\n        while(l<=r){\\n            int m=(l+((r-l)>>1));\\n            if(b[m]>=c){\\n                ans=m;\\n                r=m-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2333575,
                "title": "easy-to-understand-java-binary-search",
                "content": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long res,tmp;\\n        int i,pos,left,right,mid;\\n        TreeSet<Integer> set = new TreeSet<Integer>();\\n        List<Integer> cnt = new ArrayList<>();\\n\\n        \\n        for(i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        for(Integer x: set){\\n            cnt.add(Integer.bitCount(x));\\n        }\\n        \\n        Collections.sort(cnt);\\n        \\n        res=0;\\n        for(i=cnt.size()-1;i>=0;i--){\\n            left=0;\\n            pos=right=i;\\n            while(left<=right){\\n                mid = left+(right-left)/2;\\n                if(cnt.get(i)+cnt.get(mid)>=k){\\n                    right=mid-1;\\n                    pos=mid;\\n                }\\n                else{\\n                    left=mid+1;\\n                }\\n            }\\n            tmp=i-pos;\\n            res+=tmp*2; \\n            if(cnt.get(i)*2>=k){\\n                res++;\\n            }\\n              \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long res,tmp;\\n        int i,pos,left,right,mid;\\n        TreeSet<Integer> set = new TreeSet<Integer>();\\n        List<Integer> cnt = new ArrayList<>();\\n\\n        \\n        for(i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        for(Integer x: set){\\n            cnt.add(Integer.bitCount(x));\\n        }\\n        \\n        Collections.sort(cnt);\\n        \\n        res=0;\\n        for(i=cnt.size()-1;i>=0;i--){\\n            left=0;\\n            pos=right=i;\\n            while(left<=right){\\n                mid = left+(right-left)/2;\\n                if(cnt.get(i)+cnt.get(mid)>=k){\\n                    right=mid-1;\\n                    pos=mid;\\n                }\\n                else{\\n                    left=mid+1;\\n                }\\n            }\\n            tmp=i-pos;\\n            res+=tmp*2; \\n            if(cnt.get(i)*2>=k){\\n                res++;\\n            }\\n              \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333463,
                "title": "java-map-easy-to-understand-with-comments",
                "content": "```\\n    // TC = O(32*n)\\n    // The idea is to avoid solving the problem in O(n2) by using map\\n    // We have used map to store nr of set bits of all numbers grouped together\\n    // then used vis Set to avoid duplication of them.\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long ans = 0L;\\n\\n        TreeMap<Integer, TreeSet<Integer>> map = new TreeMap<>(); // {nr. of set  bits, nr}\\n\\n        for (int num : nums) {\\n            if (!map.containsKey(Integer.bitCount(num))) map.put(Integer.bitCount(num), new TreeSet<>());\\n            map.get(Integer.bitCount(num)).add(num);\\n        }\\n\\n        Set<Integer> vis = new HashSet<>();\\n\\n        for (int num : nums) {\\n            if (vis.contains(num)) continue;\\n\\n            int need = k - Integer.bitCount(num);\\n\\n            // O(32) as largest number can be of 32 bits\\n            for (Map.Entry<Integer, TreeSet<Integer>> entry : map.entrySet())\\n                if (entry.getKey() >= need) ans += entry.getValue().size();\\n\\n            vis.add(num);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    // TC = O(32*n)\\n    // The idea is to avoid solving the problem in O(n2) by using map\\n    // We have used map to store nr of set bits of all numbers grouped together\\n    // then used vis Set to avoid duplication of them.\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long ans = 0L;\\n\\n        TreeMap<Integer, TreeSet<Integer>> map = new TreeMap<>(); // {nr. of set  bits, nr}\\n\\n        for (int num : nums) {\\n            if (!map.containsKey(Integer.bitCount(num))) map.put(Integer.bitCount(num), new TreeSet<>());\\n            map.get(Integer.bitCount(num)).add(num);\\n        }\\n\\n        Set<Integer> vis = new HashSet<>();\\n\\n        for (int num : nums) {\\n            if (vis.contains(num)) continue;\\n\\n            int need = k - Integer.bitCount(num);\\n\\n            // O(32) as largest number can be of 32 bits\\n            for (Map.Entry<Integer, TreeSet<Integer>> entry : map.entrySet())\\n                if (entry.getKey() >= need) ans += entry.getValue().size();\\n\\n            vis.add(num);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332015,
                "title": "c-simple-hashing",
                "content": "long help(long long n){\\n        long long ans=0;\\n        while(n){\\n            ans+=n&1;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_map<int,set<int>> m;\\n        for(auto p: nums){  \\n            m[(help(p))].insert(p);\\n        }\\n        long long ans=0;\\n        for(auto &k1: m){\\n            for(auto &k2: m){\\n                if((k1.first+k2.first)>=k){\\n                    long long n1=k1.second.size();\\n                    long long n2=k2.second.size();\\n                    ans+=(n1*n2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "long help(long long n){\\n        long long ans=0;\\n        while(n){\\n            ans+=n&1;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_map<int,set<int>> m;\\n        for(auto p: nums){  \\n            m[(help(p))].insert(p);\\n        }\\n        long long ans=0;\\n        for(auto &k1: m){\\n            for(auto &k2: m){\\n                if((k1.first+k2.first)>=k){\\n                    long long n1=k1.second.size();\\n                    long long n2=k2.second.size();\\n                    ans+=(n1*n2);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2331831,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) \\n    {\\n       map<long long ,int>mp;\\n        unordered_set<int>st;\\n        for(int i:nums)\\n        {\\n            st.insert(i);\\n        }\\n        for(auto i:st)\\n        {\\n            int ct=0;\\n           while(i)\\n           {\\n               ct+=i&1;\\n               i>>=1;\\n           }\\n            mp[ct]++;\\n        }\\n        long long ct=0;\\n        for(int i=1; i<=60; i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                auto it=mp.lower_bound(k-i);\\n                while(it!=mp.end())\\n                {\\n                   ct+=(mp[i]*(it->second));\\n                    it++;\\n                }\\n                \\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) \\n    {\\n       map<long long ,int>mp;\\n        unordered_set<int>st;\\n        for(int i:nums)\\n        {\\n            st.insert(i);\\n        }\\n        for(auto i:st)\\n        {\\n            int ct=0;\\n           while(i)\\n           {\\n               ct+=i&1;\\n               i>>=1;\\n           }\\n            mp[ct]++;\\n        }\\n        long long ct=0;\\n        for(int i=1; i<=60; i++)\\n        {\\n            if(mp.find(i)!=mp.end())\\n            {\\n                auto it=mp.lower_bound(k-i);\\n                while(it!=mp.end())\\n                {\\n                   ct+=(mp[i]*(it->second));\\n                    it++;\\n                }\\n                \\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330487,
                "title": "c-bitset-count",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        std::vector<int> occurrences = CountHammingWeigths(nums);\\n        std::vector<int> hamming_weights;\\n        std::vector<int> counts;\\n        for (int ii = 0; ii < occurrences.size(); ++ii) {\\n            int c = occurrences[ii];\\n            if (c != 0) {\\n                hamming_weights.emplace_back(ii);\\n                counts.emplace_back(c);\\n            }\\n        }   \\n        std::vector<int> prefix_sum(counts.size());\\n        std::inclusive_scan(counts.begin(), counts.end(), prefix_sum.begin());\\n        long long result = 0;\\n        int jj = 0;\\n        for (int ii = hamming_weights.size() - 1; ii >= 0; --ii) {\\n            jj = std::lower_bound(hamming_weights.begin() + jj, hamming_weights.end(),\\n                                  std::max(0, k - hamming_weights[ii])) - hamming_weights.begin();\\n            int c1 = counts[ii];\\n            int c2 = prefix_sum.back() - (jj == 0 ? 0 : prefix_sum[jj - 1]);\\n            result += c1 * c2;\\n        }\\n        return result;\\n    }\\n    \\n    std::vector<int> CountHammingWeigths(const vector<int>& nums) {\\n        constexpr size_t kMaxNumBit = 64;\\n        std::unordered_set<int> distinct_nums(nums.begin(), nums.end());\\n        std::vector<int> weights(distinct_nums.size());\\n        std::transform(distinct_nums.cbegin(), distinct_nums.cend(), weights.begin(),\\n                       [kMaxNumBit](uint num){ return std::bitset<kMaxNumBit>(num).count(); });\\n        std::vector<int> occurrences(kMaxNumBit);\\n        for (int w : weights) {\\n            ++occurrences[w];\\n        }\\n        return occurrences;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        std::vector<int> occurrences = CountHammingWeigths(nums);\\n        std::vector<int> hamming_weights;\\n        std::vector<int> counts;\\n        for (int ii = 0; ii < occurrences.size(); ++ii) {\\n            int c = occurrences[ii];\\n            if (c != 0) {\\n                hamming_weights.emplace_back(ii);\\n                counts.emplace_back(c);\\n            }\\n        }   \\n        std::vector<int> prefix_sum(counts.size());\\n        std::inclusive_scan(counts.begin(), counts.end(), prefix_sum.begin());\\n        long long result = 0;\\n        int jj = 0;\\n        for (int ii = hamming_weights.size() - 1; ii >= 0; --ii) {\\n            jj = std::lower_bound(hamming_weights.begin() + jj, hamming_weights.end(),\\n                                  std::max(0, k - hamming_weights[ii])) - hamming_weights.begin();\\n            int c1 = counts[ii];\\n            int c2 = prefix_sum.back() - (jj == 0 ? 0 : prefix_sum[jj - 1]);\\n            result += c1 * c2;\\n        }\\n        return result;\\n    }\\n    \\n    std::vector<int> CountHammingWeigths(const vector<int>& nums) {\\n        constexpr size_t kMaxNumBit = 64;\\n        std::unordered_set<int> distinct_nums(nums.begin(), nums.end());\\n        std::vector<int> weights(distinct_nums.size());\\n        std::transform(distinct_nums.cbegin(), distinct_nums.cend(), weights.begin(),\\n                       [kMaxNumBit](uint num){ return std::bitset<kMaxNumBit>(num).count(); });\\n        std::vector<int> occurrences(kMaxNumBit);\\n        for (int w : weights) {\\n            ++occurrences[w];\\n        }\\n        return occurrences;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330317,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<Integer> distinctNumbers = new HashSet<>();\\n        List<Integer> list = new ArrayList<>();\\n        for(int num: nums){\\n            if(!distinctNumbers.add(num)) continue;\\n            int bits = numberOfSetBits(num);\\n            list.add(bits);\\n        }\\n        long answer = 0L;\\n        list.sort(null);\\n        int i=0,j=list.size()-1;\\n        while(i<=j){\\n            while(i<=j && list.get(i)+list.get(j)<k) i++;\\n            if(list.get(j)*2>=k) answer++;\\n            if(i>=j) break;\\n            answer += (long)(j-i)*2;\\n            j--;\\n        }\\n        return answer;\\n    }\\n    private int numberOfSetBits(int num){\\n        int bits = 0;\\n        while(num!=0){\\n            if((num&1)==1) bits++;\\n            num = num>>1;\\n        }\\n        return bits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<Integer> distinctNumbers = new HashSet<>();\\n        List<Integer> list = new ArrayList<>();\\n        for(int num: nums){\\n            if(!distinctNumbers.add(num)) continue;\\n            int bits = numberOfSetBits(num);\\n            list.add(bits);\\n        }\\n        long answer = 0L;\\n        list.sort(null);\\n        int i=0,j=list.size()-1;\\n        while(i<=j){\\n            while(i<=j && list.get(i)+list.get(j)<k) i++;\\n            if(list.get(j)*2>=k) answer++;\\n            if(i>=j) break;\\n            answer += (long)(j-i)*2;\\n            j--;\\n        }\\n        return answer;\\n    }\\n    private int numberOfSetBits(int num){\\n        int bits = 0;\\n        while(num!=0){\\n            if((num&1)==1) bits++;\\n            num = num>>1;\\n        }\\n        return bits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330235,
                "title": "c-intuition-behind-the-formula-similar-to-two-sum-binary-search",
                "content": "**Intuition**\\n\\nLet `x` be the number and `n(x)` be the number of set bits in `x`.\\nGiven an array `arr` of numbers, the task is to find the number of distinct pairs `(a, b)` such that `n(a OR b) + n(a AND b) >= k` **(Eq.1)**.\\n\\nBy the formulas of digital logic:\\n* `a OR b = a - (a AND b) + b` **(Eq.2)** and applying the number of set bits function on the previous equation we get\\n* \\t`n(a OR b) = n(a - (a AND b) + b)` **(Eq.3)**\\n* \\t`n(a OR b) = n(a) - n(a AND b) + n(b)` **(Eq.4)** (The function `n(x)` is distributive over addition and subraction)\\n* \\tFor ex: Let `a = 5` and `b = 1`\\n\\t* \\t`binary(5) = 101` and `binary(1) = 1`\\n\\t* \\t`a OR b = 5 OR 1 = 5` and `n(a OR b) = n(5) = 2`\\n\\t* \\t`a AND b = 5 AND 1 = 1` and `n(a OR b) = n(1) = 1`\\n\\t* \\t`n(a) = n(5) = 2` and `n(b) = n(1) = 1`\\n\\t* \\tFrom  `n(a OR b) = 2 = 2 - 1 + 1 = n(a) - n(a AND b) + n(b)` . Hence **(Eq.4)** is true and satisfied. \\n\\n* Applying **(Eq.4)** to **(Eq.1)**, we get\\n\\t* \\t`n(a OR b) + n(a AND b) >= k`\\n\\t* \\t`(n(a) - n(a AND b) + n(b)) + n(a AND b) >= k ` \\n\\t* \\t`n(a) + n(b) >= k` **(Eq.5)**\\n\\nNow, the **(Eq.5)** is very much similar to the requirement equation of the `two sum` problem `(a + b >= sum)`. Therefore, we can use the same approach as that of `two sum` problem for this problem.\\n\\n\\n**Approach**\\n* Since we need distinct pairs `(a, b)` , we should take only the unique elements from the array `arr`. \\n* Have another array called `bits` which stores the number of set bits (i.e `n(x)` ) for all the distinct numbers.\\n* Sort the `bits` array, so we can use binary search to find the answer. \\n* For every `x` in bits array, use `lower_bound` function in `C++` to find the position of first number greater than or equal to `k - x`, let that be `pos`. \\n* Then add to the answer variable `n - pos` (i.e `ans += n - pos`), where `n` is the number of distinct numbers\\n* Return the `ans`\\n\\n**Complexity**\\n* Time Complexity - `O(NlogN)`\\n* Space Complexity - `O(N)`\\n* `N` is the total number of elements in the array `arr`\\n\\n**Code**\\n```\\nlong long countExcellentPairs(vector<int>& arr, int k) {\\n        set<int> vals(arr.begin(), arr.end());\\n        \\n        vector<int> bits;\\n        for(auto &x: vals) {\\n            bits.push_back(__builtin_popcount(x));\\n        }\\n        \\n        sort(bits.begin(), bits.end());\\n        \\n        int n = bits.size();\\n        long long ans = 0;\\n        for(auto x: bits) {\\n            int pos = lower_bound(bits.begin(), bits.end(), k - x) - bits.begin();\\n            ans += n - pos;\\n        }\\n        \\n        return  ans;\\n    }\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nlong long countExcellentPairs(vector<int>& arr, int k) {\\n        set<int> vals(arr.begin(), arr.end());\\n        \\n        vector<int> bits;\\n        for(auto &x: vals) {\\n            bits.push_back(__builtin_popcount(x));\\n        }\\n        \\n        sort(bits.begin(), bits.end());\\n        \\n        int n = bits.size();\\n        long long ans = 0;\\n        for(auto x: bits) {\\n            int pos = lower_bound(bits.begin(), bits.end(), k - x) - bits.begin();\\n            ans += n - pos;\\n        }\\n        \\n        return  ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330189,
                "title": "c-simple-solution-for-beginners-explained",
                "content": "**Method:**\\n\\n* The important fact is to realize that\\n* **```number of set bits in OR(X,Y) + number of set bits in AND(X,Y) = number of set bits in X + number of set bits in Y```**\\n* so now we will store the number of set bits of each element in vector \"v\" and then count the pair(i,j) such that ```v[i]+v[j]>=k```\\n* Now, we can further optimize it\\n\\t* we don\\'t have to store the duplicates\\n\\t* if ```v[i]==v[j]``` then the number of pairs will be 1\\n\\t* else the number of pairs = 2 ({i,j},{j,i})\\n\\t* so to remove the duplicates we can use set\\n* To further optimize it we can sort the vector array v\\n* why?\\n\\t* so now we have an array in increasing order of number of set bits\\n\\t* Now, we can do binary search to find the required pair\\n\\t\\t* ```l=0, r=v.size()-1```\\n\\t\\t* note that\\n\\t\\t\\t* ``` if (v[l] + v[r] >= k)```\\n\\t\\t\\t* then sum of all the pairs between l and r will be >=k\\n\\t\\t\\t* because ```v[l+1]>=v[l]```\\n\\t\\t\\t* so we can just simply add all those pair to the ans\\n\\t\\t\\t* i.e ```ans+= (r-l)```\\n\\t\\t\\t* now as we said above when the elements are distinct then there will be two pair for each i and j so we need to multiply the ans by 2 here\\n\\t\\t\\t* i.e ```ans+= (r-l)*2```\\n* we can take care of the same element pair (i,i) while pushing the set bits in v by checking \\n\\t``` \\n\\tif (2 * cnt >= k)\\n          ans++;\\n\\t```\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    unsigned int calc(unsigned int n)\\n    {\\n        unsigned int count = 0;\\n        while (n)\\n        {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n    long long countExcellentPairs(vector<int> &nums, int k)\\n    {\\n\\n        set<int> st(nums.begin(), nums.end());\\n        long long ans = 0;\\n        vector<int> v;\\n        for (auto x : st)\\n        {\\n            int cnt = calc(x);\\n            if (2 * cnt >= k)\\n                ans++;\\n            v.push_back(cnt);\\n        }\\n        sort(v.begin(), v.end());\\n        int l = 0;\\n        int r = v.size() - 1;\\n        while (l < r)\\n        {\\n            if (v[l] + v[r] >= k)\\n            {\\n                ans += (r - l) * 2;\\n                r--;\\n            }\\n            else\\n                l++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```number of set bits in OR(X,Y) + number of set bits in AND(X,Y) = number of set bits in X + number of set bits in Y```\n```v[i]+v[j]>=k```\n```v[i]==v[j]```\n```l=0, r=v.size()-1```\n``` if (v[l] + v[r] >= k)```\n```v[l+1]>=v[l]```\n```ans+= (r-l)```\n```ans+= (r-l)*2```\n``` \\n\\tif (2 * cnt >= k)\\n          ans++;\\n\\t```\n```\\nclass Solution\\n{\\npublic:\\n    unsigned int calc(unsigned int n)\\n    {\\n        unsigned int count = 0;\\n        while (n)\\n        {\\n            count += n & 1;\\n            n >>= 1;\\n        }\\n        return count;\\n    }\\n    long long countExcellentPairs(vector<int> &nums, int k)\\n    {\\n\\n        set<int> st(nums.begin(), nums.end());\\n        long long ans = 0;\\n        vector<int> v;\\n        for (auto x : st)\\n        {\\n            int cnt = calc(x);\\n            if (2 * cnt >= k)\\n                ans++;\\n            v.push_back(cnt);\\n        }\\n        sort(v.begin(), v.end());\\n        int l = 0;\\n        int r = v.size() - 1;\\n        while (l < r)\\n        {\\n            if (v[l] + v[r] >= k)\\n            {\\n                ans += (r - l) * 2;\\n                r--;\\n            }\\n            else\\n                l++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330110,
                "title": "python-solution-prefix-sum-and-binary-search",
                "content": "```\\nclass Solution:\\n    # First reduce the complexity of the problem using hash set\\n    # Some examples of sum of AND and OR between two nums\\n    # 10101, 01010 AND: 00000, OR: 11111\\n    # 11101, 01010 AND: 01000, OR: 11111\\n    # So the quantity asked is actually sum of set bits of num1 and num2\\n    # More precisely, a set bit in num1 can either be 1 (counted in AND and OR) or 0 (counted in OR only) in num2. If we add the AND and OR set bits up, we are effectively adding up total set bits in num1 and num2\\n    # So we should record number of set bits of each unique elements in a hash table\\n    # hash_table[set_bits] = n\\n    # Then we sort the set_bits keys.\\n    # Then we construct the corresponding hash_table values prefix sums\\n    # Then each starting value i, we binary search in the keys for keys larger than k - i\\n    # Use the prefix sum array to obtain the result in nlogn time\\n    # As an example: nums = [1,2,3,1], k = 3\\n    # nums_set = [1,2,3]\\n    # set_bits = [1,1,2]\\n    # hash_table = {1: 2, 2: 1}; keys = [1,2]; prefix = [0, 2, 3]\\n    # Binary search: \\n    # for key = 1, we search for k-key = 3-1 = 2\\n    # index = 1, so we add (prefix(len(prefix)-1) - prefix(index))*hash_table[key] = (3 - 2)*2 = 2 to the result (1,3) & (2,3)\\n    # for key = 2, we search for k-key = 3-2 = 1\\n    # index = 0, so we add (prefix(len(prefix)-1) - prefix(index))*hash_table[key] = (3 - 0)*1 = 3 to the result (3,1), (3,2) and (3,3)\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        hash_table = {}\\n        for num in set(nums):\\n            set_bits = bin(num).count(\\'1\\')\\n            if set_bits not in hash_table:\\n                hash_table[set_bits] = 0\\n            hash_table[set_bits] += 1\\n        keys = sorted(hash_table.keys())\\n        prefix = [0]\\n        for key in keys:\\n            prefix.append(prefix[-1] + hash_table[key])\\n        result, n = 0, len(prefix)\\n        for key in keys:\\n            index = bisect.bisect_left(keys, k - key)\\n            result += hash_table[key]*(prefix[n-1]-prefix[index])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # First reduce the complexity of the problem using hash set\\n    # Some examples of sum of AND and OR between two nums\\n    # 10101, 01010 AND: 00000, OR: 11111\\n    # 11101, 01010 AND: 01000, OR: 11111\\n    # So the quantity asked is actually sum of set bits of num1 and num2\\n    # More precisely, a set bit in num1 can either be 1 (counted in AND and OR) or 0 (counted in OR only) in num2. If we add the AND and OR set bits up, we are effectively adding up total set bits in num1 and num2\\n    # So we should record number of set bits of each unique elements in a hash table\\n    # hash_table[set_bits] = n\\n    # Then we sort the set_bits keys.\\n    # Then we construct the corresponding hash_table values prefix sums\\n    # Then each starting value i, we binary search in the keys for keys larger than k - i\\n    # Use the prefix sum array to obtain the result in nlogn time\\n    # As an example: nums = [1,2,3,1], k = 3\\n    # nums_set = [1,2,3]\\n    # set_bits = [1,1,2]\\n    # hash_table = {1: 2, 2: 1}; keys = [1,2]; prefix = [0, 2, 3]\\n    # Binary search: \\n    # for key = 1, we search for k-key = 3-1 = 2\\n    # index = 1, so we add (prefix(len(prefix)-1) - prefix(index))*hash_table[key] = (3 - 2)*2 = 2 to the result (1,3) & (2,3)\\n    # for key = 2, we search for k-key = 3-2 = 1\\n    # index = 0, so we add (prefix(len(prefix)-1) - prefix(index))*hash_table[key] = (3 - 0)*1 = 3 to the result (3,1), (3,2) and (3,3)\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        hash_table = {}\\n        for num in set(nums):\\n            set_bits = bin(num).count(\\'1\\')\\n            if set_bits not in hash_table:\\n                hash_table[set_bits] = 0\\n            hash_table[set_bits] += 1\\n        keys = sorted(hash_table.keys())\\n        prefix = [0]\\n        for key in keys:\\n            prefix.append(prefix[-1] + hash_table[key])\\n        result, n = 0, len(prefix)\\n        for key in keys:\\n            index = bisect.bisect_left(keys, k - key)\\n            result += hash_table[key]*(prefix[n-1]-prefix[index])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329774,
                "title": "c-manual-bit-count",
                "content": "X AND Y + X OR Y == X bit count + Y bit count.\\n\\nWe calculate counts for all bossible bit numbers (from 1 to 31, from 1 to 10^9).\\nWhen just checking all possible bits combinations some of them will have a non-zero count. \\n\\n```\\npublic class Solution {\\n    public long CountExcellentPairs(int[] nums, int k) {\\n        int[] bits = new int[31];\\n        \\n        foreach(int num in nums.Distinct()){\\n            int count = CountBits(num);\\n            bits[count]++;\\n        }\\n        \\n        long ans = 0;\\n        \\n        for(int i=1; i<31; i++){\\n            for(int j=1; j<31; j++){\\n                if(i+j >= k){\\n                    ans += bits[i]*bits[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int CountBits(int num){\\n        int count =0;\\n        while(num >0){\\n            count += num&1;\\n            num >>=1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public long CountExcellentPairs(int[] nums, int k) {\\n        int[] bits = new int[31];\\n        \\n        foreach(int num in nums.Distinct()){\\n            int count = CountBits(num);\\n            bits[count]++;\\n        }\\n        \\n        long ans = 0;\\n        \\n        for(int i=1; i<31; i++){\\n            for(int j=1; j<31; j++){\\n                if(i+j >= k){\\n                    ans += bits[i]*bits[j];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int CountBits(int num){\\n        int count =0;\\n        while(num >0){\\n            count += num&1;\\n            num >>=1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329320,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> bits;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            bits.push_back(__builtin_popcount(nums[i]));\\n        }\\n        sort(bits.begin(), bits.end());\\n        long long ans = 0, m = bits.size();\\n        for (auto& b : bits)\\n            ans += (m - (lower_bound(bits.begin(), bits.end(), k - b) - bits.begin()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> bits;\\n        sort(nums.begin(), nums.end());\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i > 0 && nums[i] == nums[i - 1])\\n                continue;\\n            bits.push_back(__builtin_popcount(nums[i]));\\n        }\\n        sort(bits.begin(), bits.end());\\n        long long ans = 0, m = bits.size();\\n        for (auto& b : bits)\\n            ans += (m - (lower_bound(bits.begin(), bits.end(), k - b) - bits.begin()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328995,
                "title": "java-solution-using-bitmanipulation-and-hashing",
                "content": "```java\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int num : nums) {\\n            int setBitCnt = setBitCount(num);\\n            if(!map.containsKey(setBitCnt)) {\\n                map.put(setBitCnt, new HashSet<>());\\n            }\\n            map.get(setBitCnt).add(num);\\n        }\\n        long ans = 0;\\n        Set<Integer> vis = new HashSet<>();\\n        for(int num : nums) {\\n            if(vis.contains(num)) {\\n                continue;\\n            }\\n            int reqd = Math.max(0, k - setBitCount(num));\\n            for(int key : map.keySet()) {\\n                if(key >= reqd) {\\n                    ans += (long) map.get(key).size();\\n                }\\n            }\\n            vis.add(num);\\n        }\\n        return ans;\\n    }\\n    public int setBitCount(int num) {\\n        int cnt = 0;\\n        while(num != 0) {\\n            if((1 & num) == 1) {\\n                cnt++;\\n            }\\n            num = num >> 1;\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int num : nums) {\\n            int setBitCnt = setBitCount(num);\\n            if(!map.containsKey(setBitCnt)) {\\n                map.put(setBitCnt, new HashSet<>());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2328944,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long result = 0;\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i <= 32; i++) {\\n            map.put(i, new HashSet<Integer>());\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            int copyNum = num;\\n            int numberOfBits = 0;\\n            while (num > 0) {\\n                if (num % 2 != 0) {\\n                    numberOfBits++;\\n                }\\n                num = num / 2;\\n            }\\n            if (map.containsKey(numberOfBits)) {\\n                Set<Integer> set = map.get(numberOfBits);\\n                set.add(copyNum);\\n                map.put(numberOfBits, set);                \\n            } else {\\n                Set<Integer> set = new HashSet<>();\\n                set.add(copyNum);\\n                map.put(numberOfBits, set);\\n            }\\n        }\\n        for (int i = 0; i <= 32; i++) {\\n            for (int j = 0; j <= 32; j++) {\\n                if (i + j < k) {\\n                    continue;\\n                }\\n                result = result + map.get(i).size() * map.get(j).size();\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long countExcellentPairs(int[] nums, int k) {\\n        long result = 0;\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i <= 32; i++) {\\n            map.put(i, new HashSet<Integer>());\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            int copyNum = num;\\n            int numberOfBits = 0;\\n            while (num > 0) {\\n                if (num % 2 != 0) {\\n                    numberOfBits++;\\n                }\\n                num = num / 2;\\n            }\\n            if (map.containsKey(numberOfBits)) {\\n                Set<Integer> set = map.get(numberOfBits);\\n                set.add(copyNum);\\n                map.put(numberOfBits, set);                \\n            } else {\\n                Set<Integer> set = new HashSet<>();\\n                set.add(copyNum);\\n                map.put(numberOfBits, set);\\n            }\\n        }\\n        for (int i = 0; i <= 32; i++) {\\n            for (int j = 0; j <= 32; j++) {\\n                if (i + j < k) {\\n                    continue;\\n                }\\n                result = result + map.get(i).size() * map.get(j).size();\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328888,
                "title": "optimized-c-deduplicate-and-hash-bit-counts-with-optimizations",
                "content": "After trying a few ways to do this, this appears the fastest in practice:\\n```\\nlong long countExcellentPairs(vector<int>& v, int k) {\\n\\tlong long ans=0;\\n\\tvector<int> cnt(30,0);\\n\\tsort(v.begin(),v.end());   // for removing duplicates; seems faster than via set\\n\\tcnt[__builtin_popcount(v[0])]=1; \\n\\tfor (int i=1; i<v.size(); i++)\\n\\t\\tif (v[i]!=v[i-1])\\n\\t\\t\\tcnt[__builtin_popcount(v[i])]++;        \\n\\tfor (int i=max(k-31,1); i<30; ++i)\\n\\t  if (cnt[i]>0)\\n\\t\\tfor (int j=max(k-i,1); j<30; j++) \\n\\t\\t   ans+= cnt[i]*cnt[j];       \\n\\treturn ans;    \\n}\\n",
                "solutionTags": [],
                "code": "After trying a few ways to do this, this appears the fastest in practice:\\n```\\nlong long countExcellentPairs(vector<int>& v, int k) {\\n\\tlong long ans=0;\\n\\tvector<int> cnt(30,0);\\n\\tsort(v.begin(),v.end());   // for removing duplicates; seems faster than via set\\n\\tcnt[__builtin_popcount(v[0])]=1; \\n\\tfor (int i=1; i<v.size(); i++)\\n\\t\\tif (v[i]!=v[i-1])\\n\\t\\t\\tcnt[__builtin_popcount(v[i])]++;        \\n\\tfor (int i=max(k-31,1); i<30; ++i)\\n\\t  if (cnt[i]>0)\\n\\t\\tfor (int j=max(k-i,1); j<30; j++) \\n\\t\\t   ans+= cnt[i]*cnt[j];       \\n\\treturn ans;    \\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2328637,
                "title": "2-sum-two-pointers-o-n",
                "content": "There is a pattern: bit AND + bit OR = all the bits in 2 nums.\\n\\nSteps:\\n1. dedupe\\n2. count bit for each number, save bit count to an array\\n3. sort bit count array\\n4. use two pointers from both ends to center. similar to number of pairs bigger than target.\\n\\n```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        xs = set(nums)\\n        bs = []\\n        for v in xs:\\n            cnt = 0\\n            for i in range(32):\\n                if (v >> i) & 1 == 1:\\n                    cnt += 1\\n            bs.append(cnt)\\n        ans = 0\\n        bs.sort()\\n        # print(f\"bs {bs}\")\\n        n = len(bs)\\n        l, r = 0, n - 1\\n        \\n        \\n        while l <= r:\\n            if bs[l] + bs[r] >= k:\\n                ans += (r-l) * 2 + 1\\n                r -= 1\\n            else:\\n                l += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countExcellentPairs(self, nums: List[int], k: int) -> int:\\n        xs = set(nums)\\n        bs = []\\n        for v in xs:\\n            cnt = 0\\n            for i in range(32):\\n                if (v >> i) & 1 == 1:\\n                    cnt += 1\\n            bs.append(cnt)\\n        ans = 0\\n        bs.sort()\\n        # print(f\"bs {bs}\")\\n        n = len(bs)\\n        l, r = 0, n - 1\\n        \\n        \\n        while l <= r:\\n            if bs[l] + bs[r] >= k:\\n                ans += (r-l) * 2 + 1\\n                r -= 1\\n            else:\\n                l += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328579,
                "title": "linear-time-complexity-with-three-pass-c",
                "content": "The time complexity almost comes to O(N) (linear) and am using an array of size 32 (constant size). The approach is as follows:\\n1) Remove duplicate numbers from the \"nums\" array and convert it to number of set bits. Using the set bits, increment its frequency in the \"freq\" array.\\n2) Create another \"prefix\" array based on the \"freq\" array that was initialized in step 1.\\n3) Traverse the \"freq\" array for the number of set bits and find the remaining bits required per \"k\". Using remaining bits position and current position, add the number of excellent pairs.\\n\\n```cpp\\nclass Solution {\\n    int countSetBits(int n)\\n    {\\n        int ans = 0;\\n        while(n)\\n        {\\n            ans += 1;\\n            n &= (n-1);\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int> uset;\\n        \\n        vector<int> freq(32, 0);\\n        \\n        for(int num : nums)\\n        {\\n            if (!uset.count(num))\\n            { \\n                freq[countSetBits(num)]++;\\n                uset.insert(num);\\n            }\\n        }\\n        \\n        vector<long long> prefix(33, 0);\\n        for(int i = 0; i < 32; i++) prefix[i+1] = prefix[i] + freq[i];\\n        \\n        long long ans = 0;\\n        for(int i = 0; i < 32; i++)\\n        {\\n            if (freq[i] > 0)\\n            {\\n                long long remain = max(0, k - i);\\n                if (remain <= 32) ans += (prefix[32]-prefix[remain]) * freq[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};  \\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    int countSetBits(int n)\\n    {\\n        int ans = 0;\\n        while(n)\\n        {\\n            ans += 1;\\n            n &= (n-1);\\n        }\\n        return ans;\\n    }\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        unordered_set<int> uset;\\n        \\n        vector<int> freq(32, 0);\\n        \\n        for(int num : nums)\\n        {\\n            if (!uset.count(num))\\n            { \\n                freq[countSetBits(num)]++;\\n                uset.insert(num);\\n            }\\n        }\\n        \\n        vector<long long> prefix(33, 0);\\n        for(int i = 0; i < 32; i++) prefix[i+1] = prefix[i] + freq[i];\\n        \\n        long long ans = 0;\\n        for(int i = 0; i < 32; i++)\\n        {\\n            if (freq[i] > 0)\\n            {\\n                long long remain = max(0, k - i);\\n                if (remain <= 32) ans += (prefix[32]-prefix[remain]) * freq[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328567,
                "title": "c-bit-manipulations-math",
                "content": "Runtime: 496 ms, faster than 50.00% of C++ online submissions for Number of Excellent Pairs.\\nMemory Usage: 95.3 MB, less than 50.00% of C++ online submissions for Number of Excellent Pairs.\\n```\\nclass Solution {\\npublic:\\n  inline int CountOnes5 (unsigned int n ) {\\n    n -= (n>>1) & 0x55555555;\\n    n = ((n>>2) & 0x33333333 ) + (n & 0x33333333);\\n    n = ((((n>>4) + n) & 0x0F0F0F0F) * 0x01010101) >> 24;\\n    return n;\\n  } \\n  \\n  vector<int> table; \\n  \\n  void fill_table(vector<int>& nums){\\n    unordered_set<int> st;\\n    for(int n: nums)\\n      if(!st.count(n))\\n        st.insert(n), table[CountOnes5(n)]++;\\n  }\\n  \\n  long long countExcellentPairs(vector<int>& nums, int k) {\\n    if(k > 58) return 0;\\n    table.resize(30, 0);\\n    fill_table(nums);\\n    \\n    while(table.back() == 0) table.pop_back();\\n    if(table.size()*2 < k) return 0;\\n    \\n    vector<int> sum = table;\\n    sum.resize(max(31,k+1),0);\\n    for(int i = sum.size() - 2; i; i--) sum[i] += sum[i+1]; \\n    \\n    long ans = 0, dop = 0;\\n    int i = 1, j = k-1, lim = (k+1)>>1;\\n    \\n    for(; i != lim; i++, j--) ans += (long)table[i] * sum[j];  \\n    \\n    for(; i != 30; i++) \\n      if(table[i]) dop += (long)table[i] * table[i], ans += (long)table[i] * sum[i+1]; \\n  \\n    return dop + (ans<<1);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  inline int CountOnes5 (unsigned int n ) {\\n    n -= (n>>1) & 0x55555555;\\n    n = ((n>>2) & 0x33333333 ) + (n & 0x33333333);\\n    n = ((((n>>4) + n) & 0x0F0F0F0F) * 0x01010101) >> 24;\\n    return n;\\n  } \\n  \\n  vector<int> table; \\n  \\n  void fill_table(vector<int>& nums){\\n    unordered_set<int> st;\\n    for(int n: nums)\\n      if(!st.count(n))\\n        st.insert(n), table[CountOnes5(n)]++;\\n  }\\n  \\n  long long countExcellentPairs(vector<int>& nums, int k) {\\n    if(k > 58) return 0;\\n    table.resize(30, 0);\\n    fill_table(nums);\\n    \\n    while(table.back() == 0) table.pop_back();\\n    if(table.size()*2 < k) return 0;\\n    \\n    vector<int> sum = table;\\n    sum.resize(max(31,k+1),0);\\n    for(int i = sum.size() - 2; i; i--) sum[i] += sum[i+1]; \\n    \\n    long ans = 0, dop = 0;\\n    int i = 1, j = k-1, lim = (k+1)>>1;\\n    \\n    for(; i != lim; i++, j--) ans += (long)table[i] * sum[j];  \\n    \\n    for(; i != 30; i++) \\n      if(table[i]) dop += (long)table[i] * table[i], ans += (long)table[i] * sum[i+1]; \\n  \\n    return dop + (ans<<1);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328562,
                "title": "linear-time-solution-using-count-of-set-bits",
                "content": "Main trick for this problem is to realize that total number of set bits for (x & y) + (x | y) = sum of total number of bits set in x and y. x & y will have bits set only for those which are set in both x and y and x | y will set all bits which are either set in x or y. So, bits set in both x and y will also appear twice in the sum, once for x&y and once for x | y and bits set in either x or y will appear only in x | y. So total sum will be equal to set bits in x + set bits in y.\\nAfter this realization, we need to calculate number of set bits for each element in num and generate an array where arr[i] = number of elements in num which has \"i\" set bits. Note that we need to avoid duplicate values in input num array to ensure our count does not include duplicate pairs. Then we also calculate suffix sum array from this arr where sarr[i] = number of elements in num which has >= \"i\" set bits. Then result will be sum of (arr[i] * sarr[k-i]) for all values of i (0 <= i <= 31 for int).\\n\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> sumBits(32, 0);\\n        unordered_set<int> present;\\n        \\n        for(auto n:nums){\\n            if(present.find(n) == present.end()){\\n                present.insert(n);\\n                int sum = 0;\\n                while(n != 0){\\n                    n &= (n-1);\\n                    sum++;\\n                }\\n                sumBits[sum]++;\\n            }\\n        }\\n        vector<int> pSum(32, 0);\\n        pSum[31] = sumBits[31];\\n        for(int i = 30; i >= 0; i--){\\n            pSum[i] = sumBits[i] + pSum[i+1];\\n        }\\n        \\n        long long count = 0;\\n        for(int i = 0; i < 32; i++){\\n            int j = k-i > 0 ? k-i : 0;\\n            int s = j < 32 ? pSum[j] : 0;\\n            count += ((long long)sumBits[i]*s);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        vector<int> sumBits(32, 0);\\n        unordered_set<int> present;\\n        \\n        for(auto n:nums){\\n            if(present.find(n) == present.end()){\\n                present.insert(n);\\n                int sum = 0;\\n                while(n != 0){\\n                    n &= (n-1);\\n                    sum++;\\n                }\\n                sumBits[sum]++;\\n            }\\n        }\\n        vector<int> pSum(32, 0);\\n        pSum[31] = sumBits[31];\\n        for(int i = 30; i >= 0; i--){\\n            pSum[i] = sumBits[i] + pSum[i+1];\\n        }\\n        \\n        long long count = 0;\\n        for(int i = 0; i < 32; i++){\\n            int j = k-i > 0 ? k-i : 0;\\n            int s = j < 32 ? pSum[j] : 0;\\n            count += ((long long)sumBits[i]*s);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328537,
                "title": "faster-than-100-simple-java-o-n-time-and-o-32-space-solution-use-counting-sort",
                "content": "```\\nclass Solution {\\n\\tpublic long countExcellentPairs(int[] nums, int k) {\\n\\t\\tint bitCount[] = new int[33];\\n\\t\\tlong count = 0;\\n\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\tfor (int i: nums) {\\n\\t\\t\\tif (set.add(i)) {\\n\\t\\t\\t\\tint bits = Integer.bitCount(i);\\n\\t\\t\\t\\tbitCount[bits]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i<= 32; ++i) {\\n\\t\\t\\tfor (int j = 1; j<= 32; ++j) {\\n\\t\\t\\t\\tif (i + j >= k) {\\n\\t\\t\\t\\t\\tcount += bitCount[i] * bitCount[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long countExcellentPairs(int[] nums, int k) {\\n\\t\\tint bitCount[] = new int[33];\\n\\t\\tlong count = 0;\\n\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\tfor (int i: nums) {\\n\\t\\t\\tif (set.add(i)) {\\n\\t\\t\\t\\tint bits = Integer.bitCount(i);\\n\\t\\t\\t\\tbitCount[bits]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i<= 32; ++i) {\\n\\t\\t\\tfor (int j = 1; j<= 32; ++j) {\\n\\t\\t\\t\\tif (i + j >= k) {\\n\\t\\t\\t\\t\\tcount += bitCount[i] * bitCount[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328181,
                "title": "go-inclusion-exclusion-principle",
                "content": "transform from @lee215\\n```\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n    m := make(map[int]bool)\\n    for _, num := range nums {\\n        m[num] = true\\n    }\\n    res := 0\\n    count := make(map[int]int)\\n    for key := range m {\\n        count[bit_count(key)]++\\n    }\\n    for i := 0; i < 30; i++ {\\n        for j := 0; j < 30; j++ {\\n            if i+j >= k {\\n                res += count[i]*count[j]\\n            } \\n        }\\n    }\\n    return int64(res)\\n}\\n\\nfunc bit_count(a int) int {\\n    res := 0\\n    for a > 0 {\\n        res++\\n        a = a&(a-1)\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc countExcellentPairs(nums []int, k int) int64 {\\n    m := make(map[int]bool)\\n    for _, num := range nums {\\n        m[num] = true\\n    }\\n    res := 0\\n    count := make(map[int]int)\\n    for key := range m {\\n        count[bit_count(key)]++\\n    }\\n    for i := 0; i < 30; i++ {\\n        for j := 0; j < 30; j++ {\\n            if i+j >= k {\\n                res += count[i]*count[j]\\n            } \\n        }\\n    }\\n    return int64(res)\\n}\\n\\nfunc bit_count(a int) int {\\n    res := 0\\n    for a > 0 {\\n        res++\\n        a = a&(a-1)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2327813,
                "title": "python-straightforward-dictionary-solution",
                "content": "since the data range is less than 10^9, so the most possible number of 1 is 30, since 2^30>1e9. so we can create a cnt array (or dictionary) with size 30. cnt[i] means number of val which have i 1s.\\nThen we just need to loop possible combination of cnt array, to see if i+j>=k, if yes, just multiply two counts and add it to the result. \\nOne thing that should be noted is dont forget to remove duplicate in the beginning. \\n\\nPlease upvote if you find it helpful XD\\n```\\n\\'\\'\\'\\nclass Solution(object):\\n    def countExcellentPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        nums = list(set(nums))\\n        \\n        cnt = [0]*30\\n        for x in nums:\\n            s = 0\\n            while x:\\n                s += x&1\\n                x  = x >> 1\\n            cnt[s] += 1\\n        \\n        res = 0\\n        for i in range(30):\\n            for j in range(30):\\n                if i+j>=k:\\n                    res += cnt[i]*cnt[j]\\n                \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\'\\'\\'\\nclass Solution(object):\\n    def countExcellentPairs(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        nums = list(set(nums))\\n        \\n        cnt = [0]*30\\n        for x in nums:\\n            s = 0\\n            while x:\\n                s += x&1\\n                x  = x >> 1\\n            cnt[s] += 1\\n        \\n        res = 0\\n        for i in range(30):\\n            for j in range(30):\\n                if i+j>=k:\\n                    res += cnt[i]*cnt[j]\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327808,
                "title": "leetcode-the-hard-way-but-manupulation-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\nFor num1 OR num2, it is equal to the number of set bits of num1. \\n\\nFor num1 AND num2, it is equal to the number of set bits of num2. \\n\\nTherefore, the sum of the number of set bits in (num1 OR num2) and (num1 AND num2) is equal to the sum of the number of set bits in num1 and num2. \\n\\nWe can iterate each number and count the frequency of the set bits `m[bits]`. Then we can try all combinations to check if the sum of the number of set bits in num1 and num2 is greater than or equal to `k`. If so, the number of pairs would be `m[i] * m[j]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        // remove duplicate numbers\\n        set<int> s(nums.begin(), nums.end());\\n        nums.assign(s.begin(), s.end());\\n        // hash map to store the frequency of a given set bit count\\n        unordered_map<int, int> m;\\n        // iterate each number to calculate the set bits\\n        for (auto& x : nums) {\\n            // count each set bit\\n            int cnt = 0;\\n            for (int i = 0 ; i < 32; i++) {\\n                if ((1 << i) & x) {\\n                    cnt += 1;\\n                }\\n            }\\n            m[cnt] += 1;\\n            // alternative, we can use __builtin_popcount\\n            // i.e. m[__builtin_popcount(x)]++;\\n        }\\n        // try all possible pairs\\n        for (int i = 0; i < 32; i++) {\\n            for (int j = 0; j < 32; j++) {\\n                if (i + j >= k) {\\n                    // if second condition is satisfied, \\n                    // then the number of pairs would be m[i] * m[j]\\n                    ans += m[i] * m[j] * 1LL;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n        long long ans = 0;\\n        // remove duplicate numbers\\n        set<int> s(nums.begin(), nums.end());\\n        nums.assign(s.begin(), s.end());\\n        // hash map to store the frequency of a given set bit count\\n        unordered_map<int, int> m;\\n        // iterate each number to calculate the set bits\\n        for (auto& x : nums) {\\n            // count each set bit\\n            int cnt = 0;\\n            for (int i = 0 ; i < 32; i++) {\\n                if ((1 << i) & x) {\\n                    cnt += 1;\\n                }\\n            }\\n            m[cnt] += 1;\\n            // alternative, we can use __builtin_popcount\\n            // i.e. m[__builtin_popcount(x)]++;\\n        }\\n        // try all possible pairs\\n        for (int i = 0; i < 32; i++) {\\n            for (int j = 0; j < 32; j++) {\\n                if (i + j >= k) {\\n                    // if second condition is satisfied, \\n                    // then the number of pairs would be m[i] * m[j]\\n                    ans += m[i] * m[j] * 1LL;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327788,
                "title": "java-annoying-problem",
                "content": "This problem is totally observation based.\\n\\n```\\nclass Solution {\\n    \\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num : nums){\\n            set.add(num);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        long ans = 0;\\n        for(int num : set){\\n            if( bitCount(num|num) + bitCount(num&num) >=k){\\n                //System.out.println(num+\" \");\\n                ans++;\\n            }\\n            list.add(bitCount(num));\\n        }\\n        Collections.sort(list);\\n        //System.out.println(list);\\n        TreeMap<Long,Long> map = new TreeMap<>();\\n        for(int i = 0;i<list.size();i++){\\n            if(list.get(i)>=k){\\n                //System.out.println(\"Here\");\\n                ans+=(2*(i));\\n            }else{\\n                Long first = map.ceilingKey(k-(long)list.get(i));\\n                //System.out.println(\"First \"+first);\\n                if(first!=null){\\n                    Long idx = map.get(first);\\n                    long total  = (i-idx);\\n                    //System.out.println(total);\\n                    ans+=(2*total);\\n                }\\n            }\\n            if(!map.containsKey((long)list.get(i))){\\n                map.put((long)list.get(i),(long)i);\\n            }\\n            \\n        }\\n        //System.out.println(map);\\n        return ans;\\n    }\\n    int bitCount(int num){\\n        int count = 0;\\n        for(int i = 0;i<32;i++){\\n            if( (num&(1<<i))>0 ){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public long countExcellentPairs(int[] nums, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int num : nums){\\n            set.add(num);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        long ans = 0;\\n        for(int num : set){\\n            if( bitCount(num|num) + bitCount(num&num) >=k){\\n                //System.out.println(num+\" \");\\n                ans++;\\n            }\\n            list.add(bitCount(num));\\n        }\\n        Collections.sort(list);\\n        //System.out.println(list);\\n        TreeMap<Long,Long> map = new TreeMap<>();\\n        for(int i = 0;i<list.size();i++){\\n            if(list.get(i)>=k){\\n                //System.out.println(\"Here\");\\n                ans+=(2*(i));\\n            }else{\\n                Long first = map.ceilingKey(k-(long)list.get(i));\\n                //System.out.println(\"First \"+first);\\n                if(first!=null){\\n                    Long idx = map.get(first);\\n                    long total  = (i-idx);\\n                    //System.out.println(total);\\n                    ans+=(2*total);\\n                }\\n            }\\n            if(!map.containsKey((long)list.get(i))){\\n                map.put((long)list.get(i),(long)i);\\n            }\\n            \\n        }\\n        //System.out.println(map);\\n        return ans;\\n    }\\n    int bitCount(int num){\\n        int count = 0;\\n        for(int i = 0;i<32;i++){\\n            if( (num&(1<<i))>0 ){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327751,
                "title": "c-binary-search",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) \\n    {\\n        set<int>Set;\\n        for(auto &x:nums)Set.insert(x);\\n        nums.clear();\\n        for(auto &x:Set)nums.push_back(x);\\n        int n=nums.size();\\n        vector<int>cnt(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int cur=0;\\n            for(int j=0;j<=30;j++)cur+=((nums[i]>>j)&1);\\n            cnt[i]=cur;\\n        }\\n        sort(cnt.begin(),cnt.end());\\n        ll ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int target=k-cnt[i];\\n            auto it=lower_bound(cnt.begin(),cnt.end(),target);\\n            if(it==cnt.end())continue;\\n            int idx=it-cnt.begin();\\n            ans+=n-idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) \\n    {\\n        set<int>Set;\\n        for(auto &x:nums)Set.insert(x);\\n        nums.clear();\\n        for(auto &x:Set)nums.push_back(x);\\n        int n=nums.size();\\n        vector<int>cnt(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int cur=0;\\n            for(int j=0;j<=30;j++)cur+=((nums[i]>>j)&1);\\n            cnt[i]=cur;\\n        }\\n        sort(cnt.begin(),cnt.end());\\n        ll ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int target=k-cnt[i];\\n            auto it=lower_bound(cnt.begin(),cnt.end(),target);\\n            if(it==cnt.end())continue;\\n            int idx=it-cnt.begin();\\n            ans+=n-idx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327681,
                "title": "c-counting-sort-similar-to-finding-the-pairs-with-sum-k",
                "content": "TC: O(32 * N)  = O(N) considering that `__builtin_popcount(x)` can at-most take 32 steps which is also a constant.\\nSC: O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& a, int k) {\\n        /*\\n            Create a venn diagram for x1 OR x2 and x1 AND x2.\\n            The sum of count of digits in the above two values is basically the sum of digits of two no.s\\n            \\n            So, we can count the bits in each no.f and store them in a map. the map can have a size of at max\\n            32 because there can be at max 32 bits in an integer. We can put the pairs in an unrodered_set\\n            to count the distinct ones and and count pairs like (x1, x1) separately\\n        */\\n        \\n        unordered_set<int> s(begin(a), end(a));\\n        int bitCtr[32] = {0};\\n        \\n        long long count = 0;\\n        for(int i: s) {\\n            // So, lets say ith element had p bits in it. We need to find p + q >= k, so q >= k - p\\n            // and all such existing ones\\n            \\n            int p = __builtin_popcount(i);\\n            \\n            if (p + p >= k)\\n                count++;\\n            \\n            for(int j = max(k-p, 0); j < 32; j++) {\\n                if (j + p >= k)\\n                    count += 2LL * bitCtr[j];\\n            }\\n            \\n            bitCtr[p]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& a, int k) {\\n        /*\\n            Create a venn diagram for x1 OR x2 and x1 AND x2.\\n            The sum of count of digits in the above two values is basically the sum of digits of two no.s\\n            \\n            So, we can count the bits in each no.f and store them in a map. the map can have a size of at max\\n            32 because there can be at max 32 bits in an integer. We can put the pairs in an unrodered_set\\n            to count the distinct ones and and count pairs like (x1, x1) separately\\n        */\\n        \\n        unordered_set<int> s(begin(a), end(a));\\n        int bitCtr[32] = {0};\\n        \\n        long long count = 0;\\n        for(int i: s) {\\n            // So, lets say ith element had p bits in it. We need to find p + q >= k, so q >= k - p\\n            // and all such existing ones\\n            \\n            int p = __builtin_popcount(i);\\n            \\n            if (p + p >= k)\\n                count++;\\n            \\n            for(int j = max(k-p, 0); j < 32; j++) {\\n                if (j + p >= k)\\n                    count += 2LL * bitCtr[j];\\n            }\\n            \\n            bitCtr[p]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327626,
                "title": "c-100-100",
                "content": "The key to this solution is the formula:  popcount(**a** & **b**) + popcount(**a** | **b**) == popcount(**a**) + popcount(**b**). The following is the proof.\\n\\nFirst, we know that for every bit position, there are only 4 possibilities between two numbers **a** and **b**: 00, 01, 10, 11. \\n\\n**a=0, b=0:** popcount(0) + popcount(0) == popcount(0) + popcount(0)\\n**a=0, b=1:** popcount(0) + popcount(1) == popcount(0) + popcount(1)\\n**a=1, b=0:** popcount(0) + popcount(1) == popcount(1) + popcount(0)\\n**a=0, b=1:** popcount(1) + popcount(1) == popcount(1) + popcount(1)\\n\\nThe formula holds true for all 4 combinations, and thus will be true for all numbers.\\n\\n```\\n#include <algorithm>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n\\n        // first, using our formula, we don\\'t actually care about the numbers in `nums`, just their popcounts.\\n        // We also don\\'t want duplicates, so we use unique() from <algorithm>\\n        sort(nums.begin(), nums.end());\\n        auto end = unique(nums.begin(), nums.end());\\n        vector<long long> popcounts(32); // this supports popcounts from [0,31]. We can\\'t have 32, as nums is a vector of ints, which would be signed integers.\\n        for (auto i = nums.begin(); i != end; ++i) {\\n            ++popcounts[__builtin_popcount(*i)];\\n        }\\n\\n        // next, we must find all excellent pairs.\\n        long long result = 0;\\n        for (int i = 0; i < popcounts.size(); ++i) {\\n            if (!popcounts[i]) continue; \\n            for (int j = i; j < popcounts.size(); ++j) {\\n\\n                // we found excellent pairs, as `i` and `j` represent the popcounts. There are different formulas for if i and j are the same. This is because in those cases,\\n                // we must consider the fact that a number can be a pair with itself only once, but two numbers can make 2 different pairs together (num1,num2) and (num2,num1).\\n                if (i + j >= k) {\\n                    if (i == j) {\\n                        result += popcounts[i] * popcounts[j];\\n                    } else {\\n                        result += 2 * popcounts[i] * popcounts[j];\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long countExcellentPairs(vector<int>& nums, int k) {\\n\\n        // first, using our formula, we don\\'t actually care about the numbers in `nums`, just their popcounts.\\n        // We also don\\'t want duplicates, so we use unique() from <algorithm>\\n        sort(nums.begin(), nums.end());\\n        auto end = unique(nums.begin(), nums.end());\\n        vector<long long> popcounts(32); // this supports popcounts from [0,31]. We can\\'t have 32, as nums is a vector of ints, which would be signed integers.\\n        for (auto i = nums.begin(); i != end; ++i) {\\n            ++popcounts[__builtin_popcount(*i)];\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1926378,
                "content": [
                    {
                        "username": "krishnakanna18",
                        "content": "Try to convert the condition give here sum(a|b, a&b) to the condition given in this problem -> https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/ "
                    }
                ]
            }
        ]
    }
]